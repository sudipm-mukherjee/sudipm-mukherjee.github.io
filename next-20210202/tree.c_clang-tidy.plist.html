<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/kernel/rcu/tree.c", "content": "// SPDX-License-Identifier: GPL-2.0+\n/*\n * Read-Copy Update mechanism for mutual exclusion (tree-based version)\n *\n * Copyright IBM Corporation, 2008\n *\n * Authors: Dipankar Sarma <dipankar@in.ibm.com>\n *\t    Manfred Spraul <manfred@colorfullife.com>\n *\t    Paul E. McKenney <paulmck@linux.ibm.com>\n *\n * Based on the original work by Paul McKenney <paulmck@linux.ibm.com>\n * and inputs from Rusty Russell, Andrea Arcangeli and Andi Kleen.\n *\n * For detailed explanation of Read-Copy Update mechanism see -\n *\tDocumentation/RCU\n */\n\n#define pr_fmt(fmt) \"rcu: \" fmt\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/smp.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/bitops.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n#include <linux/moduleparam.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/kernel_stat.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/prefetch.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/trace_events.h>\n#include <linux/suspend.h>\n#include <linux/ftrace.h>\n#include <linux/tick.h>\n#include <linux/sysrq.h>\n#include <linux/kprobes.h>\n#include <linux/gfp.h>\n#include <linux/oom.h>\n#include <linux/smpboot.h>\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/clock.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/kasan.h>\n#include \"../time/tick-internal.h\"\n\n#include \"tree.h\"\n#include \"rcu.h\"\n\n#ifdef MODULE_PARAM_PREFIX\n#undef MODULE_PARAM_PREFIX\n#endif\n#define MODULE_PARAM_PREFIX \"rcutree.\"\n\n/* Data structures. */\n\n/*\n * Steal a bit from the bottom of ->dynticks for idle entry/exit\n * control.  Initially this is for TLB flushing.\n */\n#define RCU_DYNTICK_CTRL_MASK 0x1\n#define RCU_DYNTICK_CTRL_CTR  (RCU_DYNTICK_CTRL_MASK + 1)\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n#ifdef CONFIG_RCU_NOCB_CPU\n\t.cblist.flags = SEGCBLIST_SOFTIRQ_ONLY,\n#endif\n};\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\n/* Dump rcu_node combining tree at boot to verify correct setup. */\nstatic bool dump_tree;\nmodule_param(dump_tree, bool, 0444);\n/* By default, use RCU_SOFTIRQ instead of rcuc kthreads. */\nstatic bool use_softirq = !IS_ENABLED(CONFIG_PREEMPT_RT);\n#ifndef CONFIG_PREEMPT_RT\nmodule_param(use_softirq, bool, 0444);\n#endif\n/* Control rcu_node-tree auto-balancing at boot time. */\nstatic bool rcu_fanout_exact;\nmodule_param(rcu_fanout_exact, bool, 0444);\n/* Increase (but not decrease) the RCU_FANOUT_LEAF at boot time. */\nstatic int rcu_fanout_leaf = RCU_FANOUT_LEAF;\nmodule_param(rcu_fanout_leaf, int, 0444);\nint rcu_num_lvls __read_mostly = RCU_NUM_LVLS;\n/* Number of rcu_nodes at specified level. */\nint num_rcu_lvl[] = NUM_RCU_LVL_INIT;\nint rcu_num_nodes __read_mostly = NUM_RCU_NODES; /* Total # rcu_nodes in use. */\n\n/*\n * The rcu_scheduler_active variable is initialized to the value\n * RCU_SCHEDULER_INACTIVE and transitions RCU_SCHEDULER_INIT just before the\n * first task is spawned.  So when this variable is RCU_SCHEDULER_INACTIVE,\n * RCU can assume that there is but one task, allowing RCU to (for example)\n * optimize synchronize_rcu() to a simple barrier().  When this variable\n * is RCU_SCHEDULER_INIT, RCU must actually do all the hard work required\n * to detect real grace periods.  This variable is also used to suppress\n * boot-time false positives from lockdep-RCU error checking.  Finally, it\n * transitions from RCU_SCHEDULER_INIT to RCU_SCHEDULER_RUNNING after RCU\n * is fully initialized, including all of its kthreads having been spawned.\n */\nint rcu_scheduler_active __read_mostly;\nEXPORT_SYMBOL_GPL(rcu_scheduler_active);\n\n/*\n * The rcu_scheduler_fully_active variable transitions from zero to one\n * during the early_initcall() processing, which is after the scheduler\n * is capable of creating new tasks.  So RCU processing (for example,\n * creating tasks for RCU priority boosting) must be delayed until after\n * rcu_scheduler_fully_active transitions from zero to one.  We also\n * currently delay invocation of any RCU callbacks until after this point.\n *\n * It might later prove better for people registering RCU callbacks during\n * early boot to take responsibility for these callbacks, but one step at\n * a time.\n */\nstatic int rcu_scheduler_fully_active __read_mostly;\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\nstatic void rcu_init_new_rnp(struct rcu_node *rnp_leaf);\nstatic void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf);\nstatic void rcu_boost_kthread_setaffinity(struct rcu_node *rnp, int outgoingcpu);\nstatic void invoke_rcu_core(void);\nstatic void rcu_report_exp_rdp(struct rcu_data *rdp);\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp);\nstatic bool rcu_rdp_is_offloaded(struct rcu_data *rdp);\n\n/* rcuc/rcub kthread realtime priority */\nstatic int kthread_prio = IS_ENABLED(CONFIG_RCU_BOOST) ? 1 : 0;\nmodule_param(kthread_prio, int, 0444);\n\n/* Delay in jiffies for grace-period initialization delays, debug only. */\n\nstatic int gp_preinit_delay;\nmodule_param(gp_preinit_delay, int, 0444);\nstatic int gp_init_delay;\nmodule_param(gp_init_delay, int, 0444);\nstatic int gp_cleanup_delay;\nmodule_param(gp_cleanup_delay, int, 0444);\n\n// Add delay to rcu_read_unlock() for strict grace periods.\nstatic int rcu_unlock_delay;\n#ifdef CONFIG_RCU_STRICT_GRACE_PERIOD\nmodule_param(rcu_unlock_delay, int, 0444);\n#endif\n\n/*\n * This rcu parameter is runtime-read-only. It reflects\n * a minimum allowed number of objects which can be cached\n * per-CPU. Object size is equal to one page. This value\n * can be changed at boot time.\n */\nstatic int rcu_min_cached_objs = 5;\nmodule_param(rcu_min_cached_objs, int, 0444);\n\n/* Retrieve RCU kthreads priority for rcutorture */\nint rcu_get_gp_kthreads_prio(void)\n{\n\treturn kthread_prio;\n}\nEXPORT_SYMBOL_GPL(rcu_get_gp_kthreads_prio);\n\n/*\n * Number of grace periods between delays, normalized by the duration of\n * the delay.  The longer the delay, the more the grace periods between\n * each delay.  The reason for this normalization is that it means that,\n * for non-zero delays, the overall slowdown of grace periods is constant\n * regardless of the duration of the delay.  This arrangement balances\n * the need for long delays to increase some race probabilities with the\n * need for fast grace periods to increase other race probabilities.\n */\n#define PER_RCU_NODE_PERIOD 3\t/* Number of grace periods between delays. */\n\n/*\n * Compute the mask of online CPUs for the specified rcu_node structure.\n * This will not be stable unless the rcu_node structure's ->lock is\n * held, but the bit corresponding to the current CPU will be stable\n * in most contexts.\n */\nstatic unsigned long rcu_rnp_online_cpus(struct rcu_node *rnp)\n{\n\treturn READ_ONCE(rnp->qsmaskinitnext);\n}\n\n/*\n * Return true if an RCU grace period is in progress.  The READ_ONCE()s\n * permit this function to be invoked without holding the root rcu_node\n * structure's ->lock, but of course results can be subject to change.\n */\nstatic int rcu_gp_in_progress(void)\n{\n\treturn rcu_seq_state(rcu_seq_current(&rcu_state.gp_seq));\n}\n\n/*\n * Return the number of callbacks queued on the specified CPU.\n * Handles both the nocbs and normal cases.\n */\nstatic long rcu_get_n_cbs_cpu(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\tif (rcu_segcblist_is_enabled(&rdp->cblist))\n\t\treturn rcu_segcblist_n_cbs(&rdp->cblist);\n\treturn 0;\n}\n\nvoid rcu_softirq_qs(void)\n{\n\trcu_qs();\n\trcu_preempt_deferred_qs(current);\n}\n\n/*\n * Record entry into an extended quiescent state.  This is only to be\n * called when not already in an extended quiescent state, that is,\n * RCU is watching prior to the call to this function and is no longer\n * watching upon return.\n */\nstatic noinstr void rcu_dynticks_eqs_enter(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior RCU read-side\n\t * critical sections, and we also must force ordering with the\n\t * next idle sojourn.\n\t */\n\trcu_dynticks_task_trace_enter();  // Before ->dynticks update!\n\tseq = arch_atomic_add_return(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n\t// RCU is no longer watching.  Better be in extended quiescent state!\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     (seq & RCU_DYNTICK_CTRL_CTR));\n\t/* Better not have special action (TLB flush) pending! */\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     (seq & RCU_DYNTICK_CTRL_MASK));\n}\n\n/*\n * Record exit from an extended quiescent state.  This is only to be\n * called from an extended quiescent state, that is, RCU is not watching\n * prior to the call to this function and is watching upon return.\n */\nstatic noinstr void rcu_dynticks_eqs_exit(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tint seq;\n\n\t/*\n\t * CPUs seeing atomic_add_return() must see prior idle sojourns,\n\t * and we also must force ordering with the next RCU read-side\n\t * critical section.\n\t */\n\tseq = arch_atomic_add_return(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n\t// RCU is now watching.  Better not be in an extended quiescent state!\n\trcu_dynticks_task_trace_exit();  // After ->dynticks update!\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     !(seq & RCU_DYNTICK_CTRL_CTR));\n\tif (seq & RCU_DYNTICK_CTRL_MASK) {\n\t\tarch_atomic_andnot(RCU_DYNTICK_CTRL_MASK, &rdp->dynticks);\n\t\tsmp_mb__after_atomic(); /* _exit after clearing mask. */\n\t}\n}\n\n/*\n * Reset the current CPU's ->dynticks counter to indicate that the\n * newly onlined CPU is no longer in an extended quiescent state.\n * This will either leave the counter unchanged, or increment it\n * to the next non-quiescent value.\n *\n * The non-atomic test/increment sequence works because the upper bits\n * of the ->dynticks counter are manipulated only by the corresponding CPU,\n * or when the corresponding CPU is offline.\n */\nstatic void rcu_dynticks_eqs_online(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tif (atomic_read(&rdp->dynticks) & RCU_DYNTICK_CTRL_CTR)\n\t\treturn;\n\tatomic_add(RCU_DYNTICK_CTRL_CTR, &rdp->dynticks);\n}\n\n/*\n * Is the current CPU in an extended quiescent state?\n *\n * No ordering, as we are sampling CPU-local information.\n */\nstatic __always_inline bool rcu_dynticks_curr_cpu_in_eqs(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\treturn !(arch_atomic_read(&rdp->dynticks) & RCU_DYNTICK_CTRL_CTR);\n}\n\n/*\n * Snapshot the ->dynticks counter with full ordering so as to allow\n * stable comparison of this counter with past and future snapshots.\n */\nstatic int rcu_dynticks_snap(struct rcu_data *rdp)\n{\n\tint snap = atomic_add_return(0, &rdp->dynticks);\n\n\treturn snap & ~RCU_DYNTICK_CTRL_MASK;\n}\n\n/*\n * Return true if the snapshot returned from rcu_dynticks_snap()\n * indicates that RCU is in an extended quiescent state.\n */\nstatic bool rcu_dynticks_in_eqs(int snap)\n{\n\treturn !(snap & RCU_DYNTICK_CTRL_CTR);\n}\n\n/* Return true if the specified CPU is currently idle from an RCU viewpoint.  */\nbool rcu_is_idle_cpu(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\treturn rcu_dynticks_in_eqs(rcu_dynticks_snap(rdp));\n}\n\n/*\n * Return true if the CPU corresponding to the specified rcu_data\n * structure has spent some time in an extended quiescent state since\n * rcu_dynticks_snap() returned the specified snapshot.\n */\nstatic bool rcu_dynticks_in_eqs_since(struct rcu_data *rdp, int snap)\n{\n\treturn snap != rcu_dynticks_snap(rdp);\n}\n\n/*\n * Return true if the referenced integer is zero while the specified\n * CPU remains within a single extended quiescent state.\n */\nbool rcu_dynticks_zero_in_eqs(int cpu, int *vp)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tint snap;\n\n\t// If not quiescent, force back to earlier extended quiescent state.\n\tsnap = atomic_read(&rdp->dynticks) & ~(RCU_DYNTICK_CTRL_MASK |\n\t\t\t\t\t       RCU_DYNTICK_CTRL_CTR);\n\n\tsmp_rmb(); // Order ->dynticks and *vp reads.\n\tif (READ_ONCE(*vp))\n\t\treturn false;  // Non-zero, so report failure;\n\tsmp_rmb(); // Order *vp read and ->dynticks re-read.\n\n\t// If still in the same extended quiescent state, we are good!\n\treturn snap == (atomic_read(&rdp->dynticks) & ~RCU_DYNTICK_CTRL_MASK);\n}\n\n/*\n * Set the special (bottom) bit of the specified CPU so that it\n * will take special action (such as flushing its TLB) on the\n * next exit from an extended quiescent state.  Returns true if\n * the bit was successfully set, or false if the CPU was not in\n * an extended quiescent state.\n */\nbool rcu_eqs_special_set(int cpu)\n{\n\tint old;\n\tint new;\n\tint new_old;\n\tstruct rcu_data *rdp = &per_cpu(rcu_data, cpu);\n\n\tnew_old = atomic_read(&rdp->dynticks);\n\tdo {\n\t\told = new_old;\n\t\tif (old & RCU_DYNTICK_CTRL_CTR)\n\t\t\treturn false;\n\t\tnew = old | RCU_DYNTICK_CTRL_MASK;\n\t\tnew_old = atomic_cmpxchg(&rdp->dynticks, old, new);\n\t} while (new_old != old);\n\treturn true;\n}\n\n/*\n * Let the RCU core know that this CPU has gone through the scheduler,\n * which is a quiescent state.  This is called when the need for a\n * quiescent state is urgent, so we burn an atomic operation and full\n * memory barriers to let the RCU core know about it, regardless of what\n * this CPU might (or might not) do in the near future.\n *\n * We inform the RCU core by emulating a zero-duration dyntick-idle period.\n *\n * The caller must have disabled interrupts and must not be idle.\n */\nnotrace void rcu_momentary_dyntick_idle(void)\n{\n\tint special;\n\n\traw_cpu_write(rcu_data.rcu_need_heavy_qs, false);\n\tspecial = atomic_add_return(2 * RCU_DYNTICK_CTRL_CTR,\n\t\t\t\t    &this_cpu_ptr(&rcu_data)->dynticks);\n\t/* It is illegal to call this from idle state. */\n\tWARN_ON_ONCE(!(special & RCU_DYNTICK_CTRL_CTR));\n\trcu_preempt_deferred_qs(current);\n}\nEXPORT_SYMBOL_GPL(rcu_momentary_dyntick_idle);\n\n/**\n * rcu_is_cpu_rrupt_from_idle - see if 'interrupted' from idle\n *\n * If the current CPU is idle and running at a first-level (not nested)\n * interrupt, or directly, from idle, return true.\n *\n * The caller must have at least disabled IRQs.\n */\nstatic int rcu_is_cpu_rrupt_from_idle(void)\n{\n\tlong nesting;\n\n\t/*\n\t * Usually called from the tick; but also used from smp_function_call()\n\t * for expedited grace periods. This latter can result in running from\n\t * the idle task, instead of an actual IPI.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\t/* Check for counter underflows */\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nesting) < 0,\n\t\t\t \"RCU dynticks_nesting counter underflow!\");\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nmi_nesting) <= 0,\n\t\t\t \"RCU dynticks_nmi_nesting counter underflow/zero!\");\n\n\t/* Are we at first interrupt nesting level? */\n\tnesting = __this_cpu_read(rcu_data.dynticks_nmi_nesting);\n\tif (nesting > 1)\n\t\treturn false;\n\n\t/*\n\t * If we're not in an interrupt, we must be in the idle task!\n\t */\n\tWARN_ON_ONCE(!nesting && !is_idle_task(current));\n\n\t/* Does CPU appear to be idle from an RCU standpoint? */\n\treturn __this_cpu_read(rcu_data.dynticks_nesting) == 0;\n}\n\n#define DEFAULT_RCU_BLIMIT (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 1000 : 10)\n\t\t\t\t// Maximum callbacks per rcu_do_batch ...\n#define DEFAULT_MAX_RCU_BLIMIT 10000 // ... even during callback flood.\nstatic long blimit = DEFAULT_RCU_BLIMIT;\n#define DEFAULT_RCU_QHIMARK 10000 // If this many pending, ignore blimit.\nstatic long qhimark = DEFAULT_RCU_QHIMARK;\n#define DEFAULT_RCU_QLOMARK 100   // Once only this many pending, use blimit.\nstatic long qlowmark = DEFAULT_RCU_QLOMARK;\n#define DEFAULT_RCU_QOVLD_MULT 2\n#define DEFAULT_RCU_QOVLD (DEFAULT_RCU_QOVLD_MULT * DEFAULT_RCU_QHIMARK)\nstatic long qovld = DEFAULT_RCU_QOVLD; // If this many pending, hammer QS.\nstatic long qovld_calc = -1;\t  // No pre-initialization lock acquisitions!\n\nmodule_param(blimit, long, 0444);\nmodule_param(qhimark, long, 0444);\nmodule_param(qlowmark, long, 0444);\nmodule_param(qovld, long, 0444);\n\nstatic ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\nstatic bool rcu_kick_kthreads;\nstatic int rcu_divisor = 7;\nmodule_param(rcu_divisor, int, 0644);\n\n/* Force an exit from rcu_do_batch() after 3 milliseconds. */\nstatic long rcu_resched_ns = 3 * NSEC_PER_MSEC;\nmodule_param(rcu_resched_ns, long, 0644);\n\n/*\n * How long the grace period must be before we start recruiting\n * quiescent-state help from rcu_note_context_switch().\n */\nstatic ulong jiffies_till_sched_qs = ULONG_MAX;\nmodule_param(jiffies_till_sched_qs, ulong, 0444);\nstatic ulong jiffies_to_sched_qs; /* See adjust_jiffies_till_sched_qs(). */\nmodule_param(jiffies_to_sched_qs, ulong, 0444); /* Display only! */\n\n/*\n * Make sure that we give the grace-period kthread time to detect any\n * idle CPUs before taking active measures to force quiescent states.\n * However, don't go below 100 milliseconds, adjusted upwards for really\n * large systems.\n */\nstatic void adjust_jiffies_till_sched_qs(void)\n{\n\tunsigned long j;\n\n\t/* If jiffies_till_sched_qs was specified, respect the request. */\n\tif (jiffies_till_sched_qs != ULONG_MAX) {\n\t\tWRITE_ONCE(jiffies_to_sched_qs, jiffies_till_sched_qs);\n\t\treturn;\n\t}\n\t/* Otherwise, set to third fqs scan, but bound below on large system. */\n\tj = READ_ONCE(jiffies_till_first_fqs) +\n\t\t      2 * READ_ONCE(jiffies_till_next_fqs);\n\tif (j < HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV)\n\t\tj = HZ / 10 + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tpr_info(\"RCU calculated value of scheduler-enlistment delay is %ld jiffies.\\n\", j);\n\tWRITE_ONCE(jiffies_to_sched_qs, j);\n}\n\nstatic int param_set_first_fqs_jiffies(const char *val, const struct kernel_param *kp)\n{\n\tulong j;\n\tint ret = kstrtoul(val, 0, &j);\n\n\tif (!ret) {\n\t\tWRITE_ONCE(*(ulong *)kp->arg, (j > HZ) ? HZ : j);\n\t\tadjust_jiffies_till_sched_qs();\n\t}\n\treturn ret;\n}\n\nstatic int param_set_next_fqs_jiffies(const char *val, const struct kernel_param *kp)\n{\n\tulong j;\n\tint ret = kstrtoul(val, 0, &j);\n\n\tif (!ret) {\n\t\tWRITE_ONCE(*(ulong *)kp->arg, (j > HZ) ? HZ : (j ?: 1));\n\t\tadjust_jiffies_till_sched_qs();\n\t}\n\treturn ret;\n}\n\nstatic const struct kernel_param_ops first_fqs_jiffies_ops = {\n\t.set = param_set_first_fqs_jiffies,\n\t.get = param_get_ulong,\n};\n\nstatic const struct kernel_param_ops next_fqs_jiffies_ops = {\n\t.set = param_set_next_fqs_jiffies,\n\t.get = param_get_ulong,\n};\n\nmodule_param_cb(jiffies_till_first_fqs, &first_fqs_jiffies_ops, &jiffies_till_first_fqs, 0644);\nmodule_param_cb(jiffies_till_next_fqs, &next_fqs_jiffies_ops, &jiffies_till_next_fqs, 0644);\nmodule_param(rcu_kick_kthreads, bool, 0644);\n\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp));\nstatic int rcu_pending(int user);\n\n/*\n * Return the number of RCU GPs completed thus far for debug & stats.\n */\nunsigned long rcu_get_gp_seq(void)\n{\n\treturn READ_ONCE(rcu_state.gp_seq);\n}\nEXPORT_SYMBOL_GPL(rcu_get_gp_seq);\n\n/*\n * Return the number of RCU expedited batches completed thus far for\n * debug & stats.  Odd numbers mean that a batch is in progress, even\n * numbers mean idle.  The value returned will thus be roughly double\n * the cumulative batches since boot.\n */\nunsigned long rcu_exp_batches_completed(void)\n{\n\treturn rcu_state.expedited_sequence;\n}\nEXPORT_SYMBOL_GPL(rcu_exp_batches_completed);\n\n/*\n * Return the root node of the rcu_state structure.\n */\nstatic struct rcu_node *rcu_get_root(void)\n{\n\treturn &rcu_state.node[0];\n}\n\n/*\n * Send along grace-period-related data for rcutorture diagnostics.\n */\nvoid rcutorture_get_gp_data(enum rcutorture_type test_type, int *flags,\n\t\t\t    unsigned long *gp_seq)\n{\n\tswitch (test_type) {\n\tcase RCU_FLAVOR:\n\t\t*flags = READ_ONCE(rcu_state.gp_flags);\n\t\t*gp_seq = rcu_seq_current(&rcu_state.gp_seq);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(rcutorture_get_gp_data);\n\n/*\n * Enter an RCU extended quiescent state, which can be either the\n * idle loop or adaptive-tickless usermode execution.\n *\n * We crowbar the ->dynticks_nmi_nesting field to zero to allow for\n * the possibility of usermode upcalls having messed up our count\n * of interrupt nesting level during the prior busy period.\n */\nstatic noinstr void rcu_eqs_enter(bool user)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting != DYNTICK_IRQ_NONIDLE);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0);\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &&\n\t\t     rdp->dynticks_nesting == 0);\n\tif (rdp->dynticks_nesting != 1) {\n\t\t// RCU will still be watching, so just do accounting and leave.\n\t\trdp->dynticks_nesting--;\n\t\treturn;\n\t}\n\n\tlockdep_assert_irqs_disabled();\n\tinstrumentation_begin();\n\ttrace_rcu_dyntick(TPS(\"Start\"), rdp->dynticks_nesting, 0, atomic_read(&rdp->dynticks));\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\tdo_nocb_deferred_wakeup(rdp);\n\trcu_prepare_for_idle();\n\trcu_preempt_deferred_qs(current);\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_enter()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\tinstrumentation_end();\n\tWRITE_ONCE(rdp->dynticks_nesting, 0); /* Avoid irq-access tearing. */\n\t// RCU is watching here ...\n\trcu_dynticks_eqs_enter();\n\t// ... but is no longer watching here.\n\trcu_dynticks_task_enter();\n}\n\n/**\n * rcu_idle_enter - inform RCU that current CPU is entering idle\n *\n * Enter idle mode, in other words, -leave- the mode in which RCU\n * read-side critical sections can occur.  (Though RCU read-side\n * critical sections can occur in irq handlers in idle, a possibility\n * handled by irq_enter() and irq_exit().)\n *\n * If you add or remove a call to rcu_idle_enter(), be sure to test with\n * CONFIG_RCU_EQS_DEBUG=y.\n */\nvoid rcu_idle_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(false);\n}\nEXPORT_SYMBOL_GPL(rcu_idle_enter);\n\n#ifdef CONFIG_NO_HZ_FULL\n/**\n * rcu_user_enter - inform RCU that we are resuming userspace.\n *\n * Enter RCU idle mode right before resuming userspace.  No use of RCU\n * is permitted between this call and rcu_user_exit(). This way the\n * CPU doesn't need to maintain the tick for RCU maintenance purposes\n * when the CPU runs in userspace.\n *\n * If you add or remove a call to rcu_user_enter(), be sure to test with\n * CONFIG_RCU_EQS_DEBUG=y.\n */\nnoinstr void rcu_user_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(true);\n}\n#endif /* CONFIG_NO_HZ_FULL */\n\n/**\n * rcu_nmi_exit - inform RCU of exit from NMI context\n *\n * If we are returning from the outermost NMI handler that interrupted an\n * RCU-idle period, update rdp->dynticks and rdp->dynticks_nmi_nesting\n * to let the RCU grace-period handling know that the CPU is back to\n * being RCU-idle.\n *\n * If you add or remove a call to rcu_nmi_exit(), be sure to test\n * with CONFIG_RCU_EQS_DEBUG=y.\n */\nnoinstr void rcu_nmi_exit(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tinstrumentation_begin();\n\t/*\n\t * Check for ->dynticks_nmi_nesting underflow and bad ->dynticks.\n\t * (We are exiting an NMI handler, so RCU better be paying attention\n\t * to us!)\n\t */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting <= 0);\n\tWARN_ON_ONCE(rcu_dynticks_curr_cpu_in_eqs());\n\n\t/*\n\t * If the nesting level is not 1, the CPU wasn't RCU-idle, so\n\t * leave it in non-RCU-idle state.\n\t */\n\tif (rdp->dynticks_nmi_nesting != 1) {\n\t\ttrace_rcu_dyntick(TPS(\"--=\"), rdp->dynticks_nmi_nesting, rdp->dynticks_nmi_nesting - 2,\n\t\t\t\t  atomic_read(&rdp->dynticks));\n\t\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* No store tearing. */\n\t\t\t   rdp->dynticks_nmi_nesting - 2);\n\t\tinstrumentation_end();\n\t\treturn;\n\t}\n\n\t/* This NMI interrupted an RCU-idle CPU, restore RCU-idleness. */\n\ttrace_rcu_dyntick(TPS(\"Startirq\"), rdp->dynticks_nmi_nesting, 0, atomic_read(&rdp->dynticks));\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, 0); /* Avoid store tearing. */\n\n\tif (!in_nmi())\n\t\trcu_prepare_for_idle();\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_enter()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\tinstrumentation_end();\n\n\t// RCU is watching here ...\n\trcu_dynticks_eqs_enter();\n\t// ... but is no longer watching here.\n\n\tif (!in_nmi())\n\t\trcu_dynticks_task_enter();\n}\n\n/**\n * rcu_irq_exit - inform RCU that current CPU is exiting irq towards idle\n *\n * Exit from an interrupt handler, which might possibly result in entering\n * idle mode, in other words, leaving the mode in which read-side critical\n * sections can occur.  The caller must have disabled interrupts.\n *\n * This code assumes that the idle loop never does anything that might\n * result in unbalanced calls to irq_enter() and irq_exit().  If your\n * architecture's idle loop violates this assumption, RCU will give you what\n * you deserve, good and hard.  But very infrequently and irreproducibly.\n *\n * Use things like work queues to work around this limitation.\n *\n * You have been warned.\n *\n * If you add or remove a call to rcu_irq_exit(), be sure to test with\n * CONFIG_RCU_EQS_DEBUG=y.\n */\nvoid noinstr rcu_irq_exit(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_nmi_exit();\n}\n\n/**\n * rcu_irq_exit_preempt - Inform RCU that current CPU is exiting irq\n *\t\t\t  towards in kernel preemption\n *\n * Same as rcu_irq_exit() but has a sanity check that scheduling is safe\n * from RCU point of view. Invoked from return from interrupt before kernel\n * preemption.\n */\nvoid rcu_irq_exit_preempt(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_nmi_exit();\n\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nesting) <= 0,\n\t\t\t \"RCU dynticks_nesting counter underflow/zero!\");\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nmi_nesting) !=\n\t\t\t DYNTICK_IRQ_NONIDLE,\n\t\t\t \"Bad RCU  dynticks_nmi_nesting counter\\n\");\n\tRCU_LOCKDEP_WARN(rcu_dynticks_curr_cpu_in_eqs(),\n\t\t\t \"RCU in extended quiescent state!\");\n}\n\n#ifdef CONFIG_PROVE_RCU\n/**\n * rcu_irq_exit_check_preempt - Validate that scheduling is possible\n */\nvoid rcu_irq_exit_check_preempt(void)\n{\n\tlockdep_assert_irqs_disabled();\n\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nesting) <= 0,\n\t\t\t \"RCU dynticks_nesting counter underflow/zero!\");\n\tRCU_LOCKDEP_WARN(__this_cpu_read(rcu_data.dynticks_nmi_nesting) !=\n\t\t\t DYNTICK_IRQ_NONIDLE,\n\t\t\t \"Bad RCU  dynticks_nmi_nesting counter\\n\");\n\tRCU_LOCKDEP_WARN(rcu_dynticks_curr_cpu_in_eqs(),\n\t\t\t \"RCU in extended quiescent state!\");\n}\n#endif /* #ifdef CONFIG_PROVE_RCU */\n\n/*\n * Wrapper for rcu_irq_exit() where interrupts are enabled.\n *\n * If you add or remove a call to rcu_irq_exit_irqson(), be sure to test\n * with CONFIG_RCU_EQS_DEBUG=y.\n */\nvoid rcu_irq_exit_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_exit();\n\tlocal_irq_restore(flags);\n}\n\n/*\n * Exit an RCU extended quiescent state, which can be either the\n * idle loop or adaptive-tickless usermode execution.\n *\n * We crowbar the ->dynticks_nmi_nesting field to DYNTICK_IRQ_NONIDLE to\n * allow for the possibility of usermode upcalls messing up our count of\n * interrupt nesting level during the busy period that is just now starting.\n */\nstatic void noinstr rcu_eqs_exit(bool user)\n{\n\tstruct rcu_data *rdp;\n\tlong oldval;\n\n\tlockdep_assert_irqs_disabled();\n\trdp = this_cpu_ptr(&rcu_data);\n\toldval = rdp->dynticks_nesting;\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && oldval < 0);\n\tif (oldval) {\n\t\t// RCU was already watching, so just do accounting and leave.\n\t\trdp->dynticks_nesting++;\n\t\treturn;\n\t}\n\trcu_dynticks_task_exit();\n\t// RCU is not watching here ...\n\trcu_dynticks_eqs_exit();\n\t// ... but is watching here.\n\tinstrumentation_begin();\n\n\t// instrumentation for the noinstr rcu_dynticks_eqs_exit()\n\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\trcu_cleanup_after_idle();\n\ttrace_rcu_dyntick(TPS(\"End\"), rdp->dynticks_nesting, 1, atomic_read(&rdp->dynticks));\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) && !user && !is_idle_task(current));\n\tWRITE_ONCE(rdp->dynticks_nesting, 1);\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting);\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, DYNTICK_IRQ_NONIDLE);\n\tinstrumentation_end();\n}\n\n/**\n * rcu_idle_exit - inform RCU that current CPU is leaving idle\n *\n * Exit idle mode, in other words, -enter- the mode in which RCU\n * read-side critical sections can occur.\n *\n * If you add or remove a call to rcu_idle_exit(), be sure to test with\n * CONFIG_RCU_EQS_DEBUG=y.\n */\nvoid rcu_idle_exit(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_eqs_exit(false);\n\tlocal_irq_restore(flags);\n}\nEXPORT_SYMBOL_GPL(rcu_idle_exit);\n\n#ifdef CONFIG_NO_HZ_FULL\n/**\n * rcu_user_exit - inform RCU that we are exiting userspace.\n *\n * Exit RCU idle mode while entering the kernel because it can\n * run a RCU read side critical section anytime.\n *\n * If you add or remove a call to rcu_user_exit(), be sure to test with\n * CONFIG_RCU_EQS_DEBUG=y.\n */\nvoid noinstr rcu_user_exit(void)\n{\n\trcu_eqs_exit(1);\n}\n\n/**\n * __rcu_irq_enter_check_tick - Enable scheduler tick on CPU if RCU needs it.\n *\n * The scheduler tick is not normally enabled when CPUs enter the kernel\n * from nohz_full userspace execution.  After all, nohz_full userspace\n * execution is an RCU quiescent state and the time executing in the kernel\n * is quite short.  Except of course when it isn't.  And it is not hard to\n * cause a large system to spend tens of seconds or even minutes looping\n * in the kernel, which can cause a number of problems, include RCU CPU\n * stall warnings.\n *\n * Therefore, if a nohz_full CPU fails to report a quiescent state\n * in a timely manner, the RCU grace-period kthread sets that CPU's\n * ->rcu_urgent_qs flag with the expectation that the next interrupt or\n * exception will invoke this function, which will turn on the scheduler\n * tick, which will enable RCU to detect that CPU's quiescent states,\n * for example, due to cond_resched() calls in CONFIG_PREEMPT=n kernels.\n * The tick will be disabled once a quiescent state is reported for\n * this CPU.\n *\n * Of course, in carefully tuned systems, there might never be an\n * interrupt or exception.  In that case, the RCU grace-period kthread\n * will eventually cause one to happen.  However, in less carefully\n * controlled environments, this function allows RCU to get what it\n * needs without creating otherwise useless interruptions.\n */\nvoid __rcu_irq_enter_check_tick(void)\n{\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t// If we're here from NMI there's nothing to do.\n\tif (in_nmi())\n\t\treturn;\n\n\tRCU_LOCKDEP_WARN(rcu_dynticks_curr_cpu_in_eqs(),\n\t\t\t \"Illegal rcu_irq_enter_check_tick() from extended quiescent state\");\n\n\tif (!tick_nohz_full_cpu(rdp->cpu) ||\n\t    !READ_ONCE(rdp->rcu_urgent_qs) ||\n\t    READ_ONCE(rdp->rcu_forced_tick)) {\n\t\t// RCU doesn't need nohz_full help from this CPU, or it is\n\t\t// already getting that help.\n\t\treturn;\n\t}\n\n\t// We get here only when not in an extended quiescent state and\n\t// from interrupts (as opposed to NMIs).  Therefore, (1) RCU is\n\t// already watching and (2) The fact that we are in an interrupt\n\t// handler and that the rcu_node lock is an irq-disabled lock\n\t// prevents self-deadlock.  So we can safely recheck under the lock.\n\t// Note that the nohz_full state currently cannot change.\n\traw_spin_lock_rcu_node(rdp->mynode);\n\tif (rdp->rcu_urgent_qs && !rdp->rcu_forced_tick) {\n\t\t// A nohz_full CPU is in the kernel and RCU needs a\n\t\t// quiescent state.  Turn on the tick!\n\t\tWRITE_ONCE(rdp->rcu_forced_tick, true);\n\t\ttick_dep_set_cpu(rdp->cpu, TICK_DEP_BIT_RCU);\n\t}\n\traw_spin_unlock_rcu_node(rdp->mynode);\n}\n#endif /* CONFIG_NO_HZ_FULL */\n\n/**\n * rcu_nmi_enter - inform RCU of entry to NMI context\n *\n * If the CPU was idle from RCU's viewpoint, update rdp->dynticks and\n * rdp->dynticks_nmi_nesting to let the RCU grace-period handling know\n * that the CPU is active.  This implementation permits nested NMIs, as\n * long as the nesting level does not overflow an int.  (You will probably\n * run out of stack space first.)\n *\n * If you add or remove a call to rcu_nmi_enter(), be sure to test\n * with CONFIG_RCU_EQS_DEBUG=y.\n */\nnoinstr void rcu_nmi_enter(void)\n{\n\tlong incby = 2;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\t/* Complain about underflow. */\n\tWARN_ON_ONCE(rdp->dynticks_nmi_nesting < 0);\n\n\t/*\n\t * If idle from RCU viewpoint, atomically increment ->dynticks\n\t * to mark non-idle and increment ->dynticks_nmi_nesting by one.\n\t * Otherwise, increment ->dynticks_nmi_nesting by two.  This means\n\t * if ->dynticks_nmi_nesting is equal to one, we are guaranteed\n\t * to be in the outermost NMI handler that interrupted an RCU-idle\n\t * period (observation due to Andy Lutomirski).\n\t */\n\tif (rcu_dynticks_curr_cpu_in_eqs()) {\n\n\t\tif (!in_nmi())\n\t\t\trcu_dynticks_task_exit();\n\n\t\t// RCU is not watching here ...\n\t\trcu_dynticks_eqs_exit();\n\t\t// ... but is watching here.\n\n\t\tif (!in_nmi()) {\n\t\t\tinstrumentation_begin();\n\t\t\trcu_cleanup_after_idle();\n\t\t\tinstrumentation_end();\n\t\t}\n\n\t\tinstrumentation_begin();\n\t\t// instrumentation for the noinstr rcu_dynticks_curr_cpu_in_eqs()\n\t\tinstrument_atomic_read(&rdp->dynticks, sizeof(rdp->dynticks));\n\t\t// instrumentation for the noinstr rcu_dynticks_eqs_exit()\n\t\tinstrument_atomic_write(&rdp->dynticks, sizeof(rdp->dynticks));\n\n\t\tincby = 1;\n\t} else if (!in_nmi()) {\n\t\tinstrumentation_begin();\n\t\trcu_irq_enter_check_tick();\n\t} else  {\n\t\tinstrumentation_begin();\n\t}\n\n\ttrace_rcu_dyntick(incby == 1 ? TPS(\"Endirq\") : TPS(\"++=\"),\n\t\t\t  rdp->dynticks_nmi_nesting,\n\t\t\t  rdp->dynticks_nmi_nesting + incby, atomic_read(&rdp->dynticks));\n\tinstrumentation_end();\n\tWRITE_ONCE(rdp->dynticks_nmi_nesting, /* Prevent store tearing. */\n\t\t   rdp->dynticks_nmi_nesting + incby);\n\tbarrier();\n}\n\n/**\n * rcu_irq_enter - inform RCU that current CPU is entering irq away from idle\n *\n * Enter an interrupt handler, which might possibly result in exiting\n * idle mode, in other words, entering the mode in which read-side critical\n * sections can occur.  The caller must have disabled interrupts.\n *\n * Note that the Linux kernel is fully capable of entering an interrupt\n * handler that it never exits, for example when doing upcalls to user mode!\n * This code assumes that the idle loop never does upcalls to user mode.\n * If your architecture's idle loop does do upcalls to user mode (or does\n * anything else that results in unbalanced calls to the irq_enter() and\n * irq_exit() functions), RCU will give you what you deserve, good and hard.\n * But very infrequently and irreproducibly.\n *\n * Use things like work queues to work around this limitation.\n *\n * You have been warned.\n *\n * If you add or remove a call to rcu_irq_enter(), be sure to test with\n * CONFIG_RCU_EQS_DEBUG=y.\n */\nnoinstr void rcu_irq_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_nmi_enter();\n}\n\n/*\n * Wrapper for rcu_irq_enter() where interrupts are enabled.\n *\n * If you add or remove a call to rcu_irq_enter_irqson(), be sure to test\n * with CONFIG_RCU_EQS_DEBUG=y.\n */\nvoid rcu_irq_enter_irqson(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_irq_enter();\n\tlocal_irq_restore(flags);\n}\n\n/*\n * If any sort of urgency was applied to the current CPU (for example,\n * the scheduler-clock interrupt was enabled on a nohz_full CPU) in order\n * to get to a quiescent state, disable it.\n */\nstatic void rcu_disable_urgency_upon_qs(struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rdp->mynode);\n\tWRITE_ONCE(rdp->rcu_urgent_qs, false);\n\tWRITE_ONCE(rdp->rcu_need_heavy_qs, false);\n\tif (tick_nohz_full_cpu(rdp->cpu) && rdp->rcu_forced_tick) {\n\t\ttick_dep_clear_cpu(rdp->cpu, TICK_DEP_BIT_RCU);\n\t\tWRITE_ONCE(rdp->rcu_forced_tick, false);\n\t}\n}\n\n/**\n * rcu_is_watching - see if RCU thinks that the current CPU is not idle\n *\n * Return true if RCU is watching the running CPU, which means that this\n * CPU can safely enter RCU read-side critical sections.  In other words,\n * if the current CPU is not in its idle loop or is in an interrupt or\n * NMI handler, return true.\n *\n * Make notrace because it can be called by the internal functions of\n * ftrace, and making this notrace removes unnecessary recursion calls.\n */\nnotrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rcu_is_watching);\n\n/*\n * If a holdout task is actually running, request an urgent quiescent\n * state from its CPU.  This is unsynchronized, so migrations can cause\n * the request to go to the wrong CPU.  Which is OK, all that will happen\n * is that the CPU's next context switch will be a bit slower and next\n * time around this task will generate another request.\n */\nvoid rcu_request_urgent_qs_task(struct task_struct *t)\n{\n\tint cpu;\n\n\tbarrier();\n\tcpu = task_cpu(t);\n\tif (!task_curr(t))\n\t\treturn; /* This task is not running on that CPU. */\n\tsmp_store_release(per_cpu_ptr(&rcu_data.rcu_urgent_qs, cpu), true);\n}\n\n#if defined(CONFIG_PROVE_RCU) && defined(CONFIG_HOTPLUG_CPU)\n\n/*\n * Is the current CPU online as far as RCU is concerned?\n *\n * Disable preemption to avoid false positives that could otherwise\n * happen due to the current CPU number being sampled, this task being\n * preempted, its old CPU being taken offline, resuming on some other CPU,\n * then determining that its old CPU is now offline.\n *\n * Disable checking if in an NMI handler because we cannot safely\n * report errors from NMI handlers anyway.  In addition, it is OK to use\n * RCU on an offline processor during initial boot, hence the check for\n * rcu_scheduler_fully_active.\n */\nbool rcu_lockdep_current_cpu_online(void)\n{\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tbool ret = false;\n\n\tif (in_nmi() || !rcu_scheduler_fully_active)\n\t\treturn true;\n\tpreempt_disable_notrace();\n\trdp = this_cpu_ptr(&rcu_data);\n\trnp = rdp->mynode;\n\tif (rdp->grpmask & rcu_rnp_online_cpus(rnp) || READ_ONCE(rnp->ofl_seq) & 0x1)\n\t\tret = true;\n\tpreempt_enable_notrace();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rcu_lockdep_current_cpu_online);\n\n#endif /* #if defined(CONFIG_PROVE_RCU) && defined(CONFIG_HOTPLUG_CPU) */\n\n/*\n * We are reporting a quiescent state on behalf of some other CPU, so\n * it is our responsibility to check for and handle potential overflow\n * of the rcu_node ->gp_seq counter with respect to the rcu_data counters.\n * After all, the CPU might be in deep idle state, and thus executing no\n * code whatsoever.\n */\nstatic void rcu_gpnum_ovf(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (ULONG_CMP_LT(rcu_seq_current(&rdp->gp_seq) + ULONG_MAX / 4,\n\t\t\t rnp->gp_seq))\n\t\tWRITE_ONCE(rdp->gpwrap, true);\n\tif (ULONG_CMP_LT(rdp->rcu_iw_gp_seq + ULONG_MAX / 4, rnp->gp_seq))\n\t\trdp->rcu_iw_gp_seq = rnp->gp_seq + ULONG_MAX / 4;\n}\n\n/*\n * Snapshot the specified CPU's dynticks counter so that we can later\n * credit them with an implicit quiescent state.  Return 1 if this CPU\n * is in dynticks idle mode, which is an extended quiescent state.\n */\nstatic int dyntick_save_progress_counter(struct rcu_data *rdp)\n{\n\trdp->dynticks_snap = rcu_dynticks_snap(rdp);\n\tif (rcu_dynticks_in_eqs(rdp->dynticks_snap)) {\n\t\ttrace_rcu_fqs(rcu_state.name, rdp->gp_seq, rdp->cpu, TPS(\"dti\"));\n\t\trcu_gpnum_ovf(rdp->mynode, rdp);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Return true if the specified CPU has passed through a quiescent\n * state by virtue of being in or having passed through an dynticks\n * idle state since the last call to dyntick_save_progress_counter()\n * for this same CPU, or by virtue of having been offline.\n */\nstatic int rcu_implicit_dynticks_qs(struct rcu_data *rdp)\n{\n\tunsigned long jtsq;\n\tbool *rnhqp;\n\tbool *ruqp;\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\t/*\n\t * If the CPU passed through or entered a dynticks idle phase with\n\t * no active irq/NMI handlers, then we can safely pretend that the CPU\n\t * already acknowledged the request to pass through a quiescent\n\t * state.  Either way, that CPU cannot possibly be in an RCU\n\t * read-side critical section that started before the beginning\n\t * of the current RCU grace period.\n\t */\n\tif (rcu_dynticks_in_eqs_since(rdp, rdp->dynticks_snap)) {\n\t\ttrace_rcu_fqs(rcu_state.name, rdp->gp_seq, rdp->cpu, TPS(\"dti\"));\n\t\trcu_gpnum_ovf(rnp, rdp);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Complain if a CPU that is considered to be offline from RCU's\n\t * perspective has not yet reported a quiescent state.  After all,\n\t * the offline CPU should have reported a quiescent state during\n\t * the CPU-offline process, or, failing that, by rcu_gp_init()\n\t * if it ran concurrently with either the CPU going offline or the\n\t * last task on a leaf rcu_node structure exiting its RCU read-side\n\t * critical section while all CPUs corresponding to that structure\n\t * are offline.  This added warning detects bugs in any of these\n\t * code paths.\n\t *\n\t * The rcu_node structure's ->lock is held here, which excludes\n\t * the relevant portions the CPU-hotplug code, the grace-period\n\t * initialization code, and the rcu_read_unlock() code paths.\n\t *\n\t * For more detail, please refer to the \"Hotplug CPU\" section\n\t * of RCU's Requirements documentation.\n\t */\n\tif (WARN_ON_ONCE(!(rdp->grpmask & rcu_rnp_online_cpus(rnp)))) {\n\t\tbool onl;\n\t\tstruct rcu_node *rnp1;\n\n\t\tpr_info(\"%s: grp: %d-%d level: %d ->gp_seq %ld ->completedqs %ld\\n\",\n\t\t\t__func__, rnp->grplo, rnp->grphi, rnp->level,\n\t\t\t(long)rnp->gp_seq, (long)rnp->completedqs);\n\t\tfor (rnp1 = rnp; rnp1; rnp1 = rnp1->parent)\n\t\t\tpr_info(\"%s: %d:%d ->qsmask %#lx ->qsmaskinit %#lx ->qsmaskinitnext %#lx ->rcu_gp_init_mask %#lx\\n\",\n\t\t\t\t__func__, rnp1->grplo, rnp1->grphi, rnp1->qsmask, rnp1->qsmaskinit, rnp1->qsmaskinitnext, rnp1->rcu_gp_init_mask);\n\t\tonl = !!(rdp->grpmask & rcu_rnp_online_cpus(rnp));\n\t\tpr_info(\"%s %d: %c online: %ld(%d) offline: %ld(%d)\\n\",\n\t\t\t__func__, rdp->cpu, \".o\"[onl],\n\t\t\t(long)rdp->rcu_onl_gp_seq, rdp->rcu_onl_gp_flags,\n\t\t\t(long)rdp->rcu_ofl_gp_seq, rdp->rcu_ofl_gp_flags);\n\t\treturn 1; /* Break things loose after complaining. */\n\t}\n\n\t/*\n\t * A CPU running for an extended time within the kernel can\n\t * delay RCU grace periods: (1) At age jiffies_to_sched_qs,\n\t * set .rcu_urgent_qs, (2) At age 2*jiffies_to_sched_qs, set\n\t * both .rcu_need_heavy_qs and .rcu_urgent_qs.  Note that the\n\t * unsynchronized assignments to the per-CPU rcu_need_heavy_qs\n\t * variable are safe because the assignments are repeated if this\n\t * CPU failed to pass through a quiescent state.  This code\n\t * also checks .jiffies_resched in case jiffies_to_sched_qs\n\t * is set way high.\n\t */\n\tjtsq = READ_ONCE(jiffies_to_sched_qs);\n\truqp = per_cpu_ptr(&rcu_data.rcu_urgent_qs, rdp->cpu);\n\trnhqp = &per_cpu(rcu_data.rcu_need_heavy_qs, rdp->cpu);\n\tif (!READ_ONCE(*rnhqp) &&\n\t    (time_after(jiffies, rcu_state.gp_start + jtsq * 2) ||\n\t     time_after(jiffies, rcu_state.jiffies_resched) ||\n\t     rcu_state.cbovld)) {\n\t\tWRITE_ONCE(*rnhqp, true);\n\t\t/* Store rcu_need_heavy_qs before rcu_urgent_qs. */\n\t\tsmp_store_release(ruqp, true);\n\t} else if (time_after(jiffies, rcu_state.gp_start + jtsq)) {\n\t\tWRITE_ONCE(*ruqp, true);\n\t}\n\n\t/*\n\t * NO_HZ_FULL CPUs can run in-kernel without rcu_sched_clock_irq!\n\t * The above code handles this, but only for straight cond_resched().\n\t * And some in-kernel loops check need_resched() before calling\n\t * cond_resched(), which defeats the above code for CPUs that are\n\t * running in-kernel with scheduling-clock interrupts disabled.\n\t * So hit them over the head with the resched_cpu() hammer!\n\t */\n\tif (tick_nohz_full_cpu(rdp->cpu) &&\n\t    (time_after(jiffies, READ_ONCE(rdp->last_fqs_resched) + jtsq * 3) ||\n\t     rcu_state.cbovld)) {\n\t\tWRITE_ONCE(*ruqp, true);\n\t\tresched_cpu(rdp->cpu);\n\t\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n\t}\n\n\t/*\n\t * If more than halfway to RCU CPU stall-warning time, invoke\n\t * resched_cpu() more frequently to try to loosen things up a bit.\n\t * Also check to see if the CPU is getting hammered with interrupts,\n\t * but only once per grace period, just to keep the IPIs down to\n\t * a dull roar.\n\t */\n\tif (time_after(jiffies, rcu_state.jiffies_resched)) {\n\t\tif (time_after(jiffies,\n\t\t\t       READ_ONCE(rdp->last_fqs_resched) + jtsq)) {\n\t\t\tresched_cpu(rdp->cpu);\n\t\t\tWRITE_ONCE(rdp->last_fqs_resched, jiffies);\n\t\t}\n\t\tif (IS_ENABLED(CONFIG_IRQ_WORK) &&\n\t\t    !rdp->rcu_iw_pending && rdp->rcu_iw_gp_seq != rnp->gp_seq &&\n\t\t    (rnp->ffmask & rdp->grpmask)) {\n\t\t\trdp->rcu_iw_pending = true;\n\t\t\trdp->rcu_iw_gp_seq = rnp->gp_seq;\n\t\t\tirq_work_queue_on(&rdp->rcu_iw, rdp->cpu);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* Trace-event wrapper function for trace_rcu_future_grace_period.  */\nstatic void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req, const char *s)\n{\n\ttrace_rcu_future_grace_period(rcu_state.name, READ_ONCE(rnp->gp_seq),\n\t\t\t\t      gp_seq_req, rnp->level,\n\t\t\t\t      rnp->grplo, rnp->grphi, s);\n}\n\n/*\n * rcu_start_this_gp - Request the start of a particular grace period\n * @rnp_start: The leaf node of the CPU from which to start.\n * @rdp: The rcu_data corresponding to the CPU from which to start.\n * @gp_seq_req: The gp_seq of the grace period to start.\n *\n * Start the specified grace period, as needed to handle newly arrived\n * callbacks.  The required future grace periods are recorded in each\n * rcu_node structure's ->gp_seq_needed field.  Returns true if there\n * is reason to awaken the grace-period kthread.\n *\n * The caller must hold the specified rcu_node structure's ->lock, which\n * is why the caller is responsible for waking the grace-period kthread.\n *\n * Returns true if the GP thread needs to be awakened else false.\n */\nstatic bool rcu_start_this_gp(struct rcu_node *rnp_start, struct rcu_data *rdp,\n\t\t\t      unsigned long gp_seq_req)\n{\n\tbool ret = false;\n\tstruct rcu_node *rnp;\n\n\t/*\n\t * Use funnel locking to either acquire the root rcu_node\n\t * structure's lock or bail out if the need for this grace period\n\t * has already been recorded -- or if that grace period has in\n\t * fact already started.  If there is already a grace period in\n\t * progress in a non-leaf node, no recording is needed because the\n\t * end of the grace period will scan the leaf rcu_node structures.\n\t * Note that rnp_start->lock must not be released.\n\t */\n\traw_lockdep_assert_held_rcu_node(rnp_start);\n\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req, TPS(\"Startleaf\"));\n\tfor (rnp = rnp_start; 1; rnp = rnp->parent) {\n\t\tif (rnp != rnp_start)\n\t\t\traw_spin_lock_rcu_node(rnp);\n\t\tif (ULONG_CMP_GE(rnp->gp_seq_needed, gp_seq_req) ||\n\t\t    rcu_seq_started(&rnp->gp_seq, gp_seq_req) ||\n\t\t    (rnp != rnp_start &&\n\t\t     rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))) {\n\t\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Prestarted\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tWRITE_ONCE(rnp->gp_seq_needed, gp_seq_req);\n\t\tif (rcu_seq_state(rcu_seq_current(&rnp->gp_seq))) {\n\t\t\t/*\n\t\t\t * We just marked the leaf or internal node, and a\n\t\t\t * grace period is in progress, which means that\n\t\t\t * rcu_gp_cleanup() will see the marking.  Bail to\n\t\t\t * reduce contention.\n\t\t\t */\n\t\t\ttrace_rcu_this_gp(rnp_start, rdp, gp_seq_req,\n\t\t\t\t\t  TPS(\"Startedleaf\"));\n\t\t\tgoto unlock_out;\n\t\t}\n\t\tif (rnp != rnp_start && rnp->parent != NULL)\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\tif (!rnp->parent)\n\t\t\tbreak;  /* At root, and perhaps also leaf. */\n\t}\n\n\t/* If GP already in progress, just leave, otherwise start one. */\n\tif (rcu_gp_in_progress()) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedleafroot\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"Startedroot\"));\n\tWRITE_ONCE(rcu_state.gp_flags, rcu_state.gp_flags | RCU_GP_FLAG_INIT);\n\tWRITE_ONCE(rcu_state.gp_req_activity, jiffies);\n\tif (!READ_ONCE(rcu_state.gp_kthread)) {\n\t\ttrace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS(\"NoGPkthread\"));\n\t\tgoto unlock_out;\n\t}\n\ttrace_rcu_grace_period(rcu_state.name, data_race(rcu_state.gp_seq), TPS(\"newreq\"));\n\tret = true;  /* Caller must wake GP kthread. */\nunlock_out:\n\t/* Push furthest requested GP to leaf node and rcu_data structure. */\n\tif (ULONG_CMP_LT(gp_seq_req, rnp->gp_seq_needed)) {\n\t\tWRITE_ONCE(rnp_start->gp_seq_needed, rnp->gp_seq_needed);\n\t\tWRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);\n\t}\n\tif (rnp != rnp_start)\n\t\traw_spin_unlock_rcu_node(rnp);\n\treturn ret;\n}\n\n/*\n * Clean up any old requests for the just-ended grace period.  Also return\n * whether any additional grace periods have been requested.\n */\nstatic bool rcu_future_gp_cleanup(struct rcu_node *rnp)\n{\n\tbool needmore;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\n\tneedmore = ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed);\n\tif (!needmore)\n\t\trnp->gp_seq_needed = rnp->gp_seq; /* Avoid counter wrap. */\n\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq,\n\t\t\t  needmore ? TPS(\"CleanupMore\") : TPS(\"Cleanup\"));\n\treturn needmore;\n}\n\n/*\n * Awaken the grace-period kthread.  Don't do a self-awaken (unless in an\n * interrupt or softirq handler, in which case we just might immediately\n * sleep upon return, resulting in a grace-period hang), and don't bother\n * awakening when there is nothing for the grace-period kthread to do\n * (as in several CPUs raced to awaken, we lost), and finally don't try\n * to awaken a kthread that has not yet been created.  If all those checks\n * are passed, track some debug information and awaken.\n *\n * So why do the self-wakeup when in an interrupt or softirq handler\n * in the grace-period kthread's context?  Because the kthread might have\n * been interrupted just as it was going to sleep, and just after the final\n * pre-sleep check of the awaken condition.  In this case, a wakeup really\n * is required, and is therefore supplied.\n */\nstatic void rcu_gp_kthread_wake(void)\n{\n\tstruct task_struct *t = READ_ONCE(rcu_state.gp_kthread);\n\n\tif ((current == t && !in_irq() && !in_serving_softirq()) ||\n\t    !READ_ONCE(rcu_state.gp_flags) || !t)\n\t\treturn;\n\tWRITE_ONCE(rcu_state.gp_wake_time, jiffies);\n\tWRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));\n\tswake_up_one(&rcu_state.gp_wq);\n}\n\n/*\n * If there is room, assign a ->gp_seq number to any callbacks on this\n * CPU that have not already been assigned.  Also accelerate any callbacks\n * that were previously assigned a ->gp_seq number that has since proven\n * to be too conservative, which can happen if callbacks get assigned a\n * ->gp_seq number while RCU is idle, but with reference to a non-root\n * rcu_node structure.  This function is idempotent, so it does not hurt\n * to call it repeatedly.  Returns an flag saying that we should awaken\n * the RCU grace-period kthread.\n *\n * The caller must hold rnp->lock with interrupts disabled.\n */\nstatic bool rcu_accelerate_cbs(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tunsigned long gp_seq_req;\n\tbool ret = false;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* If no pending (not yet ready to invoke) callbacks, nothing to do. */\n\tif (!rcu_segcblist_pend_cbs(&rdp->cblist))\n\t\treturn false;\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCbPreAcc\"));\n\n\t/*\n\t * Callbacks are often registered with incomplete grace-period\n\t * information.  Something about the fact that getting exact\n\t * information requires acquiring a global lock...  RCU therefore\n\t * makes a conservative estimate of the grace period number at which\n\t * a given callback will become ready to invoke.\tThe following\n\t * code checks this estimate and improves it when possible, thus\n\t * accelerating callback invocation to an earlier grace-period\n\t * number.\n\t */\n\tgp_seq_req = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (rcu_segcblist_accelerate(&rdp->cblist, gp_seq_req))\n\t\tret = rcu_start_this_gp(rnp, rdp, gp_seq_req);\n\n\t/* Trace depending on how much we were able to accelerate. */\n\tif (rcu_segcblist_restempty(&rdp->cblist, RCU_WAIT_TAIL))\n\t\ttrace_rcu_grace_period(rcu_state.name, gp_seq_req, TPS(\"AccWaitCB\"));\n\telse\n\t\ttrace_rcu_grace_period(rcu_state.name, gp_seq_req, TPS(\"AccReadyCB\"));\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCbPostAcc\"));\n\n\treturn ret;\n}\n\n/*\n * Similar to rcu_accelerate_cbs(), but does not require that the leaf\n * rcu_node structure's ->lock be held.  It consults the cached value\n * of ->gp_seq_needed in the rcu_data structure, and if that indicates\n * that a new grace-period request be made, invokes rcu_accelerate_cbs()\n * while holding the leaf rcu_node structure's ->lock.\n */\nstatic void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,\n\t\t\t\t\tstruct rcu_data *rdp)\n{\n\tunsigned long c;\n\tbool needwake;\n\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tc = rcu_seq_snap(&rcu_state.gp_seq);\n\tif (!READ_ONCE(rdp->gpwrap) && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {\n\t\t/* Old request still live, so mark recent callbacks. */\n\t\t(void)rcu_segcblist_accelerate(&rdp->cblist, c);\n\t\treturn;\n\t}\n\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}\n\n/*\n * Move any callbacks whose grace period has completed to the\n * RCU_DONE_TAIL sublist, then compact the remaining sublists and\n * assign ->gp_seq numbers to any callbacks in the RCU_NEXT_TAIL\n * sublist.  This function is idempotent, so it does not hurt to\n * invoke it repeatedly.  As long as it is not invoked -too- often...\n * Returns true if the RCU grace-period kthread needs to be awakened.\n *\n * The caller must hold rnp->lock with interrupts disabled.\n */\nstatic bool rcu_advance_cbs(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* If no pending (not yet ready to invoke) callbacks, nothing to do. */\n\tif (!rcu_segcblist_pend_cbs(&rdp->cblist))\n\t\treturn false;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL sublist.\n\t */\n\trcu_segcblist_advance(&rdp->cblist, rnp->gp_seq);\n\n\t/* Classify any remaining callbacks. */\n\treturn rcu_accelerate_cbs(rnp, rdp);\n}\n\n/*\n * Move and classify callbacks, but only if doing so won't require\n * that the RCU grace-period kthread be awakened.\n */\nstatic void __maybe_unused rcu_advance_cbs_nowake(struct rcu_node *rnp,\n\t\t\t\t\t\t  struct rcu_data *rdp)\n{\n\trcu_lockdep_assert_cblist_protected(rdp);\n\tif (!rcu_seq_state(rcu_seq_current(&rnp->gp_seq)) ||\n\t    !raw_spin_trylock_rcu_node(rnp))\n\t\treturn;\n\tWARN_ON_ONCE(rcu_advance_cbs(rnp, rdp));\n\traw_spin_unlock_rcu_node(rnp);\n}\n\n/*\n * In CONFIG_RCU_STRICT_GRACE_PERIOD=y kernels, attempt to generate a\n * quiescent state.  This is intended to be invoked when the CPU notices\n * a new grace period.\n */\nstatic void rcu_strict_gp_check_qs(void)\n{\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD)) {\n\t\trcu_read_lock();\n\t\trcu_read_unlock();\n\t}\n}\n\n/*\n * Update CPU-local rcu_data state to record the beginnings and ends of\n * grace periods.  The caller must hold the ->lock of the leaf rcu_node\n * structure corresponding to the current CPU, and must have irqs disabled.\n * Returns true if the grace-period kthread needs to be awakened.\n */\nstatic bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)\n{\n\tbool ret = false;\n\tbool need_qs;\n\tconst bool offloaded = rcu_rdp_is_offloaded(rdp);\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\tif (rdp->gp_seq == rnp->gp_seq)\n\t\treturn false; /* Nothing to do. */\n\n\t/* Handle the ends of any preceding grace periods first. */\n\tif (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\tif (!offloaded)\n\t\t\tret = rcu_advance_cbs(rnp, rdp); /* Advance CBs. */\n\t\trdp->core_needs_qs = false;\n\t\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuend\"));\n\t} else {\n\t\tif (!offloaded)\n\t\t\tret = rcu_accelerate_cbs(rnp, rdp); /* Recent CBs. */\n\t\tif (rdp->core_needs_qs)\n\t\t\trdp->core_needs_qs = !!(rnp->qsmask & rdp->grpmask);\n\t}\n\n\t/* Now handle the beginnings of any new-to-this-CPU grace periods. */\n\tif (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) {\n\t\t/*\n\t\t * If the current grace period is waiting for this CPU,\n\t\t * set up to detect a quiescent state, otherwise don't\n\t\t * go looking for one.\n\t\t */\n\t\ttrace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS(\"cpustart\"));\n\t\tneed_qs = !!(rnp->qsmask & rdp->grpmask);\n\t\trdp->cpu_no_qs.b.norm = need_qs;\n\t\trdp->core_needs_qs = need_qs;\n\t\tzero_cpu_stall_ticks(rdp);\n\t}\n\trdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */\n\tif (ULONG_CMP_LT(rdp->gp_seq_needed, rnp->gp_seq_needed) || rdp->gpwrap)\n\t\tWRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);\n\tWRITE_ONCE(rdp->gpwrap, false);\n\trcu_gpnum_ovf(rnp, rdp);\n\treturn ret;\n}\n\nstatic void note_gp_changes(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tbool needwake;\n\tstruct rcu_node *rnp;\n\n\tlocal_irq_save(flags);\n\trnp = rdp->mynode;\n\tif ((rdp->gp_seq == rcu_seq_current(&rnp->gp_seq) &&\n\t     !unlikely(READ_ONCE(rdp->gpwrap))) || /* w/out lock. */\n\t    !raw_spin_trylock_rcu_node(rnp)) { /* irqs already off, so later. */\n\t\tlocal_irq_restore(flags);\n\t\treturn;\n\t}\n\tneedwake = __note_gp_changes(rnp, rdp);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\trcu_strict_gp_check_qs();\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n}\n\nstatic void rcu_gp_slow(int delay)\n{\n\tif (delay > 0 &&\n\t    !(rcu_seq_ctr(rcu_state.gp_seq) %\n\t      (rcu_num_nodes * PER_RCU_NODE_PERIOD * delay)))\n\t\tschedule_timeout_idle(delay);\n}\n\nstatic unsigned long sleep_duration;\n\n/* Allow rcutorture to stall the grace-period kthread. */\nvoid rcu_gp_set_torture_wait(int duration)\n{\n\tif (IS_ENABLED(CONFIG_RCU_TORTURE_TEST) && duration > 0)\n\t\tWRITE_ONCE(sleep_duration, duration);\n}\nEXPORT_SYMBOL_GPL(rcu_gp_set_torture_wait);\n\n/* Actually implement the aforementioned wait. */\nstatic void rcu_gp_torture_wait(void)\n{\n\tunsigned long duration;\n\n\tif (!IS_ENABLED(CONFIG_RCU_TORTURE_TEST))\n\t\treturn;\n\tduration = xchg(&sleep_duration, 0UL);\n\tif (duration > 0) {\n\t\tpr_alert(\"%s: Waiting %lu jiffies\\n\", __func__, duration);\n\t\tschedule_timeout_idle(duration);\n\t\tpr_alert(\"%s: Wait complete\\n\", __func__);\n\t}\n}\n\n/*\n * Handler for on_each_cpu() to invoke the target CPU's RCU core\n * processing.\n */\nstatic void rcu_strict_gp_boundary(void *unused)\n{\n\tinvoke_rcu_core();\n}\n\n/*\n * Initialize a new grace period.  Return false if no grace period required.\n */\nstatic bool rcu_gp_init(void)\n{\n\tunsigned long firstseq;\n\tunsigned long flags;\n\tunsigned long oldmask;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\tif (!READ_ONCE(rcu_state.gp_flags)) {\n\t\t/* Spurious wakeup, tell caller to go back to sleep.  */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags, 0); /* Clear all flags: New GP. */\n\n\tif (WARN_ON_ONCE(rcu_gp_in_progress())) {\n\t\t/*\n\t\t * Grace period already in progress, don't start another.\n\t\t * Not supposed to be able to happen.\n\t\t */\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\treturn false;\n\t}\n\n\t/* Advance to a new grace period and initialize state. */\n\trecord_gp_stall_check_time();\n\t/* Record GP times before starting GP, hence rcu_seq_start(). */\n\trcu_seq_start(&rcu_state.gp_seq);\n\tASSERT_EXCLUSIVE_WRITER(rcu_state.gp_seq);\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"start\"));\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Apply per-leaf buffered online and offline operations to\n\t * the rcu_node tree. Note that this new grace period need not\n\t * wait for subsequent online CPUs, and that RCU hooks in the CPU\n\t * offlining path, when combined with checks in this function,\n\t * will handle CPUs that are currently going offline or that will\n\t * go offline later.  Please also refer to \"Hotplug CPU\" section\n\t * of RCU's Requirements documentation.\n\t */\n\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_ONOFF);\n\trcu_for_each_leaf_node(rnp) {\n\t\tsmp_mb(); // Pair with barriers used when updating ->ofl_seq to odd values.\n\t\tfirstseq = READ_ONCE(rnp->ofl_seq);\n\t\tif (firstseq & 0x1)\n\t\t\twhile (firstseq == READ_ONCE(rnp->ofl_seq))\n\t\t\t\tschedule_timeout_idle(1);  // Can't wake unless RCU is watching.\n\t\tsmp_mb(); // Pair with barriers used when updating ->ofl_seq to even values.\n\t\traw_spin_lock(&rcu_state.ofl_lock);\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (rnp->qsmaskinit == rnp->qsmaskinitnext &&\n\t\t    !rnp->wait_blkd_tasks) {\n\t\t\t/* Nothing to do on this leaf rcu_node structure. */\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record old state, apply changes to ->qsmaskinit field. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit = rnp->qsmaskinitnext;\n\n\t\t/* If zero-ness of ->qsmaskinit changed, propagate up tree. */\n\t\tif (!oldmask != !rnp->qsmaskinit) {\n\t\t\tif (!oldmask) { /* First online CPU for rcu_node. */\n\t\t\t\tif (!rnp->wait_blkd_tasks) /* Ever offline? */\n\t\t\t\t\trcu_init_new_rnp(rnp);\n\t\t\t} else if (rcu_preempt_has_tasks(rnp)) {\n\t\t\t\trnp->wait_blkd_tasks = true; /* blocked tasks */\n\t\t\t} else { /* Last offline CPU and can propagate. */\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If all waited-on tasks from prior grace period are\n\t\t * done, and if all this rcu_node structure's CPUs are\n\t\t * still offline, propagate up the rcu_node tree and\n\t\t * clear ->wait_blkd_tasks.  Otherwise, if one of this\n\t\t * rcu_node structure's CPUs has since come back online,\n\t\t * simply clear ->wait_blkd_tasks.\n\t\t */\n\t\tif (rnp->wait_blkd_tasks &&\n\t\t    (!rcu_preempt_has_tasks(rnp) || rnp->qsmaskinit)) {\n\t\t\trnp->wait_blkd_tasks = false;\n\t\t\tif (!rnp->qsmaskinit)\n\t\t\t\trcu_cleanup_dead_rnp(rnp);\n\t\t}\n\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\traw_spin_unlock(&rcu_state.ofl_lock);\n\t}\n\trcu_gp_slow(gp_preinit_delay); /* Races with CPU hotplug. */\n\n\t/*\n\t * Set the quiescent-state-needed bits in all the rcu_node\n\t * structures for all currently online CPUs in breadth-first\n\t * order, starting from the root rcu_node structure, relying on the\n\t * layout of the tree within the rcu_state.node[] array.  Note that\n\t * other CPUs will access only the leaves of the hierarchy, thus\n\t * seeing that no grace period is in progress, at least until the\n\t * corresponding leaf node has been initialized.\n\t *\n\t * The grace period cannot complete until the initialization\n\t * process finishes, because this kthread handles both.\n\t */\n\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_INIT);\n\trcu_for_each_node_breadth_first(rnp) {\n\t\trcu_gp_slow(gp_init_delay);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\trcu_preempt_check_blocked_tasks(rnp);\n\t\trnp->qsmask = rnp->qsmaskinit;\n\t\tWRITE_ONCE(rnp->gp_seq, rcu_state.gp_seq);\n\t\tif (rnp == rdp->mynode)\n\t\t\t(void)__note_gp_changes(rnp, rdp);\n\t\trcu_preempt_boost_start_gp(rnp);\n\t\ttrace_rcu_grace_period_init(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t    rnp->level, rnp->grplo,\n\t\t\t\t\t    rnp->grphi, rnp->qsmask);\n\t\t/* Quiescent states for tasks on any now-offline CPUs. */\n\t\tmask = rnp->qsmask & ~rnp->qsmaskinitnext;\n\t\trnp->rcu_gp_init_mask = mask;\n\t\tif ((mask || rnp->wait_blkd_tasks) && rcu_is_leaf_node(rnp))\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\telse\n\t\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t}\n\n\t// If strict, make all CPUs aware of new grace period.\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD))\n\t\ton_each_cpu(rcu_strict_gp_boundary, NULL, 0);\n\n\treturn true;\n}\n\n/*\n * Helper function for swait_event_idle_exclusive() wakeup at force-quiescent-state\n * time.\n */\nstatic bool rcu_gp_fqs_check_wake(int *gfp)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t// If under overload conditions, force an immediate FQS scan.\n\tif (*gfp & RCU_GP_FLAG_OVLD)\n\t\treturn true;\n\n\t// Someone like call_rcu() requested a force-quiescent-state scan.\n\t*gfp = READ_ONCE(rcu_state.gp_flags);\n\tif (*gfp & RCU_GP_FLAG_FQS)\n\t\treturn true;\n\n\t// The current grace period has completed.\n\tif (!READ_ONCE(rnp->qsmask) && !rcu_preempt_blocked_readers_cgp(rnp))\n\t\treturn true;\n\n\treturn false;\n}\n\n/*\n * Do one round of quiescent-state forcing.\n */\nstatic void rcu_gp_fqs(bool first_time)\n{\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\trcu_state.n_force_qs++;\n\tif (first_time) {\n\t\t/* Collect dyntick-idle snapshots. */\n\t\tforce_qs_rnp(dyntick_save_progress_counter);\n\t} else {\n\t\t/* Handle dyntick-idle and offline CPUs. */\n\t\tforce_qs_rnp(rcu_implicit_dynticks_qs);\n\t}\n\t/* Clear flag to prevent immediate re-entry. */\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   READ_ONCE(rcu_state.gp_flags) & ~RCU_GP_FLAG_FQS);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t}\n}\n\n/*\n * Loop doing repeated quiescent-state forcing until the grace period ends.\n */\nstatic void rcu_gp_fqs_loop(void)\n{\n\tbool first_gp_fqs;\n\tint gf = 0;\n\tunsigned long j;\n\tint ret;\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\tfirst_gp_fqs = true;\n\tj = READ_ONCE(jiffies_till_first_fqs);\n\tif (rcu_state.cbovld)\n\t\tgf = RCU_GP_FLAG_OVLD;\n\tret = 0;\n\tfor (;;) {\n\t\tif (!ret) {\n\t\t\tWRITE_ONCE(rcu_state.jiffies_force_qs, jiffies + j);\n\t\t\t/*\n\t\t\t * jiffies_force_qs before RCU_GP_WAIT_FQS state\n\t\t\t * update; required for stall checks.\n\t\t\t */\n\t\t\tsmp_wmb();\n\t\t\tWRITE_ONCE(rcu_state.jiffies_kick_kthreads,\n\t\t\t\t   jiffies + (j ? 3 * j : 2));\n\t\t}\n\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t       TPS(\"fqswait\"));\n\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_WAIT_FQS);\n\t\tret = swait_event_idle_timeout_exclusive(\n\t\t\t\trcu_state.gp_wq, rcu_gp_fqs_check_wake(&gf), j);\n\t\trcu_gp_torture_wait();\n\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_DOING_FQS);\n\t\t/* Locking provides needed memory barriers. */\n\t\t/* If grace period done, leave loop. */\n\t\tif (!READ_ONCE(rnp->qsmask) &&\n\t\t    !rcu_preempt_blocked_readers_cgp(rnp))\n\t\t\tbreak;\n\t\t/* If time for quiescent-state forcing, do it. */\n\t\tif (!time_after(rcu_state.jiffies_force_qs, jiffies) ||\n\t\t    (gf & (RCU_GP_FLAG_FQS | RCU_GP_FLAG_OVLD))) {\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"fqsstart\"));\n\t\t\trcu_gp_fqs(first_gp_fqs);\n\t\t\tgf = 0;\n\t\t\tif (first_gp_fqs) {\n\t\t\t\tfirst_gp_fqs = false;\n\t\t\t\tgf = rcu_state.cbovld ? RCU_GP_FLAG_OVLD : 0;\n\t\t\t}\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"fqsend\"));\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tret = 0; /* Force full wait till next FQS. */\n\t\t\tj = READ_ONCE(jiffies_till_next_fqs);\n\t\t} else {\n\t\t\t/* Deal with stray signal. */\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"fqswaitsig\"));\n\t\t\tret = 1; /* Keep old FQS timing. */\n\t\t\tj = jiffies;\n\t\t\tif (time_after(jiffies, rcu_state.jiffies_force_qs))\n\t\t\t\tj = 1;\n\t\t\telse\n\t\t\t\tj = rcu_state.jiffies_force_qs - j;\n\t\t\tgf = 0;\n\t\t}\n\t}\n}\n\n/*\n * Clean up after the old grace period.\n */\nstatic void rcu_gp_cleanup(void)\n{\n\tint cpu;\n\tbool needgp = false;\n\tunsigned long gp_duration;\n\tunsigned long new_gp_seq;\n\tbool offloaded;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp = rcu_get_root();\n\tstruct swait_queue_head *sq;\n\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\traw_spin_lock_irq_rcu_node(rnp);\n\trcu_state.gp_end = jiffies;\n\tgp_duration = rcu_state.gp_end - rcu_state.gp_start;\n\tif (gp_duration > rcu_state.gp_max)\n\t\trcu_state.gp_max = gp_duration;\n\n\t/*\n\t * We know the grace period is complete, but to everyone else\n\t * it appears to still be ongoing.  But it is also the case\n\t * that to everyone else it looks like there is nothing that\n\t * they can do to advance the grace period.  It is therefore\n\t * safe for us to drop the lock in order to mark the grace\n\t * period as completed in all of the rcu_node structures.\n\t */\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t/*\n\t * Propagate new ->gp_seq value to rcu_node structures so that\n\t * other CPUs don't have to wait until the start of the next grace\n\t * period to process their callbacks.  This also avoids some nasty\n\t * RCU grace-period initialization races by forcing the end of\n\t * the current grace period to be completely recorded in all of\n\t * the rcu_node structures before the beginning of the next grace\n\t * period is recorded in any of the rcu_node structures.\n\t */\n\tnew_gp_seq = rcu_state.gp_seq;\n\trcu_seq_end(&new_gp_seq);\n\trcu_for_each_node_breadth_first(rnp) {\n\t\traw_spin_lock_irq_rcu_node(rnp);\n\t\tif (WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)))\n\t\t\tdump_blkd_tasks(rnp, 10);\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tWRITE_ONCE(rnp->gp_seq, new_gp_seq);\n\t\trdp = this_cpu_ptr(&rcu_data);\n\t\tif (rnp == rdp->mynode)\n\t\t\tneedgp = __note_gp_changes(rnp, rdp) || needgp;\n\t\t/* smp_mb() provided by prior unlock-lock pair. */\n\t\tneedgp = rcu_future_gp_cleanup(rnp) || needgp;\n\t\t// Reset overload indication for CPUs no longer overloaded\n\t\tif (rcu_is_leaf_node(rnp))\n\t\t\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->cbovldmask) {\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tcheck_cb_ovld_locked(rdp, rnp);\n\t\t\t}\n\t\tsq = rcu_nocb_gp_get(rnp);\n\t\traw_spin_unlock_irq_rcu_node(rnp);\n\t\trcu_nocb_gp_cleanup(sq);\n\t\tcond_resched_tasks_rcu_qs();\n\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\trcu_gp_slow(gp_cleanup_delay);\n\t}\n\trnp = rcu_get_root();\n\traw_spin_lock_irq_rcu_node(rnp); /* GP before ->gp_seq update. */\n\n\t/* Declare grace period done, trace first to use old GP number. */\n\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS(\"end\"));\n\trcu_seq_end(&rcu_state.gp_seq);\n\tASSERT_EXCLUSIVE_WRITER(rcu_state.gp_seq);\n\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_IDLE);\n\t/* Check for GP requests since above loop. */\n\trdp = this_cpu_ptr(&rcu_data);\n\tif (!needgp && ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed)) {\n\t\ttrace_rcu_this_gp(rnp, rdp, rnp->gp_seq_needed,\n\t\t\t\t  TPS(\"CleanupMore\"));\n\t\tneedgp = true;\n\t}\n\t/* Advance CBs to reduce false positives below. */\n\toffloaded = rcu_rdp_is_offloaded(rdp);\n\tif ((offloaded || !rcu_accelerate_cbs(rnp, rdp)) && needgp) {\n\t\tWRITE_ONCE(rcu_state.gp_flags, RCU_GP_FLAG_INIT);\n\t\tWRITE_ONCE(rcu_state.gp_req_activity, jiffies);\n\t\ttrace_rcu_grace_period(rcu_state.name,\n\t\t\t\t       rcu_state.gp_seq,\n\t\t\t\t       TPS(\"newreq\"));\n\t} else {\n\t\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t\t   rcu_state.gp_flags & RCU_GP_FLAG_INIT);\n\t}\n\traw_spin_unlock_irq_rcu_node(rnp);\n\n\t// If strict, make all CPUs aware of the end of the old grace period.\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD))\n\t\ton_each_cpu(rcu_strict_gp_boundary, NULL, 0);\n}\n\n/*\n * Body of kthread that handles grace periods.\n */\nstatic int __noreturn rcu_gp_kthread(void *unused)\n{\n\trcu_bind_gp_kthread();\n\tfor (;;) {\n\n\t\t/* Handle grace-period start. */\n\t\tfor (;;) {\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"reqwait\"));\n\t\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_WAIT_GPS);\n\t\t\tswait_event_idle_exclusive(rcu_state.gp_wq,\n\t\t\t\t\t READ_ONCE(rcu_state.gp_flags) &\n\t\t\t\t\t RCU_GP_FLAG_INIT);\n\t\t\trcu_gp_torture_wait();\n\t\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_DONE_GPS);\n\t\t\t/* Locking provides needed memory barrier. */\n\t\t\tif (rcu_gp_init())\n\t\t\t\tbreak;\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\t\t\tWARN_ON(signal_pending(current));\n\t\t\ttrace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq,\n\t\t\t\t\t       TPS(\"reqwaitsig\"));\n\t\t}\n\n\t\t/* Handle quiescent-state forcing. */\n\t\trcu_gp_fqs_loop();\n\n\t\t/* Handle grace-period end. */\n\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_CLEANUP);\n\t\trcu_gp_cleanup();\n\t\tWRITE_ONCE(rcu_state.gp_state, RCU_GP_CLEANED);\n\t}\n}\n\n/*\n * Report a full set of quiescent states to the rcu_state data structure.\n * Invoke rcu_gp_kthread_wake() to awaken the grace-period kthread if\n * another grace period is required.  Whether we wake the grace-period\n * kthread or it awakens itself for the next round of quiescent-state\n * forcing, that kthread will clean up after the just-completed grace\n * period.  Note that the caller must hold rnp->lock, which is released\n * before return.\n */\nstatic void rcu_report_qs_rsp(unsigned long flags)\n\t__releases(rcu_get_root()->lock)\n{\n\traw_lockdep_assert_held_rcu_node(rcu_get_root());\n\tWARN_ON_ONCE(!rcu_gp_in_progress());\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rcu_get_root(), flags);\n\trcu_gp_kthread_wake();\n}\n\n/*\n * Similar to rcu_report_qs_rdp(), for which it is a helper function.\n * Allows quiescent states for a group of CPUs to be reported at one go\n * to the specified rcu_node structure, though all the CPUs in the group\n * must be represented by the same rcu_node structure (which need not be a\n * leaf rcu_node structure, though it often will be).  The gps parameter\n * is the grace-period snapshot, which means that the quiescent states\n * are valid only if rnp->gp_seq is equal to gps.  That structure's lock\n * must be held upon entry, and it is released before return.\n *\n * As a special case, if mask is zero, the bit-already-cleared check is\n * disabled.  This allows propagating quiescent state due to resumed tasks\n * during grace-period initialization.\n */\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long oldmask = 0;\n\tstruct rcu_node *rnp_c;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\n\t/* Walk up the rcu_node hierarchy. */\n\tfor (;;) {\n\t\tif ((!(rnp->qsmask & mask) && mask) || rnp->gp_seq != gps) {\n\n\t\t\t/*\n\t\t\t * Our bit has already been cleared, or the\n\t\t\t * relevant grace period is already over, so done.\n\t\t\t */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON_ONCE(oldmask); /* Any child must be all zeroed! */\n\t\tWARN_ON_ONCE(!rcu_is_leaf_node(rnp) &&\n\t\t\t     rcu_preempt_blocked_readers_cgp(rnp));\n\t\tWRITE_ONCE(rnp->qsmask, rnp->qsmask & ~mask);\n\t\ttrace_rcu_quiescent_state_report(rcu_state.name, rnp->gp_seq,\n\t\t\t\t\t\t mask, rnp->qsmask, rnp->level,\n\t\t\t\t\t\t rnp->grplo, rnp->grphi,\n\t\t\t\t\t\t !!rnp->gp_tasks);\n\t\tif (rnp->qsmask != 0 || rcu_preempt_blocked_readers_cgp(rnp)) {\n\n\t\t\t/* Other bits still set at this level, so done. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\treturn;\n\t\t}\n\t\trnp->completedqs = rnp->gp_seq;\n\t\tmask = rnp->grpmask;\n\t\tif (rnp->parent == NULL) {\n\n\t\t\t/* No more levels.  Exit loop holding root lock. */\n\n\t\t\tbreak;\n\t\t}\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\trnp_c = rnp;\n\t\trnp = rnp->parent;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\toldmask = READ_ONCE(rnp_c->qsmask);\n\t}\n\n\t/*\n\t * Get here if we are the last CPU to pass through a quiescent\n\t * state for this grace period.  Invoke rcu_report_qs_rsp()\n\t * to clean up and start the next grace period if one is needed.\n\t */\n\trcu_report_qs_rsp(flags); /* releases rnp->lock. */\n}\n\n/*\n * Record a quiescent state for all tasks that were previously queued\n * on the specified rcu_node structure and that were blocking the current\n * RCU grace period.  The caller must hold the corresponding rnp->lock with\n * irqs disabled, and this lock is released upon return, but irqs remain\n * disabled.\n */\nstatic void __maybe_unused\nrcu_report_unblock_qs_rnp(struct rcu_node *rnp, unsigned long flags)\n\t__releases(rnp->lock)\n{\n\tunsigned long gps;\n\tunsigned long mask;\n\tstruct rcu_node *rnp_p;\n\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (WARN_ON_ONCE(!IS_ENABLED(CONFIG_PREEMPT_RCU)) ||\n\t    WARN_ON_ONCE(rcu_preempt_blocked_readers_cgp(rnp)) ||\n\t    rnp->qsmask != 0) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;  /* Still need more quiescent states! */\n\t}\n\n\trnp->completedqs = rnp->gp_seq;\n\trnp_p = rnp->parent;\n\tif (rnp_p == NULL) {\n\t\t/*\n\t\t * Only one rcu_node structure in the tree, so don't\n\t\t * try to report up to its nonexistent parent!\n\t\t */\n\t\trcu_report_qs_rsp(flags);\n\t\treturn;\n\t}\n\n\t/* Report up the rest of the hierarchy, tracking current ->gp_seq. */\n\tgps = rnp->gp_seq;\n\tmask = rnp->grpmask;\n\traw_spin_unlock_rcu_node(rnp);\t/* irqs remain disabled. */\n\traw_spin_lock_rcu_node(rnp_p);\t/* irqs already disabled. */\n\trcu_report_qs_rnp(mask, rnp_p, gps, flags);\n}\n\n/*\n * Record a quiescent state for the specified CPU to that CPU's rcu_data\n * structure.  This must be called from the specified CPU.\n */\nstatic void\nrcu_report_qs_rdp(struct rcu_data *rdp)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tbool needwake = false;\n\tconst bool offloaded = rcu_rdp_is_offloaded(rdp);\n\tstruct rcu_node *rnp;\n\n\tWARN_ON_ONCE(rdp->cpu != smp_processor_id());\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tif (rdp->cpu_no_qs.b.norm || rdp->gp_seq != rnp->gp_seq ||\n\t    rdp->gpwrap) {\n\n\t\t/*\n\t\t * The grace period in which this quiescent state was\n\t\t * recorded has ended, so don't report it upwards.\n\t\t * We will instead need a new quiescent state that lies\n\t\t * within the current grace period.\n\t\t */\n\t\trdp->cpu_no_qs.b.norm = true;\t/* need qs for new gp. */\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\treturn;\n\t}\n\tmask = rdp->grpmask;\n\trdp->core_needs_qs = false;\n\tif ((rnp->qsmask & mask) == 0) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t} else {\n\t\t/*\n\t\t * This GP can't end until cpu checks in, so all of our\n\t\t * callbacks can be processed during the next GP.\n\t\t */\n\t\tif (!offloaded)\n\t\t\tneedwake = rcu_accelerate_cbs(rnp, rdp);\n\n\t\trcu_disable_urgency_upon_qs(rdp);\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t/* ^^^ Released rnp->lock */\n\t\tif (needwake)\n\t\t\trcu_gp_kthread_wake();\n\t}\n}\n\n/*\n * Check to see if there is a new grace period of which this CPU\n * is not yet aware, and if so, set up local rcu_data state for it.\n * Otherwise, see if this CPU has just passed through its first\n * quiescent state for this grace period, and record that fact if so.\n */\nstatic void\nrcu_check_quiescent_state(struct rcu_data *rdp)\n{\n\t/* Check for grace-period ends and beginnings. */\n\tnote_gp_changes(rdp);\n\n\t/*\n\t * Does this CPU still need to do its part for current grace period?\n\t * If no, return and let the other CPUs do their part as well.\n\t */\n\tif (!rdp->core_needs_qs)\n\t\treturn;\n\n\t/*\n\t * Was there a quiescent state since the beginning of the grace\n\t * period? If no, then exit and wait for the next call.\n\t */\n\tif (rdp->cpu_no_qs.b.norm)\n\t\treturn;\n\n\t/*\n\t * Tell RCU we are done (but rcu_report_qs_rdp() will be the\n\t * judge of that).\n\t */\n\trcu_report_qs_rdp(rdp);\n}\n\n/*\n * Near the end of the offline process.  Trace the fact that this CPU\n * is going offline.\n */\nint rcutree_dying_cpu(unsigned int cpu)\n{\n\tbool blkd;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU))\n\t\treturn 0;\n\n\tblkd = !!(rnp->qsmask & rdp->grpmask);\n\ttrace_rcu_grace_period(rcu_state.name, READ_ONCE(rnp->gp_seq),\n\t\t\t       blkd ? TPS(\"cpuofl-bgp\") : TPS(\"cpuofl\"));\n\treturn 0;\n}\n\n/*\n * All CPUs for the specified rcu_node structure have gone offline,\n * and all tasks that were preempted within an RCU read-side critical\n * section while running on one of those CPUs have since exited their RCU\n * read-side critical section.  Some other CPU is reporting this fact with\n * the specified rcu_node structure's ->lock held and interrupts disabled.\n * This function therefore goes up the tree of rcu_node structures,\n * clearing the corresponding bits in the ->qsmaskinit fields.  Note that\n * the leaf rcu_node structure's ->qsmaskinit field has already been\n * updated.\n *\n * This function does check that the specified rcu_node structure has\n * all CPUs offline and no blocked tasks, so it is OK to invoke it\n * prematurely.  That said, invoking it after the fact will cost you\n * a needless lock acquisition.  So once it has done its work, don't\n * invoke it again.\n */\nstatic void rcu_cleanup_dead_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU) ||\n\t    WARN_ON_ONCE(rnp_leaf->qsmaskinit) ||\n\t    WARN_ON_ONCE(rcu_preempt_has_tasks(rnp_leaf)))\n\t\treturn;\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (!rnp)\n\t\t\tbreak;\n\t\traw_spin_lock_rcu_node(rnp); /* irqs already disabled. */\n\t\trnp->qsmaskinit &= ~mask;\n\t\t/* Between grace periods, so better already be zero! */\n\t\tWARN_ON_ONCE(rnp->qsmask);\n\t\tif (rnp->qsmaskinit) {\n\t\t\traw_spin_unlock_rcu_node(rnp);\n\t\t\t/* irqs remain disabled. */\n\t\t\treturn;\n\t\t}\n\t\traw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */\n\t}\n}\n\n/*\n * The CPU has been completely removed, and some other CPU is reporting\n * this fact from process context.  Do the remainder of the cleanup.\n * There can only be one CPU hotplug operation at a time, so no need for\n * explicit locking.\n */\nint rcutree_dead_cpu(unsigned int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;  /* Outgoing CPU's rdp & rnp. */\n\n\tif (!IS_ENABLED(CONFIG_HOTPLUG_CPU))\n\t\treturn 0;\n\n\tWRITE_ONCE(rcu_state.n_online_cpus, rcu_state.n_online_cpus - 1);\n\t/* Adjust any no-longer-needed kthreads. */\n\trcu_boost_kthread_setaffinity(rnp, -1);\n\t/* Do any needed no-CB deferred wakeups from this CPU. */\n\tdo_nocb_deferred_wakeup(per_cpu_ptr(&rcu_data, cpu));\n\n\t// Stop-machine done, so allow nohz_full to disable tick.\n\ttick_dep_clear(TICK_DEP_BIT_RCU);\n\treturn 0;\n}\n\n/*\n * Invoke any RCU callbacks that have made it to the end of their grace\n * period.  Thottle as specified by rdp->blimit.\n */\nstatic void rcu_do_batch(struct rcu_data *rdp)\n{\n\tint div;\n\tbool __maybe_unused empty;\n\tunsigned long flags;\n\tconst bool offloaded = rcu_rdp_is_offloaded(rdp);\n\tstruct rcu_head *rhp;\n\tstruct rcu_cblist rcl = RCU_CBLIST_INITIALIZER(rcl);\n\tlong bl, count = 0;\n\tlong pending, tlimit = 0;\n\n\t/* If no callbacks are ready, just return. */\n\tif (!rcu_segcblist_ready_cbs(&rdp->cblist)) {\n\t\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), 0);\n\t\ttrace_rcu_batch_end(rcu_state.name, 0,\n\t\t\t\t    !rcu_segcblist_empty(&rdp->cblist),\n\t\t\t\t    need_resched(), is_idle_task(current),\n\t\t\t\t    rcu_is_callbacks_kthread());\n\t\treturn;\n\t}\n\n\t/*\n\t * Extract the list of ready callbacks, disabling to prevent\n\t * races with call_rcu() from interrupt handlers.  Leave the\n\t * callback counts, as rcu_barrier() needs to be conservative.\n\t */\n\tlocal_irq_save(flags);\n\trcu_nocb_lock(rdp);\n\tWARN_ON_ONCE(cpu_is_offline(smp_processor_id()));\n\tpending = rcu_segcblist_n_cbs(&rdp->cblist);\n\tdiv = READ_ONCE(rcu_divisor);\n\tdiv = div < 0 ? 7 : div > sizeof(long) * 8 - 2 ? sizeof(long) * 8 - 2 : div;\n\tbl = max(rdp->blimit, pending >> div);\n\tif (unlikely(bl > 100)) {\n\t\tlong rrn = READ_ONCE(rcu_resched_ns);\n\n\t\trrn = rrn < NSEC_PER_MSEC ? NSEC_PER_MSEC : rrn > NSEC_PER_SEC ? NSEC_PER_SEC : rrn;\n\t\ttlimit = local_clock() + rrn;\n\t}\n\ttrace_rcu_batch_start(rcu_state.name,\n\t\t\t      rcu_segcblist_n_cbs(&rdp->cblist), bl);\n\trcu_segcblist_extract_done_cbs(&rdp->cblist, &rcl);\n\tif (offloaded)\n\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCbDequeued\"));\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\t/* Invoke callbacks. */\n\ttick_dep_set_task(current, TICK_DEP_BIT_RCU);\n\trhp = rcu_cblist_dequeue(&rcl);\n\n\tfor (; rhp; rhp = rcu_cblist_dequeue(&rcl)) {\n\t\trcu_callback_t f;\n\n\t\tcount++;\n\t\tdebug_rcu_head_unqueue(rhp);\n\n\t\trcu_lock_acquire(&rcu_callback_map);\n\t\ttrace_rcu_invoke_callback(rcu_state.name, rhp);\n\n\t\tf = rhp->func;\n\t\tWRITE_ONCE(rhp->func, (rcu_callback_t)0L);\n\t\tf(rhp);\n\n\t\trcu_lock_release(&rcu_callback_map);\n\n\t\t/*\n\t\t * Stop only if limit reached and CPU has something to do.\n\t\t */\n\t\tif (count >= bl && !offloaded &&\n\t\t    (need_resched() ||\n\t\t     (!is_idle_task(current) && !rcu_is_callbacks_kthread())))\n\t\t\tbreak;\n\t\tif (unlikely(tlimit)) {\n\t\t\t/* only call local_clock() every 32 callbacks */\n\t\t\tif (likely((count & 31) || local_clock() < tlimit))\n\t\t\t\tcontinue;\n\t\t\t/* Exceeded the time limit, so leave. */\n\t\t\tbreak;\n\t\t}\n\t\tif (!in_serving_softirq()) {\n\t\t\tlocal_bh_enable();\n\t\t\tlockdep_assert_irqs_enabled();\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t\tlockdep_assert_irqs_enabled();\n\t\t\tlocal_bh_disable();\n\t\t}\n\t}\n\n\tlocal_irq_save(flags);\n\trcu_nocb_lock(rdp);\n\trdp->n_cbs_invoked += count;\n\ttrace_rcu_batch_end(rcu_state.name, count, !!rcl.head, need_resched(),\n\t\t\t    is_idle_task(current), rcu_is_callbacks_kthread());\n\n\t/* Update counts and requeue any remaining callbacks. */\n\trcu_segcblist_insert_done_cbs(&rdp->cblist, &rcl);\n\trcu_segcblist_add_len(&rdp->cblist, -count);\n\n\t/* Reinstate batch limit if we have worked down the excess. */\n\tcount = rcu_segcblist_n_cbs(&rdp->cblist);\n\tif (rdp->blimit >= DEFAULT_MAX_RCU_BLIMIT && count <= qlowmark)\n\t\trdp->blimit = blimit;\n\n\t/* Reset ->qlen_last_fqs_check trigger if enough CBs have drained. */\n\tif (count == 0 && rdp->qlen_last_fqs_check != 0) {\n\t\trdp->qlen_last_fqs_check = 0;\n\t\trdp->n_force_qs_snap = rcu_state.n_force_qs;\n\t} else if (count < rdp->qlen_last_fqs_check - qhimark)\n\t\trdp->qlen_last_fqs_check = count;\n\n\t/*\n\t * The following usually indicates a double call_rcu().  To track\n\t * this down, try building with CONFIG_DEBUG_OBJECTS_RCU_HEAD=y.\n\t */\n\tempty = rcu_segcblist_empty(&rdp->cblist);\n\tWARN_ON_ONCE(count == 0 && !empty);\n\tWARN_ON_ONCE(!IS_ENABLED(CONFIG_RCU_NOCB_CPU) &&\n\t\t     count != 0 && empty);\n\tWARN_ON_ONCE(count == 0 && rcu_segcblist_n_segment_cbs(&rdp->cblist) != 0);\n\tWARN_ON_ONCE(!empty && rcu_segcblist_n_segment_cbs(&rdp->cblist) == 0);\n\n\trcu_nocb_unlock_irqrestore(rdp, flags);\n\n\t/* Re-invoke RCU core processing if there are callbacks remaining. */\n\tif (!offloaded && rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\tinvoke_rcu_core();\n\ttick_dep_clear_task(current, TICK_DEP_BIT_RCU);\n}\n\n/*\n * This function is invoked from each scheduling-clock interrupt,\n * and checks to see if this CPU is in a non-context-switch quiescent\n * state, for example, user mode or idle loop.  It also schedules RCU\n * core processing.  If the current grace period has gone on too long,\n * it will ask the scheduler to manufacture a context switch for the sole\n * purpose of providing a providing the needed quiescent state.\n */\nvoid rcu_sched_clock_irq(int user)\n{\n\ttrace_rcu_utilization(TPS(\"Start scheduler-tick\"));\n\tlockdep_assert_irqs_disabled();\n\traw_cpu_inc(rcu_data.ticks_this_gp);\n\t/* The load-acquire pairs with the store-release setting to true. */\n\tif (smp_load_acquire(this_cpu_ptr(&rcu_data.rcu_urgent_qs))) {\n\t\t/* Idle and userspace execution already are quiescent states. */\n\t\tif (!rcu_is_cpu_rrupt_from_idle() && !user) {\n\t\t\tset_tsk_need_resched(current);\n\t\t\tset_preempt_need_resched();\n\t\t}\n\t\t__this_cpu_write(rcu_data.rcu_urgent_qs, false);\n\t}\n\trcu_flavor_sched_clock_irq(user);\n\tif (rcu_pending(user))\n\t\tinvoke_rcu_core();\n\tlockdep_assert_irqs_disabled();\n\n\ttrace_rcu_utilization(TPS(\"End scheduler-tick\"));\n}\n\n/*\n * Scan the leaf rcu_node structures.  For each structure on which all\n * CPUs have reported a quiescent state and on which there are tasks\n * blocking the current grace period, initiate RCU priority boosting.\n * Otherwise, invoke the specified function to check dyntick state for\n * each CPU that has not yet reported a quiescent state.\n */\nstatic void force_qs_rnp(int (*f)(struct rcu_data *rdp))\n{\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trcu_state.cbovld = rcu_state.cbovldnext;\n\trcu_state.cbovldnext = false;\n\trcu_for_each_leaf_node(rnp) {\n\t\tcond_resched_tasks_rcu_qs();\n\t\tmask = 0;\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t\trcu_state.cbovldnext |= !!rnp->cbovldmask;\n\t\tif (rnp->qsmask == 0) {\n\t\t\tif (rcu_preempt_blocked_readers_cgp(rnp)) {\n\t\t\t\t/*\n\t\t\t\t * No point in scanning bits because they\n\t\t\t\t * are all zero.  But we might need to\n\t\t\t\t * priority-boost blocked readers.\n\t\t\t\t */\n\t\t\t\trcu_initiate_boost(rnp, flags);\n\t\t\t\t/* rcu_initiate_boost() releases rnp->lock */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tfor_each_leaf_node_cpu_mask(rnp, cpu, rnp->qsmask) {\n\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\tif (f(rdp)) {\n\t\t\t\tmask |= rdp->grpmask;\n\t\t\t\trcu_disable_urgency_upon_qs(rdp);\n\t\t\t}\n\t\t}\n\t\tif (mask != 0) {\n\t\t\t/* Idle/offline CPUs, report (releases rnp->lock). */\n\t\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\t} else {\n\t\t\t/* Nothing to do here, so just drop the lock. */\n\t\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t\t}\n\t}\n}\n\n/*\n * Force quiescent states on reluctant CPUs, and also detect which\n * CPUs are in dyntick-idle mode.\n */\nvoid rcu_force_quiescent_state(void)\n{\n\tunsigned long flags;\n\tbool ret;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_old = NULL;\n\n\t/* Funnel through hierarchy to reduce memory contention. */\n\trnp = __this_cpu_read(rcu_data.mynode);\n\tfor (; rnp != NULL; rnp = rnp->parent) {\n\t\tret = (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) ||\n\t\t       !raw_spin_trylock(&rnp->fqslock);\n\t\tif (rnp_old != NULL)\n\t\t\traw_spin_unlock(&rnp_old->fqslock);\n\t\tif (ret)\n\t\t\treturn;\n\t\trnp_old = rnp;\n\t}\n\t/* rnp_old == rcu_get_root(), rnp == NULL. */\n\n\t/* Reached the root of the rcu_node tree, acquire lock. */\n\traw_spin_lock_irqsave_rcu_node(rnp_old, flags);\n\traw_spin_unlock(&rnp_old->fqslock);\n\tif (READ_ONCE(rcu_state.gp_flags) & RCU_GP_FLAG_FQS) {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\t\treturn;  /* Someone beat us to it. */\n\t}\n\tWRITE_ONCE(rcu_state.gp_flags,\n\t\t   READ_ONCE(rcu_state.gp_flags) | RCU_GP_FLAG_FQS);\n\traw_spin_unlock_irqrestore_rcu_node(rnp_old, flags);\n\trcu_gp_kthread_wake();\n}\nEXPORT_SYMBOL_GPL(rcu_force_quiescent_state);\n\n// Workqueue handler for an RCU reader for kernels enforcing struct RCU\n// grace periods.\nstatic void strict_work_handler(struct work_struct *work)\n{\n\trcu_read_lock();\n\trcu_read_unlock();\n}\n\n/* Perform RCU core processing work for the current CPU.  */\nstatic __latent_entropy void rcu_core(void)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = raw_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\tconst bool do_batch = !rcu_segcblist_completely_offloaded(&rdp->cblist);\n\n\tif (cpu_is_offline(smp_processor_id()))\n\t\treturn;\n\ttrace_rcu_utilization(TPS(\"Start RCU core\"));\n\tWARN_ON_ONCE(!rdp->beenonline);\n\n\t/* Report any deferred quiescent states if preemption enabled. */\n\tif (!(preempt_count() & PREEMPT_MASK)) {\n\t\trcu_preempt_deferred_qs(current);\n\t} else if (rcu_preempt_need_deferred_qs(current)) {\n\t\tset_tsk_need_resched(current);\n\t\tset_preempt_need_resched();\n\t}\n\n\t/* Update RCU state based on any recent quiescent states. */\n\trcu_check_quiescent_state(rdp);\n\n\t/* No grace period and unregistered callbacks? */\n\tif (!rcu_gp_in_progress() &&\n\t    rcu_segcblist_is_enabled(&rdp->cblist) && do_batch) {\n\t\trcu_nocb_lock_irqsave(rdp, flags);\n\t\tif (!rcu_segcblist_restempty(&rdp->cblist, RCU_NEXT_READY_TAIL))\n\t\t\trcu_accelerate_cbs_unlocked(rnp, rdp);\n\t\trcu_nocb_unlock_irqrestore(rdp, flags);\n\t}\n\n\trcu_check_gp_start_stall(rnp, rdp, rcu_jiffies_till_stall_check());\n\n\t/* If there are callbacks ready, invoke them. */\n\tif (do_batch && rcu_segcblist_ready_cbs(&rdp->cblist) &&\n\t    likely(READ_ONCE(rcu_scheduler_fully_active)))\n\t\trcu_do_batch(rdp);\n\n\t/* Do any needed deferred wakeups of rcuo kthreads. */\n\tdo_nocb_deferred_wakeup(rdp);\n\ttrace_rcu_utilization(TPS(\"End RCU core\"));\n\n\t// If strict GPs, schedule an RCU reader in a clean environment.\n\tif (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD))\n\t\tqueue_work_on(rdp->cpu, rcu_gp_wq, &rdp->strict_work);\n}\n\nstatic void rcu_core_si(struct softirq_action *h)\n{\n\trcu_core();\n}\n\nstatic void rcu_wake_cond(struct task_struct *t, int status)\n{\n\t/*\n\t * If the thread is yielding, only wake it when this\n\t * is invoked from idle\n\t */\n\tif (t && (status != RCU_KTHREAD_YIELDING || is_idle_task(current)))\n\t\twake_up_process(t);\n}\n\nstatic void invoke_rcu_core_kthread(void)\n{\n\tstruct task_struct *t;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__this_cpu_write(rcu_data.rcu_cpu_has_work, 1);\n\tt = __this_cpu_read(rcu_data.rcu_cpu_kthread_task);\n\tif (t != NULL && t != current)\n\t\trcu_wake_cond(t, __this_cpu_read(rcu_data.rcu_cpu_kthread_status));\n\tlocal_irq_restore(flags);\n}\n\n/*\n * Wake up this CPU's rcuc kthread to do RCU core processing.\n */\nstatic void invoke_rcu_core(void)\n{\n\tif (!cpu_online(smp_processor_id()))\n\t\treturn;\n\tif (use_softirq)\n\t\traise_softirq(RCU_SOFTIRQ);\n\telse\n\t\tinvoke_rcu_core_kthread();\n}\n\nstatic void rcu_cpu_kthread_park(unsigned int cpu)\n{\n\tper_cpu(rcu_data.rcu_cpu_kthread_status, cpu) = RCU_KTHREAD_OFFCPU;\n}\n\nstatic int rcu_cpu_kthread_should_run(unsigned int cpu)\n{\n\treturn __this_cpu_read(rcu_data.rcu_cpu_has_work);\n}\n\n/*\n * Per-CPU kernel thread that invokes RCU callbacks.  This replaces\n * the RCU softirq used in configurations of RCU that do not support RCU\n * priority boosting.\n */\nstatic void rcu_cpu_kthread(unsigned int cpu)\n{\n\tunsigned int *statusp = this_cpu_ptr(&rcu_data.rcu_cpu_kthread_status);\n\tchar work, *workp = this_cpu_ptr(&rcu_data.rcu_cpu_has_work);\n\tint spincnt;\n\n\ttrace_rcu_utilization(TPS(\"Start CPU kthread@rcu_run\"));\n\tfor (spincnt = 0; spincnt < 10; spincnt++) {\n\t\tlocal_bh_disable();\n\t\t*statusp = RCU_KTHREAD_RUNNING;\n\t\tlocal_irq_disable();\n\t\twork = *workp;\n\t\t*workp = 0;\n\t\tlocal_irq_enable();\n\t\tif (work)\n\t\t\trcu_core();\n\t\tlocal_bh_enable();\n\t\tif (*workp == 0) {\n\t\t\ttrace_rcu_utilization(TPS(\"End CPU kthread@rcu_wait\"));\n\t\t\t*statusp = RCU_KTHREAD_WAITING;\n\t\t\treturn;\n\t\t}\n\t}\n\t*statusp = RCU_KTHREAD_YIELDING;\n\ttrace_rcu_utilization(TPS(\"Start CPU kthread@rcu_yield\"));\n\tschedule_timeout_idle(2);\n\ttrace_rcu_utilization(TPS(\"End CPU kthread@rcu_yield\"));\n\t*statusp = RCU_KTHREAD_WAITING;\n}\n\nstatic struct smp_hotplug_thread rcu_cpu_thread_spec = {\n\t.store\t\t\t= &rcu_data.rcu_cpu_kthread_task,\n\t.thread_should_run\t= rcu_cpu_kthread_should_run,\n\t.thread_fn\t\t= rcu_cpu_kthread,\n\t.thread_comm\t\t= \"rcuc/%u\",\n\t.setup\t\t\t= rcu_cpu_kthread_setup,\n\t.park\t\t\t= rcu_cpu_kthread_park,\n};\n\n/*\n * Spawn per-CPU RCU core processing kthreads.\n */\nstatic int __init rcu_spawn_core_kthreads(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(rcu_data.rcu_cpu_has_work, cpu) = 0;\n\tif (!IS_ENABLED(CONFIG_RCU_BOOST) && use_softirq)\n\t\treturn 0;\n\tWARN_ONCE(smpboot_register_percpu_thread(&rcu_cpu_thread_spec),\n\t\t  \"%s: Could not start rcuc kthread, OOM is now expected behavior\\n\", __func__);\n\treturn 0;\n}\nearly_initcall(rcu_spawn_core_kthreads);\n\n/*\n * Handle any core-RCU processing required by a call_rcu() invocation.\n */\nstatic void __call_rcu_core(struct rcu_data *rdp, struct rcu_head *head,\n\t\t\t    unsigned long flags)\n{\n\t/*\n\t * If called from an extended quiescent state, invoke the RCU\n\t * core in order to force a re-evaluation of RCU's idleness.\n\t */\n\tif (!rcu_is_watching())\n\t\tinvoke_rcu_core();\n\n\t/* If interrupts were disabled or CPU offline, don't invoke RCU core. */\n\tif (irqs_disabled_flags(flags) || cpu_is_offline(smp_processor_id()))\n\t\treturn;\n\n\t/*\n\t * Force the grace period if too many callbacks or too long waiting.\n\t * Enforce hysteresis, and don't invoke rcu_force_quiescent_state()\n\t * if some other CPU has recently done so.  Also, don't bother\n\t * invoking rcu_force_quiescent_state() if the newly enqueued callback\n\t * is the only one waiting for a grace period to complete.\n\t */\n\tif (unlikely(rcu_segcblist_n_cbs(&rdp->cblist) >\n\t\t     rdp->qlen_last_fqs_check + qhimark)) {\n\n\t\t/* Are we ignoring a completed grace period? */\n\t\tnote_gp_changes(rdp);\n\n\t\t/* Start a new grace period if one not already started. */\n\t\tif (!rcu_gp_in_progress()) {\n\t\t\trcu_accelerate_cbs_unlocked(rdp->mynode, rdp);\n\t\t} else {\n\t\t\t/* Give the grace period a kick. */\n\t\t\trdp->blimit = DEFAULT_MAX_RCU_BLIMIT;\n\t\t\tif (rcu_state.n_force_qs == rdp->n_force_qs_snap &&\n\t\t\t    rcu_segcblist_first_pend_cb(&rdp->cblist) != head)\n\t\t\t\trcu_force_quiescent_state();\n\t\t\trdp->n_force_qs_snap = rcu_state.n_force_qs;\n\t\t\trdp->qlen_last_fqs_check = rcu_segcblist_n_cbs(&rdp->cblist);\n\t\t}\n\t}\n}\n\n/*\n * RCU callback function to leak a callback.\n */\nstatic void rcu_leak_callback(struct rcu_head *rhp)\n{\n}\n\n/*\n * Check and if necessary update the leaf rcu_node structure's\n * ->cbovldmask bit corresponding to the current CPU based on that CPU's\n * number of queued RCU callbacks.  The caller must hold the leaf rcu_node\n * structure's ->lock.\n */\nstatic void check_cb_ovld_locked(struct rcu_data *rdp, struct rcu_node *rnp)\n{\n\traw_lockdep_assert_held_rcu_node(rnp);\n\tif (qovld_calc <= 0)\n\t\treturn; // Early boot and wildcard value set.\n\tif (rcu_segcblist_n_cbs(&rdp->cblist) >= qovld_calc)\n\t\tWRITE_ONCE(rnp->cbovldmask, rnp->cbovldmask | rdp->grpmask);\n\telse\n\t\tWRITE_ONCE(rnp->cbovldmask, rnp->cbovldmask & ~rdp->grpmask);\n}\n\n/*\n * Check and if necessary update the leaf rcu_node structure's\n * ->cbovldmask bit corresponding to the current CPU based on that CPU's\n * number of queued RCU callbacks.  No locks need be held, but the\n * caller must have disabled interrupts.\n *\n * Note that this function ignores the possibility that there are a lot\n * of callbacks all of which have already seen the end of their respective\n * grace periods.  This omission is due to the need for no-CBs CPUs to\n * be holding ->nocb_lock to do this check, which is too heavy for a\n * common-case operation.\n */\nstatic void check_cb_ovld(struct rcu_data *rdp)\n{\n\tstruct rcu_node *const rnp = rdp->mynode;\n\n\tif (qovld_calc <= 0 ||\n\t    ((rcu_segcblist_n_cbs(&rdp->cblist) >= qovld_calc) ==\n\t     !!(READ_ONCE(rnp->cbovldmask) & rdp->grpmask)))\n\t\treturn; // Early boot wildcard value or already set correctly.\n\traw_spin_lock_rcu_node(rnp);\n\tcheck_cb_ovld_locked(rdp, rnp);\n\traw_spin_unlock_rcu_node(rnp);\n}\n\n/* Helper function for call_rcu() and friends.  */\nstatic void\n__call_rcu(struct rcu_head *head, rcu_callback_t func)\n{\n\tstatic atomic_t doublefrees;\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tbool was_alldone;\n\n\t/* Misaligned rcu_head! */\n\tWARN_ON_ONCE((unsigned long)head & (sizeof(void *) - 1));\n\n\tif (debug_rcu_head_queue(head)) {\n\t\t/*\n\t\t * Probable double call_rcu(), so leak the callback.\n\t\t * Use rcu:rcu_callback trace event to find the previous\n\t\t * time callback was passed to __call_rcu().\n\t\t */\n\t\tif (atomic_inc_return(&doublefrees) < 4) {\n\t\t\tpr_err(\"%s(): Double-freed CB %p->%pS()!!!  \", __func__, head, head->func);\n\t\t\tmem_dump_obj(head);\n\t\t}\n\t\tWRITE_ONCE(head->func, rcu_leak_callback);\n\t\treturn;\n\t}\n\thead->func = func;\n\thead->next = NULL;\n\tlocal_irq_save(flags);\n\tkasan_record_aux_stack(head);\n\trdp = this_cpu_ptr(&rcu_data);\n\n\t/* Add the callback to our list. */\n\tif (unlikely(!rcu_segcblist_is_enabled(&rdp->cblist))) {\n\t\t// This can trigger due to call_rcu() from offline CPU:\n\t\tWARN_ON_ONCE(rcu_scheduler_active != RCU_SCHEDULER_INACTIVE);\n\t\tWARN_ON_ONCE(!rcu_is_watching());\n\t\t// Very early boot, before rcu_init().  Initialize if needed\n\t\t// and then drop through to queue the callback.\n\t\tif (rcu_segcblist_empty(&rdp->cblist))\n\t\t\trcu_segcblist_init(&rdp->cblist);\n\t}\n\n\tcheck_cb_ovld(rdp);\n\tif (rcu_nocb_try_bypass(rdp, head, &was_alldone, flags))\n\t\treturn; // Enqueued onto ->nocb_bypass, so just leave.\n\t// If no-CBs CPU gets here, rcu_nocb_try_bypass() acquired ->nocb_lock.\n\trcu_segcblist_enqueue(&rdp->cblist, head);\n\tif (__is_kvfree_rcu_offset((unsigned long)func))\n\t\ttrace_rcu_kvfree_callback(rcu_state.name, head,\n\t\t\t\t\t (unsigned long)func,\n\t\t\t\t\t rcu_segcblist_n_cbs(&rdp->cblist));\n\telse\n\t\ttrace_rcu_callback(rcu_state.name, head,\n\t\t\t\t   rcu_segcblist_n_cbs(&rdp->cblist));\n\n\ttrace_rcu_segcb_stats(&rdp->cblist, TPS(\"SegCBQueued\"));\n\n\t/* Go handle any RCU core processing required. */\n\tif (unlikely(rcu_rdp_is_offloaded(rdp))) {\n\t\t__call_rcu_nocb_wake(rdp, was_alldone, flags); /* unlocks */\n\t} else {\n\t\t__call_rcu_core(rdp, head, flags);\n\t\tlocal_irq_restore(flags);\n\t}\n}\n\n/**\n * call_rcu() - Queue an RCU callback for invocation after a grace period.\n * @head: structure to be used for queueing the RCU updates.\n * @func: actual callback function to be invoked after the grace period\n *\n * The callback function will be invoked some time after a full grace\n * period elapses, in other words after all pre-existing RCU read-side\n * critical sections have completed.  However, the callback function\n * might well execute concurrently with RCU read-side critical sections\n * that started after call_rcu() was invoked.  RCU read-side critical\n * sections are delimited by rcu_read_lock() and rcu_read_unlock(), and\n * may be nested.  In addition, regions of code across which interrupts,\n * preemption, or softirqs have been disabled also serve as RCU read-side\n * critical sections.  This includes hardware interrupt handlers, softirq\n * handlers, and NMI handlers.\n *\n * Note that all CPUs must agree that the grace period extended beyond\n * all pre-existing RCU read-side critical section.  On systems with more\n * than one CPU, this means that when \"func()\" is invoked, each CPU is\n * guaranteed to have executed a full memory barrier since the end of its\n * last RCU read-side critical section whose beginning preceded the call\n * to call_rcu().  It also means that each CPU executing an RCU read-side\n * critical section that continues beyond the start of \"func()\" must have\n * executed a memory barrier after the call_rcu() but before the beginning\n * of that RCU read-side critical section.  Note that these guarantees\n * include CPUs that are offline, idle, or executing in user mode, as\n * well as CPUs that are executing in the kernel.\n *\n * Furthermore, if CPU A invoked call_rcu() and CPU B invoked the\n * resulting RCU callback function \"func()\", then both CPU A and CPU B are\n * guaranteed to execute a full memory barrier during the time interval\n * between the call to call_rcu() and the invocation of \"func()\" -- even\n * if CPU A and CPU B are the same CPU (but again only if the system has\n * more than one CPU).\n */\nvoid call_rcu(struct rcu_head *head, rcu_callback_t func)\n{\n\t__call_rcu(head, func);\n}\nEXPORT_SYMBOL_GPL(call_rcu);\n\n\n/* Maximum number of jiffies to wait before draining a batch. */\n#define KFREE_DRAIN_JIFFIES (HZ / 50)\n#define KFREE_N_BATCHES 2\n#define FREE_N_CHANNELS 2\n\n/**\n * struct kvfree_rcu_bulk_data - single block to store kvfree_rcu() pointers\n * @nr_records: Number of active pointers in the array\n * @next: Next bulk object in the block chain\n * @records: Array of the kvfree_rcu() pointers\n */\nstruct kvfree_rcu_bulk_data {\n\tunsigned long nr_records;\n\tstruct kvfree_rcu_bulk_data *next;\n\tvoid *records[];\n};\n\n/*\n * This macro defines how many entries the \"records\" array\n * will contain. It is based on the fact that the size of\n * kvfree_rcu_bulk_data structure becomes exactly one page.\n */\n#define KVFREE_BULK_MAX_ENTR \\\n\t((PAGE_SIZE - sizeof(struct kvfree_rcu_bulk_data)) / sizeof(void *))\n\n/**\n * struct kfree_rcu_cpu_work - single batch of kfree_rcu() requests\n * @rcu_work: Let queue_rcu_work() invoke workqueue handler after grace period\n * @head_free: List of kfree_rcu() objects waiting for a grace period\n * @bkvhead_free: Bulk-List of kvfree_rcu() objects waiting for a grace period\n * @krcp: Pointer to @kfree_rcu_cpu structure\n */\n\nstruct kfree_rcu_cpu_work {\n\tstruct rcu_work rcu_work;\n\tstruct rcu_head *head_free;\n\tstruct kvfree_rcu_bulk_data *bkvhead_free[FREE_N_CHANNELS];\n\tstruct kfree_rcu_cpu *krcp;\n};\n\n/**\n * struct kfree_rcu_cpu - batch up kfree_rcu() requests for RCU grace period\n * @head: List of kfree_rcu() objects not yet waiting for a grace period\n * @bkvhead: Bulk-List of kvfree_rcu() objects not yet waiting for a grace period\n * @krw_arr: Array of batches of kfree_rcu() objects waiting for a grace period\n * @lock: Synchronize access to this structure\n * @monitor_work: Promote @head to @head_free after KFREE_DRAIN_JIFFIES\n * @monitor_todo: Tracks whether a @monitor_work delayed work is pending\n * @initialized: The @rcu_work fields have been initialized\n * @count: Number of objects for which GP not started\n * @bkvcache:\n *\tA simple cache list that contains objects for reuse purpose.\n *\tIn order to save some per-cpu space the list is singular.\n *\tEven though it is lockless an access has to be protected by the\n *\tper-cpu lock.\n * @page_cache_work: A work to refill the cache when it is empty\n * @work_in_progress: Indicates that page_cache_work is running\n * @hrtimer: A hrtimer for scheduling a page_cache_work\n * @nr_bkv_objs: number of allocated objects at @bkvcache.\n *\n * This is a per-CPU structure.  The reason that it is not included in\n * the rcu_data structure is to permit this code to be extracted from\n * the RCU files.  Such extraction could allow further optimization of\n * the interactions with the slab allocators.\n */\nstruct kfree_rcu_cpu {\n\tstruct rcu_head *head;\n\tstruct kvfree_rcu_bulk_data *bkvhead[FREE_N_CHANNELS];\n\tstruct kfree_rcu_cpu_work krw_arr[KFREE_N_BATCHES];\n\traw_spinlock_t lock;\n\tstruct delayed_work monitor_work;\n\tbool monitor_todo;\n\tbool initialized;\n\tint count;\n\n\tstruct work_struct page_cache_work;\n\tatomic_t work_in_progress;\n\tstruct hrtimer hrtimer;\n\n\tstruct llist_head bkvcache;\n\tint nr_bkv_objs;\n};\n\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nstatic __always_inline void\ndebug_rcu_bhead_unqueue(struct kvfree_rcu_bulk_data *bhead)\n{\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\n\tint i;\n\n\tfor (i = 0; i < bhead->nr_records; i++)\n\t\tdebug_rcu_head_unqueue((struct rcu_head *)(bhead->records[i]));\n#endif\n}\n\nstatic inline struct kfree_rcu_cpu *\nkrc_this_cpu_lock(unsigned long *flags)\n{\n\tstruct kfree_rcu_cpu *krcp;\n\n\tlocal_irq_save(*flags);\t// For safely calling this_cpu_ptr().\n\tkrcp = this_cpu_ptr(&krc);\n\traw_spin_lock(&krcp->lock);\n\n\treturn krcp;\n}\n\nstatic inline void\nkrc_this_cpu_unlock(struct kfree_rcu_cpu *krcp, unsigned long flags)\n{\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n}\n\nstatic inline struct kvfree_rcu_bulk_data *\nget_cached_bnode(struct kfree_rcu_cpu *krcp)\n{\n\tif (!krcp->nr_bkv_objs)\n\t\treturn NULL;\n\n\tkrcp->nr_bkv_objs--;\n\treturn (struct kvfree_rcu_bulk_data *)\n\t\tllist_del_first(&krcp->bkvcache);\n}\n\nstatic inline bool\nput_cached_bnode(struct kfree_rcu_cpu *krcp,\n\tstruct kvfree_rcu_bulk_data *bnode)\n{\n\t// Check the limit.\n\tif (krcp->nr_bkv_objs >= rcu_min_cached_objs)\n\t\treturn false;\n\n\tllist_add((struct llist_node *) bnode, &krcp->bkvcache);\n\tkrcp->nr_bkv_objs++;\n\treturn true;\n\n}\n\n/*\n * This function is invoked in workqueue context after a grace period.\n * It frees all the objects queued on ->bhead_free or ->head_free.\n */\nstatic void kfree_rcu_work(struct work_struct *work)\n{\n\tunsigned long flags;\n\tstruct kvfree_rcu_bulk_data *bkvhead[FREE_N_CHANNELS], *bnext;\n\tstruct rcu_head *head, *next;\n\tstruct kfree_rcu_cpu *krcp;\n\tstruct kfree_rcu_cpu_work *krwp;\n\tint i, j;\n\n\tkrwp = container_of(to_rcu_work(work),\n\t\t\t    struct kfree_rcu_cpu_work, rcu_work);\n\tkrcp = krwp->krcp;\n\n\traw_spin_lock_irqsave(&krcp->lock, flags);\n\t// Channels 1 and 2.\n\tfor (i = 0; i < FREE_N_CHANNELS; i++) {\n\t\tbkvhead[i] = krwp->bkvhead_free[i];\n\t\tkrwp->bkvhead_free[i] = NULL;\n\t}\n\n\t// Channel 3.\n\thead = krwp->head_free;\n\tkrwp->head_free = NULL;\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\n\t// Handle two first channels.\n\tfor (i = 0; i < FREE_N_CHANNELS; i++) {\n\t\tfor (; bkvhead[i]; bkvhead[i] = bnext) {\n\t\t\tbnext = bkvhead[i]->next;\n\t\t\tdebug_rcu_bhead_unqueue(bkvhead[i]);\n\n\t\t\trcu_lock_acquire(&rcu_callback_map);\n\t\t\tif (i == 0) { // kmalloc() / kfree().\n\t\t\t\ttrace_rcu_invoke_kfree_bulk_callback(\n\t\t\t\t\trcu_state.name, bkvhead[i]->nr_records,\n\t\t\t\t\tbkvhead[i]->records);\n\n\t\t\t\tkfree_bulk(bkvhead[i]->nr_records,\n\t\t\t\t\tbkvhead[i]->records);\n\t\t\t} else { // vmalloc() / vfree().\n\t\t\t\tfor (j = 0; j < bkvhead[i]->nr_records; j++) {\n\t\t\t\t\ttrace_rcu_invoke_kvfree_callback(\n\t\t\t\t\t\trcu_state.name,\n\t\t\t\t\t\tbkvhead[i]->records[j], 0);\n\n\t\t\t\t\tvfree(bkvhead[i]->records[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\trcu_lock_release(&rcu_callback_map);\n\n\t\t\traw_spin_lock_irqsave(&krcp->lock, flags);\n\t\t\tif (put_cached_bnode(krcp, bkvhead[i]))\n\t\t\t\tbkvhead[i] = NULL;\n\t\t\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\n\t\t\tif (bkvhead[i])\n\t\t\t\tfree_page((unsigned long) bkvhead[i]);\n\n\t\t\tcond_resched_tasks_rcu_qs();\n\t\t}\n\t}\n\n\t/*\n\t * Emergency case only. It can happen under low memory\n\t * condition when an allocation gets failed, so the \"bulk\"\n\t * path can not be temporary maintained.\n\t */\n\tfor (; head; head = next) {\n\t\tunsigned long offset = (unsigned long)head->func;\n\t\tvoid *ptr = (void *)head - offset;\n\n\t\tnext = head->next;\n\t\tdebug_rcu_head_unqueue((struct rcu_head *)ptr);\n\t\trcu_lock_acquire(&rcu_callback_map);\n\t\ttrace_rcu_invoke_kvfree_callback(rcu_state.name, head, offset);\n\n\t\tif (!WARN_ON_ONCE(!__is_kvfree_rcu_offset(offset)))\n\t\t\tkvfree(ptr);\n\n\t\trcu_lock_release(&rcu_callback_map);\n\t\tcond_resched_tasks_rcu_qs();\n\t}\n}\n\n/*\n * Schedule the kfree batch RCU work to run in workqueue context after a GP.\n *\n * This function is invoked by kfree_rcu_monitor() when the KFREE_DRAIN_JIFFIES\n * timeout has been reached.\n */\nstatic inline bool queue_kfree_rcu_work(struct kfree_rcu_cpu *krcp)\n{\n\tstruct kfree_rcu_cpu_work *krwp;\n\tbool repeat = false;\n\tint i, j;\n\n\tlockdep_assert_held(&krcp->lock);\n\n\tfor (i = 0; i < KFREE_N_BATCHES; i++) {\n\t\tkrwp = &(krcp->krw_arr[i]);\n\n\t\t/*\n\t\t * Try to detach bkvhead or head and attach it over any\n\t\t * available corresponding free channel. It can be that\n\t\t * a previous RCU batch is in progress, it means that\n\t\t * immediately to queue another one is not possible so\n\t\t * return false to tell caller to retry.\n\t\t */\n\t\tif ((krcp->bkvhead[0] && !krwp->bkvhead_free[0]) ||\n\t\t\t(krcp->bkvhead[1] && !krwp->bkvhead_free[1]) ||\n\t\t\t\t(krcp->head && !krwp->head_free)) {\n\t\t\t// Channel 1 corresponds to SLAB ptrs.\n\t\t\t// Channel 2 corresponds to vmalloc ptrs.\n\t\t\tfor (j = 0; j < FREE_N_CHANNELS; j++) {\n\t\t\t\tif (!krwp->bkvhead_free[j]) {\n\t\t\t\t\tkrwp->bkvhead_free[j] = krcp->bkvhead[j];\n\t\t\t\t\tkrcp->bkvhead[j] = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Channel 3 corresponds to emergency path.\n\t\t\tif (!krwp->head_free) {\n\t\t\t\tkrwp->head_free = krcp->head;\n\t\t\t\tkrcp->head = NULL;\n\t\t\t}\n\n\t\t\tWRITE_ONCE(krcp->count, 0);\n\n\t\t\t/*\n\t\t\t * One work is per one batch, so there are three\n\t\t\t * \"free channels\", the batch can handle. It can\n\t\t\t * be that the work is in the pending state when\n\t\t\t * channels have been detached following by each\n\t\t\t * other.\n\t\t\t */\n\t\t\tqueue_rcu_work(system_wq, &krwp->rcu_work);\n\t\t}\n\n\t\t// Repeat if any \"free\" corresponding channel is still busy.\n\t\tif (krcp->bkvhead[0] || krcp->bkvhead[1] || krcp->head)\n\t\t\trepeat = true;\n\t}\n\n\treturn !repeat;\n}\n\nstatic inline void kfree_rcu_drain_unlock(struct kfree_rcu_cpu *krcp,\n\t\t\t\t\t  unsigned long flags)\n{\n\t// Attempt to start a new batch.\n\tkrcp->monitor_todo = false;\n\tif (queue_kfree_rcu_work(krcp)) {\n\t\t// Success! Our job is done here.\n\t\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\t\treturn;\n\t}\n\n\t// Previous RCU batch still in progress, try again later.\n\tkrcp->monitor_todo = true;\n\tschedule_delayed_work(&krcp->monitor_work, KFREE_DRAIN_JIFFIES);\n\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n}\n\n/*\n * This function is invoked after the KFREE_DRAIN_JIFFIES timeout.\n * It invokes kfree_rcu_drain_unlock() to attempt to start another batch.\n */\nstatic void kfree_rcu_monitor(struct work_struct *work)\n{\n\tunsigned long flags;\n\tstruct kfree_rcu_cpu *krcp = container_of(work, struct kfree_rcu_cpu,\n\t\t\t\t\t\t monitor_work.work);\n\n\traw_spin_lock_irqsave(&krcp->lock, flags);\n\tif (krcp->monitor_todo)\n\t\tkfree_rcu_drain_unlock(krcp, flags);\n\telse\n\t\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n}\n\nstatic enum hrtimer_restart\nschedule_page_work_fn(struct hrtimer *t)\n{\n\tstruct kfree_rcu_cpu *krcp =\n\t\tcontainer_of(t, struct kfree_rcu_cpu, hrtimer);\n\n\tqueue_work(system_highpri_wq, &krcp->page_cache_work);\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void fill_page_cache_func(struct work_struct *work)\n{\n\tstruct kvfree_rcu_bulk_data *bnode;\n\tstruct kfree_rcu_cpu *krcp =\n\t\tcontainer_of(work, struct kfree_rcu_cpu,\n\t\t\tpage_cache_work);\n\tunsigned long flags;\n\tbool pushed;\n\tint i;\n\n\tfor (i = 0; i < rcu_min_cached_objs; i++) {\n\t\tbnode = (struct kvfree_rcu_bulk_data *)\n\t\t\t__get_free_page(GFP_KERNEL | __GFP_NOWARN);\n\n\t\tif (bnode) {\n\t\t\traw_spin_lock_irqsave(&krcp->lock, flags);\n\t\t\tpushed = put_cached_bnode(krcp, bnode);\n\t\t\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\n\t\t\tif (!pushed) {\n\t\t\t\tfree_page((unsigned long) bnode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tatomic_set(&krcp->work_in_progress, 0);\n}\n\nstatic void\nrun_page_cache_worker(struct kfree_rcu_cpu *krcp)\n{\n\tif (rcu_scheduler_active == RCU_SCHEDULER_RUNNING &&\n\t\t\t!atomic_xchg(&krcp->work_in_progress, 1)) {\n\t\thrtimer_init(&krcp->hrtimer, CLOCK_MONOTONIC,\n\t\t\tHRTIMER_MODE_REL);\n\t\tkrcp->hrtimer.function = schedule_page_work_fn;\n\t\thrtimer_start(&krcp->hrtimer, 0, HRTIMER_MODE_REL);\n\t}\n}\n\n// Record ptr in a page managed by krcp, with the pre-krc_this_cpu_lock()\n// state specified by flags.  If can_alloc is true, the caller must\n// be schedulable and not be holding any locks or mutexes that might be\n// acquired by the memory allocator or anything that it might invoke.\n// Returns true if ptr was successfully recorded, else the caller must\n// use a fallback.\nstatic inline bool\nadd_ptr_to_bulk_krc_lock(struct kfree_rcu_cpu **krcp,\n\tunsigned long *flags, void *ptr, bool can_alloc)\n{\n\tstruct kvfree_rcu_bulk_data *bnode;\n\tint idx;\n\n\t*krcp = krc_this_cpu_lock(flags);\n\tif (unlikely(!(*krcp)->initialized))\n\t\treturn false;\n\n\tidx = !!is_vmalloc_addr(ptr);\n\n\t/* Check if a new block is required. */\n\tif (!(*krcp)->bkvhead[idx] ||\n\t\t\t(*krcp)->bkvhead[idx]->nr_records == KVFREE_BULK_MAX_ENTR) {\n\t\tbnode = get_cached_bnode(*krcp);\n\t\tif (!bnode && can_alloc) {\n\t\t\tkrc_this_cpu_unlock(*krcp, *flags);\n\t\t\tbnode = (struct kvfree_rcu_bulk_data *)\n\t\t\t\t__get_free_page(GFP_KERNEL | __GFP_RETRY_MAYFAIL | __GFP_NOMEMALLOC | __GFP_NOWARN);\n\t\t\t*krcp = krc_this_cpu_lock(flags);\n\t\t}\n\n\t\tif (!bnode)\n\t\t\treturn false;\n\n\t\t/* Initialize the new block. */\n\t\tbnode->nr_records = 0;\n\t\tbnode->next = (*krcp)->bkvhead[idx];\n\n\t\t/* Attach it to the head. */\n\t\t(*krcp)->bkvhead[idx] = bnode;\n\t}\n\n\t/* Finally insert. */\n\t(*krcp)->bkvhead[idx]->records\n\t\t[(*krcp)->bkvhead[idx]->nr_records++] = ptr;\n\n\treturn true;\n}\n\n/*\n * Queue a request for lazy invocation of appropriate free routine after a\n * grace period. Please note there are three paths are maintained, two are the\n * main ones that use array of pointers interface and third one is emergency\n * one, that is used only when the main path can not be maintained temporary,\n * due to memory pressure.\n *\n * Each kvfree_call_rcu() request is added to a batch. The batch will be drained\n * every KFREE_DRAIN_JIFFIES number of jiffies. All the objects in the batch will\n * be free'd in workqueue context. This allows us to: batch requests together to\n * reduce the number of grace periods during heavy kfree_rcu()/kvfree_rcu() load.\n */\nvoid kvfree_call_rcu(struct rcu_head *head, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tstruct kfree_rcu_cpu *krcp;\n\tbool success;\n\tvoid *ptr;\n\n\tif (head) {\n\t\tptr = (void *) head - (unsigned long) func;\n\t} else {\n\t\t/*\n\t\t * Please note there is a limitation for the head-less\n\t\t * variant, that is why there is a clear rule for such\n\t\t * objects: it can be used from might_sleep() context\n\t\t * only. For other places please embed an rcu_head to\n\t\t * your data.\n\t\t */\n\t\tmight_sleep();\n\t\tptr = (unsigned long *) func;\n\t}\n\n\t// Queue the object but don't yet schedule the batch.\n\tif (debug_rcu_head_queue(ptr)) {\n\t\t// Probable double kfree_rcu(), just leak.\n\t\tWARN_ONCE(1, \"%s(): Double-freed call. rcu_head %p\\n\",\n\t\t\t  __func__, head);\n\n\t\t// Mark as success and leave.\n\t\treturn;\n\t}\n\n\tkasan_record_aux_stack(ptr);\n\tsuccess = add_ptr_to_bulk_krc_lock(&krcp, &flags, ptr, !head);\n\tif (!success) {\n\t\trun_page_cache_worker(krcp);\n\n\t\tif (head == NULL)\n\t\t\t// Inline if kvfree_rcu(one_arg) call.\n\t\t\tgoto unlock_return;\n\n\t\thead->func = func;\n\t\thead->next = krcp->head;\n\t\tkrcp->head = head;\n\t\tsuccess = true;\n\t}\n\n\tWRITE_ONCE(krcp->count, krcp->count + 1);\n\n\t// Set timer to drain after KFREE_DRAIN_JIFFIES.\n\tif (rcu_scheduler_active == RCU_SCHEDULER_RUNNING &&\n\t    !krcp->monitor_todo) {\n\t\tkrcp->monitor_todo = true;\n\t\tschedule_delayed_work(&krcp->monitor_work, KFREE_DRAIN_JIFFIES);\n\t}\n\nunlock_return:\n\tkrc_this_cpu_unlock(krcp, flags);\n\n\t/*\n\t * Inline kvfree() after synchronize_rcu(). We can do\n\t * it from might_sleep() context only, so the current\n\t * CPU can pass the QS state.\n\t */\n\tif (!success) {\n\t\tdebug_rcu_head_unqueue((struct rcu_head *) ptr);\n\t\tsynchronize_rcu();\n\t\tkvfree(ptr);\n\t}\n}\nEXPORT_SYMBOL_GPL(kvfree_call_rcu);\n\nstatic unsigned long\nkfree_rcu_shrink_count(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu;\n\tunsigned long count = 0;\n\n\t/* Snapshot count of all CPUs */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount += READ_ONCE(krcp->count);\n\t}\n\n\treturn count;\n}\n\nstatic unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\tunsigned long flags;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\traw_spin_lock_irqsave(&krcp->lock, flags);\n\t\tif (krcp->monitor_todo)\n\t\t\tkfree_rcu_drain_unlock(krcp, flags);\n\t\telse\n\t\t\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}\n\nstatic struct shrinker kfree_rcu_shrinker = {\n\t.count_objects = kfree_rcu_shrink_count,\n\t.scan_objects = kfree_rcu_shrink_scan,\n\t.batch = 0,\n\t.seeks = DEFAULT_SEEKS,\n};\n\nvoid __init kfree_rcu_scheduler_running(void)\n{\n\tint cpu;\n\tunsigned long flags;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\traw_spin_lock_irqsave(&krcp->lock, flags);\n\t\tif (!krcp->head || krcp->monitor_todo) {\n\t\t\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tkrcp->monitor_todo = true;\n\t\tschedule_delayed_work_on(cpu, &krcp->monitor_work,\n\t\t\t\t\t KFREE_DRAIN_JIFFIES);\n\t\traw_spin_unlock_irqrestore(&krcp->lock, flags);\n\t}\n}\n\n/*\n * During early boot, any blocking grace-period wait automatically\n * implies a grace period.  Later on, this is never the case for PREEMPTION.\n *\n * However, because a context switch is a grace period for !PREEMPTION, any\n * blocking grace-period wait automatically implies a grace period if\n * there is only one CPU online at any point time during execution of\n * either synchronize_rcu() or synchronize_rcu_expedited().  It is OK to\n * occasionally incorrectly indicate that there are multiple CPUs online\n * when there was in fact only one the whole time, as this just adds some\n * overhead: RCU still operates correctly.\n */\nstatic int rcu_blocking_is_gp(void)\n{\n\tint ret;\n\n\tif (IS_ENABLED(CONFIG_PREEMPTION))\n\t\treturn rcu_scheduler_active == RCU_SCHEDULER_INACTIVE;\n\tmight_sleep();  /* Check for RCU read-side critical section. */\n\tpreempt_disable();\n\t/*\n\t * If the rcu_state.n_online_cpus counter is equal to one,\n\t * there is only one CPU, and that CPU sees all prior accesses\n\t * made by any CPU that was online at the time of its access.\n\t * Furthermore, if this counter is equal to one, its value cannot\n\t * change until after the preempt_enable() below.\n\t *\n\t * Furthermore, if rcu_state.n_online_cpus is equal to one here,\n\t * all later CPUs (both this one and any that come online later\n\t * on) are guaranteed to see all accesses prior to this point\n\t * in the code, without the need for additional memory barriers.\n\t * Those memory barriers are provided by CPU-hotplug code.\n\t */\n\tret = READ_ONCE(rcu_state.n_online_cpus) <= 1;\n\tpreempt_enable();\n\treturn ret;\n}\n\n/**\n * synchronize_rcu - wait until a grace period has elapsed.\n *\n * Control will return to the caller some time after a full grace\n * period has elapsed, in other words after all currently executing RCU\n * read-side critical sections have completed.  Note, however, that\n * upon return from synchronize_rcu(), the caller might well be executing\n * concurrently with new RCU read-side critical sections that began while\n * synchronize_rcu() was waiting.  RCU read-side critical sections are\n * delimited by rcu_read_lock() and rcu_read_unlock(), and may be nested.\n * In addition, regions of code across which interrupts, preemption, or\n * softirqs have been disabled also serve as RCU read-side critical\n * sections.  This includes hardware interrupt handlers, softirq handlers,\n * and NMI handlers.\n *\n * Note that this guarantee implies further memory-ordering guarantees.\n * On systems with more than one CPU, when synchronize_rcu() returns,\n * each CPU is guaranteed to have executed a full memory barrier since\n * the end of its last RCU read-side critical section whose beginning\n * preceded the call to synchronize_rcu().  In addition, each CPU having\n * an RCU read-side critical section that extends beyond the return from\n * synchronize_rcu() is guaranteed to have executed a full memory barrier\n * after the beginning of synchronize_rcu() and before the beginning of\n * that RCU read-side critical section.  Note that these guarantees include\n * CPUs that are offline, idle, or executing in user mode, as well as CPUs\n * that are executing in the kernel.\n *\n * Furthermore, if CPU A invoked synchronize_rcu(), which returned\n * to its caller on CPU B, then both CPU A and CPU B are guaranteed\n * to have executed a full memory barrier during the execution of\n * synchronize_rcu() -- even if CPU A and CPU B are the same CPU (but\n * again only if the system has more than one CPU).\n */\nvoid synchronize_rcu(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu() in RCU read-side critical section\");\n\tif (rcu_blocking_is_gp())\n\t\treturn;  // Context allows vacuous grace periods.\n\tif (rcu_gp_is_expedited())\n\t\tsynchronize_rcu_expedited();\n\telse\n\t\twait_rcu_gp(call_rcu);\n}\nEXPORT_SYMBOL_GPL(synchronize_rcu);\n\n/**\n * get_state_synchronize_rcu - Snapshot current RCU state\n *\n * Returns a cookie that is used by a later call to cond_synchronize_rcu()\n * to determine whether or not a full grace period has elapsed in the\n * meantime.\n */\nunsigned long get_state_synchronize_rcu(void)\n{\n\t/*\n\t * Any prior manipulation of RCU-protected data must happen\n\t * before the load from ->gp_seq.\n\t */\n\tsmp_mb();  /* ^^^ */\n\treturn rcu_seq_snap(&rcu_state.gp_seq);\n}\nEXPORT_SYMBOL_GPL(get_state_synchronize_rcu);\n\n/**\n * cond_synchronize_rcu - Conditionally wait for an RCU grace period\n *\n * @oldstate: return value from earlier call to get_state_synchronize_rcu()\n *\n * If a full RCU grace period has elapsed since the earlier call to\n * get_state_synchronize_rcu(), just return.  Otherwise, invoke\n * synchronize_rcu() to wait for a full grace period.\n *\n * Yes, this function does not take counter wrap into account.  But\n * counter wrap is harmless.  If the counter wraps, we have waited for\n * more than 2 billion grace periods (and way more on a 64-bit system!),\n * so waiting for one additional grace period should be just fine.\n */\nvoid cond_synchronize_rcu(unsigned long oldstate)\n{\n\tif (!rcu_seq_done(&rcu_state.gp_seq, oldstate))\n\t\tsynchronize_rcu();\n\telse\n\t\tsmp_mb(); /* Ensure GP ends before subsequent accesses. */\n}\nEXPORT_SYMBOL_GPL(cond_synchronize_rcu);\n\n/*\n * Check to see if there is any immediate RCU-related work to be done by\n * the current CPU, returning 1 if so and zero otherwise.  The checks are\n * in order of increasing expense: checks that can be carried out against\n * CPU-local state are performed first.  However, we must check for CPU\n * stalls first, else we might not get a chance.\n */\nstatic int rcu_pending(int user)\n{\n\tbool gp_in_progress;\n\tstruct rcu_data *rdp = this_cpu_ptr(&rcu_data);\n\tstruct rcu_node *rnp = rdp->mynode;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Check for CPU stalls, if enabled. */\n\tcheck_cpu_stall(rdp);\n\n\t/* Does this CPU need a deferred NOCB wakeup? */\n\tif (rcu_nocb_need_deferred_wakeup(rdp))\n\t\treturn 1;\n\n\t/* Is this a nohz_full CPU in userspace or idle?  (Ignore RCU if so.) */\n\tif ((user || rcu_is_cpu_rrupt_from_idle()) && rcu_nohz_full_cpu())\n\t\treturn 0;\n\n\t/* Is the RCU core waiting for a quiescent state from this CPU? */\n\tgp_in_progress = rcu_gp_in_progress();\n\tif (rdp->core_needs_qs && !rdp->cpu_no_qs.b.norm && gp_in_progress)\n\t\treturn 1;\n\n\t/* Does this CPU have callbacks ready to invoke? */\n\tif (!rcu_rdp_is_offloaded(rdp) &&\n\t    rcu_segcblist_ready_cbs(&rdp->cblist))\n\t\treturn 1;\n\n\t/* Has RCU gone idle with this CPU needing another grace period? */\n\tif (!gp_in_progress && rcu_segcblist_is_enabled(&rdp->cblist) &&\n\t    !rcu_rdp_is_offloaded(rdp) &&\n\t    !rcu_segcblist_restempty(&rdp->cblist, RCU_NEXT_READY_TAIL))\n\t\treturn 1;\n\n\t/* Have RCU grace period completed or started?  */\n\tif (rcu_seq_current(&rnp->gp_seq) != rdp->gp_seq ||\n\t    unlikely(READ_ONCE(rdp->gpwrap))) /* outside lock */\n\t\treturn 1;\n\n\t/* nothing to do */\n\treturn 0;\n}\n\n/*\n * Helper function for rcu_barrier() tracing.  If tracing is disabled,\n * the compiler is expected to optimize this away.\n */\nstatic void rcu_barrier_trace(const char *s, int cpu, unsigned long done)\n{\n\ttrace_rcu_barrier(rcu_state.name, s, cpu,\n\t\t\t  atomic_read(&rcu_state.barrier_cpu_count), done);\n}\n\n/*\n * RCU callback function for rcu_barrier().  If we are last, wake\n * up the task executing rcu_barrier().\n *\n * Note that the value of rcu_state.barrier_sequence must be captured\n * before the atomic_dec_and_test().  Otherwise, if this CPU is not last,\n * other CPUs might count the value down to zero before this CPU gets\n * around to invoking rcu_barrier_trace(), which might result in bogus\n * data from the next instance of rcu_barrier().\n */\nstatic void rcu_barrier_callback(struct rcu_head *rhp)\n{\n\tunsigned long __maybe_unused s = rcu_state.barrier_sequence;\n\n\tif (atomic_dec_and_test(&rcu_state.barrier_cpu_count)) {\n\t\trcu_barrier_trace(TPS(\"LastCB\"), -1, s);\n\t\tcomplete(&rcu_state.barrier_completion);\n\t} else {\n\t\trcu_barrier_trace(TPS(\"CB\"), -1, s);\n\t}\n}\n\n/*\n * Called with preemption disabled, and from cross-cpu IRQ context.\n */\nstatic void rcu_barrier_func(void *cpu_in)\n{\n\tuintptr_t cpu = (uintptr_t)cpu_in;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_barrier_trace(TPS(\"IRQ\"), -1, rcu_state.barrier_sequence);\n\trdp->barrier_head.func = rcu_barrier_callback;\n\tdebug_rcu_head_queue(&rdp->barrier_head);\n\trcu_nocb_lock(rdp);\n\tWARN_ON_ONCE(!rcu_nocb_flush_bypass(rdp, NULL, jiffies));\n\tif (rcu_segcblist_entrain(&rdp->cblist, &rdp->barrier_head)) {\n\t\tatomic_inc(&rcu_state.barrier_cpu_count);\n\t} else {\n\t\tdebug_rcu_head_unqueue(&rdp->barrier_head);\n\t\trcu_barrier_trace(TPS(\"IRQNQ\"), -1,\n\t\t\t\t  rcu_state.barrier_sequence);\n\t}\n\trcu_nocb_unlock(rdp);\n}\n\n/**\n * rcu_barrier - Wait until all in-flight call_rcu() callbacks complete.\n *\n * Note that this primitive does not necessarily wait for an RCU grace period\n * to complete.  For example, if there are no RCU callbacks queued anywhere\n * in the system, then rcu_barrier() is within its rights to return\n * immediately, without waiting for anything, much less an RCU grace period.\n */\nvoid rcu_barrier(void)\n{\n\tuintptr_t cpu;\n\tstruct rcu_data *rdp;\n\tunsigned long s = rcu_seq_snap(&rcu_state.barrier_sequence);\n\n\trcu_barrier_trace(TPS(\"Begin\"), -1, s);\n\n\t/* Take mutex to serialize concurrent rcu_barrier() requests. */\n\tmutex_lock(&rcu_state.barrier_mutex);\n\n\t/* Did someone else do our work for us? */\n\tif (rcu_seq_done(&rcu_state.barrier_sequence, s)) {\n\t\trcu_barrier_trace(TPS(\"EarlyExit\"), -1,\n\t\t\t\t  rcu_state.barrier_sequence);\n\t\tsmp_mb(); /* caller's subsequent code after above check. */\n\t\tmutex_unlock(&rcu_state.barrier_mutex);\n\t\treturn;\n\t}\n\n\t/* Mark the start of the barrier operation. */\n\trcu_seq_start(&rcu_state.barrier_sequence);\n\trcu_barrier_trace(TPS(\"Inc1\"), -1, rcu_state.barrier_sequence);\n\n\t/*\n\t * Initialize the count to two rather than to zero in order\n\t * to avoid a too-soon return to zero in case of an immediate\n\t * invocation of the just-enqueued callback (or preemption of\n\t * this task).  Exclude CPU-hotplug operations to ensure that no\n\t * offline non-offloaded CPU has callbacks queued.\n\t */\n\tinit_completion(&rcu_state.barrier_completion);\n\tatomic_set(&rcu_state.barrier_cpu_count, 2);\n\tget_online_cpus();\n\n\t/*\n\t * Force each CPU with callbacks to register a new callback.\n\t * When that callback is invoked, we will know that all of the\n\t * corresponding CPU's preceding callbacks have been invoked.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\tif (cpu_is_offline(cpu) &&\n\t\t    !rcu_rdp_is_offloaded(rdp))\n\t\t\tcontinue;\n\t\tif (rcu_segcblist_n_cbs(&rdp->cblist) && cpu_online(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OnlineQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t\tsmp_call_function_single(cpu, rcu_barrier_func, (void *)cpu, 1);\n\t\t} else if (rcu_segcblist_n_cbs(&rdp->cblist) &&\n\t\t\t   cpu_is_offline(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OfflineNoCBQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t\tlocal_irq_disable();\n\t\t\trcu_barrier_func((void *)cpu);\n\t\t\tlocal_irq_enable();\n\t\t} else if (cpu_is_offline(cpu)) {\n\t\t\trcu_barrier_trace(TPS(\"OfflineNoCBNoQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t} else {\n\t\t\trcu_barrier_trace(TPS(\"OnlineNQ\"), cpu,\n\t\t\t\t\t  rcu_state.barrier_sequence);\n\t\t}\n\t}\n\tput_online_cpus();\n\n\t/*\n\t * Now that we have an rcu_barrier_callback() callback on each\n\t * CPU, and thus each counted, remove the initial count.\n\t */\n\tif (atomic_sub_and_test(2, &rcu_state.barrier_cpu_count))\n\t\tcomplete(&rcu_state.barrier_completion);\n\n\t/* Wait for all rcu_barrier_callback() callbacks to be invoked. */\n\twait_for_completion(&rcu_state.barrier_completion);\n\n\t/* Mark the end of the barrier operation. */\n\trcu_barrier_trace(TPS(\"Inc2\"), -1, rcu_state.barrier_sequence);\n\trcu_seq_end(&rcu_state.barrier_sequence);\n\n\t/* Other rcu_barrier() invocations can now safely proceed. */\n\tmutex_unlock(&rcu_state.barrier_mutex);\n}\nEXPORT_SYMBOL_GPL(rcu_barrier);\n\n/*\n * Propagate ->qsinitmask bits up the rcu_node tree to account for the\n * first CPU in a given leaf rcu_node structure coming online.  The caller\n * must hold the corresponding leaf rcu_node ->lock with interrrupts\n * disabled.\n */\nstatic void rcu_init_new_rnp(struct rcu_node *rnp_leaf)\n{\n\tlong mask;\n\tlong oldmask;\n\tstruct rcu_node *rnp = rnp_leaf;\n\n\traw_lockdep_assert_held_rcu_node(rnp_leaf);\n\tWARN_ON_ONCE(rnp->wait_blkd_tasks);\n\tfor (;;) {\n\t\tmask = rnp->grpmask;\n\t\trnp = rnp->parent;\n\t\tif (rnp == NULL)\n\t\t\treturn;\n\t\traw_spin_lock_rcu_node(rnp); /* Interrupts already disabled. */\n\t\toldmask = rnp->qsmaskinit;\n\t\trnp->qsmaskinit |= mask;\n\t\traw_spin_unlock_rcu_node(rnp); /* Interrupts remain disabled. */\n\t\tif (oldmask)\n\t\t\treturn;\n\t}\n}\n\n/*\n * Do boot-time initialization of a CPU's per-CPU RCU data.\n */\nstatic void __init\nrcu_boot_init_percpu_data(int cpu)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\trdp->grpmask = leaf_node_cpu_bit(rdp->mynode, cpu);\n\tINIT_WORK(&rdp->strict_work, strict_work_handler);\n\tWARN_ON_ONCE(rdp->dynticks_nesting != 1);\n\tWARN_ON_ONCE(rcu_dynticks_in_eqs(rcu_dynticks_snap(rdp)));\n\trdp->rcu_ofl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_ofl_gp_flags = RCU_GP_CLEANED;\n\trdp->rcu_onl_gp_seq = rcu_state.gp_seq;\n\trdp->rcu_onl_gp_flags = RCU_GP_CLEANED;\n\trdp->cpu = cpu;\n\trcu_boot_init_nocb_percpu_data(rdp);\n}\n\n/*\n * Invoked early in the CPU-online process, when pretty much all services\n * are available.  The incoming CPU is not present.\n *\n * Initializes a CPU's per-CPU RCU data.  Note that only one online or\n * offline event can be happening at a given time.  Note also that we can\n * accept some slop in the rsp->gp_seq access due to the fact that this\n * CPU cannot possibly have any non-offloaded RCU callbacks in flight yet.\n * And any offloaded callbacks are being numbered elsewhere.\n */\nint rcutree_prepare_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rcu_get_root();\n\n\t/* Set up local state, ensuring consistent view of global state. */\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trdp->qlen_last_fqs_check = 0;\n\trdp->n_force_qs_snap = rcu_state.n_force_qs;\n\trdp->blimit = blimit;\n\trdp->dynticks_nesting = 1;\t/* CPU not up, no tearing. */\n\trcu_dynticks_eqs_online();\n\traw_spin_unlock_rcu_node(rnp);\t\t/* irqs remain disabled. */\n\t/*\n\t * Lock in case the CB/GP kthreads are still around handling\n\t * old callbacks (longer term we should flush all callbacks\n\t * before completing CPU offline)\n\t */\n\trcu_nocb_lock(rdp);\n\tif (rcu_segcblist_empty(&rdp->cblist)) /* No early-boot CBs? */\n\t\trcu_segcblist_init(&rdp->cblist);  /* Re-enable callbacks. */\n\trcu_nocb_unlock(rdp);\n\n\t/*\n\t * Add CPU to leaf rcu_node pending-online bitmask.  Any needed\n\t * propagation up the rcu_node tree will happen at the beginning\n\t * of the next grace period.\n\t */\n\trnp = rdp->mynode;\n\traw_spin_lock_rcu_node(rnp);\t\t/* irqs already disabled. */\n\trdp->beenonline = true;\t /* We have now been online. */\n\trdp->gp_seq = READ_ONCE(rnp->gp_seq);\n\trdp->gp_seq_needed = rdp->gp_seq;\n\trdp->cpu_no_qs.b.norm = true;\n\trdp->core_needs_qs = false;\n\trdp->rcu_iw_pending = false;\n\trdp->rcu_iw = IRQ_WORK_INIT_HARD(rcu_iw_handler);\n\trdp->rcu_iw_gp_seq = rdp->gp_seq - 1;\n\ttrace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS(\"cpuonl\"));\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\trcu_prepare_kthreads(cpu);\n\trcu_spawn_cpu_nocb_kthread(cpu);\n\tWRITE_ONCE(rcu_state.n_online_cpus, rcu_state.n_online_cpus + 1);\n\n\treturn 0;\n}\n\n/*\n * Update RCU priority boot kthread affinity for CPU-hotplug changes.\n */\nstatic void rcutree_affinity_setting(unsigned int cpu, int outgoing)\n{\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\n\trcu_boost_kthread_setaffinity(rdp->mynode, outgoing);\n}\n\n/*\n * Near the end of the CPU-online process.  Pretty much all services\n * enabled, and the CPU is now very much alive.\n */\nint rcutree_online_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask |= rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn 0; /* Too early in boot for scheduler work. */\n\tsync_sched_exp_online_cleanup(cpu);\n\trcutree_affinity_setting(cpu, -1);\n\n\t// Stop-machine done, so allow nohz_full to disable tick.\n\ttick_dep_clear(TICK_DEP_BIT_RCU);\n\treturn 0;\n}\n\n/*\n * Near the beginning of the process.  The CPU is still very much alive\n * with pretty much all services enabled.\n */\nint rcutree_offline_cpu(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\trnp = rdp->mynode;\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\trnp->ffmask &= ~rdp->grpmask;\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\n\trcutree_affinity_setting(cpu, cpu);\n\n\t// nohz_full CPUs need the tick for stop-machine to work quickly\n\ttick_dep_set(TICK_DEP_BIT_RCU);\n\treturn 0;\n}\n\n/*\n * Mark the specified CPU as being online so that subsequent grace periods\n * (both expedited and normal) will wait on it.  Note that this means that\n * incoming CPUs are not allowed to use RCU read-side critical sections\n * until this function is called.  Failing to observe this restriction\n * will result in lockdep splats.\n *\n * Note that this function is special in that it is invoked directly\n * from the incoming CPU rather than from the cpuhp_step mechanism.\n * This is because this function must be invoked at a precise location.\n */\nvoid rcu_cpu_starting(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp;\n\tstruct rcu_node *rnp;\n\tbool newcpu;\n\n\trdp = per_cpu_ptr(&rcu_data, cpu);\n\tif (rdp->cpu_started)\n\t\treturn;\n\trdp->cpu_started = true;\n\n\trnp = rdp->mynode;\n\tmask = rdp->grpmask;\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(!(rnp->ofl_seq & 0x1));\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tWRITE_ONCE(rnp->qsmaskinitnext, rnp->qsmaskinitnext | mask);\n\tnewcpu = !(rnp->expmaskinitnext & mask);\n\trnp->expmaskinitnext |= mask;\n\t/* Allow lockless access for expedited grace periods. */\n\tsmp_store_release(&rcu_state.ncpus, rcu_state.ncpus + newcpu); /* ^^^ */\n\tASSERT_EXCLUSIVE_WRITER(rcu_state.ncpus);\n\trcu_gpnum_ovf(rnp, rdp); /* Offline-induced counter wrap? */\n\trdp->rcu_onl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_onl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\n\t/* An incoming CPU should never be blocking a grace period. */\n\tif (WARN_ON_ONCE(rnp->qsmask & mask)) { /* RCU waiting on incoming CPU? */\n\t\trcu_disable_urgency_upon_qs(rdp);\n\t\t/* Report QS -after- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t} else {\n\t\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\t}\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(rnp->ofl_seq & 0x1);\n\tsmp_mb(); /* Ensure RCU read-side usage follows above initialization. */\n}\n\n/*\n * The outgoing function has no further need of RCU, so remove it from\n * the rcu_node tree's ->qsmaskinitnext bit masks.\n *\n * Note that this function is special in that it is invoked directly\n * from the outgoing CPU rather than from the cpuhp_step mechanism.\n * This is because this function must be invoked at a precise location.\n */\nvoid rcu_report_dead(unsigned int cpu)\n{\n\tunsigned long flags;\n\tunsigned long mask;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tstruct rcu_node *rnp = rdp->mynode;  /* Outgoing CPU's rdp & rnp. */\n\n\t// Do any dangling deferred wakeups.\n\tdo_nocb_deferred_wakeup(rdp);\n\n\t/* QS for any half-done expedited grace period. */\n\tpreempt_disable();\n\trcu_report_exp_rdp(this_cpu_ptr(&rcu_data));\n\tpreempt_enable();\n\trcu_preempt_deferred_qs(current);\n\n\t/* Remove outgoing CPU from mask in the leaf rcu_node structure. */\n\tmask = rdp->grpmask;\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(!(rnp->ofl_seq & 0x1));\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\traw_spin_lock(&rcu_state.ofl_lock);\n\traw_spin_lock_irqsave_rcu_node(rnp, flags); /* Enforce GP memory-order guarantee. */\n\trdp->rcu_ofl_gp_seq = READ_ONCE(rcu_state.gp_seq);\n\trdp->rcu_ofl_gp_flags = READ_ONCE(rcu_state.gp_flags);\n\tif (rnp->qsmask & mask) { /* RCU waiting on outgoing CPU? */\n\t\t/* Report quiescent state -before- changing ->qsmaskinitnext! */\n\t\trcu_report_qs_rnp(mask, rnp, rnp->gp_seq, flags);\n\t\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\t}\n\tWRITE_ONCE(rnp->qsmaskinitnext, rnp->qsmaskinitnext & ~mask);\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\traw_spin_unlock(&rcu_state.ofl_lock);\n\tsmp_mb(); // Pair with rcu_gp_cleanup()'s ->ofl_seq barrier().\n\tWRITE_ONCE(rnp->ofl_seq, rnp->ofl_seq + 1);\n\tWARN_ON_ONCE(rnp->ofl_seq & 0x1);\n\n\trdp->cpu_started = false;\n}\n\n#ifdef CONFIG_HOTPLUG_CPU\n/*\n * The outgoing CPU has just passed through the dying-idle state, and we\n * are being invoked from the CPU that was IPIed to continue the offline\n * operation.  Migrate the outgoing CPU's callbacks to the current CPU.\n */\nvoid rcutree_migrate_callbacks(int cpu)\n{\n\tunsigned long flags;\n\tstruct rcu_data *my_rdp;\n\tstruct rcu_node *my_rnp;\n\tstruct rcu_data *rdp = per_cpu_ptr(&rcu_data, cpu);\n\tbool needwake;\n\n\tif (rcu_rdp_is_offloaded(rdp) ||\n\t    rcu_segcblist_empty(&rdp->cblist))\n\t\treturn;  /* No callbacks to migrate. */\n\n\tlocal_irq_save(flags);\n\tmy_rdp = this_cpu_ptr(&rcu_data);\n\tmy_rnp = my_rdp->mynode;\n\trcu_nocb_lock(my_rdp); /* irqs already disabled. */\n\tWARN_ON_ONCE(!rcu_nocb_flush_bypass(my_rdp, NULL, jiffies));\n\traw_spin_lock_rcu_node(my_rnp); /* irqs already disabled. */\n\t/* Leverage recent GPs and set GP for new callbacks. */\n\tneedwake = rcu_advance_cbs(my_rnp, rdp) ||\n\t\t   rcu_advance_cbs(my_rnp, my_rdp);\n\trcu_segcblist_merge(&my_rdp->cblist, &rdp->cblist);\n\tneedwake = needwake || rcu_advance_cbs(my_rnp, my_rdp);\n\trcu_segcblist_disable(&rdp->cblist);\n\tWARN_ON_ONCE(rcu_segcblist_empty(&my_rdp->cblist) !=\n\t\t     !rcu_segcblist_n_cbs(&my_rdp->cblist));\n\tif (rcu_rdp_is_offloaded(my_rdp)) {\n\t\traw_spin_unlock_rcu_node(my_rnp); /* irqs remain disabled. */\n\t\t__call_rcu_nocb_wake(my_rdp, true, flags);\n\t} else {\n\t\trcu_nocb_unlock(my_rdp); /* irqs remain disabled. */\n\t\traw_spin_unlock_irqrestore_rcu_node(my_rnp, flags);\n\t}\n\tif (needwake)\n\t\trcu_gp_kthread_wake();\n\tlockdep_assert_irqs_enabled();\n\tWARN_ONCE(rcu_segcblist_n_cbs(&rdp->cblist) != 0 ||\n\t\t  !rcu_segcblist_empty(&rdp->cblist),\n\t\t  \"rcu_cleanup_dead_cpu: Callbacks on offline CPU %d: qlen=%lu, 1stCB=%p\\n\",\n\t\t  cpu, rcu_segcblist_n_cbs(&rdp->cblist),\n\t\t  rcu_segcblist_first_cb(&rdp->cblist));\n}\n#endif\n\n/*\n * On non-huge systems, use expedited RCU grace periods to make suspend\n * and hibernation run faster.\n */\nstatic int rcu_pm_notify(struct notifier_block *self,\n\t\t\t unsigned long action, void *hcpu)\n{\n\tswitch (action) {\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_SUSPEND_PREPARE:\n\t\trcu_expedite_gp();\n\t\tbreak;\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_SUSPEND:\n\t\trcu_unexpedite_gp();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\n/*\n * Spawn the kthreads that handle RCU's grace periods.\n */\nstatic int __init rcu_spawn_gp_kthread(void)\n{\n\tunsigned long flags;\n\tint kthread_prio_in = kthread_prio;\n\tstruct rcu_node *rnp;\n\tstruct sched_param sp;\n\tstruct task_struct *t;\n\n\t/* Force priority into range. */\n\tif (IS_ENABLED(CONFIG_RCU_BOOST) && kthread_prio < 2\n\t    && IS_BUILTIN(CONFIG_RCU_TORTURE_TEST))\n\t\tkthread_prio = 2;\n\telse if (IS_ENABLED(CONFIG_RCU_BOOST) && kthread_prio < 1)\n\t\tkthread_prio = 1;\n\telse if (kthread_prio < 0)\n\t\tkthread_prio = 0;\n\telse if (kthread_prio > 99)\n\t\tkthread_prio = 99;\n\n\tif (kthread_prio != kthread_prio_in)\n\t\tpr_alert(\"rcu_spawn_gp_kthread(): Limited prio to %d from %d\\n\",\n\t\t\t kthread_prio, kthread_prio_in);\n\n\trcu_scheduler_fully_active = 1;\n\tt = kthread_create(rcu_gp_kthread, NULL, \"%s\", rcu_state.name);\n\tif (WARN_ONCE(IS_ERR(t), \"%s: Could not start grace-period kthread, OOM is now expected behavior\\n\", __func__))\n\t\treturn 0;\n\tif (kthread_prio) {\n\t\tsp.sched_priority = kthread_prio;\n\t\tsched_setscheduler_nocheck(t, SCHED_FIFO, &sp);\n\t}\n\trnp = rcu_get_root();\n\traw_spin_lock_irqsave_rcu_node(rnp, flags);\n\tWRITE_ONCE(rcu_state.gp_activity, jiffies);\n\tWRITE_ONCE(rcu_state.gp_req_activity, jiffies);\n\t// Reset .gp_activity and .gp_req_activity before setting .gp_kthread.\n\tsmp_store_release(&rcu_state.gp_kthread, t);  /* ^^^ */\n\traw_spin_unlock_irqrestore_rcu_node(rnp, flags);\n\twake_up_process(t);\n\trcu_spawn_nocb_kthreads();\n\trcu_spawn_boost_kthreads();\n\treturn 0;\n}\nearly_initcall(rcu_spawn_gp_kthread);\n\n/*\n * This function is invoked towards the end of the scheduler's\n * initialization process.  Before this is called, the idle task might\n * contain synchronous grace-period primitives (during which time, this idle\n * task is booting the system, and such primitives are no-ops).  After this\n * function is called, any synchronous grace-period primitives are run as\n * expedited, with the requesting task driving the grace period forward.\n * A later core_initcall() rcu_set_runtime_mode() will switch to full\n * runtime RCU functionality.\n */\nvoid rcu_scheduler_starting(void)\n{\n\tWARN_ON(num_online_cpus() != 1);\n\tWARN_ON(nr_context_switches() > 0);\n\trcu_test_sync_prims();\n\trcu_scheduler_active = RCU_SCHEDULER_INIT;\n\trcu_test_sync_prims();\n}\n\n/*\n * Helper function for rcu_init() that initializes the rcu_state structure.\n */\nstatic void __init rcu_init_one(void)\n{\n\tstatic const char * const buf[] = RCU_NODE_NAME_INIT;\n\tstatic const char * const fqs[] = RCU_FQS_NAME_INIT;\n\tstatic struct lock_class_key rcu_node_class[RCU_NUM_LVLS];\n\tstatic struct lock_class_key rcu_fqs_class[RCU_NUM_LVLS];\n\n\tint levelspread[RCU_NUM_LVLS];\t\t/* kids/node in each level. */\n\tint cpustride = 1;\n\tint i;\n\tint j;\n\tstruct rcu_node *rnp;\n\n\tBUILD_BUG_ON(RCU_NUM_LVLS > ARRAY_SIZE(buf));  /* Fix buf[] init! */\n\n\t/* Silence gcc 4.8 false positive about array index out of range. */\n\tif (rcu_num_lvls <= 0 || rcu_num_lvls > RCU_NUM_LVLS)\n\t\tpanic(\"rcu_init_one: rcu_num_lvls out of range\");\n\n\t/* Initialize the level-tracking arrays. */\n\n\tfor (i = 1; i < rcu_num_lvls; i++)\n\t\trcu_state.level[i] =\n\t\t\trcu_state.level[i - 1] + num_rcu_lvl[i - 1];\n\trcu_init_levelspread(levelspread, num_rcu_lvl);\n\n\t/* Initialize the elements themselves, starting from the leaves. */\n\n\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {\n\t\tcpustride *= levelspread[i];\n\t\trnp = rcu_state.level[i];\n\t\tfor (j = 0; j < num_rcu_lvl[i]; j++, rnp++) {\n\t\t\traw_spin_lock_init(&ACCESS_PRIVATE(rnp, lock));\n\t\t\tlockdep_set_class_and_name(&ACCESS_PRIVATE(rnp, lock),\n\t\t\t\t\t\t   &rcu_node_class[i], buf[i]);\n\t\t\traw_spin_lock_init(&rnp->fqslock);\n\t\t\tlockdep_set_class_and_name(&rnp->fqslock,\n\t\t\t\t\t\t   &rcu_fqs_class[i], fqs[i]);\n\t\t\trnp->gp_seq = rcu_state.gp_seq;\n\t\t\trnp->gp_seq_needed = rcu_state.gp_seq;\n\t\t\trnp->completedqs = rcu_state.gp_seq;\n\t\t\trnp->qsmask = 0;\n\t\t\trnp->qsmaskinit = 0;\n\t\t\trnp->grplo = j * cpustride;\n\t\t\trnp->grphi = (j + 1) * cpustride - 1;\n\t\t\tif (rnp->grphi >= nr_cpu_ids)\n\t\t\t\trnp->grphi = nr_cpu_ids - 1;\n\t\t\tif (i == 0) {\n\t\t\t\trnp->grpnum = 0;\n\t\t\t\trnp->grpmask = 0;\n\t\t\t\trnp->parent = NULL;\n\t\t\t} else {\n\t\t\t\trnp->grpnum = j % levelspread[i - 1];\n\t\t\t\trnp->grpmask = BIT(rnp->grpnum);\n\t\t\t\trnp->parent = rcu_state.level[i - 1] +\n\t\t\t\t\t      j / levelspread[i - 1];\n\t\t\t}\n\t\t\trnp->level = i;\n\t\t\tINIT_LIST_HEAD(&rnp->blkd_tasks);\n\t\t\trcu_init_one_nocb(rnp);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[0]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[1]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[2]);\n\t\t\tinit_waitqueue_head(&rnp->exp_wq[3]);\n\t\t\tspin_lock_init(&rnp->exp_lock);\n\t\t}\n\t}\n\n\tinit_swait_queue_head(&rcu_state.gp_wq);\n\tinit_swait_queue_head(&rcu_state.expedited_wq);\n\trnp = rcu_first_leaf_node();\n\tfor_each_possible_cpu(i) {\n\t\twhile (i > rnp->grphi)\n\t\t\trnp++;\n\t\tper_cpu_ptr(&rcu_data, i)->mynode = rnp;\n\t\trcu_boot_init_percpu_data(i);\n\t}\n}\n\n/*\n * Compute the rcu_node tree geometry from kernel parameters.  This cannot\n * replace the definitions in tree.h because those are needed to size\n * the ->node array in the rcu_state structure.\n */\nstatic void __init rcu_init_geometry(void)\n{\n\tulong d;\n\tint i;\n\tint rcu_capacity[RCU_NUM_LVLS];\n\n\t/*\n\t * Initialize any unspecified boot parameters.\n\t * The default values of jiffies_till_first_fqs and\n\t * jiffies_till_next_fqs are set to the RCU_JIFFIES_TILL_FORCE_QS\n\t * value, which is a function of HZ, then adding one for each\n\t * RCU_JIFFIES_FQS_DIV CPUs that might be on the system.\n\t */\n\td = RCU_JIFFIES_TILL_FORCE_QS + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tif (jiffies_till_first_fqs == ULONG_MAX)\n\t\tjiffies_till_first_fqs = d;\n\tif (jiffies_till_next_fqs == ULONG_MAX)\n\t\tjiffies_till_next_fqs = d;\n\tadjust_jiffies_till_sched_qs();\n\n\t/* If the compile-time values are accurate, just leave. */\n\tif (rcu_fanout_leaf == RCU_FANOUT_LEAF &&\n\t    nr_cpu_ids == NR_CPUS)\n\t\treturn;\n\tpr_info(\"Adjusting geometry for rcu_fanout_leaf=%d, nr_cpu_ids=%u\\n\",\n\t\trcu_fanout_leaf, nr_cpu_ids);\n\n\t/*\n\t * The boot-time rcu_fanout_leaf parameter must be at least two\n\t * and cannot exceed the number of bits in the rcu_node masks.\n\t * Complain and fall back to the compile-time values if this\n\t * limit is exceeded.\n\t */\n\tif (rcu_fanout_leaf < 2 ||\n\t    rcu_fanout_leaf > sizeof(unsigned long) * 8) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Compute number of nodes that can be handled an rcu_node tree\n\t * with the given number of levels.\n\t */\n\trcu_capacity[0] = rcu_fanout_leaf;\n\tfor (i = 1; i < RCU_NUM_LVLS; i++)\n\t\trcu_capacity[i] = rcu_capacity[i - 1] * RCU_FANOUT;\n\n\t/*\n\t * The tree must be able to accommodate the configured number of CPUs.\n\t * If this limit is exceeded, fall back to the compile-time values.\n\t */\n\tif (nr_cpu_ids > rcu_capacity[RCU_NUM_LVLS - 1]) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* Calculate the number of levels in the tree. */\n\tfor (i = 0; nr_cpu_ids > rcu_capacity[i]; i++) {\n\t}\n\trcu_num_lvls = i + 1;\n\n\t/* Calculate the number of rcu_nodes at each level of the tree. */\n\tfor (i = 0; i < rcu_num_lvls; i++) {\n\t\tint cap = rcu_capacity[(rcu_num_lvls - 1) - i];\n\t\tnum_rcu_lvl[i] = DIV_ROUND_UP(nr_cpu_ids, cap);\n\t}\n\n\t/* Calculate the total number of rcu_node structures. */\n\trcu_num_nodes = 0;\n\tfor (i = 0; i < rcu_num_lvls; i++)\n\t\trcu_num_nodes += num_rcu_lvl[i];\n}\n\n/*\n * Dump out the structure of the rcu_node combining tree associated\n * with the rcu_state structure.\n */\nstatic void __init rcu_dump_rcu_node_tree(void)\n{\n\tint level = 0;\n\tstruct rcu_node *rnp;\n\n\tpr_info(\"rcu_node tree layout dump\\n\");\n\tpr_info(\" \");\n\trcu_for_each_node_breadth_first(rnp) {\n\t\tif (rnp->level != level) {\n\t\t\tpr_cont(\"\\n\");\n\t\t\tpr_info(\" \");\n\t\t\tlevel = rnp->level;\n\t\t}\n\t\tpr_cont(\"%d:%d ^%d  \", rnp->grplo, rnp->grphi, rnp->grpnum);\n\t}\n\tpr_cont(\"\\n\");\n}\n\nstruct workqueue_struct *rcu_gp_wq;\nstruct workqueue_struct *rcu_par_gp_wq;\n\nstatic void __init kfree_rcu_batch_init(void)\n{\n\tint cpu;\n\tint i;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tfor (i = 0; i < KFREE_N_BATCHES; i++) {\n\t\t\tINIT_RCU_WORK(&krcp->krw_arr[i].rcu_work, kfree_rcu_work);\n\t\t\tkrcp->krw_arr[i].krcp = krcp;\n\t\t}\n\n\t\tINIT_DELAYED_WORK(&krcp->monitor_work, kfree_rcu_monitor);\n\t\tINIT_WORK(&krcp->page_cache_work, fill_page_cache_func);\n\t\tkrcp->initialized = true;\n\t}\n\tif (register_shrinker(&kfree_rcu_shrinker))\n\t\tpr_err(\"Failed to register kfree_rcu() shrinker!\\n\");\n}\n\nvoid __init rcu_init(void)\n{\n\tint cpu;\n\n\trcu_early_boot_tests();\n\n\tkfree_rcu_batch_init();\n\trcu_bootup_announce();\n\trcu_init_geometry();\n\trcu_init_one();\n\tif (dump_tree)\n\t\trcu_dump_rcu_node_tree();\n\tif (use_softirq)\n\t\topen_softirq(RCU_SOFTIRQ, rcu_core_si);\n\n\t/*\n\t * We don't need protection against CPU-hotplug here because\n\t * this is called early in boot, before either interrupts\n\t * or the scheduler are operational.\n\t */\n\tpm_notifier(rcu_pm_notify, 0);\n\tfor_each_online_cpu(cpu) {\n\t\trcutree_prepare_cpu(cpu);\n\t\trcu_cpu_starting(cpu);\n\t\trcutree_online_cpu(cpu);\n\t}\n\n\t/* Create workqueue for expedited GPs and for Tree SRCU. */\n\trcu_gp_wq = alloc_workqueue(\"rcu_gp\", WQ_MEM_RECLAIM, 0);\n\tWARN_ON(!rcu_gp_wq);\n\trcu_par_gp_wq = alloc_workqueue(\"rcu_par_gp\", WQ_MEM_RECLAIM, 0);\n\tWARN_ON(!rcu_par_gp_wq);\n\tsrcu_init();\n\n\t/* Fill in default value for rcutree.qovld boot parameter. */\n\t/* -After- the rcu_node ->lock fields are initialized! */\n\tif (qovld < 0)\n\t\tqovld_calc = DEFAULT_RCU_QOVLD_MULT * qhimark;\n\telse\n\t\tqovld_calc = qovld;\n}\n\n#include \"tree_stall.h\"\n#include \"tree_exp.h\"\n#include \"tree_plugin.h\"\n"}}, "reports": [{"events": [{"location": {"col": 2, "file": 0, "line": 264}, "message": "Value stored to 'seq' is never read"}, {"location": {"col": 2, "file": 0, "line": 264}, "message": "Value stored to 'seq' is never read"}], "macros": [], "notes": [], "path": "/src/kernel/rcu/tree.c", "reportHash": "76fb2d74f16272ef996e3771a0e9ebcd", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 1953}, "message": "Value stored to 'ret' is never read"}, {"location": {"col": 3, "file": 0, "line": 1953}, "message": "Value stored to 'ret' is never read"}], "macros": [], "notes": [], "path": "/src/kernel/rcu/tree.c", "reportHash": "cade51a4ee687552d84e63cff0066f09", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
