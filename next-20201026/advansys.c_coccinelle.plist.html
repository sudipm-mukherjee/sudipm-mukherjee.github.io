<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/scsi/advansys.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * advansys.c - Linux Host Driver for AdvanSys SCSI Adapters\n *\n * Copyright (c) 1995-2000 Advanced System Products, Inc.\n * Copyright (c) 2000-2001 ConnectCom Solutions, Inc.\n * Copyright (c) 2007 Matthew Wilcox <matthew@wil.cx>\n * Copyright (c) 2014 Hannes Reinecke <hare@suse.de>\n * All Rights Reserved.\n */\n\n/*\n * As of March 8, 2000 Advanced System Products, Inc. (AdvanSys)\n * changed its name to ConnectCom Solutions, Inc.\n * On June 18, 2001 Initio Corp. acquired ConnectCom's SCSI assets\n */\n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/isa.h>\n#include <linux/eisa.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware.h>\n#include <linux/dmapool.h>\n\n#include <asm/io.h>\n#include <asm/dma.h>\n\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n\n#define DRV_NAME \"advansys\"\n#define ASC_VERSION \"3.5\"\t/* AdvanSys Driver Version */\n\n/* FIXME:\n *\n *  1. Use scsi_transport_spi\n *  2. advansys_info is not safe against multiple simultaneous callers\n *  3. Add module_param to override ISA/VLB ioport array\n */\n\n/* Enable driver /proc statistics. */\n#define ADVANSYS_STATS\n\n/* Enable driver tracing. */\n#undef ADVANSYS_DEBUG\n\ntypedef unsigned char uchar;\n\n#define isodd_word(val)   ((((uint)val) & (uint)0x0001) != 0)\n\n#define PCI_VENDOR_ID_ASP\t\t0x10cd\n#define PCI_DEVICE_ID_ASP_1200A\t\t0x1100\n#define PCI_DEVICE_ID_ASP_ABP940\t0x1200\n#define PCI_DEVICE_ID_ASP_ABP940U\t0x1300\n#define PCI_DEVICE_ID_ASP_ABP940UW\t0x2300\n#define PCI_DEVICE_ID_38C0800_REV1\t0x2500\n#define PCI_DEVICE_ID_38C1600_REV1\t0x2700\n\n#define PortAddr                 unsigned int\t/* port address size  */\n#define inp(port)                inb(port)\n#define outp(port, byte)         outb((byte), (port))\n\n#define inpw(port)               inw(port)\n#define outpw(port, word)        outw((word), (port))\n\n#define ASC_MAX_SG_QUEUE    7\n#define ASC_MAX_SG_LIST     255\n\n#define ASC_CS_TYPE  unsigned short\n\n#define ASC_IS_ISA          (0x0001)\n#define ASC_IS_ISAPNP       (0x0081)\n#define ASC_IS_EISA         (0x0002)\n#define ASC_IS_PCI          (0x0004)\n#define ASC_IS_PCI_ULTRA    (0x0104)\n#define ASC_IS_PCMCIA       (0x0008)\n#define ASC_IS_MCA          (0x0020)\n#define ASC_IS_VL           (0x0040)\n#define ASC_IS_WIDESCSI_16  (0x0100)\n#define ASC_IS_WIDESCSI_32  (0x0200)\n#define ASC_IS_BIG_ENDIAN   (0x8000)\n\n#define ASC_CHIP_MIN_VER_VL      (0x01)\n#define ASC_CHIP_MAX_VER_VL      (0x07)\n#define ASC_CHIP_MIN_VER_PCI     (0x09)\n#define ASC_CHIP_MAX_VER_PCI     (0x0F)\n#define ASC_CHIP_VER_PCI_BIT     (0x08)\n#define ASC_CHIP_MIN_VER_ISA     (0x11)\n#define ASC_CHIP_MIN_VER_ISA_PNP (0x21)\n#define ASC_CHIP_MAX_VER_ISA     (0x27)\n#define ASC_CHIP_VER_ISA_BIT     (0x30)\n#define ASC_CHIP_VER_ISAPNP_BIT  (0x20)\n#define ASC_CHIP_VER_ASYN_BUG    (0x21)\n#define ASC_CHIP_VER_PCI             0x08\n#define ASC_CHIP_VER_PCI_ULTRA_3150  (ASC_CHIP_VER_PCI | 0x02)\n#define ASC_CHIP_VER_PCI_ULTRA_3050  (ASC_CHIP_VER_PCI | 0x03)\n#define ASC_CHIP_MIN_VER_EISA (0x41)\n#define ASC_CHIP_MAX_VER_EISA (0x47)\n#define ASC_CHIP_VER_EISA_BIT (0x40)\n#define ASC_CHIP_LATEST_VER_EISA   ((ASC_CHIP_MIN_VER_EISA - 1) + 3)\n#define ASC_MAX_VL_DMA_COUNT    (0x07FFFFFFL)\n#define ASC_MAX_PCI_DMA_COUNT   (0xFFFFFFFFL)\n#define ASC_MAX_ISA_DMA_COUNT   (0x00FFFFFFL)\n\n#define ASC_SCSI_ID_BITS  3\n#define ASC_SCSI_TIX_TYPE     uchar\n#define ASC_ALL_DEVICE_BIT_SET  0xFF\n#define ASC_SCSI_BIT_ID_TYPE  uchar\n#define ASC_MAX_TID       7\n#define ASC_MAX_LUN       7\n#define ASC_SCSI_WIDTH_BIT_SET  0xFF\n#define ASC_MAX_SENSE_LEN   32\n#define ASC_MIN_SENSE_LEN   14\n#define ASC_SCSI_RESET_HOLD_TIME_US  60\n\n/*\n * Narrow boards only support 12-byte commands, while wide boards\n * extend to 16-byte commands.\n */\n#define ASC_MAX_CDB_LEN     12\n#define ADV_MAX_CDB_LEN     16\n\n#define MS_SDTR_LEN    0x03\n#define MS_WDTR_LEN    0x02\n\n#define ASC_SG_LIST_PER_Q   7\n#define QS_FREE        0x00\n#define QS_READY       0x01\n#define QS_DISC1       0x02\n#define QS_DISC2       0x04\n#define QS_BUSY        0x08\n#define QS_ABORTED     0x40\n#define QS_DONE        0x80\n#define QC_NO_CALLBACK   0x01\n#define QC_SG_SWAP_QUEUE 0x02\n#define QC_SG_HEAD       0x04\n#define QC_DATA_IN       0x08\n#define QC_DATA_OUT      0x10\n#define QC_URGENT        0x20\n#define QC_MSG_OUT       0x40\n#define QC_REQ_SENSE     0x80\n#define QCSG_SG_XFER_LIST  0x02\n#define QCSG_SG_XFER_MORE  0x04\n#define QCSG_SG_XFER_END   0x08\n#define QD_IN_PROGRESS       0x00\n#define QD_NO_ERROR          0x01\n#define QD_ABORTED_BY_HOST   0x02\n#define QD_WITH_ERROR        0x04\n#define QD_INVALID_REQUEST   0x80\n#define QD_INVALID_HOST_NUM  0x81\n#define QD_INVALID_DEVICE    0x82\n#define QD_ERR_INTERNAL      0xFF\n#define QHSTA_NO_ERROR               0x00\n#define QHSTA_M_SEL_TIMEOUT          0x11\n#define QHSTA_M_DATA_OVER_RUN        0x12\n#define QHSTA_M_DATA_UNDER_RUN       0x12\n#define QHSTA_M_UNEXPECTED_BUS_FREE  0x13\n#define QHSTA_M_BAD_BUS_PHASE_SEQ    0x14\n#define QHSTA_D_QDONE_SG_LIST_CORRUPTED 0x21\n#define QHSTA_D_ASC_DVC_ERROR_CODE_SET  0x22\n#define QHSTA_D_HOST_ABORT_FAILED       0x23\n#define QHSTA_D_EXE_SCSI_Q_FAILED       0x24\n#define QHSTA_D_EXE_SCSI_Q_BUSY_TIMEOUT 0x25\n#define QHSTA_D_ASPI_NO_BUF_POOL        0x26\n#define QHSTA_M_WTM_TIMEOUT         0x41\n#define QHSTA_M_BAD_CMPL_STATUS_IN  0x42\n#define QHSTA_M_NO_AUTO_REQ_SENSE   0x43\n#define QHSTA_M_AUTO_REQ_SENSE_FAIL 0x44\n#define QHSTA_M_TARGET_STATUS_BUSY  0x45\n#define QHSTA_M_BAD_TAG_CODE        0x46\n#define QHSTA_M_BAD_QUEUE_FULL_OR_BUSY  0x47\n#define QHSTA_M_HUNG_REQ_SCSI_BUS_RESET 0x48\n#define QHSTA_D_LRAM_CMP_ERROR        0x81\n#define QHSTA_M_MICRO_CODE_ERROR_HALT 0xA1\n#define ASC_FLAG_SCSIQ_REQ        0x01\n#define ASC_FLAG_BIOS_SCSIQ_REQ   0x02\n#define ASC_FLAG_BIOS_ASYNC_IO    0x04\n#define ASC_FLAG_SRB_LINEAR_ADDR  0x08\n#define ASC_FLAG_WIN16            0x10\n#define ASC_FLAG_WIN32            0x20\n#define ASC_FLAG_ISA_OVER_16MB    0x40\n#define ASC_FLAG_DOS_VM_CALLBACK  0x80\n#define ASC_TAG_FLAG_EXTRA_BYTES               0x10\n#define ASC_TAG_FLAG_DISABLE_DISCONNECT        0x04\n#define ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX  0x08\n#define ASC_TAG_FLAG_DISABLE_CHK_COND_INT_HOST 0x40\n#define ASC_SCSIQ_CPY_BEG              4\n#define ASC_SCSIQ_SGHD_CPY_BEG         2\n#define ASC_SCSIQ_B_FWD                0\n#define ASC_SCSIQ_B_BWD                1\n#define ASC_SCSIQ_B_STATUS             2\n#define ASC_SCSIQ_B_QNO                3\n#define ASC_SCSIQ_B_CNTL               4\n#define ASC_SCSIQ_B_SG_QUEUE_CNT       5\n#define ASC_SCSIQ_D_DATA_ADDR          8\n#define ASC_SCSIQ_D_DATA_CNT          12\n#define ASC_SCSIQ_B_SENSE_LEN         20\n#define ASC_SCSIQ_DONE_INFO_BEG       22\n#define ASC_SCSIQ_D_SRBPTR            22\n#define ASC_SCSIQ_B_TARGET_IX         26\n#define ASC_SCSIQ_B_CDB_LEN           28\n#define ASC_SCSIQ_B_TAG_CODE          29\n#define ASC_SCSIQ_W_VM_ID             30\n#define ASC_SCSIQ_DONE_STATUS         32\n#define ASC_SCSIQ_HOST_STATUS         33\n#define ASC_SCSIQ_SCSI_STATUS         34\n#define ASC_SCSIQ_CDB_BEG             36\n#define ASC_SCSIQ_DW_REMAIN_XFER_ADDR 56\n#define ASC_SCSIQ_DW_REMAIN_XFER_CNT  60\n#define ASC_SCSIQ_B_FIRST_SG_WK_QP    48\n#define ASC_SCSIQ_B_SG_WK_QP          49\n#define ASC_SCSIQ_B_SG_WK_IX          50\n#define ASC_SCSIQ_W_ALT_DC1           52\n#define ASC_SCSIQ_B_LIST_CNT          6\n#define ASC_SCSIQ_B_CUR_LIST_CNT      7\n#define ASC_SGQ_B_SG_CNTL             4\n#define ASC_SGQ_B_SG_HEAD_QP          5\n#define ASC_SGQ_B_SG_LIST_CNT         6\n#define ASC_SGQ_B_SG_CUR_LIST_CNT     7\n#define ASC_SGQ_LIST_BEG              8\n#define ASC_DEF_SCSI1_QNG    4\n#define ASC_MAX_SCSI1_QNG    4\n#define ASC_DEF_SCSI2_QNG    16\n#define ASC_MAX_SCSI2_QNG    32\n#define ASC_TAG_CODE_MASK    0x23\n#define ASC_STOP_REQ_RISC_STOP      0x01\n#define ASC_STOP_ACK_RISC_STOP      0x03\n#define ASC_STOP_CLEAN_UP_BUSY_Q    0x10\n#define ASC_STOP_CLEAN_UP_DISC_Q    0x20\n#define ASC_STOP_HOST_REQ_RISC_HALT 0x40\n#define ASC_TIDLUN_TO_IX(tid, lun)  (ASC_SCSI_TIX_TYPE)((tid) + ((lun)<<ASC_SCSI_ID_BITS))\n#define ASC_TID_TO_TARGET_ID(tid)   (ASC_SCSI_BIT_ID_TYPE)(0x01 << (tid))\n#define ASC_TIX_TO_TARGET_ID(tix)   (0x01 << ((tix) & ASC_MAX_TID))\n#define ASC_TIX_TO_TID(tix)         ((tix) & ASC_MAX_TID)\n#define ASC_TID_TO_TIX(tid)         ((tid) & ASC_MAX_TID)\n#define ASC_TIX_TO_LUN(tix)         (((tix) >> ASC_SCSI_ID_BITS) & ASC_MAX_LUN)\n#define ASC_QNO_TO_QADDR(q_no)      ((ASC_QADR_BEG)+((int)(q_no) << 6))\n\ntypedef struct asc_scsiq_1 {\n\tuchar status;\n\tuchar q_no;\n\tuchar cntl;\n\tuchar sg_queue_cnt;\n\tuchar target_id;\n\tuchar target_lun;\n\t__le32 data_addr;\n\t__le32 data_cnt;\n\t__le32 sense_addr;\n\tuchar sense_len;\n\tuchar extra_bytes;\n} ASC_SCSIQ_1;\n\ntypedef struct asc_scsiq_2 {\n\tu32 srb_tag;\n\tuchar target_ix;\n\tuchar flag;\n\tuchar cdb_len;\n\tuchar tag_code;\n\tushort vm_id;\n} ASC_SCSIQ_2;\n\ntypedef struct asc_scsiq_3 {\n\tuchar done_stat;\n\tuchar host_stat;\n\tuchar scsi_stat;\n\tuchar scsi_msg;\n} ASC_SCSIQ_3;\n\ntypedef struct asc_scsiq_4 {\n\tuchar cdb[ASC_MAX_CDB_LEN];\n\tuchar y_first_sg_list_qp;\n\tuchar y_working_sg_qp;\n\tuchar y_working_sg_ix;\n\tuchar y_res;\n\tushort x_req_count;\n\tushort x_reconnect_rtn;\n\t__le32 x_saved_data_addr;\n\t__le32 x_saved_data_cnt;\n} ASC_SCSIQ_4;\n\ntypedef struct asc_q_done_info {\n\tASC_SCSIQ_2 d2;\n\tASC_SCSIQ_3 d3;\n\tuchar q_status;\n\tuchar q_no;\n\tuchar cntl;\n\tuchar sense_len;\n\tuchar extra_bytes;\n\tuchar res;\n\tu32 remain_bytes;\n} ASC_QDONE_INFO;\n\ntypedef struct asc_sg_list {\n\t__le32 addr;\n\t__le32 bytes;\n} ASC_SG_LIST;\n\ntypedef struct asc_sg_head {\n\tushort entry_cnt;\n\tushort queue_cnt;\n\tushort entry_to_copy;\n\tushort res;\n\tASC_SG_LIST sg_list[];\n} ASC_SG_HEAD;\n\ntypedef struct asc_scsi_q {\n\tASC_SCSIQ_1 q1;\n\tASC_SCSIQ_2 q2;\n\tuchar *cdbptr;\n\tASC_SG_HEAD *sg_head;\n\tushort remain_sg_entry_cnt;\n\tushort next_sg_index;\n} ASC_SCSI_Q;\n\ntypedef struct asc_scsi_bios_req_q {\n\tASC_SCSIQ_1 r1;\n\tASC_SCSIQ_2 r2;\n\tuchar *cdbptr;\n\tASC_SG_HEAD *sg_head;\n\tuchar *sense_ptr;\n\tASC_SCSIQ_3 r3;\n\tuchar cdb[ASC_MAX_CDB_LEN];\n\tuchar sense[ASC_MIN_SENSE_LEN];\n} ASC_SCSI_BIOS_REQ_Q;\n\ntypedef struct asc_risc_q {\n\tuchar fwd;\n\tuchar bwd;\n\tASC_SCSIQ_1 i1;\n\tASC_SCSIQ_2 i2;\n\tASC_SCSIQ_3 i3;\n\tASC_SCSIQ_4 i4;\n} ASC_RISC_Q;\n\ntypedef struct asc_sg_list_q {\n\tuchar seq_no;\n\tuchar q_no;\n\tuchar cntl;\n\tuchar sg_head_qp;\n\tuchar sg_list_cnt;\n\tuchar sg_cur_list_cnt;\n} ASC_SG_LIST_Q;\n\ntypedef struct asc_risc_sg_list_q {\n\tuchar fwd;\n\tuchar bwd;\n\tASC_SG_LIST_Q sg;\n\tASC_SG_LIST sg_list[7];\n} ASC_RISC_SG_LIST_Q;\n\n#define ASCQ_ERR_Q_STATUS             0x0D\n#define ASCQ_ERR_CUR_QNG              0x17\n#define ASCQ_ERR_SG_Q_LINKS           0x18\n#define ASCQ_ERR_ISR_RE_ENTRY         0x1A\n#define ASCQ_ERR_CRITICAL_RE_ENTRY    0x1B\n#define ASCQ_ERR_ISR_ON_CRITICAL      0x1C\n\n/*\n * Warning code values are set in ASC_DVC_VAR  'warn_code'.\n */\n#define ASC_WARN_NO_ERROR             0x0000\n#define ASC_WARN_IO_PORT_ROTATE       0x0001\n#define ASC_WARN_EEPROM_CHKSUM        0x0002\n#define ASC_WARN_IRQ_MODIFIED         0x0004\n#define ASC_WARN_AUTO_CONFIG          0x0008\n#define ASC_WARN_CMD_QNG_CONFLICT     0x0010\n#define ASC_WARN_EEPROM_RECOVER       0x0020\n#define ASC_WARN_CFG_MSW_RECOVER      0x0040\n\n/*\n * Error code values are set in {ASC/ADV}_DVC_VAR  'err_code'.\n */\n#define ASC_IERR_NO_CARRIER\t\t0x0001\t/* No more carrier memory */\n#define ASC_IERR_MCODE_CHKSUM\t\t0x0002\t/* micro code check sum error */\n#define ASC_IERR_SET_PC_ADDR\t\t0x0004\n#define ASC_IERR_START_STOP_CHIP\t0x0008\t/* start/stop chip failed */\n#define ASC_IERR_ILLEGAL_CONNECTION\t0x0010\t/* Illegal cable connection */\n#define ASC_IERR_SINGLE_END_DEVICE\t0x0020\t/* SE device on DIFF bus */\n#define ASC_IERR_REVERSED_CABLE\t\t0x0040\t/* Narrow flat cable reversed */\n#define ASC_IERR_SET_SCSI_ID\t\t0x0080\t/* set SCSI ID failed */\n#define ASC_IERR_HVD_DEVICE\t\t0x0100\t/* HVD device on LVD port */\n#define ASC_IERR_BAD_SIGNATURE\t\t0x0200\t/* signature not found */\n#define ASC_IERR_NO_BUS_TYPE\t\t0x0400\n#define ASC_IERR_BIST_PRE_TEST\t\t0x0800\t/* BIST pre-test error */\n#define ASC_IERR_BIST_RAM_TEST\t\t0x1000\t/* BIST RAM test error */\n#define ASC_IERR_BAD_CHIPTYPE\t\t0x2000\t/* Invalid chip_type setting */\n\n#define ASC_DEF_MAX_TOTAL_QNG   (0xF0)\n#define ASC_MIN_TAG_Q_PER_DVC   (0x04)\n#define ASC_MIN_FREE_Q        (0x02)\n#define ASC_MIN_TOTAL_QNG     ((ASC_MAX_SG_QUEUE)+(ASC_MIN_FREE_Q))\n#define ASC_MAX_TOTAL_QNG 240\n#define ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG 16\n#define ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG   8\n#define ASC_MAX_PCI_INRAM_TOTAL_QNG  20\n#define ASC_MAX_INRAM_TAG_QNG   16\n#define ASC_IOADR_GAP   0x10\n#define ASC_SYN_MAX_OFFSET         0x0F\n#define ASC_DEF_SDTR_OFFSET        0x0F\n#define ASC_SDTR_ULTRA_PCI_10MB_INDEX  0x02\n#define ASYN_SDTR_DATA_FIX_PCI_REV_AB 0x41\n\n/* The narrow chip only supports a limited selection of transfer rates.\n * These are encoded in the range 0..7 or 0..15 depending whether the chip\n * is Ultra-capable or not.  These tables let us convert from one to the other.\n */\nstatic const unsigned char asc_syn_xfer_period[8] = {\n\t25, 30, 35, 40, 50, 60, 70, 85\n};\n\nstatic const unsigned char asc_syn_ultra_xfer_period[16] = {\n\t12, 19, 25, 32, 38, 44, 50, 57, 63, 69, 75, 82, 88, 94, 100, 107\n};\n\ntypedef struct ext_msg {\n\tuchar msg_type;\n\tuchar msg_len;\n\tuchar msg_req;\n\tunion {\n\t\tstruct {\n\t\t\tuchar sdtr_xfer_period;\n\t\t\tuchar sdtr_req_ack_offset;\n\t\t} sdtr;\n\t\tstruct {\n\t\t\tuchar wdtr_width;\n\t\t} wdtr;\n\t\tstruct {\n\t\t\tuchar mdp_b3;\n\t\t\tuchar mdp_b2;\n\t\t\tuchar mdp_b1;\n\t\t\tuchar mdp_b0;\n\t\t} mdp;\n\t} u_ext_msg;\n\tuchar res;\n} EXT_MSG;\n\n#define xfer_period     u_ext_msg.sdtr.sdtr_xfer_period\n#define req_ack_offset  u_ext_msg.sdtr.sdtr_req_ack_offset\n#define wdtr_width      u_ext_msg.wdtr.wdtr_width\n#define mdp_b3          u_ext_msg.mdp_b3\n#define mdp_b2          u_ext_msg.mdp_b2\n#define mdp_b1          u_ext_msg.mdp_b1\n#define mdp_b0          u_ext_msg.mdp_b0\n\ntypedef struct asc_dvc_cfg {\n\tASC_SCSI_BIT_ID_TYPE can_tagged_qng;\n\tASC_SCSI_BIT_ID_TYPE cmd_qng_enabled;\n\tASC_SCSI_BIT_ID_TYPE disc_enable;\n\tASC_SCSI_BIT_ID_TYPE sdtr_enable;\n\tuchar chip_scsi_id;\n\tuchar isa_dma_speed;\n\tuchar isa_dma_channel;\n\tuchar chip_version;\n\tushort mcode_date;\n\tushort mcode_version;\n\tuchar max_tag_qng[ASC_MAX_TID + 1];\n\tuchar sdtr_period_offset[ASC_MAX_TID + 1];\n\tuchar adapter_info[6];\n} ASC_DVC_CFG;\n\n#define ASC_DEF_DVC_CNTL       0xFFFF\n#define ASC_DEF_CHIP_SCSI_ID   7\n#define ASC_DEF_ISA_DMA_SPEED  4\n#define ASC_INIT_STATE_BEG_GET_CFG   0x0001\n#define ASC_INIT_STATE_END_GET_CFG   0x0002\n#define ASC_INIT_STATE_BEG_SET_CFG   0x0004\n#define ASC_INIT_STATE_END_SET_CFG   0x0008\n#define ASC_INIT_STATE_BEG_LOAD_MC   0x0010\n#define ASC_INIT_STATE_END_LOAD_MC   0x0020\n#define ASC_INIT_STATE_BEG_INQUIRY   0x0040\n#define ASC_INIT_STATE_END_INQUIRY   0x0080\n#define ASC_INIT_RESET_SCSI_DONE     0x0100\n#define ASC_INIT_STATE_WITHOUT_EEP   0x8000\n#define ASC_BUG_FIX_IF_NOT_DWB       0x0001\n#define ASC_BUG_FIX_ASYN_USE_SYN     0x0002\n#define ASC_MIN_TAGGED_CMD  7\n#define ASC_MAX_SCSI_RESET_WAIT      30\n#define ASC_OVERRUN_BSIZE\t\t64\n\nstruct asc_dvc_var;\t\t/* Forward Declaration. */\n\ntypedef struct asc_dvc_var {\n\tPortAddr iop_base;\n\tushort err_code;\n\tushort dvc_cntl;\n\tushort bug_fix_cntl;\n\tushort bus_type;\n\tASC_SCSI_BIT_ID_TYPE init_sdtr;\n\tASC_SCSI_BIT_ID_TYPE sdtr_done;\n\tASC_SCSI_BIT_ID_TYPE use_tagged_qng;\n\tASC_SCSI_BIT_ID_TYPE unit_not_ready;\n\tASC_SCSI_BIT_ID_TYPE queue_full_or_busy;\n\tASC_SCSI_BIT_ID_TYPE start_motor;\n\tuchar *overrun_buf;\n\tdma_addr_t overrun_dma;\n\tuchar scsi_reset_wait;\n\tuchar chip_no;\n\tbool is_in_int;\n\tuchar max_total_qng;\n\tuchar cur_total_qng;\n\tuchar in_critical_cnt;\n\tuchar last_q_shortage;\n\tushort init_state;\n\tuchar cur_dvc_qng[ASC_MAX_TID + 1];\n\tuchar max_dvc_qng[ASC_MAX_TID + 1];\n\tASC_SCSI_Q *scsiq_busy_head[ASC_MAX_TID + 1];\n\tASC_SCSI_Q *scsiq_busy_tail[ASC_MAX_TID + 1];\n\tconst uchar *sdtr_period_tbl;\n\tASC_DVC_CFG *cfg;\n\tASC_SCSI_BIT_ID_TYPE pci_fix_asyn_xfer_always;\n\tchar redo_scam;\n\tushort res2;\n\tuchar dos_int13_table[ASC_MAX_TID + 1];\n\tunsigned int max_dma_count;\n\tASC_SCSI_BIT_ID_TYPE no_scam;\n\tASC_SCSI_BIT_ID_TYPE pci_fix_asyn_xfer;\n\tuchar min_sdtr_index;\n\tuchar max_sdtr_index;\n\tstruct asc_board *drv_ptr;\n\tunsigned int uc_break;\n} ASC_DVC_VAR;\n\ntypedef struct asc_dvc_inq_info {\n\tuchar type[ASC_MAX_TID + 1][ASC_MAX_LUN + 1];\n} ASC_DVC_INQ_INFO;\n\ntypedef struct asc_cap_info {\n\tu32 lba;\n\tu32 blk_size;\n} ASC_CAP_INFO;\n\ntypedef struct asc_cap_info_array {\n\tASC_CAP_INFO cap_info[ASC_MAX_TID + 1][ASC_MAX_LUN + 1];\n} ASC_CAP_INFO_ARRAY;\n\n#define ASC_MCNTL_NO_SEL_TIMEOUT  (ushort)0x0001\n#define ASC_MCNTL_NULL_TARGET     (ushort)0x0002\n#define ASC_CNTL_INITIATOR         (ushort)0x0001\n#define ASC_CNTL_BIOS_GT_1GB       (ushort)0x0002\n#define ASC_CNTL_BIOS_GT_2_DISK    (ushort)0x0004\n#define ASC_CNTL_BIOS_REMOVABLE    (ushort)0x0008\n#define ASC_CNTL_NO_SCAM           (ushort)0x0010\n#define ASC_CNTL_INT_MULTI_Q       (ushort)0x0080\n#define ASC_CNTL_NO_LUN_SUPPORT    (ushort)0x0040\n#define ASC_CNTL_NO_VERIFY_COPY    (ushort)0x0100\n#define ASC_CNTL_RESET_SCSI        (ushort)0x0200\n#define ASC_CNTL_INIT_INQUIRY      (ushort)0x0400\n#define ASC_CNTL_INIT_VERBOSE      (ushort)0x0800\n#define ASC_CNTL_SCSI_PARITY       (ushort)0x1000\n#define ASC_CNTL_BURST_MODE        (ushort)0x2000\n#define ASC_CNTL_SDTR_ENABLE_ULTRA (ushort)0x4000\n#define ASC_EEP_DVC_CFG_BEG_VL    2\n#define ASC_EEP_MAX_DVC_ADDR_VL   15\n#define ASC_EEP_DVC_CFG_BEG      32\n#define ASC_EEP_MAX_DVC_ADDR     45\n#define ASC_EEP_MAX_RETRY        20\n\n/*\n * These macros keep the chip SCSI id and ISA DMA speed\n * bitfields in board order. C bitfields aren't portable\n * between big and little-endian platforms so they are\n * not used.\n */\n\n#define ASC_EEP_GET_CHIP_ID(cfg)    ((cfg)->id_speed & 0x0f)\n#define ASC_EEP_GET_DMA_SPD(cfg)    (((cfg)->id_speed & 0xf0) >> 4)\n#define ASC_EEP_SET_CHIP_ID(cfg, sid) \\\n   ((cfg)->id_speed = ((cfg)->id_speed & 0xf0) | ((sid) & ASC_MAX_TID))\n#define ASC_EEP_SET_DMA_SPD(cfg, spd) \\\n   ((cfg)->id_speed = ((cfg)->id_speed & 0x0f) | ((spd) & 0x0f) << 4)\n\ntypedef struct asceep_config {\n\tushort cfg_lsw;\n\tushort cfg_msw;\n\tuchar init_sdtr;\n\tuchar disc_enable;\n\tuchar use_cmd_qng;\n\tuchar start_motor;\n\tuchar max_total_qng;\n\tuchar max_tag_qng;\n\tuchar bios_scan;\n\tuchar power_up_wait;\n\tuchar no_scam;\n\tuchar id_speed;\t\t/* low order 4 bits is chip scsi id */\n\t/* high order 4 bits is isa dma speed */\n\tuchar dos_int13_table[ASC_MAX_TID + 1];\n\tuchar adapter_info[6];\n\tushort cntl;\n\tushort chksum;\n} ASCEEP_CONFIG;\n\n#define ASC_EEP_CMD_READ          0x80\n#define ASC_EEP_CMD_WRITE         0x40\n#define ASC_EEP_CMD_WRITE_ABLE    0x30\n#define ASC_EEP_CMD_WRITE_DISABLE 0x00\n#define ASCV_MSGOUT_BEG         0x0000\n#define ASCV_MSGOUT_SDTR_PERIOD (ASCV_MSGOUT_BEG+3)\n#define ASCV_MSGOUT_SDTR_OFFSET (ASCV_MSGOUT_BEG+4)\n#define ASCV_BREAK_SAVED_CODE   (ushort)0x0006\n#define ASCV_MSGIN_BEG          (ASCV_MSGOUT_BEG+8)\n#define ASCV_MSGIN_SDTR_PERIOD  (ASCV_MSGIN_BEG+3)\n#define ASCV_MSGIN_SDTR_OFFSET  (ASCV_MSGIN_BEG+4)\n#define ASCV_SDTR_DATA_BEG      (ASCV_MSGIN_BEG+8)\n#define ASCV_SDTR_DONE_BEG      (ASCV_SDTR_DATA_BEG+8)\n#define ASCV_MAX_DVC_QNG_BEG    (ushort)0x0020\n#define ASCV_BREAK_ADDR           (ushort)0x0028\n#define ASCV_BREAK_NOTIFY_COUNT   (ushort)0x002A\n#define ASCV_BREAK_CONTROL        (ushort)0x002C\n#define ASCV_BREAK_HIT_COUNT      (ushort)0x002E\n\n#define ASCV_ASCDVC_ERR_CODE_W  (ushort)0x0030\n#define ASCV_MCODE_CHKSUM_W   (ushort)0x0032\n#define ASCV_MCODE_SIZE_W     (ushort)0x0034\n#define ASCV_STOP_CODE_B      (ushort)0x0036\n#define ASCV_DVC_ERR_CODE_B   (ushort)0x0037\n#define ASCV_OVERRUN_PADDR_D  (ushort)0x0038\n#define ASCV_OVERRUN_BSIZE_D  (ushort)0x003C\n#define ASCV_HALTCODE_W       (ushort)0x0040\n#define ASCV_CHKSUM_W         (ushort)0x0042\n#define ASCV_MC_DATE_W        (ushort)0x0044\n#define ASCV_MC_VER_W         (ushort)0x0046\n#define ASCV_NEXTRDY_B        (ushort)0x0048\n#define ASCV_DONENEXT_B       (ushort)0x0049\n#define ASCV_USE_TAGGED_QNG_B (ushort)0x004A\n#define ASCV_SCSIBUSY_B       (ushort)0x004B\n#define ASCV_Q_DONE_IN_PROGRESS_B  (ushort)0x004C\n#define ASCV_CURCDB_B         (ushort)0x004D\n#define ASCV_RCLUN_B          (ushort)0x004E\n#define ASCV_BUSY_QHEAD_B     (ushort)0x004F\n#define ASCV_DISC1_QHEAD_B    (ushort)0x0050\n#define ASCV_DISC_ENABLE_B    (ushort)0x0052\n#define ASCV_CAN_TAGGED_QNG_B (ushort)0x0053\n#define ASCV_HOSTSCSI_ID_B    (ushort)0x0055\n#define ASCV_MCODE_CNTL_B     (ushort)0x0056\n#define ASCV_NULL_TARGET_B    (ushort)0x0057\n#define ASCV_FREE_Q_HEAD_W    (ushort)0x0058\n#define ASCV_DONE_Q_TAIL_W    (ushort)0x005A\n#define ASCV_FREE_Q_HEAD_B    (ushort)(ASCV_FREE_Q_HEAD_W+1)\n#define ASCV_DONE_Q_TAIL_B    (ushort)(ASCV_DONE_Q_TAIL_W+1)\n#define ASCV_HOST_FLAG_B      (ushort)0x005D\n#define ASCV_TOTAL_READY_Q_B  (ushort)0x0064\n#define ASCV_VER_SERIAL_B     (ushort)0x0065\n#define ASCV_HALTCODE_SAVED_W (ushort)0x0066\n#define ASCV_WTM_FLAG_B       (ushort)0x0068\n#define ASCV_RISC_FLAG_B      (ushort)0x006A\n#define ASCV_REQ_SG_LIST_QP   (ushort)0x006B\n#define ASC_HOST_FLAG_IN_ISR        0x01\n#define ASC_HOST_FLAG_ACK_INT       0x02\n#define ASC_RISC_FLAG_GEN_INT      0x01\n#define ASC_RISC_FLAG_REQ_SG_LIST  0x02\n#define IOP_CTRL         (0x0F)\n#define IOP_STATUS       (0x0E)\n#define IOP_INT_ACK      IOP_STATUS\n#define IOP_REG_IFC      (0x0D)\n#define IOP_SYN_OFFSET    (0x0B)\n#define IOP_EXTRA_CONTROL (0x0D)\n#define IOP_REG_PC        (0x0C)\n#define IOP_RAM_ADDR      (0x0A)\n#define IOP_RAM_DATA      (0x08)\n#define IOP_EEP_DATA      (0x06)\n#define IOP_EEP_CMD       (0x07)\n#define IOP_VERSION       (0x03)\n#define IOP_CONFIG_HIGH   (0x04)\n#define IOP_CONFIG_LOW    (0x02)\n#define IOP_SIG_BYTE      (0x01)\n#define IOP_SIG_WORD      (0x00)\n#define IOP_REG_DC1      (0x0E)\n#define IOP_REG_DC0      (0x0C)\n#define IOP_REG_SB       (0x0B)\n#define IOP_REG_DA1      (0x0A)\n#define IOP_REG_DA0      (0x08)\n#define IOP_REG_SC       (0x09)\n#define IOP_DMA_SPEED    (0x07)\n#define IOP_REG_FLAG     (0x07)\n#define IOP_FIFO_H       (0x06)\n#define IOP_FIFO_L       (0x04)\n#define IOP_REG_ID       (0x05)\n#define IOP_REG_QP       (0x03)\n#define IOP_REG_IH       (0x02)\n#define IOP_REG_IX       (0x01)\n#define IOP_REG_AX       (0x00)\n#define IFC_REG_LOCK      (0x00)\n#define IFC_REG_UNLOCK    (0x09)\n#define IFC_WR_EN_FILTER  (0x10)\n#define IFC_RD_NO_EEPROM  (0x10)\n#define IFC_SLEW_RATE     (0x20)\n#define IFC_ACT_NEG       (0x40)\n#define IFC_INP_FILTER    (0x80)\n#define IFC_INIT_DEFAULT  (IFC_ACT_NEG | IFC_REG_UNLOCK)\n#define SC_SEL   (uchar)(0x80)\n#define SC_BSY   (uchar)(0x40)\n#define SC_ACK   (uchar)(0x20)\n#define SC_REQ   (uchar)(0x10)\n#define SC_ATN   (uchar)(0x08)\n#define SC_IO    (uchar)(0x04)\n#define SC_CD    (uchar)(0x02)\n#define SC_MSG   (uchar)(0x01)\n#define SEC_SCSI_CTL         (uchar)(0x80)\n#define SEC_ACTIVE_NEGATE    (uchar)(0x40)\n#define SEC_SLEW_RATE        (uchar)(0x20)\n#define SEC_ENABLE_FILTER    (uchar)(0x10)\n#define ASC_HALT_EXTMSG_IN     (ushort)0x8000\n#define ASC_HALT_CHK_CONDITION (ushort)0x8100\n#define ASC_HALT_SS_QUEUE_FULL (ushort)0x8200\n#define ASC_HALT_DISABLE_ASYN_USE_SYN_FIX  (ushort)0x8300\n#define ASC_HALT_ENABLE_ASYN_USE_SYN_FIX   (ushort)0x8400\n#define ASC_HALT_SDTR_REJECTED (ushort)0x4000\n#define ASC_HALT_HOST_COPY_SG_LIST_TO_RISC ( ushort )0x2000\n#define ASC_MAX_QNO        0xF8\n#define ASC_DATA_SEC_BEG   (ushort)0x0080\n#define ASC_DATA_SEC_END   (ushort)0x0080\n#define ASC_CODE_SEC_BEG   (ushort)0x0080\n#define ASC_CODE_SEC_END   (ushort)0x0080\n#define ASC_QADR_BEG       (0x4000)\n#define ASC_QADR_USED      (ushort)(ASC_MAX_QNO * 64)\n#define ASC_QADR_END       (ushort)0x7FFF\n#define ASC_QLAST_ADR      (ushort)0x7FC0\n#define ASC_QBLK_SIZE      0x40\n#define ASC_BIOS_DATA_QBEG 0xF8\n#define ASC_MIN_ACTIVE_QNO 0x01\n#define ASC_QLINK_END      0xFF\n#define ASC_EEPROM_WORDS   0x10\n#define ASC_MAX_MGS_LEN    0x10\n#define ASC_BIOS_ADDR_DEF  0xDC00\n#define ASC_BIOS_SIZE      0x3800\n#define ASC_BIOS_RAM_OFF   0x3800\n#define ASC_BIOS_RAM_SIZE  0x800\n#define ASC_BIOS_MIN_ADDR  0xC000\n#define ASC_BIOS_MAX_ADDR  0xEC00\n#define ASC_BIOS_BANK_SIZE 0x0400\n#define ASC_MCODE_START_ADDR  0x0080\n#define ASC_CFG0_HOST_INT_ON    0x0020\n#define ASC_CFG0_BIOS_ON        0x0040\n#define ASC_CFG0_VERA_BURST_ON  0x0080\n#define ASC_CFG0_SCSI_PARITY_ON 0x0800\n#define ASC_CFG1_SCSI_TARGET_ON 0x0080\n#define ASC_CFG1_LRAM_8BITS_ON  0x0800\n#define ASC_CFG_MSW_CLR_MASK    0x3080\n#define CSW_TEST1             (ASC_CS_TYPE)0x8000\n#define CSW_AUTO_CONFIG       (ASC_CS_TYPE)0x4000\n#define CSW_RESERVED1         (ASC_CS_TYPE)0x2000\n#define CSW_IRQ_WRITTEN       (ASC_CS_TYPE)0x1000\n#define CSW_33MHZ_SELECTED    (ASC_CS_TYPE)0x0800\n#define CSW_TEST2             (ASC_CS_TYPE)0x0400\n#define CSW_TEST3             (ASC_CS_TYPE)0x0200\n#define CSW_RESERVED2         (ASC_CS_TYPE)0x0100\n#define CSW_DMA_DONE          (ASC_CS_TYPE)0x0080\n#define CSW_FIFO_RDY          (ASC_CS_TYPE)0x0040\n#define CSW_EEP_READ_DONE     (ASC_CS_TYPE)0x0020\n#define CSW_HALTED            (ASC_CS_TYPE)0x0010\n#define CSW_SCSI_RESET_ACTIVE (ASC_CS_TYPE)0x0008\n#define CSW_PARITY_ERR        (ASC_CS_TYPE)0x0004\n#define CSW_SCSI_RESET_LATCH  (ASC_CS_TYPE)0x0002\n#define CSW_INT_PENDING       (ASC_CS_TYPE)0x0001\n#define CIW_CLR_SCSI_RESET_INT (ASC_CS_TYPE)0x1000\n#define CIW_INT_ACK      (ASC_CS_TYPE)0x0100\n#define CIW_TEST1        (ASC_CS_TYPE)0x0200\n#define CIW_TEST2        (ASC_CS_TYPE)0x0400\n#define CIW_SEL_33MHZ    (ASC_CS_TYPE)0x0800\n#define CIW_IRQ_ACT      (ASC_CS_TYPE)0x1000\n#define CC_CHIP_RESET   (uchar)0x80\n#define CC_SCSI_RESET   (uchar)0x40\n#define CC_HALT         (uchar)0x20\n#define CC_SINGLE_STEP  (uchar)0x10\n#define CC_DMA_ABLE     (uchar)0x08\n#define CC_TEST         (uchar)0x04\n#define CC_BANK_ONE     (uchar)0x02\n#define CC_DIAG         (uchar)0x01\n#define ASC_1000_ID0W      0x04C1\n#define ASC_1000_ID0W_FIX  0x00C1\n#define ASC_1000_ID1B      0x25\n#define ASC_EISA_REV_IOP_MASK  (0x0C83)\n#define ASC_EISA_CFG_IOP_MASK  (0x0C86)\n#define ASC_GET_EISA_SLOT(iop)  (PortAddr)((iop) & 0xF000)\n#define INS_HALTINT        (ushort)0x6281\n#define INS_HALT           (ushort)0x6280\n#define INS_SINT           (ushort)0x6200\n#define INS_RFLAG_WTM      (ushort)0x7380\n#define ASC_MC_SAVE_CODE_WSIZE  0x500\n#define ASC_MC_SAVE_DATA_WSIZE  0x40\n\ntypedef struct asc_mc_saved {\n\tushort data[ASC_MC_SAVE_DATA_WSIZE];\n\tushort code[ASC_MC_SAVE_CODE_WSIZE];\n} ASC_MC_SAVED;\n\n#define AscGetQDoneInProgress(port)         AscReadLramByte((port), ASCV_Q_DONE_IN_PROGRESS_B)\n#define AscPutQDoneInProgress(port, val)    AscWriteLramByte((port), ASCV_Q_DONE_IN_PROGRESS_B, val)\n#define AscGetVarFreeQHead(port)            AscReadLramWord((port), ASCV_FREE_Q_HEAD_W)\n#define AscGetVarDoneQTail(port)            AscReadLramWord((port), ASCV_DONE_Q_TAIL_W)\n#define AscPutVarFreeQHead(port, val)       AscWriteLramWord((port), ASCV_FREE_Q_HEAD_W, val)\n#define AscPutVarDoneQTail(port, val)       AscWriteLramWord((port), ASCV_DONE_Q_TAIL_W, val)\n#define AscGetRiscVarFreeQHead(port)        AscReadLramByte((port), ASCV_NEXTRDY_B)\n#define AscGetRiscVarDoneQTail(port)        AscReadLramByte((port), ASCV_DONENEXT_B)\n#define AscPutRiscVarFreeQHead(port, val)   AscWriteLramByte((port), ASCV_NEXTRDY_B, val)\n#define AscPutRiscVarDoneQTail(port, val)   AscWriteLramByte((port), ASCV_DONENEXT_B, val)\n#define AscPutMCodeSDTRDoneAtID(port, id, data)  AscWriteLramByte((port), (ushort)((ushort)ASCV_SDTR_DONE_BEG+(ushort)id), (data))\n#define AscGetMCodeSDTRDoneAtID(port, id)        AscReadLramByte((port), (ushort)((ushort)ASCV_SDTR_DONE_BEG+(ushort)id))\n#define AscPutMCodeInitSDTRAtID(port, id, data)  AscWriteLramByte((port), (ushort)((ushort)ASCV_SDTR_DATA_BEG+(ushort)id), data)\n#define AscGetMCodeInitSDTRAtID(port, id)        AscReadLramByte((port), (ushort)((ushort)ASCV_SDTR_DATA_BEG+(ushort)id))\n#define AscGetChipSignatureByte(port)     (uchar)inp((port)+IOP_SIG_BYTE)\n#define AscGetChipSignatureWord(port)     (ushort)inpw((port)+IOP_SIG_WORD)\n#define AscGetChipVerNo(port)             (uchar)inp((port)+IOP_VERSION)\n#define AscGetChipCfgLsw(port)            (ushort)inpw((port)+IOP_CONFIG_LOW)\n#define AscGetChipCfgMsw(port)            (ushort)inpw((port)+IOP_CONFIG_HIGH)\n#define AscSetChipCfgLsw(port, data)      outpw((port)+IOP_CONFIG_LOW, data)\n#define AscSetChipCfgMsw(port, data)      outpw((port)+IOP_CONFIG_HIGH, data)\n#define AscGetChipEEPCmd(port)            (uchar)inp((port)+IOP_EEP_CMD)\n#define AscSetChipEEPCmd(port, data)      outp((port)+IOP_EEP_CMD, data)\n#define AscGetChipEEPData(port)           (ushort)inpw((port)+IOP_EEP_DATA)\n#define AscSetChipEEPData(port, data)     outpw((port)+IOP_EEP_DATA, data)\n#define AscGetChipLramAddr(port)          (ushort)inpw((PortAddr)((port)+IOP_RAM_ADDR))\n#define AscSetChipLramAddr(port, addr)    outpw((PortAddr)((port)+IOP_RAM_ADDR), addr)\n#define AscGetChipLramData(port)          (ushort)inpw((port)+IOP_RAM_DATA)\n#define AscSetChipLramData(port, data)    outpw((port)+IOP_RAM_DATA, data)\n#define AscGetChipIFC(port)               (uchar)inp((port)+IOP_REG_IFC)\n#define AscSetChipIFC(port, data)          outp((port)+IOP_REG_IFC, data)\n#define AscGetChipStatus(port)            (ASC_CS_TYPE)inpw((port)+IOP_STATUS)\n#define AscSetChipStatus(port, cs_val)    outpw((port)+IOP_STATUS, cs_val)\n#define AscGetChipControl(port)           (uchar)inp((port)+IOP_CTRL)\n#define AscSetChipControl(port, cc_val)   outp((port)+IOP_CTRL, cc_val)\n#define AscGetChipSyn(port)               (uchar)inp((port)+IOP_SYN_OFFSET)\n#define AscSetChipSyn(port, data)         outp((port)+IOP_SYN_OFFSET, data)\n#define AscSetPCAddr(port, data)          outpw((port)+IOP_REG_PC, data)\n#define AscGetPCAddr(port)                (ushort)inpw((port)+IOP_REG_PC)\n#define AscIsIntPending(port)             (AscGetChipStatus(port) & (CSW_INT_PENDING | CSW_SCSI_RESET_LATCH))\n#define AscGetChipScsiID(port)            ((AscGetChipCfgLsw(port) >> 8) & ASC_MAX_TID)\n#define AscGetExtraControl(port)          (uchar)inp((port)+IOP_EXTRA_CONTROL)\n#define AscSetExtraControl(port, data)    outp((port)+IOP_EXTRA_CONTROL, data)\n#define AscReadChipAX(port)               (ushort)inpw((port)+IOP_REG_AX)\n#define AscWriteChipAX(port, data)        outpw((port)+IOP_REG_AX, data)\n#define AscReadChipIX(port)               (uchar)inp((port)+IOP_REG_IX)\n#define AscWriteChipIX(port, data)        outp((port)+IOP_REG_IX, data)\n#define AscReadChipIH(port)               (ushort)inpw((port)+IOP_REG_IH)\n#define AscWriteChipIH(port, data)        outpw((port)+IOP_REG_IH, data)\n#define AscReadChipQP(port)               (uchar)inp((port)+IOP_REG_QP)\n#define AscWriteChipQP(port, data)        outp((port)+IOP_REG_QP, data)\n#define AscReadChipFIFO_L(port)           (ushort)inpw((port)+IOP_REG_FIFO_L)\n#define AscWriteChipFIFO_L(port, data)    outpw((port)+IOP_REG_FIFO_L, data)\n#define AscReadChipFIFO_H(port)           (ushort)inpw((port)+IOP_REG_FIFO_H)\n#define AscWriteChipFIFO_H(port, data)    outpw((port)+IOP_REG_FIFO_H, data)\n#define AscReadChipDmaSpeed(port)         (uchar)inp((port)+IOP_DMA_SPEED)\n#define AscWriteChipDmaSpeed(port, data)  outp((port)+IOP_DMA_SPEED, data)\n#define AscReadChipDA0(port)              (ushort)inpw((port)+IOP_REG_DA0)\n#define AscWriteChipDA0(port)             outpw((port)+IOP_REG_DA0, data)\n#define AscReadChipDA1(port)              (ushort)inpw((port)+IOP_REG_DA1)\n#define AscWriteChipDA1(port)             outpw((port)+IOP_REG_DA1, data)\n#define AscReadChipDC0(port)              (ushort)inpw((port)+IOP_REG_DC0)\n#define AscWriteChipDC0(port)             outpw((port)+IOP_REG_DC0, data)\n#define AscReadChipDC1(port)              (ushort)inpw((port)+IOP_REG_DC1)\n#define AscWriteChipDC1(port)             outpw((port)+IOP_REG_DC1, data)\n#define AscReadChipDvcID(port)            (uchar)inp((port)+IOP_REG_ID)\n#define AscWriteChipDvcID(port, data)     outp((port)+IOP_REG_ID, data)\n\n#define AdvPortAddr  void __iomem *\t/* Virtual memory address size */\n\n/*\n * Define Adv Library required memory access macros.\n */\n#define ADV_MEM_READB(addr) readb(addr)\n#define ADV_MEM_READW(addr) readw(addr)\n#define ADV_MEM_WRITEB(addr, byte) writeb(byte, addr)\n#define ADV_MEM_WRITEW(addr, word) writew(word, addr)\n#define ADV_MEM_WRITEDW(addr, dword) writel(dword, addr)\n\n/*\n * Define total number of simultaneous maximum element scatter-gather\n * request blocks per wide adapter. ASC_DEF_MAX_HOST_QNG (253) is the\n * maximum number of outstanding commands per wide host adapter. Each\n * command uses one or more ADV_SG_BLOCK each with 15 scatter-gather\n * elements. Allow each command to have at least one ADV_SG_BLOCK structure.\n * This allows about 15 commands to have the maximum 17 ADV_SG_BLOCK\n * structures or 255 scatter-gather elements.\n */\n#define ADV_TOT_SG_BLOCK        ASC_DEF_MAX_HOST_QNG\n\n/*\n * Define maximum number of scatter-gather elements per request.\n */\n#define ADV_MAX_SG_LIST         255\n#define NO_OF_SG_PER_BLOCK              15\n\n#define ADV_EEP_DVC_CFG_BEGIN           (0x00)\n#define ADV_EEP_DVC_CFG_END             (0x15)\n#define ADV_EEP_DVC_CTL_BEGIN           (0x16)\t/* location of OEM name */\n#define ADV_EEP_MAX_WORD_ADDR           (0x1E)\n\n#define ADV_EEP_DELAY_MS                100\n\n#define ADV_EEPROM_BIG_ENDIAN          0x8000\t/* EEPROM Bit 15 */\n#define ADV_EEPROM_BIOS_ENABLE         0x4000\t/* EEPROM Bit 14 */\n/*\n * For the ASC3550 Bit 13 is Termination Polarity control bit.\n * For later ICs Bit 13 controls whether the CIS (Card Information\n * Service Section) is loaded from EEPROM.\n */\n#define ADV_EEPROM_TERM_POL            0x2000\t/* EEPROM Bit 13 */\n#define ADV_EEPROM_CIS_LD              0x2000\t/* EEPROM Bit 13 */\n/*\n * ASC38C1600 Bit 11\n *\n * If EEPROM Bit 11 is 0 for Function 0, then Function 0 will specify\n * INT A in the PCI Configuration Space Int Pin field. If it is 1, then\n * Function 0 will specify INT B.\n *\n * If EEPROM Bit 11 is 0 for Function 1, then Function 1 will specify\n * INT B in the PCI Configuration Space Int Pin field. If it is 1, then\n * Function 1 will specify INT A.\n */\n#define ADV_EEPROM_INTAB               0x0800\t/* EEPROM Bit 11 */\n\ntypedef struct adveep_3550_config {\n\t/* Word Offset, Description */\n\n\tushort cfg_lsw;\t\t/* 00 power up initialization */\n\t/*  bit 13 set - Term Polarity Control */\n\t/*  bit 14 set - BIOS Enable */\n\t/*  bit 15 set - Big Endian Mode */\n\tushort cfg_msw;\t\t/* 01 unused      */\n\tushort disc_enable;\t/* 02 disconnect enable */\n\tushort wdtr_able;\t/* 03 Wide DTR able */\n\tushort sdtr_able;\t/* 04 Synchronous DTR able */\n\tushort start_motor;\t/* 05 send start up motor */\n\tushort tagqng_able;\t/* 06 tag queuing able */\n\tushort bios_scan;\t/* 07 BIOS device control */\n\tushort scam_tolerant;\t/* 08 no scam */\n\n\tuchar adapter_scsi_id;\t/* 09 Host Adapter ID */\n\tuchar bios_boot_delay;\t/*    power up wait */\n\n\tuchar scsi_reset_delay;\t/* 10 reset delay */\n\tuchar bios_id_lun;\t/*    first boot device scsi id & lun */\n\t/*    high nibble is lun */\n\t/*    low nibble is scsi id */\n\n\tuchar termination;\t/* 11 0 - automatic */\n\t/*    1 - low off / high off */\n\t/*    2 - low off / high on */\n\t/*    3 - low on  / high on */\n\t/*    There is no low on  / high off */\n\n\tuchar reserved1;\t/*    reserved byte (not used) */\n\n\tushort bios_ctrl;\t/* 12 BIOS control bits */\n\t/*  bit 0  BIOS don't act as initiator. */\n\t/*  bit 1  BIOS > 1 GB support */\n\t/*  bit 2  BIOS > 2 Disk Support */\n\t/*  bit 3  BIOS don't support removables */\n\t/*  bit 4  BIOS support bootable CD */\n\t/*  bit 5  BIOS scan enabled */\n\t/*  bit 6  BIOS support multiple LUNs */\n\t/*  bit 7  BIOS display of message */\n\t/*  bit 8  SCAM disabled */\n\t/*  bit 9  Reset SCSI bus during init. */\n\t/*  bit 10 */\n\t/*  bit 11 No verbose initialization. */\n\t/*  bit 12 SCSI parity enabled */\n\t/*  bit 13 */\n\t/*  bit 14 */\n\t/*  bit 15 */\n\tushort ultra_able;\t/* 13 ULTRA speed able */\n\tushort reserved2;\t/* 14 reserved */\n\tuchar max_host_qng;\t/* 15 maximum host queuing */\n\tuchar max_dvc_qng;\t/*    maximum per device queuing */\n\tushort dvc_cntl;\t/* 16 control bit for driver */\n\tushort bug_fix;\t\t/* 17 control bit for bug fix */\n\tushort serial_number_word1;\t/* 18 Board serial number word 1 */\n\tushort serial_number_word2;\t/* 19 Board serial number word 2 */\n\tushort serial_number_word3;\t/* 20 Board serial number word 3 */\n\tushort check_sum;\t/* 21 EEP check sum */\n\tuchar oem_name[16];\t/* 22 OEM name */\n\tushort dvc_err_code;\t/* 30 last device driver error code */\n\tushort adv_err_code;\t/* 31 last uc and Adv Lib error code */\n\tushort adv_err_addr;\t/* 32 last uc error address */\n\tushort saved_dvc_err_code;\t/* 33 saved last dev. driver error code   */\n\tushort saved_adv_err_code;\t/* 34 saved last uc and Adv Lib error code */\n\tushort saved_adv_err_addr;\t/* 35 saved last uc error address         */\n\tushort num_of_err;\t/* 36 number of error */\n} ADVEEP_3550_CONFIG;\n\ntypedef struct adveep_38C0800_config {\n\t/* Word Offset, Description */\n\n\tushort cfg_lsw;\t\t/* 00 power up initialization */\n\t/*  bit 13 set - Load CIS */\n\t/*  bit 14 set - BIOS Enable */\n\t/*  bit 15 set - Big Endian Mode */\n\tushort cfg_msw;\t\t/* 01 unused      */\n\tushort disc_enable;\t/* 02 disconnect enable */\n\tushort wdtr_able;\t/* 03 Wide DTR able */\n\tushort sdtr_speed1;\t/* 04 SDTR Speed TID 0-3 */\n\tushort start_motor;\t/* 05 send start up motor */\n\tushort tagqng_able;\t/* 06 tag queuing able */\n\tushort bios_scan;\t/* 07 BIOS device control */\n\tushort scam_tolerant;\t/* 08 no scam */\n\n\tuchar adapter_scsi_id;\t/* 09 Host Adapter ID */\n\tuchar bios_boot_delay;\t/*    power up wait */\n\n\tuchar scsi_reset_delay;\t/* 10 reset delay */\n\tuchar bios_id_lun;\t/*    first boot device scsi id & lun */\n\t/*    high nibble is lun */\n\t/*    low nibble is scsi id */\n\n\tuchar termination_se;\t/* 11 0 - automatic */\n\t/*    1 - low off / high off */\n\t/*    2 - low off / high on */\n\t/*    3 - low on  / high on */\n\t/*    There is no low on  / high off */\n\n\tuchar termination_lvd;\t/* 11 0 - automatic */\n\t/*    1 - low off / high off */\n\t/*    2 - low off / high on */\n\t/*    3 - low on  / high on */\n\t/*    There is no low on  / high off */\n\n\tushort bios_ctrl;\t/* 12 BIOS control bits */\n\t/*  bit 0  BIOS don't act as initiator. */\n\t/*  bit 1  BIOS > 1 GB support */\n\t/*  bit 2  BIOS > 2 Disk Support */\n\t/*  bit 3  BIOS don't support removables */\n\t/*  bit 4  BIOS support bootable CD */\n\t/*  bit 5  BIOS scan enabled */\n\t/*  bit 6  BIOS support multiple LUNs */\n\t/*  bit 7  BIOS display of message */\n\t/*  bit 8  SCAM disabled */\n\t/*  bit 9  Reset SCSI bus during init. */\n\t/*  bit 10 */\n\t/*  bit 11 No verbose initialization. */\n\t/*  bit 12 SCSI parity enabled */\n\t/*  bit 13 */\n\t/*  bit 14 */\n\t/*  bit 15 */\n\tushort sdtr_speed2;\t/* 13 SDTR speed TID 4-7 */\n\tushort sdtr_speed3;\t/* 14 SDTR speed TID 8-11 */\n\tuchar max_host_qng;\t/* 15 maximum host queueing */\n\tuchar max_dvc_qng;\t/*    maximum per device queuing */\n\tushort dvc_cntl;\t/* 16 control bit for driver */\n\tushort sdtr_speed4;\t/* 17 SDTR speed 4 TID 12-15 */\n\tushort serial_number_word1;\t/* 18 Board serial number word 1 */\n\tushort serial_number_word2;\t/* 19 Board serial number word 2 */\n\tushort serial_number_word3;\t/* 20 Board serial number word 3 */\n\tushort check_sum;\t/* 21 EEP check sum */\n\tuchar oem_name[16];\t/* 22 OEM name */\n\tushort dvc_err_code;\t/* 30 last device driver error code */\n\tushort adv_err_code;\t/* 31 last uc and Adv Lib error code */\n\tushort adv_err_addr;\t/* 32 last uc error address */\n\tushort saved_dvc_err_code;\t/* 33 saved last dev. driver error code   */\n\tushort saved_adv_err_code;\t/* 34 saved last uc and Adv Lib error code */\n\tushort saved_adv_err_addr;\t/* 35 saved last uc error address         */\n\tushort reserved36;\t/* 36 reserved */\n\tushort reserved37;\t/* 37 reserved */\n\tushort reserved38;\t/* 38 reserved */\n\tushort reserved39;\t/* 39 reserved */\n\tushort reserved40;\t/* 40 reserved */\n\tushort reserved41;\t/* 41 reserved */\n\tushort reserved42;\t/* 42 reserved */\n\tushort reserved43;\t/* 43 reserved */\n\tushort reserved44;\t/* 44 reserved */\n\tushort reserved45;\t/* 45 reserved */\n\tushort reserved46;\t/* 46 reserved */\n\tushort reserved47;\t/* 47 reserved */\n\tushort reserved48;\t/* 48 reserved */\n\tushort reserved49;\t/* 49 reserved */\n\tushort reserved50;\t/* 50 reserved */\n\tushort reserved51;\t/* 51 reserved */\n\tushort reserved52;\t/* 52 reserved */\n\tushort reserved53;\t/* 53 reserved */\n\tushort reserved54;\t/* 54 reserved */\n\tushort reserved55;\t/* 55 reserved */\n\tushort cisptr_lsw;\t/* 56 CIS PTR LSW */\n\tushort cisprt_msw;\t/* 57 CIS PTR MSW */\n\tushort subsysvid;\t/* 58 SubSystem Vendor ID */\n\tushort subsysid;\t/* 59 SubSystem ID */\n\tushort reserved60;\t/* 60 reserved */\n\tushort reserved61;\t/* 61 reserved */\n\tushort reserved62;\t/* 62 reserved */\n\tushort reserved63;\t/* 63 reserved */\n} ADVEEP_38C0800_CONFIG;\n\ntypedef struct adveep_38C1600_config {\n\t/* Word Offset, Description */\n\n\tushort cfg_lsw;\t\t/* 00 power up initialization */\n\t/*  bit 11 set - Func. 0 INTB, Func. 1 INTA */\n\t/*       clear - Func. 0 INTA, Func. 1 INTB */\n\t/*  bit 13 set - Load CIS */\n\t/*  bit 14 set - BIOS Enable */\n\t/*  bit 15 set - Big Endian Mode */\n\tushort cfg_msw;\t\t/* 01 unused */\n\tushort disc_enable;\t/* 02 disconnect enable */\n\tushort wdtr_able;\t/* 03 Wide DTR able */\n\tushort sdtr_speed1;\t/* 04 SDTR Speed TID 0-3 */\n\tushort start_motor;\t/* 05 send start up motor */\n\tushort tagqng_able;\t/* 06 tag queuing able */\n\tushort bios_scan;\t/* 07 BIOS device control */\n\tushort scam_tolerant;\t/* 08 no scam */\n\n\tuchar adapter_scsi_id;\t/* 09 Host Adapter ID */\n\tuchar bios_boot_delay;\t/*    power up wait */\n\n\tuchar scsi_reset_delay;\t/* 10 reset delay */\n\tuchar bios_id_lun;\t/*    first boot device scsi id & lun */\n\t/*    high nibble is lun */\n\t/*    low nibble is scsi id */\n\n\tuchar termination_se;\t/* 11 0 - automatic */\n\t/*    1 - low off / high off */\n\t/*    2 - low off / high on */\n\t/*    3 - low on  / high on */\n\t/*    There is no low on  / high off */\n\n\tuchar termination_lvd;\t/* 11 0 - automatic */\n\t/*    1 - low off / high off */\n\t/*    2 - low off / high on */\n\t/*    3 - low on  / high on */\n\t/*    There is no low on  / high off */\n\n\tushort bios_ctrl;\t/* 12 BIOS control bits */\n\t/*  bit 0  BIOS don't act as initiator. */\n\t/*  bit 1  BIOS > 1 GB support */\n\t/*  bit 2  BIOS > 2 Disk Support */\n\t/*  bit 3  BIOS don't support removables */\n\t/*  bit 4  BIOS support bootable CD */\n\t/*  bit 5  BIOS scan enabled */\n\t/*  bit 6  BIOS support multiple LUNs */\n\t/*  bit 7  BIOS display of message */\n\t/*  bit 8  SCAM disabled */\n\t/*  bit 9  Reset SCSI bus during init. */\n\t/*  bit 10 Basic Integrity Checking disabled */\n\t/*  bit 11 No verbose initialization. */\n\t/*  bit 12 SCSI parity enabled */\n\t/*  bit 13 AIPP (Asyn. Info. Ph. Prot.) dis. */\n\t/*  bit 14 */\n\t/*  bit 15 */\n\tushort sdtr_speed2;\t/* 13 SDTR speed TID 4-7 */\n\tushort sdtr_speed3;\t/* 14 SDTR speed TID 8-11 */\n\tuchar max_host_qng;\t/* 15 maximum host queueing */\n\tuchar max_dvc_qng;\t/*    maximum per device queuing */\n\tushort dvc_cntl;\t/* 16 control bit for driver */\n\tushort sdtr_speed4;\t/* 17 SDTR speed 4 TID 12-15 */\n\tushort serial_number_word1;\t/* 18 Board serial number word 1 */\n\tushort serial_number_word2;\t/* 19 Board serial number word 2 */\n\tushort serial_number_word3;\t/* 20 Board serial number word 3 */\n\tushort check_sum;\t/* 21 EEP check sum */\n\tuchar oem_name[16];\t/* 22 OEM name */\n\tushort dvc_err_code;\t/* 30 last device driver error code */\n\tushort adv_err_code;\t/* 31 last uc and Adv Lib error code */\n\tushort adv_err_addr;\t/* 32 last uc error address */\n\tushort saved_dvc_err_code;\t/* 33 saved last dev. driver error code   */\n\tushort saved_adv_err_code;\t/* 34 saved last uc and Adv Lib error code */\n\tushort saved_adv_err_addr;\t/* 35 saved last uc error address         */\n\tushort reserved36;\t/* 36 reserved */\n\tushort reserved37;\t/* 37 reserved */\n\tushort reserved38;\t/* 38 reserved */\n\tushort reserved39;\t/* 39 reserved */\n\tushort reserved40;\t/* 40 reserved */\n\tushort reserved41;\t/* 41 reserved */\n\tushort reserved42;\t/* 42 reserved */\n\tushort reserved43;\t/* 43 reserved */\n\tushort reserved44;\t/* 44 reserved */\n\tushort reserved45;\t/* 45 reserved */\n\tushort reserved46;\t/* 46 reserved */\n\tushort reserved47;\t/* 47 reserved */\n\tushort reserved48;\t/* 48 reserved */\n\tushort reserved49;\t/* 49 reserved */\n\tushort reserved50;\t/* 50 reserved */\n\tushort reserved51;\t/* 51 reserved */\n\tushort reserved52;\t/* 52 reserved */\n\tushort reserved53;\t/* 53 reserved */\n\tushort reserved54;\t/* 54 reserved */\n\tushort reserved55;\t/* 55 reserved */\n\tushort cisptr_lsw;\t/* 56 CIS PTR LSW */\n\tushort cisprt_msw;\t/* 57 CIS PTR MSW */\n\tushort subsysvid;\t/* 58 SubSystem Vendor ID */\n\tushort subsysid;\t/* 59 SubSystem ID */\n\tushort reserved60;\t/* 60 reserved */\n\tushort reserved61;\t/* 61 reserved */\n\tushort reserved62;\t/* 62 reserved */\n\tushort reserved63;\t/* 63 reserved */\n} ADVEEP_38C1600_CONFIG;\n\n/*\n * EEPROM Commands\n */\n#define ASC_EEP_CMD_DONE             0x0200\n\n/* bios_ctrl */\n#define BIOS_CTRL_BIOS               0x0001\n#define BIOS_CTRL_EXTENDED_XLAT      0x0002\n#define BIOS_CTRL_GT_2_DISK          0x0004\n#define BIOS_CTRL_BIOS_REMOVABLE     0x0008\n#define BIOS_CTRL_BOOTABLE_CD        0x0010\n#define BIOS_CTRL_MULTIPLE_LUN       0x0040\n#define BIOS_CTRL_DISPLAY_MSG        0x0080\n#define BIOS_CTRL_NO_SCAM            0x0100\n#define BIOS_CTRL_RESET_SCSI_BUS     0x0200\n#define BIOS_CTRL_INIT_VERBOSE       0x0800\n#define BIOS_CTRL_SCSI_PARITY        0x1000\n#define BIOS_CTRL_AIPP_DIS           0x2000\n\n#define ADV_3550_MEMSIZE   0x2000\t/* 8 KB Internal Memory */\n\n#define ADV_38C0800_MEMSIZE  0x4000\t/* 16 KB Internal Memory */\n\n/*\n * XXX - Since ASC38C1600 Rev.3 has a local RAM failure issue, there is\n * a special 16K Adv Library and Microcode version. After the issue is\n * resolved, should restore 32K support.\n *\n * #define ADV_38C1600_MEMSIZE  0x8000L   * 32 KB Internal Memory *\n */\n#define ADV_38C1600_MEMSIZE  0x4000\t/* 16 KB Internal Memory */\n\n/*\n * Byte I/O register address from base of 'iop_base'.\n */\n#define IOPB_INTR_STATUS_REG    0x00\n#define IOPB_CHIP_ID_1          0x01\n#define IOPB_INTR_ENABLES       0x02\n#define IOPB_CHIP_TYPE_REV      0x03\n#define IOPB_RES_ADDR_4         0x04\n#define IOPB_RES_ADDR_5         0x05\n#define IOPB_RAM_DATA           0x06\n#define IOPB_RES_ADDR_7         0x07\n#define IOPB_FLAG_REG           0x08\n#define IOPB_RES_ADDR_9         0x09\n#define IOPB_RISC_CSR           0x0A\n#define IOPB_RES_ADDR_B         0x0B\n#define IOPB_RES_ADDR_C         0x0C\n#define IOPB_RES_ADDR_D         0x0D\n#define IOPB_SOFT_OVER_WR       0x0E\n#define IOPB_RES_ADDR_F         0x0F\n#define IOPB_MEM_CFG            0x10\n#define IOPB_RES_ADDR_11        0x11\n#define IOPB_GPIO_DATA          0x12\n#define IOPB_RES_ADDR_13        0x13\n#define IOPB_FLASH_PAGE         0x14\n#define IOPB_RES_ADDR_15        0x15\n#define IOPB_GPIO_CNTL          0x16\n#define IOPB_RES_ADDR_17        0x17\n#define IOPB_FLASH_DATA         0x18\n#define IOPB_RES_ADDR_19        0x19\n#define IOPB_RES_ADDR_1A        0x1A\n#define IOPB_RES_ADDR_1B        0x1B\n#define IOPB_RES_ADDR_1C        0x1C\n#define IOPB_RES_ADDR_1D        0x1D\n#define IOPB_RES_ADDR_1E        0x1E\n#define IOPB_RES_ADDR_1F        0x1F\n#define IOPB_DMA_CFG0           0x20\n#define IOPB_DMA_CFG1           0x21\n#define IOPB_TICKLE             0x22\n#define IOPB_DMA_REG_WR         0x23\n#define IOPB_SDMA_STATUS        0x24\n#define IOPB_SCSI_BYTE_CNT      0x25\n#define IOPB_HOST_BYTE_CNT      0x26\n#define IOPB_BYTE_LEFT_TO_XFER  0x27\n#define IOPB_BYTE_TO_XFER_0     0x28\n#define IOPB_BYTE_TO_XFER_1     0x29\n#define IOPB_BYTE_TO_XFER_2     0x2A\n#define IOPB_BYTE_TO_XFER_3     0x2B\n#define IOPB_ACC_GRP            0x2C\n#define IOPB_RES_ADDR_2D        0x2D\n#define IOPB_DEV_ID             0x2E\n#define IOPB_RES_ADDR_2F        0x2F\n#define IOPB_SCSI_DATA          0x30\n#define IOPB_RES_ADDR_31        0x31\n#define IOPB_RES_ADDR_32        0x32\n#define IOPB_SCSI_DATA_HSHK     0x33\n#define IOPB_SCSI_CTRL          0x34\n#define IOPB_RES_ADDR_35        0x35\n#define IOPB_RES_ADDR_36        0x36\n#define IOPB_RES_ADDR_37        0x37\n#define IOPB_RAM_BIST           0x38\n#define IOPB_PLL_TEST           0x39\n#define IOPB_PCI_INT_CFG        0x3A\n#define IOPB_RES_ADDR_3B        0x3B\n#define IOPB_RFIFO_CNT          0x3C\n#define IOPB_RES_ADDR_3D        0x3D\n#define IOPB_RES_ADDR_3E        0x3E\n#define IOPB_RES_ADDR_3F        0x3F\n\n/*\n * Word I/O register address from base of 'iop_base'.\n */\n#define IOPW_CHIP_ID_0          0x00\t/* CID0  */\n#define IOPW_CTRL_REG           0x02\t/* CC    */\n#define IOPW_RAM_ADDR           0x04\t/* LA    */\n#define IOPW_RAM_DATA           0x06\t/* LD    */\n#define IOPW_RES_ADDR_08        0x08\n#define IOPW_RISC_CSR           0x0A\t/* CSR   */\n#define IOPW_SCSI_CFG0          0x0C\t/* CFG0  */\n#define IOPW_SCSI_CFG1          0x0E\t/* CFG1  */\n#define IOPW_RES_ADDR_10        0x10\n#define IOPW_SEL_MASK           0x12\t/* SM    */\n#define IOPW_RES_ADDR_14        0x14\n#define IOPW_FLASH_ADDR         0x16\t/* FA    */\n#define IOPW_RES_ADDR_18        0x18\n#define IOPW_EE_CMD             0x1A\t/* EC    */\n#define IOPW_EE_DATA            0x1C\t/* ED    */\n#define IOPW_SFIFO_CNT          0x1E\t/* SFC   */\n#define IOPW_RES_ADDR_20        0x20\n#define IOPW_Q_BASE             0x22\t/* QB    */\n#define IOPW_QP                 0x24\t/* QP    */\n#define IOPW_IX                 0x26\t/* IX    */\n#define IOPW_SP                 0x28\t/* SP    */\n#define IOPW_PC                 0x2A\t/* PC    */\n#define IOPW_RES_ADDR_2C        0x2C\n#define IOPW_RES_ADDR_2E        0x2E\n#define IOPW_SCSI_DATA          0x30\t/* SD    */\n#define IOPW_SCSI_DATA_HSHK     0x32\t/* SDH   */\n#define IOPW_SCSI_CTRL          0x34\t/* SC    */\n#define IOPW_HSHK_CFG           0x36\t/* HCFG  */\n#define IOPW_SXFR_STATUS        0x36\t/* SXS   */\n#define IOPW_SXFR_CNTL          0x38\t/* SXL   */\n#define IOPW_SXFR_CNTH          0x3A\t/* SXH   */\n#define IOPW_RES_ADDR_3C        0x3C\n#define IOPW_RFIFO_DATA         0x3E\t/* RFD   */\n\n/*\n * Doubleword I/O register address from base of 'iop_base'.\n */\n#define IOPDW_RES_ADDR_0         0x00\n#define IOPDW_RAM_DATA           0x04\n#define IOPDW_RES_ADDR_8         0x08\n#define IOPDW_RES_ADDR_C         0x0C\n#define IOPDW_RES_ADDR_10        0x10\n#define IOPDW_COMMA              0x14\n#define IOPDW_COMMB              0x18\n#define IOPDW_RES_ADDR_1C        0x1C\n#define IOPDW_SDMA_ADDR0         0x20\n#define IOPDW_SDMA_ADDR1         0x24\n#define IOPDW_SDMA_COUNT         0x28\n#define IOPDW_SDMA_ERROR         0x2C\n#define IOPDW_RDMA_ADDR0         0x30\n#define IOPDW_RDMA_ADDR1         0x34\n#define IOPDW_RDMA_COUNT         0x38\n#define IOPDW_RDMA_ERROR         0x3C\n\n#define ADV_CHIP_ID_BYTE         0x25\n#define ADV_CHIP_ID_WORD         0x04C1\n\n#define ADV_INTR_ENABLE_HOST_INTR                   0x01\n#define ADV_INTR_ENABLE_SEL_INTR                    0x02\n#define ADV_INTR_ENABLE_DPR_INTR                    0x04\n#define ADV_INTR_ENABLE_RTA_INTR                    0x08\n#define ADV_INTR_ENABLE_RMA_INTR                    0x10\n#define ADV_INTR_ENABLE_RST_INTR                    0x20\n#define ADV_INTR_ENABLE_DPE_INTR                    0x40\n#define ADV_INTR_ENABLE_GLOBAL_INTR                 0x80\n\n#define ADV_INTR_STATUS_INTRA            0x01\n#define ADV_INTR_STATUS_INTRB            0x02\n#define ADV_INTR_STATUS_INTRC            0x04\n\n#define ADV_RISC_CSR_STOP           (0x0000)\n#define ADV_RISC_TEST_COND          (0x2000)\n#define ADV_RISC_CSR_RUN            (0x4000)\n#define ADV_RISC_CSR_SINGLE_STEP    (0x8000)\n\n#define ADV_CTRL_REG_HOST_INTR      0x0100\n#define ADV_CTRL_REG_SEL_INTR       0x0200\n#define ADV_CTRL_REG_DPR_INTR       0x0400\n#define ADV_CTRL_REG_RTA_INTR       0x0800\n#define ADV_CTRL_REG_RMA_INTR       0x1000\n#define ADV_CTRL_REG_RES_BIT14      0x2000\n#define ADV_CTRL_REG_DPE_INTR       0x4000\n#define ADV_CTRL_REG_POWER_DONE     0x8000\n#define ADV_CTRL_REG_ANY_INTR       0xFF00\n\n#define ADV_CTRL_REG_CMD_RESET             0x00C6\n#define ADV_CTRL_REG_CMD_WR_IO_REG         0x00C5\n#define ADV_CTRL_REG_CMD_RD_IO_REG         0x00C4\n#define ADV_CTRL_REG_CMD_WR_PCI_CFG_SPACE  0x00C3\n#define ADV_CTRL_REG_CMD_RD_PCI_CFG_SPACE  0x00C2\n\n#define ADV_TICKLE_NOP                      0x00\n#define ADV_TICKLE_A                        0x01\n#define ADV_TICKLE_B                        0x02\n#define ADV_TICKLE_C                        0x03\n\n#define AdvIsIntPending(port) \\\n    (AdvReadWordRegister(port, IOPW_CTRL_REG) & ADV_CTRL_REG_HOST_INTR)\n\n/*\n * SCSI_CFG0 Register bit definitions\n */\n#define TIMER_MODEAB    0xC000\t/* Watchdog, Second, and Select. Timer Ctrl. */\n#define PARITY_EN       0x2000\t/* Enable SCSI Parity Error detection */\n#define EVEN_PARITY     0x1000\t/* Select Even Parity */\n#define WD_LONG         0x0800\t/* Watchdog Interval, 1: 57 min, 0: 13 sec */\n#define QUEUE_128       0x0400\t/* Queue Size, 1: 128 byte, 0: 64 byte */\n#define PRIM_MODE       0x0100\t/* Primitive SCSI mode */\n#define SCAM_EN         0x0080\t/* Enable SCAM selection */\n#define SEL_TMO_LONG    0x0040\t/* Sel/Resel Timeout, 1: 400 ms, 0: 1.6 ms */\n#define CFRM_ID         0x0020\t/* SCAM id sel. confirm., 1: fast, 0: 6.4 ms */\n#define OUR_ID_EN       0x0010\t/* Enable OUR_ID bits */\n#define OUR_ID          0x000F\t/* SCSI ID */\n\n/*\n * SCSI_CFG1 Register bit definitions\n */\n#define BIG_ENDIAN      0x8000\t/* Enable Big Endian Mode MIO:15, EEP:15 */\n#define TERM_POL        0x2000\t/* Terminator Polarity Ctrl. MIO:13, EEP:13 */\n#define SLEW_RATE       0x1000\t/* SCSI output buffer slew rate */\n#define FILTER_SEL      0x0C00\t/* Filter Period Selection */\n#define  FLTR_DISABLE    0x0000\t/* Input Filtering Disabled */\n#define  FLTR_11_TO_20NS 0x0800\t/* Input Filtering 11ns to 20ns */\n#define  FLTR_21_TO_39NS 0x0C00\t/* Input Filtering 21ns to 39ns */\n#define ACTIVE_DBL      0x0200\t/* Disable Active Negation */\n#define DIFF_MODE       0x0100\t/* SCSI differential Mode (Read-Only) */\n#define DIFF_SENSE      0x0080\t/* 1: No SE cables, 0: SE cable (Read-Only) */\n#define TERM_CTL_SEL    0x0040\t/* Enable TERM_CTL_H and TERM_CTL_L */\n#define TERM_CTL        0x0030\t/* External SCSI Termination Bits */\n#define  TERM_CTL_H      0x0020\t/* Enable External SCSI Upper Termination */\n#define  TERM_CTL_L      0x0010\t/* Enable External SCSI Lower Termination */\n#define CABLE_DETECT    0x000F\t/* External SCSI Cable Connection Status */\n\n/*\n * Addendum for ASC-38C0800 Chip\n *\n * The ASC-38C1600 Chip uses the same definitions except that the\n * bus mode override bits [12:10] have been moved to byte register\n * offset 0xE (IOPB_SOFT_OVER_WR) bits [12:10]. The [12:10] bits in\n * SCSI_CFG1 are read-only and always available. Bit 14 (DIS_TERM_DRV)\n * is not needed. The [12:10] bits in IOPB_SOFT_OVER_WR are write-only.\n * Also each ASC-38C1600 function or channel uses only cable bits [5:4]\n * and [1:0]. Bits [14], [7:6], [3:2] are unused.\n */\n#define DIS_TERM_DRV    0x4000\t/* 1: Read c_det[3:0], 0: cannot read */\n#define HVD_LVD_SE      0x1C00\t/* Device Detect Bits */\n#define  HVD             0x1000\t/* HVD Device Detect */\n#define  LVD             0x0800\t/* LVD Device Detect */\n#define  SE              0x0400\t/* SE Device Detect */\n#define TERM_LVD        0x00C0\t/* LVD Termination Bits */\n#define  TERM_LVD_HI     0x0080\t/* Enable LVD Upper Termination */\n#define  TERM_LVD_LO     0x0040\t/* Enable LVD Lower Termination */\n#define TERM_SE         0x0030\t/* SE Termination Bits */\n#define  TERM_SE_HI      0x0020\t/* Enable SE Upper Termination */\n#define  TERM_SE_LO      0x0010\t/* Enable SE Lower Termination */\n#define C_DET_LVD       0x000C\t/* LVD Cable Detect Bits */\n#define  C_DET3          0x0008\t/* Cable Detect for LVD External Wide */\n#define  C_DET2          0x0004\t/* Cable Detect for LVD Internal Wide */\n#define C_DET_SE        0x0003\t/* SE Cable Detect Bits */\n#define  C_DET1          0x0002\t/* Cable Detect for SE Internal Wide */\n#define  C_DET0          0x0001\t/* Cable Detect for SE Internal Narrow */\n\n#define CABLE_ILLEGAL_A 0x7\n    /* x 0 0 0  | on  on | Illegal (all 3 connectors are used) */\n\n#define CABLE_ILLEGAL_B 0xB\n    /* 0 x 0 0  | on  on | Illegal (all 3 connectors are used) */\n\n/*\n * MEM_CFG Register bit definitions\n */\n#define BIOS_EN         0x40\t/* BIOS Enable MIO:14,EEP:14 */\n#define FAST_EE_CLK     0x20\t/* Diagnostic Bit */\n#define RAM_SZ          0x1C\t/* Specify size of RAM to RISC */\n#define  RAM_SZ_2KB      0x00\t/* 2 KB */\n#define  RAM_SZ_4KB      0x04\t/* 4 KB */\n#define  RAM_SZ_8KB      0x08\t/* 8 KB */\n#define  RAM_SZ_16KB     0x0C\t/* 16 KB */\n#define  RAM_SZ_32KB     0x10\t/* 32 KB */\n#define  RAM_SZ_64KB     0x14\t/* 64 KB */\n\n/*\n * DMA_CFG0 Register bit definitions\n *\n * This register is only accessible to the host.\n */\n#define BC_THRESH_ENB   0x80\t/* PCI DMA Start Conditions */\n#define FIFO_THRESH     0x70\t/* PCI DMA FIFO Threshold */\n#define  FIFO_THRESH_16B  0x00\t/* 16 bytes */\n#define  FIFO_THRESH_32B  0x20\t/* 32 bytes */\n#define  FIFO_THRESH_48B  0x30\t/* 48 bytes */\n#define  FIFO_THRESH_64B  0x40\t/* 64 bytes */\n#define  FIFO_THRESH_80B  0x50\t/* 80 bytes (default) */\n#define  FIFO_THRESH_96B  0x60\t/* 96 bytes */\n#define  FIFO_THRESH_112B 0x70\t/* 112 bytes */\n#define START_CTL       0x0C\t/* DMA start conditions */\n#define  START_CTL_TH    0x00\t/* Wait threshold level (default) */\n#define  START_CTL_ID    0x04\t/* Wait SDMA/SBUS idle */\n#define  START_CTL_THID  0x08\t/* Wait threshold and SDMA/SBUS idle */\n#define  START_CTL_EMFU  0x0C\t/* Wait SDMA FIFO empty/full */\n#define READ_CMD        0x03\t/* Memory Read Method */\n#define  READ_CMD_MR     0x00\t/* Memory Read */\n#define  READ_CMD_MRL    0x02\t/* Memory Read Long */\n#define  READ_CMD_MRM    0x03\t/* Memory Read Multiple (default) */\n\n/*\n * ASC-38C0800 RAM BIST Register bit definitions\n */\n#define RAM_TEST_MODE         0x80\n#define PRE_TEST_MODE         0x40\n#define NORMAL_MODE           0x00\n#define RAM_TEST_DONE         0x10\n#define RAM_TEST_STATUS       0x0F\n#define  RAM_TEST_HOST_ERROR   0x08\n#define  RAM_TEST_INTRAM_ERROR 0x04\n#define  RAM_TEST_RISC_ERROR   0x02\n#define  RAM_TEST_SCSI_ERROR   0x01\n#define  RAM_TEST_SUCCESS      0x00\n#define PRE_TEST_VALUE        0x05\n#define NORMAL_VALUE          0x00\n\n/*\n * ASC38C1600 Definitions\n *\n * IOPB_PCI_INT_CFG Bit Field Definitions\n */\n\n#define INTAB_LD        0x80\t/* Value loaded from EEPROM Bit 11. */\n\n/*\n * Bit 1 can be set to change the interrupt for the Function to operate in\n * Totem Pole mode. By default Bit 1 is 0 and the interrupt operates in\n * Open Drain mode. Both functions of the ASC38C1600 must be set to the same\n * mode, otherwise the operating mode is undefined.\n */\n#define TOTEMPOLE       0x02\n\n/*\n * Bit 0 can be used to change the Int Pin for the Function. The value is\n * 0 by default for both Functions with Function 0 using INT A and Function\n * B using INT B. For Function 0 if set, INT B is used. For Function 1 if set,\n * INT A is used.\n *\n * EEPROM Word 0 Bit 11 for each Function may change the initial Int Pin\n * value specified in the PCI Configuration Space.\n */\n#define INTAB           0x01\n\n/*\n * Adv Library Status Definitions\n */\n#define ADV_TRUE        1\n#define ADV_FALSE       0\n#define ADV_SUCCESS     1\n#define ADV_BUSY        0\n#define ADV_ERROR       (-1)\n\n/*\n * ADV_DVC_VAR 'warn_code' values\n */\n#define ASC_WARN_BUSRESET_ERROR         0x0001\t/* SCSI Bus Reset error */\n#define ASC_WARN_EEPROM_CHKSUM          0x0002\t/* EEP check sum error */\n#define ASC_WARN_EEPROM_TERMINATION     0x0004\t/* EEP termination bad field */\n#define ASC_WARN_ERROR                  0xFFFF\t/* ADV_ERROR return */\n\n#define ADV_MAX_TID                     15\t/* max. target identifier */\n#define ADV_MAX_LUN                     7\t/* max. logical unit number */\n\n/*\n * Fixed locations of microcode operating variables.\n */\n#define ASC_MC_CODE_BEGIN_ADDR          0x0028\t/* microcode start address */\n#define ASC_MC_CODE_END_ADDR            0x002A\t/* microcode end address */\n#define ASC_MC_CODE_CHK_SUM             0x002C\t/* microcode code checksum */\n#define ASC_MC_VERSION_DATE             0x0038\t/* microcode version */\n#define ASC_MC_VERSION_NUM              0x003A\t/* microcode number */\n#define ASC_MC_BIOSMEM                  0x0040\t/* BIOS RISC Memory Start */\n#define ASC_MC_BIOSLEN                  0x0050\t/* BIOS RISC Memory Length */\n#define ASC_MC_BIOS_SIGNATURE           0x0058\t/* BIOS Signature 0x55AA */\n#define ASC_MC_BIOS_VERSION             0x005A\t/* BIOS Version (2 bytes) */\n#define ASC_MC_SDTR_SPEED1              0x0090\t/* SDTR Speed for TID 0-3 */\n#define ASC_MC_SDTR_SPEED2              0x0092\t/* SDTR Speed for TID 4-7 */\n#define ASC_MC_SDTR_SPEED3              0x0094\t/* SDTR Speed for TID 8-11 */\n#define ASC_MC_SDTR_SPEED4              0x0096\t/* SDTR Speed for TID 12-15 */\n#define ASC_MC_CHIP_TYPE                0x009A\n#define ASC_MC_INTRB_CODE               0x009B\n#define ASC_MC_WDTR_ABLE                0x009C\n#define ASC_MC_SDTR_ABLE                0x009E\n#define ASC_MC_TAGQNG_ABLE              0x00A0\n#define ASC_MC_DISC_ENABLE              0x00A2\n#define ASC_MC_IDLE_CMD_STATUS          0x00A4\n#define ASC_MC_IDLE_CMD                 0x00A6\n#define ASC_MC_IDLE_CMD_PARAMETER       0x00A8\n#define ASC_MC_DEFAULT_SCSI_CFG0        0x00AC\n#define ASC_MC_DEFAULT_SCSI_CFG1        0x00AE\n#define ASC_MC_DEFAULT_MEM_CFG          0x00B0\n#define ASC_MC_DEFAULT_SEL_MASK         0x00B2\n#define ASC_MC_SDTR_DONE                0x00B6\n#define ASC_MC_NUMBER_OF_QUEUED_CMD     0x00C0\n#define ASC_MC_NUMBER_OF_MAX_CMD        0x00D0\n#define ASC_MC_DEVICE_HSHK_CFG_TABLE    0x0100\n#define ASC_MC_CONTROL_FLAG             0x0122\t/* Microcode control flag. */\n#define ASC_MC_WDTR_DONE                0x0124\n#define ASC_MC_CAM_MODE_MASK            0x015E\t/* CAM mode TID bitmask. */\n#define ASC_MC_ICQ                      0x0160\n#define ASC_MC_IRQ                      0x0164\n#define ASC_MC_PPR_ABLE                 0x017A\n\n/*\n * BIOS LRAM variable absolute offsets.\n */\n#define BIOS_CODESEG    0x54\n#define BIOS_CODELEN    0x56\n#define BIOS_SIGNATURE  0x58\n#define BIOS_VERSION    0x5A\n\n/*\n * Microcode Control Flags\n *\n * Flags set by the Adv Library in RISC variable 'control_flag' (0x122)\n * and handled by the microcode.\n */\n#define CONTROL_FLAG_IGNORE_PERR        0x0001\t/* Ignore DMA Parity Errors */\n#define CONTROL_FLAG_ENABLE_AIPP        0x0002\t/* Enabled AIPP checking. */\n\n/*\n * ASC_MC_DEVICE_HSHK_CFG_TABLE microcode table or HSHK_CFG register format\n */\n#define HSHK_CFG_WIDE_XFR       0x8000\n#define HSHK_CFG_RATE           0x0F00\n#define HSHK_CFG_OFFSET         0x001F\n\n#define ASC_DEF_MAX_HOST_QNG    0xFD\t/* Max. number of host commands (253) */\n#define ASC_DEF_MIN_HOST_QNG    0x10\t/* Min. number of host commands (16) */\n#define ASC_DEF_MAX_DVC_QNG     0x3F\t/* Max. number commands per device (63) */\n#define ASC_DEF_MIN_DVC_QNG     0x04\t/* Min. number commands per device (4) */\n\n#define ASC_QC_DATA_CHECK  0x01\t/* Require ASC_QC_DATA_OUT set or clear. */\n#define ASC_QC_DATA_OUT    0x02\t/* Data out DMA transfer. */\n#define ASC_QC_START_MOTOR 0x04\t/* Send auto-start motor before request. */\n#define ASC_QC_NO_OVERRUN  0x08\t/* Don't report overrun. */\n#define ASC_QC_FREEZE_TIDQ 0x10\t/* Freeze TID queue after request. XXX TBD */\n\n#define ASC_QSC_NO_DISC     0x01\t/* Don't allow disconnect for request. */\n#define ASC_QSC_NO_TAGMSG   0x02\t/* Don't allow tag queuing for request. */\n#define ASC_QSC_NO_SYNC     0x04\t/* Don't use Synch. transfer on request. */\n#define ASC_QSC_NO_WIDE     0x08\t/* Don't use Wide transfer on request. */\n#define ASC_QSC_REDO_DTR    0x10\t/* Renegotiate WDTR/SDTR before request. */\n/*\n * Note: If a Tag Message is to be sent and neither ASC_QSC_HEAD_TAG or\n * ASC_QSC_ORDERED_TAG is set, then a Simple Tag Message (0x20) is used.\n */\n#define ASC_QSC_HEAD_TAG    0x40\t/* Use Head Tag Message (0x21). */\n#define ASC_QSC_ORDERED_TAG 0x80\t/* Use Ordered Tag Message (0x22). */\n\n/*\n * All fields here are accessed by the board microcode and need to be\n * little-endian.\n */\ntypedef struct adv_carr_t {\n\t__le32 carr_va;\t/* Carrier Virtual Address */\n\t__le32 carr_pa;\t/* Carrier Physical Address */\n\t__le32 areq_vpa;\t/* ADV_SCSI_REQ_Q Virtual or Physical Address */\n\t/*\n\t * next_vpa [31:4]            Carrier Virtual or Physical Next Pointer\n\t *\n\t * next_vpa [3:1]             Reserved Bits\n\t * next_vpa [0]               Done Flag set in Response Queue.\n\t */\n\t__le32 next_vpa;\n} ADV_CARR_T;\n\n/*\n * Mask used to eliminate low 4 bits of carrier 'next_vpa' field.\n */\n#define ADV_NEXT_VPA_MASK       0xFFFFFFF0\n\n#define ADV_RQ_DONE             0x00000001\n#define ADV_RQ_GOOD             0x00000002\n#define ADV_CQ_STOPPER          0x00000000\n\n#define ADV_GET_CARRP(carrp) ((carrp) & ADV_NEXT_VPA_MASK)\n\n/*\n * Each carrier is 64 bytes, and we need three additional\n * carrier for icq, irq, and the termination carrier.\n */\n#define ADV_CARRIER_COUNT (ASC_DEF_MAX_HOST_QNG + 3)\n\n#define ADV_CARRIER_BUFSIZE \\\n\t(ADV_CARRIER_COUNT * sizeof(ADV_CARR_T))\n\n#define ADV_CHIP_ASC3550          0x01\t/* Ultra-Wide IC */\n#define ADV_CHIP_ASC38C0800       0x02\t/* Ultra2-Wide/LVD IC */\n#define ADV_CHIP_ASC38C1600       0x03\t/* Ultra3-Wide/LVD2 IC */\n\n/*\n * Adapter temporary configuration structure\n *\n * This structure can be discarded after initialization. Don't add\n * fields here needed after initialization.\n *\n * Field naming convention:\n *\n *  *_enable indicates the field enables or disables a feature. The\n *  value of the field is never reset.\n */\ntypedef struct adv_dvc_cfg {\n\tushort disc_enable;\t/* enable disconnection */\n\tuchar chip_version;\t/* chip version */\n\tuchar termination;\t/* Term. Ctrl. bits 6-5 of SCSI_CFG1 register */\n\tushort control_flag;\t/* Microcode Control Flag */\n\tushort mcode_date;\t/* Microcode date */\n\tushort mcode_version;\t/* Microcode version */\n\tushort serial1;\t\t/* EEPROM serial number word 1 */\n\tushort serial2;\t\t/* EEPROM serial number word 2 */\n\tushort serial3;\t\t/* EEPROM serial number word 3 */\n} ADV_DVC_CFG;\n\nstruct adv_dvc_var;\nstruct adv_scsi_req_q;\n\ntypedef struct adv_sg_block {\n\tuchar reserved1;\n\tuchar reserved2;\n\tuchar reserved3;\n\tuchar sg_cnt;\t\t/* Valid entries in block. */\n\t__le32 sg_ptr;\t/* Pointer to next sg block. */\n\tstruct {\n\t\t__le32 sg_addr;\t/* SG element address. */\n\t\t__le32 sg_count;\t/* SG element count. */\n\t} sg_list[NO_OF_SG_PER_BLOCK];\n} ADV_SG_BLOCK;\n\n/*\n * ADV_SCSI_REQ_Q - microcode request structure\n *\n * All fields in this structure up to byte 60 are used by the microcode.\n * The microcode makes assumptions about the size and ordering of fields\n * in this structure. Do not change the structure definition here without\n * coordinating the change with the microcode.\n *\n * All fields accessed by microcode must be maintained in little_endian\n * order.\n */\ntypedef struct adv_scsi_req_q {\n\tuchar cntl;\t\t/* Ucode flags and state (ASC_MC_QC_*). */\n\tuchar target_cmd;\n\tuchar target_id;\t/* Device target identifier. */\n\tuchar target_lun;\t/* Device target logical unit number. */\n\t__le32 data_addr;\t/* Data buffer physical address. */\n\t__le32 data_cnt;\t/* Data count. Ucode sets to residual. */\n\t__le32 sense_addr;\n\t__le32 carr_pa;\n\tuchar mflag;\n\tuchar sense_len;\n\tuchar cdb_len;\t\t/* SCSI CDB length. Must <= 16 bytes. */\n\tuchar scsi_cntl;\n\tuchar done_status;\t/* Completion status. */\n\tuchar scsi_status;\t/* SCSI status byte. */\n\tuchar host_status;\t/* Ucode host status. */\n\tuchar sg_working_ix;\n\tuchar cdb[12];\t\t/* SCSI CDB bytes 0-11. */\n\t__le32 sg_real_addr;\t/* SG list physical address. */\n\t__le32 scsiq_rptr;\n\tuchar cdb16[4];\t\t/* SCSI CDB bytes 12-15. */\n\t__le32 scsiq_ptr;\n\t__le32 carr_va;\n\t/*\n\t * End of microcode structure - 60 bytes. The rest of the structure\n\t * is used by the Adv Library and ignored by the microcode.\n\t */\n\tu32 srb_tag;\n\tADV_SG_BLOCK *sg_list_ptr;\t/* SG list virtual address. */\n} ADV_SCSI_REQ_Q;\n\n/*\n * The following two structures are used to process Wide Board requests.\n *\n * The ADV_SCSI_REQ_Q structure in adv_req_t is passed to the Adv Library\n * and microcode with the ADV_SCSI_REQ_Q field 'srb_tag' set to the\n * SCSI request tag. The adv_req_t structure 'cmndp' field in turn points\n * to the Mid-Level SCSI request structure.\n *\n * Zero or more ADV_SG_BLOCK are used with each ADV_SCSI_REQ_Q. Each\n * ADV_SG_BLOCK structure holds 15 scatter-gather elements. Under Linux\n * up to 255 scatter-gather elements may be used per request or\n * ADV_SCSI_REQ_Q.\n *\n * Both structures must be 32 byte aligned.\n */\ntypedef struct adv_sgblk {\n\tADV_SG_BLOCK sg_block;\t/* Sgblock structure. */\n\tdma_addr_t sg_addr;\t/* Physical address */\n\tstruct adv_sgblk *next_sgblkp;\t/* Next scatter-gather structure. */\n} adv_sgblk_t;\n\ntypedef struct adv_req {\n\tADV_SCSI_REQ_Q scsi_req_q;\t/* Adv Library request structure. */\n\tuchar align[24];\t/* Request structure padding. */\n\tstruct scsi_cmnd *cmndp;\t/* Mid-Level SCSI command pointer. */\n\tdma_addr_t req_addr;\n\tadv_sgblk_t *sgblkp;\t/* Adv Library scatter-gather pointer. */\n} adv_req_t __aligned(32);\n\n/*\n * Adapter operation variable structure.\n *\n * One structure is required per host adapter.\n *\n * Field naming convention:\n *\n *  *_able indicates both whether a feature should be enabled or disabled\n *  and whether a device isi capable of the feature. At initialization\n *  this field may be set, but later if a device is found to be incapable\n *  of the feature, the field is cleared.\n */\ntypedef struct adv_dvc_var {\n\tAdvPortAddr iop_base;\t/* I/O port address */\n\tushort err_code;\t/* fatal error code */\n\tushort bios_ctrl;\t/* BIOS control word, EEPROM word 12 */\n\tushort wdtr_able;\t/* try WDTR for a device */\n\tushort sdtr_able;\t/* try SDTR for a device */\n\tushort ultra_able;\t/* try SDTR Ultra speed for a device */\n\tushort sdtr_speed1;\t/* EEPROM SDTR Speed for TID 0-3   */\n\tushort sdtr_speed2;\t/* EEPROM SDTR Speed for TID 4-7   */\n\tushort sdtr_speed3;\t/* EEPROM SDTR Speed for TID 8-11  */\n\tushort sdtr_speed4;\t/* EEPROM SDTR Speed for TID 12-15 */\n\tushort tagqng_able;\t/* try tagged queuing with a device */\n\tushort ppr_able;\t/* PPR message capable per TID bitmask. */\n\tuchar max_dvc_qng;\t/* maximum number of tagged commands per device */\n\tushort start_motor;\t/* start motor command allowed */\n\tuchar scsi_reset_wait;\t/* delay in seconds after scsi bus reset */\n\tuchar chip_no;\t\t/* should be assigned by caller */\n\tuchar max_host_qng;\t/* maximum number of Q'ed command allowed */\n\tushort no_scam;\t\t/* scam_tolerant of EEPROM */\n\tstruct asc_board *drv_ptr;\t/* driver pointer to private structure */\n\tuchar chip_scsi_id;\t/* chip SCSI target ID */\n\tuchar chip_type;\n\tuchar bist_err_code;\n\tADV_CARR_T *carrier;\n\tADV_CARR_T *carr_freelist;\t/* Carrier free list. */\n\tdma_addr_t carrier_addr;\n\tADV_CARR_T *icq_sp;\t/* Initiator command queue stopper pointer. */\n\tADV_CARR_T *irq_sp;\t/* Initiator response queue stopper pointer. */\n\tushort carr_pending_cnt;\t/* Count of pending carriers. */\n\t/*\n\t * Note: The following fields will not be used after initialization. The\n\t * driver may discard the buffer after initialization is done.\n\t */\n\tADV_DVC_CFG *cfg;\t/* temporary configuration structure  */\n} ADV_DVC_VAR;\n\n/*\n * Microcode idle loop commands\n */\n#define IDLE_CMD_COMPLETED           0\n#define IDLE_CMD_STOP_CHIP           0x0001\n#define IDLE_CMD_STOP_CHIP_SEND_INT  0x0002\n#define IDLE_CMD_SEND_INT            0x0004\n#define IDLE_CMD_ABORT               0x0008\n#define IDLE_CMD_DEVICE_RESET        0x0010\n#define IDLE_CMD_SCSI_RESET_START    0x0020\t/* Assert SCSI Bus Reset */\n#define IDLE_CMD_SCSI_RESET_END      0x0040\t/* Deassert SCSI Bus Reset */\n#define IDLE_CMD_SCSIREQ             0x0080\n\n#define IDLE_CMD_STATUS_SUCCESS      0x0001\n#define IDLE_CMD_STATUS_FAILURE      0x0002\n\n/*\n * AdvSendIdleCmd() flag definitions.\n */\n#define ADV_NOWAIT     0x01\n\n/*\n * Wait loop time out values.\n */\n#define SCSI_WAIT_100_MSEC           100UL\t/* 100 milliseconds */\n#define SCSI_US_PER_MSEC             1000\t/* microseconds per millisecond */\n#define SCSI_MAX_RETRY               10\t/* retry count */\n\n#define ADV_ASYNC_RDMA_FAILURE          0x01\t/* Fatal RDMA failure. */\n#define ADV_ASYNC_SCSI_BUS_RESET_DET    0x02\t/* Detected SCSI Bus Reset. */\n#define ADV_ASYNC_CARRIER_READY_FAILURE 0x03\t/* Carrier Ready failure. */\n#define ADV_RDMA_IN_CARR_AND_Q_INVALID  0x04\t/* RDMAed-in data invalid. */\n\n#define ADV_HOST_SCSI_BUS_RESET      0x80\t/* Host Initiated SCSI Bus Reset. */\n\n/* Read byte from a register. */\n#define AdvReadByteRegister(iop_base, reg_off) \\\n     (ADV_MEM_READB((iop_base) + (reg_off)))\n\n/* Write byte to a register. */\n#define AdvWriteByteRegister(iop_base, reg_off, byte) \\\n     (ADV_MEM_WRITEB((iop_base) + (reg_off), (byte)))\n\n/* Read word (2 bytes) from a register. */\n#define AdvReadWordRegister(iop_base, reg_off) \\\n     (ADV_MEM_READW((iop_base) + (reg_off)))\n\n/* Write word (2 bytes) to a register. */\n#define AdvWriteWordRegister(iop_base, reg_off, word) \\\n     (ADV_MEM_WRITEW((iop_base) + (reg_off), (word)))\n\n/* Write dword (4 bytes) to a register. */\n#define AdvWriteDWordRegister(iop_base, reg_off, dword) \\\n     (ADV_MEM_WRITEDW((iop_base) + (reg_off), (dword)))\n\n/* Read byte from LRAM. */\n#define AdvReadByteLram(iop_base, addr, byte) \\\ndo { \\\n    ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)); \\\n    (byte) = ADV_MEM_READB((iop_base) + IOPB_RAM_DATA); \\\n} while (0)\n\n/* Write byte to LRAM. */\n#define AdvWriteByteLram(iop_base, addr, byte) \\\n    (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \\\n     ADV_MEM_WRITEB((iop_base) + IOPB_RAM_DATA, (byte)))\n\n/* Read word (2 bytes) from LRAM. */\n#define AdvReadWordLram(iop_base, addr, word) \\\ndo { \\\n    ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)); \\\n    (word) = (ADV_MEM_READW((iop_base) + IOPW_RAM_DATA)); \\\n} while (0)\n\n/* Write word (2 bytes) to LRAM. */\n#define AdvWriteWordLram(iop_base, addr, word) \\\n    (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \\\n     ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, (word)))\n\n/* Write little-endian double word (4 bytes) to LRAM */\n/* Because of unspecified C language ordering don't use auto-increment. */\n#define AdvWriteDWordLramNoSwap(iop_base, addr, dword) \\\n    ((ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr)), \\\n      ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, \\\n                     cpu_to_le16((ushort) ((dword) & 0xFFFF)))), \\\n     (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_ADDR, (addr) + 2), \\\n      ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, \\\n                     cpu_to_le16((ushort) ((dword >> 16) & 0xFFFF)))))\n\n/* Read word (2 bytes) from LRAM assuming that the address is already set. */\n#define AdvReadWordAutoIncLram(iop_base) \\\n     (ADV_MEM_READW((iop_base) + IOPW_RAM_DATA))\n\n/* Write word (2 bytes) to LRAM assuming that the address is already set. */\n#define AdvWriteWordAutoIncLram(iop_base, word) \\\n     (ADV_MEM_WRITEW((iop_base) + IOPW_RAM_DATA, (word)))\n\n/*\n * Define macro to check for Condor signature.\n *\n * Evaluate to ADV_TRUE if a Condor chip is found the specified port\n * address 'iop_base'. Otherwise evalue to ADV_FALSE.\n */\n#define AdvFindSignature(iop_base) \\\n    (((AdvReadByteRegister((iop_base), IOPB_CHIP_ID_1) == \\\n    ADV_CHIP_ID_BYTE) && \\\n     (AdvReadWordRegister((iop_base), IOPW_CHIP_ID_0) == \\\n    ADV_CHIP_ID_WORD)) ?  ADV_TRUE : ADV_FALSE)\n\n/*\n * Define macro to Return the version number of the chip at 'iop_base'.\n *\n * The second parameter 'bus_type' is currently unused.\n */\n#define AdvGetChipVersion(iop_base, bus_type) \\\n    AdvReadByteRegister((iop_base), IOPB_CHIP_TYPE_REV)\n\n/*\n * Abort an SRB in the chip's RISC Memory. The 'srb_tag' argument must\n * match the ADV_SCSI_REQ_Q 'srb_tag' field.\n *\n * If the request has not yet been sent to the device it will simply be\n * aborted from RISC memory. If the request is disconnected it will be\n * aborted on reselection by sending an Abort Message to the target ID.\n *\n * Return value:\n *      ADV_TRUE(1) - Queue was successfully aborted.\n *      ADV_FALSE(0) - Queue was not found on the active queue list.\n */\n#define AdvAbortQueue(asc_dvc, srb_tag) \\\n     AdvSendIdleCmd((asc_dvc), (ushort) IDLE_CMD_ABORT, \\\n\t\t    (ADV_DCNT) (srb_tag))\n\n/*\n * Send a Bus Device Reset Message to the specified target ID.\n *\n * All outstanding commands will be purged if sending the\n * Bus Device Reset Message is successful.\n *\n * Return Value:\n *      ADV_TRUE(1) - All requests on the target are purged.\n *      ADV_FALSE(0) - Couldn't issue Bus Device Reset Message; Requests\n *                     are not purged.\n */\n#define AdvResetDevice(asc_dvc, target_id) \\\n     AdvSendIdleCmd((asc_dvc), (ushort) IDLE_CMD_DEVICE_RESET,\t\\\n\t\t    (ADV_DCNT) (target_id))\n\n/*\n * SCSI Wide Type definition.\n */\n#define ADV_SCSI_BIT_ID_TYPE   ushort\n\n/*\n * AdvInitScsiTarget() 'cntl_flag' options.\n */\n#define ADV_SCAN_LUN           0x01\n#define ADV_CAPINFO_NOLUN      0x02\n\n/*\n * Convert target id to target id bit mask.\n */\n#define ADV_TID_TO_TIDMASK(tid)   (0x01 << ((tid) & ADV_MAX_TID))\n\n/*\n * ADV_SCSI_REQ_Q 'done_status' and 'host_status' return values.\n */\n\n#define QD_NO_STATUS         0x00\t/* Request not completed yet. */\n#define QD_NO_ERROR          0x01\n#define QD_ABORTED_BY_HOST   0x02\n#define QD_WITH_ERROR        0x04\n\n#define QHSTA_NO_ERROR              0x00\n#define QHSTA_M_SEL_TIMEOUT         0x11\n#define QHSTA_M_DATA_OVER_RUN       0x12\n#define QHSTA_M_UNEXPECTED_BUS_FREE 0x13\n#define QHSTA_M_QUEUE_ABORTED       0x15\n#define QHSTA_M_SXFR_SDMA_ERR       0x16\t/* SXFR_STATUS SCSI DMA Error */\n#define QHSTA_M_SXFR_SXFR_PERR      0x17\t/* SXFR_STATUS SCSI Bus Parity Error */\n#define QHSTA_M_RDMA_PERR           0x18\t/* RISC PCI DMA parity error */\n#define QHSTA_M_SXFR_OFF_UFLW       0x19\t/* SXFR_STATUS Offset Underflow */\n#define QHSTA_M_SXFR_OFF_OFLW       0x20\t/* SXFR_STATUS Offset Overflow */\n#define QHSTA_M_SXFR_WD_TMO         0x21\t/* SXFR_STATUS Watchdog Timeout */\n#define QHSTA_M_SXFR_DESELECTED     0x22\t/* SXFR_STATUS Deselected */\n/* Note: QHSTA_M_SXFR_XFR_OFLW is identical to QHSTA_M_DATA_OVER_RUN. */\n#define QHSTA_M_SXFR_XFR_OFLW       0x12\t/* SXFR_STATUS Transfer Overflow */\n#define QHSTA_M_SXFR_XFR_PH_ERR     0x24\t/* SXFR_STATUS Transfer Phase Error */\n#define QHSTA_M_SXFR_UNKNOWN_ERROR  0x25\t/* SXFR_STATUS Unknown Error */\n#define QHSTA_M_SCSI_BUS_RESET      0x30\t/* Request aborted from SBR */\n#define QHSTA_M_SCSI_BUS_RESET_UNSOL 0x31\t/* Request aborted from unsol. SBR */\n#define QHSTA_M_BUS_DEVICE_RESET    0x32\t/* Request aborted from BDR */\n#define QHSTA_M_DIRECTION_ERR       0x35\t/* Data Phase mismatch */\n#define QHSTA_M_DIRECTION_ERR_HUNG  0x36\t/* Data Phase mismatch and bus hang */\n#define QHSTA_M_WTM_TIMEOUT         0x41\n#define QHSTA_M_BAD_CMPL_STATUS_IN  0x42\n#define QHSTA_M_NO_AUTO_REQ_SENSE   0x43\n#define QHSTA_M_AUTO_REQ_SENSE_FAIL 0x44\n#define QHSTA_M_INVALID_DEVICE      0x45\t/* Bad target ID */\n#define QHSTA_M_FROZEN_TIDQ         0x46\t/* TID Queue frozen. */\n#define QHSTA_M_SGBACKUP_ERROR      0x47\t/* Scatter-Gather backup error */\n\n/* Return the address that is aligned at the next doubleword >= to 'addr'. */\n#define ADV_32BALIGN(addr)     (((ulong) (addr) + 0x1F) & ~0x1F)\n\n/*\n * Total contiguous memory needed for driver SG blocks.\n *\n * ADV_MAX_SG_LIST must be defined by a driver. It is the maximum\n * number of scatter-gather elements the driver supports in a\n * single request.\n */\n\n#define ADV_SG_LIST_MAX_BYTE_SIZE \\\n         (sizeof(ADV_SG_BLOCK) * \\\n          ((ADV_MAX_SG_LIST + (NO_OF_SG_PER_BLOCK - 1))/NO_OF_SG_PER_BLOCK))\n\n/* struct asc_board flags */\n#define ASC_IS_WIDE_BOARD       0x04\t/* AdvanSys Wide Board */\n\n#define ASC_NARROW_BOARD(boardp) (((boardp)->flags & ASC_IS_WIDE_BOARD) == 0)\n\n#define NO_ISA_DMA              0xff\t/* No ISA DMA Channel Used */\n\n#define ASC_INFO_SIZE           128\t/* advansys_info() line size */\n\n/* Asc Library return codes */\n#define ASC_TRUE        1\n#define ASC_FALSE       0\n#define ASC_NOERROR     1\n#define ASC_BUSY        0\n#define ASC_ERROR       (-1)\n\n/* struct scsi_cmnd function return codes */\n#define STATUS_BYTE(byte)   (byte)\n#define MSG_BYTE(byte)      ((byte) << 8)\n#define HOST_BYTE(byte)     ((byte) << 16)\n#define DRIVER_BYTE(byte)   ((byte) << 24)\n\n#define ASC_STATS(shost, counter) ASC_STATS_ADD(shost, counter, 1)\n#ifndef ADVANSYS_STATS\n#define ASC_STATS_ADD(shost, counter, count)\n#else /* ADVANSYS_STATS */\n#define ASC_STATS_ADD(shost, counter, count) \\\n\t(((struct asc_board *) shost_priv(shost))->asc_stats.counter += (count))\n#endif /* ADVANSYS_STATS */\n\n/* If the result wraps when calculating tenths, return 0. */\n#define ASC_TENTHS(num, den) \\\n    (((10 * ((num)/(den))) > (((num) * 10)/(den))) ? \\\n    0 : ((((num) * 10)/(den)) - (10 * ((num)/(den)))))\n\n/*\n * Display a message to the console.\n */\n#define ASC_PRINT(s) \\\n    { \\\n        printk(\"advansys: \"); \\\n        printk(s); \\\n    }\n\n#define ASC_PRINT1(s, a1) \\\n    { \\\n        printk(\"advansys: \"); \\\n        printk((s), (a1)); \\\n    }\n\n#define ASC_PRINT2(s, a1, a2) \\\n    { \\\n        printk(\"advansys: \"); \\\n        printk((s), (a1), (a2)); \\\n    }\n\n#define ASC_PRINT3(s, a1, a2, a3) \\\n    { \\\n        printk(\"advansys: \"); \\\n        printk((s), (a1), (a2), (a3)); \\\n    }\n\n#define ASC_PRINT4(s, a1, a2, a3, a4) \\\n    { \\\n        printk(\"advansys: \"); \\\n        printk((s), (a1), (a2), (a3), (a4)); \\\n    }\n\n#ifndef ADVANSYS_DEBUG\n\n#define ASC_DBG(lvl, s...)\n#define ASC_DBG_PRT_SCSI_HOST(lvl, s)\n#define ASC_DBG_PRT_ASC_SCSI_Q(lvl, scsiqp)\n#define ASC_DBG_PRT_ADV_SCSI_REQ_Q(lvl, scsiqp)\n#define ASC_DBG_PRT_ASC_QDONE_INFO(lvl, qdone)\n#define ADV_DBG_PRT_ADV_SCSI_REQ_Q(lvl, scsiqp)\n#define ASC_DBG_PRT_HEX(lvl, name, start, length)\n#define ASC_DBG_PRT_CDB(lvl, cdb, len)\n#define ASC_DBG_PRT_SENSE(lvl, sense, len)\n#define ASC_DBG_PRT_INQUIRY(lvl, inq, len)\n\n#else /* ADVANSYS_DEBUG */\n\n/*\n * Debugging Message Levels:\n * 0: Errors Only\n * 1: High-Level Tracing\n * 2-N: Verbose Tracing\n */\n\n#define ASC_DBG(lvl, format, arg...) {\t\t\t\t\t\\\n\tif (asc_dbglvl >= (lvl))\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"%s: %s: \" format, DRV_NAME,\t\t\\\n\t\t\t__func__ , ## arg);\t\t\t\t\\\n}\n\n#define ASC_DBG_PRT_SCSI_HOST(lvl, s) \\\n    { \\\n        if (asc_dbglvl >= (lvl)) { \\\n            asc_prt_scsi_host(s); \\\n        } \\\n    }\n\n#define ASC_DBG_PRT_ASC_SCSI_Q(lvl, scsiqp) \\\n    { \\\n        if (asc_dbglvl >= (lvl)) { \\\n            asc_prt_asc_scsi_q(scsiqp); \\\n        } \\\n    }\n\n#define ASC_DBG_PRT_ASC_QDONE_INFO(lvl, qdone) \\\n    { \\\n        if (asc_dbglvl >= (lvl)) { \\\n            asc_prt_asc_qdone_info(qdone); \\\n        } \\\n    }\n\n#define ASC_DBG_PRT_ADV_SCSI_REQ_Q(lvl, scsiqp) \\\n    { \\\n        if (asc_dbglvl >= (lvl)) { \\\n            asc_prt_adv_scsi_req_q(scsiqp); \\\n        } \\\n    }\n\n#define ASC_DBG_PRT_HEX(lvl, name, start, length) \\\n    { \\\n        if (asc_dbglvl >= (lvl)) { \\\n            asc_prt_hex((name), (start), (length)); \\\n        } \\\n    }\n\n#define ASC_DBG_PRT_CDB(lvl, cdb, len) \\\n        ASC_DBG_PRT_HEX((lvl), \"CDB\", (uchar *) (cdb), (len));\n\n#define ASC_DBG_PRT_SENSE(lvl, sense, len) \\\n        ASC_DBG_PRT_HEX((lvl), \"SENSE\", (uchar *) (sense), (len));\n\n#define ASC_DBG_PRT_INQUIRY(lvl, inq, len) \\\n        ASC_DBG_PRT_HEX((lvl), \"INQUIRY\", (uchar *) (inq), (len));\n#endif /* ADVANSYS_DEBUG */\n\n#ifdef ADVANSYS_STATS\n\n/* Per board statistics structure */\nstruct asc_stats {\n\t/* Driver Entrypoint Statistics */\n\tunsigned int queuecommand;\t/* # calls to advansys_queuecommand() */\n\tunsigned int reset;\t\t/* # calls to advansys_eh_bus_reset() */\n\tunsigned int biosparam;\t/* # calls to advansys_biosparam() */\n\tunsigned int interrupt;\t/* # advansys_interrupt() calls */\n\tunsigned int callback;\t/* # calls to asc/adv_isr_callback() */\n\tunsigned int done;\t\t/* # calls to request's scsi_done function */\n\tunsigned int build_error;\t/* # asc/adv_build_req() ASC_ERROR returns. */\n\tunsigned int adv_build_noreq;\t/* # adv_build_req() adv_req_t alloc. fail. */\n\tunsigned int adv_build_nosg;\t/* # adv_build_req() adv_sgblk_t alloc. fail. */\n\t/* AscExeScsiQueue()/AdvExeScsiQueue() Statistics */\n\tunsigned int exe_noerror;\t/* # ASC_NOERROR returns. */\n\tunsigned int exe_busy;\t/* # ASC_BUSY returns. */\n\tunsigned int exe_error;\t/* # ASC_ERROR returns. */\n\tunsigned int exe_unknown;\t/* # unknown returns. */\n\t/* Data Transfer Statistics */\n\tunsigned int xfer_cnt;\t/* # I/O requests received */\n\tunsigned int xfer_elem;\t/* # scatter-gather elements */\n\tunsigned int xfer_sect;\t/* # 512-byte blocks */\n};\n#endif /* ADVANSYS_STATS */\n\n/*\n * Structure allocated for each board.\n *\n * This structure is allocated by scsi_host_alloc() at the end\n * of the 'Scsi_Host' structure starting at the 'hostdata'\n * field. It is guaranteed to be allocated from DMA-able memory.\n */\nstruct asc_board {\n\tstruct device *dev;\n\tstruct Scsi_Host *shost;\n\tuint flags;\t\t/* Board flags */\n\tunsigned int irq;\n\tunion {\n\t\tASC_DVC_VAR asc_dvc_var;\t/* Narrow board */\n\t\tADV_DVC_VAR adv_dvc_var;\t/* Wide board */\n\t} dvc_var;\n\tunion {\n\t\tASC_DVC_CFG asc_dvc_cfg;\t/* Narrow board */\n\t\tADV_DVC_CFG adv_dvc_cfg;\t/* Wide board */\n\t} dvc_cfg;\n\tushort asc_n_io_port;\t/* Number I/O ports. */\n\tADV_SCSI_BIT_ID_TYPE init_tidmask;\t/* Target init./valid mask */\n\tushort reqcnt[ADV_MAX_TID + 1];\t/* Starvation request count */\n\tADV_SCSI_BIT_ID_TYPE queue_full;\t/* Queue full mask */\n\tushort queue_full_cnt[ADV_MAX_TID + 1];\t/* Queue full count */\n\tunion {\n\t\tASCEEP_CONFIG asc_eep;\t/* Narrow EEPROM config. */\n\t\tADVEEP_3550_CONFIG adv_3550_eep;\t/* 3550 EEPROM config. */\n\t\tADVEEP_38C0800_CONFIG adv_38C0800_eep;\t/* 38C0800 EEPROM config. */\n\t\tADVEEP_38C1600_CONFIG adv_38C1600_eep;\t/* 38C1600 EEPROM config. */\n\t} eep_config;\n\t/* /proc/scsi/advansys/[0...] */\n#ifdef ADVANSYS_STATS\n\tstruct asc_stats asc_stats;\t/* Board statistics */\n#endif\t\t\t\t/* ADVANSYS_STATS */\n\t/*\n\t * The following fields are used only for Narrow Boards.\n\t */\n\tuchar sdtr_data[ASC_MAX_TID + 1];\t/* SDTR information */\n\t/*\n\t * The following fields are used only for Wide Boards.\n\t */\n\tvoid __iomem *ioremap_addr;\t/* I/O Memory remap address. */\n\tushort ioport;\t\t/* I/O Port address. */\n\tadv_req_t *adv_reqp;\t/* Request structures. */\n\tdma_addr_t adv_reqp_addr;\n\tsize_t adv_reqp_size;\n\tstruct dma_pool *adv_sgblk_pool;\t/* Scatter-gather structures. */\n\tushort bios_signature;\t/* BIOS Signature. */\n\tushort bios_version;\t/* BIOS Version. */\n\tushort bios_codeseg;\t/* BIOS Code Segment. */\n\tushort bios_codelen;\t/* BIOS Code Segment Length. */\n};\n\n#define asc_dvc_to_board(asc_dvc) container_of(asc_dvc, struct asc_board, \\\n\t\t\t\t\t\t\tdvc_var.asc_dvc_var)\n#define adv_dvc_to_board(adv_dvc) container_of(adv_dvc, struct asc_board, \\\n\t\t\t\t\t\t\tdvc_var.adv_dvc_var)\n#define adv_dvc_to_pdev(adv_dvc) to_pci_dev(adv_dvc_to_board(adv_dvc)->dev)\n\n#ifdef ADVANSYS_DEBUG\nstatic int asc_dbglvl = 3;\n\n/*\n * asc_prt_asc_dvc_var()\n */\nstatic void asc_prt_asc_dvc_var(ASC_DVC_VAR *h)\n{\n\tprintk(\"ASC_DVC_VAR at addr 0x%lx\\n\", (ulong)h);\n\n\tprintk(\" iop_base 0x%x, err_code 0x%x, dvc_cntl 0x%x, bug_fix_cntl \"\n\t       \"%d,\\n\", h->iop_base, h->err_code, h->dvc_cntl, h->bug_fix_cntl);\n\n\tprintk(\" bus_type %d, init_sdtr 0x%x,\\n\", h->bus_type,\n\t\t(unsigned)h->init_sdtr);\n\n\tprintk(\" sdtr_done 0x%x, use_tagged_qng 0x%x, unit_not_ready 0x%x, \"\n\t       \"chip_no 0x%x,\\n\", (unsigned)h->sdtr_done,\n\t       (unsigned)h->use_tagged_qng, (unsigned)h->unit_not_ready,\n\t       (unsigned)h->chip_no);\n\n\tprintk(\" queue_full_or_busy 0x%x, start_motor 0x%x, scsi_reset_wait \"\n\t       \"%u,\\n\", (unsigned)h->queue_full_or_busy,\n\t       (unsigned)h->start_motor, (unsigned)h->scsi_reset_wait);\n\n\tprintk(\" is_in_int %u, max_total_qng %u, cur_total_qng %u, \"\n\t       \"in_critical_cnt %u,\\n\", (unsigned)h->is_in_int,\n\t       (unsigned)h->max_total_qng, (unsigned)h->cur_total_qng,\n\t       (unsigned)h->in_critical_cnt);\n\n\tprintk(\" last_q_shortage %u, init_state 0x%x, no_scam 0x%x, \"\n\t       \"pci_fix_asyn_xfer 0x%x,\\n\", (unsigned)h->last_q_shortage,\n\t       (unsigned)h->init_state, (unsigned)h->no_scam,\n\t       (unsigned)h->pci_fix_asyn_xfer);\n\n\tprintk(\" cfg 0x%lx\\n\", (ulong)h->cfg);\n}\n\n/*\n * asc_prt_asc_dvc_cfg()\n */\nstatic void asc_prt_asc_dvc_cfg(ASC_DVC_CFG *h)\n{\n\tprintk(\"ASC_DVC_CFG at addr 0x%lx\\n\", (ulong)h);\n\n\tprintk(\" can_tagged_qng 0x%x, cmd_qng_enabled 0x%x,\\n\",\n\t       h->can_tagged_qng, h->cmd_qng_enabled);\n\tprintk(\" disc_enable 0x%x, sdtr_enable 0x%x,\\n\",\n\t       h->disc_enable, h->sdtr_enable);\n\n\tprintk(\" chip_scsi_id %d, isa_dma_speed %d, isa_dma_channel %d, \"\n\t\t\"chip_version %d,\\n\", h->chip_scsi_id, h->isa_dma_speed,\n\t\th->isa_dma_channel, h->chip_version);\n\n\tprintk(\" mcode_date 0x%x, mcode_version %d\\n\",\n\t\th->mcode_date, h->mcode_version);\n}\n\n/*\n * asc_prt_adv_dvc_var()\n *\n * Display an ADV_DVC_VAR structure.\n */\nstatic void asc_prt_adv_dvc_var(ADV_DVC_VAR *h)\n{\n\tprintk(\" ADV_DVC_VAR at addr 0x%lx\\n\", (ulong)h);\n\n\tprintk(\"  iop_base 0x%lx, err_code 0x%x, ultra_able 0x%x\\n\",\n\t       (ulong)h->iop_base, h->err_code, (unsigned)h->ultra_able);\n\n\tprintk(\"  sdtr_able 0x%x, wdtr_able 0x%x\\n\",\n\t       (unsigned)h->sdtr_able, (unsigned)h->wdtr_able);\n\n\tprintk(\"  start_motor 0x%x, scsi_reset_wait 0x%x\\n\",\n\t       (unsigned)h->start_motor, (unsigned)h->scsi_reset_wait);\n\n\tprintk(\"  max_host_qng %u, max_dvc_qng %u, carr_freelist 0x%p\\n\",\n\t       (unsigned)h->max_host_qng, (unsigned)h->max_dvc_qng,\n\t       h->carr_freelist);\n\n\tprintk(\"  icq_sp 0x%p, irq_sp 0x%p\\n\", h->icq_sp, h->irq_sp);\n\n\tprintk(\"  no_scam 0x%x, tagqng_able 0x%x\\n\",\n\t       (unsigned)h->no_scam, (unsigned)h->tagqng_able);\n\n\tprintk(\"  chip_scsi_id 0x%x, cfg 0x%lx\\n\",\n\t       (unsigned)h->chip_scsi_id, (ulong)h->cfg);\n}\n\n/*\n * asc_prt_adv_dvc_cfg()\n *\n * Display an ADV_DVC_CFG structure.\n */\nstatic void asc_prt_adv_dvc_cfg(ADV_DVC_CFG *h)\n{\n\tprintk(\" ADV_DVC_CFG at addr 0x%lx\\n\", (ulong)h);\n\n\tprintk(\"  disc_enable 0x%x, termination 0x%x\\n\",\n\t       h->disc_enable, h->termination);\n\n\tprintk(\"  chip_version 0x%x, mcode_date 0x%x\\n\",\n\t       h->chip_version, h->mcode_date);\n\n\tprintk(\"  mcode_version 0x%x, control_flag 0x%x\\n\",\n\t       h->mcode_version, h->control_flag);\n}\n\n/*\n * asc_prt_scsi_host()\n */\nstatic void asc_prt_scsi_host(struct Scsi_Host *s)\n{\n\tstruct asc_board *boardp = shost_priv(s);\n\n\tprintk(\"Scsi_Host at addr 0x%p, device %s\\n\", s, dev_name(boardp->dev));\n\tprintk(\" host_busy %d, host_no %d,\\n\",\n\t       scsi_host_busy(s), s->host_no);\n\n\tprintk(\" base 0x%lx, io_port 0x%lx, irq %d,\\n\",\n\t       (ulong)s->base, (ulong)s->io_port, boardp->irq);\n\n\tprintk(\" dma_channel %d, this_id %d, can_queue %d,\\n\",\n\t       s->dma_channel, s->this_id, s->can_queue);\n\n\tprintk(\" cmd_per_lun %d, sg_tablesize %d, unchecked_isa_dma %d\\n\",\n\t       s->cmd_per_lun, s->sg_tablesize, s->unchecked_isa_dma);\n\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tasc_prt_asc_dvc_var(&boardp->dvc_var.asc_dvc_var);\n\t\tasc_prt_asc_dvc_cfg(&boardp->dvc_cfg.asc_dvc_cfg);\n\t} else {\n\t\tasc_prt_adv_dvc_var(&boardp->dvc_var.adv_dvc_var);\n\t\tasc_prt_adv_dvc_cfg(&boardp->dvc_cfg.adv_dvc_cfg);\n\t}\n}\n\n/*\n * asc_prt_hex()\n *\n * Print hexadecimal output in 4 byte groupings 32 bytes\n * or 8 double-words per line.\n */\nstatic void asc_prt_hex(char *f, uchar *s, int l)\n{\n\tint i;\n\tint j;\n\tint k;\n\tint m;\n\n\tprintk(\"%s: (%d bytes)\\n\", f, l);\n\n\tfor (i = 0; i < l; i += 32) {\n\n\t\t/* Display a maximum of 8 double-words per line. */\n\t\tif ((k = (l - i) / 4) >= 8) {\n\t\t\tk = 8;\n\t\t\tm = 0;\n\t\t} else {\n\t\t\tm = (l - i) % 4;\n\t\t}\n\n\t\tfor (j = 0; j < k; j++) {\n\t\t\tprintk(\" %2.2X%2.2X%2.2X%2.2X\",\n\t\t\t       (unsigned)s[i + (j * 4)],\n\t\t\t       (unsigned)s[i + (j * 4) + 1],\n\t\t\t       (unsigned)s[i + (j * 4) + 2],\n\t\t\t       (unsigned)s[i + (j * 4) + 3]);\n\t\t}\n\n\t\tswitch (m) {\n\t\tcase 0:\n\t\tdefault:\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tprintk(\" %2.2X\", (unsigned)s[i + (j * 4)]);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintk(\" %2.2X%2.2X\",\n\t\t\t       (unsigned)s[i + (j * 4)],\n\t\t\t       (unsigned)s[i + (j * 4) + 1]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintk(\" %2.2X%2.2X%2.2X\",\n\t\t\t       (unsigned)s[i + (j * 4) + 1],\n\t\t\t       (unsigned)s[i + (j * 4) + 2],\n\t\t\t       (unsigned)s[i + (j * 4) + 3]);\n\t\t\tbreak;\n\t\t}\n\n\t\tprintk(\"\\n\");\n\t}\n}\n\n/*\n * asc_prt_asc_scsi_q()\n */\nstatic void asc_prt_asc_scsi_q(ASC_SCSI_Q *q)\n{\n\tASC_SG_HEAD *sgp;\n\tint i;\n\n\tprintk(\"ASC_SCSI_Q at addr 0x%lx\\n\", (ulong)q);\n\n\tprintk\n\t    (\" target_ix 0x%x, target_lun %u, srb_tag 0x%x, tag_code 0x%x,\\n\",\n\t     q->q2.target_ix, q->q1.target_lun, q->q2.srb_tag,\n\t     q->q2.tag_code);\n\n\tprintk\n\t    (\" data_addr 0x%lx, data_cnt %lu, sense_addr 0x%lx, sense_len %u,\\n\",\n\t     (ulong)le32_to_cpu(q->q1.data_addr),\n\t     (ulong)le32_to_cpu(q->q1.data_cnt),\n\t     (ulong)le32_to_cpu(q->q1.sense_addr), q->q1.sense_len);\n\n\tprintk(\" cdbptr 0x%lx, cdb_len %u, sg_head 0x%lx, sg_queue_cnt %u\\n\",\n\t       (ulong)q->cdbptr, q->q2.cdb_len,\n\t       (ulong)q->sg_head, q->q1.sg_queue_cnt);\n\n\tif (q->sg_head) {\n\t\tsgp = q->sg_head;\n\t\tprintk(\"ASC_SG_HEAD at addr 0x%lx\\n\", (ulong)sgp);\n\t\tprintk(\" entry_cnt %u, queue_cnt %u\\n\", sgp->entry_cnt,\n\t\t       sgp->queue_cnt);\n\t\tfor (i = 0; i < sgp->entry_cnt; i++) {\n\t\t\tprintk(\" [%u]: addr 0x%lx, bytes %lu\\n\",\n\t\t\t       i, (ulong)le32_to_cpu(sgp->sg_list[i].addr),\n\t\t\t       (ulong)le32_to_cpu(sgp->sg_list[i].bytes));\n\t\t}\n\n\t}\n}\n\n/*\n * asc_prt_asc_qdone_info()\n */\nstatic void asc_prt_asc_qdone_info(ASC_QDONE_INFO *q)\n{\n\tprintk(\"ASC_QDONE_INFO at addr 0x%lx\\n\", (ulong)q);\n\tprintk(\" srb_tag 0x%x, target_ix %u, cdb_len %u, tag_code %u,\\n\",\n\t       q->d2.srb_tag, q->d2.target_ix, q->d2.cdb_len,\n\t       q->d2.tag_code);\n\tprintk\n\t    (\" done_stat 0x%x, host_stat 0x%x, scsi_stat 0x%x, scsi_msg 0x%x\\n\",\n\t     q->d3.done_stat, q->d3.host_stat, q->d3.scsi_stat, q->d3.scsi_msg);\n}\n\n/*\n * asc_prt_adv_sgblock()\n *\n * Display an ADV_SG_BLOCK structure.\n */\nstatic void asc_prt_adv_sgblock(int sgblockno, ADV_SG_BLOCK *b)\n{\n\tint i;\n\n\tprintk(\" ADV_SG_BLOCK at addr 0x%lx (sgblockno %d)\\n\",\n\t       (ulong)b, sgblockno);\n\tprintk(\"  sg_cnt %u, sg_ptr 0x%x\\n\",\n\t       b->sg_cnt, (u32)le32_to_cpu(b->sg_ptr));\n\tBUG_ON(b->sg_cnt > NO_OF_SG_PER_BLOCK);\n\tif (b->sg_ptr != 0)\n\t\tBUG_ON(b->sg_cnt != NO_OF_SG_PER_BLOCK);\n\tfor (i = 0; i < b->sg_cnt; i++) {\n\t\tprintk(\"  [%u]: sg_addr 0x%x, sg_count 0x%x\\n\",\n\t\t       i, (u32)le32_to_cpu(b->sg_list[i].sg_addr),\n\t\t       (u32)le32_to_cpu(b->sg_list[i].sg_count));\n\t}\n}\n\n/*\n * asc_prt_adv_scsi_req_q()\n *\n * Display an ADV_SCSI_REQ_Q structure.\n */\nstatic void asc_prt_adv_scsi_req_q(ADV_SCSI_REQ_Q *q)\n{\n\tint sg_blk_cnt;\n\tstruct adv_sg_block *sg_ptr;\n\tadv_sgblk_t *sgblkp;\n\n\tprintk(\"ADV_SCSI_REQ_Q at addr 0x%lx\\n\", (ulong)q);\n\n\tprintk(\"  target_id %u, target_lun %u, srb_tag 0x%x\\n\",\n\t       q->target_id, q->target_lun, q->srb_tag);\n\n\tprintk(\"  cntl 0x%x, data_addr 0x%lx\\n\",\n\t       q->cntl, (ulong)le32_to_cpu(q->data_addr));\n\n\tprintk(\"  data_cnt %lu, sense_addr 0x%lx, sense_len %u,\\n\",\n\t       (ulong)le32_to_cpu(q->data_cnt),\n\t       (ulong)le32_to_cpu(q->sense_addr), q->sense_len);\n\n\tprintk\n\t    (\"  cdb_len %u, done_status 0x%x, host_status 0x%x, scsi_status 0x%x\\n\",\n\t     q->cdb_len, q->done_status, q->host_status, q->scsi_status);\n\n\tprintk(\"  sg_working_ix 0x%x, target_cmd %u\\n\",\n\t       q->sg_working_ix, q->target_cmd);\n\n\tprintk(\"  scsiq_rptr 0x%lx, sg_real_addr 0x%lx, sg_list_ptr 0x%lx\\n\",\n\t       (ulong)le32_to_cpu(q->scsiq_rptr),\n\t       (ulong)le32_to_cpu(q->sg_real_addr), (ulong)q->sg_list_ptr);\n\n\t/* Display the request's ADV_SG_BLOCK structures. */\n\tif (q->sg_list_ptr != NULL) {\n\t\tsgblkp = container_of(q->sg_list_ptr, adv_sgblk_t, sg_block);\n\t\tsg_blk_cnt = 0;\n\t\twhile (sgblkp) {\n\t\t\tsg_ptr = &sgblkp->sg_block;\n\t\t\tasc_prt_adv_sgblock(sg_blk_cnt, sg_ptr);\n\t\t\tif (sg_ptr->sg_ptr == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsgblkp = sgblkp->next_sgblkp;\n\t\t\tsg_blk_cnt++;\n\t\t}\n\t}\n}\n#endif /* ADVANSYS_DEBUG */\n\n/*\n * advansys_info()\n *\n * Return suitable for printing on the console with the argument\n * adapter's configuration information.\n *\n * Note: The information line should not exceed ASC_INFO_SIZE bytes,\n * otherwise the static 'info' array will be overrun.\n */\nstatic const char *advansys_info(struct Scsi_Host *shost)\n{\n\tstatic char info[ASC_INFO_SIZE];\n\tstruct asc_board *boardp = shost_priv(shost);\n\tASC_DVC_VAR *asc_dvc_varp;\n\tADV_DVC_VAR *adv_dvc_varp;\n\tchar *busname;\n\tchar *widename = NULL;\n\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tasc_dvc_varp = &boardp->dvc_var.asc_dvc_var;\n\t\tASC_DBG(1, \"begin\\n\");\n\t\tif (asc_dvc_varp->bus_type & ASC_IS_ISA) {\n\t\t\tif ((asc_dvc_varp->bus_type & ASC_IS_ISAPNP) ==\n\t\t\t    ASC_IS_ISAPNP) {\n\t\t\t\tbusname = \"ISA PnP\";\n\t\t\t} else {\n\t\t\t\tbusname = \"ISA\";\n\t\t\t}\n\t\t\tsprintf(info,\n\t\t\t\t\"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X, DMA 0x%X\",\n\t\t\t\tASC_VERSION, busname,\n\t\t\t\t(ulong)shost->io_port,\n\t\t\t\t(ulong)shost->io_port + ASC_IOADR_GAP - 1,\n\t\t\t\tboardp->irq, shost->dma_channel);\n\t\t} else {\n\t\t\tif (asc_dvc_varp->bus_type & ASC_IS_VL) {\n\t\t\t\tbusname = \"VL\";\n\t\t\t} else if (asc_dvc_varp->bus_type & ASC_IS_EISA) {\n\t\t\t\tbusname = \"EISA\";\n\t\t\t} else if (asc_dvc_varp->bus_type & ASC_IS_PCI) {\n\t\t\t\tif ((asc_dvc_varp->bus_type & ASC_IS_PCI_ULTRA)\n\t\t\t\t    == ASC_IS_PCI_ULTRA) {\n\t\t\t\t\tbusname = \"PCI Ultra\";\n\t\t\t\t} else {\n\t\t\t\t\tbusname = \"PCI\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbusname = \"?\";\n\t\t\t\tshost_printk(KERN_ERR, shost, \"unknown bus \"\n\t\t\t\t\t\"type %d\\n\", asc_dvc_varp->bus_type);\n\t\t\t}\n\t\t\tsprintf(info,\n\t\t\t\t\"AdvanSys SCSI %s: %s: IO 0x%lX-0x%lX, IRQ 0x%X\",\n\t\t\t\tASC_VERSION, busname, (ulong)shost->io_port,\n\t\t\t\t(ulong)shost->io_port + ASC_IOADR_GAP - 1,\n\t\t\t\tboardp->irq);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Wide Adapter Information\n\t\t *\n\t\t * Memory-mapped I/O is used instead of I/O space to access\n\t\t * the adapter, but display the I/O Port range. The Memory\n\t\t * I/O address is displayed through the driver /proc file.\n\t\t */\n\t\tadv_dvc_varp = &boardp->dvc_var.adv_dvc_var;\n\t\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\t\twidename = \"Ultra-Wide\";\n\t\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\t\twidename = \"Ultra2-Wide\";\n\t\t} else {\n\t\t\twidename = \"Ultra3-Wide\";\n\t\t}\n\t\tsprintf(info,\n\t\t\t\"AdvanSys SCSI %s: PCI %s: PCIMEM 0x%lX-0x%lX, IRQ 0x%X\",\n\t\t\tASC_VERSION, widename, (ulong)adv_dvc_varp->iop_base,\n\t\t\t(ulong)adv_dvc_varp->iop_base + boardp->asc_n_io_port - 1, boardp->irq);\n\t}\n\tBUG_ON(strlen(info) >= ASC_INFO_SIZE);\n\tASC_DBG(1, \"end\\n\");\n\treturn info;\n}\n\n#ifdef CONFIG_PROC_FS\n\n/*\n * asc_prt_board_devices()\n *\n * Print driver information for devices attached to the board.\n */\nstatic void asc_prt_board_devices(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\tint chip_scsi_id;\n\tint i;\n\n\tseq_printf(m,\n\t\t   \"\\nDevice Information for AdvanSys SCSI Host %d:\\n\",\n\t\t   shost->host_no);\n\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tchip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;\n\t} else {\n\t\tchip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;\n\t}\n\n\tseq_puts(m, \"Target IDs Detected:\");\n\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\t\tif (boardp->init_tidmask & ADV_TID_TO_TIDMASK(i))\n\t\t\tseq_printf(m, \" %X,\", i);\n\t}\n\tseq_printf(m, \" (%X=Host Adapter)\\n\", chip_scsi_id);\n}\n\n/*\n * Display Wide Board BIOS Information.\n */\nstatic void asc_prt_adv_bios(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\tushort major, minor, letter;\n\n\tseq_puts(m, \"\\nROM BIOS Version: \");\n\n\t/*\n\t * If the BIOS saved a valid signature, then fill in\n\t * the BIOS code segment base address.\n\t */\n\tif (boardp->bios_signature != 0x55AA) {\n\t\tseq_puts(m, \"Disabled or Pre-3.1\\n\"\n\t\t\t\"BIOS either disabled or Pre-3.1. If it is pre-3.1, then a newer version\\n\"\n\t\t\t\"can be found at the ConnectCom FTP site: ftp://ftp.connectcom.net/pub\\n\");\n\t} else {\n\t\tmajor = (boardp->bios_version >> 12) & 0xF;\n\t\tminor = (boardp->bios_version >> 8) & 0xF;\n\t\tletter = (boardp->bios_version & 0xFF);\n\n\t\tseq_printf(m, \"%d.%d%c\\n\",\n\t\t\t\t   major, minor,\n\t\t\t\t   letter >= 26 ? '?' : letter + 'A');\n\t\t/*\n\t\t * Current available ROM BIOS release is 3.1I for UW\n\t\t * and 3.2I for U2W. This code doesn't differentiate\n\t\t * UW and U2W boards.\n\t\t */\n\t\tif (major < 3 || (major <= 3 && minor < 1) ||\n\t\t    (major <= 3 && minor <= 1 && letter < ('I' - 'A'))) {\n\t\t\tseq_puts(m, \"Newer version of ROM BIOS is available at the ConnectCom FTP site:\\n\"\n\t\t\t\t\"ftp://ftp.connectcom.net/pub\\n\");\n\t\t}\n\t}\n}\n\n/*\n * Add serial number to information bar if signature AAh\n * is found in at bit 15-9 (7 bits) of word 1.\n *\n * Serial Number consists fo 12 alpha-numeric digits.\n *\n *       1 - Product type (A,B,C,D..)  Word0: 15-13 (3 bits)\n *       2 - MFG Location (A,B,C,D..)  Word0: 12-10 (3 bits)\n *     3-4 - Product ID (0-99)         Word0: 9-0 (10 bits)\n *       5 - Product revision (A-J)    Word0:  \"         \"\n *\n *           Signature                 Word1: 15-9 (7 bits)\n *       6 - Year (0-9)                Word1: 8-6 (3 bits) & Word2: 15 (1 bit)\n *     7-8 - Week of the year (1-52)   Word1: 5-0 (6 bits)\n *\n *    9-12 - Serial Number (A001-Z999) Word2: 14-0 (15 bits)\n *\n * Note 1: Only production cards will have a serial number.\n *\n * Note 2: Signature is most significant 7 bits (0xFE).\n *\n * Returns ASC_TRUE if serial number found, otherwise returns ASC_FALSE.\n */\nstatic int asc_get_eeprom_string(ushort *serialnum, uchar *cp)\n{\n\tushort w, num;\n\n\tif ((serialnum[1] & 0xFE00) != ((ushort)0xAA << 8)) {\n\t\treturn ASC_FALSE;\n\t} else {\n\t\t/*\n\t\t * First word - 6 digits.\n\t\t */\n\t\tw = serialnum[0];\n\n\t\t/* Product type - 1st digit. */\n\t\tif ((*cp = 'A' + ((w & 0xE000) >> 13)) == 'H') {\n\t\t\t/* Product type is P=Prototype */\n\t\t\t*cp += 0x8;\n\t\t}\n\t\tcp++;\n\n\t\t/* Manufacturing location - 2nd digit. */\n\t\t*cp++ = 'A' + ((w & 0x1C00) >> 10);\n\n\t\t/* Product ID - 3rd, 4th digits. */\n\t\tnum = w & 0x3FF;\n\t\t*cp++ = '0' + (num / 100);\n\t\tnum %= 100;\n\t\t*cp++ = '0' + (num / 10);\n\n\t\t/* Product revision - 5th digit. */\n\t\t*cp++ = 'A' + (num % 10);\n\n\t\t/*\n\t\t * Second word\n\t\t */\n\t\tw = serialnum[1];\n\n\t\t/*\n\t\t * Year - 6th digit.\n\t\t *\n\t\t * If bit 15 of third word is set, then the\n\t\t * last digit of the year is greater than 7.\n\t\t */\n\t\tif (serialnum[2] & 0x8000) {\n\t\t\t*cp++ = '8' + ((w & 0x1C0) >> 6);\n\t\t} else {\n\t\t\t*cp++ = '0' + ((w & 0x1C0) >> 6);\n\t\t}\n\n\t\t/* Week of year - 7th, 8th digits. */\n\t\tnum = w & 0x003F;\n\t\t*cp++ = '0' + num / 10;\n\t\tnum %= 10;\n\t\t*cp++ = '0' + num;\n\n\t\t/*\n\t\t * Third word\n\t\t */\n\t\tw = serialnum[2] & 0x7FFF;\n\n\t\t/* Serial number - 9th digit. */\n\t\t*cp++ = 'A' + (w / 1000);\n\n\t\t/* 10th, 11th, 12th digits. */\n\t\tnum = w % 1000;\n\t\t*cp++ = '0' + num / 100;\n\t\tnum %= 100;\n\t\t*cp++ = '0' + num / 10;\n\t\tnum %= 10;\n\t\t*cp++ = '0' + num;\n\n\t\t*cp = '\\0';\t/* Null Terminate the string. */\n\t\treturn ASC_TRUE;\n\t}\n}\n\n/*\n * asc_prt_asc_board_eeprom()\n *\n * Print board EEPROM configuration.\n */\nstatic void asc_prt_asc_board_eeprom(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\tASC_DVC_VAR *asc_dvc_varp;\n\tASCEEP_CONFIG *ep;\n\tint i;\n#ifdef CONFIG_ISA\n\tint isa_dma_speed[] = { 10, 8, 7, 6, 5, 4, 3, 2 };\n#endif /* CONFIG_ISA */\n\tuchar serialstr[13];\n\n\tasc_dvc_varp = &boardp->dvc_var.asc_dvc_var;\n\tep = &boardp->eep_config.asc_eep;\n\n\tseq_printf(m,\n\t\t   \"\\nEEPROM Settings for AdvanSys SCSI Host %d:\\n\",\n\t\t   shost->host_no);\n\n\tif (asc_get_eeprom_string((ushort *)&ep->adapter_info[0], serialstr)\n\t    == ASC_TRUE)\n\t\tseq_printf(m, \" Serial Number: %s\\n\", serialstr);\n\telse if (ep->adapter_info[5] == 0xBB)\n\t\tseq_puts(m,\n\t\t\t \" Default Settings Used for EEPROM-less Adapter.\\n\");\n\telse\n\t\tseq_puts(m, \" Serial Number Signature Not Present.\\n\");\n\n\tseq_printf(m,\n\t\t   \" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\\n\",\n\t\t   ASC_EEP_GET_CHIP_ID(ep), ep->max_total_qng,\n\t\t   ep->max_tag_qng);\n\n\tseq_printf(m,\n\t\t   \" cntl 0x%x, no_scam 0x%x\\n\", ep->cntl, ep->no_scam);\n\n\tseq_puts(m, \" Target ID:           \");\n\tfor (i = 0; i <= ASC_MAX_TID; i++)\n\t\tseq_printf(m, \" %d\", i);\n\n\tseq_puts(m, \"\\n Disconnects:         \");\n\tfor (i = 0; i <= ASC_MAX_TID; i++)\n\t\tseq_printf(m, \" %c\",\n\t\t\t   (ep->disc_enable & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\n\tseq_puts(m, \"\\n Command Queuing:     \");\n\tfor (i = 0; i <= ASC_MAX_TID; i++)\n\t\tseq_printf(m, \" %c\",\n\t\t\t   (ep->use_cmd_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\n\tseq_puts(m, \"\\n Start Motor:         \");\n\tfor (i = 0; i <= ASC_MAX_TID; i++)\n\t\tseq_printf(m, \" %c\",\n\t\t\t   (ep->start_motor & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\n\tseq_puts(m, \"\\n Synchronous Transfer:\");\n\tfor (i = 0; i <= ASC_MAX_TID; i++)\n\t\tseq_printf(m, \" %c\",\n\t\t\t   (ep->init_sdtr & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\tseq_putc(m, '\\n');\n\n#ifdef CONFIG_ISA\n\tif (asc_dvc_varp->bus_type & ASC_IS_ISA) {\n\t\tseq_printf(m,\n\t\t\t   \" Host ISA DMA speed:   %d MB/S\\n\",\n\t\t\t   isa_dma_speed[ASC_EEP_GET_DMA_SPD(ep)]);\n\t}\n#endif /* CONFIG_ISA */\n}\n\n/*\n * asc_prt_adv_board_eeprom()\n *\n * Print board EEPROM configuration.\n */\nstatic void asc_prt_adv_board_eeprom(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\tADV_DVC_VAR *adv_dvc_varp;\n\tint i;\n\tchar *termstr;\n\tuchar serialstr[13];\n\tADVEEP_3550_CONFIG *ep_3550 = NULL;\n\tADVEEP_38C0800_CONFIG *ep_38C0800 = NULL;\n\tADVEEP_38C1600_CONFIG *ep_38C1600 = NULL;\n\tushort word;\n\tushort *wordp;\n\tushort sdtr_speed = 0;\n\n\tadv_dvc_varp = &boardp->dvc_var.adv_dvc_var;\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\tep_3550 = &boardp->eep_config.adv_3550_eep;\n\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tep_38C0800 = &boardp->eep_config.adv_38C0800_eep;\n\t} else {\n\t\tep_38C1600 = &boardp->eep_config.adv_38C1600_eep;\n\t}\n\n\tseq_printf(m,\n\t\t   \"\\nEEPROM Settings for AdvanSys SCSI Host %d:\\n\",\n\t\t   shost->host_no);\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\twordp = &ep_3550->serial_number_word1;\n\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\twordp = &ep_38C0800->serial_number_word1;\n\t} else {\n\t\twordp = &ep_38C1600->serial_number_word1;\n\t}\n\n\tif (asc_get_eeprom_string(wordp, serialstr) == ASC_TRUE)\n\t\tseq_printf(m, \" Serial Number: %s\\n\", serialstr);\n\telse\n\t\tseq_puts(m, \" Serial Number Signature Not Present.\\n\");\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)\n\t\tseq_printf(m,\n\t\t\t   \" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\\n\",\n\t\t\t   ep_3550->adapter_scsi_id,\n\t\t\t   ep_3550->max_host_qng, ep_3550->max_dvc_qng);\n\telse if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)\n\t\tseq_printf(m,\n\t\t\t   \" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\\n\",\n\t\t\t   ep_38C0800->adapter_scsi_id,\n\t\t\t   ep_38C0800->max_host_qng,\n\t\t\t   ep_38C0800->max_dvc_qng);\n\telse\n\t\tseq_printf(m,\n\t\t\t   \" Host SCSI ID: %u, Host Queue Size: %u, Device Queue Size: %u\\n\",\n\t\t\t   ep_38C1600->adapter_scsi_id,\n\t\t\t   ep_38C1600->max_host_qng,\n\t\t\t   ep_38C1600->max_dvc_qng);\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\tword = ep_3550->termination;\n\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tword = ep_38C0800->termination_lvd;\n\t} else {\n\t\tword = ep_38C1600->termination_lvd;\n\t}\n\tswitch (word) {\n\tcase 1:\n\t\ttermstr = \"Low Off/High Off\";\n\t\tbreak;\n\tcase 2:\n\t\ttermstr = \"Low Off/High On\";\n\t\tbreak;\n\tcase 3:\n\t\ttermstr = \"Low On/High On\";\n\t\tbreak;\n\tdefault:\n\tcase 0:\n\t\ttermstr = \"Automatic\";\n\t\tbreak;\n\t}\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550)\n\t\tseq_printf(m,\n\t\t\t   \" termination: %u (%s), bios_ctrl: 0x%x\\n\",\n\t\t\t   ep_3550->termination, termstr,\n\t\t\t   ep_3550->bios_ctrl);\n\telse if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800)\n\t\tseq_printf(m,\n\t\t\t   \" termination: %u (%s), bios_ctrl: 0x%x\\n\",\n\t\t\t   ep_38C0800->termination_lvd, termstr,\n\t\t\t   ep_38C0800->bios_ctrl);\n\telse\n\t\tseq_printf(m,\n\t\t\t   \" termination: %u (%s), bios_ctrl: 0x%x\\n\",\n\t\t\t   ep_38C1600->termination_lvd, termstr,\n\t\t\t   ep_38C1600->bios_ctrl);\n\n\tseq_puts(m, \" Target ID:           \");\n\tfor (i = 0; i <= ADV_MAX_TID; i++)\n\t\tseq_printf(m, \" %X\", i);\n\tseq_putc(m, '\\n');\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\tword = ep_3550->disc_enable;\n\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tword = ep_38C0800->disc_enable;\n\t} else {\n\t\tword = ep_38C1600->disc_enable;\n\t}\n\tseq_puts(m, \" Disconnects:         \");\n\tfor (i = 0; i <= ADV_MAX_TID; i++)\n\t\tseq_printf(m, \" %c\",\n\t\t\t   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\tseq_putc(m, '\\n');\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\tword = ep_3550->tagqng_able;\n\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tword = ep_38C0800->tagqng_able;\n\t} else {\n\t\tword = ep_38C1600->tagqng_able;\n\t}\n\tseq_puts(m, \" Command Queuing:     \");\n\tfor (i = 0; i <= ADV_MAX_TID; i++)\n\t\tseq_printf(m, \" %c\",\n\t\t\t   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\tseq_putc(m, '\\n');\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\tword = ep_3550->start_motor;\n\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tword = ep_38C0800->start_motor;\n\t} else {\n\t\tword = ep_38C1600->start_motor;\n\t}\n\tseq_puts(m, \" Start Motor:         \");\n\tfor (i = 0; i <= ADV_MAX_TID; i++)\n\t\tseq_printf(m, \" %c\",\n\t\t\t   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\tseq_putc(m, '\\n');\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\tseq_puts(m, \" Synchronous Transfer:\");\n\t\tfor (i = 0; i <= ADV_MAX_TID; i++)\n\t\t\tseq_printf(m, \" %c\",\n\t\t\t\t   (ep_3550->sdtr_able & ADV_TID_TO_TIDMASK(i)) ?\n\t\t\t\t   'Y' : 'N');\n\t\tseq_putc(m, '\\n');\n\t}\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\tseq_puts(m, \" Ultra Transfer:      \");\n\t\tfor (i = 0; i <= ADV_MAX_TID; i++)\n\t\t\tseq_printf(m, \" %c\",\n\t\t\t\t   (ep_3550->ultra_able & ADV_TID_TO_TIDMASK(i))\n\t\t\t\t   ? 'Y' : 'N');\n\t\tseq_putc(m, '\\n');\n\t}\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\tword = ep_3550->wdtr_able;\n\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tword = ep_38C0800->wdtr_able;\n\t} else {\n\t\tword = ep_38C1600->wdtr_able;\n\t}\n\tseq_puts(m, \" Wide Transfer:       \");\n\tfor (i = 0; i <= ADV_MAX_TID; i++)\n\t\tseq_printf(m, \" %c\",\n\t\t\t   (word & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\tseq_putc(m, '\\n');\n\n\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800 ||\n\t    adv_dvc_varp->chip_type == ADV_CHIP_ASC38C1600) {\n\t\tseq_puts(m, \" Synchronous Transfer Speed (Mhz):\\n  \");\n\t\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\t\t\tchar *speed_str;\n\n\t\t\tif (i == 0) {\n\t\t\t\tsdtr_speed = adv_dvc_varp->sdtr_speed1;\n\t\t\t} else if (i == 4) {\n\t\t\t\tsdtr_speed = adv_dvc_varp->sdtr_speed2;\n\t\t\t} else if (i == 8) {\n\t\t\t\tsdtr_speed = adv_dvc_varp->sdtr_speed3;\n\t\t\t} else if (i == 12) {\n\t\t\t\tsdtr_speed = adv_dvc_varp->sdtr_speed4;\n\t\t\t}\n\t\t\tswitch (sdtr_speed & ADV_MAX_TID) {\n\t\t\tcase 0:\n\t\t\t\tspeed_str = \"Off\";\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tspeed_str = \"  5\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tspeed_str = \" 10\";\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tspeed_str = \" 20\";\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tspeed_str = \" 40\";\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tspeed_str = \" 80\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tspeed_str = \"Unk\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseq_printf(m, \"%X:%s \", i, speed_str);\n\t\t\tif (i == 7)\n\t\t\t\tseq_puts(m, \"\\n  \");\n\t\t\tsdtr_speed >>= 4;\n\t\t}\n\t\tseq_putc(m, '\\n');\n\t}\n}\n\n/*\n * asc_prt_driver_conf()\n */\nstatic void asc_prt_driver_conf(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\tint chip_scsi_id;\n\n\tseq_printf(m,\n\t\t\"\\nLinux Driver Configuration and Information for AdvanSys SCSI Host %d:\\n\",\n\t\tshost->host_no);\n\n\tseq_printf(m,\n\t\t   \" host_busy %d, max_id %u, max_lun %llu, max_channel %u\\n\",\n\t\t   scsi_host_busy(shost), shost->max_id,\n\t\t   shost->max_lun, shost->max_channel);\n\n\tseq_printf(m,\n\t\t   \" unique_id %d, can_queue %d, this_id %d, sg_tablesize %u, cmd_per_lun %u\\n\",\n\t\t   shost->unique_id, shost->can_queue, shost->this_id,\n\t\t   shost->sg_tablesize, shost->cmd_per_lun);\n\n\tseq_printf(m,\n\t\t   \" unchecked_isa_dma %d\\n\",\n\t\t   shost->unchecked_isa_dma);\n\n\tseq_printf(m,\n\t\t   \" flags 0x%x, last_reset 0x%lx, jiffies 0x%lx, asc_n_io_port 0x%x\\n\",\n\t\t   boardp->flags, shost->last_reset, jiffies,\n\t\t   boardp->asc_n_io_port);\n\n\tseq_printf(m, \" io_port 0x%lx\\n\", shost->io_port);\n\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tchip_scsi_id = boardp->dvc_cfg.asc_dvc_cfg.chip_scsi_id;\n\t} else {\n\t\tchip_scsi_id = boardp->dvc_var.adv_dvc_var.chip_scsi_id;\n\t}\n}\n\n/*\n * asc_prt_asc_board_info()\n *\n * Print dynamic board configuration information.\n */\nstatic void asc_prt_asc_board_info(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\tint chip_scsi_id;\n\tASC_DVC_VAR *v;\n\tASC_DVC_CFG *c;\n\tint i;\n\tint renegotiate = 0;\n\n\tv = &boardp->dvc_var.asc_dvc_var;\n\tc = &boardp->dvc_cfg.asc_dvc_cfg;\n\tchip_scsi_id = c->chip_scsi_id;\n\n\tseq_printf(m,\n\t\t   \"\\nAsc Library Configuration and Statistics for AdvanSys SCSI Host %d:\\n\",\n\t\t   shost->host_no);\n\n\tseq_printf(m, \" chip_version %u, mcode_date 0x%x, \"\n\t\t   \"mcode_version 0x%x, err_code %u\\n\",\n\t\t   c->chip_version, c->mcode_date, c->mcode_version,\n\t\t   v->err_code);\n\n\t/* Current number of commands waiting for the host. */\n\tseq_printf(m,\n\t\t   \" Total Command Pending: %d\\n\", v->cur_total_qng);\n\n\tseq_puts(m, \" Command Queuing:\");\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\t\tseq_printf(m, \" %X:%c\",\n\t\t\t   i,\n\t\t\t   (v->use_tagged_qng & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\t}\n\n\t/* Current number of commands waiting for a device. */\n\tseq_puts(m, \"\\n Command Queue Pending:\");\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\t\tseq_printf(m, \" %X:%u\", i, v->cur_dvc_qng[i]);\n\t}\n\n\t/* Current limit on number of commands that can be sent to a device. */\n\tseq_puts(m, \"\\n Command Queue Limit:\");\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\t\tseq_printf(m, \" %X:%u\", i, v->max_dvc_qng[i]);\n\t}\n\n\t/* Indicate whether the device has returned queue full status. */\n\tseq_puts(m, \"\\n Command Queue Full:\");\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (boardp->queue_full & ADV_TID_TO_TIDMASK(i))\n\t\t\tseq_printf(m, \" %X:Y-%d\",\n\t\t\t\t   i, boardp->queue_full_cnt[i]);\n\t\telse\n\t\t\tseq_printf(m, \" %X:N\", i);\n\t}\n\n\tseq_puts(m, \"\\n Synchronous Transfer:\");\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\t\tseq_printf(m, \" %X:%c\",\n\t\t\t   i,\n\t\t\t   (v->sdtr_done & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\t}\n\tseq_putc(m, '\\n');\n\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tuchar syn_period_ix;\n\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0) ||\n\t\t    ((v->init_sdtr & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq_printf(m, \"  %X:\", i);\n\n\t\tif ((boardp->sdtr_data[i] & ASC_SYN_MAX_OFFSET) == 0) {\n\t\t\tseq_puts(m, \" Asynchronous\");\n\t\t} else {\n\t\t\tsyn_period_ix =\n\t\t\t    (boardp->sdtr_data[i] >> 4) & (v->max_sdtr_index -\n\t\t\t\t\t\t\t   1);\n\n\t\t\tseq_printf(m,\n\t\t\t\t   \" Transfer Period Factor: %d (%d.%d Mhz),\",\n\t\t\t\t   v->sdtr_period_tbl[syn_period_ix],\n\t\t\t\t   250 / v->sdtr_period_tbl[syn_period_ix],\n\t\t\t\t   ASC_TENTHS(250,\n\t\t\t\t\t      v->sdtr_period_tbl[syn_period_ix]));\n\n\t\t\tseq_printf(m, \" REQ/ACK Offset: %d\",\n\t\t\t\t   boardp->sdtr_data[i] & ASC_SYN_MAX_OFFSET);\n\t\t}\n\n\t\tif ((v->sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {\n\t\t\tseq_puts(m, \"*\\n\");\n\t\t\trenegotiate = 1;\n\t\t} else {\n\t\t\tseq_putc(m, '\\n');\n\t\t}\n\t}\n\n\tif (renegotiate) {\n\t\tseq_puts(m, \" * = Re-negotiation pending before next command.\\n\");\n\t}\n}\n\n/*\n * asc_prt_adv_board_info()\n *\n * Print dynamic board configuration information.\n */\nstatic void asc_prt_adv_board_info(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\tint i;\n\tADV_DVC_VAR *v;\n\tADV_DVC_CFG *c;\n\tAdvPortAddr iop_base;\n\tushort chip_scsi_id;\n\tushort lramword;\n\tuchar lrambyte;\n\tushort tagqng_able;\n\tushort sdtr_able, wdtr_able;\n\tushort wdtr_done, sdtr_done;\n\tushort period = 0;\n\tint renegotiate = 0;\n\n\tv = &boardp->dvc_var.adv_dvc_var;\n\tc = &boardp->dvc_cfg.adv_dvc_cfg;\n\tiop_base = v->iop_base;\n\tchip_scsi_id = v->chip_scsi_id;\n\n\tseq_printf(m,\n\t\t   \"\\nAdv Library Configuration and Statistics for AdvanSys SCSI Host %d:\\n\",\n\t\t   shost->host_no);\n\n\tseq_printf(m,\n\t\t   \" iop_base 0x%lx, cable_detect: %X, err_code %u\\n\",\n\t\t   (unsigned long)v->iop_base,\n\t\t   AdvReadWordRegister(iop_base,IOPW_SCSI_CFG1) & CABLE_DETECT,\n\t\t   v->err_code);\n\n\tseq_printf(m, \" chip_version %u, mcode_date 0x%x, \"\n\t\t   \"mcode_version 0x%x\\n\", c->chip_version,\n\t\t   c->mcode_date, c->mcode_version);\n\n\tAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tseq_puts(m, \" Queuing Enabled:\");\n\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq_printf(m, \" %X:%c\",\n\t\t\t   i,\n\t\t\t   (tagqng_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\t}\n\n\tseq_puts(m, \"\\n Queue Limit:\");\n\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + i,\n\t\t\t\tlrambyte);\n\n\t\tseq_printf(m, \" %X:%d\", i, lrambyte);\n\t}\n\n\tseq_puts(m, \"\\n Command Pending:\");\n\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_QUEUED_CMD + i,\n\t\t\t\tlrambyte);\n\n\t\tseq_printf(m, \" %X:%d\", i, lrambyte);\n\t}\n\tseq_putc(m, '\\n');\n\n\tAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\tseq_puts(m, \" Wide Enabled:\");\n\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq_printf(m, \" %X:%c\",\n\t\t\t   i,\n\t\t\t   (wdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\t}\n\tseq_putc(m, '\\n');\n\n\tAdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, wdtr_done);\n\tseq_puts(m, \" Transfer Bit Width:\");\n\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tAdvReadWordLram(iop_base,\n\t\t\t\tASC_MC_DEVICE_HSHK_CFG_TABLE + (2 * i),\n\t\t\t\tlramword);\n\n\t\tseq_printf(m, \" %X:%d\",\n\t\t\t   i, (lramword & 0x8000) ? 16 : 8);\n\n\t\tif ((wdtr_able & ADV_TID_TO_TIDMASK(i)) &&\n\t\t    (wdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {\n\t\t\tseq_putc(m, '*');\n\t\t\trenegotiate = 1;\n\t\t}\n\t}\n\tseq_putc(m, '\\n');\n\n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\tseq_puts(m, \" Synchronous Enabled:\");\n\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq_printf(m, \" %X:%c\",\n\t\t\t   i,\n\t\t\t   (sdtr_able & ADV_TID_TO_TIDMASK(i)) ? 'Y' : 'N');\n\t}\n\tseq_putc(m, '\\n');\n\n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, sdtr_done);\n\tfor (i = 0; i <= ADV_MAX_TID; i++) {\n\n\t\tAdvReadWordLram(iop_base,\n\t\t\t\tASC_MC_DEVICE_HSHK_CFG_TABLE + (2 * i),\n\t\t\t\tlramword);\n\t\tlramword &= ~0x8000;\n\n\t\tif ((chip_scsi_id == i) ||\n\t\t    ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(i)) == 0) ||\n\t\t    ((sdtr_able & ADV_TID_TO_TIDMASK(i)) == 0)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq_printf(m, \"  %X:\", i);\n\n\t\tif ((lramword & 0x1F) == 0) {\t/* Check for REQ/ACK Offset 0. */\n\t\t\tseq_puts(m, \" Asynchronous\");\n\t\t} else {\n\t\t\tseq_puts(m, \" Transfer Period Factor: \");\n\n\t\t\tif ((lramword & 0x1F00) == 0x1100) {\t/* 80 Mhz */\n\t\t\t\tseq_puts(m, \"9 (80.0 Mhz),\");\n\t\t\t} else if ((lramword & 0x1F00) == 0x1000) {\t/* 40 Mhz */\n\t\t\t\tseq_puts(m, \"10 (40.0 Mhz),\");\n\t\t\t} else {\t/* 20 Mhz or below. */\n\n\t\t\t\tperiod = (((lramword >> 8) * 25) + 50) / 4;\n\n\t\t\t\tif (period == 0) {\t/* Should never happen. */\n\t\t\t\t\tseq_printf(m, \"%d (? Mhz), \", period);\n\t\t\t\t} else {\n\t\t\t\t\tseq_printf(m,\n\t\t\t\t\t\t   \"%d (%d.%d Mhz),\",\n\t\t\t\t\t\t   period, 250 / period,\n\t\t\t\t\t\t   ASC_TENTHS(250, period));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tseq_printf(m, \" REQ/ACK Offset: %d\",\n\t\t\t\t   lramword & 0x1F);\n\t\t}\n\n\t\tif ((sdtr_done & ADV_TID_TO_TIDMASK(i)) == 0) {\n\t\t\tseq_puts(m, \"*\\n\");\n\t\t\trenegotiate = 1;\n\t\t} else {\n\t\t\tseq_putc(m, '\\n');\n\t\t}\n\t}\n\n\tif (renegotiate) {\n\t\tseq_puts(m, \" * = Re-negotiation pending before next command.\\n\");\n\t}\n}\n\n#ifdef ADVANSYS_STATS\n/*\n * asc_prt_board_stats()\n */\nstatic void asc_prt_board_stats(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\tstruct asc_stats *s = &boardp->asc_stats;\n\n\tseq_printf(m,\n\t\t   \"\\nLinux Driver Statistics for AdvanSys SCSI Host %d:\\n\",\n\t\t   shost->host_no);\n\n\tseq_printf(m,\n\t\t   \" queuecommand %u, reset %u, biosparam %u, interrupt %u\\n\",\n\t\t   s->queuecommand, s->reset, s->biosparam,\n\t\t   s->interrupt);\n\n\tseq_printf(m,\n\t\t   \" callback %u, done %u, build_error %u, build_noreq %u, build_nosg %u\\n\",\n\t\t   s->callback, s->done, s->build_error,\n\t\t   s->adv_build_noreq, s->adv_build_nosg);\n\n\tseq_printf(m,\n\t\t   \" exe_noerror %u, exe_busy %u, exe_error %u, exe_unknown %u\\n\",\n\t\t   s->exe_noerror, s->exe_busy, s->exe_error,\n\t\t   s->exe_unknown);\n\n\t/*\n\t * Display data transfer statistics.\n\t */\n\tif (s->xfer_cnt > 0) {\n\t\tseq_printf(m, \" xfer_cnt %u, xfer_elem %u, \",\n\t\t\t   s->xfer_cnt, s->xfer_elem);\n\n\t\tseq_printf(m, \"xfer_bytes %u.%01u kb\\n\",\n\t\t\t   s->xfer_sect / 2, ASC_TENTHS(s->xfer_sect, 2));\n\n\t\t/* Scatter gather transfer statistics */\n\t\tseq_printf(m, \" avg_num_elem %u.%01u, \",\n\t\t\t   s->xfer_elem / s->xfer_cnt,\n\t\t\t   ASC_TENTHS(s->xfer_elem, s->xfer_cnt));\n\n\t\tseq_printf(m, \"avg_elem_size %u.%01u kb, \",\n\t\t\t   (s->xfer_sect / 2) / s->xfer_elem,\n\t\t\t   ASC_TENTHS((s->xfer_sect / 2), s->xfer_elem));\n\n\t\tseq_printf(m, \"avg_xfer_size %u.%01u kb\\n\",\n\t\t\t   (s->xfer_sect / 2) / s->xfer_cnt,\n\t\t\t   ASC_TENTHS((s->xfer_sect / 2), s->xfer_cnt));\n\t}\n}\n#endif /* ADVANSYS_STATS */\n\n/*\n * advansys_show_info() - /proc/scsi/advansys/{0,1,2,3,...}\n *\n * m: seq_file to print into\n * shost: Scsi_Host\n *\n * Return the number of bytes read from or written to a\n * /proc/scsi/advansys/[0...] file.\n */\nstatic int\nadvansys_show_info(struct seq_file *m, struct Scsi_Host *shost)\n{\n\tstruct asc_board *boardp = shost_priv(shost);\n\n\tASC_DBG(1, \"begin\\n\");\n\n\t/*\n\t * User read of /proc/scsi/advansys/[0...] file.\n\t */\n\n\t/*\n\t * Get board configuration information.\n\t *\n\t * advansys_info() returns the board string from its own static buffer.\n\t */\n\t/* Copy board information. */\n\tseq_printf(m, \"%s\\n\", (char *)advansys_info(shost));\n\t/*\n\t * Display Wide Board BIOS Information.\n\t */\n\tif (!ASC_NARROW_BOARD(boardp))\n\t\tasc_prt_adv_bios(m, shost);\n\n\t/*\n\t * Display driver information for each device attached to the board.\n\t */\n\tasc_prt_board_devices(m, shost);\n\n\t/*\n\t * Display EEPROM configuration for the board.\n\t */\n\tif (ASC_NARROW_BOARD(boardp))\n\t\tasc_prt_asc_board_eeprom(m, shost);\n\telse\n\t\tasc_prt_adv_board_eeprom(m, shost);\n\n\t/*\n\t * Display driver configuration and information for the board.\n\t */\n\tasc_prt_driver_conf(m, shost);\n\n#ifdef ADVANSYS_STATS\n\t/*\n\t * Display driver statistics for the board.\n\t */\n\tasc_prt_board_stats(m, shost);\n#endif /* ADVANSYS_STATS */\n\n\t/*\n\t * Display Asc Library dynamic configuration information\n\t * for the board.\n\t */\n\tif (ASC_NARROW_BOARD(boardp))\n\t\tasc_prt_asc_board_info(m, shost);\n\telse\n\t\tasc_prt_adv_board_info(m, shost);\n\treturn 0;\n}\n#endif /* CONFIG_PROC_FS */\n\nstatic void asc_scsi_done(struct scsi_cmnd *scp)\n{\n\tscsi_dma_unmap(scp);\n\tASC_STATS(scp->device->host, done);\n\tscp->scsi_done(scp);\n}\n\nstatic void AscSetBank(PortAddr iop_base, uchar bank)\n{\n\tuchar val;\n\n\tval = AscGetChipControl(iop_base) &\n\t    (~\n\t     (CC_SINGLE_STEP | CC_TEST | CC_DIAG | CC_SCSI_RESET |\n\t      CC_CHIP_RESET));\n\tif (bank == 1) {\n\t\tval |= CC_BANK_ONE;\n\t} else if (bank == 2) {\n\t\tval |= CC_DIAG | CC_BANK_ONE;\n\t} else {\n\t\tval &= ~CC_BANK_ONE;\n\t}\n\tAscSetChipControl(iop_base, val);\n}\n\nstatic void AscSetChipIH(PortAddr iop_base, ushort ins_code)\n{\n\tAscSetBank(iop_base, 1);\n\tAscWriteChipIH(iop_base, ins_code);\n\tAscSetBank(iop_base, 0);\n}\n\nstatic int AscStartChip(PortAddr iop_base)\n{\n\tAscSetChipControl(iop_base, 0);\n\tif ((AscGetChipStatus(iop_base) & CSW_HALTED) != 0) {\n\t\treturn (0);\n\t}\n\treturn (1);\n}\n\nstatic bool AscStopChip(PortAddr iop_base)\n{\n\tuchar cc_val;\n\n\tcc_val =\n\t    AscGetChipControl(iop_base) &\n\t    (~(CC_SINGLE_STEP | CC_TEST | CC_DIAG));\n\tAscSetChipControl(iop_base, (uchar)(cc_val | CC_HALT));\n\tAscSetChipIH(iop_base, INS_HALT);\n\tAscSetChipIH(iop_base, INS_RFLAG_WTM);\n\tif ((AscGetChipStatus(iop_base) & CSW_HALTED) == 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool AscIsChipHalted(PortAddr iop_base)\n{\n\tif ((AscGetChipStatus(iop_base) & CSW_HALTED) != 0) {\n\t\tif ((AscGetChipControl(iop_base) & CC_HALT) != 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool AscResetChipAndScsiBus(ASC_DVC_VAR *asc_dvc)\n{\n\tPortAddr iop_base;\n\tint i = 10;\n\n\tiop_base = asc_dvc->iop_base;\n\twhile ((AscGetChipStatus(iop_base) & CSW_SCSI_RESET_ACTIVE)\n\t       && (i-- > 0)) {\n\t\tmdelay(100);\n\t}\n\tAscStopChip(iop_base);\n\tAscSetChipControl(iop_base, CC_CHIP_RESET | CC_SCSI_RESET | CC_HALT);\n\tudelay(60);\n\tAscSetChipIH(iop_base, INS_RFLAG_WTM);\n\tAscSetChipIH(iop_base, INS_HALT);\n\tAscSetChipControl(iop_base, CC_CHIP_RESET | CC_HALT);\n\tAscSetChipControl(iop_base, CC_HALT);\n\tmdelay(200);\n\tAscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);\n\tAscSetChipStatus(iop_base, 0);\n\treturn (AscIsChipHalted(iop_base));\n}\n\nstatic int AscFindSignature(PortAddr iop_base)\n{\n\tushort sig_word;\n\n\tASC_DBG(1, \"AscGetChipSignatureByte(0x%x) 0x%x\\n\",\n\t\t iop_base, AscGetChipSignatureByte(iop_base));\n\tif (AscGetChipSignatureByte(iop_base) == (uchar)ASC_1000_ID1B) {\n\t\tASC_DBG(1, \"AscGetChipSignatureWord(0x%x) 0x%x\\n\",\n\t\t\t iop_base, AscGetChipSignatureWord(iop_base));\n\t\tsig_word = AscGetChipSignatureWord(iop_base);\n\t\tif ((sig_word == (ushort)ASC_1000_ID0W) ||\n\t\t    (sig_word == (ushort)ASC_1000_ID0W_FIX)) {\n\t\t\treturn (1);\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic void AscEnableInterrupt(PortAddr iop_base)\n{\n\tushort cfg;\n\n\tcfg = AscGetChipCfgLsw(iop_base);\n\tAscSetChipCfgLsw(iop_base, cfg | ASC_CFG0_HOST_INT_ON);\n}\n\nstatic void AscDisableInterrupt(PortAddr iop_base)\n{\n\tushort cfg;\n\n\tcfg = AscGetChipCfgLsw(iop_base);\n\tAscSetChipCfgLsw(iop_base, cfg & (~ASC_CFG0_HOST_INT_ON));\n}\n\nstatic uchar AscReadLramByte(PortAddr iop_base, ushort addr)\n{\n\tunsigned char byte_data;\n\tunsigned short word_data;\n\n\tif (isodd_word(addr)) {\n\t\tAscSetChipLramAddr(iop_base, addr - 1);\n\t\tword_data = AscGetChipLramData(iop_base);\n\t\tbyte_data = (word_data >> 8) & 0xFF;\n\t} else {\n\t\tAscSetChipLramAddr(iop_base, addr);\n\t\tword_data = AscGetChipLramData(iop_base);\n\t\tbyte_data = word_data & 0xFF;\n\t}\n\treturn byte_data;\n}\n\nstatic ushort AscReadLramWord(PortAddr iop_base, ushort addr)\n{\n\tushort word_data;\n\n\tAscSetChipLramAddr(iop_base, addr);\n\tword_data = AscGetChipLramData(iop_base);\n\treturn (word_data);\n}\n\nstatic void\nAscMemWordSetLram(PortAddr iop_base, ushort s_addr, ushort set_wval, int words)\n{\n\tint i;\n\n\tAscSetChipLramAddr(iop_base, s_addr);\n\tfor (i = 0; i < words; i++) {\n\t\tAscSetChipLramData(iop_base, set_wval);\n\t}\n}\n\nstatic void AscWriteLramWord(PortAddr iop_base, ushort addr, ushort word_val)\n{\n\tAscSetChipLramAddr(iop_base, addr);\n\tAscSetChipLramData(iop_base, word_val);\n}\n\nstatic void AscWriteLramByte(PortAddr iop_base, ushort addr, uchar byte_val)\n{\n\tushort word_data;\n\n\tif (isodd_word(addr)) {\n\t\taddr--;\n\t\tword_data = AscReadLramWord(iop_base, addr);\n\t\tword_data &= 0x00FF;\n\t\tword_data |= (((ushort)byte_val << 8) & 0xFF00);\n\t} else {\n\t\tword_data = AscReadLramWord(iop_base, addr);\n\t\tword_data &= 0xFF00;\n\t\tword_data |= ((ushort)byte_val & 0x00FF);\n\t}\n\tAscWriteLramWord(iop_base, addr, word_data);\n}\n\n/*\n * Copy 2 bytes to LRAM.\n *\n * The source data is assumed to be in little-endian order in memory\n * and is maintained in little-endian order when written to LRAM.\n */\nstatic void\nAscMemWordCopyPtrToLram(PortAddr iop_base, ushort s_addr,\n\t\t\tconst uchar *s_buffer, int words)\n{\n\tint i;\n\n\tAscSetChipLramAddr(iop_base, s_addr);\n\tfor (i = 0; i < 2 * words; i += 2) {\n\t\t/*\n\t\t * On a little-endian system the second argument below\n\t\t * produces a little-endian ushort which is written to\n\t\t * LRAM in little-endian order. On a big-endian system\n\t\t * the second argument produces a big-endian ushort which\n\t\t * is \"transparently\" byte-swapped by outpw() and written\n\t\t * in little-endian order to LRAM.\n\t\t */\n\t\toutpw(iop_base + IOP_RAM_DATA,\n\t\t      ((ushort)s_buffer[i + 1] << 8) | s_buffer[i]);\n\t}\n}\n\n/*\n * Copy 4 bytes to LRAM.\n *\n * The source data is assumed to be in little-endian order in memory\n * and is maintained in little-endian order when written to LRAM.\n */\nstatic void\nAscMemDWordCopyPtrToLram(PortAddr iop_base,\n\t\t\t ushort s_addr, uchar *s_buffer, int dwords)\n{\n\tint i;\n\n\tAscSetChipLramAddr(iop_base, s_addr);\n\tfor (i = 0; i < 4 * dwords; i += 4) {\n\t\toutpw(iop_base + IOP_RAM_DATA, ((ushort)s_buffer[i + 1] << 8) | s_buffer[i]);\t/* LSW */\n\t\toutpw(iop_base + IOP_RAM_DATA, ((ushort)s_buffer[i + 3] << 8) | s_buffer[i + 2]);\t/* MSW */\n\t}\n}\n\n/*\n * Copy 2 bytes from LRAM.\n *\n * The source data is assumed to be in little-endian order in LRAM\n * and is maintained in little-endian order when written to memory.\n */\nstatic void\nAscMemWordCopyPtrFromLram(PortAddr iop_base,\n\t\t\t  ushort s_addr, uchar *d_buffer, int words)\n{\n\tint i;\n\tushort word;\n\n\tAscSetChipLramAddr(iop_base, s_addr);\n\tfor (i = 0; i < 2 * words; i += 2) {\n\t\tword = inpw(iop_base + IOP_RAM_DATA);\n\t\td_buffer[i] = word & 0xff;\n\t\td_buffer[i + 1] = (word >> 8) & 0xff;\n\t}\n}\n\nstatic u32 AscMemSumLramWord(PortAddr iop_base, ushort s_addr, int words)\n{\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < words; i++, s_addr += 2) {\n\t\tsum += AscReadLramWord(iop_base, s_addr);\n\t}\n\treturn (sum);\n}\n\nstatic void AscInitLram(ASC_DVC_VAR *asc_dvc)\n{\n\tuchar i;\n\tushort s_addr;\n\tPortAddr iop_base;\n\n\tiop_base = asc_dvc->iop_base;\n\tAscMemWordSetLram(iop_base, ASC_QADR_BEG, 0,\n\t\t\t  (ushort)(((int)(asc_dvc->max_total_qng + 2 + 1) *\n\t\t\t\t    64) >> 1));\n\ti = ASC_MIN_ACTIVE_QNO;\n\ts_addr = ASC_QADR_BEG + ASC_QBLK_SIZE;\n\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),\n\t\t\t (uchar)(i + 1));\n\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),\n\t\t\t (uchar)(asc_dvc->max_total_qng));\n\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),\n\t\t\t (uchar)i);\n\ti++;\n\ts_addr += ASC_QBLK_SIZE;\n\tfor (; i < asc_dvc->max_total_qng; i++, s_addr += ASC_QBLK_SIZE) {\n\t\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),\n\t\t\t\t (uchar)(i + 1));\n\t\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),\n\t\t\t\t (uchar)(i - 1));\n\t\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),\n\t\t\t\t (uchar)i);\n\t}\n\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_FWD),\n\t\t\t (uchar)ASC_QLINK_END);\n\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_BWD),\n\t\t\t (uchar)(asc_dvc->max_total_qng - 1));\n\tAscWriteLramByte(iop_base, (ushort)(s_addr + ASC_SCSIQ_B_QNO),\n\t\t\t (uchar)asc_dvc->max_total_qng);\n\ti++;\n\ts_addr += ASC_QBLK_SIZE;\n\tfor (; i <= (uchar)(asc_dvc->max_total_qng + 3);\n\t     i++, s_addr += ASC_QBLK_SIZE) {\n\t\tAscWriteLramByte(iop_base,\n\t\t\t\t (ushort)(s_addr + (ushort)ASC_SCSIQ_B_FWD), i);\n\t\tAscWriteLramByte(iop_base,\n\t\t\t\t (ushort)(s_addr + (ushort)ASC_SCSIQ_B_BWD), i);\n\t\tAscWriteLramByte(iop_base,\n\t\t\t\t (ushort)(s_addr + (ushort)ASC_SCSIQ_B_QNO), i);\n\t}\n}\n\nstatic u32\nAscLoadMicroCode(PortAddr iop_base, ushort s_addr,\n\t\t const uchar *mcode_buf, ushort mcode_size)\n{\n\tu32 chksum;\n\tushort mcode_word_size;\n\tushort mcode_chksum;\n\n\t/* Write the microcode buffer starting at LRAM address 0. */\n\tmcode_word_size = (ushort)(mcode_size >> 1);\n\tAscMemWordSetLram(iop_base, s_addr, 0, mcode_word_size);\n\tAscMemWordCopyPtrToLram(iop_base, s_addr, mcode_buf, mcode_word_size);\n\n\tchksum = AscMemSumLramWord(iop_base, s_addr, mcode_word_size);\n\tASC_DBG(1, \"chksum 0x%lx\\n\", (ulong)chksum);\n\tmcode_chksum = (ushort)AscMemSumLramWord(iop_base,\n\t\t\t\t\t\t (ushort)ASC_CODE_SEC_BEG,\n\t\t\t\t\t\t (ushort)((mcode_size -\n\t\t\t\t\t\t\t   s_addr - (ushort)\n\t\t\t\t\t\t\t   ASC_CODE_SEC_BEG) /\n\t\t\t\t\t\t\t  2));\n\tASC_DBG(1, \"mcode_chksum 0x%lx\\n\", (ulong)mcode_chksum);\n\tAscWriteLramWord(iop_base, ASCV_MCODE_CHKSUM_W, mcode_chksum);\n\tAscWriteLramWord(iop_base, ASCV_MCODE_SIZE_W, mcode_size);\n\treturn chksum;\n}\n\nstatic void AscInitQLinkVar(ASC_DVC_VAR *asc_dvc)\n{\n\tPortAddr iop_base;\n\tint i;\n\tushort lram_addr;\n\n\tiop_base = asc_dvc->iop_base;\n\tAscPutRiscVarFreeQHead(iop_base, 1);\n\tAscPutRiscVarDoneQTail(iop_base, asc_dvc->max_total_qng);\n\tAscPutVarFreeQHead(iop_base, 1);\n\tAscPutVarDoneQTail(iop_base, asc_dvc->max_total_qng);\n\tAscWriteLramByte(iop_base, ASCV_BUSY_QHEAD_B,\n\t\t\t (uchar)((int)asc_dvc->max_total_qng + 1));\n\tAscWriteLramByte(iop_base, ASCV_DISC1_QHEAD_B,\n\t\t\t (uchar)((int)asc_dvc->max_total_qng + 2));\n\tAscWriteLramByte(iop_base, (ushort)ASCV_TOTAL_READY_Q_B,\n\t\t\t asc_dvc->max_total_qng);\n\tAscWriteLramWord(iop_base, ASCV_ASCDVC_ERR_CODE_W, 0);\n\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\tAscWriteLramByte(iop_base, ASCV_STOP_CODE_B, 0);\n\tAscWriteLramByte(iop_base, ASCV_SCSIBUSY_B, 0);\n\tAscWriteLramByte(iop_base, ASCV_WTM_FLAG_B, 0);\n\tAscPutQDoneInProgress(iop_base, 0);\n\tlram_addr = ASC_QADR_BEG;\n\tfor (i = 0; i < 32; i++, lram_addr += 2) {\n\t\tAscWriteLramWord(iop_base, lram_addr, 0);\n\t}\n}\n\nstatic int AscInitMicroCodeVar(ASC_DVC_VAR *asc_dvc)\n{\n\tint i;\n\tint warn_code;\n\tPortAddr iop_base;\n\t__le32 phy_addr;\n\t__le32 phy_size;\n\tstruct asc_board *board = asc_dvc_to_board(asc_dvc);\n\n\tiop_base = asc_dvc->iop_base;\n\twarn_code = 0;\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tAscPutMCodeInitSDTRAtID(iop_base, i,\n\t\t\t\t\tasc_dvc->cfg->sdtr_period_offset[i]);\n\t}\n\n\tAscInitQLinkVar(asc_dvc);\n\tAscWriteLramByte(iop_base, ASCV_DISC_ENABLE_B,\n\t\t\t asc_dvc->cfg->disc_enable);\n\tAscWriteLramByte(iop_base, ASCV_HOSTSCSI_ID_B,\n\t\t\t ASC_TID_TO_TARGET_ID(asc_dvc->cfg->chip_scsi_id));\n\n\t/* Ensure overrun buffer is aligned on an 8 byte boundary. */\n\tBUG_ON((unsigned long)asc_dvc->overrun_buf & 7);\n\tasc_dvc->overrun_dma = dma_map_single(board->dev, asc_dvc->overrun_buf,\n\t\t\t\t\tASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(board->dev, asc_dvc->overrun_dma)) {\n\t\twarn_code = -ENOMEM;\n\t\tgoto err_dma_map;\n\t}\n\tphy_addr = cpu_to_le32(asc_dvc->overrun_dma);\n\tAscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_PADDR_D,\n\t\t\t\t (uchar *)&phy_addr, 1);\n\tphy_size = cpu_to_le32(ASC_OVERRUN_BSIZE);\n\tAscMemDWordCopyPtrToLram(iop_base, ASCV_OVERRUN_BSIZE_D,\n\t\t\t\t (uchar *)&phy_size, 1);\n\n\tasc_dvc->cfg->mcode_date =\n\t    AscReadLramWord(iop_base, (ushort)ASCV_MC_DATE_W);\n\tasc_dvc->cfg->mcode_version =\n\t    AscReadLramWord(iop_base, (ushort)ASCV_MC_VER_W);\n\n\tAscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);\n\tif (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {\n\t\tasc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;\n\t\twarn_code = -EINVAL;\n\t\tgoto err_mcode_start;\n\t}\n\tif (AscStartChip(iop_base) != 1) {\n\t\tasc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;\n\t\twarn_code = -EIO;\n\t\tgoto err_mcode_start;\n\t}\n\n\treturn warn_code;\n\nerr_mcode_start:\n\tdma_unmap_single(board->dev, asc_dvc->overrun_dma,\n\t\t\t ASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);\nerr_dma_map:\n\tasc_dvc->overrun_dma = 0;\n\treturn warn_code;\n}\n\nstatic int AscInitAsc1000Driver(ASC_DVC_VAR *asc_dvc)\n{\n\tconst struct firmware *fw;\n\tconst char fwname[] = \"advansys/mcode.bin\";\n\tint err;\n\tunsigned long chksum;\n\tint warn_code;\n\tPortAddr iop_base;\n\n\tiop_base = asc_dvc->iop_base;\n\twarn_code = 0;\n\tif ((asc_dvc->dvc_cntl & ASC_CNTL_RESET_SCSI) &&\n\t    !(asc_dvc->init_state & ASC_INIT_RESET_SCSI_DONE)) {\n\t\tAscResetChipAndScsiBus(asc_dvc);\n\t\tmdelay(asc_dvc->scsi_reset_wait * 1000); /* XXX: msleep? */\n\t}\n\tasc_dvc->init_state |= ASC_INIT_STATE_BEG_LOAD_MC;\n\tif (asc_dvc->err_code != 0)\n\t\treturn ASC_ERROR;\n\tif (!AscFindSignature(asc_dvc->iop_base)) {\n\t\tasc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;\n\t\treturn warn_code;\n\t}\n\tAscDisableInterrupt(iop_base);\n\tAscInitLram(asc_dvc);\n\n\terr = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"Failed to load image \\\"%s\\\" err %d\\n\",\n\t\t       fwname, err);\n\t\tasc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;\n\t\treturn err;\n\t}\n\tif (fw->size < 4) {\n\t\tprintk(KERN_ERR \"Bogus length %zu in image \\\"%s\\\"\\n\",\n\t\t       fw->size, fwname);\n\t\trelease_firmware(fw);\n\t\tasc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;\n\t\treturn -EINVAL;\n\t}\n\tchksum = (fw->data[3] << 24) | (fw->data[2] << 16) |\n\t\t (fw->data[1] << 8) | fw->data[0];\n\tASC_DBG(1, \"_asc_mcode_chksum 0x%lx\\n\", (ulong)chksum);\n\tif (AscLoadMicroCode(iop_base, 0, &fw->data[4],\n\t\t\t     fw->size - 4) != chksum) {\n\t\tasc_dvc->err_code |= ASC_IERR_MCODE_CHKSUM;\n\t\trelease_firmware(fw);\n\t\treturn warn_code;\n\t}\n\trelease_firmware(fw);\n\twarn_code |= AscInitMicroCodeVar(asc_dvc);\n\tif (!asc_dvc->overrun_dma)\n\t\treturn warn_code;\n\tasc_dvc->init_state |= ASC_INIT_STATE_END_LOAD_MC;\n\tAscEnableInterrupt(iop_base);\n\treturn warn_code;\n}\n\n/*\n * Load the Microcode\n *\n * Write the microcode image to RISC memory starting at address 0.\n *\n * The microcode is stored compressed in the following format:\n *\n *  254 word (508 byte) table indexed by byte code followed\n *  by the following byte codes:\n *\n *    1-Byte Code:\n *      00: Emit word 0 in table.\n *      01: Emit word 1 in table.\n *      .\n *      FD: Emit word 253 in table.\n *\n *    Multi-Byte Code:\n *      FE WW WW: (3 byte code) Word to emit is the next word WW WW.\n *      FF BB WW WW: (4 byte code) Emit BB count times next word WW WW.\n *\n * Returns 0 or an error if the checksum doesn't match\n */\nstatic int AdvLoadMicrocode(AdvPortAddr iop_base, const unsigned char *buf,\n\t\t\t    int size, int memsize, int chksum)\n{\n\tint i, j, end, len = 0;\n\tu32 sum;\n\n\tAdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);\n\n\tfor (i = 253 * 2; i < size; i++) {\n\t\tif (buf[i] == 0xff) {\n\t\t\tunsigned short word = (buf[i + 3] << 8) | buf[i + 2];\n\t\t\tfor (j = 0; j < buf[i + 1]; j++) {\n\t\t\t\tAdvWriteWordAutoIncLram(iop_base, word);\n\t\t\t\tlen += 2;\n\t\t\t}\n\t\t\ti += 3;\n\t\t} else if (buf[i] == 0xfe) {\n\t\t\tunsigned short word = (buf[i + 2] << 8) | buf[i + 1];\n\t\t\tAdvWriteWordAutoIncLram(iop_base, word);\n\t\t\ti += 2;\n\t\t\tlen += 2;\n\t\t} else {\n\t\t\tunsigned int off = buf[i] * 2;\n\t\t\tunsigned short word = (buf[off + 1] << 8) | buf[off];\n\t\t\tAdvWriteWordAutoIncLram(iop_base, word);\n\t\t\tlen += 2;\n\t\t}\n\t}\n\n\tend = len;\n\n\twhile (len < memsize) {\n\t\tAdvWriteWordAutoIncLram(iop_base, 0);\n\t\tlen += 2;\n\t}\n\n\t/* Verify the microcode checksum. */\n\tsum = 0;\n\tAdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, 0);\n\n\tfor (len = 0; len < end; len += 2) {\n\t\tsum += AdvReadWordAutoIncLram(iop_base);\n\t}\n\n\tif (sum != chksum)\n\t\treturn ASC_IERR_MCODE_CHKSUM;\n\n\treturn 0;\n}\n\nstatic void AdvBuildCarrierFreelist(struct adv_dvc_var *adv_dvc)\n{\n\toff_t carr_offset = 0, next_offset;\n\tdma_addr_t carr_paddr;\n\tint carr_num = ADV_CARRIER_BUFSIZE / sizeof(ADV_CARR_T), i;\n\n\tfor (i = 0; i < carr_num; i++) {\n\t\tcarr_offset = i * sizeof(ADV_CARR_T);\n\t\t/* Get physical address of the carrier 'carrp'. */\n\t\tcarr_paddr = adv_dvc->carrier_addr + carr_offset;\n\n\t\tadv_dvc->carrier[i].carr_pa = cpu_to_le32(carr_paddr);\n\t\tadv_dvc->carrier[i].carr_va = cpu_to_le32(carr_offset);\n\t\tadv_dvc->carrier[i].areq_vpa = 0;\n\t\tnext_offset = carr_offset + sizeof(ADV_CARR_T);\n\t\tif (i == carr_num)\n\t\t\tnext_offset = ~0;\n\t\tadv_dvc->carrier[i].next_vpa = cpu_to_le32(next_offset);\n\t}\n\t/*\n\t * We cannot have a carrier with 'carr_va' of '0', as\n\t * a reference to this carrier would be interpreted as\n\t * list termination.\n\t * So start at carrier 1 with the freelist.\n\t */\n\tadv_dvc->carr_freelist = &adv_dvc->carrier[1];\n}\n\nstatic ADV_CARR_T *adv_get_carrier(struct adv_dvc_var *adv_dvc, u32 offset)\n{\n\tint index;\n\n\tBUG_ON(offset > ADV_CARRIER_BUFSIZE);\n\n\tindex = offset / sizeof(ADV_CARR_T);\n\treturn &adv_dvc->carrier[index];\n}\n\nstatic ADV_CARR_T *adv_get_next_carrier(struct adv_dvc_var *adv_dvc)\n{\n\tADV_CARR_T *carrp = adv_dvc->carr_freelist;\n\tu32 next_vpa = le32_to_cpu(carrp->next_vpa);\n\n\tif (next_vpa == 0 || next_vpa == ~0) {\n\t\tASC_DBG(1, \"invalid vpa offset 0x%x\\n\", next_vpa);\n\t\treturn NULL;\n\t}\n\n\tadv_dvc->carr_freelist = adv_get_carrier(adv_dvc, next_vpa);\n\t/*\n\t * insert stopper carrier to terminate list\n\t */\n\tcarrp->next_vpa = cpu_to_le32(ADV_CQ_STOPPER);\n\n\treturn carrp;\n}\n\n/*\n * 'offset' is the index in the request pointer array\n */\nstatic adv_req_t * adv_get_reqp(struct adv_dvc_var *adv_dvc, u32 offset)\n{\n\tstruct asc_board *boardp = adv_dvc->drv_ptr;\n\n\tBUG_ON(offset > adv_dvc->max_host_qng);\n\treturn &boardp->adv_reqp[offset];\n}\n\n/*\n * Send an idle command to the chip and wait for completion.\n *\n * Command completion is polled for once per microsecond.\n *\n * The function can be called from anywhere including an interrupt handler.\n * But the function is not re-entrant, so it uses the DvcEnter/LeaveCritical()\n * functions to prevent reentrancy.\n *\n * Return Values:\n *   ADV_TRUE - command completed successfully\n *   ADV_FALSE - command failed\n *   ADV_ERROR - command timed out\n */\nstatic int\nAdvSendIdleCmd(ADV_DVC_VAR *asc_dvc,\n\t       ushort idle_cmd, u32 idle_cmd_parameter)\n{\n\tint result, i, j;\n\tAdvPortAddr iop_base;\n\n\tiop_base = asc_dvc->iop_base;\n\n\t/*\n\t * Clear the idle command status which is set by the microcode\n\t * to a non-zero value to indicate when the command is completed.\n\t * The non-zero result is one of the IDLE_CMD_STATUS_* values\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS, (ushort)0);\n\n\t/*\n\t * Write the idle command value after the idle command parameter\n\t * has been written to avoid a race condition. If the order is not\n\t * followed, the microcode may process the idle command before the\n\t * parameters have been written to LRAM.\n\t */\n\tAdvWriteDWordLramNoSwap(iop_base, ASC_MC_IDLE_CMD_PARAMETER,\n\t\t\t\tcpu_to_le32(idle_cmd_parameter));\n\tAdvWriteWordLram(iop_base, ASC_MC_IDLE_CMD, idle_cmd);\n\n\t/*\n\t * Tickle the RISC to tell it to process the idle command.\n\t */\n\tAdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_B);\n\tif (asc_dvc->chip_type == ADV_CHIP_ASC3550) {\n\t\t/*\n\t\t * Clear the tickle value. In the ASC-3550 the RISC flag\n\t\t * command 'clr_tickle_b' does not work unless the host\n\t\t * value is cleared.\n\t\t */\n\t\tAdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_NOP);\n\t}\n\n\t/* Wait for up to 100 millisecond for the idle command to timeout. */\n\tfor (i = 0; i < SCSI_WAIT_100_MSEC; i++) {\n\t\t/* Poll once each microsecond for command completion. */\n\t\tfor (j = 0; j < SCSI_US_PER_MSEC; j++) {\n\t\t\tAdvReadWordLram(iop_base, ASC_MC_IDLE_CMD_STATUS,\n\t\t\t\t\tresult);\n\t\t\tif (result != 0)\n\t\t\t\treturn result;\n\t\t\tudelay(1);\n\t\t}\n\t}\n\n\tBUG();\t\t/* The idle command should never timeout. */\n\treturn ADV_ERROR;\n}\n\n/*\n * Reset SCSI Bus and purge all outstanding requests.\n *\n * Return Value:\n *      ADV_TRUE(1) -   All requests are purged and SCSI Bus is reset.\n *      ADV_FALSE(0) -  Microcode command failed.\n *      ADV_ERROR(-1) - Microcode command timed-out. Microcode or IC\n *                      may be hung which requires driver recovery.\n */\nstatic int AdvResetSB(ADV_DVC_VAR *asc_dvc)\n{\n\tint status;\n\n\t/*\n\t * Send the SCSI Bus Reset idle start idle command which asserts\n\t * the SCSI Bus Reset signal.\n\t */\n\tstatus = AdvSendIdleCmd(asc_dvc, (ushort)IDLE_CMD_SCSI_RESET_START, 0L);\n\tif (status != ADV_TRUE) {\n\t\treturn status;\n\t}\n\n\t/*\n\t * Delay for the specified SCSI Bus Reset hold time.\n\t *\n\t * The hold time delay is done on the host because the RISC has no\n\t * microsecond accurate timer.\n\t */\n\tudelay(ASC_SCSI_RESET_HOLD_TIME_US);\n\n\t/*\n\t * Send the SCSI Bus Reset end idle command which de-asserts\n\t * the SCSI Bus Reset signal and purges any pending requests.\n\t */\n\tstatus = AdvSendIdleCmd(asc_dvc, (ushort)IDLE_CMD_SCSI_RESET_END, 0L);\n\tif (status != ADV_TRUE) {\n\t\treturn status;\n\t}\n\n\tmdelay(asc_dvc->scsi_reset_wait * 1000);\t/* XXX: msleep? */\n\n\treturn status;\n}\n\n/*\n * Initialize the ASC-3550.\n *\n * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.\n *\n * For a non-fatal error return a warning code. If there are no warnings\n * then 0 is returned.\n *\n * Needed after initialization for error recovery.\n */\nstatic int AdvInitAsc3550Driver(ADV_DVC_VAR *asc_dvc)\n{\n\tconst struct firmware *fw;\n\tconst char fwname[] = \"advansys/3550.bin\";\n\tAdvPortAddr iop_base;\n\tushort warn_code;\n\tint begin_addr;\n\tint end_addr;\n\tushort code_sum;\n\tint word;\n\tint i;\n\tint err;\n\tunsigned long chksum;\n\tushort scsi_cfg1;\n\tuchar tid;\n\tushort bios_mem[ASC_MC_BIOSLEN / 2];\t/* BIOS RISC Memory 0x40-0x8F. */\n\tushort wdtr_able = 0, sdtr_able, tagqng_able;\n\tuchar max_cmd[ADV_MAX_TID + 1];\n\n\t/* If there is already an error, don't continue. */\n\tif (asc_dvc->err_code != 0)\n\t\treturn ADV_ERROR;\n\n\t/*\n\t * The caller must set 'chip_type' to ADV_CHIP_ASC3550.\n\t */\n\tif (asc_dvc->chip_type != ADV_CHIP_ASC3550) {\n\t\tasc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;\n\t\treturn ADV_ERROR;\n\t}\n\n\twarn_code = 0;\n\tiop_base = asc_dvc->iop_base;\n\n\t/*\n\t * Save the RISC memory BIOS region before writing the microcode.\n\t * The BIOS may already be loaded and using its RISC LRAM region\n\t * so its region must be saved and restored.\n\t *\n\t * Note: This code makes the assumption, which is currently true,\n\t * that a chip reset does not clear RISC LRAM.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\n\t\tAdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] == 0x55AA) {\n\t\tushort bios_version, major, minor;\n\n\t\tbios_version =\n\t\t    bios_mem[(ASC_MC_BIOS_VERSION - ASC_MC_BIOSMEM) / 2];\n\t\tmajor = (bios_version >> 12) & 0xF;\n\t\tminor = (bios_version >> 8) & 0xF;\n\t\tif (major < 3 || (major == 3 && minor == 1)) {\n\t\t\t/* BIOS 3.1 and earlier location of 'wdtr_able' variable. */\n\t\t\tAdvReadWordLram(iop_base, 0x120, wdtr_able);\n\t\t} else {\n\t\t\tAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t}\n\t}\n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\tAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\n\t\tAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\tmax_cmd[tid]);\n\t}\n\n\terr = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"Failed to load image \\\"%s\\\" err %d\\n\",\n\t\t       fwname, err);\n\t\tasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\n\t\treturn err;\n\t}\n\tif (fw->size < 4) {\n\t\tprintk(KERN_ERR \"Bogus length %zu in image \\\"%s\\\"\\n\",\n\t\t       fw->size, fwname);\n\t\trelease_firmware(fw);\n\t\tasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\n\t\treturn -EINVAL;\n\t}\n\tchksum = (fw->data[3] << 24) | (fw->data[2] << 16) |\n\t\t (fw->data[1] << 8) | fw->data[0];\n\tasc_dvc->err_code = AdvLoadMicrocode(iop_base, &fw->data[4],\n\t\t\t\t\t     fw->size - 4, ADV_3550_MEMSIZE,\n\t\t\t\t\t     chksum);\n\trelease_firmware(fw);\n\tif (asc_dvc->err_code)\n\t\treturn ADV_ERROR;\n\n\t/*\n\t * Restore the RISC memory BIOS region.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\n\t\tAdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\t bios_mem[i]);\n\t}\n\n\t/*\n\t * Calculate and write the microcode code checksum to the microcode\n\t * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).\n\t */\n\tAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tAdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tAdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += AdvReadWordAutoIncLram(iop_base);\n\t}\n\tAdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t/*\n\t * Read and save microcode version and date.\n\t */\n\tAdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,\n\t\t\tasc_dvc->cfg->mcode_date);\n\tAdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,\n\t\t\tasc_dvc->cfg->mcode_version);\n\n\t/*\n\t * Set the chip type to indicate the ASC3550.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC3550);\n\n\t/*\n\t * If the PCI Configuration Command Register \"Parity Error Response\n\t * Control\" Bit was clear (0), then set the microcode variable\n\t * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode\n\t * to ignore DMA parity errors.\n\t */\n\tif (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\tAdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tAdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t/*\n\t * For ASC-3550, setting the START_CTL_EMFU [3:2] bits sets a FIFO\n\t * threshold of 128 bytes. This register is only accessible to the host.\n\t */\n\tAdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,\n\t\t\t     START_CTL_EMFU | READ_CMD_MRM);\n\n\t/*\n\t * Microcode operating variables for WDTR, SDTR, and command tag\n\t * queuing will be set in slave_configure() based on what a\n\t * device reports it is capable of in Inquiry byte 7.\n\t *\n\t * If SCSI Bus Resets have been disabled, then directly set\n\t * SDTR and WDTR from the EEPROM configuration. This will allow\n\t * the BIOS and warm boot to work without a SCSI bus hang on\n\t * the Inquiry caused by host and target mismatched DTR values.\n\t * Without the SCSI Bus Reset, before an Inquiry a device can't\n\t * be assumed to be in Asynchronous, Narrow mode.\n\t */\n\tif ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,\n\t\t\t\t asc_dvc->wdtr_able);\n\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,\n\t\t\t\t asc_dvc->sdtr_able);\n\t}\n\n\t/*\n\t * Set microcode operating variables for SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 based on the ULTRA EEPROM per TID\n\t * bitmask. These values determine the maximum SDTR speed negotiated\n\t * with a device.\n\t *\n\t * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them\n\t * without determining here whether the device supports SDTR.\n\t *\n\t * 4-bit speed  SDTR speed name\n\t * ===========  ===============\n\t * 0000b (0x0)  SDTR disabled\n\t * 0001b (0x1)  5 Mhz\n\t * 0010b (0x2)  10 Mhz\n\t * 0011b (0x3)  20 Mhz (Ultra)\n\t * 0100b (0x4)  40 Mhz (LVD/Ultra2)\n\t * 0101b (0x5)  80 Mhz (LVD2/Ultra3)\n\t * 0110b (0x6)  Undefined\n\t * .\n\t * 1111b (0xF)  Undefined\n\t */\n\tword = 0;\n\tfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\n\t\tif (ADV_TID_TO_TIDMASK(tid) & asc_dvc->ultra_able) {\n\t\t\t/* Set Ultra speed for TID 'tid'. */\n\t\t\tword |= (0x3 << (4 * (tid % 4)));\n\t\t} else {\n\t\t\t/* Set Fast speed for TID 'tid'. */\n\t\t\tword |= (0x2 << (4 * (tid % 4)));\n\t\t}\n\t\tif (tid == 3) {\t/* Check if done with sdtr_speed1. */\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, word);\n\t\t\tword = 0;\n\t\t} else if (tid == 7) {\t/* Check if done with sdtr_speed2. */\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, word);\n\t\t\tword = 0;\n\t\t} else if (tid == 11) {\t/* Check if done with sdtr_speed3. */\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, word);\n\t\t\tword = 0;\n\t\t} else if (tid == 15) {\t/* Check if done with sdtr_speed4. */\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, word);\n\t\t\t/* End of loop. */\n\t\t}\n\t}\n\n\t/*\n\t * Set microcode operating variable for the disconnect per TID bitmask.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,\n\t\t\t asc_dvc->cfg->disc_enable);\n\n\t/*\n\t * Set SCSI_CFG0 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG0 register using this value\n\t * after it is started below.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\t\t PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |\n\t\t\t asc_dvc->chip_scsi_id);\n\n\t/*\n\t * Determine SCSI_CFG1 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\n\t/* Read current SCSI_CFG1 Register value. */\n\tscsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);\n\n\t/*\n\t * If all three connectors are in use, return an error.\n\t */\n\tif ((scsi_cfg1 & CABLE_ILLEGAL_A) == 0 ||\n\t    (scsi_cfg1 & CABLE_ILLEGAL_B) == 0) {\n\t\tasc_dvc->err_code |= ASC_IERR_ILLEGAL_CONNECTION;\n\t\treturn ADV_ERROR;\n\t}\n\n\t/*\n\t * If the internal narrow cable is reversed all of the SCSI_CTRL\n\t * register signals will be set. Check for and return an error if\n\t * this condition is found.\n\t */\n\tif ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {\n\t\tasc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;\n\t\treturn ADV_ERROR;\n\t}\n\n\t/*\n\t * If this is a differential board and a single-ended device\n\t * is attached to one of the connectors, return an error.\n\t */\n\tif ((scsi_cfg1 & DIFF_MODE) && (scsi_cfg1 & DIFF_SENSE) == 0) {\n\t\tasc_dvc->err_code |= ASC_IERR_SINGLE_END_DEVICE;\n\t\treturn ADV_ERROR;\n\t}\n\n\t/*\n\t * If automatic termination control is enabled, then set the\n\t * termination value based on a table listed in a_condor.h.\n\t *\n\t * If manual termination was specified with an EEPROM setting\n\t * then 'termination' was set-up in AdvInitFrom3550EEPROM() and\n\t * is ready to be 'ored' into SCSI_CFG1.\n\t */\n\tif (asc_dvc->cfg->termination == 0) {\n\t\t/*\n\t\t * The software always controls termination by setting TERM_CTL_SEL.\n\t\t * If TERM_CTL_SEL were set to 0, the hardware would set termination.\n\t\t */\n\t\tasc_dvc->cfg->termination |= TERM_CTL_SEL;\n\n\t\tswitch (scsi_cfg1 & CABLE_DETECT) {\n\t\t\t/* TERM_CTL_H: on, TERM_CTL_L: on */\n\t\tcase 0x3:\n\t\tcase 0x7:\n\t\tcase 0xB:\n\t\tcase 0xD:\n\t\tcase 0xE:\n\t\tcase 0xF:\n\t\t\tasc_dvc->cfg->termination |= (TERM_CTL_H | TERM_CTL_L);\n\t\t\tbreak;\n\n\t\t\t/* TERM_CTL_H: on, TERM_CTL_L: off */\n\t\tcase 0x1:\n\t\tcase 0x5:\n\t\tcase 0x9:\n\t\tcase 0xA:\n\t\tcase 0xC:\n\t\t\tasc_dvc->cfg->termination |= TERM_CTL_H;\n\t\t\tbreak;\n\n\t\t\t/* TERM_CTL_H: off, TERM_CTL_L: off */\n\t\tcase 0x2:\n\t\tcase 0x6:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Clear any set TERM_CTL_H and TERM_CTL_L bits.\n\t */\n\tscsi_cfg1 &= ~TERM_CTL;\n\n\t/*\n\t * Invert the TERM_CTL_H and TERM_CTL_L bits and then\n\t * set 'scsi_cfg1'. The TERM_POL bit does not need to be\n\t * referenced, because the hardware internally inverts\n\t * the Termination High and Low bits if TERM_POL is set.\n\t */\n\tscsi_cfg1 |= (TERM_CTL_SEL | (~asc_dvc->cfg->termination & TERM_CTL));\n\n\t/*\n\t * Set SCSI_CFG1 Microcode Default Value\n\t *\n\t * Set filter value and possibly modified termination control\n\t * bits in the Microcode SCSI_CFG1 Register Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1,\n\t\t\t FLTR_DISABLE | scsi_cfg1);\n\n\t/*\n\t * Set MEM_CFG Microcode Default Value\n\t *\n\t * The microcode will set the MEM_CFG register using this value\n\t * after it is started below.\n\t *\n\t * MEM_CFG may be accessed as a word or byte, but only bits 0-7\n\t * are defined.\n\t *\n\t * ASC-3550 has 8KB internal memory.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,\n\t\t\t BIOS_EN | RAM_SZ_8KB);\n\n\t/*\n\t * Set SEL_MASK Microcode Default Value\n\t *\n\t * The microcode will set the SEL_MASK register using this value\n\t * after it is started below.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,\n\t\t\t ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));\n\n\tAdvBuildCarrierFreelist(asc_dvc);\n\n\t/*\n\t * Set-up the Host->RISC Initiator Command Queue (ICQ).\n\t */\n\n\tasc_dvc->icq_sp = adv_get_next_carrier(asc_dvc);\n\tif (!asc_dvc->icq_sp) {\n\t\tasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\n\t\treturn ADV_ERROR;\n\t}\n\n\t/*\n\t * Set RISC ICQ physical address start value.\n\t */\n\tAdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);\n\n\t/*\n\t * Set-up the RISC->Host Initiator Response Queue (IRQ).\n\t */\n\tasc_dvc->irq_sp = adv_get_next_carrier(asc_dvc);\n\tif (!asc_dvc->irq_sp) {\n\t\tasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\n\t\treturn ADV_ERROR;\n\t}\n\n\t/*\n\t * Set RISC IRQ physical address start value.\n\t */\n\tAdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);\n\tasc_dvc->carr_pending_cnt = 0;\n\n\tAdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,\n\t\t\t     (ADV_INTR_ENABLE_HOST_INTR |\n\t\t\t      ADV_INTR_ENABLE_GLOBAL_INTR));\n\n\tAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);\n\tAdvWriteWordRegister(iop_base, IOPW_PC, word);\n\n\t/* finally, finally, gentlemen, start your engine */\n\tAdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);\n\n\t/*\n\t * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus\n\t * Resets should be performed. The RISC has to be running\n\t * to issue a SCSI Bus Reset.\n\t */\n\tif (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {\n\t\t/*\n\t\t * If the BIOS Signature is present in memory, restore the\n\t\t * BIOS Handshake Configuration Table and do not perform\n\t\t * a SCSI Bus Reset.\n\t\t */\n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==\n\t\t    0x55AA) {\n\t\t\t/*\n\t\t\t * Restore per TID negotiated values.\n\t\t\t */\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\t tagqng_able);\n\t\t\tfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\n\t\t\t\tAdvWriteByteLram(iop_base,\n\t\t\t\t\t\t ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\t\t max_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetSB(asc_dvc) != ADV_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn warn_code;\n}\n\n/*\n * Initialize the ASC-38C0800.\n *\n * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.\n *\n * For a non-fatal error return a warning code. If there are no warnings\n * then 0 is returned.\n *\n * Needed after initialization for error recovery.\n */\nstatic int AdvInitAsc38C0800Driver(ADV_DVC_VAR *asc_dvc)\n{\n\tconst struct firmware *fw;\n\tconst char fwname[] = \"advansys/38C0800.bin\";\n\tAdvPortAddr iop_base;\n\tushort warn_code;\n\tint begin_addr;\n\tint end_addr;\n\tushort code_sum;\n\tint word;\n\tint i;\n\tint err;\n\tunsigned long chksum;\n\tushort scsi_cfg1;\n\tuchar byte;\n\tuchar tid;\n\tushort bios_mem[ASC_MC_BIOSLEN / 2];\t/* BIOS RISC Memory 0x40-0x8F. */\n\tushort wdtr_able, sdtr_able, tagqng_able;\n\tuchar max_cmd[ADV_MAX_TID + 1];\n\n\t/* If there is already an error, don't continue. */\n\tif (asc_dvc->err_code != 0)\n\t\treturn ADV_ERROR;\n\n\t/*\n\t * The caller must set 'chip_type' to ADV_CHIP_ASC38C0800.\n\t */\n\tif (asc_dvc->chip_type != ADV_CHIP_ASC38C0800) {\n\t\tasc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;\n\t\treturn ADV_ERROR;\n\t}\n\n\twarn_code = 0;\n\tiop_base = asc_dvc->iop_base;\n\n\t/*\n\t * Save the RISC memory BIOS region before writing the microcode.\n\t * The BIOS may already be loaded and using its RISC LRAM region\n\t * so its region must be saved and restored.\n\t *\n\t * Note: This code makes the assumption, which is currently true,\n\t * that a chip reset does not clear RISC LRAM.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\n\t\tAdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\tAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\n\t\tAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * RAM BIST (RAM Built-In Self Test)\n\t *\n\t * Address : I/O base + offset 0x38h register (byte).\n\t * Function: Bit 7-6(RW) : RAM mode\n\t *                          Normal Mode   : 0x00\n\t *                          Pre-test Mode : 0x40\n\t *                          RAM Test Mode : 0x80\n\t *           Bit 5       : unused\n\t *           Bit 4(RO)   : Done bit\n\t *           Bit 3-0(RO) : Status\n\t *                          Host Error    : 0x08\n\t *                          Int_RAM Error : 0x04\n\t *                          RISC Error    : 0x02\n\t *                          SCSI Error    : 0x01\n\t *                          No Error      : 0x00\n\t *\n\t * Note: RAM BIST code should be put right here, before loading the\n\t * microcode and after saving the RISC memory BIOS region.\n\t */\n\n\t/*\n\t * LRAM Pre-test\n\t *\n\t * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.\n\t * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return\n\t * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset\n\t * to NORMAL_MODE, return an error too.\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);\n\t\tmdelay(10);\t/* Wait for 10ms before reading back. */\n\t\tbyte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);\n\t\tif ((byte & RAM_TEST_DONE) == 0\n\t\t    || (byte & 0x0F) != PRE_TEST_VALUE) {\n\t\t\tasc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;\n\t\t\treturn ADV_ERROR;\n\t\t}\n\n\t\tAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);\n\t\tmdelay(10);\t/* Wait for 10ms before reading back. */\n\t\tif (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)\n\t\t    != NORMAL_VALUE) {\n\t\t\tasc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;\n\t\t\treturn ADV_ERROR;\n\t\t}\n\t}\n\n\t/*\n\t * LRAM Test - It takes about 1.5 ms to run through the test.\n\t *\n\t * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.\n\t * If Done bit not set or Status not 0, save register byte, set the\n\t * err_code, and return an error.\n\t */\n\tAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);\n\tmdelay(10);\t/* Wait for 10ms before checking status. */\n\n\tbyte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);\n\tif ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {\n\t\t/* Get here if Done bit not set or Status not 0. */\n\t\tasc_dvc->bist_err_code = byte;\t/* for BIOS display message */\n\t\tasc_dvc->err_code = ASC_IERR_BIST_RAM_TEST;\n\t\treturn ADV_ERROR;\n\t}\n\n\t/* We need to reset back to normal mode after LRAM test passes. */\n\tAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);\n\n\terr = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"Failed to load image \\\"%s\\\" err %d\\n\",\n\t\t       fwname, err);\n\t\tasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\n\t\treturn err;\n\t}\n\tif (fw->size < 4) {\n\t\tprintk(KERN_ERR \"Bogus length %zu in image \\\"%s\\\"\\n\",\n\t\t       fw->size, fwname);\n\t\trelease_firmware(fw);\n\t\tasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\n\t\treturn -EINVAL;\n\t}\n\tchksum = (fw->data[3] << 24) | (fw->data[2] << 16) |\n\t\t (fw->data[1] << 8) | fw->data[0];\n\tasc_dvc->err_code = AdvLoadMicrocode(iop_base, &fw->data[4],\n\t\t\t\t\t     fw->size - 4, ADV_38C0800_MEMSIZE,\n\t\t\t\t\t     chksum);\n\trelease_firmware(fw);\n\tif (asc_dvc->err_code)\n\t\treturn ADV_ERROR;\n\n\t/*\n\t * Restore the RISC memory BIOS region.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\n\t\tAdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\t bios_mem[i]);\n\t}\n\n\t/*\n\t * Calculate and write the microcode code checksum to the microcode\n\t * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).\n\t */\n\tAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tAdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tAdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += AdvReadWordAutoIncLram(iop_base);\n\t}\n\tAdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t/*\n\t * Read microcode version and date.\n\t */\n\tAdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,\n\t\t\tasc_dvc->cfg->mcode_date);\n\tAdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,\n\t\t\tasc_dvc->cfg->mcode_version);\n\n\t/*\n\t * Set the chip type to indicate the ASC38C0800.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C0800);\n\n\t/*\n\t * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.\n\t * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current\n\t * cable detection and then we are able to read C_DET[3:0].\n\t *\n\t * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1\n\t * Microcode Default Value' section below.\n\t */\n\tscsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);\n\tAdvWriteWordRegister(iop_base, IOPW_SCSI_CFG1,\n\t\t\t     scsi_cfg1 | DIS_TERM_DRV);\n\n\t/*\n\t * If the PCI Configuration Command Register \"Parity Error Response\n\t * Control\" Bit was clear (0), then set the microcode variable\n\t * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode\n\t * to ignore DMA parity errors.\n\t */\n\tif (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\tAdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tAdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t/*\n\t * For ASC-38C0800, set FIFO_THRESH_80B [6:4] bits and START_CTL_TH [3:2]\n\t * bits for the default FIFO threshold.\n\t *\n\t * Note: ASC-38C0800 FIFO threshold has been changed to 256 bytes.\n\t *\n\t * For DMA Errata #4 set the BC_THRESH_ENB bit.\n\t */\n\tAdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,\n\t\t\t     BC_THRESH_ENB | FIFO_THRESH_80B | START_CTL_TH |\n\t\t\t     READ_CMD_MRM);\n\n\t/*\n\t * Microcode operating variables for WDTR, SDTR, and command tag\n\t * queuing will be set in slave_configure() based on what a\n\t * device reports it is capable of in Inquiry byte 7.\n\t *\n\t * If SCSI Bus Resets have been disabled, then directly set\n\t * SDTR and WDTR from the EEPROM configuration. This will allow\n\t * the BIOS and warm boot to work without a SCSI bus hang on\n\t * the Inquiry caused by host and target mismatched DTR values.\n\t * Without the SCSI Bus Reset, before an Inquiry a device can't\n\t * be assumed to be in Asynchronous, Narrow mode.\n\t */\n\tif ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,\n\t\t\t\t asc_dvc->wdtr_able);\n\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,\n\t\t\t\t asc_dvc->sdtr_able);\n\t}\n\n\t/*\n\t * Set microcode operating variables for DISC and SDTR_SPEED1,\n\t * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM\n\t * configuration values.\n\t *\n\t * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them\n\t * without determining here whether the device supports SDTR.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,\n\t\t\t asc_dvc->cfg->disc_enable);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, asc_dvc->sdtr_speed1);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, asc_dvc->sdtr_speed2);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, asc_dvc->sdtr_speed3);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, asc_dvc->sdtr_speed4);\n\n\t/*\n\t * Set SCSI_CFG0 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG0 register using this value\n\t * after it is started below.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\t\t PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |\n\t\t\t asc_dvc->chip_scsi_id);\n\n\t/*\n\t * Determine SCSI_CFG1 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\n\t/* Read current SCSI_CFG1 Register value. */\n\tscsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);\n\n\t/*\n\t * If the internal narrow cable is reversed all of the SCSI_CTRL\n\t * register signals will be set. Check for and return an error if\n\t * this condition is found.\n\t */\n\tif ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {\n\t\tasc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;\n\t\treturn ADV_ERROR;\n\t}\n\n\t/*\n\t * All kind of combinations of devices attached to one of four\n\t * connectors are acceptable except HVD device attached. For example,\n\t * LVD device can be attached to SE connector while SE device attached\n\t * to LVD connector.  If LVD device attached to SE connector, it only\n\t * runs up to Ultra speed.\n\t *\n\t * If an HVD device is attached to one of LVD connectors, return an\n\t * error.  However, there is no way to detect HVD device attached to\n\t * SE connectors.\n\t */\n\tif (scsi_cfg1 & HVD) {\n\t\tasc_dvc->err_code = ASC_IERR_HVD_DEVICE;\n\t\treturn ADV_ERROR;\n\t}\n\n\t/*\n\t * If either SE or LVD automatic termination control is enabled, then\n\t * set the termination value based on a table listed in a_condor.h.\n\t *\n\t * If manual termination was specified with an EEPROM setting then\n\t * 'termination' was set-up in AdvInitFrom38C0800EEPROM() and is ready\n\t * to be 'ored' into SCSI_CFG1.\n\t */\n\tif ((asc_dvc->cfg->termination & TERM_SE) == 0) {\n\t\t/* SE automatic termination control is enabled. */\n\t\tswitch (scsi_cfg1 & C_DET_SE) {\n\t\t\t/* TERM_SE_HI: on, TERM_SE_LO: on */\n\t\tcase 0x1:\n\t\tcase 0x2:\n\t\tcase 0x3:\n\t\t\tasc_dvc->cfg->termination |= TERM_SE;\n\t\t\tbreak;\n\n\t\t\t/* TERM_SE_HI: on, TERM_SE_LO: off */\n\t\tcase 0x0:\n\t\t\tasc_dvc->cfg->termination |= TERM_SE_HI;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((asc_dvc->cfg->termination & TERM_LVD) == 0) {\n\t\t/* LVD automatic termination control is enabled. */\n\t\tswitch (scsi_cfg1 & C_DET_LVD) {\n\t\t\t/* TERM_LVD_HI: on, TERM_LVD_LO: on */\n\t\tcase 0x4:\n\t\tcase 0x8:\n\t\tcase 0xC:\n\t\t\tasc_dvc->cfg->termination |= TERM_LVD;\n\t\t\tbreak;\n\n\t\t\t/* TERM_LVD_HI: off, TERM_LVD_LO: off */\n\t\tcase 0x0:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Clear any set TERM_SE and TERM_LVD bits.\n\t */\n\tscsi_cfg1 &= (~TERM_SE & ~TERM_LVD);\n\n\t/*\n\t * Invert the TERM_SE and TERM_LVD bits and then set 'scsi_cfg1'.\n\t */\n\tscsi_cfg1 |= (~asc_dvc->cfg->termination & 0xF0);\n\n\t/*\n\t * Clear BIG_ENDIAN, DIS_TERM_DRV, Terminator Polarity and HVD/LVD/SE\n\t * bits and set possibly modified termination control bits in the\n\t * Microcode SCSI_CFG1 Register Value.\n\t */\n\tscsi_cfg1 &= (~BIG_ENDIAN & ~DIS_TERM_DRV & ~TERM_POL & ~HVD_LVD_SE);\n\n\t/*\n\t * Set SCSI_CFG1 Microcode Default Value\n\t *\n\t * Set possibly modified termination control and reset DIS_TERM_DRV\n\t * bits in the Microcode SCSI_CFG1 Register Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);\n\n\t/*\n\t * Set MEM_CFG Microcode Default Value\n\t *\n\t * The microcode will set the MEM_CFG register using this value\n\t * after it is started below.\n\t *\n\t * MEM_CFG may be accessed as a word or byte, but only bits 0-7\n\t * are defined.\n\t *\n\t * ASC-38C0800 has 16KB internal memory.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,\n\t\t\t BIOS_EN | RAM_SZ_16KB);\n\n\t/*\n\t * Set SEL_MASK Microcode Default Value\n\t *\n\t * The microcode will set the SEL_MASK register using this value\n\t * after it is started below.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,\n\t\t\t ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));\n\n\tAdvBuildCarrierFreelist(asc_dvc);\n\n\t/*\n\t * Set-up the Host->RISC Initiator Command Queue (ICQ).\n\t */\n\n\tasc_dvc->icq_sp = adv_get_next_carrier(asc_dvc);\n\tif (!asc_dvc->icq_sp) {\n\t\tASC_DBG(0, \"Failed to get ICQ carrier\\n\");\n\t\tasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\n\t\treturn ADV_ERROR;\n\t}\n\n\t/*\n\t * Set RISC ICQ physical address start value.\n\t * carr_pa is LE, must be native before write\n\t */\n\tAdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);\n\n\t/*\n\t * Set-up the RISC->Host Initiator Response Queue (IRQ).\n\t */\n\tasc_dvc->irq_sp = adv_get_next_carrier(asc_dvc);\n\tif (!asc_dvc->irq_sp) {\n\t\tASC_DBG(0, \"Failed to get IRQ carrier\\n\");\n\t\tasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\n\t\treturn ADV_ERROR;\n\t}\n\n\t/*\n\t * Set RISC IRQ physical address start value.\n\t *\n\t * carr_pa is LE, must be native before write *\n\t */\n\tAdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);\n\tasc_dvc->carr_pending_cnt = 0;\n\n\tAdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,\n\t\t\t     (ADV_INTR_ENABLE_HOST_INTR |\n\t\t\t      ADV_INTR_ENABLE_GLOBAL_INTR));\n\n\tAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);\n\tAdvWriteWordRegister(iop_base, IOPW_PC, word);\n\n\t/* finally, finally, gentlemen, start your engine */\n\tAdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);\n\n\t/*\n\t * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus\n\t * Resets should be performed. The RISC has to be running\n\t * to issue a SCSI Bus Reset.\n\t */\n\tif (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {\n\t\t/*\n\t\t * If the BIOS Signature is present in memory, restore the\n\t\t * BIOS Handshake Configuration Table and do not perform\n\t\t * a SCSI Bus Reset.\n\t\t */\n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==\n\t\t    0x55AA) {\n\t\t\t/*\n\t\t\t * Restore per TID negotiated values.\n\t\t\t */\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\t tagqng_able);\n\t\t\tfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\n\t\t\t\tAdvWriteByteLram(iop_base,\n\t\t\t\t\t\t ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\t\t max_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetSB(asc_dvc) != ADV_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn warn_code;\n}\n\n/*\n * Initialize the ASC-38C1600.\n *\n * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.\n *\n * For a non-fatal error return a warning code. If there are no warnings\n * then 0 is returned.\n *\n * Needed after initialization for error recovery.\n */\nstatic int AdvInitAsc38C1600Driver(ADV_DVC_VAR *asc_dvc)\n{\n\tconst struct firmware *fw;\n\tconst char fwname[] = \"advansys/38C1600.bin\";\n\tAdvPortAddr iop_base;\n\tushort warn_code;\n\tint begin_addr;\n\tint end_addr;\n\tushort code_sum;\n\tlong word;\n\tint i;\n\tint err;\n\tunsigned long chksum;\n\tushort scsi_cfg1;\n\tuchar byte;\n\tuchar tid;\n\tushort bios_mem[ASC_MC_BIOSLEN / 2];\t/* BIOS RISC Memory 0x40-0x8F. */\n\tushort wdtr_able, sdtr_able, ppr_able, tagqng_able;\n\tuchar max_cmd[ASC_MAX_TID + 1];\n\n\t/* If there is already an error, don't continue. */\n\tif (asc_dvc->err_code != 0) {\n\t\treturn ADV_ERROR;\n\t}\n\n\t/*\n\t * The caller must set 'chip_type' to ADV_CHIP_ASC38C1600.\n\t */\n\tif (asc_dvc->chip_type != ADV_CHIP_ASC38C1600) {\n\t\tasc_dvc->err_code = ASC_IERR_BAD_CHIPTYPE;\n\t\treturn ADV_ERROR;\n\t}\n\n\twarn_code = 0;\n\tiop_base = asc_dvc->iop_base;\n\n\t/*\n\t * Save the RISC memory BIOS region before writing the microcode.\n\t * The BIOS may already be loaded and using its RISC LRAM region\n\t * so its region must be saved and restored.\n\t *\n\t * Note: This code makes the assumption, which is currently true,\n\t * that a chip reset does not clear RISC LRAM.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\n\t\tAdvReadWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\tbios_mem[i]);\n\t}\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\tAdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);\n\tAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ASC_MAX_TID; tid++) {\n\t\tAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * RAM BIST (Built-In Self Test)\n\t *\n\t * Address : I/O base + offset 0x38h register (byte).\n\t * Function: Bit 7-6(RW) : RAM mode\n\t *                          Normal Mode   : 0x00\n\t *                          Pre-test Mode : 0x40\n\t *                          RAM Test Mode : 0x80\n\t *           Bit 5       : unused\n\t *           Bit 4(RO)   : Done bit\n\t *           Bit 3-0(RO) : Status\n\t *                          Host Error    : 0x08\n\t *                          Int_RAM Error : 0x04\n\t *                          RISC Error    : 0x02\n\t *                          SCSI Error    : 0x01\n\t *                          No Error      : 0x00\n\t *\n\t * Note: RAM BIST code should be put right here, before loading the\n\t * microcode and after saving the RISC memory BIOS region.\n\t */\n\n\t/*\n\t * LRAM Pre-test\n\t *\n\t * Write PRE_TEST_MODE (0x40) to register and wait for 10 milliseconds.\n\t * If Done bit not set or low nibble not PRE_TEST_VALUE (0x05), return\n\t * an error. Reset to NORMAL_MODE (0x00) and do again. If cannot reset\n\t * to NORMAL_MODE, return an error too.\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, PRE_TEST_MODE);\n\t\tmdelay(10);\t/* Wait for 10ms before reading back. */\n\t\tbyte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);\n\t\tif ((byte & RAM_TEST_DONE) == 0\n\t\t    || (byte & 0x0F) != PRE_TEST_VALUE) {\n\t\t\tasc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;\n\t\t\treturn ADV_ERROR;\n\t\t}\n\n\t\tAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);\n\t\tmdelay(10);\t/* Wait for 10ms before reading back. */\n\t\tif (AdvReadByteRegister(iop_base, IOPB_RAM_BIST)\n\t\t    != NORMAL_VALUE) {\n\t\t\tasc_dvc->err_code = ASC_IERR_BIST_PRE_TEST;\n\t\t\treturn ADV_ERROR;\n\t\t}\n\t}\n\n\t/*\n\t * LRAM Test - It takes about 1.5 ms to run through the test.\n\t *\n\t * Write RAM_TEST_MODE (0x80) to register and wait for 10 milliseconds.\n\t * If Done bit not set or Status not 0, save register byte, set the\n\t * err_code, and return an error.\n\t */\n\tAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, RAM_TEST_MODE);\n\tmdelay(10);\t/* Wait for 10ms before checking status. */\n\n\tbyte = AdvReadByteRegister(iop_base, IOPB_RAM_BIST);\n\tif ((byte & RAM_TEST_DONE) == 0 || (byte & RAM_TEST_STATUS) != 0) {\n\t\t/* Get here if Done bit not set or Status not 0. */\n\t\tasc_dvc->bist_err_code = byte;\t/* for BIOS display message */\n\t\tasc_dvc->err_code = ASC_IERR_BIST_RAM_TEST;\n\t\treturn ADV_ERROR;\n\t}\n\n\t/* We need to reset back to normal mode after LRAM test passes. */\n\tAdvWriteByteRegister(iop_base, IOPB_RAM_BIST, NORMAL_MODE);\n\n\terr = request_firmware(&fw, fwname, asc_dvc->drv_ptr->dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"Failed to load image \\\"%s\\\" err %d\\n\",\n\t\t       fwname, err);\n\t\tasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\n\t\treturn err;\n\t}\n\tif (fw->size < 4) {\n\t\tprintk(KERN_ERR \"Bogus length %zu in image \\\"%s\\\"\\n\",\n\t\t       fw->size, fwname);\n\t\trelease_firmware(fw);\n\t\tasc_dvc->err_code = ASC_IERR_MCODE_CHKSUM;\n\t\treturn -EINVAL;\n\t}\n\tchksum = (fw->data[3] << 24) | (fw->data[2] << 16) |\n\t\t (fw->data[1] << 8) | fw->data[0];\n\tasc_dvc->err_code = AdvLoadMicrocode(iop_base, &fw->data[4],\n\t\t\t\t\t     fw->size - 4, ADV_38C1600_MEMSIZE,\n\t\t\t\t\t     chksum);\n\trelease_firmware(fw);\n\tif (asc_dvc->err_code)\n\t\treturn ADV_ERROR;\n\n\t/*\n\t * Restore the RISC memory BIOS region.\n\t */\n\tfor (i = 0; i < ASC_MC_BIOSLEN / 2; i++) {\n\t\tAdvWriteWordLram(iop_base, ASC_MC_BIOSMEM + (2 * i),\n\t\t\t\t bios_mem[i]);\n\t}\n\n\t/*\n\t * Calculate and write the microcode code checksum to the microcode\n\t * code checksum location ASC_MC_CODE_CHK_SUM (0x2C).\n\t */\n\tAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, begin_addr);\n\tAdvReadWordLram(iop_base, ASC_MC_CODE_END_ADDR, end_addr);\n\tcode_sum = 0;\n\tAdvWriteWordRegister(iop_base, IOPW_RAM_ADDR, begin_addr);\n\tfor (word = begin_addr; word < end_addr; word += 2) {\n\t\tcode_sum += AdvReadWordAutoIncLram(iop_base);\n\t}\n\tAdvWriteWordLram(iop_base, ASC_MC_CODE_CHK_SUM, code_sum);\n\n\t/*\n\t * Read microcode version and date.\n\t */\n\tAdvReadWordLram(iop_base, ASC_MC_VERSION_DATE,\n\t\t\tasc_dvc->cfg->mcode_date);\n\tAdvReadWordLram(iop_base, ASC_MC_VERSION_NUM,\n\t\t\tasc_dvc->cfg->mcode_version);\n\n\t/*\n\t * Set the chip type to indicate the ASC38C1600.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_CHIP_TYPE, ADV_CHIP_ASC38C1600);\n\n\t/*\n\t * Write 1 to bit 14 'DIS_TERM_DRV' in the SCSI_CFG1 register.\n\t * When DIS_TERM_DRV set to 1, C_DET[3:0] will reflect current\n\t * cable detection and then we are able to read C_DET[3:0].\n\t *\n\t * Note: We will reset DIS_TERM_DRV to 0 in the 'Set SCSI_CFG1\n\t * Microcode Default Value' section below.\n\t */\n\tscsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);\n\tAdvWriteWordRegister(iop_base, IOPW_SCSI_CFG1,\n\t\t\t     scsi_cfg1 | DIS_TERM_DRV);\n\n\t/*\n\t * If the PCI Configuration Command Register \"Parity Error Response\n\t * Control\" Bit was clear (0), then set the microcode variable\n\t * 'control_flag' CONTROL_FLAG_IGNORE_PERR flag to tell the microcode\n\t * to ignore DMA parity errors.\n\t */\n\tif (asc_dvc->cfg->control_flag & CONTROL_FLAG_IGNORE_PERR) {\n\t\tAdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_IGNORE_PERR;\n\t\tAdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t/*\n\t * If the BIOS control flag AIPP (Asynchronous Information\n\t * Phase Protection) disable bit is not set, then set the firmware\n\t * 'control_flag' CONTROL_FLAG_ENABLE_AIPP bit to enable\n\t * AIPP checking and encoding.\n\t */\n\tif ((asc_dvc->bios_ctrl & BIOS_CTRL_AIPP_DIS) == 0) {\n\t\tAdvReadWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\n\t\tword |= CONTROL_FLAG_ENABLE_AIPP;\n\t\tAdvWriteWordLram(iop_base, ASC_MC_CONTROL_FLAG, word);\n\t}\n\n\t/*\n\t * For ASC-38C1600 use DMA_CFG0 default values: FIFO_THRESH_80B [6:4],\n\t * and START_CTL_TH [3:2].\n\t */\n\tAdvWriteByteRegister(iop_base, IOPB_DMA_CFG0,\n\t\t\t     FIFO_THRESH_80B | START_CTL_TH | READ_CMD_MRM);\n\n\t/*\n\t * Microcode operating variables for WDTR, SDTR, and command tag\n\t * queuing will be set in slave_configure() based on what a\n\t * device reports it is capable of in Inquiry byte 7.\n\t *\n\t * If SCSI Bus Resets have been disabled, then directly set\n\t * SDTR and WDTR from the EEPROM configuration. This will allow\n\t * the BIOS and warm boot to work without a SCSI bus hang on\n\t * the Inquiry caused by host and target mismatched DTR values.\n\t * Without the SCSI Bus Reset, before an Inquiry a device can't\n\t * be assumed to be in Asynchronous, Narrow mode.\n\t */\n\tif ((asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) == 0) {\n\t\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE,\n\t\t\t\t asc_dvc->wdtr_able);\n\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE,\n\t\t\t\t asc_dvc->sdtr_able);\n\t}\n\n\t/*\n\t * Set microcode operating variables for DISC and SDTR_SPEED1,\n\t * SDTR_SPEED2, SDTR_SPEED3, and SDTR_SPEED4 based on the EEPROM\n\t * configuration values.\n\t *\n\t * The SDTR per TID bitmask overrides the SDTR_SPEED1, SDTR_SPEED2,\n\t * SDTR_SPEED3, and SDTR_SPEED4 values so it is safe to set them\n\t * without determining here whether the device supports SDTR.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_DISC_ENABLE,\n\t\t\t asc_dvc->cfg->disc_enable);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED1, asc_dvc->sdtr_speed1);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED2, asc_dvc->sdtr_speed2);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED3, asc_dvc->sdtr_speed3);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_SPEED4, asc_dvc->sdtr_speed4);\n\n\t/*\n\t * Set SCSI_CFG0 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG0 register using this value\n\t * after it is started below.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG0,\n\t\t\t PARITY_EN | QUEUE_128 | SEL_TMO_LONG | OUR_ID_EN |\n\t\t\t asc_dvc->chip_scsi_id);\n\n\t/*\n\t * Calculate SCSI_CFG1 Microcode Default Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t *\n\t * Each ASC-38C1600 function has only two cable detect bits.\n\t * The bus mode override bits are in IOPB_SOFT_OVER_WR.\n\t */\n\tscsi_cfg1 = AdvReadWordRegister(iop_base, IOPW_SCSI_CFG1);\n\n\t/*\n\t * If the cable is reversed all of the SCSI_CTRL register signals\n\t * will be set. Check for and return an error if this condition is\n\t * found.\n\t */\n\tif ((AdvReadWordRegister(iop_base, IOPW_SCSI_CTRL) & 0x3F07) == 0x3F07) {\n\t\tasc_dvc->err_code |= ASC_IERR_REVERSED_CABLE;\n\t\treturn ADV_ERROR;\n\t}\n\n\t/*\n\t * Each ASC-38C1600 function has two connectors. Only an HVD device\n\t * can not be connected to either connector. An LVD device or SE device\n\t * may be connected to either connecor. If an SE device is connected,\n\t * then at most Ultra speed (20 Mhz) can be used on both connectors.\n\t *\n\t * If an HVD device is attached, return an error.\n\t */\n\tif (scsi_cfg1 & HVD) {\n\t\tasc_dvc->err_code |= ASC_IERR_HVD_DEVICE;\n\t\treturn ADV_ERROR;\n\t}\n\n\t/*\n\t * Each function in the ASC-38C1600 uses only the SE cable detect and\n\t * termination because there are two connectors for each function. Each\n\t * function may use either LVD or SE mode. Corresponding the SE automatic\n\t * termination control EEPROM bits are used for each function. Each\n\t * function has its own EEPROM. If SE automatic control is enabled for\n\t * the function, then set the termination value based on a table listed\n\t * in a_condor.h.\n\t *\n\t * If manual termination is specified in the EEPROM for the function,\n\t * then 'termination' was set-up in AscInitFrom38C1600EEPROM() and is\n\t * ready to be 'ored' into SCSI_CFG1.\n\t */\n\tif ((asc_dvc->cfg->termination & TERM_SE) == 0) {\n\t\tstruct pci_dev *pdev = adv_dvc_to_pdev(asc_dvc);\n\t\t/* SE automatic termination control is enabled. */\n\t\tswitch (scsi_cfg1 & C_DET_SE) {\n\t\t\t/* TERM_SE_HI: on, TERM_SE_LO: on */\n\t\tcase 0x1:\n\t\tcase 0x2:\n\t\tcase 0x3:\n\t\t\tasc_dvc->cfg->termination |= TERM_SE;\n\t\t\tbreak;\n\n\t\tcase 0x0:\n\t\t\tif (PCI_FUNC(pdev->devfn) == 0) {\n\t\t\t\t/* Function 0 - TERM_SE_HI: off, TERM_SE_LO: off */\n\t\t\t} else {\n\t\t\t\t/* Function 1 - TERM_SE_HI: on, TERM_SE_LO: off */\n\t\t\t\tasc_dvc->cfg->termination |= TERM_SE_HI;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Clear any set TERM_SE bits.\n\t */\n\tscsi_cfg1 &= ~TERM_SE;\n\n\t/*\n\t * Invert the TERM_SE bits and then set 'scsi_cfg1'.\n\t */\n\tscsi_cfg1 |= (~asc_dvc->cfg->termination & TERM_SE);\n\n\t/*\n\t * Clear Big Endian and Terminator Polarity bits and set possibly\n\t * modified termination control bits in the Microcode SCSI_CFG1\n\t * Register Value.\n\t *\n\t * Big Endian bit is not used even on big endian machines.\n\t */\n\tscsi_cfg1 &= (~BIG_ENDIAN & ~DIS_TERM_DRV & ~TERM_POL);\n\n\t/*\n\t * Set SCSI_CFG1 Microcode Default Value\n\t *\n\t * Set possibly modified termination control bits in the Microcode\n\t * SCSI_CFG1 Register Value.\n\t *\n\t * The microcode will set the SCSI_CFG1 register using this value\n\t * after it is started below.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SCSI_CFG1, scsi_cfg1);\n\n\t/*\n\t * Set MEM_CFG Microcode Default Value\n\t *\n\t * The microcode will set the MEM_CFG register using this value\n\t * after it is started below.\n\t *\n\t * MEM_CFG may be accessed as a word or byte, but only bits 0-7\n\t * are defined.\n\t *\n\t * ASC-38C1600 has 32KB internal memory.\n\t *\n\t * XXX - Since ASC38C1600 Rev.3 has a Local RAM failure issue, we come\n\t * out a special 16K Adv Library and Microcode version. After the issue\n\t * resolved, we should turn back to the 32K support. Both a_condor.h and\n\t * mcode.sas files also need to be updated.\n\t *\n\t * AdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,\n\t *  BIOS_EN | RAM_SZ_32KB);\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_MEM_CFG,\n\t\t\t BIOS_EN | RAM_SZ_16KB);\n\n\t/*\n\t * Set SEL_MASK Microcode Default Value\n\t *\n\t * The microcode will set the SEL_MASK register using this value\n\t * after it is started below.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_DEFAULT_SEL_MASK,\n\t\t\t ADV_TID_TO_TIDMASK(asc_dvc->chip_scsi_id));\n\n\tAdvBuildCarrierFreelist(asc_dvc);\n\n\t/*\n\t * Set-up the Host->RISC Initiator Command Queue (ICQ).\n\t */\n\tasc_dvc->icq_sp = adv_get_next_carrier(asc_dvc);\n\tif (!asc_dvc->icq_sp) {\n\t\tasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\n\t\treturn ADV_ERROR;\n\t}\n\n\t/*\n\t * Set RISC ICQ physical address start value. Initialize the\n\t * COMMA register to the same value otherwise the RISC will\n\t * prematurely detect a command is available.\n\t */\n\tAdvWriteDWordLramNoSwap(iop_base, ASC_MC_ICQ, asc_dvc->icq_sp->carr_pa);\n\tAdvWriteDWordRegister(iop_base, IOPDW_COMMA,\n\t\t\t      le32_to_cpu(asc_dvc->icq_sp->carr_pa));\n\n\t/*\n\t * Set-up the RISC->Host Initiator Response Queue (IRQ).\n\t */\n\tasc_dvc->irq_sp = adv_get_next_carrier(asc_dvc);\n\tif (!asc_dvc->irq_sp) {\n\t\tasc_dvc->err_code |= ASC_IERR_NO_CARRIER;\n\t\treturn ADV_ERROR;\n\t}\n\n\t/*\n\t * Set RISC IRQ physical address start value.\n\t */\n\tAdvWriteDWordLramNoSwap(iop_base, ASC_MC_IRQ, asc_dvc->irq_sp->carr_pa);\n\tasc_dvc->carr_pending_cnt = 0;\n\n\tAdvWriteByteRegister(iop_base, IOPB_INTR_ENABLES,\n\t\t\t     (ADV_INTR_ENABLE_HOST_INTR |\n\t\t\t      ADV_INTR_ENABLE_GLOBAL_INTR));\n\tAdvReadWordLram(iop_base, ASC_MC_CODE_BEGIN_ADDR, word);\n\tAdvWriteWordRegister(iop_base, IOPW_PC, word);\n\n\t/* finally, finally, gentlemen, start your engine */\n\tAdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_RUN);\n\n\t/*\n\t * Reset the SCSI Bus if the EEPROM indicates that SCSI Bus\n\t * Resets should be performed. The RISC has to be running\n\t * to issue a SCSI Bus Reset.\n\t */\n\tif (asc_dvc->bios_ctrl & BIOS_CTRL_RESET_SCSI_BUS) {\n\t\t/*\n\t\t * If the BIOS Signature is present in memory, restore the\n\t\t * per TID microcode operating variables.\n\t\t */\n\t\tif (bios_mem[(ASC_MC_BIOS_SIGNATURE - ASC_MC_BIOSMEM) / 2] ==\n\t\t    0x55AA) {\n\t\t\t/*\n\t\t\t * Restore per TID negotiated values.\n\t\t\t */\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\t tagqng_able);\n\t\t\tfor (tid = 0; tid <= ASC_MAX_TID; tid++) {\n\t\t\t\tAdvWriteByteLram(iop_base,\n\t\t\t\t\t\t ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t\t\t max_cmd[tid]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (AdvResetSB(asc_dvc) != ADV_TRUE) {\n\t\t\t\twarn_code = ASC_WARN_BUSRESET_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn warn_code;\n}\n\n/*\n * Reset chip and SCSI Bus.\n *\n * Return Value:\n *      ADV_TRUE(1) -   Chip re-initialization and SCSI Bus Reset successful.\n *      ADV_FALSE(0) -  Chip re-initialization and SCSI Bus Reset failure.\n */\nstatic int AdvResetChipAndSB(ADV_DVC_VAR *asc_dvc)\n{\n\tint status;\n\tushort wdtr_able, sdtr_able, tagqng_able;\n\tushort ppr_able = 0;\n\tuchar tid, max_cmd[ADV_MAX_TID + 1];\n\tAdvPortAddr iop_base;\n\tushort bios_sig;\n\n\tiop_base = asc_dvc->iop_base;\n\n\t/*\n\t * Save current per TID negotiated values.\n\t */\n\tAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\tif (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {\n\t\tAdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);\n\t}\n\tAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\n\t\tAdvReadByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\tmax_cmd[tid]);\n\t}\n\n\t/*\n\t * Force the AdvInitAsc3550/38C0800Driver() function to\n\t * perform a SCSI Bus Reset by clearing the BIOS signature word.\n\t * The initialization functions assumes a SCSI Bus Reset is not\n\t * needed if the BIOS signature word is present.\n\t */\n\tAdvReadWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, bios_sig);\n\tAdvWriteWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, 0);\n\n\t/*\n\t * Stop chip and reset it.\n\t */\n\tAdvWriteWordRegister(iop_base, IOPW_RISC_CSR, ADV_RISC_CSR_STOP);\n\tAdvWriteWordRegister(iop_base, IOPW_CTRL_REG, ADV_CTRL_REG_CMD_RESET);\n\tmdelay(100);\n\tAdvWriteWordRegister(iop_base, IOPW_CTRL_REG,\n\t\t\t     ADV_CTRL_REG_CMD_WR_IO_REG);\n\n\t/*\n\t * Reset Adv Library error code, if any, and try\n\t * re-initializing the chip.\n\t */\n\tasc_dvc->err_code = 0;\n\tif (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {\n\t\tstatus = AdvInitAsc38C1600Driver(asc_dvc);\n\t} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tstatus = AdvInitAsc38C0800Driver(asc_dvc);\n\t} else {\n\t\tstatus = AdvInitAsc3550Driver(asc_dvc);\n\t}\n\n\t/* Translate initialization return value to status value. */\n\tif (status == 0) {\n\t\tstatus = ADV_TRUE;\n\t} else {\n\t\tstatus = ADV_FALSE;\n\t}\n\n\t/*\n\t * Restore the BIOS signature word.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_BIOS_SIGNATURE, bios_sig);\n\n\t/*\n\t * Restore per TID negotiated values.\n\t */\n\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, wdtr_able);\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, sdtr_able);\n\tif (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {\n\t\tAdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, ppr_able);\n\t}\n\tAdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE, tagqng_able);\n\tfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\n\t\tAdvWriteByteLram(iop_base, ASC_MC_NUMBER_OF_MAX_CMD + tid,\n\t\t\t\t max_cmd[tid]);\n\t}\n\n\treturn status;\n}\n\n/*\n * adv_async_callback() - Adv Library asynchronous event callback function.\n */\nstatic void adv_async_callback(ADV_DVC_VAR *adv_dvc_varp, uchar code)\n{\n\tswitch (code) {\n\tcase ADV_ASYNC_SCSI_BUS_RESET_DET:\n\t\t/*\n\t\t * The firmware detected a SCSI Bus reset.\n\t\t */\n\t\tASC_DBG(0, \"ADV_ASYNC_SCSI_BUS_RESET_DET\\n\");\n\t\tbreak;\n\n\tcase ADV_ASYNC_RDMA_FAILURE:\n\t\t/*\n\t\t * Handle RDMA failure by resetting the SCSI Bus and\n\t\t * possibly the chip if it is unresponsive. Log the error\n\t\t * with a unique code.\n\t\t */\n\t\tASC_DBG(0, \"ADV_ASYNC_RDMA_FAILURE\\n\");\n\t\tAdvResetChipAndSB(adv_dvc_varp);\n\t\tbreak;\n\n\tcase ADV_HOST_SCSI_BUS_RESET:\n\t\t/*\n\t\t * Host generated SCSI bus reset occurred.\n\t\t */\n\t\tASC_DBG(0, \"ADV_HOST_SCSI_BUS_RESET\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tASC_DBG(0, \"unknown code 0x%x\\n\", code);\n\t\tbreak;\n\t}\n}\n\n/*\n * adv_isr_callback() - Second Level Interrupt Handler called by AdvISR().\n *\n * Callback function for the Wide SCSI Adv Library.\n */\nstatic void adv_isr_callback(ADV_DVC_VAR *adv_dvc_varp, ADV_SCSI_REQ_Q *scsiqp)\n{\n\tstruct asc_board *boardp = adv_dvc_varp->drv_ptr;\n\tadv_req_t *reqp;\n\tadv_sgblk_t *sgblkp;\n\tstruct scsi_cmnd *scp;\n\tu32 resid_cnt;\n\tdma_addr_t sense_addr;\n\n\tASC_DBG(1, \"adv_dvc_varp 0x%p, scsiqp 0x%p\\n\",\n\t\tadv_dvc_varp, scsiqp);\n\tASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);\n\n\t/*\n\t * Get the adv_req_t structure for the command that has been\n\t * completed. The adv_req_t structure actually contains the\n\t * completed ADV_SCSI_REQ_Q structure.\n\t */\n\tscp = scsi_host_find_tag(boardp->shost, scsiqp->srb_tag);\n\n\tASC_DBG(1, \"scp 0x%p\\n\", scp);\n\tif (scp == NULL) {\n\t\tASC_PRINT\n\t\t    (\"adv_isr_callback: scp is NULL; adv_req_t dropped.\\n\");\n\t\treturn;\n\t}\n\tASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);\n\n\treqp = (adv_req_t *)scp->host_scribble;\n\tASC_DBG(1, \"reqp 0x%lx\\n\", (ulong)reqp);\n\tif (reqp == NULL) {\n\t\tASC_PRINT(\"adv_isr_callback: reqp is NULL\\n\");\n\t\treturn;\n\t}\n\t/*\n\t * Remove backreferences to avoid duplicate\n\t * command completions.\n\t */\n\tscp->host_scribble = NULL;\n\treqp->cmndp = NULL;\n\n\tASC_STATS(boardp->shost, callback);\n\tASC_DBG(1, \"shost 0x%p\\n\", boardp->shost);\n\n\tsense_addr = le32_to_cpu(scsiqp->sense_addr);\n\tdma_unmap_single(boardp->dev, sense_addr,\n\t\t\t SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\n\n\t/*\n\t * 'done_status' contains the command's ending status.\n\t */\n\tswitch (scsiqp->done_status) {\n\tcase QD_NO_ERROR:\n\t\tASC_DBG(2, \"QD_NO_ERROR\\n\");\n\t\tscp->result = 0;\n\n\t\t/*\n\t\t * Check for an underrun condition.\n\t\t *\n\t\t * If there was no error and an underrun condition, then\n\t\t * then return the number of underrun bytes.\n\t\t */\n\t\tresid_cnt = le32_to_cpu(scsiqp->data_cnt);\n\t\tif (scsi_bufflen(scp) != 0 && resid_cnt != 0 &&\n\t\t    resid_cnt <= scsi_bufflen(scp)) {\n\t\t\tASC_DBG(1, \"underrun condition %lu bytes\\n\",\n\t\t\t\t (ulong)resid_cnt);\n\t\t\tscsi_set_resid(scp, resid_cnt);\n\t\t}\n\t\tbreak;\n\n\tcase QD_WITH_ERROR:\n\t\tASC_DBG(2, \"QD_WITH_ERROR\\n\");\n\t\tswitch (scsiqp->host_status) {\n\t\tcase QHSTA_NO_ERROR:\n\t\t\tif (scsiqp->scsi_status == SAM_STAT_CHECK_CONDITION) {\n\t\t\t\tASC_DBG(2, \"SAM_STAT_CHECK_CONDITION\\n\");\n\t\t\t\tASC_DBG_PRT_SENSE(2, scp->sense_buffer,\n\t\t\t\t\t\t  SCSI_SENSE_BUFFERSIZE);\n\t\t\t\t/*\n\t\t\t\t * Note: The 'status_byte()' macro used by\n\t\t\t\t * target drivers defined in scsi.h shifts the\n\t\t\t\t * status byte returned by host drivers right\n\t\t\t\t * by 1 bit.  This is why target drivers also\n\t\t\t\t * use right shifted status byte definitions.\n\t\t\t\t * For instance target drivers use\n\t\t\t\t * CHECK_CONDITION, defined to 0x1, instead of\n\t\t\t\t * the SCSI defined check condition value of\n\t\t\t\t * 0x2. Host drivers are supposed to return\n\t\t\t\t * the status byte as it is defined by SCSI.\n\t\t\t\t */\n\t\t\t\tscp->result = DRIVER_BYTE(DRIVER_SENSE) |\n\t\t\t\t    STATUS_BYTE(scsiqp->scsi_status);\n\t\t\t} else {\n\t\t\t\tscp->result = STATUS_BYTE(scsiqp->scsi_status);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Some other QHSTA error occurred. */\n\t\t\tASC_DBG(1, \"host_status 0x%x\\n\", scsiqp->host_status);\n\t\t\tscp->result = HOST_BYTE(DID_BAD_TARGET);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase QD_ABORTED_BY_HOST:\n\t\tASC_DBG(1, \"QD_ABORTED_BY_HOST\\n\");\n\t\tscp->result =\n\t\t    HOST_BYTE(DID_ABORT) | STATUS_BYTE(scsiqp->scsi_status);\n\t\tbreak;\n\n\tdefault:\n\t\tASC_DBG(1, \"done_status 0x%x\\n\", scsiqp->done_status);\n\t\tscp->result =\n\t\t    HOST_BYTE(DID_ERROR) | STATUS_BYTE(scsiqp->scsi_status);\n\t\tbreak;\n\t}\n\n\t/*\n\t * If the 'init_tidmask' bit isn't already set for the target and the\n\t * current request finished normally, then set the bit for the target\n\t * to indicate that a device is present.\n\t */\n\tif ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(scp->device->id)) == 0 &&\n\t    scsiqp->done_status == QD_NO_ERROR &&\n\t    scsiqp->host_status == QHSTA_NO_ERROR) {\n\t\tboardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);\n\t}\n\n\tasc_scsi_done(scp);\n\n\t/*\n\t * Free all 'adv_sgblk_t' structures allocated for the request.\n\t */\n\twhile ((sgblkp = reqp->sgblkp) != NULL) {\n\t\t/* Remove 'sgblkp' from the request list. */\n\t\treqp->sgblkp = sgblkp->next_sgblkp;\n\n\t\tdma_pool_free(boardp->adv_sgblk_pool, sgblkp,\n\t\t\t      sgblkp->sg_addr);\n\t}\n\n\tASC_DBG(1, \"done\\n\");\n}\n\n/*\n * Adv Library Interrupt Service Routine\n *\n *  This function is called by a driver's interrupt service routine.\n *  The function disables and re-enables interrupts.\n *\n *  When a microcode idle command is completed, the ADV_DVC_VAR\n *  'idle_cmd_done' field is set to ADV_TRUE.\n *\n *  Note: AdvISR() can be called when interrupts are disabled or even\n *  when there is no hardware interrupt condition present. It will\n *  always check for completed idle commands and microcode requests.\n *  This is an important feature that shouldn't be changed because it\n *  allows commands to be completed from polling mode loops.\n *\n * Return:\n *   ADV_TRUE(1) - interrupt was pending\n *   ADV_FALSE(0) - no interrupt was pending\n */\nstatic int AdvISR(ADV_DVC_VAR *asc_dvc)\n{\n\tAdvPortAddr iop_base;\n\tuchar int_stat;\n\tushort target_bit;\n\tADV_CARR_T *free_carrp;\n\t__le32 irq_next_vpa;\n\tADV_SCSI_REQ_Q *scsiq;\n\tadv_req_t *reqp;\n\n\tiop_base = asc_dvc->iop_base;\n\n\t/* Reading the register clears the interrupt. */\n\tint_stat = AdvReadByteRegister(iop_base, IOPB_INTR_STATUS_REG);\n\n\tif ((int_stat & (ADV_INTR_STATUS_INTRA | ADV_INTR_STATUS_INTRB |\n\t\t\t ADV_INTR_STATUS_INTRC)) == 0) {\n\t\treturn ADV_FALSE;\n\t}\n\n\t/*\n\t * Notify the driver of an asynchronous microcode condition by\n\t * calling the adv_async_callback function. The function\n\t * is passed the microcode ASC_MC_INTRB_CODE byte value.\n\t */\n\tif (int_stat & ADV_INTR_STATUS_INTRB) {\n\t\tuchar intrb_code;\n\n\t\tAdvReadByteLram(iop_base, ASC_MC_INTRB_CODE, intrb_code);\n\n\t\tif (asc_dvc->chip_type == ADV_CHIP_ASC3550 ||\n\t\t    asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {\n\t\t\tif (intrb_code == ADV_ASYNC_CARRIER_READY_FAILURE &&\n\t\t\t    asc_dvc->carr_pending_cnt != 0) {\n\t\t\t\tAdvWriteByteRegister(iop_base, IOPB_TICKLE,\n\t\t\t\t\t\t     ADV_TICKLE_A);\n\t\t\t\tif (asc_dvc->chip_type == ADV_CHIP_ASC3550) {\n\t\t\t\t\tAdvWriteByteRegister(iop_base,\n\t\t\t\t\t\t\t     IOPB_TICKLE,\n\t\t\t\t\t\t\t     ADV_TICKLE_NOP);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tadv_async_callback(asc_dvc, intrb_code);\n\t}\n\n\t/*\n\t * Check if the IRQ stopper carrier contains a completed request.\n\t */\n\twhile (((irq_next_vpa =\n\t\t le32_to_cpu(asc_dvc->irq_sp->next_vpa)) & ADV_RQ_DONE) != 0) {\n\t\t/*\n\t\t * Get a pointer to the newly completed ADV_SCSI_REQ_Q structure.\n\t\t * The RISC will have set 'areq_vpa' to a virtual address.\n\t\t *\n\t\t * The firmware will have copied the ADV_SCSI_REQ_Q.scsiq_ptr\n\t\t * field to the carrier ADV_CARR_T.areq_vpa field. The conversion\n\t\t * below complements the conversion of ADV_SCSI_REQ_Q.scsiq_ptr'\n\t\t * in AdvExeScsiQueue().\n\t\t */\n\t\tu32 pa_offset = le32_to_cpu(asc_dvc->irq_sp->areq_vpa);\n\t\tASC_DBG(1, \"irq_sp %p areq_vpa %u\\n\",\n\t\t\tasc_dvc->irq_sp, pa_offset);\n\t\treqp = adv_get_reqp(asc_dvc, pa_offset);\n\t\tscsiq = &reqp->scsi_req_q;\n\n\t\t/*\n\t\t * Request finished with good status and the queue was not\n\t\t * DMAed to host memory by the firmware. Set all status fields\n\t\t * to indicate good status.\n\t\t */\n\t\tif ((irq_next_vpa & ADV_RQ_GOOD) != 0) {\n\t\t\tscsiq->done_status = QD_NO_ERROR;\n\t\t\tscsiq->host_status = scsiq->scsi_status = 0;\n\t\t\tscsiq->data_cnt = 0L;\n\t\t}\n\n\t\t/*\n\t\t * Advance the stopper pointer to the next carrier\n\t\t * ignoring the lower four bits. Free the previous\n\t\t * stopper carrier.\n\t\t */\n\t\tfree_carrp = asc_dvc->irq_sp;\n\t\tasc_dvc->irq_sp = adv_get_carrier(asc_dvc,\n\t\t\t\t\t\t  ADV_GET_CARRP(irq_next_vpa));\n\n\t\tfree_carrp->next_vpa = asc_dvc->carr_freelist->carr_va;\n\t\tasc_dvc->carr_freelist = free_carrp;\n\t\tasc_dvc->carr_pending_cnt--;\n\n\t\ttarget_bit = ADV_TID_TO_TIDMASK(scsiq->target_id);\n\n\t\t/*\n\t\t * Clear request microcode control flag.\n\t\t */\n\t\tscsiq->cntl = 0;\n\n\t\t/*\n\t\t * Notify the driver of the completed request by passing\n\t\t * the ADV_SCSI_REQ_Q pointer to its callback function.\n\t\t */\n\t\tadv_isr_callback(asc_dvc, scsiq);\n\t\t/*\n\t\t * Note: After the driver callback function is called, 'scsiq'\n\t\t * can no longer be referenced.\n\t\t *\n\t\t * Fall through and continue processing other completed\n\t\t * requests...\n\t\t */\n\t}\n\treturn ADV_TRUE;\n}\n\nstatic int AscSetLibErrorCode(ASC_DVC_VAR *asc_dvc, ushort err_code)\n{\n\tif (asc_dvc->err_code == 0) {\n\t\tasc_dvc->err_code = err_code;\n\t\tAscWriteLramWord(asc_dvc->iop_base, ASCV_ASCDVC_ERR_CODE_W,\n\t\t\t\t err_code);\n\t}\n\treturn err_code;\n}\n\nstatic void AscAckInterrupt(PortAddr iop_base)\n{\n\tuchar host_flag;\n\tuchar risc_flag;\n\tushort loop;\n\n\tloop = 0;\n\tdo {\n\t\trisc_flag = AscReadLramByte(iop_base, ASCV_RISC_FLAG_B);\n\t\tif (loop++ > 0x7FFF) {\n\t\t\tbreak;\n\t\t}\n\t} while ((risc_flag & ASC_RISC_FLAG_GEN_INT) != 0);\n\thost_flag =\n\t    AscReadLramByte(iop_base,\n\t\t\t    ASCV_HOST_FLAG_B) & (~ASC_HOST_FLAG_ACK_INT);\n\tAscWriteLramByte(iop_base, ASCV_HOST_FLAG_B,\n\t\t\t (uchar)(host_flag | ASC_HOST_FLAG_ACK_INT));\n\tAscSetChipStatus(iop_base, CIW_INT_ACK);\n\tloop = 0;\n\twhile (AscGetChipStatus(iop_base) & CSW_INT_PENDING) {\n\t\tAscSetChipStatus(iop_base, CIW_INT_ACK);\n\t\tif (loop++ > 3) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tAscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);\n}\n\nstatic uchar AscGetSynPeriodIndex(ASC_DVC_VAR *asc_dvc, uchar syn_time)\n{\n\tconst uchar *period_table;\n\tint max_index;\n\tint min_index;\n\tint i;\n\n\tperiod_table = asc_dvc->sdtr_period_tbl;\n\tmax_index = (int)asc_dvc->max_sdtr_index;\n\tmin_index = (int)asc_dvc->min_sdtr_index;\n\tif ((syn_time <= period_table[max_index])) {\n\t\tfor (i = min_index; i < (max_index - 1); i++) {\n\t\t\tif (syn_time <= period_table[i]) {\n\t\t\t\treturn (uchar)i;\n\t\t\t}\n\t\t}\n\t\treturn (uchar)max_index;\n\t} else {\n\t\treturn (uchar)(max_index + 1);\n\t}\n}\n\nstatic uchar\nAscMsgOutSDTR(ASC_DVC_VAR *asc_dvc, uchar sdtr_period, uchar sdtr_offset)\n{\n\tPortAddr iop_base = asc_dvc->iop_base;\n\tuchar sdtr_period_index = AscGetSynPeriodIndex(asc_dvc, sdtr_period);\n\tEXT_MSG sdtr_buf = {\n\t\t.msg_type = EXTENDED_MESSAGE,\n\t\t.msg_len = MS_SDTR_LEN,\n\t\t.msg_req = EXTENDED_SDTR,\n\t\t.xfer_period = sdtr_period,\n\t\t.req_ack_offset = sdtr_offset,\n\t};\n\tsdtr_offset &= ASC_SYN_MAX_OFFSET;\n\n\tif (sdtr_period_index <= asc_dvc->max_sdtr_index) {\n\t\tAscMemWordCopyPtrToLram(iop_base, ASCV_MSGOUT_BEG,\n\t\t\t\t\t(uchar *)&sdtr_buf,\n\t\t\t\t\tsizeof(EXT_MSG) >> 1);\n\t\treturn ((sdtr_period_index << 4) | sdtr_offset);\n\t} else {\n\t\tsdtr_buf.req_ack_offset = 0;\n\t\tAscMemWordCopyPtrToLram(iop_base, ASCV_MSGOUT_BEG,\n\t\t\t\t\t(uchar *)&sdtr_buf,\n\t\t\t\t\tsizeof(EXT_MSG) >> 1);\n\t\treturn 0;\n\t}\n}\n\nstatic uchar\nAscCalSDTRData(ASC_DVC_VAR *asc_dvc, uchar sdtr_period, uchar syn_offset)\n{\n\tuchar byte;\n\tuchar sdtr_period_ix;\n\n\tsdtr_period_ix = AscGetSynPeriodIndex(asc_dvc, sdtr_period);\n\tif (sdtr_period_ix > asc_dvc->max_sdtr_index)\n\t\treturn 0xFF;\n\tbyte = (sdtr_period_ix << 4) | (syn_offset & ASC_SYN_MAX_OFFSET);\n\treturn byte;\n}\n\nstatic bool AscSetChipSynRegAtID(PortAddr iop_base, uchar id, uchar sdtr_data)\n{\n\tASC_SCSI_BIT_ID_TYPE org_id;\n\tint i;\n\tbool sta = true;\n\n\tAscSetBank(iop_base, 1);\n\torg_id = AscReadChipDvcID(iop_base);\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tif (org_id == (0x01 << i))\n\t\t\tbreak;\n\t}\n\torg_id = (ASC_SCSI_BIT_ID_TYPE) i;\n\tAscWriteChipDvcID(iop_base, id);\n\tif (AscReadChipDvcID(iop_base) == (0x01 << id)) {\n\t\tAscSetBank(iop_base, 0);\n\t\tAscSetChipSyn(iop_base, sdtr_data);\n\t\tif (AscGetChipSyn(iop_base) != sdtr_data) {\n\t\t\tsta = false;\n\t\t}\n\t} else {\n\t\tsta = false;\n\t}\n\tAscSetBank(iop_base, 1);\n\tAscWriteChipDvcID(iop_base, org_id);\n\tAscSetBank(iop_base, 0);\n\treturn (sta);\n}\n\nstatic void AscSetChipSDTR(PortAddr iop_base, uchar sdtr_data, uchar tid_no)\n{\n\tAscSetChipSynRegAtID(iop_base, tid_no, sdtr_data);\n\tAscPutMCodeSDTRDoneAtID(iop_base, tid_no, sdtr_data);\n}\n\nstatic void AscIsrChipHalted(ASC_DVC_VAR *asc_dvc)\n{\n\tEXT_MSG ext_msg;\n\tEXT_MSG out_msg;\n\tushort halt_q_addr;\n\tbool sdtr_accept;\n\tushort int_halt_code;\n\tASC_SCSI_BIT_ID_TYPE scsi_busy;\n\tASC_SCSI_BIT_ID_TYPE target_id;\n\tPortAddr iop_base;\n\tuchar tag_code;\n\tuchar q_status;\n\tuchar halt_qp;\n\tuchar sdtr_data;\n\tuchar target_ix;\n\tuchar q_cntl, tid_no;\n\tuchar cur_dvc_qng;\n\tuchar asyn_sdtr;\n\tuchar scsi_status;\n\tstruct asc_board *boardp;\n\n\tBUG_ON(!asc_dvc->drv_ptr);\n\tboardp = asc_dvc->drv_ptr;\n\n\tiop_base = asc_dvc->iop_base;\n\tint_halt_code = AscReadLramWord(iop_base, ASCV_HALTCODE_W);\n\n\thalt_qp = AscReadLramByte(iop_base, ASCV_CURCDB_B);\n\thalt_q_addr = ASC_QNO_TO_QADDR(halt_qp);\n\ttarget_ix = AscReadLramByte(iop_base,\n\t\t\t\t    (ushort)(halt_q_addr +\n\t\t\t\t\t     (ushort)ASC_SCSIQ_B_TARGET_IX));\n\tq_cntl = AscReadLramByte(iop_base,\n\t\t\t    (ushort)(halt_q_addr + (ushort)ASC_SCSIQ_B_CNTL));\n\ttid_no = ASC_TIX_TO_TID(target_ix);\n\ttarget_id = (uchar)ASC_TID_TO_TARGET_ID(tid_no);\n\tif (asc_dvc->pci_fix_asyn_xfer & target_id) {\n\t\tasyn_sdtr = ASYN_SDTR_DATA_FIX_PCI_REV_AB;\n\t} else {\n\t\tasyn_sdtr = 0;\n\t}\n\tif (int_halt_code == ASC_HALT_DISABLE_ASYN_USE_SYN_FIX) {\n\t\tif (asc_dvc->pci_fix_asyn_xfer & target_id) {\n\t\t\tAscSetChipSDTR(iop_base, 0, tid_no);\n\t\t\tboardp->sdtr_data[tid_no] = 0;\n\t\t}\n\t\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\t\treturn;\n\t} else if (int_halt_code == ASC_HALT_ENABLE_ASYN_USE_SYN_FIX) {\n\t\tif (asc_dvc->pci_fix_asyn_xfer & target_id) {\n\t\t\tAscSetChipSDTR(iop_base, asyn_sdtr, tid_no);\n\t\t\tboardp->sdtr_data[tid_no] = asyn_sdtr;\n\t\t}\n\t\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\t\treturn;\n\t} else if (int_halt_code == ASC_HALT_EXTMSG_IN) {\n\t\tAscMemWordCopyPtrFromLram(iop_base,\n\t\t\t\t\t  ASCV_MSGIN_BEG,\n\t\t\t\t\t  (uchar *)&ext_msg,\n\t\t\t\t\t  sizeof(EXT_MSG) >> 1);\n\n\t\tif (ext_msg.msg_type == EXTENDED_MESSAGE &&\n\t\t    ext_msg.msg_req == EXTENDED_SDTR &&\n\t\t    ext_msg.msg_len == MS_SDTR_LEN) {\n\t\t\tsdtr_accept = true;\n\t\t\tif ((ext_msg.req_ack_offset > ASC_SYN_MAX_OFFSET)) {\n\n\t\t\t\tsdtr_accept = false;\n\t\t\t\text_msg.req_ack_offset = ASC_SYN_MAX_OFFSET;\n\t\t\t}\n\t\t\tif ((ext_msg.xfer_period <\n\t\t\t     asc_dvc->sdtr_period_tbl[asc_dvc->min_sdtr_index])\n\t\t\t    || (ext_msg.xfer_period >\n\t\t\t\tasc_dvc->sdtr_period_tbl[asc_dvc->\n\t\t\t\t\t\t\t max_sdtr_index])) {\n\t\t\t\tsdtr_accept = false;\n\t\t\t\text_msg.xfer_period =\n\t\t\t\t    asc_dvc->sdtr_period_tbl[asc_dvc->\n\t\t\t\t\t\t\t     min_sdtr_index];\n\t\t\t}\n\t\t\tif (sdtr_accept) {\n\t\t\t\tsdtr_data =\n\t\t\t\t    AscCalSDTRData(asc_dvc, ext_msg.xfer_period,\n\t\t\t\t\t\t   ext_msg.req_ack_offset);\n\t\t\t\tif (sdtr_data == 0xFF) {\n\n\t\t\t\t\tq_cntl |= QC_MSG_OUT;\n\t\t\t\t\tasc_dvc->init_sdtr &= ~target_id;\n\t\t\t\t\tasc_dvc->sdtr_done &= ~target_id;\n\t\t\t\t\tAscSetChipSDTR(iop_base, asyn_sdtr,\n\t\t\t\t\t\t       tid_no);\n\t\t\t\t\tboardp->sdtr_data[tid_no] = asyn_sdtr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ext_msg.req_ack_offset == 0) {\n\n\t\t\t\tq_cntl &= ~QC_MSG_OUT;\n\t\t\t\tasc_dvc->init_sdtr &= ~target_id;\n\t\t\t\tasc_dvc->sdtr_done &= ~target_id;\n\t\t\t\tAscSetChipSDTR(iop_base, asyn_sdtr, tid_no);\n\t\t\t} else {\n\t\t\t\tif (sdtr_accept && (q_cntl & QC_MSG_OUT)) {\n\t\t\t\t\tq_cntl &= ~QC_MSG_OUT;\n\t\t\t\t\tasc_dvc->sdtr_done |= target_id;\n\t\t\t\t\tasc_dvc->init_sdtr |= target_id;\n\t\t\t\t\tasc_dvc->pci_fix_asyn_xfer &=\n\t\t\t\t\t    ~target_id;\n\t\t\t\t\tsdtr_data =\n\t\t\t\t\t    AscCalSDTRData(asc_dvc,\n\t\t\t\t\t\t\t   ext_msg.xfer_period,\n\t\t\t\t\t\t\t   ext_msg.\n\t\t\t\t\t\t\t   req_ack_offset);\n\t\t\t\t\tAscSetChipSDTR(iop_base, sdtr_data,\n\t\t\t\t\t\t       tid_no);\n\t\t\t\t\tboardp->sdtr_data[tid_no] = sdtr_data;\n\t\t\t\t} else {\n\t\t\t\t\tq_cntl |= QC_MSG_OUT;\n\t\t\t\t\tAscMsgOutSDTR(asc_dvc,\n\t\t\t\t\t\t      ext_msg.xfer_period,\n\t\t\t\t\t\t      ext_msg.req_ack_offset);\n\t\t\t\t\tasc_dvc->pci_fix_asyn_xfer &=\n\t\t\t\t\t    ~target_id;\n\t\t\t\t\tsdtr_data =\n\t\t\t\t\t    AscCalSDTRData(asc_dvc,\n\t\t\t\t\t\t\t   ext_msg.xfer_period,\n\t\t\t\t\t\t\t   ext_msg.\n\t\t\t\t\t\t\t   req_ack_offset);\n\t\t\t\t\tAscSetChipSDTR(iop_base, sdtr_data,\n\t\t\t\t\t\t       tid_no);\n\t\t\t\t\tboardp->sdtr_data[tid_no] = sdtr_data;\n\t\t\t\t\tasc_dvc->sdtr_done |= target_id;\n\t\t\t\t\tasc_dvc->init_sdtr |= target_id;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tAscWriteLramByte(iop_base,\n\t\t\t\t\t (ushort)(halt_q_addr +\n\t\t\t\t\t\t  (ushort)ASC_SCSIQ_B_CNTL),\n\t\t\t\t\t q_cntl);\n\t\t\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\t\t\treturn;\n\t\t} else if (ext_msg.msg_type == EXTENDED_MESSAGE &&\n\t\t\t   ext_msg.msg_req == EXTENDED_WDTR &&\n\t\t\t   ext_msg.msg_len == MS_WDTR_LEN) {\n\n\t\t\text_msg.wdtr_width = 0;\n\t\t\tAscMemWordCopyPtrToLram(iop_base,\n\t\t\t\t\t\tASCV_MSGOUT_BEG,\n\t\t\t\t\t\t(uchar *)&ext_msg,\n\t\t\t\t\t\tsizeof(EXT_MSG) >> 1);\n\t\t\tq_cntl |= QC_MSG_OUT;\n\t\t\tAscWriteLramByte(iop_base,\n\t\t\t\t\t (ushort)(halt_q_addr +\n\t\t\t\t\t\t  (ushort)ASC_SCSIQ_B_CNTL),\n\t\t\t\t\t q_cntl);\n\t\t\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\t\t\treturn;\n\t\t} else {\n\n\t\t\text_msg.msg_type = MESSAGE_REJECT;\n\t\t\tAscMemWordCopyPtrToLram(iop_base,\n\t\t\t\t\t\tASCV_MSGOUT_BEG,\n\t\t\t\t\t\t(uchar *)&ext_msg,\n\t\t\t\t\t\tsizeof(EXT_MSG) >> 1);\n\t\t\tq_cntl |= QC_MSG_OUT;\n\t\t\tAscWriteLramByte(iop_base,\n\t\t\t\t\t (ushort)(halt_q_addr +\n\t\t\t\t\t\t  (ushort)ASC_SCSIQ_B_CNTL),\n\t\t\t\t\t q_cntl);\n\t\t\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\t\t\treturn;\n\t\t}\n\t} else if (int_halt_code == ASC_HALT_CHK_CONDITION) {\n\n\t\tq_cntl |= QC_REQ_SENSE;\n\n\t\tif ((asc_dvc->init_sdtr & target_id) != 0) {\n\n\t\t\tasc_dvc->sdtr_done &= ~target_id;\n\n\t\t\tsdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);\n\t\t\tq_cntl |= QC_MSG_OUT;\n\t\t\tAscMsgOutSDTR(asc_dvc,\n\t\t\t\t      asc_dvc->\n\t\t\t\t      sdtr_period_tbl[(sdtr_data >> 4) &\n\t\t\t\t\t\t      (uchar)(asc_dvc->\n\t\t\t\t\t\t\t      max_sdtr_index -\n\t\t\t\t\t\t\t      1)],\n\t\t\t\t      (uchar)(sdtr_data & (uchar)\n\t\t\t\t\t      ASC_SYN_MAX_OFFSET));\n\t\t}\n\n\t\tAscWriteLramByte(iop_base,\n\t\t\t\t (ushort)(halt_q_addr +\n\t\t\t\t\t  (ushort)ASC_SCSIQ_B_CNTL), q_cntl);\n\n\t\ttag_code = AscReadLramByte(iop_base,\n\t\t\t\t\t   (ushort)(halt_q_addr + (ushort)\n\t\t\t\t\t\t    ASC_SCSIQ_B_TAG_CODE));\n\t\ttag_code &= 0xDC;\n\t\tif ((asc_dvc->pci_fix_asyn_xfer & target_id)\n\t\t    && !(asc_dvc->pci_fix_asyn_xfer_always & target_id)\n\t\t    ) {\n\n\t\t\ttag_code |= (ASC_TAG_FLAG_DISABLE_DISCONNECT\n\t\t\t\t     | ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX);\n\n\t\t}\n\t\tAscWriteLramByte(iop_base,\n\t\t\t\t (ushort)(halt_q_addr +\n\t\t\t\t\t  (ushort)ASC_SCSIQ_B_TAG_CODE),\n\t\t\t\t tag_code);\n\n\t\tq_status = AscReadLramByte(iop_base,\n\t\t\t\t\t   (ushort)(halt_q_addr + (ushort)\n\t\t\t\t\t\t    ASC_SCSIQ_B_STATUS));\n\t\tq_status |= (QS_READY | QS_BUSY);\n\t\tAscWriteLramByte(iop_base,\n\t\t\t\t (ushort)(halt_q_addr +\n\t\t\t\t\t  (ushort)ASC_SCSIQ_B_STATUS),\n\t\t\t\t q_status);\n\n\t\tscsi_busy = AscReadLramByte(iop_base, (ushort)ASCV_SCSIBUSY_B);\n\t\tscsi_busy &= ~target_id;\n\t\tAscWriteLramByte(iop_base, (ushort)ASCV_SCSIBUSY_B, scsi_busy);\n\n\t\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\t\treturn;\n\t} else if (int_halt_code == ASC_HALT_SDTR_REJECTED) {\n\n\t\tAscMemWordCopyPtrFromLram(iop_base,\n\t\t\t\t\t  ASCV_MSGOUT_BEG,\n\t\t\t\t\t  (uchar *)&out_msg,\n\t\t\t\t\t  sizeof(EXT_MSG) >> 1);\n\n\t\tif ((out_msg.msg_type == EXTENDED_MESSAGE) &&\n\t\t    (out_msg.msg_len == MS_SDTR_LEN) &&\n\t\t    (out_msg.msg_req == EXTENDED_SDTR)) {\n\n\t\t\tasc_dvc->init_sdtr &= ~target_id;\n\t\t\tasc_dvc->sdtr_done &= ~target_id;\n\t\t\tAscSetChipSDTR(iop_base, asyn_sdtr, tid_no);\n\t\t\tboardp->sdtr_data[tid_no] = asyn_sdtr;\n\t\t}\n\t\tq_cntl &= ~QC_MSG_OUT;\n\t\tAscWriteLramByte(iop_base,\n\t\t\t\t (ushort)(halt_q_addr +\n\t\t\t\t\t  (ushort)ASC_SCSIQ_B_CNTL), q_cntl);\n\t\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\t\treturn;\n\t} else if (int_halt_code == ASC_HALT_SS_QUEUE_FULL) {\n\n\t\tscsi_status = AscReadLramByte(iop_base,\n\t\t\t\t\t      (ushort)((ushort)halt_q_addr +\n\t\t\t\t\t\t       (ushort)\n\t\t\t\t\t\t       ASC_SCSIQ_SCSI_STATUS));\n\t\tcur_dvc_qng =\n\t\t    AscReadLramByte(iop_base,\n\t\t\t\t    (ushort)((ushort)ASC_QADR_BEG +\n\t\t\t\t\t     (ushort)target_ix));\n\t\tif ((cur_dvc_qng > 0) && (asc_dvc->cur_dvc_qng[tid_no] > 0)) {\n\n\t\t\tscsi_busy = AscReadLramByte(iop_base,\n\t\t\t\t\t\t    (ushort)ASCV_SCSIBUSY_B);\n\t\t\tscsi_busy |= target_id;\n\t\t\tAscWriteLramByte(iop_base,\n\t\t\t\t\t (ushort)ASCV_SCSIBUSY_B, scsi_busy);\n\t\t\tasc_dvc->queue_full_or_busy |= target_id;\n\n\t\t\tif (scsi_status == SAM_STAT_TASK_SET_FULL) {\n\t\t\t\tif (cur_dvc_qng > ASC_MIN_TAGGED_CMD) {\n\t\t\t\t\tcur_dvc_qng -= 1;\n\t\t\t\t\tasc_dvc->max_dvc_qng[tid_no] =\n\t\t\t\t\t    cur_dvc_qng;\n\n\t\t\t\t\tAscWriteLramByte(iop_base,\n\t\t\t\t\t\t\t (ushort)((ushort)\n\t\t\t\t\t\t\t\t  ASCV_MAX_DVC_QNG_BEG\n\t\t\t\t\t\t\t\t  + (ushort)\n\t\t\t\t\t\t\t\t  tid_no),\n\t\t\t\t\t\t\t cur_dvc_qng);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set the device queue depth to the\n\t\t\t\t\t * number of active requests when the\n\t\t\t\t\t * QUEUE FULL condition was encountered.\n\t\t\t\t\t */\n\t\t\t\t\tboardp->queue_full |= target_id;\n\t\t\t\t\tboardp->queue_full_cnt[tid_no] =\n\t\t\t\t\t    cur_dvc_qng;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0);\n\t\treturn;\n\t}\n\treturn;\n}\n\n/*\n * void\n * DvcGetQinfo(PortAddr iop_base, ushort s_addr, uchar *inbuf, int words)\n *\n * Calling/Exit State:\n *    none\n *\n * Description:\n *     Input an ASC_QDONE_INFO structure from the chip\n */\nstatic void\nDvcGetQinfo(PortAddr iop_base, ushort s_addr, uchar *inbuf, int words)\n{\n\tint i;\n\tushort word;\n\n\tAscSetChipLramAddr(iop_base, s_addr);\n\tfor (i = 0; i < 2 * words; i += 2) {\n\t\tif (i == 10) {\n\t\t\tcontinue;\n\t\t}\n\t\tword = inpw(iop_base + IOP_RAM_DATA);\n\t\tinbuf[i] = word & 0xff;\n\t\tinbuf[i + 1] = (word >> 8) & 0xff;\n\t}\n\tASC_DBG_PRT_HEX(2, \"DvcGetQinfo\", inbuf, 2 * words);\n}\n\nstatic uchar\n_AscCopyLramScsiDoneQ(PortAddr iop_base,\n\t\t      ushort q_addr,\n\t\t      ASC_QDONE_INFO *scsiq, unsigned int max_dma_count)\n{\n\tushort _val;\n\tuchar sg_queue_cnt;\n\n\tDvcGetQinfo(iop_base,\n\t\t    q_addr + ASC_SCSIQ_DONE_INFO_BEG,\n\t\t    (uchar *)scsiq,\n\t\t    (sizeof(ASC_SCSIQ_2) + sizeof(ASC_SCSIQ_3)) / 2);\n\n\t_val = AscReadLramWord(iop_base,\n\t\t\t       (ushort)(q_addr + (ushort)ASC_SCSIQ_B_STATUS));\n\tscsiq->q_status = (uchar)_val;\n\tscsiq->q_no = (uchar)(_val >> 8);\n\t_val = AscReadLramWord(iop_base,\n\t\t\t       (ushort)(q_addr + (ushort)ASC_SCSIQ_B_CNTL));\n\tscsiq->cntl = (uchar)_val;\n\tsg_queue_cnt = (uchar)(_val >> 8);\n\t_val = AscReadLramWord(iop_base,\n\t\t\t       (ushort)(q_addr +\n\t\t\t\t\t(ushort)ASC_SCSIQ_B_SENSE_LEN));\n\tscsiq->sense_len = (uchar)_val;\n\tscsiq->extra_bytes = (uchar)(_val >> 8);\n\n\t/*\n\t * Read high word of remain bytes from alternate location.\n\t */\n\tscsiq->remain_bytes = (((u32)AscReadLramWord(iop_base,\n\t\t\t\t\t\t     (ushort)(q_addr +\n\t\t\t\t\t\t\t      (ushort)\n\t\t\t\t\t\t\t      ASC_SCSIQ_W_ALT_DC1)))\n\t\t\t       << 16);\n\t/*\n\t * Read low word of remain bytes from original location.\n\t */\n\tscsiq->remain_bytes += AscReadLramWord(iop_base,\n\t\t\t\t\t       (ushort)(q_addr + (ushort)\n\t\t\t\t\t\t\tASC_SCSIQ_DW_REMAIN_XFER_CNT));\n\n\tscsiq->remain_bytes &= max_dma_count;\n\treturn sg_queue_cnt;\n}\n\n/*\n * asc_isr_callback() - Second Level Interrupt Handler called by AscISR().\n *\n * Interrupt callback function for the Narrow SCSI Asc Library.\n */\nstatic void asc_isr_callback(ASC_DVC_VAR *asc_dvc_varp, ASC_QDONE_INFO *qdonep)\n{\n\tstruct asc_board *boardp = asc_dvc_varp->drv_ptr;\n\tu32 srb_tag;\n\tstruct scsi_cmnd *scp;\n\n\tASC_DBG(1, \"asc_dvc_varp 0x%p, qdonep 0x%p\\n\", asc_dvc_varp, qdonep);\n\tASC_DBG_PRT_ASC_QDONE_INFO(2, qdonep);\n\n\t/*\n\t * Decrease the srb_tag by 1 to find the SCSI command\n\t */\n\tsrb_tag = qdonep->d2.srb_tag - 1;\n\tscp = scsi_host_find_tag(boardp->shost, srb_tag);\n\tif (!scp)\n\t\treturn;\n\n\tASC_DBG_PRT_CDB(2, scp->cmnd, scp->cmd_len);\n\n\tASC_STATS(boardp->shost, callback);\n\n\tdma_unmap_single(boardp->dev, scp->SCp.dma_handle,\n\t\t\t SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\n\t/*\n\t * 'qdonep' contains the command's ending status.\n\t */\n\tswitch (qdonep->d3.done_stat) {\n\tcase QD_NO_ERROR:\n\t\tASC_DBG(2, \"QD_NO_ERROR\\n\");\n\t\tscp->result = 0;\n\n\t\t/*\n\t\t * Check for an underrun condition.\n\t\t *\n\t\t * If there was no error and an underrun condition, then\n\t\t * return the number of underrun bytes.\n\t\t */\n\t\tif (scsi_bufflen(scp) != 0 && qdonep->remain_bytes != 0 &&\n\t\t    qdonep->remain_bytes <= scsi_bufflen(scp)) {\n\t\t\tASC_DBG(1, \"underrun condition %u bytes\\n\",\n\t\t\t\t (unsigned)qdonep->remain_bytes);\n\t\t\tscsi_set_resid(scp, qdonep->remain_bytes);\n\t\t}\n\t\tbreak;\n\n\tcase QD_WITH_ERROR:\n\t\tASC_DBG(2, \"QD_WITH_ERROR\\n\");\n\t\tswitch (qdonep->d3.host_stat) {\n\t\tcase QHSTA_NO_ERROR:\n\t\t\tif (qdonep->d3.scsi_stat == SAM_STAT_CHECK_CONDITION) {\n\t\t\t\tASC_DBG(2, \"SAM_STAT_CHECK_CONDITION\\n\");\n\t\t\t\tASC_DBG_PRT_SENSE(2, scp->sense_buffer,\n\t\t\t\t\t\t  SCSI_SENSE_BUFFERSIZE);\n\t\t\t\t/*\n\t\t\t\t * Note: The 'status_byte()' macro used by\n\t\t\t\t * target drivers defined in scsi.h shifts the\n\t\t\t\t * status byte returned by host drivers right\n\t\t\t\t * by 1 bit.  This is why target drivers also\n\t\t\t\t * use right shifted status byte definitions.\n\t\t\t\t * For instance target drivers use\n\t\t\t\t * CHECK_CONDITION, defined to 0x1, instead of\n\t\t\t\t * the SCSI defined check condition value of\n\t\t\t\t * 0x2. Host drivers are supposed to return\n\t\t\t\t * the status byte as it is defined by SCSI.\n\t\t\t\t */\n\t\t\t\tscp->result = DRIVER_BYTE(DRIVER_SENSE) |\n\t\t\t\t    STATUS_BYTE(qdonep->d3.scsi_stat);\n\t\t\t} else {\n\t\t\t\tscp->result = STATUS_BYTE(qdonep->d3.scsi_stat);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* QHSTA error occurred */\n\t\t\tASC_DBG(1, \"host_stat 0x%x\\n\", qdonep->d3.host_stat);\n\t\t\tscp->result = HOST_BYTE(DID_BAD_TARGET);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase QD_ABORTED_BY_HOST:\n\t\tASC_DBG(1, \"QD_ABORTED_BY_HOST\\n\");\n\t\tscp->result =\n\t\t    HOST_BYTE(DID_ABORT) | MSG_BYTE(qdonep->d3.\n\t\t\t\t\t\t    scsi_msg) |\n\t\t    STATUS_BYTE(qdonep->d3.scsi_stat);\n\t\tbreak;\n\n\tdefault:\n\t\tASC_DBG(1, \"done_stat 0x%x\\n\", qdonep->d3.done_stat);\n\t\tscp->result =\n\t\t    HOST_BYTE(DID_ERROR) | MSG_BYTE(qdonep->d3.\n\t\t\t\t\t\t    scsi_msg) |\n\t\t    STATUS_BYTE(qdonep->d3.scsi_stat);\n\t\tbreak;\n\t}\n\n\t/*\n\t * If the 'init_tidmask' bit isn't already set for the target and the\n\t * current request finished normally, then set the bit for the target\n\t * to indicate that a device is present.\n\t */\n\tif ((boardp->init_tidmask & ADV_TID_TO_TIDMASK(scp->device->id)) == 0 &&\n\t    qdonep->d3.done_stat == QD_NO_ERROR &&\n\t    qdonep->d3.host_stat == QHSTA_NO_ERROR) {\n\t\tboardp->init_tidmask |= ADV_TID_TO_TIDMASK(scp->device->id);\n\t}\n\n\tasc_scsi_done(scp);\n}\n\nstatic int AscIsrQDone(ASC_DVC_VAR *asc_dvc)\n{\n\tuchar next_qp;\n\tuchar n_q_used;\n\tuchar sg_list_qp;\n\tuchar sg_queue_cnt;\n\tuchar q_cnt;\n\tuchar done_q_tail;\n\tuchar tid_no;\n\tASC_SCSI_BIT_ID_TYPE scsi_busy;\n\tASC_SCSI_BIT_ID_TYPE target_id;\n\tPortAddr iop_base;\n\tushort q_addr;\n\tushort sg_q_addr;\n\tuchar cur_target_qng;\n\tASC_QDONE_INFO scsiq_buf;\n\tASC_QDONE_INFO *scsiq;\n\tbool false_overrun;\n\n\tiop_base = asc_dvc->iop_base;\n\tn_q_used = 1;\n\tscsiq = (ASC_QDONE_INFO *)&scsiq_buf;\n\tdone_q_tail = (uchar)AscGetVarDoneQTail(iop_base);\n\tq_addr = ASC_QNO_TO_QADDR(done_q_tail);\n\tnext_qp = AscReadLramByte(iop_base,\n\t\t\t\t  (ushort)(q_addr + (ushort)ASC_SCSIQ_B_FWD));\n\tif (next_qp != ASC_QLINK_END) {\n\t\tAscPutVarDoneQTail(iop_base, next_qp);\n\t\tq_addr = ASC_QNO_TO_QADDR(next_qp);\n\t\tsg_queue_cnt = _AscCopyLramScsiDoneQ(iop_base, q_addr, scsiq,\n\t\t\t\t\t\t     asc_dvc->max_dma_count);\n\t\tAscWriteLramByte(iop_base,\n\t\t\t\t (ushort)(q_addr +\n\t\t\t\t\t  (ushort)ASC_SCSIQ_B_STATUS),\n\t\t\t\t (uchar)(scsiq->\n\t\t\t\t\t q_status & (uchar)~(QS_READY |\n\t\t\t\t\t\t\t     QS_ABORTED)));\n\t\ttid_no = ASC_TIX_TO_TID(scsiq->d2.target_ix);\n\t\ttarget_id = ASC_TIX_TO_TARGET_ID(scsiq->d2.target_ix);\n\t\tif ((scsiq->cntl & QC_SG_HEAD) != 0) {\n\t\t\tsg_q_addr = q_addr;\n\t\t\tsg_list_qp = next_qp;\n\t\t\tfor (q_cnt = 0; q_cnt < sg_queue_cnt; q_cnt++) {\n\t\t\t\tsg_list_qp = AscReadLramByte(iop_base,\n\t\t\t\t\t\t\t     (ushort)(sg_q_addr\n\t\t\t\t\t\t\t\t      + (ushort)\n\t\t\t\t\t\t\t\t      ASC_SCSIQ_B_FWD));\n\t\t\t\tsg_q_addr = ASC_QNO_TO_QADDR(sg_list_qp);\n\t\t\t\tif (sg_list_qp == ASC_QLINK_END) {\n\t\t\t\t\tAscSetLibErrorCode(asc_dvc,\n\t\t\t\t\t\t\t   ASCQ_ERR_SG_Q_LINKS);\n\t\t\t\t\tscsiq->d3.done_stat = QD_WITH_ERROR;\n\t\t\t\t\tscsiq->d3.host_stat =\n\t\t\t\t\t    QHSTA_D_QDONE_SG_LIST_CORRUPTED;\n\t\t\t\t\tgoto FATAL_ERR_QDONE;\n\t\t\t\t}\n\t\t\t\tAscWriteLramByte(iop_base,\n\t\t\t\t\t\t (ushort)(sg_q_addr + (ushort)\n\t\t\t\t\t\t\t  ASC_SCSIQ_B_STATUS),\n\t\t\t\t\t\t QS_FREE);\n\t\t\t}\n\t\t\tn_q_used = sg_queue_cnt + 1;\n\t\t\tAscPutVarDoneQTail(iop_base, sg_list_qp);\n\t\t}\n\t\tif (asc_dvc->queue_full_or_busy & target_id) {\n\t\t\tcur_target_qng = AscReadLramByte(iop_base,\n\t\t\t\t\t\t\t (ushort)((ushort)\n\t\t\t\t\t\t\t\t  ASC_QADR_BEG\n\t\t\t\t\t\t\t\t  + (ushort)\n\t\t\t\t\t\t\t\t  scsiq->d2.\n\t\t\t\t\t\t\t\t  target_ix));\n\t\t\tif (cur_target_qng < asc_dvc->max_dvc_qng[tid_no]) {\n\t\t\t\tscsi_busy = AscReadLramByte(iop_base, (ushort)\n\t\t\t\t\t\t\t    ASCV_SCSIBUSY_B);\n\t\t\t\tscsi_busy &= ~target_id;\n\t\t\t\tAscWriteLramByte(iop_base,\n\t\t\t\t\t\t (ushort)ASCV_SCSIBUSY_B,\n\t\t\t\t\t\t scsi_busy);\n\t\t\t\tasc_dvc->queue_full_or_busy &= ~target_id;\n\t\t\t}\n\t\t}\n\t\tif (asc_dvc->cur_total_qng >= n_q_used) {\n\t\t\tasc_dvc->cur_total_qng -= n_q_used;\n\t\t\tif (asc_dvc->cur_dvc_qng[tid_no] != 0) {\n\t\t\t\tasc_dvc->cur_dvc_qng[tid_no]--;\n\t\t\t}\n\t\t} else {\n\t\t\tAscSetLibErrorCode(asc_dvc, ASCQ_ERR_CUR_QNG);\n\t\t\tscsiq->d3.done_stat = QD_WITH_ERROR;\n\t\t\tgoto FATAL_ERR_QDONE;\n\t\t}\n\t\tif ((scsiq->d2.srb_tag == 0UL) ||\n\t\t    ((scsiq->q_status & QS_ABORTED) != 0)) {\n\t\t\treturn (0x11);\n\t\t} else if (scsiq->q_status == QS_DONE) {\n\t\t\t/*\n\t\t\t * This is also curious.\n\t\t\t * false_overrun will _always_ be set to 'false'\n\t\t\t */\n\t\t\tfalse_overrun = false;\n\t\t\tif (scsiq->extra_bytes != 0) {\n\t\t\t\tscsiq->remain_bytes += scsiq->extra_bytes;\n\t\t\t}\n\t\t\tif (scsiq->d3.done_stat == QD_WITH_ERROR) {\n\t\t\t\tif (scsiq->d3.host_stat ==\n\t\t\t\t    QHSTA_M_DATA_OVER_RUN) {\n\t\t\t\t\tif ((scsiq->\n\t\t\t\t\t     cntl & (QC_DATA_IN | QC_DATA_OUT))\n\t\t\t\t\t    == 0) {\n\t\t\t\t\t\tscsiq->d3.done_stat =\n\t\t\t\t\t\t    QD_NO_ERROR;\n\t\t\t\t\t\tscsiq->d3.host_stat =\n\t\t\t\t\t\t    QHSTA_NO_ERROR;\n\t\t\t\t\t} else if (false_overrun) {\n\t\t\t\t\t\tscsiq->d3.done_stat =\n\t\t\t\t\t\t    QD_NO_ERROR;\n\t\t\t\t\t\tscsiq->d3.host_stat =\n\t\t\t\t\t\t    QHSTA_NO_ERROR;\n\t\t\t\t\t}\n\t\t\t\t} else if (scsiq->d3.host_stat ==\n\t\t\t\t\t   QHSTA_M_HUNG_REQ_SCSI_BUS_RESET) {\n\t\t\t\t\tAscStopChip(iop_base);\n\t\t\t\t\tAscSetChipControl(iop_base,\n\t\t\t\t\t\t\t  (uchar)(CC_SCSI_RESET\n\t\t\t\t\t\t\t\t  | CC_HALT));\n\t\t\t\t\tudelay(60);\n\t\t\t\t\tAscSetChipControl(iop_base, CC_HALT);\n\t\t\t\t\tAscSetChipStatus(iop_base,\n\t\t\t\t\t\t\t CIW_CLR_SCSI_RESET_INT);\n\t\t\t\t\tAscSetChipStatus(iop_base, 0);\n\t\t\t\t\tAscSetChipControl(iop_base, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((scsiq->cntl & QC_NO_CALLBACK) == 0) {\n\t\t\t\tasc_isr_callback(asc_dvc, scsiq);\n\t\t\t} else {\n\t\t\t\tif ((AscReadLramByte(iop_base,\n\t\t\t\t\t\t     (ushort)(q_addr + (ushort)\n\t\t\t\t\t\t\t      ASC_SCSIQ_CDB_BEG))\n\t\t\t\t     == START_STOP)) {\n\t\t\t\t\tasc_dvc->unit_not_ready &= ~target_id;\n\t\t\t\t\tif (scsiq->d3.done_stat != QD_NO_ERROR) {\n\t\t\t\t\t\tasc_dvc->start_motor &=\n\t\t\t\t\t\t    ~target_id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (1);\n\t\t} else {\n\t\t\tAscSetLibErrorCode(asc_dvc, ASCQ_ERR_Q_STATUS);\n FATAL_ERR_QDONE:\n\t\t\tif ((scsiq->cntl & QC_NO_CALLBACK) == 0) {\n\t\t\t\tasc_isr_callback(asc_dvc, scsiq);\n\t\t\t}\n\t\t\treturn (0x80);\n\t\t}\n\t}\n\treturn (0);\n}\n\nstatic int AscISR(ASC_DVC_VAR *asc_dvc)\n{\n\tASC_CS_TYPE chipstat;\n\tPortAddr iop_base;\n\tushort saved_ram_addr;\n\tuchar ctrl_reg;\n\tuchar saved_ctrl_reg;\n\tint int_pending;\n\tint status;\n\tuchar host_flag;\n\n\tiop_base = asc_dvc->iop_base;\n\tint_pending = ASC_FALSE;\n\n\tif (AscIsIntPending(iop_base) == 0)\n\t\treturn int_pending;\n\n\tif ((asc_dvc->init_state & ASC_INIT_STATE_END_LOAD_MC) == 0) {\n\t\treturn ASC_ERROR;\n\t}\n\tif (asc_dvc->in_critical_cnt != 0) {\n\t\tAscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_ON_CRITICAL);\n\t\treturn ASC_ERROR;\n\t}\n\tif (asc_dvc->is_in_int) {\n\t\tAscSetLibErrorCode(asc_dvc, ASCQ_ERR_ISR_RE_ENTRY);\n\t\treturn ASC_ERROR;\n\t}\n\tasc_dvc->is_in_int = true;\n\tctrl_reg = AscGetChipControl(iop_base);\n\tsaved_ctrl_reg = ctrl_reg & (~(CC_SCSI_RESET | CC_CHIP_RESET |\n\t\t\t\t       CC_SINGLE_STEP | CC_DIAG | CC_TEST));\n\tchipstat = AscGetChipStatus(iop_base);\n\tif (chipstat & CSW_SCSI_RESET_LATCH) {\n\t\tif (!(asc_dvc->bus_type & (ASC_IS_VL | ASC_IS_EISA))) {\n\t\t\tint i = 10;\n\t\t\tint_pending = ASC_TRUE;\n\t\t\tasc_dvc->sdtr_done = 0;\n\t\t\tsaved_ctrl_reg &= (uchar)(~CC_HALT);\n\t\t\twhile ((AscGetChipStatus(iop_base) &\n\t\t\t\tCSW_SCSI_RESET_ACTIVE) && (i-- > 0)) {\n\t\t\t\tmdelay(100);\n\t\t\t}\n\t\t\tAscSetChipControl(iop_base, (CC_CHIP_RESET | CC_HALT));\n\t\t\tAscSetChipControl(iop_base, CC_HALT);\n\t\t\tAscSetChipStatus(iop_base, CIW_CLR_SCSI_RESET_INT);\n\t\t\tAscSetChipStatus(iop_base, 0);\n\t\t\tchipstat = AscGetChipStatus(iop_base);\n\t\t}\n\t}\n\tsaved_ram_addr = AscGetChipLramAddr(iop_base);\n\thost_flag = AscReadLramByte(iop_base,\n\t\t\t\t    ASCV_HOST_FLAG_B) &\n\t    (uchar)(~ASC_HOST_FLAG_IN_ISR);\n\tAscWriteLramByte(iop_base, ASCV_HOST_FLAG_B,\n\t\t\t (uchar)(host_flag | (uchar)ASC_HOST_FLAG_IN_ISR));\n\tif ((chipstat & CSW_INT_PENDING) || (int_pending)) {\n\t\tAscAckInterrupt(iop_base);\n\t\tint_pending = ASC_TRUE;\n\t\tif ((chipstat & CSW_HALTED) && (ctrl_reg & CC_SINGLE_STEP)) {\n\t\t\tAscIsrChipHalted(asc_dvc);\n\t\t\tsaved_ctrl_reg &= (uchar)(~CC_HALT);\n\t\t} else {\n\t\t\tif ((asc_dvc->dvc_cntl & ASC_CNTL_INT_MULTI_Q) != 0) {\n\t\t\t\twhile (((status =\n\t\t\t\t\t AscIsrQDone(asc_dvc)) & 0x01) != 0) {\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tif ((status =\n\t\t\t\t\t     AscIsrQDone(asc_dvc)) == 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} while (status == 0x11);\n\t\t\t}\n\t\t\tif ((status & 0x80) != 0)\n\t\t\t\tint_pending = ASC_ERROR;\n\t\t}\n\t}\n\tAscWriteLramByte(iop_base, ASCV_HOST_FLAG_B, host_flag);\n\tAscSetChipLramAddr(iop_base, saved_ram_addr);\n\tAscSetChipControl(iop_base, saved_ctrl_reg);\n\tasc_dvc->is_in_int = false;\n\treturn int_pending;\n}\n\n/*\n * advansys_reset()\n *\n * Reset the host associated with the command 'scp'.\n *\n * This function runs its own thread. Interrupts must be blocked but\n * sleeping is allowed and no locking other than for host structures is\n * required. Returns SUCCESS or FAILED.\n */\nstatic int advansys_reset(struct scsi_cmnd *scp)\n{\n\tstruct Scsi_Host *shost = scp->device->host;\n\tstruct asc_board *boardp = shost_priv(shost);\n\tunsigned long flags;\n\tint status;\n\tint ret = SUCCESS;\n\n\tASC_DBG(1, \"0x%p\\n\", scp);\n\n\tASC_STATS(shost, reset);\n\n\tscmd_printk(KERN_INFO, scp, \"SCSI host reset started...\\n\");\n\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;\n\n\t\t/* Reset the chip and SCSI bus. */\n\t\tASC_DBG(1, \"before AscInitAsc1000Driver()\\n\");\n\t\tstatus = AscInitAsc1000Driver(asc_dvc);\n\n\t\t/* Refer to ASC_IERR_* definitions for meaning of 'err_code'. */\n\t\tif (asc_dvc->err_code || !asc_dvc->overrun_dma) {\n\t\t\tscmd_printk(KERN_INFO, scp, \"SCSI host reset error: \"\n\t\t\t\t    \"0x%x, status: 0x%x\\n\", asc_dvc->err_code,\n\t\t\t\t    status);\n\t\t\tret = FAILED;\n\t\t} else if (status) {\n\t\t\tscmd_printk(KERN_INFO, scp, \"SCSI host reset warning: \"\n\t\t\t\t    \"0x%x\\n\", status);\n\t\t} else {\n\t\t\tscmd_printk(KERN_INFO, scp, \"SCSI host reset \"\n\t\t\t\t    \"successful\\n\");\n\t\t}\n\n\t\tASC_DBG(1, \"after AscInitAsc1000Driver()\\n\");\n\t} else {\n\t\t/*\n\t\t * If the suggest reset bus flags are set, then reset the bus.\n\t\t * Otherwise only reset the device.\n\t\t */\n\t\tADV_DVC_VAR *adv_dvc = &boardp->dvc_var.adv_dvc_var;\n\n\t\t/*\n\t\t * Reset the chip and SCSI bus.\n\t\t */\n\t\tASC_DBG(1, \"before AdvResetChipAndSB()\\n\");\n\t\tswitch (AdvResetChipAndSB(adv_dvc)) {\n\t\tcase ASC_TRUE:\n\t\t\tscmd_printk(KERN_INFO, scp, \"SCSI host reset \"\n\t\t\t\t    \"successful\\n\");\n\t\t\tbreak;\n\t\tcase ASC_FALSE:\n\t\tdefault:\n\t\t\tscmd_printk(KERN_INFO, scp, \"SCSI host reset error\\n\");\n\t\t\tret = FAILED;\n\t\t\tbreak;\n\t\t}\n\t\tspin_lock_irqsave(shost->host_lock, flags);\n\t\tAdvISR(adv_dvc);\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t}\n\n\tASC_DBG(1, \"ret %d\\n\", ret);\n\n\treturn ret;\n}\n\n/*\n * advansys_biosparam()\n *\n * Translate disk drive geometry if the \"BIOS greater than 1 GB\"\n * support is enabled for a drive.\n *\n * ip (information pointer) is an int array with the following definition:\n * ip[0]: heads\n * ip[1]: sectors\n * ip[2]: cylinders\n */\nstatic int\nadvansys_biosparam(struct scsi_device *sdev, struct block_device *bdev,\n\t\t   sector_t capacity, int ip[])\n{\n\tstruct asc_board *boardp = shost_priv(sdev->host);\n\n\tASC_DBG(1, \"begin\\n\");\n\tASC_STATS(sdev->host, biosparam);\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tif ((boardp->dvc_var.asc_dvc_var.dvc_cntl &\n\t\t     ASC_CNTL_BIOS_GT_1GB) && capacity > 0x200000) {\n\t\t\tip[0] = 255;\n\t\t\tip[1] = 63;\n\t\t} else {\n\t\t\tip[0] = 64;\n\t\t\tip[1] = 32;\n\t\t}\n\t} else {\n\t\tif ((boardp->dvc_var.adv_dvc_var.bios_ctrl &\n\t\t     BIOS_CTRL_EXTENDED_XLAT) && capacity > 0x200000) {\n\t\t\tip[0] = 255;\n\t\t\tip[1] = 63;\n\t\t} else {\n\t\t\tip[0] = 64;\n\t\t\tip[1] = 32;\n\t\t}\n\t}\n\tip[2] = (unsigned long)capacity / (ip[0] * ip[1]);\n\tASC_DBG(1, \"end\\n\");\n\treturn 0;\n}\n\n/*\n * First-level interrupt handler.\n *\n * 'dev_id' is a pointer to the interrupting adapter's Scsi_Host.\n */\nstatic irqreturn_t advansys_interrupt(int irq, void *dev_id)\n{\n\tstruct Scsi_Host *shost = dev_id;\n\tstruct asc_board *boardp = shost_priv(shost);\n\tirqreturn_t result = IRQ_NONE;\n\tunsigned long flags;\n\n\tASC_DBG(2, \"boardp 0x%p\\n\", boardp);\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tif (AscIsIntPending(shost->io_port)) {\n\t\t\tresult = IRQ_HANDLED;\n\t\t\tASC_STATS(shost, interrupt);\n\t\t\tASC_DBG(1, \"before AscISR()\\n\");\n\t\t\tAscISR(&boardp->dvc_var.asc_dvc_var);\n\t\t}\n\t} else {\n\t\tASC_DBG(1, \"before AdvISR()\\n\");\n\t\tif (AdvISR(&boardp->dvc_var.adv_dvc_var)) {\n\t\t\tresult = IRQ_HANDLED;\n\t\t\tASC_STATS(shost, interrupt);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tASC_DBG(1, \"end\\n\");\n\treturn result;\n}\n\nstatic bool AscHostReqRiscHalt(PortAddr iop_base)\n{\n\tint count = 0;\n\tbool sta = false;\n\tuchar saved_stop_code;\n\n\tif (AscIsChipHalted(iop_base))\n\t\treturn true;\n\tsaved_stop_code = AscReadLramByte(iop_base, ASCV_STOP_CODE_B);\n\tAscWriteLramByte(iop_base, ASCV_STOP_CODE_B,\n\t\t\t ASC_STOP_HOST_REQ_RISC_HALT | ASC_STOP_REQ_RISC_STOP);\n\tdo {\n\t\tif (AscIsChipHalted(iop_base)) {\n\t\t\tsta = true;\n\t\t\tbreak;\n\t\t}\n\t\tmdelay(100);\n\t} while (count++ < 20);\n\tAscWriteLramByte(iop_base, ASCV_STOP_CODE_B, saved_stop_code);\n\treturn sta;\n}\n\nstatic bool\nAscSetRunChipSynRegAtID(PortAddr iop_base, uchar tid_no, uchar sdtr_data)\n{\n\tbool sta = false;\n\n\tif (AscHostReqRiscHalt(iop_base)) {\n\t\tsta = AscSetChipSynRegAtID(iop_base, tid_no, sdtr_data);\n\t\tAscStartChip(iop_base);\n\t}\n\treturn sta;\n}\n\nstatic void AscAsyncFix(ASC_DVC_VAR *asc_dvc, struct scsi_device *sdev)\n{\n\tchar type = sdev->type;\n\tASC_SCSI_BIT_ID_TYPE tid_bits = 1 << sdev->id;\n\n\tif (!(asc_dvc->bug_fix_cntl & ASC_BUG_FIX_ASYN_USE_SYN))\n\t\treturn;\n\tif (asc_dvc->init_sdtr & tid_bits)\n\t\treturn;\n\n\tif ((type == TYPE_ROM) && (strncmp(sdev->vendor, \"HP \", 3) == 0))\n\t\tasc_dvc->pci_fix_asyn_xfer_always |= tid_bits;\n\n\tasc_dvc->pci_fix_asyn_xfer |= tid_bits;\n\tif ((type == TYPE_PROCESSOR) || (type == TYPE_SCANNER) ||\n\t    (type == TYPE_ROM) || (type == TYPE_TAPE))\n\t\tasc_dvc->pci_fix_asyn_xfer &= ~tid_bits;\n\n\tif (asc_dvc->pci_fix_asyn_xfer & tid_bits)\n\t\tAscSetRunChipSynRegAtID(asc_dvc->iop_base, sdev->id,\n\t\t\t\t\tASYN_SDTR_DATA_FIX_PCI_REV_AB);\n}\n\nstatic void\nadvansys_narrow_slave_configure(struct scsi_device *sdev, ASC_DVC_VAR *asc_dvc)\n{\n\tASC_SCSI_BIT_ID_TYPE tid_bit = 1 << sdev->id;\n\tASC_SCSI_BIT_ID_TYPE orig_use_tagged_qng = asc_dvc->use_tagged_qng;\n\n\tif (sdev->lun == 0) {\n\t\tASC_SCSI_BIT_ID_TYPE orig_init_sdtr = asc_dvc->init_sdtr;\n\t\tif ((asc_dvc->cfg->sdtr_enable & tid_bit) && sdev->sdtr) {\n\t\t\tasc_dvc->init_sdtr |= tid_bit;\n\t\t} else {\n\t\t\tasc_dvc->init_sdtr &= ~tid_bit;\n\t\t}\n\n\t\tif (orig_init_sdtr != asc_dvc->init_sdtr)\n\t\t\tAscAsyncFix(asc_dvc, sdev);\n\t}\n\n\tif (sdev->tagged_supported) {\n\t\tif (asc_dvc->cfg->cmd_qng_enabled & tid_bit) {\n\t\t\tif (sdev->lun == 0) {\n\t\t\t\tasc_dvc->cfg->can_tagged_qng |= tid_bit;\n\t\t\t\tasc_dvc->use_tagged_qng |= tid_bit;\n\t\t\t}\n\t\t\tscsi_change_queue_depth(sdev, \n\t\t\t\t\t\tasc_dvc->max_dvc_qng[sdev->id]);\n\t\t}\n\t} else {\n\t\tif (sdev->lun == 0) {\n\t\t\tasc_dvc->cfg->can_tagged_qng &= ~tid_bit;\n\t\t\tasc_dvc->use_tagged_qng &= ~tid_bit;\n\t\t}\n\t}\n\n\tif ((sdev->lun == 0) &&\n\t    (orig_use_tagged_qng != asc_dvc->use_tagged_qng)) {\n\t\tAscWriteLramByte(asc_dvc->iop_base, ASCV_DISC_ENABLE_B,\n\t\t\t\t asc_dvc->cfg->disc_enable);\n\t\tAscWriteLramByte(asc_dvc->iop_base, ASCV_USE_TAGGED_QNG_B,\n\t\t\t\t asc_dvc->use_tagged_qng);\n\t\tAscWriteLramByte(asc_dvc->iop_base, ASCV_CAN_TAGGED_QNG_B,\n\t\t\t\t asc_dvc->cfg->can_tagged_qng);\n\n\t\tasc_dvc->max_dvc_qng[sdev->id] =\n\t\t\t\t\tasc_dvc->cfg->max_tag_qng[sdev->id];\n\t\tAscWriteLramByte(asc_dvc->iop_base,\n\t\t\t\t (ushort)(ASCV_MAX_DVC_QNG_BEG + sdev->id),\n\t\t\t\t asc_dvc->max_dvc_qng[sdev->id]);\n\t}\n}\n\n/*\n * Wide Transfers\n *\n * If the EEPROM enabled WDTR for the device and the device supports wide\n * bus (16 bit) transfers, then turn on the device's 'wdtr_able' bit and\n * write the new value to the microcode.\n */\nstatic void\nadvansys_wide_enable_wdtr(AdvPortAddr iop_base, unsigned short tidmask)\n{\n\tunsigned short cfg_word;\n\tAdvReadWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);\n\tif ((cfg_word & tidmask) != 0)\n\t\treturn;\n\n\tcfg_word |= tidmask;\n\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_ABLE, cfg_word);\n\n\t/*\n\t * Clear the microcode SDTR and WDTR negotiation done indicators for\n\t * the target to cause it to negotiate with the new setting set above.\n\t * WDTR when accepted causes the target to enter asynchronous mode, so\n\t * SDTR must be negotiated.\n\t */\n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);\n\tcfg_word &= ~tidmask;\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);\n\tAdvReadWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);\n\tcfg_word &= ~tidmask;\n\tAdvWriteWordLram(iop_base, ASC_MC_WDTR_DONE, cfg_word);\n}\n\n/*\n * Synchronous Transfers\n *\n * If the EEPROM enabled SDTR for the device and the device\n * supports synchronous transfers, then turn on the device's\n * 'sdtr_able' bit. Write the new value to the microcode.\n */\nstatic void\nadvansys_wide_enable_sdtr(AdvPortAddr iop_base, unsigned short tidmask)\n{\n\tunsigned short cfg_word;\n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);\n\tif ((cfg_word & tidmask) != 0)\n\t\treturn;\n\n\tcfg_word |= tidmask;\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_ABLE, cfg_word);\n\n\t/*\n\t * Clear the microcode \"SDTR negotiation\" done indicator for the\n\t * target to cause it to negotiate with the new setting set above.\n\t */\n\tAdvReadWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);\n\tcfg_word &= ~tidmask;\n\tAdvWriteWordLram(iop_base, ASC_MC_SDTR_DONE, cfg_word);\n}\n\n/*\n * PPR (Parallel Protocol Request) Capable\n *\n * If the device supports DT mode, then it must be PPR capable.\n * The PPR message will be used in place of the SDTR and WDTR\n * messages to negotiate synchronous speed and offset, transfer\n * width, and protocol options.\n */\nstatic void advansys_wide_enable_ppr(ADV_DVC_VAR *adv_dvc,\n\t\t\t\tAdvPortAddr iop_base, unsigned short tidmask)\n{\n\tAdvReadWordLram(iop_base, ASC_MC_PPR_ABLE, adv_dvc->ppr_able);\n\tadv_dvc->ppr_able |= tidmask;\n\tAdvWriteWordLram(iop_base, ASC_MC_PPR_ABLE, adv_dvc->ppr_able);\n}\n\nstatic void\nadvansys_wide_slave_configure(struct scsi_device *sdev, ADV_DVC_VAR *adv_dvc)\n{\n\tAdvPortAddr iop_base = adv_dvc->iop_base;\n\tunsigned short tidmask = 1 << sdev->id;\n\n\tif (sdev->lun == 0) {\n\t\t/*\n\t\t * Handle WDTR, SDTR, and Tag Queuing. If the feature\n\t\t * is enabled in the EEPROM and the device supports the\n\t\t * feature, then enable it in the microcode.\n\t\t */\n\n\t\tif ((adv_dvc->wdtr_able & tidmask) && sdev->wdtr)\n\t\t\tadvansys_wide_enable_wdtr(iop_base, tidmask);\n\t\tif ((adv_dvc->sdtr_able & tidmask) && sdev->sdtr)\n\t\t\tadvansys_wide_enable_sdtr(iop_base, tidmask);\n\t\tif (adv_dvc->chip_type == ADV_CHIP_ASC38C1600 && sdev->ppr)\n\t\t\tadvansys_wide_enable_ppr(adv_dvc, iop_base, tidmask);\n\n\t\t/*\n\t\t * Tag Queuing is disabled for the BIOS which runs in polled\n\t\t * mode and would see no benefit from Tag Queuing. Also by\n\t\t * disabling Tag Queuing in the BIOS devices with Tag Queuing\n\t\t * bugs will at least work with the BIOS.\n\t\t */\n\t\tif ((adv_dvc->tagqng_able & tidmask) &&\n\t\t    sdev->tagged_supported) {\n\t\t\tunsigned short cfg_word;\n\t\t\tAdvReadWordLram(iop_base, ASC_MC_TAGQNG_ABLE, cfg_word);\n\t\t\tcfg_word |= tidmask;\n\t\t\tAdvWriteWordLram(iop_base, ASC_MC_TAGQNG_ABLE,\n\t\t\t\t\t cfg_word);\n\t\t\tAdvWriteByteLram(iop_base,\n\t\t\t\t\t ASC_MC_NUMBER_OF_MAX_CMD + sdev->id,\n\t\t\t\t\t adv_dvc->max_dvc_qng);\n\t\t}\n\t}\n\n\tif ((adv_dvc->tagqng_able & tidmask) && sdev->tagged_supported)\n\t\tscsi_change_queue_depth(sdev, adv_dvc->max_dvc_qng);\n}\n\n/*\n * Set the number of commands to queue per device for the\n * specified host adapter.\n */\nstatic int advansys_slave_configure(struct scsi_device *sdev)\n{\n\tstruct asc_board *boardp = shost_priv(sdev->host);\n\n\tif (ASC_NARROW_BOARD(boardp))\n\t\tadvansys_narrow_slave_configure(sdev,\n\t\t\t\t\t\t&boardp->dvc_var.asc_dvc_var);\n\telse\n\t\tadvansys_wide_slave_configure(sdev,\n\t\t\t\t\t\t&boardp->dvc_var.adv_dvc_var);\n\n\treturn 0;\n}\n\nstatic __le32 asc_get_sense_buffer_dma(struct scsi_cmnd *scp)\n{\n\tstruct asc_board *board = shost_priv(scp->device->host);\n\n\tscp->SCp.dma_handle = dma_map_single(board->dev, scp->sense_buffer,\n\t\t\t\t\t     SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t\t     DMA_FROM_DEVICE);\n\tif (dma_mapping_error(board->dev, scp->SCp.dma_handle)) {\n\t\tASC_DBG(1, \"failed to map sense buffer\\n\");\n\t\treturn 0;\n\t}\n\treturn cpu_to_le32(scp->SCp.dma_handle);\n}\n\nstatic int asc_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,\n\t\t\tstruct asc_scsi_q *asc_scsi_q)\n{\n\tstruct asc_dvc_var *asc_dvc = &boardp->dvc_var.asc_dvc_var;\n\tint use_sg;\n\tu32 srb_tag;\n\n\tmemset(asc_scsi_q, 0, sizeof(*asc_scsi_q));\n\n\t/*\n\t * Set the srb_tag to the command tag + 1, as\n\t * srb_tag '0' is used internally by the chip.\n\t */\n\tsrb_tag = scp->request->tag + 1;\n\tasc_scsi_q->q2.srb_tag = srb_tag;\n\n\t/*\n\t * Build the ASC_SCSI_Q request.\n\t */\n\tasc_scsi_q->cdbptr = &scp->cmnd[0];\n\tasc_scsi_q->q2.cdb_len = scp->cmd_len;\n\tasc_scsi_q->q1.target_id = ASC_TID_TO_TARGET_ID(scp->device->id);\n\tasc_scsi_q->q1.target_lun = scp->device->lun;\n\tasc_scsi_q->q2.target_ix =\n\t    ASC_TIDLUN_TO_IX(scp->device->id, scp->device->lun);\n\tasc_scsi_q->q1.sense_addr = asc_get_sense_buffer_dma(scp);\n\tasc_scsi_q->q1.sense_len = SCSI_SENSE_BUFFERSIZE;\n\tif (!asc_scsi_q->q1.sense_addr)\n\t\treturn ASC_BUSY;\n\n\t/*\n\t * If there are any outstanding requests for the current target,\n\t * then every 255th request send an ORDERED request. This heuristic\n\t * tries to retain the benefit of request sorting while preventing\n\t * request starvation. 255 is the max number of tags or pending commands\n\t * a device may have outstanding.\n\t *\n\t * The request count is incremented below for every successfully\n\t * started request.\n\t *\n\t */\n\tif ((asc_dvc->cur_dvc_qng[scp->device->id] > 0) &&\n\t    (boardp->reqcnt[scp->device->id] % 255) == 0) {\n\t\tasc_scsi_q->q2.tag_code = ORDERED_QUEUE_TAG;\n\t} else {\n\t\tasc_scsi_q->q2.tag_code = SIMPLE_QUEUE_TAG;\n\t}\n\n\t/* Build ASC_SCSI_Q */\n\tuse_sg = scsi_dma_map(scp);\n\tif (use_sg < 0) {\n\t\tASC_DBG(1, \"failed to map sglist\\n\");\n\t\treturn ASC_BUSY;\n\t} else if (use_sg > 0) {\n\t\tint sgcnt;\n\t\tstruct scatterlist *slp;\n\t\tstruct asc_sg_head *asc_sg_head;\n\n\t\tif (use_sg > scp->device->host->sg_tablesize) {\n\t\t\tscmd_printk(KERN_ERR, scp, \"use_sg %d > \"\n\t\t\t\t\"sg_tablesize %d\\n\", use_sg,\n\t\t\t\tscp->device->host->sg_tablesize);\n\t\t\tscsi_dma_unmap(scp);\n\t\t\tscp->result = HOST_BYTE(DID_ERROR);\n\t\t\treturn ASC_ERROR;\n\t\t}\n\n\t\tasc_sg_head = kzalloc(sizeof(asc_scsi_q->sg_head) +\n\t\t\tuse_sg * sizeof(struct asc_sg_list), GFP_ATOMIC);\n\t\tif (!asc_sg_head) {\n\t\t\tscsi_dma_unmap(scp);\n\t\t\tscp->result = HOST_BYTE(DID_SOFT_ERROR);\n\t\t\treturn ASC_ERROR;\n\t\t}\n\n\t\tasc_scsi_q->q1.cntl |= QC_SG_HEAD;\n\t\tasc_scsi_q->sg_head = asc_sg_head;\n\t\tasc_scsi_q->q1.data_cnt = 0;\n\t\tasc_scsi_q->q1.data_addr = 0;\n\t\t/* This is a byte value, otherwise it would need to be swapped. */\n\t\tasc_sg_head->entry_cnt = asc_scsi_q->q1.sg_queue_cnt = use_sg;\n\t\tASC_STATS_ADD(scp->device->host, xfer_elem,\n\t\t\t      asc_sg_head->entry_cnt);\n\n\t\t/*\n\t\t * Convert scatter-gather list into ASC_SG_HEAD list.\n\t\t */\n\t\tscsi_for_each_sg(scp, slp, use_sg, sgcnt) {\n\t\t\tasc_sg_head->sg_list[sgcnt].addr =\n\t\t\t    cpu_to_le32(sg_dma_address(slp));\n\t\t\tasc_sg_head->sg_list[sgcnt].bytes =\n\t\t\t    cpu_to_le32(sg_dma_len(slp));\n\t\t\tASC_STATS_ADD(scp->device->host, xfer_sect,\n\t\t\t\t      DIV_ROUND_UP(sg_dma_len(slp), 512));\n\t\t}\n\t}\n\n\tASC_STATS(scp->device->host, xfer_cnt);\n\n\tASC_DBG_PRT_ASC_SCSI_Q(2, asc_scsi_q);\n\tASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);\n\n\treturn ASC_NOERROR;\n}\n\n/*\n * Build scatter-gather list for Adv Library (Wide Board).\n *\n * Additional ADV_SG_BLOCK structures will need to be allocated\n * if the total number of scatter-gather elements exceeds\n * NO_OF_SG_PER_BLOCK (15). The ADV_SG_BLOCK structures are\n * assumed to be physically contiguous.\n *\n * Return:\n *      ADV_SUCCESS(1) - SG List successfully created\n *      ADV_ERROR(-1) - SG List creation failed\n */\nstatic int\nadv_get_sglist(struct asc_board *boardp, adv_req_t *reqp,\n\t       ADV_SCSI_REQ_Q *scsiqp, struct scsi_cmnd *scp, int use_sg)\n{\n\tadv_sgblk_t *sgblkp, *prev_sgblkp;\n\tstruct scatterlist *slp;\n\tint sg_elem_cnt;\n\tADV_SG_BLOCK *sg_block, *prev_sg_block;\n\tdma_addr_t sgblk_paddr;\n\tint i;\n\n\tslp = scsi_sglist(scp);\n\tsg_elem_cnt = use_sg;\n\tprev_sgblkp = NULL;\n\tprev_sg_block = NULL;\n\treqp->sgblkp = NULL;\n\n\tfor (;;) {\n\t\t/*\n\t\t * Allocate a 'adv_sgblk_t' structure from the board free\n\t\t * list. One 'adv_sgblk_t' structure holds NO_OF_SG_PER_BLOCK\n\t\t * (15) scatter-gather elements.\n\t\t */\n\t\tsgblkp = dma_pool_alloc(boardp->adv_sgblk_pool, GFP_ATOMIC,\n\t\t\t\t\t&sgblk_paddr);\n\t\tif (!sgblkp) {\n\t\t\tASC_DBG(1, \"no free adv_sgblk_t\\n\");\n\t\t\tASC_STATS(scp->device->host, adv_build_nosg);\n\n\t\t\t/*\n\t\t\t * Allocation failed. Free 'adv_sgblk_t' structures\n\t\t\t * already allocated for the request.\n\t\t\t */\n\t\t\twhile ((sgblkp = reqp->sgblkp) != NULL) {\n\t\t\t\t/* Remove 'sgblkp' from the request list. */\n\t\t\t\treqp->sgblkp = sgblkp->next_sgblkp;\n\t\t\t\tsgblkp->next_sgblkp = NULL;\n\t\t\t\tdma_pool_free(boardp->adv_sgblk_pool, sgblkp,\n\t\t\t\t\t      sgblkp->sg_addr);\n\t\t\t}\n\t\t\treturn ASC_BUSY;\n\t\t}\n\t\t/* Complete 'adv_sgblk_t' board allocation. */\n\t\tsgblkp->sg_addr = sgblk_paddr;\n\t\tsgblkp->next_sgblkp = NULL;\n\t\tsg_block = &sgblkp->sg_block;\n\n\t\t/*\n\t\t * Check if this is the first 'adv_sgblk_t' for the\n\t\t * request.\n\t\t */\n\t\tif (reqp->sgblkp == NULL) {\n\t\t\t/* Request's first scatter-gather block. */\n\t\t\treqp->sgblkp = sgblkp;\n\n\t\t\t/*\n\t\t\t * Set ADV_SCSI_REQ_T ADV_SG_BLOCK virtual and physical\n\t\t\t * address pointers.\n\t\t\t */\n\t\t\tscsiqp->sg_list_ptr = sg_block;\n\t\t\tscsiqp->sg_real_addr = cpu_to_le32(sgblk_paddr);\n\t\t} else {\n\t\t\t/* Request's second or later scatter-gather block. */\n\t\t\tprev_sgblkp->next_sgblkp = sgblkp;\n\n\t\t\t/*\n\t\t\t * Point the previous ADV_SG_BLOCK structure to\n\t\t\t * the newly allocated ADV_SG_BLOCK structure.\n\t\t\t */\n\t\t\tprev_sg_block->sg_ptr = cpu_to_le32(sgblk_paddr);\n\t\t}\n\n\t\tfor (i = 0; i < NO_OF_SG_PER_BLOCK; i++) {\n\t\t\tsg_block->sg_list[i].sg_addr =\n\t\t\t\t\tcpu_to_le32(sg_dma_address(slp));\n\t\t\tsg_block->sg_list[i].sg_count =\n\t\t\t\t\tcpu_to_le32(sg_dma_len(slp));\n\t\t\tASC_STATS_ADD(scp->device->host, xfer_sect,\n\t\t\t\t      DIV_ROUND_UP(sg_dma_len(slp), 512));\n\n\t\t\tif (--sg_elem_cnt == 0) {\n\t\t\t\t/*\n\t\t\t\t * Last ADV_SG_BLOCK and scatter-gather entry.\n\t\t\t\t */\n\t\t\t\tsg_block->sg_cnt = i + 1;\n\t\t\t\tsg_block->sg_ptr = 0L; /* Last ADV_SG_BLOCK in list. */\n\t\t\t\treturn ADV_SUCCESS;\n\t\t\t}\n\t\t\tslp = sg_next(slp);\n\t\t}\n\t\tsg_block->sg_cnt = NO_OF_SG_PER_BLOCK;\n\t\tprev_sg_block = sg_block;\n\t\tprev_sgblkp = sgblkp;\n\t}\n}\n\n/*\n * Build a request structure for the Adv Library (Wide Board).\n *\n * If an adv_req_t can not be allocated to issue the request,\n * then return ASC_BUSY. If an error occurs, then return ASC_ERROR.\n *\n * Multi-byte fields in the ADV_SCSI_REQ_Q that are used by the\n * microcode for DMA addresses or math operations are byte swapped\n * to little-endian order.\n */\nstatic int\nadv_build_req(struct asc_board *boardp, struct scsi_cmnd *scp,\n\t      adv_req_t **adv_reqpp)\n{\n\tu32 srb_tag = scp->request->tag;\n\tadv_req_t *reqp;\n\tADV_SCSI_REQ_Q *scsiqp;\n\tint ret;\n\tint use_sg;\n\tdma_addr_t sense_addr;\n\n\t/*\n\t * Allocate an adv_req_t structure from the board to execute\n\t * the command.\n\t */\n\treqp = &boardp->adv_reqp[srb_tag];\n\tif (reqp->cmndp && reqp->cmndp != scp ) {\n\t\tASC_DBG(1, \"no free adv_req_t\\n\");\n\t\tASC_STATS(scp->device->host, adv_build_noreq);\n\t\treturn ASC_BUSY;\n\t}\n\n\treqp->req_addr = boardp->adv_reqp_addr + (srb_tag * sizeof(adv_req_t));\n\n\tscsiqp = &reqp->scsi_req_q;\n\n\t/*\n\t * Initialize the structure.\n\t */\n\tscsiqp->cntl = scsiqp->scsi_cntl = scsiqp->done_status = 0;\n\n\t/*\n\t * Set the srb_tag to the command tag.\n\t */\n\tscsiqp->srb_tag = srb_tag;\n\n\t/*\n\t * Set 'host_scribble' to point to the adv_req_t structure.\n\t */\n\treqp->cmndp = scp;\n\tscp->host_scribble = (void *)reqp;\n\n\t/*\n\t * Build the ADV_SCSI_REQ_Q request.\n\t */\n\n\t/* Set CDB length and copy it to the request structure.  */\n\tscsiqp->cdb_len = scp->cmd_len;\n\t/* Copy first 12 CDB bytes to cdb[]. */\n\tmemcpy(scsiqp->cdb, scp->cmnd, scp->cmd_len < 12 ? scp->cmd_len : 12);\n\t/* Copy last 4 CDB bytes, if present, to cdb16[]. */\n\tif (scp->cmd_len > 12) {\n\t\tint cdb16_len = scp->cmd_len - 12;\n\n\t\tmemcpy(scsiqp->cdb16, &scp->cmnd[12], cdb16_len);\n\t}\n\n\tscsiqp->target_id = scp->device->id;\n\tscsiqp->target_lun = scp->device->lun;\n\n\tsense_addr = dma_map_single(boardp->dev, scp->sense_buffer,\n\t\t\t\t    SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(boardp->dev, sense_addr)) {\n\t\tASC_DBG(1, \"failed to map sense buffer\\n\");\n\t\tASC_STATS(scp->device->host, adv_build_noreq);\n\t\treturn ASC_BUSY;\n\t}\n\tscsiqp->sense_addr = cpu_to_le32(sense_addr);\n\tscsiqp->sense_len = SCSI_SENSE_BUFFERSIZE;\n\n\t/* Build ADV_SCSI_REQ_Q */\n\n\tuse_sg = scsi_dma_map(scp);\n\tif (use_sg < 0) {\n\t\tASC_DBG(1, \"failed to map SG list\\n\");\n\t\tASC_STATS(scp->device->host, adv_build_noreq);\n\t\treturn ASC_BUSY;\n\t} else if (use_sg == 0) {\n\t\t/* Zero-length transfer */\n\t\treqp->sgblkp = NULL;\n\t\tscsiqp->data_cnt = 0;\n\n\t\tscsiqp->data_addr = 0;\n\t\tscsiqp->sg_list_ptr = NULL;\n\t\tscsiqp->sg_real_addr = 0;\n\t} else {\n\t\tif (use_sg > ADV_MAX_SG_LIST) {\n\t\t\tscmd_printk(KERN_ERR, scp, \"use_sg %d > \"\n\t\t\t\t   \"ADV_MAX_SG_LIST %d\\n\", use_sg,\n\t\t\t\t   scp->device->host->sg_tablesize);\n\t\t\tscsi_dma_unmap(scp);\n\t\t\tscp->result = HOST_BYTE(DID_ERROR);\n\t\t\treqp->cmndp = NULL;\n\t\t\tscp->host_scribble = NULL;\n\n\t\t\treturn ASC_ERROR;\n\t\t}\n\n\t\tscsiqp->data_cnt = cpu_to_le32(scsi_bufflen(scp));\n\n\t\tret = adv_get_sglist(boardp, reqp, scsiqp, scp, use_sg);\n\t\tif (ret != ADV_SUCCESS) {\n\t\t\tscsi_dma_unmap(scp);\n\t\t\tscp->result = HOST_BYTE(DID_ERROR);\n\t\t\treqp->cmndp = NULL;\n\t\t\tscp->host_scribble = NULL;\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tASC_STATS_ADD(scp->device->host, xfer_elem, use_sg);\n\t}\n\n\tASC_STATS(scp->device->host, xfer_cnt);\n\n\tASC_DBG_PRT_ADV_SCSI_REQ_Q(2, scsiqp);\n\tASC_DBG_PRT_CDB(1, scp->cmnd, scp->cmd_len);\n\n\t*adv_reqpp = reqp;\n\n\treturn ASC_NOERROR;\n}\n\nstatic int AscSgListToQueue(int sg_list)\n{\n\tint n_sg_list_qs;\n\n\tn_sg_list_qs = ((sg_list - 1) / ASC_SG_LIST_PER_Q);\n\tif (((sg_list - 1) % ASC_SG_LIST_PER_Q) != 0)\n\t\tn_sg_list_qs++;\n\treturn n_sg_list_qs + 1;\n}\n\nstatic uint\nAscGetNumOfFreeQueue(ASC_DVC_VAR *asc_dvc, uchar target_ix, uchar n_qs)\n{\n\tuint cur_used_qs;\n\tuint cur_free_qs;\n\tASC_SCSI_BIT_ID_TYPE target_id;\n\tuchar tid_no;\n\n\ttarget_id = ASC_TIX_TO_TARGET_ID(target_ix);\n\ttid_no = ASC_TIX_TO_TID(target_ix);\n\tif ((asc_dvc->unit_not_ready & target_id) ||\n\t    (asc_dvc->queue_full_or_busy & target_id)) {\n\t\treturn 0;\n\t}\n\tif (n_qs == 1) {\n\t\tcur_used_qs = (uint) asc_dvc->cur_total_qng +\n\t\t    (uint) asc_dvc->last_q_shortage + (uint) ASC_MIN_FREE_Q;\n\t} else {\n\t\tcur_used_qs = (uint) asc_dvc->cur_total_qng +\n\t\t    (uint) ASC_MIN_FREE_Q;\n\t}\n\tif ((uint) (cur_used_qs + n_qs) <= (uint) asc_dvc->max_total_qng) {\n\t\tcur_free_qs = (uint) asc_dvc->max_total_qng - cur_used_qs;\n\t\tif (asc_dvc->cur_dvc_qng[tid_no] >=\n\t\t    asc_dvc->max_dvc_qng[tid_no]) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn cur_free_qs;\n\t}\n\tif (n_qs > 1) {\n\t\tif ((n_qs > asc_dvc->last_q_shortage)\n\t\t    && (n_qs <= (asc_dvc->max_total_qng - ASC_MIN_FREE_Q))) {\n\t\t\tasc_dvc->last_q_shortage = n_qs;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic uchar AscAllocFreeQueue(PortAddr iop_base, uchar free_q_head)\n{\n\tushort q_addr;\n\tuchar next_qp;\n\tuchar q_status;\n\n\tq_addr = ASC_QNO_TO_QADDR(free_q_head);\n\tq_status = (uchar)AscReadLramByte(iop_base,\n\t\t\t\t\t  (ushort)(q_addr +\n\t\t\t\t\t\t   ASC_SCSIQ_B_STATUS));\n\tnext_qp = AscReadLramByte(iop_base, (ushort)(q_addr + ASC_SCSIQ_B_FWD));\n\tif (((q_status & QS_READY) == 0) && (next_qp != ASC_QLINK_END))\n\t\treturn next_qp;\n\treturn ASC_QLINK_END;\n}\n\nstatic uchar\nAscAllocMultipleFreeQueue(PortAddr iop_base, uchar free_q_head, uchar n_free_q)\n{\n\tuchar i;\n\n\tfor (i = 0; i < n_free_q; i++) {\n\t\tfree_q_head = AscAllocFreeQueue(iop_base, free_q_head);\n\t\tif (free_q_head == ASC_QLINK_END)\n\t\t\tbreak;\n\t}\n\treturn free_q_head;\n}\n\n/*\n * void\n * DvcPutScsiQ(PortAddr iop_base, ushort s_addr, uchar *outbuf, int words)\n *\n * Calling/Exit State:\n *    none\n *\n * Description:\n *     Output an ASC_SCSI_Q structure to the chip\n */\nstatic void\nDvcPutScsiQ(PortAddr iop_base, ushort s_addr, uchar *outbuf, int words)\n{\n\tint i;\n\n\tASC_DBG_PRT_HEX(2, \"DvcPutScsiQ\", outbuf, 2 * words);\n\tAscSetChipLramAddr(iop_base, s_addr);\n\tfor (i = 0; i < 2 * words; i += 2) {\n\t\tif (i == 4 || i == 20) {\n\t\t\tcontinue;\n\t\t}\n\t\toutpw(iop_base + IOP_RAM_DATA,\n\t\t      ((ushort)outbuf[i + 1] << 8) | outbuf[i]);\n\t}\n}\n\nstatic int AscPutReadyQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)\n{\n\tushort q_addr;\n\tuchar tid_no;\n\tuchar sdtr_data;\n\tuchar syn_period_ix;\n\tuchar syn_offset;\n\tPortAddr iop_base;\n\n\tiop_base = asc_dvc->iop_base;\n\tif (((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0) &&\n\t    ((asc_dvc->sdtr_done & scsiq->q1.target_id) == 0)) {\n\t\ttid_no = ASC_TIX_TO_TID(scsiq->q2.target_ix);\n\t\tsdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);\n\t\tsyn_period_ix =\n\t\t    (sdtr_data >> 4) & (asc_dvc->max_sdtr_index - 1);\n\t\tsyn_offset = sdtr_data & ASC_SYN_MAX_OFFSET;\n\t\tAscMsgOutSDTR(asc_dvc,\n\t\t\t      asc_dvc->sdtr_period_tbl[syn_period_ix],\n\t\t\t      syn_offset);\n\t\tscsiq->q1.cntl |= QC_MSG_OUT;\n\t}\n\tq_addr = ASC_QNO_TO_QADDR(q_no);\n\tif ((scsiq->q1.target_id & asc_dvc->use_tagged_qng) == 0) {\n\t\tscsiq->q2.tag_code &= ~SIMPLE_QUEUE_TAG;\n\t}\n\tscsiq->q1.status = QS_FREE;\n\tAscMemWordCopyPtrToLram(iop_base,\n\t\t\t\tq_addr + ASC_SCSIQ_CDB_BEG,\n\t\t\t\t(uchar *)scsiq->cdbptr, scsiq->q2.cdb_len >> 1);\n\n\tDvcPutScsiQ(iop_base,\n\t\t    q_addr + ASC_SCSIQ_CPY_BEG,\n\t\t    (uchar *)&scsiq->q1.cntl,\n\t\t    ((sizeof(ASC_SCSIQ_1) + sizeof(ASC_SCSIQ_2)) / 2) - 1);\n\tAscWriteLramWord(iop_base,\n\t\t\t (ushort)(q_addr + (ushort)ASC_SCSIQ_B_STATUS),\n\t\t\t (ushort)(((ushort)scsiq->q1.\n\t\t\t\t   q_no << 8) | (ushort)QS_READY));\n\treturn 1;\n}\n\nstatic int\nAscPutReadySgListQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar q_no)\n{\n\tint sta;\n\tint i;\n\tASC_SG_HEAD *sg_head;\n\tASC_SG_LIST_Q scsi_sg_q;\n\t__le32 saved_data_addr;\n\t__le32 saved_data_cnt;\n\tPortAddr iop_base;\n\tushort sg_list_dwords;\n\tushort sg_index;\n\tushort sg_entry_cnt;\n\tushort q_addr;\n\tuchar next_qp;\n\n\tiop_base = asc_dvc->iop_base;\n\tsg_head = scsiq->sg_head;\n\tsaved_data_addr = scsiq->q1.data_addr;\n\tsaved_data_cnt = scsiq->q1.data_cnt;\n\tscsiq->q1.data_addr = cpu_to_le32(sg_head->sg_list[0].addr);\n\tscsiq->q1.data_cnt = cpu_to_le32(sg_head->sg_list[0].bytes);\n\t/*\n\t * Set sg_entry_cnt to be the number of SG elements that\n\t * will fit in the allocated SG queues. It is minus 1, because\n\t * the first SG element is handled above.\n\t */\n\tsg_entry_cnt = sg_head->entry_cnt - 1;\n\n\tif (sg_entry_cnt != 0) {\n\t\tscsiq->q1.cntl |= QC_SG_HEAD;\n\t\tq_addr = ASC_QNO_TO_QADDR(q_no);\n\t\tsg_index = 1;\n\t\tscsiq->q1.sg_queue_cnt = sg_head->queue_cnt;\n\t\tscsi_sg_q.sg_head_qp = q_no;\n\t\tscsi_sg_q.cntl = QCSG_SG_XFER_LIST;\n\t\tfor (i = 0; i < sg_head->queue_cnt; i++) {\n\t\t\tscsi_sg_q.seq_no = i + 1;\n\t\t\tif (sg_entry_cnt > ASC_SG_LIST_PER_Q) {\n\t\t\t\tsg_list_dwords = (uchar)(ASC_SG_LIST_PER_Q * 2);\n\t\t\t\tsg_entry_cnt -= ASC_SG_LIST_PER_Q;\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tscsi_sg_q.sg_list_cnt =\n\t\t\t\t\t    ASC_SG_LIST_PER_Q;\n\t\t\t\t\tscsi_sg_q.sg_cur_list_cnt =\n\t\t\t\t\t    ASC_SG_LIST_PER_Q;\n\t\t\t\t} else {\n\t\t\t\t\tscsi_sg_q.sg_list_cnt =\n\t\t\t\t\t    ASC_SG_LIST_PER_Q - 1;\n\t\t\t\t\tscsi_sg_q.sg_cur_list_cnt =\n\t\t\t\t\t    ASC_SG_LIST_PER_Q - 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tscsi_sg_q.cntl |= QCSG_SG_XFER_END;\n\t\t\t\tsg_list_dwords = sg_entry_cnt << 1;\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tscsi_sg_q.sg_list_cnt = sg_entry_cnt;\n\t\t\t\t\tscsi_sg_q.sg_cur_list_cnt =\n\t\t\t\t\t    sg_entry_cnt;\n\t\t\t\t} else {\n\t\t\t\t\tscsi_sg_q.sg_list_cnt =\n\t\t\t\t\t    sg_entry_cnt - 1;\n\t\t\t\t\tscsi_sg_q.sg_cur_list_cnt =\n\t\t\t\t\t    sg_entry_cnt - 1;\n\t\t\t\t}\n\t\t\t\tsg_entry_cnt = 0;\n\t\t\t}\n\t\t\tnext_qp = AscReadLramByte(iop_base,\n\t\t\t\t\t\t  (ushort)(q_addr +\n\t\t\t\t\t\t\t   ASC_SCSIQ_B_FWD));\n\t\t\tscsi_sg_q.q_no = next_qp;\n\t\t\tq_addr = ASC_QNO_TO_QADDR(next_qp);\n\t\t\tAscMemWordCopyPtrToLram(iop_base,\n\t\t\t\t\t\tq_addr + ASC_SCSIQ_SGHD_CPY_BEG,\n\t\t\t\t\t\t(uchar *)&scsi_sg_q,\n\t\t\t\t\t\tsizeof(ASC_SG_LIST_Q) >> 1);\n\t\t\tAscMemDWordCopyPtrToLram(iop_base,\n\t\t\t\t\t\t q_addr + ASC_SGQ_LIST_BEG,\n\t\t\t\t\t\t (uchar *)&sg_head->\n\t\t\t\t\t\t sg_list[sg_index],\n\t\t\t\t\t\t sg_list_dwords);\n\t\t\tsg_index += ASC_SG_LIST_PER_Q;\n\t\t\tscsiq->next_sg_index = sg_index;\n\t\t}\n\t} else {\n\t\tscsiq->q1.cntl &= ~QC_SG_HEAD;\n\t}\n\tsta = AscPutReadyQueue(asc_dvc, scsiq, q_no);\n\tscsiq->q1.data_addr = saved_data_addr;\n\tscsiq->q1.data_cnt = saved_data_cnt;\n\treturn (sta);\n}\n\nstatic int\nAscSendScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq, uchar n_q_required)\n{\n\tPortAddr iop_base;\n\tuchar free_q_head;\n\tuchar next_qp;\n\tuchar tid_no;\n\tuchar target_ix;\n\tint sta;\n\n\tiop_base = asc_dvc->iop_base;\n\ttarget_ix = scsiq->q2.target_ix;\n\ttid_no = ASC_TIX_TO_TID(target_ix);\n\tsta = 0;\n\tfree_q_head = (uchar)AscGetVarFreeQHead(iop_base);\n\tif (n_q_required > 1) {\n\t\tnext_qp = AscAllocMultipleFreeQueue(iop_base, free_q_head,\n\t\t\t\t\t\t    (uchar)n_q_required);\n\t\tif (next_qp != ASC_QLINK_END) {\n\t\t\tasc_dvc->last_q_shortage = 0;\n\t\t\tscsiq->sg_head->queue_cnt = n_q_required - 1;\n\t\t\tscsiq->q1.q_no = free_q_head;\n\t\t\tsta = AscPutReadySgListQueue(asc_dvc, scsiq,\n\t\t\t\t\t\t     free_q_head);\n\t\t}\n\t} else if (n_q_required == 1) {\n\t\tnext_qp = AscAllocFreeQueue(iop_base, free_q_head);\n\t\tif (next_qp != ASC_QLINK_END) {\n\t\t\tscsiq->q1.q_no = free_q_head;\n\t\t\tsta = AscPutReadyQueue(asc_dvc, scsiq, free_q_head);\n\t\t}\n\t}\n\tif (sta == 1) {\n\t\tAscPutVarFreeQHead(iop_base, next_qp);\n\t\tasc_dvc->cur_total_qng += n_q_required;\n\t\tasc_dvc->cur_dvc_qng[tid_no]++;\n\t}\n\treturn sta;\n}\n\n#define ASC_SYN_OFFSET_ONE_DISABLE_LIST  16\nstatic uchar _syn_offset_one_disable_cmd[ASC_SYN_OFFSET_ONE_DISABLE_LIST] = {\n\tINQUIRY,\n\tREQUEST_SENSE,\n\tREAD_CAPACITY,\n\tREAD_TOC,\n\tMODE_SELECT,\n\tMODE_SENSE,\n\tMODE_SELECT_10,\n\tMODE_SENSE_10,\n\t0xFF,\n\t0xFF,\n\t0xFF,\n\t0xFF,\n\t0xFF,\n\t0xFF,\n\t0xFF,\n\t0xFF\n};\n\nstatic int AscExeScsiQueue(ASC_DVC_VAR *asc_dvc, ASC_SCSI_Q *scsiq)\n{\n\tPortAddr iop_base;\n\tint sta;\n\tint n_q_required;\n\tbool disable_syn_offset_one_fix;\n\tint i;\n\tu32 addr;\n\tushort sg_entry_cnt = 0;\n\tushort sg_entry_cnt_minus_one = 0;\n\tuchar target_ix;\n\tuchar tid_no;\n\tuchar sdtr_data;\n\tuchar extra_bytes;\n\tuchar scsi_cmd;\n\tuchar disable_cmd;\n\tASC_SG_HEAD *sg_head;\n\tunsigned long data_cnt;\n\n\tiop_base = asc_dvc->iop_base;\n\tsg_head = scsiq->sg_head;\n\tif (asc_dvc->err_code != 0)\n\t\treturn ASC_ERROR;\n\tscsiq->q1.q_no = 0;\n\tif ((scsiq->q2.tag_code & ASC_TAG_FLAG_EXTRA_BYTES) == 0) {\n\t\tscsiq->q1.extra_bytes = 0;\n\t}\n\tsta = 0;\n\ttarget_ix = scsiq->q2.target_ix;\n\ttid_no = ASC_TIX_TO_TID(target_ix);\n\tn_q_required = 1;\n\tif (scsiq->cdbptr[0] == REQUEST_SENSE) {\n\t\tif ((asc_dvc->init_sdtr & scsiq->q1.target_id) != 0) {\n\t\t\tasc_dvc->sdtr_done &= ~scsiq->q1.target_id;\n\t\t\tsdtr_data = AscGetMCodeInitSDTRAtID(iop_base, tid_no);\n\t\t\tAscMsgOutSDTR(asc_dvc,\n\t\t\t\t      asc_dvc->\n\t\t\t\t      sdtr_period_tbl[(sdtr_data >> 4) &\n\t\t\t\t\t\t      (uchar)(asc_dvc->\n\t\t\t\t\t\t\t      max_sdtr_index -\n\t\t\t\t\t\t\t      1)],\n\t\t\t\t      (uchar)(sdtr_data & (uchar)\n\t\t\t\t\t      ASC_SYN_MAX_OFFSET));\n\t\t\tscsiq->q1.cntl |= (QC_MSG_OUT | QC_URGENT);\n\t\t}\n\t}\n\tif (asc_dvc->in_critical_cnt != 0) {\n\t\tAscSetLibErrorCode(asc_dvc, ASCQ_ERR_CRITICAL_RE_ENTRY);\n\t\treturn ASC_ERROR;\n\t}\n\tasc_dvc->in_critical_cnt++;\n\tif ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {\n\t\tif ((sg_entry_cnt = sg_head->entry_cnt) == 0) {\n\t\t\tasc_dvc->in_critical_cnt--;\n\t\t\treturn ASC_ERROR;\n\t\t}\n\t\tif (sg_entry_cnt > ASC_MAX_SG_LIST) {\n\t\t\tasc_dvc->in_critical_cnt--;\n\t\t\treturn ASC_ERROR;\n\t\t}\n\t\tif (sg_entry_cnt == 1) {\n\t\t\tscsiq->q1.data_addr = cpu_to_le32(sg_head->sg_list[0].addr);\n\t\t\tscsiq->q1.data_cnt = cpu_to_le32(sg_head->sg_list[0].bytes);\n\t\t\tscsiq->q1.cntl &= ~(QC_SG_HEAD | QC_SG_SWAP_QUEUE);\n\t\t}\n\t\tsg_entry_cnt_minus_one = sg_entry_cnt - 1;\n\t}\n\tscsi_cmd = scsiq->cdbptr[0];\n\tdisable_syn_offset_one_fix = false;\n\tif ((asc_dvc->pci_fix_asyn_xfer & scsiq->q1.target_id) &&\n\t    !(asc_dvc->pci_fix_asyn_xfer_always & scsiq->q1.target_id)) {\n\t\tif (scsiq->q1.cntl & QC_SG_HEAD) {\n\t\t\tdata_cnt = 0;\n\t\t\tfor (i = 0; i < sg_entry_cnt; i++) {\n\t\t\t\tdata_cnt += le32_to_cpu(sg_head->sg_list[i].\n\t\t\t\t\t\t\tbytes);\n\t\t\t}\n\t\t} else {\n\t\t\tdata_cnt = le32_to_cpu(scsiq->q1.data_cnt);\n\t\t}\n\t\tif (data_cnt != 0UL) {\n\t\t\tif (data_cnt < 512UL) {\n\t\t\t\tdisable_syn_offset_one_fix = true;\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < ASC_SYN_OFFSET_ONE_DISABLE_LIST;\n\t\t\t\t     i++) {\n\t\t\t\t\tdisable_cmd =\n\t\t\t\t\t    _syn_offset_one_disable_cmd[i];\n\t\t\t\t\tif (disable_cmd == 0xFF) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (scsi_cmd == disable_cmd) {\n\t\t\t\t\t\tdisable_syn_offset_one_fix =\n\t\t\t\t\t\t    true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (disable_syn_offset_one_fix) {\n\t\tscsiq->q2.tag_code &= ~SIMPLE_QUEUE_TAG;\n\t\tscsiq->q2.tag_code |= (ASC_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX |\n\t\t\t\t       ASC_TAG_FLAG_DISABLE_DISCONNECT);\n\t} else {\n\t\tscsiq->q2.tag_code &= 0x27;\n\t}\n\tif ((scsiq->q1.cntl & QC_SG_HEAD) != 0) {\n\t\tif (asc_dvc->bug_fix_cntl) {\n\t\t\tif (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {\n\t\t\t\tif ((scsi_cmd == READ_6) ||\n\t\t\t\t    (scsi_cmd == READ_10)) {\n\t\t\t\t\taddr = le32_to_cpu(sg_head->\n\t\t\t\t\t\t\t\t   sg_list\n\t\t\t\t\t\t\t\t   [sg_entry_cnt_minus_one].\n\t\t\t\t\t\t\t\t   addr) +\n\t\t\t\t\t\tle32_to_cpu(sg_head->\n\t\t\t\t\t\t\t\t  sg_list\n\t\t\t\t\t\t\t\t  [sg_entry_cnt_minus_one].\n\t\t\t\t\t\t\t\t  bytes);\n\t\t\t\t\textra_bytes =\n\t\t\t\t\t    (uchar)((ushort)addr & 0x0003);\n\t\t\t\t\tif ((extra_bytes != 0)\n\t\t\t\t\t    &&\n\t\t\t\t\t    ((scsiq->q2.\n\t\t\t\t\t      tag_code &\n\t\t\t\t\t      ASC_TAG_FLAG_EXTRA_BYTES)\n\t\t\t\t\t     == 0)) {\n\t\t\t\t\t\tscsiq->q2.tag_code |=\n\t\t\t\t\t\t    ASC_TAG_FLAG_EXTRA_BYTES;\n\t\t\t\t\t\tscsiq->q1.extra_bytes =\n\t\t\t\t\t\t    extra_bytes;\n\t\t\t\t\t\tdata_cnt =\n\t\t\t\t\t\t    le32_to_cpu(sg_head->\n\t\t\t\t\t\t\t\tsg_list\n\t\t\t\t\t\t\t\t[sg_entry_cnt_minus_one].\n\t\t\t\t\t\t\t\tbytes);\n\t\t\t\t\t\tdata_cnt -= extra_bytes;\n\t\t\t\t\t\tsg_head->\n\t\t\t\t\t\t    sg_list\n\t\t\t\t\t\t    [sg_entry_cnt_minus_one].\n\t\t\t\t\t\t    bytes =\n\t\t\t\t\t\t    cpu_to_le32(data_cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsg_head->entry_to_copy = sg_head->entry_cnt;\n\t\tn_q_required = AscSgListToQueue(sg_entry_cnt);\n\t\tif ((AscGetNumOfFreeQueue(asc_dvc, target_ix, n_q_required) >=\n\t\t     (uint) n_q_required)\n\t\t    || ((scsiq->q1.cntl & QC_URGENT) != 0)) {\n\t\t\tif ((sta =\n\t\t\t     AscSendScsiQueue(asc_dvc, scsiq,\n\t\t\t\t\t      n_q_required)) == 1) {\n\t\t\t\tasc_dvc->in_critical_cnt--;\n\t\t\t\treturn (sta);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (asc_dvc->bug_fix_cntl) {\n\t\t\tif (asc_dvc->bug_fix_cntl & ASC_BUG_FIX_IF_NOT_DWB) {\n\t\t\t\tif ((scsi_cmd == READ_6) ||\n\t\t\t\t    (scsi_cmd == READ_10)) {\n\t\t\t\t\taddr =\n\t\t\t\t\t    le32_to_cpu(scsiq->q1.data_addr) +\n\t\t\t\t\t    le32_to_cpu(scsiq->q1.data_cnt);\n\t\t\t\t\textra_bytes =\n\t\t\t\t\t    (uchar)((ushort)addr & 0x0003);\n\t\t\t\t\tif ((extra_bytes != 0)\n\t\t\t\t\t    &&\n\t\t\t\t\t    ((scsiq->q2.\n\t\t\t\t\t      tag_code &\n\t\t\t\t\t      ASC_TAG_FLAG_EXTRA_BYTES)\n\t\t\t\t\t     == 0)) {\n\t\t\t\t\t\tdata_cnt =\n\t\t\t\t\t\t    le32_to_cpu(scsiq->q1.\n\t\t\t\t\t\t\t\tdata_cnt);\n\t\t\t\t\t\tif (((ushort)data_cnt & 0x01FF)\n\t\t\t\t\t\t    == 0) {\n\t\t\t\t\t\t\tscsiq->q2.tag_code |=\n\t\t\t\t\t\t\t    ASC_TAG_FLAG_EXTRA_BYTES;\n\t\t\t\t\t\t\tdata_cnt -= extra_bytes;\n\t\t\t\t\t\t\tscsiq->q1.data_cnt =\n\t\t\t\t\t\t\t    cpu_to_le32\n\t\t\t\t\t\t\t    (data_cnt);\n\t\t\t\t\t\t\tscsiq->q1.extra_bytes =\n\t\t\t\t\t\t\t    extra_bytes;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tn_q_required = 1;\n\t\tif ((AscGetNumOfFreeQueue(asc_dvc, target_ix, 1) >= 1) ||\n\t\t    ((scsiq->q1.cntl & QC_URGENT) != 0)) {\n\t\t\tif ((sta = AscSendScsiQueue(asc_dvc, scsiq,\n\t\t\t\t\t\t    n_q_required)) == 1) {\n\t\t\t\tasc_dvc->in_critical_cnt--;\n\t\t\t\treturn (sta);\n\t\t\t}\n\t\t}\n\t}\n\tasc_dvc->in_critical_cnt--;\n\treturn (sta);\n}\n\n/*\n * AdvExeScsiQueue() - Send a request to the RISC microcode program.\n *\n *   Allocate a carrier structure, point the carrier to the ADV_SCSI_REQ_Q,\n *   add the carrier to the ICQ (Initiator Command Queue), and tickle the\n *   RISC to notify it a new command is ready to be executed.\n *\n * If 'done_status' is not set to QD_DO_RETRY, then 'error_retry' will be\n * set to SCSI_MAX_RETRY.\n *\n * Multi-byte fields in the ADV_SCSI_REQ_Q that are used by the microcode\n * for DMA addresses or math operations are byte swapped to little-endian\n * order.\n *\n * Return:\n *      ADV_SUCCESS(1) - The request was successfully queued.\n *      ADV_BUSY(0) -    Resource unavailable; Retry again after pending\n *                       request completes.\n *      ADV_ERROR(-1) -  Invalid ADV_SCSI_REQ_Q request structure\n *                       host IC error.\n */\nstatic int AdvExeScsiQueue(ADV_DVC_VAR *asc_dvc, adv_req_t *reqp)\n{\n\tAdvPortAddr iop_base;\n\tADV_CARR_T *new_carrp;\n\tADV_SCSI_REQ_Q *scsiq = &reqp->scsi_req_q;\n\n\t/*\n\t * The ADV_SCSI_REQ_Q 'target_id' field should never exceed ADV_MAX_TID.\n\t */\n\tif (scsiq->target_id > ADV_MAX_TID) {\n\t\tscsiq->host_status = QHSTA_M_INVALID_DEVICE;\n\t\tscsiq->done_status = QD_WITH_ERROR;\n\t\treturn ADV_ERROR;\n\t}\n\n\tiop_base = asc_dvc->iop_base;\n\n\t/*\n\t * Allocate a carrier ensuring at least one carrier always\n\t * remains on the freelist and initialize fields.\n\t */\n\tnew_carrp = adv_get_next_carrier(asc_dvc);\n\tif (!new_carrp) {\n\t\tASC_DBG(1, \"No free carriers\\n\");\n\t\treturn ADV_BUSY;\n\t}\n\n\tasc_dvc->carr_pending_cnt++;\n\n\t/* Save virtual and physical address of ADV_SCSI_REQ_Q and carrier. */\n\tscsiq->scsiq_ptr = cpu_to_le32(scsiq->srb_tag);\n\tscsiq->scsiq_rptr = cpu_to_le32(reqp->req_addr);\n\n\tscsiq->carr_va = asc_dvc->icq_sp->carr_va;\n\tscsiq->carr_pa = asc_dvc->icq_sp->carr_pa;\n\n\t/*\n\t * Use the current stopper to send the ADV_SCSI_REQ_Q command to\n\t * the microcode. The newly allocated stopper will become the new\n\t * stopper.\n\t */\n\tasc_dvc->icq_sp->areq_vpa = scsiq->scsiq_rptr;\n\n\t/*\n\t * Set the 'next_vpa' pointer for the old stopper to be the\n\t * physical address of the new stopper. The RISC can only\n\t * follow physical addresses.\n\t */\n\tasc_dvc->icq_sp->next_vpa = new_carrp->carr_pa;\n\n\t/*\n\t * Set the host adapter stopper pointer to point to the new carrier.\n\t */\n\tasc_dvc->icq_sp = new_carrp;\n\n\tif (asc_dvc->chip_type == ADV_CHIP_ASC3550 ||\n\t    asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {\n\t\t/*\n\t\t * Tickle the RISC to tell it to read its Command Queue Head pointer.\n\t\t */\n\t\tAdvWriteByteRegister(iop_base, IOPB_TICKLE, ADV_TICKLE_A);\n\t\tif (asc_dvc->chip_type == ADV_CHIP_ASC3550) {\n\t\t\t/*\n\t\t\t * Clear the tickle value. In the ASC-3550 the RISC flag\n\t\t\t * command 'clr_tickle_a' does not work unless the host\n\t\t\t * value is cleared.\n\t\t\t */\n\t\t\tAdvWriteByteRegister(iop_base, IOPB_TICKLE,\n\t\t\t\t\t     ADV_TICKLE_NOP);\n\t\t}\n\t} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {\n\t\t/*\n\t\t * Notify the RISC a carrier is ready by writing the physical\n\t\t * address of the new carrier stopper to the COMMA register.\n\t\t */\n\t\tAdvWriteDWordRegister(iop_base, IOPDW_COMMA,\n\t\t\t\t      le32_to_cpu(new_carrp->carr_pa));\n\t}\n\n\treturn ADV_SUCCESS;\n}\n\n/*\n * Execute a single 'struct scsi_cmnd'.\n */\nstatic int asc_execute_scsi_cmnd(struct scsi_cmnd *scp)\n{\n\tint ret, err_code;\n\tstruct asc_board *boardp = shost_priv(scp->device->host);\n\n\tASC_DBG(1, \"scp 0x%p\\n\", scp);\n\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tASC_DVC_VAR *asc_dvc = &boardp->dvc_var.asc_dvc_var;\n\t\tstruct asc_scsi_q asc_scsi_q;\n\n\t\tret = asc_build_req(boardp, scp, &asc_scsi_q);\n\t\tif (ret != ASC_NOERROR) {\n\t\t\tASC_STATS(scp->device->host, build_error);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = AscExeScsiQueue(asc_dvc, &asc_scsi_q);\n\t\tkfree(asc_scsi_q.sg_head);\n\t\terr_code = asc_dvc->err_code;\n\t} else {\n\t\tADV_DVC_VAR *adv_dvc = &boardp->dvc_var.adv_dvc_var;\n\t\tadv_req_t *adv_reqp;\n\n\t\tswitch (adv_build_req(boardp, scp, &adv_reqp)) {\n\t\tcase ASC_NOERROR:\n\t\t\tASC_DBG(3, \"adv_build_req ASC_NOERROR\\n\");\n\t\t\tbreak;\n\t\tcase ASC_BUSY:\n\t\t\tASC_DBG(1, \"adv_build_req ASC_BUSY\\n\");\n\t\t\t/*\n\t\t\t * The asc_stats fields 'adv_build_noreq' and\n\t\t\t * 'adv_build_nosg' count wide board busy conditions.\n\t\t\t * They are updated in adv_build_req and\n\t\t\t * adv_get_sglist, respectively.\n\t\t\t */\n\t\t\treturn ASC_BUSY;\n\t\tcase ASC_ERROR:\n\t\tdefault:\n\t\t\tASC_DBG(1, \"adv_build_req ASC_ERROR\\n\");\n\t\t\tASC_STATS(scp->device->host, build_error);\n\t\t\treturn ASC_ERROR;\n\t\t}\n\n\t\tret = AdvExeScsiQueue(adv_dvc, adv_reqp);\n\t\terr_code = adv_dvc->err_code;\n\t}\n\n\tswitch (ret) {\n\tcase ASC_NOERROR:\n\t\tASC_STATS(scp->device->host, exe_noerror);\n\t\t/*\n\t\t * Increment monotonically increasing per device\n\t\t * successful request counter. Wrapping doesn't matter.\n\t\t */\n\t\tboardp->reqcnt[scp->device->id]++;\n\t\tASC_DBG(1, \"ExeScsiQueue() ASC_NOERROR\\n\");\n\t\tbreak;\n\tcase ASC_BUSY:\n\t\tASC_DBG(1, \"ExeScsiQueue() ASC_BUSY\\n\");\n\t\tASC_STATS(scp->device->host, exe_busy);\n\t\tbreak;\n\tcase ASC_ERROR:\n\t\tscmd_printk(KERN_ERR, scp, \"ExeScsiQueue() ASC_ERROR, \"\n\t\t\t\"err_code 0x%x\\n\", err_code);\n\t\tASC_STATS(scp->device->host, exe_error);\n\t\tscp->result = HOST_BYTE(DID_ERROR);\n\t\tbreak;\n\tdefault:\n\t\tscmd_printk(KERN_ERR, scp, \"ExeScsiQueue() unknown, \"\n\t\t\t\"err_code 0x%x\\n\", err_code);\n\t\tASC_STATS(scp->device->host, exe_unknown);\n\t\tscp->result = HOST_BYTE(DID_ERROR);\n\t\tbreak;\n\t}\n\n\tASC_DBG(1, \"end\\n\");\n\treturn ret;\n}\n\n/*\n * advansys_queuecommand() - interrupt-driven I/O entrypoint.\n *\n * This function always returns 0. Command return status is saved\n * in the 'scp' result field.\n */\nstatic int\nadvansys_queuecommand_lck(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))\n{\n\tstruct Scsi_Host *shost = scp->device->host;\n\tint asc_res, result = 0;\n\n\tASC_STATS(shost, queuecommand);\n\tscp->scsi_done = done;\n\n\tasc_res = asc_execute_scsi_cmnd(scp);\n\n\tswitch (asc_res) {\n\tcase ASC_NOERROR:\n\t\tbreak;\n\tcase ASC_BUSY:\n\t\tresult = SCSI_MLQUEUE_HOST_BUSY;\n\t\tbreak;\n\tcase ASC_ERROR:\n\tdefault:\n\t\tasc_scsi_done(scp);\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic DEF_SCSI_QCMD(advansys_queuecommand)\n\nstatic ushort AscGetEisaChipCfg(PortAddr iop_base)\n{\n\tPortAddr eisa_cfg_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |\n\t    (PortAddr) (ASC_EISA_CFG_IOP_MASK);\n\treturn inpw(eisa_cfg_iop);\n}\n\n/*\n * Return the BIOS address of the adapter at the specified\n * I/O port and with the specified bus type.\n */\nstatic unsigned short AscGetChipBiosAddress(PortAddr iop_base,\n\t\t\t\t\t    unsigned short bus_type)\n{\n\tunsigned short cfg_lsw;\n\tunsigned short bios_addr;\n\n\t/*\n\t * The PCI BIOS is re-located by the motherboard BIOS. Because\n\t * of this the driver can not determine where a PCI BIOS is\n\t * loaded and executes.\n\t */\n\tif (bus_type & ASC_IS_PCI)\n\t\treturn 0;\n\n\tif ((bus_type & ASC_IS_EISA) != 0) {\n\t\tcfg_lsw = AscGetEisaChipCfg(iop_base);\n\t\tcfg_lsw &= 0x000F;\n\t\tbios_addr = ASC_BIOS_MIN_ADDR + cfg_lsw * ASC_BIOS_BANK_SIZE;\n\t\treturn bios_addr;\n\t}\n\n\tcfg_lsw = AscGetChipCfgLsw(iop_base);\n\n\t/*\n\t *  ISA PnP uses the top bit as the 32K BIOS flag\n\t */\n\tif (bus_type == ASC_IS_ISAPNP)\n\t\tcfg_lsw &= 0x7FFF;\n\tbios_addr = ASC_BIOS_MIN_ADDR + (cfg_lsw >> 12) * ASC_BIOS_BANK_SIZE;\n\treturn bios_addr;\n}\n\nstatic uchar AscSetChipScsiID(PortAddr iop_base, uchar new_host_id)\n{\n\tushort cfg_lsw;\n\n\tif (AscGetChipScsiID(iop_base) == new_host_id) {\n\t\treturn (new_host_id);\n\t}\n\tcfg_lsw = AscGetChipCfgLsw(iop_base);\n\tcfg_lsw &= 0xF8FF;\n\tcfg_lsw |= (ushort)((new_host_id & ASC_MAX_TID) << 8);\n\tAscSetChipCfgLsw(iop_base, cfg_lsw);\n\treturn (AscGetChipScsiID(iop_base));\n}\n\nstatic unsigned char AscGetChipScsiCtrl(PortAddr iop_base)\n{\n\tunsigned char sc;\n\n\tAscSetBank(iop_base, 1);\n\tsc = inp(iop_base + IOP_REG_SC);\n\tAscSetBank(iop_base, 0);\n\treturn sc;\n}\n\nstatic unsigned char AscGetChipVersion(PortAddr iop_base,\n\t\t\t\t       unsigned short bus_type)\n{\n\tif (bus_type & ASC_IS_EISA) {\n\t\tPortAddr eisa_iop;\n\t\tunsigned char revision;\n\t\teisa_iop = (PortAddr) ASC_GET_EISA_SLOT(iop_base) |\n\t\t    (PortAddr) ASC_EISA_REV_IOP_MASK;\n\t\trevision = inp(eisa_iop);\n\t\treturn ASC_CHIP_MIN_VER_EISA - 1 + revision;\n\t}\n\treturn AscGetChipVerNo(iop_base);\n}\n\n#ifdef CONFIG_ISA\nstatic void AscEnableIsaDma(uchar dma_channel)\n{\n\tif (dma_channel < 4) {\n\t\toutp(0x000B, (ushort)(0xC0 | dma_channel));\n\t\toutp(0x000A, dma_channel);\n\t} else if (dma_channel < 8) {\n\t\toutp(0x00D6, (ushort)(0xC0 | (dma_channel - 4)));\n\t\toutp(0x00D4, (ushort)(dma_channel - 4));\n\t}\n}\n#endif /* CONFIG_ISA */\n\nstatic int AscStopQueueExe(PortAddr iop_base)\n{\n\tint count = 0;\n\n\tif (AscReadLramByte(iop_base, ASCV_STOP_CODE_B) == 0) {\n\t\tAscWriteLramByte(iop_base, ASCV_STOP_CODE_B,\n\t\t\t\t ASC_STOP_REQ_RISC_STOP);\n\t\tdo {\n\t\t\tif (AscReadLramByte(iop_base, ASCV_STOP_CODE_B) &\n\t\t\t    ASC_STOP_ACK_RISC_STOP) {\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tmdelay(100);\n\t\t} while (count++ < 20);\n\t}\n\treturn (0);\n}\n\nstatic unsigned int AscGetMaxDmaCount(ushort bus_type)\n{\n\tif (bus_type & ASC_IS_ISA)\n\t\treturn ASC_MAX_ISA_DMA_COUNT;\n\telse if (bus_type & (ASC_IS_EISA | ASC_IS_VL))\n\t\treturn ASC_MAX_VL_DMA_COUNT;\n\treturn ASC_MAX_PCI_DMA_COUNT;\n}\n\n#ifdef CONFIG_ISA\nstatic ushort AscGetIsaDmaChannel(PortAddr iop_base)\n{\n\tushort channel;\n\n\tchannel = AscGetChipCfgLsw(iop_base) & 0x0003;\n\tif (channel == 0x03)\n\t\treturn (0);\n\telse if (channel == 0x00)\n\t\treturn (7);\n\treturn (channel + 4);\n}\n\nstatic ushort AscSetIsaDmaChannel(PortAddr iop_base, ushort dma_channel)\n{\n\tushort cfg_lsw;\n\tuchar value;\n\n\tif ((dma_channel >= 5) && (dma_channel <= 7)) {\n\t\tif (dma_channel == 7)\n\t\t\tvalue = 0x00;\n\t\telse\n\t\t\tvalue = dma_channel - 4;\n\t\tcfg_lsw = AscGetChipCfgLsw(iop_base) & 0xFFFC;\n\t\tcfg_lsw |= value;\n\t\tAscSetChipCfgLsw(iop_base, cfg_lsw);\n\t\treturn (AscGetIsaDmaChannel(iop_base));\n\t}\n\treturn 0;\n}\n\nstatic uchar AscGetIsaDmaSpeed(PortAddr iop_base)\n{\n\tuchar speed_value;\n\n\tAscSetBank(iop_base, 1);\n\tspeed_value = AscReadChipDmaSpeed(iop_base);\n\tspeed_value &= 0x07;\n\tAscSetBank(iop_base, 0);\n\treturn speed_value;\n}\n\nstatic uchar AscSetIsaDmaSpeed(PortAddr iop_base, uchar speed_value)\n{\n\tspeed_value &= 0x07;\n\tAscSetBank(iop_base, 1);\n\tAscWriteChipDmaSpeed(iop_base, speed_value);\n\tAscSetBank(iop_base, 0);\n\treturn AscGetIsaDmaSpeed(iop_base);\n}\n#endif /* CONFIG_ISA */\n\nstatic void AscInitAscDvcVar(ASC_DVC_VAR *asc_dvc)\n{\n\tint i;\n\tPortAddr iop_base;\n\tuchar chip_version;\n\n\tiop_base = asc_dvc->iop_base;\n\tasc_dvc->err_code = 0;\n\tif ((asc_dvc->bus_type &\n\t     (ASC_IS_ISA | ASC_IS_PCI | ASC_IS_EISA | ASC_IS_VL)) == 0) {\n\t\tasc_dvc->err_code |= ASC_IERR_NO_BUS_TYPE;\n\t}\n\tAscSetChipControl(iop_base, CC_HALT);\n\tAscSetChipStatus(iop_base, 0);\n\tasc_dvc->bug_fix_cntl = 0;\n\tasc_dvc->pci_fix_asyn_xfer = 0;\n\tasc_dvc->pci_fix_asyn_xfer_always = 0;\n\t/* asc_dvc->init_state initialized in AscInitGetConfig(). */\n\tasc_dvc->sdtr_done = 0;\n\tasc_dvc->cur_total_qng = 0;\n\tasc_dvc->is_in_int = false;\n\tasc_dvc->in_critical_cnt = 0;\n\tasc_dvc->last_q_shortage = 0;\n\tasc_dvc->use_tagged_qng = 0;\n\tasc_dvc->no_scam = 0;\n\tasc_dvc->unit_not_ready = 0;\n\tasc_dvc->queue_full_or_busy = 0;\n\tasc_dvc->redo_scam = 0;\n\tasc_dvc->res2 = 0;\n\tasc_dvc->min_sdtr_index = 0;\n\tasc_dvc->cfg->can_tagged_qng = 0;\n\tasc_dvc->cfg->cmd_qng_enabled = 0;\n\tasc_dvc->dvc_cntl = ASC_DEF_DVC_CNTL;\n\tasc_dvc->init_sdtr = 0;\n\tasc_dvc->max_total_qng = ASC_DEF_MAX_TOTAL_QNG;\n\tasc_dvc->scsi_reset_wait = 3;\n\tasc_dvc->start_motor = ASC_SCSI_WIDTH_BIT_SET;\n\tasc_dvc->max_dma_count = AscGetMaxDmaCount(asc_dvc->bus_type);\n\tasc_dvc->cfg->sdtr_enable = ASC_SCSI_WIDTH_BIT_SET;\n\tasc_dvc->cfg->disc_enable = ASC_SCSI_WIDTH_BIT_SET;\n\tasc_dvc->cfg->chip_scsi_id = ASC_DEF_CHIP_SCSI_ID;\n\tchip_version = AscGetChipVersion(iop_base, asc_dvc->bus_type);\n\tasc_dvc->cfg->chip_version = chip_version;\n\tasc_dvc->sdtr_period_tbl = asc_syn_xfer_period;\n\tasc_dvc->max_sdtr_index = 7;\n\tif ((asc_dvc->bus_type & ASC_IS_PCI) &&\n\t    (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3150)) {\n\t\tasc_dvc->bus_type = ASC_IS_PCI_ULTRA;\n\t\tasc_dvc->sdtr_period_tbl = asc_syn_ultra_xfer_period;\n\t\tasc_dvc->max_sdtr_index = 15;\n\t\tif (chip_version == ASC_CHIP_VER_PCI_ULTRA_3150) {\n\t\t\tAscSetExtraControl(iop_base,\n\t\t\t\t\t   (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));\n\t\t} else if (chip_version >= ASC_CHIP_VER_PCI_ULTRA_3050) {\n\t\t\tAscSetExtraControl(iop_base,\n\t\t\t\t\t   (SEC_ACTIVE_NEGATE |\n\t\t\t\t\t    SEC_ENABLE_FILTER));\n\t\t}\n\t}\n\tif (asc_dvc->bus_type == ASC_IS_PCI) {\n\t\tAscSetExtraControl(iop_base,\n\t\t\t\t   (SEC_ACTIVE_NEGATE | SEC_SLEW_RATE));\n\t}\n\n\tasc_dvc->cfg->isa_dma_speed = ASC_DEF_ISA_DMA_SPEED;\n#ifdef CONFIG_ISA\n\tif ((asc_dvc->bus_type & ASC_IS_ISA) != 0) {\n\t\tif (chip_version >= ASC_CHIP_MIN_VER_ISA_PNP) {\n\t\t\tAscSetChipIFC(iop_base, IFC_INIT_DEFAULT);\n\t\t\tasc_dvc->bus_type = ASC_IS_ISAPNP;\n\t\t}\n\t\tasc_dvc->cfg->isa_dma_channel =\n\t\t    (uchar)AscGetIsaDmaChannel(iop_base);\n\t}\n#endif /* CONFIG_ISA */\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tasc_dvc->cur_dvc_qng[i] = 0;\n\t\tasc_dvc->max_dvc_qng[i] = ASC_MAX_SCSI1_QNG;\n\t\tasc_dvc->scsiq_busy_head[i] = (ASC_SCSI_Q *)0L;\n\t\tasc_dvc->scsiq_busy_tail[i] = (ASC_SCSI_Q *)0L;\n\t\tasc_dvc->cfg->max_tag_qng[i] = ASC_MAX_INRAM_TAG_QNG;\n\t}\n}\n\nstatic int AscWriteEEPCmdReg(PortAddr iop_base, uchar cmd_reg)\n{\n\tint retry;\n\n\tfor (retry = 0; retry < ASC_EEP_MAX_RETRY; retry++) {\n\t\tunsigned char read_back;\n\t\tAscSetChipEEPCmd(iop_base, cmd_reg);\n\t\tmdelay(1);\n\t\tread_back = AscGetChipEEPCmd(iop_base);\n\t\tif (read_back == cmd_reg)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void AscWaitEEPRead(void)\n{\n\tmdelay(1);\n}\n\nstatic ushort AscReadEEPWord(PortAddr iop_base, uchar addr)\n{\n\tushort read_wval;\n\tuchar cmd_reg;\n\n\tAscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_DISABLE);\n\tAscWaitEEPRead();\n\tcmd_reg = addr | ASC_EEP_CMD_READ;\n\tAscWriteEEPCmdReg(iop_base, cmd_reg);\n\tAscWaitEEPRead();\n\tread_wval = AscGetChipEEPData(iop_base);\n\tAscWaitEEPRead();\n\treturn read_wval;\n}\n\nstatic ushort AscGetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf,\n\t\t\t      ushort bus_type)\n{\n\tushort wval;\n\tushort sum;\n\tushort *wbuf;\n\tint cfg_beg;\n\tint cfg_end;\n\tint uchar_end_in_config = ASC_EEP_MAX_DVC_ADDR - 2;\n\tint s_addr;\n\n\twbuf = (ushort *)cfg_buf;\n\tsum = 0;\n\t/* Read two config words; Byte-swapping done by AscReadEEPWord(). */\n\tfor (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {\n\t\t*wbuf = AscReadEEPWord(iop_base, (uchar)s_addr);\n\t\tsum += *wbuf;\n\t}\n\tif (bus_type & ASC_IS_VL) {\n\t\tcfg_beg = ASC_EEP_DVC_CFG_BEG_VL;\n\t\tcfg_end = ASC_EEP_MAX_DVC_ADDR_VL;\n\t} else {\n\t\tcfg_beg = ASC_EEP_DVC_CFG_BEG;\n\t\tcfg_end = ASC_EEP_MAX_DVC_ADDR;\n\t}\n\tfor (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {\n\t\twval = AscReadEEPWord(iop_base, (uchar)s_addr);\n\t\tif (s_addr <= uchar_end_in_config) {\n\t\t\t/*\n\t\t\t * Swap all char fields - must unswap bytes already swapped\n\t\t\t * by AscReadEEPWord().\n\t\t\t */\n\t\t\t*wbuf = le16_to_cpu(wval);\n\t\t} else {\n\t\t\t/* Don't swap word field at the end - cntl field. */\n\t\t\t*wbuf = wval;\n\t\t}\n\t\tsum += wval;\t/* Checksum treats all EEPROM data as words. */\n\t}\n\t/*\n\t * Read the checksum word which will be compared against 'sum'\n\t * by the caller. Word field already swapped.\n\t */\n\t*wbuf = AscReadEEPWord(iop_base, (uchar)s_addr);\n\treturn sum;\n}\n\nstatic int AscTestExternalLram(ASC_DVC_VAR *asc_dvc)\n{\n\tPortAddr iop_base;\n\tushort q_addr;\n\tushort saved_word;\n\tint sta;\n\n\tiop_base = asc_dvc->iop_base;\n\tsta = 0;\n\tq_addr = ASC_QNO_TO_QADDR(241);\n\tsaved_word = AscReadLramWord(iop_base, q_addr);\n\tAscSetChipLramAddr(iop_base, q_addr);\n\tAscSetChipLramData(iop_base, 0x55AA);\n\tmdelay(10);\n\tAscSetChipLramAddr(iop_base, q_addr);\n\tif (AscGetChipLramData(iop_base) == 0x55AA) {\n\t\tsta = 1;\n\t\tAscWriteLramWord(iop_base, q_addr, saved_word);\n\t}\n\treturn (sta);\n}\n\nstatic void AscWaitEEPWrite(void)\n{\n\tmdelay(20);\n}\n\nstatic int AscWriteEEPDataReg(PortAddr iop_base, ushort data_reg)\n{\n\tushort read_back;\n\tint retry;\n\n\tretry = 0;\n\twhile (true) {\n\t\tAscSetChipEEPData(iop_base, data_reg);\n\t\tmdelay(1);\n\t\tread_back = AscGetChipEEPData(iop_base);\n\t\tif (read_back == data_reg) {\n\t\t\treturn (1);\n\t\t}\n\t\tif (retry++ > ASC_EEP_MAX_RETRY) {\n\t\t\treturn (0);\n\t\t}\n\t}\n}\n\nstatic ushort AscWriteEEPWord(PortAddr iop_base, uchar addr, ushort word_val)\n{\n\tushort read_wval;\n\n\tread_wval = AscReadEEPWord(iop_base, addr);\n\tif (read_wval != word_val) {\n\t\tAscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_ABLE);\n\t\tAscWaitEEPRead();\n\t\tAscWriteEEPDataReg(iop_base, word_val);\n\t\tAscWaitEEPRead();\n\t\tAscWriteEEPCmdReg(iop_base,\n\t\t\t\t  (uchar)((uchar)ASC_EEP_CMD_WRITE | addr));\n\t\tAscWaitEEPWrite();\n\t\tAscWriteEEPCmdReg(iop_base, ASC_EEP_CMD_WRITE_DISABLE);\n\t\tAscWaitEEPRead();\n\t\treturn (AscReadEEPWord(iop_base, addr));\n\t}\n\treturn (read_wval);\n}\n\nstatic int AscSetEEPConfigOnce(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf,\n\t\t\t       ushort bus_type)\n{\n\tint n_error;\n\tushort *wbuf;\n\tushort word;\n\tushort sum;\n\tint s_addr;\n\tint cfg_beg;\n\tint cfg_end;\n\tint uchar_end_in_config = ASC_EEP_MAX_DVC_ADDR - 2;\n\n\twbuf = (ushort *)cfg_buf;\n\tn_error = 0;\n\tsum = 0;\n\t/* Write two config words; AscWriteEEPWord() will swap bytes. */\n\tfor (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {\n\t\tsum += *wbuf;\n\t\tif (*wbuf != AscWriteEEPWord(iop_base, (uchar)s_addr, *wbuf)) {\n\t\t\tn_error++;\n\t\t}\n\t}\n\tif (bus_type & ASC_IS_VL) {\n\t\tcfg_beg = ASC_EEP_DVC_CFG_BEG_VL;\n\t\tcfg_end = ASC_EEP_MAX_DVC_ADDR_VL;\n\t} else {\n\t\tcfg_beg = ASC_EEP_DVC_CFG_BEG;\n\t\tcfg_end = ASC_EEP_MAX_DVC_ADDR;\n\t}\n\tfor (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {\n\t\tif (s_addr <= uchar_end_in_config) {\n\t\t\t/*\n\t\t\t * This is a char field. Swap char fields before they are\n\t\t\t * swapped again by AscWriteEEPWord().\n\t\t\t */\n\t\t\tword = cpu_to_le16(*wbuf);\n\t\t\tif (word !=\n\t\t\t    AscWriteEEPWord(iop_base, (uchar)s_addr, word)) {\n\t\t\t\tn_error++;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Don't swap word field at the end - cntl field. */\n\t\t\tif (*wbuf !=\n\t\t\t    AscWriteEEPWord(iop_base, (uchar)s_addr, *wbuf)) {\n\t\t\t\tn_error++;\n\t\t\t}\n\t\t}\n\t\tsum += *wbuf;\t/* Checksum calculated from word values. */\n\t}\n\t/* Write checksum word. It will be swapped by AscWriteEEPWord(). */\n\t*wbuf = sum;\n\tif (sum != AscWriteEEPWord(iop_base, (uchar)s_addr, sum)) {\n\t\tn_error++;\n\t}\n\n\t/* Read EEPROM back again. */\n\twbuf = (ushort *)cfg_buf;\n\t/*\n\t * Read two config words; Byte-swapping done by AscReadEEPWord().\n\t */\n\tfor (s_addr = 0; s_addr < 2; s_addr++, wbuf++) {\n\t\tif (*wbuf != AscReadEEPWord(iop_base, (uchar)s_addr)) {\n\t\t\tn_error++;\n\t\t}\n\t}\n\tif (bus_type & ASC_IS_VL) {\n\t\tcfg_beg = ASC_EEP_DVC_CFG_BEG_VL;\n\t\tcfg_end = ASC_EEP_MAX_DVC_ADDR_VL;\n\t} else {\n\t\tcfg_beg = ASC_EEP_DVC_CFG_BEG;\n\t\tcfg_end = ASC_EEP_MAX_DVC_ADDR;\n\t}\n\tfor (s_addr = cfg_beg; s_addr <= (cfg_end - 1); s_addr++, wbuf++) {\n\t\tif (s_addr <= uchar_end_in_config) {\n\t\t\t/*\n\t\t\t * Swap all char fields. Must unswap bytes already swapped\n\t\t\t * by AscReadEEPWord().\n\t\t\t */\n\t\t\tword =\n\t\t\t    le16_to_cpu(AscReadEEPWord\n\t\t\t\t\t(iop_base, (uchar)s_addr));\n\t\t} else {\n\t\t\t/* Don't swap word field at the end - cntl field. */\n\t\t\tword = AscReadEEPWord(iop_base, (uchar)s_addr);\n\t\t}\n\t\tif (*wbuf != word) {\n\t\t\tn_error++;\n\t\t}\n\t}\n\t/* Read checksum; Byte swapping not needed. */\n\tif (AscReadEEPWord(iop_base, (uchar)s_addr) != sum) {\n\t\tn_error++;\n\t}\n\treturn n_error;\n}\n\nstatic int AscSetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG *cfg_buf,\n\t\t\t   ushort bus_type)\n{\n\tint retry;\n\tint n_error;\n\n\tretry = 0;\n\twhile (true) {\n\t\tif ((n_error = AscSetEEPConfigOnce(iop_base, cfg_buf,\n\t\t\t\t\t\t   bus_type)) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (++retry > ASC_EEP_MAX_RETRY) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn n_error;\n}\n\nstatic int AscInitFromEEP(ASC_DVC_VAR *asc_dvc)\n{\n\tASCEEP_CONFIG eep_config_buf;\n\tASCEEP_CONFIG *eep_config;\n\tPortAddr iop_base;\n\tushort chksum;\n\tushort warn_code;\n\tushort cfg_msw, cfg_lsw;\n\tint i;\n\tint write_eep = 0;\n\n\tiop_base = asc_dvc->iop_base;\n\twarn_code = 0;\n\tAscWriteLramWord(iop_base, ASCV_HALTCODE_W, 0x00FE);\n\tAscStopQueueExe(iop_base);\n\tif ((AscStopChip(iop_base)) ||\n\t    (AscGetChipScsiCtrl(iop_base) != 0)) {\n\t\tasc_dvc->init_state |= ASC_INIT_RESET_SCSI_DONE;\n\t\tAscResetChipAndScsiBus(asc_dvc);\n\t\tmdelay(asc_dvc->scsi_reset_wait * 1000); /* XXX: msleep? */\n\t}\n\tif (!AscIsChipHalted(iop_base)) {\n\t\tasc_dvc->err_code |= ASC_IERR_START_STOP_CHIP;\n\t\treturn (warn_code);\n\t}\n\tAscSetPCAddr(iop_base, ASC_MCODE_START_ADDR);\n\tif (AscGetPCAddr(iop_base) != ASC_MCODE_START_ADDR) {\n\t\tasc_dvc->err_code |= ASC_IERR_SET_PC_ADDR;\n\t\treturn (warn_code);\n\t}\n\teep_config = (ASCEEP_CONFIG *)&eep_config_buf;\n\tcfg_msw = AscGetChipCfgMsw(iop_base);\n\tcfg_lsw = AscGetChipCfgLsw(iop_base);\n\tif ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {\n\t\tcfg_msw &= ~ASC_CFG_MSW_CLR_MASK;\n\t\twarn_code |= ASC_WARN_CFG_MSW_RECOVER;\n\t\tAscSetChipCfgMsw(iop_base, cfg_msw);\n\t}\n\tchksum = AscGetEEPConfig(iop_base, eep_config, asc_dvc->bus_type);\n\tASC_DBG(1, \"chksum 0x%x\\n\", chksum);\n\tif (chksum == 0) {\n\t\tchksum = 0xaa55;\n\t}\n\tif (AscGetChipStatus(iop_base) & CSW_AUTO_CONFIG) {\n\t\twarn_code |= ASC_WARN_AUTO_CONFIG;\n\t\tif (asc_dvc->cfg->chip_version == 3) {\n\t\t\tif (eep_config->cfg_lsw != cfg_lsw) {\n\t\t\t\twarn_code |= ASC_WARN_EEPROM_RECOVER;\n\t\t\t\teep_config->cfg_lsw =\n\t\t\t\t    AscGetChipCfgLsw(iop_base);\n\t\t\t}\n\t\t\tif (eep_config->cfg_msw != cfg_msw) {\n\t\t\t\twarn_code |= ASC_WARN_EEPROM_RECOVER;\n\t\t\t\teep_config->cfg_msw =\n\t\t\t\t    AscGetChipCfgMsw(iop_base);\n\t\t\t}\n\t\t}\n\t}\n\teep_config->cfg_msw &= ~ASC_CFG_MSW_CLR_MASK;\n\teep_config->cfg_lsw |= ASC_CFG0_HOST_INT_ON;\n\tASC_DBG(1, \"eep_config->chksum 0x%x\\n\", eep_config->chksum);\n\tif (chksum != eep_config->chksum) {\n\t\tif (AscGetChipVersion(iop_base, asc_dvc->bus_type) ==\n\t\t    ASC_CHIP_VER_PCI_ULTRA_3050) {\n\t\t\tASC_DBG(1, \"chksum error ignored; EEPROM-less board\\n\");\n\t\t\teep_config->init_sdtr = 0xFF;\n\t\t\teep_config->disc_enable = 0xFF;\n\t\t\teep_config->start_motor = 0xFF;\n\t\t\teep_config->use_cmd_qng = 0;\n\t\t\teep_config->max_total_qng = 0xF0;\n\t\t\teep_config->max_tag_qng = 0x20;\n\t\t\teep_config->cntl = 0xBFFF;\n\t\t\tASC_EEP_SET_CHIP_ID(eep_config, 7);\n\t\t\teep_config->no_scam = 0;\n\t\t\teep_config->adapter_info[0] = 0;\n\t\t\teep_config->adapter_info[1] = 0;\n\t\t\teep_config->adapter_info[2] = 0;\n\t\t\teep_config->adapter_info[3] = 0;\n\t\t\teep_config->adapter_info[4] = 0;\n\t\t\t/* Indicate EEPROM-less board. */\n\t\t\teep_config->adapter_info[5] = 0xBB;\n\t\t} else {\n\t\t\tASC_PRINT\n\t\t\t    (\"AscInitFromEEP: EEPROM checksum error; Will try to re-write EEPROM.\\n\");\n\t\t\twrite_eep = 1;\n\t\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\t\t}\n\t}\n\tasc_dvc->cfg->sdtr_enable = eep_config->init_sdtr;\n\tasc_dvc->cfg->disc_enable = eep_config->disc_enable;\n\tasc_dvc->cfg->cmd_qng_enabled = eep_config->use_cmd_qng;\n\tasc_dvc->cfg->isa_dma_speed = ASC_EEP_GET_DMA_SPD(eep_config);\n\tasc_dvc->start_motor = eep_config->start_motor;\n\tasc_dvc->dvc_cntl = eep_config->cntl;\n\tasc_dvc->no_scam = eep_config->no_scam;\n\tasc_dvc->cfg->adapter_info[0] = eep_config->adapter_info[0];\n\tasc_dvc->cfg->adapter_info[1] = eep_config->adapter_info[1];\n\tasc_dvc->cfg->adapter_info[2] = eep_config->adapter_info[2];\n\tasc_dvc->cfg->adapter_info[3] = eep_config->adapter_info[3];\n\tasc_dvc->cfg->adapter_info[4] = eep_config->adapter_info[4];\n\tasc_dvc->cfg->adapter_info[5] = eep_config->adapter_info[5];\n\tif (!AscTestExternalLram(asc_dvc)) {\n\t\tif (((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) ==\n\t\t     ASC_IS_PCI_ULTRA)) {\n\t\t\teep_config->max_total_qng =\n\t\t\t    ASC_MAX_PCI_ULTRA_INRAM_TOTAL_QNG;\n\t\t\teep_config->max_tag_qng =\n\t\t\t    ASC_MAX_PCI_ULTRA_INRAM_TAG_QNG;\n\t\t} else {\n\t\t\teep_config->cfg_msw |= 0x0800;\n\t\t\tcfg_msw |= 0x0800;\n\t\t\tAscSetChipCfgMsw(iop_base, cfg_msw);\n\t\t\teep_config->max_total_qng = ASC_MAX_PCI_INRAM_TOTAL_QNG;\n\t\t\teep_config->max_tag_qng = ASC_MAX_INRAM_TAG_QNG;\n\t\t}\n\t} else {\n\t}\n\tif (eep_config->max_total_qng < ASC_MIN_TOTAL_QNG) {\n\t\teep_config->max_total_qng = ASC_MIN_TOTAL_QNG;\n\t}\n\tif (eep_config->max_total_qng > ASC_MAX_TOTAL_QNG) {\n\t\teep_config->max_total_qng = ASC_MAX_TOTAL_QNG;\n\t}\n\tif (eep_config->max_tag_qng > eep_config->max_total_qng) {\n\t\teep_config->max_tag_qng = eep_config->max_total_qng;\n\t}\n\tif (eep_config->max_tag_qng < ASC_MIN_TAG_Q_PER_DVC) {\n\t\teep_config->max_tag_qng = ASC_MIN_TAG_Q_PER_DVC;\n\t}\n\tasc_dvc->max_total_qng = eep_config->max_total_qng;\n\tif ((eep_config->use_cmd_qng & eep_config->disc_enable) !=\n\t    eep_config->use_cmd_qng) {\n\t\teep_config->disc_enable = eep_config->use_cmd_qng;\n\t\twarn_code |= ASC_WARN_CMD_QNG_CONFLICT;\n\t}\n\tASC_EEP_SET_CHIP_ID(eep_config,\n\t\t\t    ASC_EEP_GET_CHIP_ID(eep_config) & ASC_MAX_TID);\n\tasc_dvc->cfg->chip_scsi_id = ASC_EEP_GET_CHIP_ID(eep_config);\n\tif (((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) &&\n\t    !(asc_dvc->dvc_cntl & ASC_CNTL_SDTR_ENABLE_ULTRA)) {\n\t\tasc_dvc->min_sdtr_index = ASC_SDTR_ULTRA_PCI_10MB_INDEX;\n\t}\n\n\tfor (i = 0; i <= ASC_MAX_TID; i++) {\n\t\tasc_dvc->dos_int13_table[i] = eep_config->dos_int13_table[i];\n\t\tasc_dvc->cfg->max_tag_qng[i] = eep_config->max_tag_qng;\n\t\tasc_dvc->cfg->sdtr_period_offset[i] =\n\t\t    (uchar)(ASC_DEF_SDTR_OFFSET |\n\t\t\t    (asc_dvc->min_sdtr_index << 4));\n\t}\n\teep_config->cfg_msw = AscGetChipCfgMsw(iop_base);\n\tif (write_eep) {\n\t\tif ((i = AscSetEEPConfig(iop_base, eep_config,\n\t\t\t\t     asc_dvc->bus_type)) != 0) {\n\t\t\tASC_PRINT1\n\t\t\t    (\"AscInitFromEEP: Failed to re-write EEPROM with %d errors.\\n\",\n\t\t\t     i);\n\t\t} else {\n\t\t\tASC_PRINT\n\t\t\t    (\"AscInitFromEEP: Successfully re-wrote EEPROM.\\n\");\n\t\t}\n\t}\n\treturn (warn_code);\n}\n\nstatic int AscInitGetConfig(struct Scsi_Host *shost)\n{\n\tstruct asc_board *board = shost_priv(shost);\n\tASC_DVC_VAR *asc_dvc = &board->dvc_var.asc_dvc_var;\n\tunsigned short warn_code = 0;\n\n\tasc_dvc->init_state = ASC_INIT_STATE_BEG_GET_CFG;\n\tif (asc_dvc->err_code != 0)\n\t\treturn asc_dvc->err_code;\n\n\tif (AscFindSignature(asc_dvc->iop_base)) {\n\t\tAscInitAscDvcVar(asc_dvc);\n\t\twarn_code = AscInitFromEEP(asc_dvc);\n\t\tasc_dvc->init_state |= ASC_INIT_STATE_END_GET_CFG;\n\t\tif (asc_dvc->scsi_reset_wait > ASC_MAX_SCSI_RESET_WAIT)\n\t\t\tasc_dvc->scsi_reset_wait = ASC_MAX_SCSI_RESET_WAIT;\n\t} else {\n\t\tasc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;\n\t}\n\n\tswitch (warn_code) {\n\tcase 0:\t/* No error */\n\t\tbreak;\n\tcase ASC_WARN_IO_PORT_ROTATE:\n\t\tshost_printk(KERN_WARNING, shost, \"I/O port address \"\n\t\t\t\t\"modified\\n\");\n\t\tbreak;\n\tcase ASC_WARN_AUTO_CONFIG:\n\t\tshost_printk(KERN_WARNING, shost, \"I/O port increment switch \"\n\t\t\t\t\"enabled\\n\");\n\t\tbreak;\n\tcase ASC_WARN_EEPROM_CHKSUM:\n\t\tshost_printk(KERN_WARNING, shost, \"EEPROM checksum error\\n\");\n\t\tbreak;\n\tcase ASC_WARN_IRQ_MODIFIED:\n\t\tshost_printk(KERN_WARNING, shost, \"IRQ modified\\n\");\n\t\tbreak;\n\tcase ASC_WARN_CMD_QNG_CONFLICT:\n\t\tshost_printk(KERN_WARNING, shost, \"tag queuing enabled w/o \"\n\t\t\t\t\"disconnects\\n\");\n\t\tbreak;\n\tdefault:\n\t\tshost_printk(KERN_WARNING, shost, \"unknown warning: 0x%x\\n\",\n\t\t\t\twarn_code);\n\t\tbreak;\n\t}\n\n\tif (asc_dvc->err_code != 0)\n\t\tshost_printk(KERN_ERR, shost, \"error 0x%x at init_state \"\n\t\t\t\"0x%x\\n\", asc_dvc->err_code, asc_dvc->init_state);\n\n\treturn asc_dvc->err_code;\n}\n\nstatic int AscInitSetConfig(struct pci_dev *pdev, struct Scsi_Host *shost)\n{\n\tstruct asc_board *board = shost_priv(shost);\n\tASC_DVC_VAR *asc_dvc = &board->dvc_var.asc_dvc_var;\n\tPortAddr iop_base = asc_dvc->iop_base;\n\tunsigned short cfg_msw;\n\tunsigned short warn_code = 0;\n\n\tasc_dvc->init_state |= ASC_INIT_STATE_BEG_SET_CFG;\n\tif (asc_dvc->err_code != 0)\n\t\treturn asc_dvc->err_code;\n\tif (!AscFindSignature(asc_dvc->iop_base)) {\n\t\tasc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;\n\t\treturn asc_dvc->err_code;\n\t}\n\n\tcfg_msw = AscGetChipCfgMsw(iop_base);\n\tif ((cfg_msw & ASC_CFG_MSW_CLR_MASK) != 0) {\n\t\tcfg_msw &= ~ASC_CFG_MSW_CLR_MASK;\n\t\twarn_code |= ASC_WARN_CFG_MSW_RECOVER;\n\t\tAscSetChipCfgMsw(iop_base, cfg_msw);\n\t}\n\tif ((asc_dvc->cfg->cmd_qng_enabled & asc_dvc->cfg->disc_enable) !=\n\t    asc_dvc->cfg->cmd_qng_enabled) {\n\t\tasc_dvc->cfg->disc_enable = asc_dvc->cfg->cmd_qng_enabled;\n\t\twarn_code |= ASC_WARN_CMD_QNG_CONFLICT;\n\t}\n\tif (AscGetChipStatus(iop_base) & CSW_AUTO_CONFIG) {\n\t\twarn_code |= ASC_WARN_AUTO_CONFIG;\n\t}\n#ifdef CONFIG_PCI\n\tif (asc_dvc->bus_type & ASC_IS_PCI) {\n\t\tcfg_msw &= 0xFFC0;\n\t\tAscSetChipCfgMsw(iop_base, cfg_msw);\n\t\tif ((asc_dvc->bus_type & ASC_IS_PCI_ULTRA) == ASC_IS_PCI_ULTRA) {\n\t\t} else {\n\t\t\tif ((pdev->device == PCI_DEVICE_ID_ASP_1200A) ||\n\t\t\t    (pdev->device == PCI_DEVICE_ID_ASP_ABP940)) {\n\t\t\t\tasc_dvc->bug_fix_cntl |= ASC_BUG_FIX_IF_NOT_DWB;\n\t\t\t\tasc_dvc->bug_fix_cntl |=\n\t\t\t\t    ASC_BUG_FIX_ASYN_USE_SYN;\n\t\t\t}\n\t\t}\n\t} else\n#endif /* CONFIG_PCI */\n\tif (asc_dvc->bus_type == ASC_IS_ISAPNP) {\n\t\tif (AscGetChipVersion(iop_base, asc_dvc->bus_type)\n\t\t    == ASC_CHIP_VER_ASYN_BUG) {\n\t\t\tasc_dvc->bug_fix_cntl |= ASC_BUG_FIX_ASYN_USE_SYN;\n\t\t}\n\t}\n\tif (AscSetChipScsiID(iop_base, asc_dvc->cfg->chip_scsi_id) !=\n\t    asc_dvc->cfg->chip_scsi_id) {\n\t\tasc_dvc->err_code |= ASC_IERR_SET_SCSI_ID;\n\t}\n#ifdef CONFIG_ISA\n\tif (asc_dvc->bus_type & ASC_IS_ISA) {\n\t\tAscSetIsaDmaChannel(iop_base, asc_dvc->cfg->isa_dma_channel);\n\t\tAscSetIsaDmaSpeed(iop_base, asc_dvc->cfg->isa_dma_speed);\n\t}\n#endif /* CONFIG_ISA */\n\n\tasc_dvc->init_state |= ASC_INIT_STATE_END_SET_CFG;\n\n\tswitch (warn_code) {\n\tcase 0:\t/* No error. */\n\t\tbreak;\n\tcase ASC_WARN_IO_PORT_ROTATE:\n\t\tshost_printk(KERN_WARNING, shost, \"I/O port address \"\n\t\t\t\t\"modified\\n\");\n\t\tbreak;\n\tcase ASC_WARN_AUTO_CONFIG:\n\t\tshost_printk(KERN_WARNING, shost, \"I/O port increment switch \"\n\t\t\t\t\"enabled\\n\");\n\t\tbreak;\n\tcase ASC_WARN_EEPROM_CHKSUM:\n\t\tshost_printk(KERN_WARNING, shost, \"EEPROM checksum error\\n\");\n\t\tbreak;\n\tcase ASC_WARN_IRQ_MODIFIED:\n\t\tshost_printk(KERN_WARNING, shost, \"IRQ modified\\n\");\n\t\tbreak;\n\tcase ASC_WARN_CMD_QNG_CONFLICT:\n\t\tshost_printk(KERN_WARNING, shost, \"tag queuing w/o \"\n\t\t\t\t\"disconnects\\n\");\n\t\tbreak;\n\tdefault:\n\t\tshost_printk(KERN_WARNING, shost, \"unknown warning: 0x%x\\n\",\n\t\t\t\twarn_code);\n\t\tbreak;\n\t}\n\n\tif (asc_dvc->err_code != 0)\n\t\tshost_printk(KERN_ERR, shost, \"error 0x%x at init_state \"\n\t\t\t\"0x%x\\n\", asc_dvc->err_code, asc_dvc->init_state);\n\n\treturn asc_dvc->err_code;\n}\n\n/*\n * EEPROM Configuration.\n *\n * All drivers should use this structure to set the default EEPROM\n * configuration. The BIOS now uses this structure when it is built.\n * Additional structure information can be found in a_condor.h where\n * the structure is defined.\n *\n * The *_Field_IsChar structs are needed to correct for endianness.\n * These values are read from the board 16 bits at a time directly\n * into the structs. Because some fields are char, the values will be\n * in the wrong order. The *_Field_IsChar tells when to flip the\n * bytes. Data read and written to PCI memory is automatically swapped\n * on big-endian platforms so char fields read as words are actually being\n * unswapped on big-endian platforms.\n */\n#ifdef CONFIG_PCI\nstatic ADVEEP_3550_CONFIG Default_3550_EEPROM_Config = {\n\tADV_EEPROM_BIOS_ENABLE,\t/* cfg_lsw */\n\t0x0000,\t\t\t/* cfg_msw */\n\t0xFFFF,\t\t\t/* disc_enable */\n\t0xFFFF,\t\t\t/* wdtr_able */\n\t0xFFFF,\t\t\t/* sdtr_able */\n\t0xFFFF,\t\t\t/* start_motor */\n\t0xFFFF,\t\t\t/* tagqng_able */\n\t0xFFFF,\t\t\t/* bios_scan */\n\t0,\t\t\t/* scam_tolerant */\n\t7,\t\t\t/* adapter_scsi_id */\n\t0,\t\t\t/* bios_boot_delay */\n\t3,\t\t\t/* scsi_reset_delay */\n\t0,\t\t\t/* bios_id_lun */\n\t0,\t\t\t/* termination */\n\t0,\t\t\t/* reserved1 */\n\t0xFFE7,\t\t\t/* bios_ctrl */\n\t0xFFFF,\t\t\t/* ultra_able */\n\t0,\t\t\t/* reserved2 */\n\tASC_DEF_MAX_HOST_QNG,\t/* max_host_qng */\n\tASC_DEF_MAX_DVC_QNG,\t/* max_dvc_qng */\n\t0,\t\t\t/* dvc_cntl */\n\t0,\t\t\t/* bug_fix */\n\t0,\t\t\t/* serial_number_word1 */\n\t0,\t\t\t/* serial_number_word2 */\n\t0,\t\t\t/* serial_number_word3 */\n\t0,\t\t\t/* check_sum */\n\t{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t,\t\t\t/* oem_name[16] */\n\t0,\t\t\t/* dvc_err_code */\n\t0,\t\t\t/* adv_err_code */\n\t0,\t\t\t/* adv_err_addr */\n\t0,\t\t\t/* saved_dvc_err_code */\n\t0,\t\t\t/* saved_adv_err_code */\n\t0,\t\t\t/* saved_adv_err_addr */\n\t0\t\t\t/* num_of_err */\n};\n\nstatic ADVEEP_3550_CONFIG ADVEEP_3550_Config_Field_IsChar = {\n\t0,\t\t\t/* cfg_lsw */\n\t0,\t\t\t/* cfg_msw */\n\t0,\t\t\t/* -disc_enable */\n\t0,\t\t\t/* wdtr_able */\n\t0,\t\t\t/* sdtr_able */\n\t0,\t\t\t/* start_motor */\n\t0,\t\t\t/* tagqng_able */\n\t0,\t\t\t/* bios_scan */\n\t0,\t\t\t/* scam_tolerant */\n\t1,\t\t\t/* adapter_scsi_id */\n\t1,\t\t\t/* bios_boot_delay */\n\t1,\t\t\t/* scsi_reset_delay */\n\t1,\t\t\t/* bios_id_lun */\n\t1,\t\t\t/* termination */\n\t1,\t\t\t/* reserved1 */\n\t0,\t\t\t/* bios_ctrl */\n\t0,\t\t\t/* ultra_able */\n\t0,\t\t\t/* reserved2 */\n\t1,\t\t\t/* max_host_qng */\n\t1,\t\t\t/* max_dvc_qng */\n\t0,\t\t\t/* dvc_cntl */\n\t0,\t\t\t/* bug_fix */\n\t0,\t\t\t/* serial_number_word1 */\n\t0,\t\t\t/* serial_number_word2 */\n\t0,\t\t\t/* serial_number_word3 */\n\t0,\t\t\t/* check_sum */\n\t{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n\t,\t\t\t/* oem_name[16] */\n\t0,\t\t\t/* dvc_err_code */\n\t0,\t\t\t/* adv_err_code */\n\t0,\t\t\t/* adv_err_addr */\n\t0,\t\t\t/* saved_dvc_err_code */\n\t0,\t\t\t/* saved_adv_err_code */\n\t0,\t\t\t/* saved_adv_err_addr */\n\t0\t\t\t/* num_of_err */\n};\n\nstatic ADVEEP_38C0800_CONFIG Default_38C0800_EEPROM_Config = {\n\tADV_EEPROM_BIOS_ENABLE,\t/* 00 cfg_lsw */\n\t0x0000,\t\t\t/* 01 cfg_msw */\n\t0xFFFF,\t\t\t/* 02 disc_enable */\n\t0xFFFF,\t\t\t/* 03 wdtr_able */\n\t0x4444,\t\t\t/* 04 sdtr_speed1 */\n\t0xFFFF,\t\t\t/* 05 start_motor */\n\t0xFFFF,\t\t\t/* 06 tagqng_able */\n\t0xFFFF,\t\t\t/* 07 bios_scan */\n\t0,\t\t\t/* 08 scam_tolerant */\n\t7,\t\t\t/* 09 adapter_scsi_id */\n\t0,\t\t\t/*    bios_boot_delay */\n\t3,\t\t\t/* 10 scsi_reset_delay */\n\t0,\t\t\t/*    bios_id_lun */\n\t0,\t\t\t/* 11 termination_se */\n\t0,\t\t\t/*    termination_lvd */\n\t0xFFE7,\t\t\t/* 12 bios_ctrl */\n\t0x4444,\t\t\t/* 13 sdtr_speed2 */\n\t0x4444,\t\t\t/* 14 sdtr_speed3 */\n\tASC_DEF_MAX_HOST_QNG,\t/* 15 max_host_qng */\n\tASC_DEF_MAX_DVC_QNG,\t/*    max_dvc_qng */\n\t0,\t\t\t/* 16 dvc_cntl */\n\t0x4444,\t\t\t/* 17 sdtr_speed4 */\n\t0,\t\t\t/* 18 serial_number_word1 */\n\t0,\t\t\t/* 19 serial_number_word2 */\n\t0,\t\t\t/* 20 serial_number_word3 */\n\t0,\t\t\t/* 21 check_sum */\n\t{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t,\t\t\t/* 22-29 oem_name[16] */\n\t0,\t\t\t/* 30 dvc_err_code */\n\t0,\t\t\t/* 31 adv_err_code */\n\t0,\t\t\t/* 32 adv_err_addr */\n\t0,\t\t\t/* 33 saved_dvc_err_code */\n\t0,\t\t\t/* 34 saved_adv_err_code */\n\t0,\t\t\t/* 35 saved_adv_err_addr */\n\t0,\t\t\t/* 36 reserved */\n\t0,\t\t\t/* 37 reserved */\n\t0,\t\t\t/* 38 reserved */\n\t0,\t\t\t/* 39 reserved */\n\t0,\t\t\t/* 40 reserved */\n\t0,\t\t\t/* 41 reserved */\n\t0,\t\t\t/* 42 reserved */\n\t0,\t\t\t/* 43 reserved */\n\t0,\t\t\t/* 44 reserved */\n\t0,\t\t\t/* 45 reserved */\n\t0,\t\t\t/* 46 reserved */\n\t0,\t\t\t/* 47 reserved */\n\t0,\t\t\t/* 48 reserved */\n\t0,\t\t\t/* 49 reserved */\n\t0,\t\t\t/* 50 reserved */\n\t0,\t\t\t/* 51 reserved */\n\t0,\t\t\t/* 52 reserved */\n\t0,\t\t\t/* 53 reserved */\n\t0,\t\t\t/* 54 reserved */\n\t0,\t\t\t/* 55 reserved */\n\t0,\t\t\t/* 56 cisptr_lsw */\n\t0,\t\t\t/* 57 cisprt_msw */\n\tPCI_VENDOR_ID_ASP,\t/* 58 subsysvid */\n\tPCI_DEVICE_ID_38C0800_REV1,\t/* 59 subsysid */\n\t0,\t\t\t/* 60 reserved */\n\t0,\t\t\t/* 61 reserved */\n\t0,\t\t\t/* 62 reserved */\n\t0\t\t\t/* 63 reserved */\n};\n\nstatic ADVEEP_38C0800_CONFIG ADVEEP_38C0800_Config_Field_IsChar = {\n\t0,\t\t\t/* 00 cfg_lsw */\n\t0,\t\t\t/* 01 cfg_msw */\n\t0,\t\t\t/* 02 disc_enable */\n\t0,\t\t\t/* 03 wdtr_able */\n\t0,\t\t\t/* 04 sdtr_speed1 */\n\t0,\t\t\t/* 05 start_motor */\n\t0,\t\t\t/* 06 tagqng_able */\n\t0,\t\t\t/* 07 bios_scan */\n\t0,\t\t\t/* 08 scam_tolerant */\n\t1,\t\t\t/* 09 adapter_scsi_id */\n\t1,\t\t\t/*    bios_boot_delay */\n\t1,\t\t\t/* 10 scsi_reset_delay */\n\t1,\t\t\t/*    bios_id_lun */\n\t1,\t\t\t/* 11 termination_se */\n\t1,\t\t\t/*    termination_lvd */\n\t0,\t\t\t/* 12 bios_ctrl */\n\t0,\t\t\t/* 13 sdtr_speed2 */\n\t0,\t\t\t/* 14 sdtr_speed3 */\n\t1,\t\t\t/* 15 max_host_qng */\n\t1,\t\t\t/*    max_dvc_qng */\n\t0,\t\t\t/* 16 dvc_cntl */\n\t0,\t\t\t/* 17 sdtr_speed4 */\n\t0,\t\t\t/* 18 serial_number_word1 */\n\t0,\t\t\t/* 19 serial_number_word2 */\n\t0,\t\t\t/* 20 serial_number_word3 */\n\t0,\t\t\t/* 21 check_sum */\n\t{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n\t,\t\t\t/* 22-29 oem_name[16] */\n\t0,\t\t\t/* 30 dvc_err_code */\n\t0,\t\t\t/* 31 adv_err_code */\n\t0,\t\t\t/* 32 adv_err_addr */\n\t0,\t\t\t/* 33 saved_dvc_err_code */\n\t0,\t\t\t/* 34 saved_adv_err_code */\n\t0,\t\t\t/* 35 saved_adv_err_addr */\n\t0,\t\t\t/* 36 reserved */\n\t0,\t\t\t/* 37 reserved */\n\t0,\t\t\t/* 38 reserved */\n\t0,\t\t\t/* 39 reserved */\n\t0,\t\t\t/* 40 reserved */\n\t0,\t\t\t/* 41 reserved */\n\t0,\t\t\t/* 42 reserved */\n\t0,\t\t\t/* 43 reserved */\n\t0,\t\t\t/* 44 reserved */\n\t0,\t\t\t/* 45 reserved */\n\t0,\t\t\t/* 46 reserved */\n\t0,\t\t\t/* 47 reserved */\n\t0,\t\t\t/* 48 reserved */\n\t0,\t\t\t/* 49 reserved */\n\t0,\t\t\t/* 50 reserved */\n\t0,\t\t\t/* 51 reserved */\n\t0,\t\t\t/* 52 reserved */\n\t0,\t\t\t/* 53 reserved */\n\t0,\t\t\t/* 54 reserved */\n\t0,\t\t\t/* 55 reserved */\n\t0,\t\t\t/* 56 cisptr_lsw */\n\t0,\t\t\t/* 57 cisprt_msw */\n\t0,\t\t\t/* 58 subsysvid */\n\t0,\t\t\t/* 59 subsysid */\n\t0,\t\t\t/* 60 reserved */\n\t0,\t\t\t/* 61 reserved */\n\t0,\t\t\t/* 62 reserved */\n\t0\t\t\t/* 63 reserved */\n};\n\nstatic ADVEEP_38C1600_CONFIG Default_38C1600_EEPROM_Config = {\n\tADV_EEPROM_BIOS_ENABLE,\t/* 00 cfg_lsw */\n\t0x0000,\t\t\t/* 01 cfg_msw */\n\t0xFFFF,\t\t\t/* 02 disc_enable */\n\t0xFFFF,\t\t\t/* 03 wdtr_able */\n\t0x5555,\t\t\t/* 04 sdtr_speed1 */\n\t0xFFFF,\t\t\t/* 05 start_motor */\n\t0xFFFF,\t\t\t/* 06 tagqng_able */\n\t0xFFFF,\t\t\t/* 07 bios_scan */\n\t0,\t\t\t/* 08 scam_tolerant */\n\t7,\t\t\t/* 09 adapter_scsi_id */\n\t0,\t\t\t/*    bios_boot_delay */\n\t3,\t\t\t/* 10 scsi_reset_delay */\n\t0,\t\t\t/*    bios_id_lun */\n\t0,\t\t\t/* 11 termination_se */\n\t0,\t\t\t/*    termination_lvd */\n\t0xFFE7,\t\t\t/* 12 bios_ctrl */\n\t0x5555,\t\t\t/* 13 sdtr_speed2 */\n\t0x5555,\t\t\t/* 14 sdtr_speed3 */\n\tASC_DEF_MAX_HOST_QNG,\t/* 15 max_host_qng */\n\tASC_DEF_MAX_DVC_QNG,\t/*    max_dvc_qng */\n\t0,\t\t\t/* 16 dvc_cntl */\n\t0x5555,\t\t\t/* 17 sdtr_speed4 */\n\t0,\t\t\t/* 18 serial_number_word1 */\n\t0,\t\t\t/* 19 serial_number_word2 */\n\t0,\t\t\t/* 20 serial_number_word3 */\n\t0,\t\t\t/* 21 check_sum */\n\t{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\t,\t\t\t/* 22-29 oem_name[16] */\n\t0,\t\t\t/* 30 dvc_err_code */\n\t0,\t\t\t/* 31 adv_err_code */\n\t0,\t\t\t/* 32 adv_err_addr */\n\t0,\t\t\t/* 33 saved_dvc_err_code */\n\t0,\t\t\t/* 34 saved_adv_err_code */\n\t0,\t\t\t/* 35 saved_adv_err_addr */\n\t0,\t\t\t/* 36 reserved */\n\t0,\t\t\t/* 37 reserved */\n\t0,\t\t\t/* 38 reserved */\n\t0,\t\t\t/* 39 reserved */\n\t0,\t\t\t/* 40 reserved */\n\t0,\t\t\t/* 41 reserved */\n\t0,\t\t\t/* 42 reserved */\n\t0,\t\t\t/* 43 reserved */\n\t0,\t\t\t/* 44 reserved */\n\t0,\t\t\t/* 45 reserved */\n\t0,\t\t\t/* 46 reserved */\n\t0,\t\t\t/* 47 reserved */\n\t0,\t\t\t/* 48 reserved */\n\t0,\t\t\t/* 49 reserved */\n\t0,\t\t\t/* 50 reserved */\n\t0,\t\t\t/* 51 reserved */\n\t0,\t\t\t/* 52 reserved */\n\t0,\t\t\t/* 53 reserved */\n\t0,\t\t\t/* 54 reserved */\n\t0,\t\t\t/* 55 reserved */\n\t0,\t\t\t/* 56 cisptr_lsw */\n\t0,\t\t\t/* 57 cisprt_msw */\n\tPCI_VENDOR_ID_ASP,\t/* 58 subsysvid */\n\tPCI_DEVICE_ID_38C1600_REV1,\t/* 59 subsysid */\n\t0,\t\t\t/* 60 reserved */\n\t0,\t\t\t/* 61 reserved */\n\t0,\t\t\t/* 62 reserved */\n\t0\t\t\t/* 63 reserved */\n};\n\nstatic ADVEEP_38C1600_CONFIG ADVEEP_38C1600_Config_Field_IsChar = {\n\t0,\t\t\t/* 00 cfg_lsw */\n\t0,\t\t\t/* 01 cfg_msw */\n\t0,\t\t\t/* 02 disc_enable */\n\t0,\t\t\t/* 03 wdtr_able */\n\t0,\t\t\t/* 04 sdtr_speed1 */\n\t0,\t\t\t/* 05 start_motor */\n\t0,\t\t\t/* 06 tagqng_able */\n\t0,\t\t\t/* 07 bios_scan */\n\t0,\t\t\t/* 08 scam_tolerant */\n\t1,\t\t\t/* 09 adapter_scsi_id */\n\t1,\t\t\t/*    bios_boot_delay */\n\t1,\t\t\t/* 10 scsi_reset_delay */\n\t1,\t\t\t/*    bios_id_lun */\n\t1,\t\t\t/* 11 termination_se */\n\t1,\t\t\t/*    termination_lvd */\n\t0,\t\t\t/* 12 bios_ctrl */\n\t0,\t\t\t/* 13 sdtr_speed2 */\n\t0,\t\t\t/* 14 sdtr_speed3 */\n\t1,\t\t\t/* 15 max_host_qng */\n\t1,\t\t\t/*    max_dvc_qng */\n\t0,\t\t\t/* 16 dvc_cntl */\n\t0,\t\t\t/* 17 sdtr_speed4 */\n\t0,\t\t\t/* 18 serial_number_word1 */\n\t0,\t\t\t/* 19 serial_number_word2 */\n\t0,\t\t\t/* 20 serial_number_word3 */\n\t0,\t\t\t/* 21 check_sum */\n\t{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n\t,\t\t\t/* 22-29 oem_name[16] */\n\t0,\t\t\t/* 30 dvc_err_code */\n\t0,\t\t\t/* 31 adv_err_code */\n\t0,\t\t\t/* 32 adv_err_addr */\n\t0,\t\t\t/* 33 saved_dvc_err_code */\n\t0,\t\t\t/* 34 saved_adv_err_code */\n\t0,\t\t\t/* 35 saved_adv_err_addr */\n\t0,\t\t\t/* 36 reserved */\n\t0,\t\t\t/* 37 reserved */\n\t0,\t\t\t/* 38 reserved */\n\t0,\t\t\t/* 39 reserved */\n\t0,\t\t\t/* 40 reserved */\n\t0,\t\t\t/* 41 reserved */\n\t0,\t\t\t/* 42 reserved */\n\t0,\t\t\t/* 43 reserved */\n\t0,\t\t\t/* 44 reserved */\n\t0,\t\t\t/* 45 reserved */\n\t0,\t\t\t/* 46 reserved */\n\t0,\t\t\t/* 47 reserved */\n\t0,\t\t\t/* 48 reserved */\n\t0,\t\t\t/* 49 reserved */\n\t0,\t\t\t/* 50 reserved */\n\t0,\t\t\t/* 51 reserved */\n\t0,\t\t\t/* 52 reserved */\n\t0,\t\t\t/* 53 reserved */\n\t0,\t\t\t/* 54 reserved */\n\t0,\t\t\t/* 55 reserved */\n\t0,\t\t\t/* 56 cisptr_lsw */\n\t0,\t\t\t/* 57 cisprt_msw */\n\t0,\t\t\t/* 58 subsysvid */\n\t0,\t\t\t/* 59 subsysid */\n\t0,\t\t\t/* 60 reserved */\n\t0,\t\t\t/* 61 reserved */\n\t0,\t\t\t/* 62 reserved */\n\t0\t\t\t/* 63 reserved */\n};\n\n/*\n * Wait for EEPROM command to complete\n */\nstatic void AdvWaitEEPCmd(AdvPortAddr iop_base)\n{\n\tint eep_delay_ms;\n\n\tfor (eep_delay_ms = 0; eep_delay_ms < ADV_EEP_DELAY_MS; eep_delay_ms++) {\n\t\tif (AdvReadWordRegister(iop_base, IOPW_EE_CMD) &\n\t\t    ASC_EEP_CMD_DONE) {\n\t\t\tbreak;\n\t\t}\n\t\tmdelay(1);\n\t}\n\tif ((AdvReadWordRegister(iop_base, IOPW_EE_CMD) & ASC_EEP_CMD_DONE) ==\n\t    0)\n\t\tBUG();\n}\n\n/*\n * Read the EEPROM from specified location\n */\nstatic ushort AdvReadEEPWord(AdvPortAddr iop_base, int eep_word_addr)\n{\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\n\t\t\t     ASC_EEP_CMD_READ | eep_word_addr);\n\tAdvWaitEEPCmd(iop_base);\n\treturn AdvReadWordRegister(iop_base, IOPW_EE_DATA);\n}\n\n/*\n * Write the EEPROM from 'cfg_buf'.\n */\nstatic void AdvSet3550EEPConfig(AdvPortAddr iop_base,\n\t\t\t\tADVEEP_3550_CONFIG *cfg_buf)\n{\n\tushort *wbuf;\n\tushort addr, chksum;\n\tushort *charfields;\n\n\twbuf = (ushort *)cfg_buf;\n\tcharfields = (ushort *)&ADVEEP_3550_Config_Field_IsChar;\n\tchksum = 0;\n\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);\n\tAdvWaitEEPCmd(iop_base);\n\n\t/*\n\t * Write EEPROM from word 0 to word 20.\n\t */\n\tfor (addr = ADV_EEP_DVC_CFG_BEGIN;\n\t     addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++) {\n\t\tushort word;\n\n\t\tif (*charfields++) {\n\t\t\tword = cpu_to_le16(*wbuf);\n\t\t} else {\n\t\t\tword = *wbuf;\n\t\t}\n\t\tchksum += *wbuf;\t/* Checksum is calculated from word values. */\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\n\t\t\t\t     ASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iop_base);\n\t\tmdelay(ADV_EEP_DELAY_MS);\n\t}\n\n\t/*\n\t * Write EEPROM checksum at word 21.\n\t */\n\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);\n\tAdvWaitEEPCmd(iop_base);\n\twbuf++;\n\tcharfields++;\n\n\t/*\n\t * Write EEPROM OEM name at words 22 to 29.\n\t */\n\tfor (addr = ADV_EEP_DVC_CTL_BEGIN;\n\t     addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++) {\n\t\tushort word;\n\n\t\tif (*charfields++) {\n\t\t\tword = cpu_to_le16(*wbuf);\n\t\t} else {\n\t\t\tword = *wbuf;\n\t\t}\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\n\t\t\t\t     ASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iop_base);\n\t}\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);\n\tAdvWaitEEPCmd(iop_base);\n}\n\n/*\n * Write the EEPROM from 'cfg_buf'.\n */\nstatic void AdvSet38C0800EEPConfig(AdvPortAddr iop_base,\n\t\t\t\t   ADVEEP_38C0800_CONFIG *cfg_buf)\n{\n\tushort *wbuf;\n\tushort *charfields;\n\tushort addr, chksum;\n\n\twbuf = (ushort *)cfg_buf;\n\tcharfields = (ushort *)&ADVEEP_38C0800_Config_Field_IsChar;\n\tchksum = 0;\n\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);\n\tAdvWaitEEPCmd(iop_base);\n\n\t/*\n\t * Write EEPROM from word 0 to word 20.\n\t */\n\tfor (addr = ADV_EEP_DVC_CFG_BEGIN;\n\t     addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++) {\n\t\tushort word;\n\n\t\tif (*charfields++) {\n\t\t\tword = cpu_to_le16(*wbuf);\n\t\t} else {\n\t\t\tword = *wbuf;\n\t\t}\n\t\tchksum += *wbuf;\t/* Checksum is calculated from word values. */\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\n\t\t\t\t     ASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iop_base);\n\t\tmdelay(ADV_EEP_DELAY_MS);\n\t}\n\n\t/*\n\t * Write EEPROM checksum at word 21.\n\t */\n\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);\n\tAdvWaitEEPCmd(iop_base);\n\twbuf++;\n\tcharfields++;\n\n\t/*\n\t * Write EEPROM OEM name at words 22 to 29.\n\t */\n\tfor (addr = ADV_EEP_DVC_CTL_BEGIN;\n\t     addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++) {\n\t\tushort word;\n\n\t\tif (*charfields++) {\n\t\t\tword = cpu_to_le16(*wbuf);\n\t\t} else {\n\t\t\tword = *wbuf;\n\t\t}\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\n\t\t\t\t     ASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iop_base);\n\t}\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);\n\tAdvWaitEEPCmd(iop_base);\n}\n\n/*\n * Write the EEPROM from 'cfg_buf'.\n */\nstatic void AdvSet38C1600EEPConfig(AdvPortAddr iop_base,\n\t\t\t\t   ADVEEP_38C1600_CONFIG *cfg_buf)\n{\n\tushort *wbuf;\n\tushort *charfields;\n\tushort addr, chksum;\n\n\twbuf = (ushort *)cfg_buf;\n\tcharfields = (ushort *)&ADVEEP_38C1600_Config_Field_IsChar;\n\tchksum = 0;\n\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);\n\tAdvWaitEEPCmd(iop_base);\n\n\t/*\n\t * Write EEPROM from word 0 to word 20.\n\t */\n\tfor (addr = ADV_EEP_DVC_CFG_BEGIN;\n\t     addr < ADV_EEP_DVC_CFG_END; addr++, wbuf++) {\n\t\tushort word;\n\n\t\tif (*charfields++) {\n\t\t\tword = cpu_to_le16(*wbuf);\n\t\t} else {\n\t\t\tword = *wbuf;\n\t\t}\n\t\tchksum += *wbuf;\t/* Checksum is calculated from word values. */\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\n\t\t\t\t     ASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iop_base);\n\t\tmdelay(ADV_EEP_DELAY_MS);\n\t}\n\n\t/*\n\t * Write EEPROM checksum at word 21.\n\t */\n\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);\n\tAdvWaitEEPCmd(iop_base);\n\twbuf++;\n\tcharfields++;\n\n\t/*\n\t * Write EEPROM OEM name at words 22 to 29.\n\t */\n\tfor (addr = ADV_EEP_DVC_CTL_BEGIN;\n\t     addr < ADV_EEP_MAX_WORD_ADDR; addr++, wbuf++) {\n\t\tushort word;\n\n\t\tif (*charfields++) {\n\t\t\tword = cpu_to_le16(*wbuf);\n\t\t} else {\n\t\t\tword = *wbuf;\n\t\t}\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_DATA, word);\n\t\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD,\n\t\t\t\t     ASC_EEP_CMD_WRITE | addr);\n\t\tAdvWaitEEPCmd(iop_base);\n\t}\n\tAdvWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);\n\tAdvWaitEEPCmd(iop_base);\n}\n\n/*\n * Read EEPROM configuration into the specified buffer.\n *\n * Return a checksum based on the EEPROM configuration read.\n */\nstatic ushort AdvGet3550EEPConfig(AdvPortAddr iop_base,\n\t\t\t\t  ADVEEP_3550_CONFIG *cfg_buf)\n{\n\tushort wval, chksum;\n\tushort *wbuf;\n\tint eep_addr;\n\tushort *charfields;\n\n\tcharfields = (ushort *)&ADVEEP_3550_Config_Field_IsChar;\n\twbuf = (ushort *)cfg_buf;\n\tchksum = 0;\n\n\tfor (eep_addr = ADV_EEP_DVC_CFG_BEGIN;\n\t     eep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {\n\t\twval = AdvReadEEPWord(iop_base, eep_addr);\n\t\tchksum += wval;\t/* Checksum is calculated from word values. */\n\t\tif (*charfields++) {\n\t\t\t*wbuf = le16_to_cpu(wval);\n\t\t} else {\n\t\t\t*wbuf = wval;\n\t\t}\n\t}\n\t/* Read checksum word. */\n\t*wbuf = AdvReadEEPWord(iop_base, eep_addr);\n\twbuf++;\n\tcharfields++;\n\n\t/* Read rest of EEPROM not covered by the checksum. */\n\tfor (eep_addr = ADV_EEP_DVC_CTL_BEGIN;\n\t     eep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {\n\t\t*wbuf = AdvReadEEPWord(iop_base, eep_addr);\n\t\tif (*charfields++) {\n\t\t\t*wbuf = le16_to_cpu(*wbuf);\n\t\t}\n\t}\n\treturn chksum;\n}\n\n/*\n * Read EEPROM configuration into the specified buffer.\n *\n * Return a checksum based on the EEPROM configuration read.\n */\nstatic ushort AdvGet38C0800EEPConfig(AdvPortAddr iop_base,\n\t\t\t\t     ADVEEP_38C0800_CONFIG *cfg_buf)\n{\n\tushort wval, chksum;\n\tushort *wbuf;\n\tint eep_addr;\n\tushort *charfields;\n\n\tcharfields = (ushort *)&ADVEEP_38C0800_Config_Field_IsChar;\n\twbuf = (ushort *)cfg_buf;\n\tchksum = 0;\n\n\tfor (eep_addr = ADV_EEP_DVC_CFG_BEGIN;\n\t     eep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {\n\t\twval = AdvReadEEPWord(iop_base, eep_addr);\n\t\tchksum += wval;\t/* Checksum is calculated from word values. */\n\t\tif (*charfields++) {\n\t\t\t*wbuf = le16_to_cpu(wval);\n\t\t} else {\n\t\t\t*wbuf = wval;\n\t\t}\n\t}\n\t/* Read checksum word. */\n\t*wbuf = AdvReadEEPWord(iop_base, eep_addr);\n\twbuf++;\n\tcharfields++;\n\n\t/* Read rest of EEPROM not covered by the checksum. */\n\tfor (eep_addr = ADV_EEP_DVC_CTL_BEGIN;\n\t     eep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {\n\t\t*wbuf = AdvReadEEPWord(iop_base, eep_addr);\n\t\tif (*charfields++) {\n\t\t\t*wbuf = le16_to_cpu(*wbuf);\n\t\t}\n\t}\n\treturn chksum;\n}\n\n/*\n * Read EEPROM configuration into the specified buffer.\n *\n * Return a checksum based on the EEPROM configuration read.\n */\nstatic ushort AdvGet38C1600EEPConfig(AdvPortAddr iop_base,\n\t\t\t\t     ADVEEP_38C1600_CONFIG *cfg_buf)\n{\n\tushort wval, chksum;\n\tushort *wbuf;\n\tint eep_addr;\n\tushort *charfields;\n\n\tcharfields = (ushort *)&ADVEEP_38C1600_Config_Field_IsChar;\n\twbuf = (ushort *)cfg_buf;\n\tchksum = 0;\n\n\tfor (eep_addr = ADV_EEP_DVC_CFG_BEGIN;\n\t     eep_addr < ADV_EEP_DVC_CFG_END; eep_addr++, wbuf++) {\n\t\twval = AdvReadEEPWord(iop_base, eep_addr);\n\t\tchksum += wval;\t/* Checksum is calculated from word values. */\n\t\tif (*charfields++) {\n\t\t\t*wbuf = le16_to_cpu(wval);\n\t\t} else {\n\t\t\t*wbuf = wval;\n\t\t}\n\t}\n\t/* Read checksum word. */\n\t*wbuf = AdvReadEEPWord(iop_base, eep_addr);\n\twbuf++;\n\tcharfields++;\n\n\t/* Read rest of EEPROM not covered by the checksum. */\n\tfor (eep_addr = ADV_EEP_DVC_CTL_BEGIN;\n\t     eep_addr < ADV_EEP_MAX_WORD_ADDR; eep_addr++, wbuf++) {\n\t\t*wbuf = AdvReadEEPWord(iop_base, eep_addr);\n\t\tif (*charfields++) {\n\t\t\t*wbuf = le16_to_cpu(*wbuf);\n\t\t}\n\t}\n\treturn chksum;\n}\n\n/*\n * Read the board's EEPROM configuration. Set fields in ADV_DVC_VAR and\n * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while\n * all of this is done.\n *\n * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.\n *\n * For a non-fatal error return a warning code. If there are no warnings\n * then 0 is returned.\n *\n * Note: Chip is stopped on entry.\n */\nstatic int AdvInitFrom3550EEP(ADV_DVC_VAR *asc_dvc)\n{\n\tAdvPortAddr iop_base;\n\tushort warn_code;\n\tADVEEP_3550_CONFIG eep_config;\n\n\tiop_base = asc_dvc->iop_base;\n\n\twarn_code = 0;\n\n\t/*\n\t * Read the board's EEPROM configuration.\n\t *\n\t * Set default values if a bad checksum is found.\n\t */\n\tif (AdvGet3550EEPConfig(iop_base, &eep_config) != eep_config.check_sum) {\n\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\n\t\t/*\n\t\t * Set EEPROM default values.\n\t\t */\n\t\tmemcpy(&eep_config, &Default_3550_EEPROM_Config,\n\t\t\tsizeof(ADVEEP_3550_CONFIG));\n\n\t\t/*\n\t\t * Assume the 6 byte board serial number that was read from\n\t\t * EEPROM is correct even if the EEPROM checksum failed.\n\t\t */\n\t\teep_config.serial_number_word3 =\n\t\t    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);\n\n\t\teep_config.serial_number_word2 =\n\t\t    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);\n\n\t\teep_config.serial_number_word1 =\n\t\t    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);\n\n\t\tAdvSet3550EEPConfig(iop_base, &eep_config);\n\t}\n\t/*\n\t * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the\n\t * EEPROM configuration that was read.\n\t *\n\t * This is the mapping of EEPROM fields to Adv Library fields.\n\t */\n\tasc_dvc->wdtr_able = eep_config.wdtr_able;\n\tasc_dvc->sdtr_able = eep_config.sdtr_able;\n\tasc_dvc->ultra_able = eep_config.ultra_able;\n\tasc_dvc->tagqng_able = eep_config.tagqng_able;\n\tasc_dvc->cfg->disc_enable = eep_config.disc_enable;\n\tasc_dvc->max_host_qng = eep_config.max_host_qng;\n\tasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\n\tasc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ADV_MAX_TID);\n\tasc_dvc->start_motor = eep_config.start_motor;\n\tasc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;\n\tasc_dvc->bios_ctrl = eep_config.bios_ctrl;\n\tasc_dvc->no_scam = eep_config.scam_tolerant;\n\tasc_dvc->cfg->serial1 = eep_config.serial_number_word1;\n\tasc_dvc->cfg->serial2 = eep_config.serial_number_word2;\n\tasc_dvc->cfg->serial3 = eep_config.serial_number_word3;\n\n\t/*\n\t * Set the host maximum queuing (max. 253, min. 16) and the per device\n\t * maximum queuing (max. 63, min. 4).\n\t */\n\tif (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {\n\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_host_qng == 0) {\n\t\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t\t} else {\n\t\t\teep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;\n\t\t}\n\t}\n\n\tif (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {\n\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_dvc_qng == 0) {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t\t} else {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;\n\t\t}\n\t}\n\n\t/*\n\t * If 'max_dvc_qng' is greater than 'max_host_qng', then\n\t * set 'max_dvc_qng' to 'max_host_qng'.\n\t */\n\tif (eep_config.max_dvc_qng > eep_config.max_host_qng) {\n\t\teep_config.max_dvc_qng = eep_config.max_host_qng;\n\t}\n\n\t/*\n\t * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'\n\t * values based on possibly adjusted EEPROM values.\n\t */\n\tasc_dvc->max_host_qng = eep_config.max_host_qng;\n\tasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\n\n\t/*\n\t * If the EEPROM 'termination' field is set to automatic (0), then set\n\t * the ADV_DVC_CFG 'termination' field to automatic also.\n\t *\n\t * If the termination is specified with a non-zero 'termination'\n\t * value check that a legal value is set and set the ADV_DVC_CFG\n\t * 'termination' field appropriately.\n\t */\n\tif (eep_config.termination == 0) {\n\t\tasc_dvc->cfg->termination = 0;\t/* auto termination */\n\t} else {\n\t\t/* Enable manual control with low off / high off. */\n\t\tif (eep_config.termination == 1) {\n\t\t\tasc_dvc->cfg->termination = TERM_CTL_SEL;\n\n\t\t\t/* Enable manual control with low off / high on. */\n\t\t} else if (eep_config.termination == 2) {\n\t\t\tasc_dvc->cfg->termination = TERM_CTL_SEL | TERM_CTL_H;\n\n\t\t\t/* Enable manual control with low on / high on. */\n\t\t} else if (eep_config.termination == 3) {\n\t\t\tasc_dvc->cfg->termination =\n\t\t\t    TERM_CTL_SEL | TERM_CTL_H | TERM_CTL_L;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The EEPROM 'termination' field contains a bad value. Use\n\t\t\t * automatic termination instead.\n\t\t\t */\n\t\t\tasc_dvc->cfg->termination = 0;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\treturn warn_code;\n}\n\n/*\n * Read the board's EEPROM configuration. Set fields in ADV_DVC_VAR and\n * ADV_DVC_CFG based on the EEPROM settings. The chip is stopped while\n * all of this is done.\n *\n * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.\n *\n * For a non-fatal error return a warning code. If there are no warnings\n * then 0 is returned.\n *\n * Note: Chip is stopped on entry.\n */\nstatic int AdvInitFrom38C0800EEP(ADV_DVC_VAR *asc_dvc)\n{\n\tAdvPortAddr iop_base;\n\tushort warn_code;\n\tADVEEP_38C0800_CONFIG eep_config;\n\tuchar tid, termination;\n\tushort sdtr_speed = 0;\n\n\tiop_base = asc_dvc->iop_base;\n\n\twarn_code = 0;\n\n\t/*\n\t * Read the board's EEPROM configuration.\n\t *\n\t * Set default values if a bad checksum is found.\n\t */\n\tif (AdvGet38C0800EEPConfig(iop_base, &eep_config) !=\n\t    eep_config.check_sum) {\n\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\n\t\t/*\n\t\t * Set EEPROM default values.\n\t\t */\n\t\tmemcpy(&eep_config, &Default_38C0800_EEPROM_Config,\n\t\t\tsizeof(ADVEEP_38C0800_CONFIG));\n\n\t\t/*\n\t\t * Assume the 6 byte board serial number that was read from\n\t\t * EEPROM is correct even if the EEPROM checksum failed.\n\t\t */\n\t\teep_config.serial_number_word3 =\n\t\t    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);\n\n\t\teep_config.serial_number_word2 =\n\t\t    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);\n\n\t\teep_config.serial_number_word1 =\n\t\t    AdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);\n\n\t\tAdvSet38C0800EEPConfig(iop_base, &eep_config);\n\t}\n\t/*\n\t * Set ADV_DVC_VAR and ADV_DVC_CFG variables from the\n\t * EEPROM configuration that was read.\n\t *\n\t * This is the mapping of EEPROM fields to Adv Library fields.\n\t */\n\tasc_dvc->wdtr_able = eep_config.wdtr_able;\n\tasc_dvc->sdtr_speed1 = eep_config.sdtr_speed1;\n\tasc_dvc->sdtr_speed2 = eep_config.sdtr_speed2;\n\tasc_dvc->sdtr_speed3 = eep_config.sdtr_speed3;\n\tasc_dvc->sdtr_speed4 = eep_config.sdtr_speed4;\n\tasc_dvc->tagqng_able = eep_config.tagqng_able;\n\tasc_dvc->cfg->disc_enable = eep_config.disc_enable;\n\tasc_dvc->max_host_qng = eep_config.max_host_qng;\n\tasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\n\tasc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ADV_MAX_TID);\n\tasc_dvc->start_motor = eep_config.start_motor;\n\tasc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;\n\tasc_dvc->bios_ctrl = eep_config.bios_ctrl;\n\tasc_dvc->no_scam = eep_config.scam_tolerant;\n\tasc_dvc->cfg->serial1 = eep_config.serial_number_word1;\n\tasc_dvc->cfg->serial2 = eep_config.serial_number_word2;\n\tasc_dvc->cfg->serial3 = eep_config.serial_number_word3;\n\n\t/*\n\t * For every Target ID if any of its 'sdtr_speed[1234]' bits\n\t * are set, then set an 'sdtr_able' bit for it.\n\t */\n\tasc_dvc->sdtr_able = 0;\n\tfor (tid = 0; tid <= ADV_MAX_TID; tid++) {\n\t\tif (tid == 0) {\n\t\t\tsdtr_speed = asc_dvc->sdtr_speed1;\n\t\t} else if (tid == 4) {\n\t\t\tsdtr_speed = asc_dvc->sdtr_speed2;\n\t\t} else if (tid == 8) {\n\t\t\tsdtr_speed = asc_dvc->sdtr_speed3;\n\t\t} else if (tid == 12) {\n\t\t\tsdtr_speed = asc_dvc->sdtr_speed4;\n\t\t}\n\t\tif (sdtr_speed & ADV_MAX_TID) {\n\t\t\tasc_dvc->sdtr_able |= (1 << tid);\n\t\t}\n\t\tsdtr_speed >>= 4;\n\t}\n\n\t/*\n\t * Set the host maximum queuing (max. 253, min. 16) and the per device\n\t * maximum queuing (max. 63, min. 4).\n\t */\n\tif (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {\n\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_host_qng == 0) {\n\t\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t\t} else {\n\t\t\teep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;\n\t\t}\n\t}\n\n\tif (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {\n\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_dvc_qng == 0) {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t\t} else {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;\n\t\t}\n\t}\n\n\t/*\n\t * If 'max_dvc_qng' is greater than 'max_host_qng', then\n\t * set 'max_dvc_qng' to 'max_host_qng'.\n\t */\n\tif (eep_config.max_dvc_qng > eep_config.max_host_qng) {\n\t\teep_config.max_dvc_qng = eep_config.max_host_qng;\n\t}\n\n\t/*\n\t * Set ADV_DVC_VAR 'max_host_qng' and ADV_DVC_VAR 'max_dvc_qng'\n\t * values based on possibly adjusted EEPROM values.\n\t */\n\tasc_dvc->max_host_qng = eep_config.max_host_qng;\n\tasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\n\n\t/*\n\t * If the EEPROM 'termination' field is set to automatic (0), then set\n\t * the ADV_DVC_CFG 'termination' field to automatic also.\n\t *\n\t * If the termination is specified with a non-zero 'termination'\n\t * value check that a legal value is set and set the ADV_DVC_CFG\n\t * 'termination' field appropriately.\n\t */\n\tif (eep_config.termination_se == 0) {\n\t\ttermination = 0;\t/* auto termination for SE */\n\t} else {\n\t\t/* Enable manual control with low off / high off. */\n\t\tif (eep_config.termination_se == 1) {\n\t\t\ttermination = 0;\n\n\t\t\t/* Enable manual control with low off / high on. */\n\t\t} else if (eep_config.termination_se == 2) {\n\t\t\ttermination = TERM_SE_HI;\n\n\t\t\t/* Enable manual control with low on / high on. */\n\t\t} else if (eep_config.termination_se == 3) {\n\t\t\ttermination = TERM_SE;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The EEPROM 'termination_se' field contains a bad value.\n\t\t\t * Use automatic termination instead.\n\t\t\t */\n\t\t\ttermination = 0;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\tif (eep_config.termination_lvd == 0) {\n\t\tasc_dvc->cfg->termination = termination;\t/* auto termination for LVD */\n\t} else {\n\t\t/* Enable manual control with low off / high off. */\n\t\tif (eep_config.termination_lvd == 1) {\n\t\t\tasc_dvc->cfg->termination = termination;\n\n\t\t\t/* Enable manual control with low off / high on. */\n\t\t} else if (eep_config.termination_lvd == 2) {\n\t\t\tasc_dvc->cfg->termination = termination | TERM_LVD_HI;\n\n\t\t\t/* Enable manual control with low on / high on. */\n\t\t} else if (eep_config.termination_lvd == 3) {\n\t\t\tasc_dvc->cfg->termination = termination | TERM_LVD;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The EEPROM 'termination_lvd' field contains a bad value.\n\t\t\t * Use automatic termination instead.\n\t\t\t */\n\t\t\tasc_dvc->cfg->termination = termination;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\treturn warn_code;\n}\n\n/*\n * Read the board's EEPROM configuration. Set fields in ASC_DVC_VAR and\n * ASC_DVC_CFG based on the EEPROM settings. The chip is stopped while\n * all of this is done.\n *\n * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.\n *\n * For a non-fatal error return a warning code. If there are no warnings\n * then 0 is returned.\n *\n * Note: Chip is stopped on entry.\n */\nstatic int AdvInitFrom38C1600EEP(ADV_DVC_VAR *asc_dvc)\n{\n\tAdvPortAddr iop_base;\n\tushort warn_code;\n\tADVEEP_38C1600_CONFIG eep_config;\n\tuchar tid, termination;\n\tushort sdtr_speed = 0;\n\n\tiop_base = asc_dvc->iop_base;\n\n\twarn_code = 0;\n\n\t/*\n\t * Read the board's EEPROM configuration.\n\t *\n\t * Set default values if a bad checksum is found.\n\t */\n\tif (AdvGet38C1600EEPConfig(iop_base, &eep_config) !=\n\t    eep_config.check_sum) {\n\t\tstruct pci_dev *pdev = adv_dvc_to_pdev(asc_dvc);\n\t\twarn_code |= ASC_WARN_EEPROM_CHKSUM;\n\n\t\t/*\n\t\t * Set EEPROM default values.\n\t\t */\n\t\tmemcpy(&eep_config, &Default_38C1600_EEPROM_Config,\n\t\t\tsizeof(ADVEEP_38C1600_CONFIG));\n\n\t\tif (PCI_FUNC(pdev->devfn) != 0) {\n\t\t\tu8 ints;\n\t\t\t/*\n\t\t\t * Disable Bit 14 (BIOS_ENABLE) to fix SPARC Ultra 60\n\t\t\t * and old Mac system booting problem. The Expansion\n\t\t\t * ROM must be disabled in Function 1 for these systems\n\t\t\t */\n\t\t\teep_config.cfg_lsw &= ~ADV_EEPROM_BIOS_ENABLE;\n\t\t\t/*\n\t\t\t * Clear the INTAB (bit 11) if the GPIO 0 input\n\t\t\t * indicates the Function 1 interrupt line is wired\n\t\t\t * to INTB.\n\t\t\t *\n\t\t\t * Set/Clear Bit 11 (INTAB) from the GPIO bit 0 input:\n\t\t\t *   1 - Function 1 interrupt line wired to INT A.\n\t\t\t *   0 - Function 1 interrupt line wired to INT B.\n\t\t\t *\n\t\t\t * Note: Function 0 is always wired to INTA.\n\t\t\t * Put all 5 GPIO bits in input mode and then read\n\t\t\t * their input values.\n\t\t\t */\n\t\t\tAdvWriteByteRegister(iop_base, IOPB_GPIO_CNTL, 0);\n\t\t\tints = AdvReadByteRegister(iop_base, IOPB_GPIO_DATA);\n\t\t\tif ((ints & 0x01) == 0)\n\t\t\t\teep_config.cfg_lsw &= ~ADV_EEPROM_INTAB;\n\t\t}\n\n\t\t/*\n\t\t * Assume the 6 byte board serial number that was read from\n\t\t * EEPROM is correct even if the EEPROM checksum failed.\n\t\t */\n\t\teep_config.serial_number_word3 =\n\t\t\tAdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 1);\n\t\teep_config.serial_number_word2 =\n\t\t\tAdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 2);\n\t\teep_config.serial_number_word1 =\n\t\t\tAdvReadEEPWord(iop_base, ADV_EEP_DVC_CFG_END - 3);\n\n\t\tAdvSet38C1600EEPConfig(iop_base, &eep_config);\n\t}\n\n\t/*\n\t * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the\n\t * EEPROM configuration that was read.\n\t *\n\t * This is the mapping of EEPROM fields to Adv Library fields.\n\t */\n\tasc_dvc->wdtr_able = eep_config.wdtr_able;\n\tasc_dvc->sdtr_speed1 = eep_config.sdtr_speed1;\n\tasc_dvc->sdtr_speed2 = eep_config.sdtr_speed2;\n\tasc_dvc->sdtr_speed3 = eep_config.sdtr_speed3;\n\tasc_dvc->sdtr_speed4 = eep_config.sdtr_speed4;\n\tasc_dvc->ppr_able = 0;\n\tasc_dvc->tagqng_able = eep_config.tagqng_able;\n\tasc_dvc->cfg->disc_enable = eep_config.disc_enable;\n\tasc_dvc->max_host_qng = eep_config.max_host_qng;\n\tasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\n\tasc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ASC_MAX_TID);\n\tasc_dvc->start_motor = eep_config.start_motor;\n\tasc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;\n\tasc_dvc->bios_ctrl = eep_config.bios_ctrl;\n\tasc_dvc->no_scam = eep_config.scam_tolerant;\n\n\t/*\n\t * For every Target ID if any of its 'sdtr_speed[1234]' bits\n\t * are set, then set an 'sdtr_able' bit for it.\n\t */\n\tasc_dvc->sdtr_able = 0;\n\tfor (tid = 0; tid <= ASC_MAX_TID; tid++) {\n\t\tif (tid == 0) {\n\t\t\tsdtr_speed = asc_dvc->sdtr_speed1;\n\t\t} else if (tid == 4) {\n\t\t\tsdtr_speed = asc_dvc->sdtr_speed2;\n\t\t} else if (tid == 8) {\n\t\t\tsdtr_speed = asc_dvc->sdtr_speed3;\n\t\t} else if (tid == 12) {\n\t\t\tsdtr_speed = asc_dvc->sdtr_speed4;\n\t\t}\n\t\tif (sdtr_speed & ASC_MAX_TID) {\n\t\t\tasc_dvc->sdtr_able |= (1 << tid);\n\t\t}\n\t\tsdtr_speed >>= 4;\n\t}\n\n\t/*\n\t * Set the host maximum queuing (max. 253, min. 16) and the per device\n\t * maximum queuing (max. 63, min. 4).\n\t */\n\tif (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG) {\n\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t} else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_host_qng == 0) {\n\t\t\teep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;\n\t\t} else {\n\t\t\teep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;\n\t\t}\n\t}\n\n\tif (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG) {\n\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t} else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG) {\n\t\t/* If the value is zero, assume it is uninitialized. */\n\t\tif (eep_config.max_dvc_qng == 0) {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;\n\t\t} else {\n\t\t\teep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;\n\t\t}\n\t}\n\n\t/*\n\t * If 'max_dvc_qng' is greater than 'max_host_qng', then\n\t * set 'max_dvc_qng' to 'max_host_qng'.\n\t */\n\tif (eep_config.max_dvc_qng > eep_config.max_host_qng) {\n\t\teep_config.max_dvc_qng = eep_config.max_host_qng;\n\t}\n\n\t/*\n\t * Set ASC_DVC_VAR 'max_host_qng' and ASC_DVC_VAR 'max_dvc_qng'\n\t * values based on possibly adjusted EEPROM values.\n\t */\n\tasc_dvc->max_host_qng = eep_config.max_host_qng;\n\tasc_dvc->max_dvc_qng = eep_config.max_dvc_qng;\n\n\t/*\n\t * If the EEPROM 'termination' field is set to automatic (0), then set\n\t * the ASC_DVC_CFG 'termination' field to automatic also.\n\t *\n\t * If the termination is specified with a non-zero 'termination'\n\t * value check that a legal value is set and set the ASC_DVC_CFG\n\t * 'termination' field appropriately.\n\t */\n\tif (eep_config.termination_se == 0) {\n\t\ttermination = 0;\t/* auto termination for SE */\n\t} else {\n\t\t/* Enable manual control with low off / high off. */\n\t\tif (eep_config.termination_se == 1) {\n\t\t\ttermination = 0;\n\n\t\t\t/* Enable manual control with low off / high on. */\n\t\t} else if (eep_config.termination_se == 2) {\n\t\t\ttermination = TERM_SE_HI;\n\n\t\t\t/* Enable manual control with low on / high on. */\n\t\t} else if (eep_config.termination_se == 3) {\n\t\t\ttermination = TERM_SE;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The EEPROM 'termination_se' field contains a bad value.\n\t\t\t * Use automatic termination instead.\n\t\t\t */\n\t\t\ttermination = 0;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\tif (eep_config.termination_lvd == 0) {\n\t\tasc_dvc->cfg->termination = termination;\t/* auto termination for LVD */\n\t} else {\n\t\t/* Enable manual control with low off / high off. */\n\t\tif (eep_config.termination_lvd == 1) {\n\t\t\tasc_dvc->cfg->termination = termination;\n\n\t\t\t/* Enable manual control with low off / high on. */\n\t\t} else if (eep_config.termination_lvd == 2) {\n\t\t\tasc_dvc->cfg->termination = termination | TERM_LVD_HI;\n\n\t\t\t/* Enable manual control with low on / high on. */\n\t\t} else if (eep_config.termination_lvd == 3) {\n\t\t\tasc_dvc->cfg->termination = termination | TERM_LVD;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The EEPROM 'termination_lvd' field contains a bad value.\n\t\t\t * Use automatic termination instead.\n\t\t\t */\n\t\t\tasc_dvc->cfg->termination = termination;\n\t\t\twarn_code |= ASC_WARN_EEPROM_TERMINATION;\n\t\t}\n\t}\n\n\treturn warn_code;\n}\n\n/*\n * Initialize the ADV_DVC_VAR structure.\n *\n * On failure set the ADV_DVC_VAR field 'err_code' and return ADV_ERROR.\n *\n * For a non-fatal error return a warning code. If there are no warnings\n * then 0 is returned.\n */\nstatic int AdvInitGetConfig(struct pci_dev *pdev, struct Scsi_Host *shost)\n{\n\tstruct asc_board *board = shost_priv(shost);\n\tADV_DVC_VAR *asc_dvc = &board->dvc_var.adv_dvc_var;\n\tunsigned short warn_code = 0;\n\tAdvPortAddr iop_base = asc_dvc->iop_base;\n\tu16 cmd;\n\tint status;\n\n\tasc_dvc->err_code = 0;\n\n\t/*\n\t * Save the state of the PCI Configuration Command Register\n\t * \"Parity Error Response Control\" Bit. If the bit is clear (0),\n\t * in AdvInitAsc3550/38C0800Driver() tell the microcode to ignore\n\t * DMA parity errors.\n\t */\n\tasc_dvc->cfg->control_flag = 0;\n\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\n\tif ((cmd & PCI_COMMAND_PARITY) == 0)\n\t\tasc_dvc->cfg->control_flag |= CONTROL_FLAG_IGNORE_PERR;\n\n\tasc_dvc->cfg->chip_version =\n\t    AdvGetChipVersion(iop_base, asc_dvc->bus_type);\n\n\tASC_DBG(1, \"iopb_chip_id_1: 0x%x 0x%x\\n\",\n\t\t (ushort)AdvReadByteRegister(iop_base, IOPB_CHIP_ID_1),\n\t\t (ushort)ADV_CHIP_ID_BYTE);\n\n\tASC_DBG(1, \"iopw_chip_id_0: 0x%x 0x%x\\n\",\n\t\t (ushort)AdvReadWordRegister(iop_base, IOPW_CHIP_ID_0),\n\t\t (ushort)ADV_CHIP_ID_WORD);\n\n\t/*\n\t * Reset the chip to start and allow register writes.\n\t */\n\tif (AdvFindSignature(iop_base) == 0) {\n\t\tasc_dvc->err_code = ASC_IERR_BAD_SIGNATURE;\n\t\treturn ADV_ERROR;\n\t} else {\n\t\t/*\n\t\t * The caller must set 'chip_type' to a valid setting.\n\t\t */\n\t\tif (asc_dvc->chip_type != ADV_CHIP_ASC3550 &&\n\t\t    asc_dvc->chip_type != ADV_CHIP_ASC38C0800 &&\n\t\t    asc_dvc->chip_type != ADV_CHIP_ASC38C1600) {\n\t\t\tasc_dvc->err_code |= ASC_IERR_BAD_CHIPTYPE;\n\t\t\treturn ADV_ERROR;\n\t\t}\n\n\t\t/*\n\t\t * Reset Chip.\n\t\t */\n\t\tAdvWriteWordRegister(iop_base, IOPW_CTRL_REG,\n\t\t\t\t     ADV_CTRL_REG_CMD_RESET);\n\t\tmdelay(100);\n\t\tAdvWriteWordRegister(iop_base, IOPW_CTRL_REG,\n\t\t\t\t     ADV_CTRL_REG_CMD_WR_IO_REG);\n\n\t\tif (asc_dvc->chip_type == ADV_CHIP_ASC38C1600) {\n\t\t\tstatus = AdvInitFrom38C1600EEP(asc_dvc);\n\t\t} else if (asc_dvc->chip_type == ADV_CHIP_ASC38C0800) {\n\t\t\tstatus = AdvInitFrom38C0800EEP(asc_dvc);\n\t\t} else {\n\t\t\tstatus = AdvInitFrom3550EEP(asc_dvc);\n\t\t}\n\t\twarn_code |= status;\n\t}\n\n\tif (warn_code != 0)\n\t\tshost_printk(KERN_WARNING, shost, \"warning: 0x%x\\n\", warn_code);\n\n\tif (asc_dvc->err_code)\n\t\tshost_printk(KERN_ERR, shost, \"error code 0x%x\\n\",\n\t\t\t\tasc_dvc->err_code);\n\n\treturn asc_dvc->err_code;\n}\n#endif\n\nstatic struct scsi_host_template advansys_template = {\n\t.proc_name = DRV_NAME,\n#ifdef CONFIG_PROC_FS\n\t.show_info = advansys_show_info,\n#endif\n\t.name = DRV_NAME,\n\t.info = advansys_info,\n\t.queuecommand = advansys_queuecommand,\n\t.eh_host_reset_handler = advansys_reset,\n\t.bios_param = advansys_biosparam,\n\t.slave_configure = advansys_slave_configure,\n\t/*\n\t * Because the driver may control an ISA adapter 'unchecked_isa_dma'\n\t * must be set. The flag will be cleared in advansys_board_found\n\t * for non-ISA adapters.\n\t */\n\t.unchecked_isa_dma = true,\n};\n\nstatic int advansys_wide_init_chip(struct Scsi_Host *shost)\n{\n\tstruct asc_board *board = shost_priv(shost);\n\tstruct adv_dvc_var *adv_dvc = &board->dvc_var.adv_dvc_var;\n\tsize_t sgblk_pool_size;\n\tint warn_code, err_code;\n\n\t/*\n\t * Allocate buffer carrier structures. The total size\n\t * is about 8 KB, so allocate all at once.\n\t */\n\tadv_dvc->carrier = dma_alloc_coherent(board->dev,\n\t\tADV_CARRIER_BUFSIZE, &adv_dvc->carrier_addr, GFP_KERNEL);\n\tASC_DBG(1, \"carrier 0x%p\\n\", adv_dvc->carrier);\n\n\tif (!adv_dvc->carrier)\n\t\tgoto kmalloc_failed;\n\n\t/*\n\t * Allocate up to 'max_host_qng' request structures for the Wide\n\t * board. The total size is about 16 KB, so allocate all at once.\n\t * If the allocation fails decrement and try again.\n\t */\n\tboard->adv_reqp_size = adv_dvc->max_host_qng * sizeof(adv_req_t);\n\tif (board->adv_reqp_size & 0x1f) {\n\t\tASC_DBG(1, \"unaligned reqp %lu bytes\\n\", sizeof(adv_req_t));\n\t\tboard->adv_reqp_size = ADV_32BALIGN(board->adv_reqp_size);\n\t}\n\tboard->adv_reqp = dma_alloc_coherent(board->dev, board->adv_reqp_size,\n\t\t&board->adv_reqp_addr, GFP_KERNEL);\n\n\tif (!board->adv_reqp)\n\t\tgoto kmalloc_failed;\n\n\tASC_DBG(1, \"reqp 0x%p, req_cnt %d, bytes %lu\\n\", board->adv_reqp,\n\t\tadv_dvc->max_host_qng, board->adv_reqp_size);\n\n\t/*\n\t * Allocate up to ADV_TOT_SG_BLOCK request structures for\n\t * the Wide board. Each structure is about 136 bytes.\n\t */\n\tsgblk_pool_size = sizeof(adv_sgblk_t) * ADV_TOT_SG_BLOCK;\n\tboard->adv_sgblk_pool = dma_pool_create(\"adv_sgblk\", board->dev,\n\t\t\t\t\t\tsgblk_pool_size, 32, 0);\n\n\tASC_DBG(1, \"sg_cnt %d * %lu = %lu bytes\\n\", ADV_TOT_SG_BLOCK,\n\t\tsizeof(adv_sgblk_t), sgblk_pool_size);\n\n\tif (!board->adv_sgblk_pool)\n\t\tgoto kmalloc_failed;\n\n\tif (adv_dvc->chip_type == ADV_CHIP_ASC3550) {\n\t\tASC_DBG(2, \"AdvInitAsc3550Driver()\\n\");\n\t\twarn_code = AdvInitAsc3550Driver(adv_dvc);\n\t} else if (adv_dvc->chip_type == ADV_CHIP_ASC38C0800) {\n\t\tASC_DBG(2, \"AdvInitAsc38C0800Driver()\\n\");\n\t\twarn_code = AdvInitAsc38C0800Driver(adv_dvc);\n\t} else {\n\t\tASC_DBG(2, \"AdvInitAsc38C1600Driver()\\n\");\n\t\twarn_code = AdvInitAsc38C1600Driver(adv_dvc);\n\t}\n\terr_code = adv_dvc->err_code;\n\n\tif (warn_code || err_code) {\n\t\tshost_printk(KERN_WARNING, shost, \"error: warn 0x%x, error \"\n\t\t\t\"0x%x\\n\", warn_code, err_code);\n\t}\n\n\tgoto exit;\n\n kmalloc_failed:\n\tshost_printk(KERN_ERR, shost, \"error: kmalloc() failed\\n\");\n\terr_code = ADV_ERROR;\n exit:\n\treturn err_code;\n}\n\nstatic void advansys_wide_free_mem(struct asc_board *board)\n{\n\tstruct adv_dvc_var *adv_dvc = &board->dvc_var.adv_dvc_var;\n\n\tif (adv_dvc->carrier) {\n\t\tdma_free_coherent(board->dev, ADV_CARRIER_BUFSIZE,\n\t\t\t\t  adv_dvc->carrier, adv_dvc->carrier_addr);\n\t\tadv_dvc->carrier = NULL;\n\t}\n\tif (board->adv_reqp) {\n\t\tdma_free_coherent(board->dev, board->adv_reqp_size,\n\t\t\t\t  board->adv_reqp, board->adv_reqp_addr);\n\t\tboard->adv_reqp = NULL;\n\t}\n\tif (board->adv_sgblk_pool) {\n\t\tdma_pool_destroy(board->adv_sgblk_pool);\n\t\tboard->adv_sgblk_pool = NULL;\n\t}\n}\n\nstatic int advansys_board_found(struct Scsi_Host *shost, unsigned int iop,\n\t\t\t\tint bus_type)\n{\n\tstruct pci_dev *pdev;\n\tstruct asc_board *boardp = shost_priv(shost);\n\tASC_DVC_VAR *asc_dvc_varp = NULL;\n\tADV_DVC_VAR *adv_dvc_varp = NULL;\n\tint share_irq, warn_code, ret;\n\n\tpdev = (bus_type == ASC_IS_PCI) ? to_pci_dev(boardp->dev) : NULL;\n\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tASC_DBG(1, \"narrow board\\n\");\n\t\tasc_dvc_varp = &boardp->dvc_var.asc_dvc_var;\n\t\tasc_dvc_varp->bus_type = bus_type;\n\t\tasc_dvc_varp->drv_ptr = boardp;\n\t\tasc_dvc_varp->cfg = &boardp->dvc_cfg.asc_dvc_cfg;\n\t\tasc_dvc_varp->iop_base = iop;\n\t} else {\n#ifdef CONFIG_PCI\n\t\tadv_dvc_varp = &boardp->dvc_var.adv_dvc_var;\n\t\tadv_dvc_varp->drv_ptr = boardp;\n\t\tadv_dvc_varp->cfg = &boardp->dvc_cfg.adv_dvc_cfg;\n\t\tif (pdev->device == PCI_DEVICE_ID_ASP_ABP940UW) {\n\t\t\tASC_DBG(1, \"wide board ASC-3550\\n\");\n\t\t\tadv_dvc_varp->chip_type = ADV_CHIP_ASC3550;\n\t\t} else if (pdev->device == PCI_DEVICE_ID_38C0800_REV1) {\n\t\t\tASC_DBG(1, \"wide board ASC-38C0800\\n\");\n\t\t\tadv_dvc_varp->chip_type = ADV_CHIP_ASC38C0800;\n\t\t} else {\n\t\t\tASC_DBG(1, \"wide board ASC-38C1600\\n\");\n\t\t\tadv_dvc_varp->chip_type = ADV_CHIP_ASC38C1600;\n\t\t}\n\n\t\tboardp->asc_n_io_port = pci_resource_len(pdev, 1);\n\t\tboardp->ioremap_addr = pci_ioremap_bar(pdev, 1);\n\t\tif (!boardp->ioremap_addr) {\n\t\t\tshost_printk(KERN_ERR, shost, \"ioremap(%lx, %d) \"\n\t\t\t\t\t\"returned NULL\\n\",\n\t\t\t\t\t(long)pci_resource_start(pdev, 1),\n\t\t\t\t\tboardp->asc_n_io_port);\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_shost;\n\t\t}\n\t\tadv_dvc_varp->iop_base = (AdvPortAddr)boardp->ioremap_addr;\n\t\tASC_DBG(1, \"iop_base: 0x%p\\n\", adv_dvc_varp->iop_base);\n\n\t\t/*\n\t\t * Even though it isn't used to access wide boards, other\n\t\t * than for the debug line below, save I/O Port address so\n\t\t * that it can be reported.\n\t\t */\n\t\tboardp->ioport = iop;\n\n\t\tASC_DBG(1, \"iopb_chip_id_1 0x%x, iopw_chip_id_0 0x%x\\n\",\n\t\t\t\t(ushort)inp(iop + 1), (ushort)inpw(iop));\n#endif /* CONFIG_PCI */\n\t}\n\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\t/*\n\t\t * Set the board bus type and PCI IRQ before\n\t\t * calling AscInitGetConfig().\n\t\t */\n\t\tswitch (asc_dvc_varp->bus_type) {\n#ifdef CONFIG_ISA\n\t\tcase ASC_IS_ISA:\n\t\t\tshost->unchecked_isa_dma = true;\n\t\t\tshare_irq = 0;\n\t\t\tbreak;\n\t\tcase ASC_IS_VL:\n\t\t\tshost->unchecked_isa_dma = false;\n\t\t\tshare_irq = 0;\n\t\t\tbreak;\n\t\tcase ASC_IS_EISA:\n\t\t\tshost->unchecked_isa_dma = false;\n\t\t\tshare_irq = IRQF_SHARED;\n\t\t\tbreak;\n#endif /* CONFIG_ISA */\n#ifdef CONFIG_PCI\n\t\tcase ASC_IS_PCI:\n\t\t\tshost->unchecked_isa_dma = false;\n\t\t\tshare_irq = IRQF_SHARED;\n\t\t\tbreak;\n#endif /* CONFIG_PCI */\n\t\tdefault:\n\t\t\tshost_printk(KERN_ERR, shost, \"unknown adapter type: \"\n\t\t\t\t\t\"%d\\n\", asc_dvc_varp->bus_type);\n\t\t\tshost->unchecked_isa_dma = false;\n\t\t\tshare_irq = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * NOTE: AscInitGetConfig() may change the board's\n\t\t * bus_type value. The bus_type value should no\n\t\t * longer be used. If the bus_type field must be\n\t\t * referenced only use the bit-wise AND operator \"&\".\n\t\t */\n\t\tASC_DBG(2, \"AscInitGetConfig()\\n\");\n\t\tret = AscInitGetConfig(shost) ? -ENODEV : 0;\n\t} else {\n#ifdef CONFIG_PCI\n\t\t/*\n\t\t * For Wide boards set PCI information before calling\n\t\t * AdvInitGetConfig().\n\t\t */\n\t\tshost->unchecked_isa_dma = false;\n\t\tshare_irq = IRQF_SHARED;\n\t\tASC_DBG(2, \"AdvInitGetConfig()\\n\");\n\n\t\tret = AdvInitGetConfig(pdev, shost) ? -ENODEV : 0;\n#else\n\t\tshare_irq = 0;\n\t\tret = -ENODEV;\n#endif /* CONFIG_PCI */\n\t}\n\n\tif (ret)\n\t\tgoto err_unmap;\n\n\t/*\n\t * Save the EEPROM configuration so that it can be displayed\n\t * from /proc/scsi/advansys/[0...].\n\t */\n\tif (ASC_NARROW_BOARD(boardp)) {\n\n\t\tASCEEP_CONFIG *ep;\n\n\t\t/*\n\t\t * Set the adapter's target id bit in the 'init_tidmask' field.\n\t\t */\n\t\tboardp->init_tidmask |=\n\t\t    ADV_TID_TO_TIDMASK(asc_dvc_varp->cfg->chip_scsi_id);\n\n\t\t/*\n\t\t * Save EEPROM settings for the board.\n\t\t */\n\t\tep = &boardp->eep_config.asc_eep;\n\n\t\tep->init_sdtr = asc_dvc_varp->cfg->sdtr_enable;\n\t\tep->disc_enable = asc_dvc_varp->cfg->disc_enable;\n\t\tep->use_cmd_qng = asc_dvc_varp->cfg->cmd_qng_enabled;\n\t\tASC_EEP_SET_DMA_SPD(ep, asc_dvc_varp->cfg->isa_dma_speed);\n\t\tep->start_motor = asc_dvc_varp->start_motor;\n\t\tep->cntl = asc_dvc_varp->dvc_cntl;\n\t\tep->no_scam = asc_dvc_varp->no_scam;\n\t\tep->max_total_qng = asc_dvc_varp->max_total_qng;\n\t\tASC_EEP_SET_CHIP_ID(ep, asc_dvc_varp->cfg->chip_scsi_id);\n\t\t/* 'max_tag_qng' is set to the same value for every device. */\n\t\tep->max_tag_qng = asc_dvc_varp->cfg->max_tag_qng[0];\n\t\tep->adapter_info[0] = asc_dvc_varp->cfg->adapter_info[0];\n\t\tep->adapter_info[1] = asc_dvc_varp->cfg->adapter_info[1];\n\t\tep->adapter_info[2] = asc_dvc_varp->cfg->adapter_info[2];\n\t\tep->adapter_info[3] = asc_dvc_varp->cfg->adapter_info[3];\n\t\tep->adapter_info[4] = asc_dvc_varp->cfg->adapter_info[4];\n\t\tep->adapter_info[5] = asc_dvc_varp->cfg->adapter_info[5];\n\n\t\t/*\n\t\t * Modify board configuration.\n\t\t */\n\t\tASC_DBG(2, \"AscInitSetConfig()\\n\");\n\t\tret = AscInitSetConfig(pdev, shost) ? -ENODEV : 0;\n\t\tif (ret)\n\t\t\tgoto err_unmap;\n\t} else {\n\t\tADVEEP_3550_CONFIG *ep_3550;\n\t\tADVEEP_38C0800_CONFIG *ep_38C0800;\n\t\tADVEEP_38C1600_CONFIG *ep_38C1600;\n\n\t\t/*\n\t\t * Save Wide EEP Configuration Information.\n\t\t */\n\t\tif (adv_dvc_varp->chip_type == ADV_CHIP_ASC3550) {\n\t\t\tep_3550 = &boardp->eep_config.adv_3550_eep;\n\n\t\t\tep_3550->adapter_scsi_id = adv_dvc_varp->chip_scsi_id;\n\t\t\tep_3550->max_host_qng = adv_dvc_varp->max_host_qng;\n\t\t\tep_3550->max_dvc_qng = adv_dvc_varp->max_dvc_qng;\n\t\t\tep_3550->termination = adv_dvc_varp->cfg->termination;\n\t\t\tep_3550->disc_enable = adv_dvc_varp->cfg->disc_enable;\n\t\t\tep_3550->bios_ctrl = adv_dvc_varp->bios_ctrl;\n\t\t\tep_3550->wdtr_able = adv_dvc_varp->wdtr_able;\n\t\t\tep_3550->sdtr_able = adv_dvc_varp->sdtr_able;\n\t\t\tep_3550->ultra_able = adv_dvc_varp->ultra_able;\n\t\t\tep_3550->tagqng_able = adv_dvc_varp->tagqng_able;\n\t\t\tep_3550->start_motor = adv_dvc_varp->start_motor;\n\t\t\tep_3550->scsi_reset_delay =\n\t\t\t    adv_dvc_varp->scsi_reset_wait;\n\t\t\tep_3550->serial_number_word1 =\n\t\t\t    adv_dvc_varp->cfg->serial1;\n\t\t\tep_3550->serial_number_word2 =\n\t\t\t    adv_dvc_varp->cfg->serial2;\n\t\t\tep_3550->serial_number_word3 =\n\t\t\t    adv_dvc_varp->cfg->serial3;\n\t\t} else if (adv_dvc_varp->chip_type == ADV_CHIP_ASC38C0800) {\n\t\t\tep_38C0800 = &boardp->eep_config.adv_38C0800_eep;\n\n\t\t\tep_38C0800->adapter_scsi_id =\n\t\t\t    adv_dvc_varp->chip_scsi_id;\n\t\t\tep_38C0800->max_host_qng = adv_dvc_varp->max_host_qng;\n\t\t\tep_38C0800->max_dvc_qng = adv_dvc_varp->max_dvc_qng;\n\t\t\tep_38C0800->termination_lvd =\n\t\t\t    adv_dvc_varp->cfg->termination;\n\t\t\tep_38C0800->disc_enable =\n\t\t\t    adv_dvc_varp->cfg->disc_enable;\n\t\t\tep_38C0800->bios_ctrl = adv_dvc_varp->bios_ctrl;\n\t\t\tep_38C0800->wdtr_able = adv_dvc_varp->wdtr_able;\n\t\t\tep_38C0800->tagqng_able = adv_dvc_varp->tagqng_able;\n\t\t\tep_38C0800->sdtr_speed1 = adv_dvc_varp->sdtr_speed1;\n\t\t\tep_38C0800->sdtr_speed2 = adv_dvc_varp->sdtr_speed2;\n\t\t\tep_38C0800->sdtr_speed3 = adv_dvc_varp->sdtr_speed3;\n\t\t\tep_38C0800->sdtr_speed4 = adv_dvc_varp->sdtr_speed4;\n\t\t\tep_38C0800->tagqng_able = adv_dvc_varp->tagqng_able;\n\t\t\tep_38C0800->start_motor = adv_dvc_varp->start_motor;\n\t\t\tep_38C0800->scsi_reset_delay =\n\t\t\t    adv_dvc_varp->scsi_reset_wait;\n\t\t\tep_38C0800->serial_number_word1 =\n\t\t\t    adv_dvc_varp->cfg->serial1;\n\t\t\tep_38C0800->serial_number_word2 =\n\t\t\t    adv_dvc_varp->cfg->serial2;\n\t\t\tep_38C0800->serial_number_word3 =\n\t\t\t    adv_dvc_varp->cfg->serial3;\n\t\t} else {\n\t\t\tep_38C1600 = &boardp->eep_config.adv_38C1600_eep;\n\n\t\t\tep_38C1600->adapter_scsi_id =\n\t\t\t    adv_dvc_varp->chip_scsi_id;\n\t\t\tep_38C1600->max_host_qng = adv_dvc_varp->max_host_qng;\n\t\t\tep_38C1600->max_dvc_qng = adv_dvc_varp->max_dvc_qng;\n\t\t\tep_38C1600->termination_lvd =\n\t\t\t    adv_dvc_varp->cfg->termination;\n\t\t\tep_38C1600->disc_enable =\n\t\t\t    adv_dvc_varp->cfg->disc_enable;\n\t\t\tep_38C1600->bios_ctrl = adv_dvc_varp->bios_ctrl;\n\t\t\tep_38C1600->wdtr_able = adv_dvc_varp->wdtr_able;\n\t\t\tep_38C1600->tagqng_able = adv_dvc_varp->tagqng_able;\n\t\t\tep_38C1600->sdtr_speed1 = adv_dvc_varp->sdtr_speed1;\n\t\t\tep_38C1600->sdtr_speed2 = adv_dvc_varp->sdtr_speed2;\n\t\t\tep_38C1600->sdtr_speed3 = adv_dvc_varp->sdtr_speed3;\n\t\t\tep_38C1600->sdtr_speed4 = adv_dvc_varp->sdtr_speed4;\n\t\t\tep_38C1600->tagqng_able = adv_dvc_varp->tagqng_able;\n\t\t\tep_38C1600->start_motor = adv_dvc_varp->start_motor;\n\t\t\tep_38C1600->scsi_reset_delay =\n\t\t\t    adv_dvc_varp->scsi_reset_wait;\n\t\t\tep_38C1600->serial_number_word1 =\n\t\t\t    adv_dvc_varp->cfg->serial1;\n\t\t\tep_38C1600->serial_number_word2 =\n\t\t\t    adv_dvc_varp->cfg->serial2;\n\t\t\tep_38C1600->serial_number_word3 =\n\t\t\t    adv_dvc_varp->cfg->serial3;\n\t\t}\n\n\t\t/*\n\t\t * Set the adapter's target id bit in the 'init_tidmask' field.\n\t\t */\n\t\tboardp->init_tidmask |=\n\t\t    ADV_TID_TO_TIDMASK(adv_dvc_varp->chip_scsi_id);\n\t}\n\n\t/*\n\t * Channels are numbered beginning with 0. For AdvanSys one host\n\t * structure supports one channel. Multi-channel boards have a\n\t * separate host structure for each channel.\n\t */\n\tshost->max_channel = 0;\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tshost->max_id = ASC_MAX_TID + 1;\n\t\tshost->max_lun = ASC_MAX_LUN + 1;\n\t\tshost->max_cmd_len = ASC_MAX_CDB_LEN;\n\n\t\tshost->io_port = asc_dvc_varp->iop_base;\n\t\tboardp->asc_n_io_port = ASC_IOADR_GAP;\n\t\tshost->this_id = asc_dvc_varp->cfg->chip_scsi_id;\n\n\t\t/* Set maximum number of queues the adapter can handle. */\n\t\tshost->can_queue = asc_dvc_varp->max_total_qng;\n\t} else {\n\t\tshost->max_id = ADV_MAX_TID + 1;\n\t\tshost->max_lun = ADV_MAX_LUN + 1;\n\t\tshost->max_cmd_len = ADV_MAX_CDB_LEN;\n\n\t\t/*\n\t\t * Save the I/O Port address and length even though\n\t\t * I/O ports are not used to access Wide boards.\n\t\t * Instead the Wide boards are accessed with\n\t\t * PCI Memory Mapped I/O.\n\t\t */\n\t\tshost->io_port = iop;\n\n\t\tshost->this_id = adv_dvc_varp->chip_scsi_id;\n\n\t\t/* Set maximum number of queues the adapter can handle. */\n\t\tshost->can_queue = adv_dvc_varp->max_host_qng;\n\t}\n\n\t/*\n\t * Set the maximum number of scatter-gather elements the\n\t * adapter can handle.\n\t */\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\t/*\n\t\t * Allow two commands with 'sg_tablesize' scatter-gather\n\t\t * elements to be executed simultaneously. This value is\n\t\t * the theoretical hardware limit. It may be decreased\n\t\t * below.\n\t\t */\n\t\tshost->sg_tablesize =\n\t\t    (((asc_dvc_varp->max_total_qng - 2) / 2) *\n\t\t     ASC_SG_LIST_PER_Q) + 1;\n\t} else {\n\t\tshost->sg_tablesize = ADV_MAX_SG_LIST;\n\t}\n\n\t/*\n\t * The value of 'sg_tablesize' can not exceed the SCSI\n\t * mid-level driver definition of SG_ALL. SG_ALL also\n\t * must not be exceeded, because it is used to define the\n\t * size of the scatter-gather table in 'struct asc_sg_head'.\n\t */\n\tif (shost->sg_tablesize > SG_ALL) {\n\t\tshost->sg_tablesize = SG_ALL;\n\t}\n\n\tASC_DBG(1, \"sg_tablesize: %d\\n\", shost->sg_tablesize);\n\n\t/* BIOS start address. */\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tshost->base = AscGetChipBiosAddress(asc_dvc_varp->iop_base,\n\t\t\t\t\t\t    asc_dvc_varp->bus_type);\n\t} else {\n\t\t/*\n\t\t * Fill-in BIOS board variables. The Wide BIOS saves\n\t\t * information in LRAM that is used by the driver.\n\t\t */\n\t\tAdvReadWordLram(adv_dvc_varp->iop_base,\n\t\t\t\tBIOS_SIGNATURE, boardp->bios_signature);\n\t\tAdvReadWordLram(adv_dvc_varp->iop_base,\n\t\t\t\tBIOS_VERSION, boardp->bios_version);\n\t\tAdvReadWordLram(adv_dvc_varp->iop_base,\n\t\t\t\tBIOS_CODESEG, boardp->bios_codeseg);\n\t\tAdvReadWordLram(adv_dvc_varp->iop_base,\n\t\t\t\tBIOS_CODELEN, boardp->bios_codelen);\n\n\t\tASC_DBG(1, \"bios_signature 0x%x, bios_version 0x%x\\n\",\n\t\t\t boardp->bios_signature, boardp->bios_version);\n\n\t\tASC_DBG(1, \"bios_codeseg 0x%x, bios_codelen 0x%x\\n\",\n\t\t\t boardp->bios_codeseg, boardp->bios_codelen);\n\n\t\t/*\n\t\t * If the BIOS saved a valid signature, then fill in\n\t\t * the BIOS code segment base address.\n\t\t */\n\t\tif (boardp->bios_signature == 0x55AA) {\n\t\t\t/*\n\t\t\t * Convert x86 realmode code segment to a linear\n\t\t\t * address by shifting left 4.\n\t\t\t */\n\t\t\tshost->base = ((ulong)boardp->bios_codeseg << 4);\n\t\t} else {\n\t\t\tshost->base = 0;\n\t\t}\n\t}\n\n\t/*\n\t * Register Board Resources - I/O Port, DMA, IRQ\n\t */\n\n\t/* Register DMA Channel for Narrow boards. */\n\tshost->dma_channel = NO_ISA_DMA;\t/* Default to no ISA DMA. */\n#ifdef CONFIG_ISA\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\t/* Register DMA channel for ISA bus. */\n\t\tif (asc_dvc_varp->bus_type & ASC_IS_ISA) {\n\t\t\tshost->dma_channel = asc_dvc_varp->cfg->isa_dma_channel;\n\t\t\tret = request_dma(shost->dma_channel, DRV_NAME);\n\t\t\tif (ret) {\n\t\t\t\tshost_printk(KERN_ERR, shost, \"request_dma() \"\n\t\t\t\t\t\t\"%d failed %d\\n\",\n\t\t\t\t\t\tshost->dma_channel, ret);\n\t\t\t\tgoto err_unmap;\n\t\t\t}\n\t\t\tAscEnableIsaDma(shost->dma_channel);\n\t\t}\n\t}\n#endif /* CONFIG_ISA */\n\n\t/* Register IRQ Number. */\n\tASC_DBG(2, \"request_irq(%d, %p)\\n\", boardp->irq, shost);\n\n\tret = request_irq(boardp->irq, advansys_interrupt, share_irq,\n\t\t\t  DRV_NAME, shost);\n\n\tif (ret) {\n\t\tif (ret == -EBUSY) {\n\t\t\tshost_printk(KERN_ERR, shost, \"request_irq(): IRQ 0x%x \"\n\t\t\t\t\t\"already in use\\n\", boardp->irq);\n\t\t} else if (ret == -EINVAL) {\n\t\t\tshost_printk(KERN_ERR, shost, \"request_irq(): IRQ 0x%x \"\n\t\t\t\t\t\"not valid\\n\", boardp->irq);\n\t\t} else {\n\t\t\tshost_printk(KERN_ERR, shost, \"request_irq(): IRQ 0x%x \"\n\t\t\t\t\t\"failed with %d\\n\", boardp->irq, ret);\n\t\t}\n\t\tgoto err_free_dma;\n\t}\n\n\t/*\n\t * Initialize board RISC chip and enable interrupts.\n\t */\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tASC_DBG(2, \"AscInitAsc1000Driver()\\n\");\n\n\t\tasc_dvc_varp->overrun_buf = kzalloc(ASC_OVERRUN_BSIZE, GFP_KERNEL);\n\t\tif (!asc_dvc_varp->overrun_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_irq;\n\t\t}\n\t\twarn_code = AscInitAsc1000Driver(asc_dvc_varp);\n\n\t\tif (warn_code || asc_dvc_varp->err_code) {\n\t\t\tshost_printk(KERN_ERR, shost, \"error: init_state 0x%x, \"\n\t\t\t\t\t\"warn 0x%x, error 0x%x\\n\",\n\t\t\t\t\tasc_dvc_varp->init_state, warn_code,\n\t\t\t\t\tasc_dvc_varp->err_code);\n\t\t\tif (!asc_dvc_varp->overrun_dma) {\n\t\t\t\tret = -ENODEV;\n\t\t\t\tgoto err_free_mem;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (advansys_wide_init_chip(shost)) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_free_mem;\n\t\t}\n\t}\n\n\tASC_DBG_PRT_SCSI_HOST(2, shost);\n\n\tret = scsi_add_host(shost, boardp->dev);\n\tif (ret)\n\t\tgoto err_free_mem;\n\n\tscsi_scan_host(shost);\n\treturn 0;\n\n err_free_mem:\n\tif (ASC_NARROW_BOARD(boardp)) {\n\t\tif (asc_dvc_varp->overrun_dma)\n\t\t\tdma_unmap_single(boardp->dev, asc_dvc_varp->overrun_dma,\n\t\t\t\t\t ASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);\n\t\tkfree(asc_dvc_varp->overrun_buf);\n\t} else\n\t\tadvansys_wide_free_mem(boardp);\n err_free_irq:\n\tfree_irq(boardp->irq, shost);\n err_free_dma:\n#ifdef CONFIG_ISA\n\tif (shost->dma_channel != NO_ISA_DMA)\n\t\tfree_dma(shost->dma_channel);\n#endif\n err_unmap:\n\tif (boardp->ioremap_addr)\n\t\tiounmap(boardp->ioremap_addr);\n#ifdef CONFIG_PCI\n err_shost:\n#endif\n\treturn ret;\n}\n\n/*\n * advansys_release()\n *\n * Release resources allocated for a single AdvanSys adapter.\n */\nstatic int advansys_release(struct Scsi_Host *shost)\n{\n\tstruct asc_board *board = shost_priv(shost);\n\tASC_DBG(1, \"begin\\n\");\n\tscsi_remove_host(shost);\n\tfree_irq(board->irq, shost);\n#ifdef CONFIG_ISA\n\tif (shost->dma_channel != NO_ISA_DMA) {\n\t\tASC_DBG(1, \"free_dma()\\n\");\n\t\tfree_dma(shost->dma_channel);\n\t}\n#endif\n\tif (ASC_NARROW_BOARD(board)) {\n\t\tdma_unmap_single(board->dev,\n\t\t\t\t\tboard->dvc_var.asc_dvc_var.overrun_dma,\n\t\t\t\t\tASC_OVERRUN_BSIZE, DMA_FROM_DEVICE);\n\t\tkfree(board->dvc_var.asc_dvc_var.overrun_buf);\n\t} else {\n\t\tiounmap(board->ioremap_addr);\n\t\tadvansys_wide_free_mem(board);\n\t}\n\tscsi_host_put(shost);\n\tASC_DBG(1, \"end\\n\");\n\treturn 0;\n}\n\n#define ASC_IOADR_TABLE_MAX_IX  11\n\nstatic PortAddr _asc_def_iop_base[ASC_IOADR_TABLE_MAX_IX] = {\n\t0x100, 0x0110, 0x120, 0x0130, 0x140, 0x0150, 0x0190,\n\t0x0210, 0x0230, 0x0250, 0x0330\n};\n\n/*\n * The ISA IRQ number is found in bits 2 and 3 of the CfgLsw.  It decodes as:\n * 00: 10\n * 01: 11\n * 10: 12\n * 11: 15\n */\nstatic unsigned int advansys_isa_irq_no(PortAddr iop_base)\n{\n\tunsigned short cfg_lsw = AscGetChipCfgLsw(iop_base);\n\tunsigned int chip_irq = ((cfg_lsw >> 2) & 0x03) + 10;\n\tif (chip_irq == 13)\n\t\tchip_irq = 15;\n\treturn chip_irq;\n}\n\nstatic int advansys_isa_probe(struct device *dev, unsigned int id)\n{\n\tint err = -ENODEV;\n\tPortAddr iop_base = _asc_def_iop_base[id];\n\tstruct Scsi_Host *shost;\n\tstruct asc_board *board;\n\n\tif (!request_region(iop_base, ASC_IOADR_GAP, DRV_NAME)) {\n\t\tASC_DBG(1, \"I/O port 0x%x busy\\n\", iop_base);\n\t\treturn -ENODEV;\n\t}\n\tASC_DBG(1, \"probing I/O port 0x%x\\n\", iop_base);\n\tif (!AscFindSignature(iop_base))\n\t\tgoto release_region;\n\tif (!(AscGetChipVersion(iop_base, ASC_IS_ISA) & ASC_CHIP_VER_ISA_BIT))\n\t\tgoto release_region;\n\n\terr = -ENOMEM;\n\tshost = scsi_host_alloc(&advansys_template, sizeof(*board));\n\tif (!shost)\n\t\tgoto release_region;\n\n\tboard = shost_priv(shost);\n\tboard->irq = advansys_isa_irq_no(iop_base);\n\tboard->dev = dev;\n\tboard->shost = shost;\n\n\terr = advansys_board_found(shost, iop_base, ASC_IS_ISA);\n\tif (err)\n\t\tgoto free_host;\n\n\tdev_set_drvdata(dev, shost);\n\treturn 0;\n\n free_host:\n\tscsi_host_put(shost);\n release_region:\n\trelease_region(iop_base, ASC_IOADR_GAP);\n\treturn err;\n}\n\nstatic int advansys_isa_remove(struct device *dev, unsigned int id)\n{\n\tint ioport = _asc_def_iop_base[id];\n\tadvansys_release(dev_get_drvdata(dev));\n\trelease_region(ioport, ASC_IOADR_GAP);\n\treturn 0;\n}\n\nstatic struct isa_driver advansys_isa_driver = {\n\t.probe\t\t= advansys_isa_probe,\n\t.remove\t\t= advansys_isa_remove,\n\t.driver = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= DRV_NAME,\n\t},\n};\n\n/*\n * The VLB IRQ number is found in bits 2 to 4 of the CfgLsw.  It decodes as:\n * 000: invalid\n * 001: 10\n * 010: 11\n * 011: 12\n * 100: invalid\n * 101: 14\n * 110: 15\n * 111: invalid\n */\nstatic unsigned int advansys_vlb_irq_no(PortAddr iop_base)\n{\n\tunsigned short cfg_lsw = AscGetChipCfgLsw(iop_base);\n\tunsigned int chip_irq = ((cfg_lsw >> 2) & 0x07) + 9;\n\tif ((chip_irq < 10) || (chip_irq == 13) || (chip_irq > 15))\n\t\treturn 0;\n\treturn chip_irq;\n}\n\nstatic int advansys_vlb_probe(struct device *dev, unsigned int id)\n{\n\tint err = -ENODEV;\n\tPortAddr iop_base = _asc_def_iop_base[id];\n\tstruct Scsi_Host *shost;\n\tstruct asc_board *board;\n\n\tif (!request_region(iop_base, ASC_IOADR_GAP, DRV_NAME)) {\n\t\tASC_DBG(1, \"I/O port 0x%x busy\\n\", iop_base);\n\t\treturn -ENODEV;\n\t}\n\tASC_DBG(1, \"probing I/O port 0x%x\\n\", iop_base);\n\tif (!AscFindSignature(iop_base))\n\t\tgoto release_region;\n\t/*\n\t * I don't think this condition can actually happen, but the old\n\t * driver did it, and the chances of finding a VLB setup in 2007\n\t * to do testing with is slight to none.\n\t */\n\tif (AscGetChipVersion(iop_base, ASC_IS_VL) > ASC_CHIP_MAX_VER_VL)\n\t\tgoto release_region;\n\n\terr = -ENOMEM;\n\tshost = scsi_host_alloc(&advansys_template, sizeof(*board));\n\tif (!shost)\n\t\tgoto release_region;\n\n\tboard = shost_priv(shost);\n\tboard->irq = advansys_vlb_irq_no(iop_base);\n\tboard->dev = dev;\n\tboard->shost = shost;\n\n\terr = advansys_board_found(shost, iop_base, ASC_IS_VL);\n\tif (err)\n\t\tgoto free_host;\n\n\tdev_set_drvdata(dev, shost);\n\treturn 0;\n\n free_host:\n\tscsi_host_put(shost);\n release_region:\n\trelease_region(iop_base, ASC_IOADR_GAP);\n\treturn -ENODEV;\n}\n\nstatic struct isa_driver advansys_vlb_driver = {\n\t.probe\t\t= advansys_vlb_probe,\n\t.remove\t\t= advansys_isa_remove,\n\t.driver = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= \"advansys_vlb\",\n\t},\n};\n\nstatic struct eisa_device_id advansys_eisa_table[] = {\n\t{ \"ABP7401\" },\n\t{ \"ABP7501\" },\n\t{ \"\" }\n};\n\nMODULE_DEVICE_TABLE(eisa, advansys_eisa_table);\n\n/*\n * EISA is a little more tricky than PCI; each EISA device may have two\n * channels, and this driver is written to make each channel its own Scsi_Host\n */\nstruct eisa_scsi_data {\n\tstruct Scsi_Host *host[2];\n};\n\n/*\n * The EISA IRQ number is found in bits 8 to 10 of the CfgLsw.  It decodes as:\n * 000: 10\n * 001: 11\n * 010: 12\n * 011: invalid\n * 100: 14\n * 101: 15\n * 110: invalid\n * 111: invalid\n */\nstatic unsigned int advansys_eisa_irq_no(struct eisa_device *edev)\n{\n\tunsigned short cfg_lsw = inw(edev->base_addr + 0xc86);\n\tunsigned int chip_irq = ((cfg_lsw >> 8) & 0x07) + 10;\n\tif ((chip_irq == 13) || (chip_irq > 15))\n\t\treturn 0;\n\treturn chip_irq;\n}\n\nstatic int advansys_eisa_probe(struct device *dev)\n{\n\tint i, ioport, irq = 0;\n\tint err;\n\tstruct eisa_device *edev = to_eisa_device(dev);\n\tstruct eisa_scsi_data *data;\n\n\terr = -ENOMEM;\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\tgoto fail;\n\tioport = edev->base_addr + 0xc30;\n\n\terr = -ENODEV;\n\tfor (i = 0; i < 2; i++, ioport += 0x20) {\n\t\tstruct asc_board *board;\n\t\tstruct Scsi_Host *shost;\n\t\tif (!request_region(ioport, ASC_IOADR_GAP, DRV_NAME)) {\n\t\t\tprintk(KERN_WARNING \"Region %x-%x busy\\n\", ioport,\n\t\t\t       ioport + ASC_IOADR_GAP - 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!AscFindSignature(ioport)) {\n\t\t\trelease_region(ioport, ASC_IOADR_GAP);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * I don't know why we need to do this for EISA chips, but\n\t\t * not for any others.  It looks to be equivalent to\n\t\t * AscGetChipCfgMsw, but I may have overlooked something,\n\t\t * so I'm not converting it until I get an EISA board to\n\t\t * test with.\n\t\t */\n\t\tinw(ioport + 4);\n\n\t\tif (!irq)\n\t\t\tirq = advansys_eisa_irq_no(edev);\n\n\t\terr = -ENOMEM;\n\t\tshost = scsi_host_alloc(&advansys_template, sizeof(*board));\n\t\tif (!shost)\n\t\t\tgoto release_region;\n\n\t\tboard = shost_priv(shost);\n\t\tboard->irq = irq;\n\t\tboard->dev = dev;\n\t\tboard->shost = shost;\n\n\t\terr = advansys_board_found(shost, ioport, ASC_IS_EISA);\n\t\tif (!err) {\n\t\t\tdata->host[i] = shost;\n\t\t\tcontinue;\n\t\t}\n\n\t\tscsi_host_put(shost);\n release_region:\n\t\trelease_region(ioport, ASC_IOADR_GAP);\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\tgoto free_data;\n\tdev_set_drvdata(dev, data);\n\treturn 0;\n\n free_data:\n\tkfree(data->host[0]);\n\tkfree(data->host[1]);\n\tkfree(data);\n fail:\n\treturn err;\n}\n\nstatic int advansys_eisa_remove(struct device *dev)\n{\n\tint i;\n\tstruct eisa_scsi_data *data = dev_get_drvdata(dev);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tint ioport;\n\t\tstruct Scsi_Host *shost = data->host[i];\n\t\tif (!shost)\n\t\t\tcontinue;\n\t\tioport = shost->io_port;\n\t\tadvansys_release(shost);\n\t\trelease_region(ioport, ASC_IOADR_GAP);\n\t}\n\n\tkfree(data);\n\treturn 0;\n}\n\nstatic struct eisa_driver advansys_eisa_driver = {\n\t.id_table =\t\tadvansys_eisa_table,\n\t.driver = {\n\t\t.name =\t\tDRV_NAME,\n\t\t.probe =\tadvansys_eisa_probe,\n\t\t.remove =\tadvansys_eisa_remove,\n\t}\n};\n\n/* PCI Devices supported by this driver */\nstatic struct pci_device_id advansys_pci_tbl[] = {\n\t{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_1200A,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_ABP940,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_ABP940U,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_ASP_ABP940UW,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_38C0800_REV1,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_ASP, PCI_DEVICE_ID_38C1600_REV1,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, advansys_pci_tbl);\n\nstatic void advansys_set_latency(struct pci_dev *pdev)\n{\n\tif ((pdev->device == PCI_DEVICE_ID_ASP_1200A) ||\n\t    (pdev->device == PCI_DEVICE_ID_ASP_ABP940)) {\n\t\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0);\n\t} else {\n\t\tu8 latency;\n\t\tpci_read_config_byte(pdev, PCI_LATENCY_TIMER, &latency);\n\t\tif (latency < 0x20)\n\t\t\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x20);\n\t}\n}\n\nstatic int advansys_pci_probe(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *ent)\n{\n\tint err, ioport;\n\tstruct Scsi_Host *shost;\n\tstruct asc_board *board;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\tgoto fail;\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err)\n\t\tgoto disable_device;\n\tpci_set_master(pdev);\n\tadvansys_set_latency(pdev);\n\n\terr = -ENODEV;\n\tif (pci_resource_len(pdev, 0) == 0)\n\t\tgoto release_region;\n\n\tioport = pci_resource_start(pdev, 0);\n\n\terr = -ENOMEM;\n\tshost = scsi_host_alloc(&advansys_template, sizeof(*board));\n\tif (!shost)\n\t\tgoto release_region;\n\n\tboard = shost_priv(shost);\n\tboard->irq = pdev->irq;\n\tboard->dev = &pdev->dev;\n\tboard->shost = shost;\n\n\tif (pdev->device == PCI_DEVICE_ID_ASP_ABP940UW ||\n\t    pdev->device == PCI_DEVICE_ID_38C0800_REV1 ||\n\t    pdev->device == PCI_DEVICE_ID_38C1600_REV1) {\n\t\tboard->flags |= ASC_IS_WIDE_BOARD;\n\t}\n\n\terr = advansys_board_found(shost, ioport, ASC_IS_PCI);\n\tif (err)\n\t\tgoto free_host;\n\n\tpci_set_drvdata(pdev, shost);\n\treturn 0;\n\n free_host:\n\tscsi_host_put(shost);\n release_region:\n\tpci_release_regions(pdev);\n disable_device:\n\tpci_disable_device(pdev);\n fail:\n\treturn err;\n}\n\nstatic void advansys_pci_remove(struct pci_dev *pdev)\n{\n\tadvansys_release(pci_get_drvdata(pdev));\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic struct pci_driver advansys_pci_driver = {\n\t.name =\t\tDRV_NAME,\n\t.id_table =\tadvansys_pci_tbl,\n\t.probe =\tadvansys_pci_probe,\n\t.remove =\tadvansys_pci_remove,\n};\n\nstatic int __init advansys_init(void)\n{\n\tint error;\n\n\terror = isa_register_driver(&advansys_isa_driver,\n\t\t\t\t    ASC_IOADR_TABLE_MAX_IX);\n\tif (error)\n\t\tgoto fail;\n\n\terror = isa_register_driver(&advansys_vlb_driver,\n\t\t\t\t    ASC_IOADR_TABLE_MAX_IX);\n\tif (error)\n\t\tgoto unregister_isa;\n\n\terror = eisa_driver_register(&advansys_eisa_driver);\n\tif (error)\n\t\tgoto unregister_vlb;\n\n\terror = pci_register_driver(&advansys_pci_driver);\n\tif (error)\n\t\tgoto unregister_eisa;\n\n\treturn 0;\n\n unregister_eisa:\n\teisa_driver_unregister(&advansys_eisa_driver);\n unregister_vlb:\n\tisa_unregister_driver(&advansys_vlb_driver);\n unregister_isa:\n\tisa_unregister_driver(&advansys_isa_driver);\n fail:\n\treturn error;\n}\n\nstatic void __exit advansys_exit(void)\n{\n\tpci_unregister_driver(&advansys_pci_driver);\n\teisa_driver_unregister(&advansys_eisa_driver);\n\tisa_unregister_driver(&advansys_vlb_driver);\n\tisa_unregister_driver(&advansys_isa_driver);\n}\n\nmodule_init(advansys_init);\nmodule_exit(advansys_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"advansys/mcode.bin\");\nMODULE_FIRMWARE(\"advansys/3550.bin\");\nMODULE_FIRMWARE(\"advansys/38C0800.bin\");\nMODULE_FIRMWARE(\"advansys/38C1600.bin\");\n"}}, "reports": [{"events": [{"location": {"col": 2, "file": 0, "line": 9785}, "message": "WARNING: Use BUG_ON instead of if condition followed by BUG."}], "macros": [], "notes": [], "path": "/src/drivers/scsi/advansys.c", "reportHash": "07943dc6d5092f14fab4c3e560cfa223", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
