<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/tools/lib/bpf/libbpf.c", "content": "// SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)\n\n/*\n * Common eBPF ELF object loading operations.\n *\n * Copyright (C) 2013-2015 Alexei Starovoitov <ast@kernel.org>\n * Copyright (C) 2015 Wang Nan <wangnan0@huawei.com>\n * Copyright (C) 2015 Huawei Inc.\n * Copyright (C) 2017 Nicira, Inc.\n * Copyright (C) 2019 Isovalent, Inc.\n */\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <libgen.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <string.h>\n#include <unistd.h>\n#include <endian.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <asm/unistd.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/bpf.h>\n#include <linux/btf.h>\n#include <linux/filter.h>\n#include <linux/list.h>\n#include <linux/limits.h>\n#include <linux/perf_event.h>\n#include <linux/ring_buffer.h>\n#include <linux/version.h>\n#include <sys/epoll.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/vfs.h>\n#include <sys/utsname.h>\n#include <sys/resource.h>\n#include <libelf.h>\n#include <gelf.h>\n#include <zlib.h>\n\n#include \"libbpf.h\"\n#include \"bpf.h\"\n#include \"btf.h\"\n#include \"str_error.h\"\n#include \"libbpf_internal.h\"\n#include \"hashmap.h\"\n\n#ifndef EM_BPF\n#define EM_BPF 247\n#endif\n\n#ifndef BPF_FS_MAGIC\n#define BPF_FS_MAGIC\t\t0xcafe4a11\n#endif\n\n#define BPF_INSN_SZ (sizeof(struct bpf_insn))\n\n/* vsprintf() in __base_pr() uses nonliteral format string. It may break\n * compilation if user enables corresponding warning. Disable it explicitly.\n */\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n\n#define __printf(a, b)\t__attribute__((format(printf, a, b)))\n\nstatic struct bpf_map *bpf_object__add_map(struct bpf_object *obj);\nstatic const struct btf_type *\nskip_mods_and_typedefs(const struct btf *btf, __u32 id, __u32 *res_id);\n\nstatic int __base_pr(enum libbpf_print_level level, const char *format,\n\t\t     va_list args)\n{\n\tif (level == LIBBPF_DEBUG)\n\t\treturn 0;\n\n\treturn vfprintf(stderr, format, args);\n}\n\nstatic libbpf_print_fn_t __libbpf_pr = __base_pr;\n\nlibbpf_print_fn_t libbpf_set_print(libbpf_print_fn_t fn)\n{\n\tlibbpf_print_fn_t old_print_fn = __libbpf_pr;\n\n\t__libbpf_pr = fn;\n\treturn old_print_fn;\n}\n\n__printf(2, 3)\nvoid libbpf_print(enum libbpf_print_level level, const char *format, ...)\n{\n\tva_list args;\n\n\tif (!__libbpf_pr)\n\t\treturn;\n\n\tva_start(args, format);\n\t__libbpf_pr(level, format, args);\n\tva_end(args);\n}\n\nstatic void pr_perm_msg(int err)\n{\n\tstruct rlimit limit;\n\tchar buf[100];\n\n\tif (err != -EPERM || geteuid() != 0)\n\t\treturn;\n\n\terr = getrlimit(RLIMIT_MEMLOCK, &limit);\n\tif (err)\n\t\treturn;\n\n\tif (limit.rlim_cur == RLIM_INFINITY)\n\t\treturn;\n\n\tif (limit.rlim_cur < 1024)\n\t\tsnprintf(buf, sizeof(buf), \"%zu bytes\", (size_t)limit.rlim_cur);\n\telse if (limit.rlim_cur < 1024*1024)\n\t\tsnprintf(buf, sizeof(buf), \"%.1f KiB\", (double)limit.rlim_cur / 1024);\n\telse\n\t\tsnprintf(buf, sizeof(buf), \"%.1f MiB\", (double)limit.rlim_cur / (1024*1024));\n\n\tpr_warn(\"permission error while running as root; try raising 'ulimit -l'? current value: %s\\n\",\n\t\tbuf);\n}\n\n#define STRERR_BUFSIZE  128\n\n/* Copied from tools/perf/util/util.h */\n#ifndef zfree\n# define zfree(ptr) ({ free(*ptr); *ptr = NULL; })\n#endif\n\n#ifndef zclose\n# define zclose(fd) ({\t\t\t\\\n\tint ___err = 0;\t\t\t\\\n\tif ((fd) >= 0)\t\t\t\\\n\t\t___err = close((fd));\t\\\n\tfd = -1;\t\t\t\\\n\t___err; })\n#endif\n\nstatic inline __u64 ptr_to_u64(const void *ptr)\n{\n\treturn (__u64) (unsigned long) ptr;\n}\n\nenum kern_feature_id {\n\t/* v4.14: kernel support for program & map names. */\n\tFEAT_PROG_NAME,\n\t/* v5.2: kernel support for global data sections. */\n\tFEAT_GLOBAL_DATA,\n\t/* BTF support */\n\tFEAT_BTF,\n\t/* BTF_KIND_FUNC and BTF_KIND_FUNC_PROTO support */\n\tFEAT_BTF_FUNC,\n\t/* BTF_KIND_VAR and BTF_KIND_DATASEC support */\n\tFEAT_BTF_DATASEC,\n\t/* BTF_FUNC_GLOBAL is supported */\n\tFEAT_BTF_GLOBAL_FUNC,\n\t/* BPF_F_MMAPABLE is supported for arrays */\n\tFEAT_ARRAY_MMAP,\n\t/* kernel support for expected_attach_type in BPF_PROG_LOAD */\n\tFEAT_EXP_ATTACH_TYPE,\n\t/* bpf_probe_read_{kernel,user}[_str] helpers */\n\tFEAT_PROBE_READ_KERN,\n\t/* BPF_PROG_BIND_MAP is supported */\n\tFEAT_PROG_BIND_MAP,\n\t__FEAT_CNT,\n};\n\nstatic bool kernel_supports(enum kern_feature_id feat_id);\n\nenum reloc_type {\n\tRELO_LD64,\n\tRELO_CALL,\n\tRELO_DATA,\n\tRELO_EXTERN,\n};\n\nstruct reloc_desc {\n\tenum reloc_type type;\n\tint insn_idx;\n\tint map_idx;\n\tint sym_off;\n\tbool processed;\n};\n\nstruct bpf_sec_def;\n\ntypedef struct bpf_link *(*attach_fn_t)(const struct bpf_sec_def *sec,\n\t\t\t\t\tstruct bpf_program *prog);\n\nstruct bpf_sec_def {\n\tconst char *sec;\n\tsize_t len;\n\tenum bpf_prog_type prog_type;\n\tenum bpf_attach_type expected_attach_type;\n\tbool is_exp_attach_type_optional;\n\tbool is_attachable;\n\tbool is_attach_btf;\n\tbool is_sleepable;\n\tattach_fn_t attach_fn;\n};\n\n/*\n * bpf_prog should be a better name but it has been used in\n * linux/filter.h.\n */\nstruct bpf_program {\n\tconst struct bpf_sec_def *sec_def;\n\tchar *sec_name;\n\tsize_t sec_idx;\n\t/* this program's instruction offset (in number of instructions)\n\t * within its containing ELF section\n\t */\n\tsize_t sec_insn_off;\n\t/* number of original instructions in ELF section belonging to this\n\t * program, not taking into account subprogram instructions possible\n\t * appended later during relocation\n\t */\n\tsize_t sec_insn_cnt;\n\t/* Offset (in number of instructions) of the start of instruction\n\t * belonging to this BPF program  within its containing main BPF\n\t * program. For the entry-point (main) BPF program, this is always\n\t * zero. For a sub-program, this gets reset before each of main BPF\n\t * programs are processed and relocated and is used to determined\n\t * whether sub-program was already appended to the main program, and\n\t * if yes, at which instruction offset.\n\t */\n\tsize_t sub_insn_off;\n\n\tchar *name;\n\t/* sec_name with / replaced by _; makes recursive pinning\n\t * in bpf_object__pin_programs easier\n\t */\n\tchar *pin_name;\n\n\t/* instructions that belong to BPF program; insns[0] is located at\n\t * sec_insn_off instruction within its ELF section in ELF file, so\n\t * when mapping ELF file instruction index to the local instruction,\n\t * one needs to subtract sec_insn_off; and vice versa.\n\t */\n\tstruct bpf_insn *insns;\n\t/* actual number of instruction in this BPF program's image; for\n\t * entry-point BPF programs this includes the size of main program\n\t * itself plus all the used sub-programs, appended at the end\n\t */\n\tsize_t insns_cnt;\n\n\tstruct reloc_desc *reloc_desc;\n\tint nr_reloc;\n\tint log_level;\n\n\tstruct {\n\t\tint nr;\n\t\tint *fds;\n\t} instances;\n\tbpf_program_prep_t preprocessor;\n\n\tstruct bpf_object *obj;\n\tvoid *priv;\n\tbpf_program_clear_priv_t clear_priv;\n\n\tbool load;\n\tenum bpf_prog_type type;\n\tenum bpf_attach_type expected_attach_type;\n\tint prog_ifindex;\n\t__u32 attach_btf_id;\n\t__u32 attach_prog_fd;\n\tvoid *func_info;\n\t__u32 func_info_rec_size;\n\t__u32 func_info_cnt;\n\n\tvoid *line_info;\n\t__u32 line_info_rec_size;\n\t__u32 line_info_cnt;\n\t__u32 prog_flags;\n};\n\nstruct bpf_struct_ops {\n\tconst char *tname;\n\tconst struct btf_type *type;\n\tstruct bpf_program **progs;\n\t__u32 *kern_func_off;\n\t/* e.g. struct tcp_congestion_ops in bpf_prog's btf format */\n\tvoid *data;\n\t/* e.g. struct bpf_struct_ops_tcp_congestion_ops in\n\t *      btf_vmlinux's format.\n\t * struct bpf_struct_ops_tcp_congestion_ops {\n\t *\t[... some other kernel fields ...]\n\t *\tstruct tcp_congestion_ops data;\n\t * }\n\t * kern_vdata-size == sizeof(struct bpf_struct_ops_tcp_congestion_ops)\n\t * bpf_map__init_kern_struct_ops() will populate the \"kern_vdata\"\n\t * from \"data\".\n\t */\n\tvoid *kern_vdata;\n\t__u32 type_id;\n};\n\n#define DATA_SEC \".data\"\n#define BSS_SEC \".bss\"\n#define RODATA_SEC \".rodata\"\n#define KCONFIG_SEC \".kconfig\"\n#define KSYMS_SEC \".ksyms\"\n#define STRUCT_OPS_SEC \".struct_ops\"\n\nenum libbpf_map_type {\n\tLIBBPF_MAP_UNSPEC,\n\tLIBBPF_MAP_DATA,\n\tLIBBPF_MAP_BSS,\n\tLIBBPF_MAP_RODATA,\n\tLIBBPF_MAP_KCONFIG,\n};\n\nstatic const char * const libbpf_type_to_btf_name[] = {\n\t[LIBBPF_MAP_DATA]\t= DATA_SEC,\n\t[LIBBPF_MAP_BSS]\t= BSS_SEC,\n\t[LIBBPF_MAP_RODATA]\t= RODATA_SEC,\n\t[LIBBPF_MAP_KCONFIG]\t= KCONFIG_SEC,\n};\n\nstruct bpf_map {\n\tchar *name;\n\tint fd;\n\tint sec_idx;\n\tsize_t sec_offset;\n\tint map_ifindex;\n\tint inner_map_fd;\n\tstruct bpf_map_def def;\n\t__u32 numa_node;\n\t__u32 btf_var_idx;\n\t__u32 btf_key_type_id;\n\t__u32 btf_value_type_id;\n\t__u32 btf_vmlinux_value_type_id;\n\tvoid *priv;\n\tbpf_map_clear_priv_t clear_priv;\n\tenum libbpf_map_type libbpf_type;\n\tvoid *mmaped;\n\tstruct bpf_struct_ops *st_ops;\n\tstruct bpf_map *inner_map;\n\tvoid **init_slots;\n\tint init_slots_sz;\n\tchar *pin_path;\n\tbool pinned;\n\tbool reused;\n};\n\nenum extern_type {\n\tEXT_UNKNOWN,\n\tEXT_KCFG,\n\tEXT_KSYM,\n};\n\nenum kcfg_type {\n\tKCFG_UNKNOWN,\n\tKCFG_CHAR,\n\tKCFG_BOOL,\n\tKCFG_INT,\n\tKCFG_TRISTATE,\n\tKCFG_CHAR_ARR,\n};\n\nstruct extern_desc {\n\tenum extern_type type;\n\tint sym_idx;\n\tint btf_id;\n\tint sec_btf_id;\n\tconst char *name;\n\tbool is_set;\n\tbool is_weak;\n\tunion {\n\t\tstruct {\n\t\t\tenum kcfg_type type;\n\t\t\tint sz;\n\t\t\tint align;\n\t\t\tint data_off;\n\t\t\tbool is_signed;\n\t\t} kcfg;\n\t\tstruct {\n\t\t\tunsigned long long addr;\n\n\t\t\t/* target btf_id of the corresponding kernel var. */\n\t\t\tint vmlinux_btf_id;\n\n\t\t\t/* local btf_id of the ksym extern's type. */\n\t\t\t__u32 type_id;\n\t\t} ksym;\n\t};\n};\n\nstatic LIST_HEAD(bpf_objects_list);\n\nstruct bpf_object {\n\tchar name[BPF_OBJ_NAME_LEN];\n\tchar license[64];\n\t__u32 kern_version;\n\n\tstruct bpf_program *programs;\n\tsize_t nr_programs;\n\tstruct bpf_map *maps;\n\tsize_t nr_maps;\n\tsize_t maps_cap;\n\n\tchar *kconfig;\n\tstruct extern_desc *externs;\n\tint nr_extern;\n\tint kconfig_map_idx;\n\tint rodata_map_idx;\n\n\tbool loaded;\n\tbool has_subcalls;\n\n\t/*\n\t * Information when doing elf related work. Only valid if fd\n\t * is valid.\n\t */\n\tstruct {\n\t\tint fd;\n\t\tconst void *obj_buf;\n\t\tsize_t obj_buf_sz;\n\t\tElf *elf;\n\t\tGElf_Ehdr ehdr;\n\t\tElf_Data *symbols;\n\t\tElf_Data *data;\n\t\tElf_Data *rodata;\n\t\tElf_Data *bss;\n\t\tElf_Data *st_ops_data;\n\t\tsize_t shstrndx; /* section index for section name strings */\n\t\tsize_t strtabidx;\n\t\tstruct {\n\t\t\tGElf_Shdr shdr;\n\t\t\tElf_Data *data;\n\t\t} *reloc_sects;\n\t\tint nr_reloc_sects;\n\t\tint maps_shndx;\n\t\tint btf_maps_shndx;\n\t\t__u32 btf_maps_sec_btf_id;\n\t\tint text_shndx;\n\t\tint symbols_shndx;\n\t\tint data_shndx;\n\t\tint rodata_shndx;\n\t\tint bss_shndx;\n\t\tint st_ops_shndx;\n\t} efile;\n\t/*\n\t * All loaded bpf_object is linked in a list, which is\n\t * hidden to caller. bpf_objects__<func> handlers deal with\n\t * all objects.\n\t */\n\tstruct list_head list;\n\n\tstruct btf *btf;\n\t/* Parse and load BTF vmlinux if any of the programs in the object need\n\t * it at load time.\n\t */\n\tstruct btf *btf_vmlinux;\n\tstruct btf_ext *btf_ext;\n\n\tvoid *priv;\n\tbpf_object_clear_priv_t clear_priv;\n\n\tchar path[];\n};\n#define obj_elf_valid(o)\t((o)->efile.elf)\n\nstatic const char *elf_sym_str(const struct bpf_object *obj, size_t off);\nstatic const char *elf_sec_str(const struct bpf_object *obj, size_t off);\nstatic Elf_Scn *elf_sec_by_idx(const struct bpf_object *obj, size_t idx);\nstatic Elf_Scn *elf_sec_by_name(const struct bpf_object *obj, const char *name);\nstatic int elf_sec_hdr(const struct bpf_object *obj, Elf_Scn *scn, GElf_Shdr *hdr);\nstatic const char *elf_sec_name(const struct bpf_object *obj, Elf_Scn *scn);\nstatic Elf_Data *elf_sec_data(const struct bpf_object *obj, Elf_Scn *scn);\nstatic int elf_sym_by_sec_off(const struct bpf_object *obj, size_t sec_idx,\n\t\t\t      size_t off, __u32 sym_type, GElf_Sym *sym);\n\nvoid bpf_program__unload(struct bpf_program *prog)\n{\n\tint i;\n\n\tif (!prog)\n\t\treturn;\n\n\t/*\n\t * If the object is opened but the program was never loaded,\n\t * it is possible that prog->instances.nr == -1.\n\t */\n\tif (prog->instances.nr > 0) {\n\t\tfor (i = 0; i < prog->instances.nr; i++)\n\t\t\tzclose(prog->instances.fds[i]);\n\t} else if (prog->instances.nr != -1) {\n\t\tpr_warn(\"Internal error: instances.nr is %d\\n\",\n\t\t\tprog->instances.nr);\n\t}\n\n\tprog->instances.nr = -1;\n\tzfree(&prog->instances.fds);\n\n\tzfree(&prog->func_info);\n\tzfree(&prog->line_info);\n}\n\nstatic void bpf_program__exit(struct bpf_program *prog)\n{\n\tif (!prog)\n\t\treturn;\n\n\tif (prog->clear_priv)\n\t\tprog->clear_priv(prog, prog->priv);\n\n\tprog->priv = NULL;\n\tprog->clear_priv = NULL;\n\n\tbpf_program__unload(prog);\n\tzfree(&prog->name);\n\tzfree(&prog->sec_name);\n\tzfree(&prog->pin_name);\n\tzfree(&prog->insns);\n\tzfree(&prog->reloc_desc);\n\n\tprog->nr_reloc = 0;\n\tprog->insns_cnt = 0;\n\tprog->sec_idx = -1;\n}\n\nstatic char *__bpf_program__pin_name(struct bpf_program *prog)\n{\n\tchar *name, *p;\n\n\tname = p = strdup(prog->sec_name);\n\twhile ((p = strchr(p, '/')))\n\t\t*p = '_';\n\n\treturn name;\n}\n\nstatic bool insn_is_subprog_call(const struct bpf_insn *insn)\n{\n\treturn BPF_CLASS(insn->code) == BPF_JMP &&\n\t       BPF_OP(insn->code) == BPF_CALL &&\n\t       BPF_SRC(insn->code) == BPF_K &&\n\t       insn->src_reg == BPF_PSEUDO_CALL &&\n\t       insn->dst_reg == 0 &&\n\t       insn->off == 0;\n}\n\nstatic int\nbpf_object__init_prog(struct bpf_object *obj, struct bpf_program *prog,\n\t\t      const char *name, size_t sec_idx, const char *sec_name,\n\t\t      size_t sec_off, void *insn_data, size_t insn_data_sz)\n{\n\tif (insn_data_sz == 0 || insn_data_sz % BPF_INSN_SZ || sec_off % BPF_INSN_SZ) {\n\t\tpr_warn(\"sec '%s': corrupted program '%s', offset %zu, size %zu\\n\",\n\t\t\tsec_name, name, sec_off, insn_data_sz);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(prog, 0, sizeof(*prog));\n\tprog->obj = obj;\n\n\tprog->sec_idx = sec_idx;\n\tprog->sec_insn_off = sec_off / BPF_INSN_SZ;\n\tprog->sec_insn_cnt = insn_data_sz / BPF_INSN_SZ;\n\t/* insns_cnt can later be increased by appending used subprograms */\n\tprog->insns_cnt = prog->sec_insn_cnt;\n\n\tprog->type = BPF_PROG_TYPE_UNSPEC;\n\tprog->load = true;\n\n\tprog->instances.fds = NULL;\n\tprog->instances.nr = -1;\n\n\tprog->sec_name = strdup(sec_name);\n\tif (!prog->sec_name)\n\t\tgoto errout;\n\n\tprog->name = strdup(name);\n\tif (!prog->name)\n\t\tgoto errout;\n\n\tprog->pin_name = __bpf_program__pin_name(prog);\n\tif (!prog->pin_name)\n\t\tgoto errout;\n\n\tprog->insns = malloc(insn_data_sz);\n\tif (!prog->insns)\n\t\tgoto errout;\n\tmemcpy(prog->insns, insn_data, insn_data_sz);\n\n\treturn 0;\nerrout:\n\tpr_warn(\"sec '%s': failed to allocate memory for prog '%s'\\n\", sec_name, name);\n\tbpf_program__exit(prog);\n\treturn -ENOMEM;\n}\n\nstatic int\nbpf_object__add_programs(struct bpf_object *obj, Elf_Data *sec_data,\n\t\t\t const char *sec_name, int sec_idx)\n{\n\tstruct bpf_program *prog, *progs;\n\tvoid *data = sec_data->d_buf;\n\tsize_t sec_sz = sec_data->d_size, sec_off, prog_sz;\n\tint nr_progs, err;\n\tconst char *name;\n\tGElf_Sym sym;\n\n\tprogs = obj->programs;\n\tnr_progs = obj->nr_programs;\n\tsec_off = 0;\n\n\twhile (sec_off < sec_sz) {\n\t\tif (elf_sym_by_sec_off(obj, sec_idx, sec_off, STT_FUNC, &sym)) {\n\t\t\tpr_warn(\"sec '%s': failed to find program symbol at offset %zu\\n\",\n\t\t\t\tsec_name, sec_off);\n\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t\t}\n\n\t\tprog_sz = sym.st_size;\n\n\t\tname = elf_sym_str(obj, sym.st_name);\n\t\tif (!name) {\n\t\t\tpr_warn(\"sec '%s': failed to get symbol name for offset %zu\\n\",\n\t\t\t\tsec_name, sec_off);\n\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t\t}\n\n\t\tif (sec_off + prog_sz > sec_sz) {\n\t\t\tpr_warn(\"sec '%s': program at offset %zu crosses section boundary\\n\",\n\t\t\t\tsec_name, sec_off);\n\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t\t}\n\n\t\tpr_debug(\"sec '%s': found program '%s' at insn offset %zu (%zu bytes), code size %zu insns (%zu bytes)\\n\",\n\t\t\t sec_name, name, sec_off / BPF_INSN_SZ, sec_off, prog_sz / BPF_INSN_SZ, prog_sz);\n\n\t\tprogs = libbpf_reallocarray(progs, nr_progs + 1, sizeof(*progs));\n\t\tif (!progs) {\n\t\t\t/*\n\t\t\t * In this case the original obj->programs\n\t\t\t * is still valid, so don't need special treat for\n\t\t\t * bpf_close_object().\n\t\t\t */\n\t\t\tpr_warn(\"sec '%s': failed to alloc memory for new program '%s'\\n\",\n\t\t\t\tsec_name, name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tobj->programs = progs;\n\n\t\tprog = &progs[nr_progs];\n\n\t\terr = bpf_object__init_prog(obj, prog, name, sec_idx, sec_name,\n\t\t\t\t\t    sec_off, data + sec_off, prog_sz);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tnr_progs++;\n\t\tobj->nr_programs = nr_progs;\n\n\t\tsec_off += prog_sz;\n\t}\n\n\treturn 0;\n}\n\nstatic __u32 get_kernel_version(void)\n{\n\t__u32 major, minor, patch;\n\tstruct utsname info;\n\n\tuname(&info);\n\tif (sscanf(info.release, \"%u.%u.%u\", &major, &minor, &patch) != 3)\n\t\treturn 0;\n\treturn KERNEL_VERSION(major, minor, patch);\n}\n\nstatic const struct btf_member *\nfind_member_by_offset(const struct btf_type *t, __u32 bit_offset)\n{\n\tstruct btf_member *m;\n\tint i;\n\n\tfor (i = 0, m = btf_members(t); i < btf_vlen(t); i++, m++) {\n\t\tif (btf_member_bit_offset(t, i) == bit_offset)\n\t\t\treturn m;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct btf_member *\nfind_member_by_name(const struct btf *btf, const struct btf_type *t,\n\t\t    const char *name)\n{\n\tstruct btf_member *m;\n\tint i;\n\n\tfor (i = 0, m = btf_members(t); i < btf_vlen(t); i++, m++) {\n\t\tif (!strcmp(btf__name_by_offset(btf, m->name_off), name))\n\t\t\treturn m;\n\t}\n\n\treturn NULL;\n}\n\n#define STRUCT_OPS_VALUE_PREFIX \"bpf_struct_ops_\"\nstatic int find_btf_by_prefix_kind(const struct btf *btf, const char *prefix,\n\t\t\t\t   const char *name, __u32 kind);\n\nstatic int\nfind_struct_ops_kern_types(const struct btf *btf, const char *tname,\n\t\t\t   const struct btf_type **type, __u32 *type_id,\n\t\t\t   const struct btf_type **vtype, __u32 *vtype_id,\n\t\t\t   const struct btf_member **data_member)\n{\n\tconst struct btf_type *kern_type, *kern_vtype;\n\tconst struct btf_member *kern_data_member;\n\t__s32 kern_vtype_id, kern_type_id;\n\t__u32 i;\n\n\tkern_type_id = btf__find_by_name_kind(btf, tname, BTF_KIND_STRUCT);\n\tif (kern_type_id < 0) {\n\t\tpr_warn(\"struct_ops init_kern: struct %s is not found in kernel BTF\\n\",\n\t\t\ttname);\n\t\treturn kern_type_id;\n\t}\n\tkern_type = btf__type_by_id(btf, kern_type_id);\n\n\t/* Find the corresponding \"map_value\" type that will be used\n\t * in map_update(BPF_MAP_TYPE_STRUCT_OPS).  For example,\n\t * find \"struct bpf_struct_ops_tcp_congestion_ops\" from the\n\t * btf_vmlinux.\n\t */\n\tkern_vtype_id = find_btf_by_prefix_kind(btf, STRUCT_OPS_VALUE_PREFIX,\n\t\t\t\t\t\ttname, BTF_KIND_STRUCT);\n\tif (kern_vtype_id < 0) {\n\t\tpr_warn(\"struct_ops init_kern: struct %s%s is not found in kernel BTF\\n\",\n\t\t\tSTRUCT_OPS_VALUE_PREFIX, tname);\n\t\treturn kern_vtype_id;\n\t}\n\tkern_vtype = btf__type_by_id(btf, kern_vtype_id);\n\n\t/* Find \"struct tcp_congestion_ops\" from\n\t * struct bpf_struct_ops_tcp_congestion_ops {\n\t *\t[ ... ]\n\t *\tstruct tcp_congestion_ops data;\n\t * }\n\t */\n\tkern_data_member = btf_members(kern_vtype);\n\tfor (i = 0; i < btf_vlen(kern_vtype); i++, kern_data_member++) {\n\t\tif (kern_data_member->type == kern_type_id)\n\t\t\tbreak;\n\t}\n\tif (i == btf_vlen(kern_vtype)) {\n\t\tpr_warn(\"struct_ops init_kern: struct %s data is not found in struct %s%s\\n\",\n\t\t\ttname, STRUCT_OPS_VALUE_PREFIX, tname);\n\t\treturn -EINVAL;\n\t}\n\n\t*type = kern_type;\n\t*type_id = kern_type_id;\n\t*vtype = kern_vtype;\n\t*vtype_id = kern_vtype_id;\n\t*data_member = kern_data_member;\n\n\treturn 0;\n}\n\nstatic bool bpf_map__is_struct_ops(const struct bpf_map *map)\n{\n\treturn map->def.type == BPF_MAP_TYPE_STRUCT_OPS;\n}\n\n/* Init the map's fields that depend on kern_btf */\nstatic int bpf_map__init_kern_struct_ops(struct bpf_map *map,\n\t\t\t\t\t const struct btf *btf,\n\t\t\t\t\t const struct btf *kern_btf)\n{\n\tconst struct btf_member *member, *kern_member, *kern_data_member;\n\tconst struct btf_type *type, *kern_type, *kern_vtype;\n\t__u32 i, kern_type_id, kern_vtype_id, kern_data_off;\n\tstruct bpf_struct_ops *st_ops;\n\tvoid *data, *kern_data;\n\tconst char *tname;\n\tint err;\n\n\tst_ops = map->st_ops;\n\ttype = st_ops->type;\n\ttname = st_ops->tname;\n\terr = find_struct_ops_kern_types(kern_btf, tname,\n\t\t\t\t\t &kern_type, &kern_type_id,\n\t\t\t\t\t &kern_vtype, &kern_vtype_id,\n\t\t\t\t\t &kern_data_member);\n\tif (err)\n\t\treturn err;\n\n\tpr_debug(\"struct_ops init_kern %s: type_id:%u kern_type_id:%u kern_vtype_id:%u\\n\",\n\t\t map->name, st_ops->type_id, kern_type_id, kern_vtype_id);\n\n\tmap->def.value_size = kern_vtype->size;\n\tmap->btf_vmlinux_value_type_id = kern_vtype_id;\n\n\tst_ops->kern_vdata = calloc(1, kern_vtype->size);\n\tif (!st_ops->kern_vdata)\n\t\treturn -ENOMEM;\n\n\tdata = st_ops->data;\n\tkern_data_off = kern_data_member->offset / 8;\n\tkern_data = st_ops->kern_vdata + kern_data_off;\n\n\tmember = btf_members(type);\n\tfor (i = 0; i < btf_vlen(type); i++, member++) {\n\t\tconst struct btf_type *mtype, *kern_mtype;\n\t\t__u32 mtype_id, kern_mtype_id;\n\t\tvoid *mdata, *kern_mdata;\n\t\t__s64 msize, kern_msize;\n\t\t__u32 moff, kern_moff;\n\t\t__u32 kern_member_idx;\n\t\tconst char *mname;\n\n\t\tmname = btf__name_by_offset(btf, member->name_off);\n\t\tkern_member = find_member_by_name(kern_btf, kern_type, mname);\n\t\tif (!kern_member) {\n\t\t\tpr_warn(\"struct_ops init_kern %s: Cannot find member %s in kernel BTF\\n\",\n\t\t\t\tmap->name, mname);\n\t\t\treturn -ENOTSUP;\n\t\t}\n\n\t\tkern_member_idx = kern_member - btf_members(kern_type);\n\t\tif (btf_member_bitfield_size(type, i) ||\n\t\t    btf_member_bitfield_size(kern_type, kern_member_idx)) {\n\t\t\tpr_warn(\"struct_ops init_kern %s: bitfield %s is not supported\\n\",\n\t\t\t\tmap->name, mname);\n\t\t\treturn -ENOTSUP;\n\t\t}\n\n\t\tmoff = member->offset / 8;\n\t\tkern_moff = kern_member->offset / 8;\n\n\t\tmdata = data + moff;\n\t\tkern_mdata = kern_data + kern_moff;\n\n\t\tmtype = skip_mods_and_typedefs(btf, member->type, &mtype_id);\n\t\tkern_mtype = skip_mods_and_typedefs(kern_btf, kern_member->type,\n\t\t\t\t\t\t    &kern_mtype_id);\n\t\tif (BTF_INFO_KIND(mtype->info) !=\n\t\t    BTF_INFO_KIND(kern_mtype->info)) {\n\t\t\tpr_warn(\"struct_ops init_kern %s: Unmatched member type %s %u != %u(kernel)\\n\",\n\t\t\t\tmap->name, mname, BTF_INFO_KIND(mtype->info),\n\t\t\t\tBTF_INFO_KIND(kern_mtype->info));\n\t\t\treturn -ENOTSUP;\n\t\t}\n\n\t\tif (btf_is_ptr(mtype)) {\n\t\t\tstruct bpf_program *prog;\n\n\t\t\tmtype = skip_mods_and_typedefs(btf, mtype->type, &mtype_id);\n\t\t\tkern_mtype = skip_mods_and_typedefs(kern_btf,\n\t\t\t\t\t\t\t    kern_mtype->type,\n\t\t\t\t\t\t\t    &kern_mtype_id);\n\t\t\tif (!btf_is_func_proto(mtype) ||\n\t\t\t    !btf_is_func_proto(kern_mtype)) {\n\t\t\t\tpr_warn(\"struct_ops init_kern %s: non func ptr %s is not supported\\n\",\n\t\t\t\t\tmap->name, mname);\n\t\t\t\treturn -ENOTSUP;\n\t\t\t}\n\n\t\t\tprog = st_ops->progs[i];\n\t\t\tif (!prog) {\n\t\t\t\tpr_debug(\"struct_ops init_kern %s: func ptr %s is not set\\n\",\n\t\t\t\t\t map->name, mname);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprog->attach_btf_id = kern_type_id;\n\t\t\tprog->expected_attach_type = kern_member_idx;\n\n\t\t\tst_ops->kern_func_off[i] = kern_data_off + kern_moff;\n\n\t\t\tpr_debug(\"struct_ops init_kern %s: func ptr %s is set to prog %s from data(+%u) to kern_data(+%u)\\n\",\n\t\t\t\t map->name, mname, prog->name, moff,\n\t\t\t\t kern_moff);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tmsize = btf__resolve_size(btf, mtype_id);\n\t\tkern_msize = btf__resolve_size(kern_btf, kern_mtype_id);\n\t\tif (msize < 0 || kern_msize < 0 || msize != kern_msize) {\n\t\t\tpr_warn(\"struct_ops init_kern %s: Error in size of member %s: %zd != %zd(kernel)\\n\",\n\t\t\t\tmap->name, mname, (ssize_t)msize,\n\t\t\t\t(ssize_t)kern_msize);\n\t\t\treturn -ENOTSUP;\n\t\t}\n\n\t\tpr_debug(\"struct_ops init_kern %s: copy %s %u bytes from data(+%u) to kern_data(+%u)\\n\",\n\t\t\t map->name, mname, (unsigned int)msize,\n\t\t\t moff, kern_moff);\n\t\tmemcpy(kern_mdata, mdata, msize);\n\t}\n\n\treturn 0;\n}\n\nstatic int bpf_object__init_kern_struct_ops_maps(struct bpf_object *obj)\n{\n\tstruct bpf_map *map;\n\tsize_t i;\n\tint err;\n\n\tfor (i = 0; i < obj->nr_maps; i++) {\n\t\tmap = &obj->maps[i];\n\n\t\tif (!bpf_map__is_struct_ops(map))\n\t\t\tcontinue;\n\n\t\terr = bpf_map__init_kern_struct_ops(map, obj->btf,\n\t\t\t\t\t\t    obj->btf_vmlinux);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int bpf_object__init_struct_ops_maps(struct bpf_object *obj)\n{\n\tconst struct btf_type *type, *datasec;\n\tconst struct btf_var_secinfo *vsi;\n\tstruct bpf_struct_ops *st_ops;\n\tconst char *tname, *var_name;\n\t__s32 type_id, datasec_id;\n\tconst struct btf *btf;\n\tstruct bpf_map *map;\n\t__u32 i;\n\n\tif (obj->efile.st_ops_shndx == -1)\n\t\treturn 0;\n\n\tbtf = obj->btf;\n\tdatasec_id = btf__find_by_name_kind(btf, STRUCT_OPS_SEC,\n\t\t\t\t\t    BTF_KIND_DATASEC);\n\tif (datasec_id < 0) {\n\t\tpr_warn(\"struct_ops init: DATASEC %s not found\\n\",\n\t\t\tSTRUCT_OPS_SEC);\n\t\treturn -EINVAL;\n\t}\n\n\tdatasec = btf__type_by_id(btf, datasec_id);\n\tvsi = btf_var_secinfos(datasec);\n\tfor (i = 0; i < btf_vlen(datasec); i++, vsi++) {\n\t\ttype = btf__type_by_id(obj->btf, vsi->type);\n\t\tvar_name = btf__name_by_offset(obj->btf, type->name_off);\n\n\t\ttype_id = btf__resolve_type(obj->btf, vsi->type);\n\t\tif (type_id < 0) {\n\t\t\tpr_warn(\"struct_ops init: Cannot resolve var type_id %u in DATASEC %s\\n\",\n\t\t\t\tvsi->type, STRUCT_OPS_SEC);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttype = btf__type_by_id(obj->btf, type_id);\n\t\ttname = btf__name_by_offset(obj->btf, type->name_off);\n\t\tif (!tname[0]) {\n\t\t\tpr_warn(\"struct_ops init: anonymous type is not supported\\n\");\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t\tif (!btf_is_struct(type)) {\n\t\t\tpr_warn(\"struct_ops init: %s is not a struct\\n\", tname);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmap = bpf_object__add_map(obj);\n\t\tif (IS_ERR(map))\n\t\t\treturn PTR_ERR(map);\n\n\t\tmap->sec_idx = obj->efile.st_ops_shndx;\n\t\tmap->sec_offset = vsi->offset;\n\t\tmap->name = strdup(var_name);\n\t\tif (!map->name)\n\t\t\treturn -ENOMEM;\n\n\t\tmap->def.type = BPF_MAP_TYPE_STRUCT_OPS;\n\t\tmap->def.key_size = sizeof(int);\n\t\tmap->def.value_size = type->size;\n\t\tmap->def.max_entries = 1;\n\n\t\tmap->st_ops = calloc(1, sizeof(*map->st_ops));\n\t\tif (!map->st_ops)\n\t\t\treturn -ENOMEM;\n\t\tst_ops = map->st_ops;\n\t\tst_ops->data = malloc(type->size);\n\t\tst_ops->progs = calloc(btf_vlen(type), sizeof(*st_ops->progs));\n\t\tst_ops->kern_func_off = malloc(btf_vlen(type) *\n\t\t\t\t\t       sizeof(*st_ops->kern_func_off));\n\t\tif (!st_ops->data || !st_ops->progs || !st_ops->kern_func_off)\n\t\t\treturn -ENOMEM;\n\n\t\tif (vsi->offset + type->size > obj->efile.st_ops_data->d_size) {\n\t\t\tpr_warn(\"struct_ops init: var %s is beyond the end of DATASEC %s\\n\",\n\t\t\t\tvar_name, STRUCT_OPS_SEC);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(st_ops->data,\n\t\t       obj->efile.st_ops_data->d_buf + vsi->offset,\n\t\t       type->size);\n\t\tst_ops->tname = tname;\n\t\tst_ops->type = type;\n\t\tst_ops->type_id = type_id;\n\n\t\tpr_debug(\"struct_ops init: struct %s(type_id=%u) %s found at offset %u\\n\",\n\t\t\t tname, type_id, var_name, vsi->offset);\n\t}\n\n\treturn 0;\n}\n\nstatic struct bpf_object *bpf_object__new(const char *path,\n\t\t\t\t\t  const void *obj_buf,\n\t\t\t\t\t  size_t obj_buf_sz,\n\t\t\t\t\t  const char *obj_name)\n{\n\tstruct bpf_object *obj;\n\tchar *end;\n\n\tobj = calloc(1, sizeof(struct bpf_object) + strlen(path) + 1);\n\tif (!obj) {\n\t\tpr_warn(\"alloc memory failed for %s\\n\", path);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tstrcpy(obj->path, path);\n\tif (obj_name) {\n\t\tstrncpy(obj->name, obj_name, sizeof(obj->name) - 1);\n\t\tobj->name[sizeof(obj->name) - 1] = 0;\n\t} else {\n\t\t/* Using basename() GNU version which doesn't modify arg. */\n\t\tstrncpy(obj->name, basename((void *)path),\n\t\t\tsizeof(obj->name) - 1);\n\t\tend = strchr(obj->name, '.');\n\t\tif (end)\n\t\t\t*end = 0;\n\t}\n\n\tobj->efile.fd = -1;\n\t/*\n\t * Caller of this function should also call\n\t * bpf_object__elf_finish() after data collection to return\n\t * obj_buf to user. If not, we should duplicate the buffer to\n\t * avoid user freeing them before elf finish.\n\t */\n\tobj->efile.obj_buf = obj_buf;\n\tobj->efile.obj_buf_sz = obj_buf_sz;\n\tobj->efile.maps_shndx = -1;\n\tobj->efile.btf_maps_shndx = -1;\n\tobj->efile.data_shndx = -1;\n\tobj->efile.rodata_shndx = -1;\n\tobj->efile.bss_shndx = -1;\n\tobj->efile.st_ops_shndx = -1;\n\tobj->kconfig_map_idx = -1;\n\tobj->rodata_map_idx = -1;\n\n\tobj->kern_version = get_kernel_version();\n\tobj->loaded = false;\n\n\tINIT_LIST_HEAD(&obj->list);\n\tlist_add(&obj->list, &bpf_objects_list);\n\treturn obj;\n}\n\nstatic void bpf_object__elf_finish(struct bpf_object *obj)\n{\n\tif (!obj_elf_valid(obj))\n\t\treturn;\n\n\tif (obj->efile.elf) {\n\t\telf_end(obj->efile.elf);\n\t\tobj->efile.elf = NULL;\n\t}\n\tobj->efile.symbols = NULL;\n\tobj->efile.data = NULL;\n\tobj->efile.rodata = NULL;\n\tobj->efile.bss = NULL;\n\tobj->efile.st_ops_data = NULL;\n\n\tzfree(&obj->efile.reloc_sects);\n\tobj->efile.nr_reloc_sects = 0;\n\tzclose(obj->efile.fd);\n\tobj->efile.obj_buf = NULL;\n\tobj->efile.obj_buf_sz = 0;\n}\n\n/* if libelf is old and doesn't support mmap(), fall back to read() */\n#ifndef ELF_C_READ_MMAP\n#define ELF_C_READ_MMAP ELF_C_READ\n#endif\n\nstatic int bpf_object__elf_init(struct bpf_object *obj)\n{\n\tint err = 0;\n\tGElf_Ehdr *ep;\n\n\tif (obj_elf_valid(obj)) {\n\t\tpr_warn(\"elf: init internal error\\n\");\n\t\treturn -LIBBPF_ERRNO__LIBELF;\n\t}\n\n\tif (obj->efile.obj_buf_sz > 0) {\n\t\t/*\n\t\t * obj_buf should have been validated by\n\t\t * bpf_object__open_buffer().\n\t\t */\n\t\tobj->efile.elf = elf_memory((char *)obj->efile.obj_buf,\n\t\t\t\t\t    obj->efile.obj_buf_sz);\n\t} else {\n\t\tobj->efile.fd = open(obj->path, O_RDONLY);\n\t\tif (obj->efile.fd < 0) {\n\t\t\tchar errmsg[STRERR_BUFSIZE], *cp;\n\n\t\t\terr = -errno;\n\t\t\tcp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));\n\t\t\tpr_warn(\"elf: failed to open %s: %s\\n\", obj->path, cp);\n\t\t\treturn err;\n\t\t}\n\n\t\tobj->efile.elf = elf_begin(obj->efile.fd, ELF_C_READ_MMAP, NULL);\n\t}\n\n\tif (!obj->efile.elf) {\n\t\tpr_warn(\"elf: failed to open %s as ELF file: %s\\n\", obj->path, elf_errmsg(-1));\n\t\terr = -LIBBPF_ERRNO__LIBELF;\n\t\tgoto errout;\n\t}\n\n\tif (!gelf_getehdr(obj->efile.elf, &obj->efile.ehdr)) {\n\t\tpr_warn(\"elf: failed to get ELF header from %s: %s\\n\", obj->path, elf_errmsg(-1));\n\t\terr = -LIBBPF_ERRNO__FORMAT;\n\t\tgoto errout;\n\t}\n\tep = &obj->efile.ehdr;\n\n\tif (elf_getshdrstrndx(obj->efile.elf, &obj->efile.shstrndx)) {\n\t\tpr_warn(\"elf: failed to get section names section index for %s: %s\\n\",\n\t\t\tobj->path, elf_errmsg(-1));\n\t\terr = -LIBBPF_ERRNO__FORMAT;\n\t\tgoto errout;\n\t}\n\n\t/* Elf is corrupted/truncated, avoid calling elf_strptr. */\n\tif (!elf_rawdata(elf_getscn(obj->efile.elf, obj->efile.shstrndx), NULL)) {\n\t\tpr_warn(\"elf: failed to get section names strings from %s: %s\\n\",\n\t\t\tobj->path, elf_errmsg(-1));\n\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t}\n\n\t/* Old LLVM set e_machine to EM_NONE */\n\tif (ep->e_type != ET_REL ||\n\t    (ep->e_machine && ep->e_machine != EM_BPF)) {\n\t\tpr_warn(\"elf: %s is not a valid eBPF object file\\n\", obj->path);\n\t\terr = -LIBBPF_ERRNO__FORMAT;\n\t\tgoto errout;\n\t}\n\n\treturn 0;\nerrout:\n\tbpf_object__elf_finish(obj);\n\treturn err;\n}\n\nstatic int bpf_object__check_endianness(struct bpf_object *obj)\n{\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n\tif (obj->efile.ehdr.e_ident[EI_DATA] == ELFDATA2LSB)\n\t\treturn 0;\n#elif __BYTE_ORDER == __BIG_ENDIAN\n\tif (obj->efile.ehdr.e_ident[EI_DATA] == ELFDATA2MSB)\n\t\treturn 0;\n#else\n# error \"Unrecognized __BYTE_ORDER__\"\n#endif\n\tpr_warn(\"elf: endianness mismatch in %s.\\n\", obj->path);\n\treturn -LIBBPF_ERRNO__ENDIAN;\n}\n\nstatic int\nbpf_object__init_license(struct bpf_object *obj, void *data, size_t size)\n{\n\tmemcpy(obj->license, data, min(size, sizeof(obj->license) - 1));\n\tpr_debug(\"license of %s is %s\\n\", obj->path, obj->license);\n\treturn 0;\n}\n\nstatic int\nbpf_object__init_kversion(struct bpf_object *obj, void *data, size_t size)\n{\n\t__u32 kver;\n\n\tif (size != sizeof(kver)) {\n\t\tpr_warn(\"invalid kver section in %s\\n\", obj->path);\n\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t}\n\tmemcpy(&kver, data, sizeof(kver));\n\tobj->kern_version = kver;\n\tpr_debug(\"kernel version of %s is %x\\n\", obj->path, obj->kern_version);\n\treturn 0;\n}\n\nstatic bool bpf_map_type__is_map_in_map(enum bpf_map_type type)\n{\n\tif (type == BPF_MAP_TYPE_ARRAY_OF_MAPS ||\n\t    type == BPF_MAP_TYPE_HASH_OF_MAPS)\n\t\treturn true;\n\treturn false;\n}\n\nint bpf_object__section_size(const struct bpf_object *obj, const char *name,\n\t\t\t     __u32 *size)\n{\n\tint ret = -ENOENT;\n\n\t*size = 0;\n\tif (!name) {\n\t\treturn -EINVAL;\n\t} else if (!strcmp(name, DATA_SEC)) {\n\t\tif (obj->efile.data)\n\t\t\t*size = obj->efile.data->d_size;\n\t} else if (!strcmp(name, BSS_SEC)) {\n\t\tif (obj->efile.bss)\n\t\t\t*size = obj->efile.bss->d_size;\n\t} else if (!strcmp(name, RODATA_SEC)) {\n\t\tif (obj->efile.rodata)\n\t\t\t*size = obj->efile.rodata->d_size;\n\t} else if (!strcmp(name, STRUCT_OPS_SEC)) {\n\t\tif (obj->efile.st_ops_data)\n\t\t\t*size = obj->efile.st_ops_data->d_size;\n\t} else {\n\t\tElf_Scn *scn = elf_sec_by_name(obj, name);\n\t\tElf_Data *data = elf_sec_data(obj, scn);\n\n\t\tif (data) {\n\t\t\tret = 0; /* found it */\n\t\t\t*size = data->d_size;\n\t\t}\n\t}\n\n\treturn *size ? 0 : ret;\n}\n\nint bpf_object__variable_offset(const struct bpf_object *obj, const char *name,\n\t\t\t\t__u32 *off)\n{\n\tElf_Data *symbols = obj->efile.symbols;\n\tconst char *sname;\n\tsize_t si;\n\n\tif (!name || !off)\n\t\treturn -EINVAL;\n\n\tfor (si = 0; si < symbols->d_size / sizeof(GElf_Sym); si++) {\n\t\tGElf_Sym sym;\n\n\t\tif (!gelf_getsym(symbols, si, &sym))\n\t\t\tcontinue;\n\t\tif (GELF_ST_BIND(sym.st_info) != STB_GLOBAL ||\n\t\t    GELF_ST_TYPE(sym.st_info) != STT_OBJECT)\n\t\t\tcontinue;\n\n\t\tsname = elf_sym_str(obj, sym.st_name);\n\t\tif (!sname) {\n\t\t\tpr_warn(\"failed to get sym name string for var %s\\n\",\n\t\t\t\tname);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (strcmp(name, sname) == 0) {\n\t\t\t*off = sym.st_value;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic struct bpf_map *bpf_object__add_map(struct bpf_object *obj)\n{\n\tstruct bpf_map *new_maps;\n\tsize_t new_cap;\n\tint i;\n\n\tif (obj->nr_maps < obj->maps_cap)\n\t\treturn &obj->maps[obj->nr_maps++];\n\n\tnew_cap = max((size_t)4, obj->maps_cap * 3 / 2);\n\tnew_maps = libbpf_reallocarray(obj->maps, new_cap, sizeof(*obj->maps));\n\tif (!new_maps) {\n\t\tpr_warn(\"alloc maps for object failed\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tobj->maps_cap = new_cap;\n\tobj->maps = new_maps;\n\n\t/* zero out new maps */\n\tmemset(obj->maps + obj->nr_maps, 0,\n\t       (obj->maps_cap - obj->nr_maps) * sizeof(*obj->maps));\n\t/*\n\t * fill all fd with -1 so won't close incorrect fd (fd=0 is stdin)\n\t * when failure (zclose won't close negative fd)).\n\t */\n\tfor (i = obj->nr_maps; i < obj->maps_cap; i++) {\n\t\tobj->maps[i].fd = -1;\n\t\tobj->maps[i].inner_map_fd = -1;\n\t}\n\n\treturn &obj->maps[obj->nr_maps++];\n}\n\nstatic size_t bpf_map_mmap_sz(const struct bpf_map *map)\n{\n\tlong page_sz = sysconf(_SC_PAGE_SIZE);\n\tsize_t map_sz;\n\n\tmap_sz = (size_t)roundup(map->def.value_size, 8) * map->def.max_entries;\n\tmap_sz = roundup(map_sz, page_sz);\n\treturn map_sz;\n}\n\nstatic char *internal_map_name(struct bpf_object *obj,\n\t\t\t       enum libbpf_map_type type)\n{\n\tchar map_name[BPF_OBJ_NAME_LEN], *p;\n\tconst char *sfx = libbpf_type_to_btf_name[type];\n\tint sfx_len = max((size_t)7, strlen(sfx));\n\tint pfx_len = min((size_t)BPF_OBJ_NAME_LEN - sfx_len - 1,\n\t\t\t  strlen(obj->name));\n\n\tsnprintf(map_name, sizeof(map_name), \"%.*s%.*s\", pfx_len, obj->name,\n\t\t sfx_len, libbpf_type_to_btf_name[type]);\n\n\t/* sanitise map name to characters allowed by kernel */\n\tfor (p = map_name; *p && p < map_name + sizeof(map_name); p++)\n\t\tif (!isalnum(*p) && *p != '_' && *p != '.')\n\t\t\t*p = '_';\n\n\treturn strdup(map_name);\n}\n\nstatic int\nbpf_object__init_internal_map(struct bpf_object *obj, enum libbpf_map_type type,\n\t\t\t      int sec_idx, void *data, size_t data_sz)\n{\n\tstruct bpf_map_def *def;\n\tstruct bpf_map *map;\n\tint err;\n\n\tmap = bpf_object__add_map(obj);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tmap->libbpf_type = type;\n\tmap->sec_idx = sec_idx;\n\tmap->sec_offset = 0;\n\tmap->name = internal_map_name(obj, type);\n\tif (!map->name) {\n\t\tpr_warn(\"failed to alloc map name\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdef = &map->def;\n\tdef->type = BPF_MAP_TYPE_ARRAY;\n\tdef->key_size = sizeof(int);\n\tdef->value_size = data_sz;\n\tdef->max_entries = 1;\n\tdef->map_flags = type == LIBBPF_MAP_RODATA || type == LIBBPF_MAP_KCONFIG\n\t\t\t ? BPF_F_RDONLY_PROG : 0;\n\tdef->map_flags |= BPF_F_MMAPABLE;\n\n\tpr_debug(\"map '%s' (global data): at sec_idx %d, offset %zu, flags %x.\\n\",\n\t\t map->name, map->sec_idx, map->sec_offset, def->map_flags);\n\n\tmap->mmaped = mmap(NULL, bpf_map_mmap_sz(map), PROT_READ | PROT_WRITE,\n\t\t\t   MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n\tif (map->mmaped == MAP_FAILED) {\n\t\terr = -errno;\n\t\tmap->mmaped = NULL;\n\t\tpr_warn(\"failed to alloc map '%s' content buffer: %d\\n\",\n\t\t\tmap->name, err);\n\t\tzfree(&map->name);\n\t\treturn err;\n\t}\n\n\tif (data)\n\t\tmemcpy(map->mmaped, data, data_sz);\n\n\tpr_debug(\"map %td is \\\"%s\\\"\\n\", map - obj->maps, map->name);\n\treturn 0;\n}\n\nstatic int bpf_object__init_global_data_maps(struct bpf_object *obj)\n{\n\tint err;\n\n\t/*\n\t * Populate obj->maps with libbpf internal maps.\n\t */\n\tif (obj->efile.data_shndx >= 0) {\n\t\terr = bpf_object__init_internal_map(obj, LIBBPF_MAP_DATA,\n\t\t\t\t\t\t    obj->efile.data_shndx,\n\t\t\t\t\t\t    obj->efile.data->d_buf,\n\t\t\t\t\t\t    obj->efile.data->d_size);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (obj->efile.rodata_shndx >= 0) {\n\t\terr = bpf_object__init_internal_map(obj, LIBBPF_MAP_RODATA,\n\t\t\t\t\t\t    obj->efile.rodata_shndx,\n\t\t\t\t\t\t    obj->efile.rodata->d_buf,\n\t\t\t\t\t\t    obj->efile.rodata->d_size);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tobj->rodata_map_idx = obj->nr_maps - 1;\n\t}\n\tif (obj->efile.bss_shndx >= 0) {\n\t\terr = bpf_object__init_internal_map(obj, LIBBPF_MAP_BSS,\n\t\t\t\t\t\t    obj->efile.bss_shndx,\n\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t    obj->efile.bss->d_size);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n\nstatic struct extern_desc *find_extern_by_name(const struct bpf_object *obj,\n\t\t\t\t\t       const void *name)\n{\n\tint i;\n\n\tfor (i = 0; i < obj->nr_extern; i++) {\n\t\tif (strcmp(obj->externs[i].name, name) == 0)\n\t\t\treturn &obj->externs[i];\n\t}\n\treturn NULL;\n}\n\nstatic int set_kcfg_value_tri(struct extern_desc *ext, void *ext_val,\n\t\t\t      char value)\n{\n\tswitch (ext->kcfg.type) {\n\tcase KCFG_BOOL:\n\t\tif (value == 'm') {\n\t\t\tpr_warn(\"extern (kcfg) %s=%c should be tristate or char\\n\",\n\t\t\t\text->name, value);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*(bool *)ext_val = value == 'y' ? true : false;\n\t\tbreak;\n\tcase KCFG_TRISTATE:\n\t\tif (value == 'y')\n\t\t\t*(enum libbpf_tristate *)ext_val = TRI_YES;\n\t\telse if (value == 'm')\n\t\t\t*(enum libbpf_tristate *)ext_val = TRI_MODULE;\n\t\telse /* value == 'n' */\n\t\t\t*(enum libbpf_tristate *)ext_val = TRI_NO;\n\t\tbreak;\n\tcase KCFG_CHAR:\n\t\t*(char *)ext_val = value;\n\t\tbreak;\n\tcase KCFG_UNKNOWN:\n\tcase KCFG_INT:\n\tcase KCFG_CHAR_ARR:\n\tdefault:\n\t\tpr_warn(\"extern (kcfg) %s=%c should be bool, tristate, or char\\n\",\n\t\t\text->name, value);\n\t\treturn -EINVAL;\n\t}\n\text->is_set = true;\n\treturn 0;\n}\n\nstatic int set_kcfg_value_str(struct extern_desc *ext, char *ext_val,\n\t\t\t      const char *value)\n{\n\tsize_t len;\n\n\tif (ext->kcfg.type != KCFG_CHAR_ARR) {\n\t\tpr_warn(\"extern (kcfg) %s=%s should be char array\\n\", ext->name, value);\n\t\treturn -EINVAL;\n\t}\n\n\tlen = strlen(value);\n\tif (value[len - 1] != '\"') {\n\t\tpr_warn(\"extern (kcfg) '%s': invalid string config '%s'\\n\",\n\t\t\text->name, value);\n\t\treturn -EINVAL;\n\t}\n\n\t/* strip quotes */\n\tlen -= 2;\n\tif (len >= ext->kcfg.sz) {\n\t\tpr_warn(\"extern (kcfg) '%s': long string config %s of (%zu bytes) truncated to %d bytes\\n\",\n\t\t\text->name, value, len, ext->kcfg.sz - 1);\n\t\tlen = ext->kcfg.sz - 1;\n\t}\n\tmemcpy(ext_val, value + 1, len);\n\text_val[len] = '\\0';\n\text->is_set = true;\n\treturn 0;\n}\n\nstatic int parse_u64(const char *value, __u64 *res)\n{\n\tchar *value_end;\n\tint err;\n\n\terrno = 0;\n\t*res = strtoull(value, &value_end, 0);\n\tif (errno) {\n\t\terr = -errno;\n\t\tpr_warn(\"failed to parse '%s' as integer: %d\\n\", value, err);\n\t\treturn err;\n\t}\n\tif (*value_end) {\n\t\tpr_warn(\"failed to parse '%s' as integer completely\\n\", value);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic bool is_kcfg_value_in_range(const struct extern_desc *ext, __u64 v)\n{\n\tint bit_sz = ext->kcfg.sz * 8;\n\n\tif (ext->kcfg.sz == 8)\n\t\treturn true;\n\n\t/* Validate that value stored in u64 fits in integer of `ext->sz`\n\t * bytes size without any loss of information. If the target integer\n\t * is signed, we rely on the following limits of integer type of\n\t * Y bits and subsequent transformation:\n\t *\n\t *     -2^(Y-1) <= X           <= 2^(Y-1) - 1\n\t *            0 <= X + 2^(Y-1) <= 2^Y - 1\n\t *            0 <= X + 2^(Y-1) <  2^Y\n\t *\n\t *  For unsigned target integer, check that all the (64 - Y) bits are\n\t *  zero.\n\t */\n\tif (ext->kcfg.is_signed)\n\t\treturn v + (1ULL << (bit_sz - 1)) < (1ULL << bit_sz);\n\telse\n\t\treturn (v >> bit_sz) == 0;\n}\n\nstatic int set_kcfg_value_num(struct extern_desc *ext, void *ext_val,\n\t\t\t      __u64 value)\n{\n\tif (ext->kcfg.type != KCFG_INT && ext->kcfg.type != KCFG_CHAR) {\n\t\tpr_warn(\"extern (kcfg) %s=%llu should be integer\\n\",\n\t\t\text->name, (unsigned long long)value);\n\t\treturn -EINVAL;\n\t}\n\tif (!is_kcfg_value_in_range(ext, value)) {\n\t\tpr_warn(\"extern (kcfg) %s=%llu value doesn't fit in %d bytes\\n\",\n\t\t\text->name, (unsigned long long)value, ext->kcfg.sz);\n\t\treturn -ERANGE;\n\t}\n\tswitch (ext->kcfg.sz) {\n\t\tcase 1: *(__u8 *)ext_val = value; break;\n\t\tcase 2: *(__u16 *)ext_val = value; break;\n\t\tcase 4: *(__u32 *)ext_val = value; break;\n\t\tcase 8: *(__u64 *)ext_val = value; break;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\text->is_set = true;\n\treturn 0;\n}\n\nstatic int bpf_object__process_kconfig_line(struct bpf_object *obj,\n\t\t\t\t\t    char *buf, void *data)\n{\n\tstruct extern_desc *ext;\n\tchar *sep, *value;\n\tint len, err = 0;\n\tvoid *ext_val;\n\t__u64 num;\n\n\tif (strncmp(buf, \"CONFIG_\", 7))\n\t\treturn 0;\n\n\tsep = strchr(buf, '=');\n\tif (!sep) {\n\t\tpr_warn(\"failed to parse '%s': no separator\\n\", buf);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Trim ending '\\n' */\n\tlen = strlen(buf);\n\tif (buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\t/* Split on '=' and ensure that a value is present. */\n\t*sep = '\\0';\n\tif (!sep[1]) {\n\t\t*sep = '=';\n\t\tpr_warn(\"failed to parse '%s': no value\\n\", buf);\n\t\treturn -EINVAL;\n\t}\n\n\text = find_extern_by_name(obj, buf);\n\tif (!ext || ext->is_set)\n\t\treturn 0;\n\n\text_val = data + ext->kcfg.data_off;\n\tvalue = sep + 1;\n\n\tswitch (*value) {\n\tcase 'y': case 'n': case 'm':\n\t\terr = set_kcfg_value_tri(ext, ext_val, *value);\n\t\tbreak;\n\tcase '\"':\n\t\terr = set_kcfg_value_str(ext, ext_val, value);\n\t\tbreak;\n\tdefault:\n\t\t/* assume integer */\n\t\terr = parse_u64(value, &num);\n\t\tif (err) {\n\t\t\tpr_warn(\"extern (kcfg) %s=%s should be integer\\n\",\n\t\t\t\text->name, value);\n\t\t\treturn err;\n\t\t}\n\t\terr = set_kcfg_value_num(ext, ext_val, num);\n\t\tbreak;\n\t}\n\tif (err)\n\t\treturn err;\n\tpr_debug(\"extern (kcfg) %s=%s\\n\", ext->name, value);\n\treturn 0;\n}\n\nstatic int bpf_object__read_kconfig_file(struct bpf_object *obj, void *data)\n{\n\tchar buf[PATH_MAX];\n\tstruct utsname uts;\n\tint len, err = 0;\n\tgzFile file;\n\n\tuname(&uts);\n\tlen = snprintf(buf, PATH_MAX, \"/boot/config-%s\", uts.release);\n\tif (len < 0)\n\t\treturn -EINVAL;\n\telse if (len >= PATH_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\t/* gzopen also accepts uncompressed files. */\n\tfile = gzopen(buf, \"r\");\n\tif (!file)\n\t\tfile = gzopen(\"/proc/config.gz\", \"r\");\n\n\tif (!file) {\n\t\tpr_warn(\"failed to open system Kconfig\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\twhile (gzgets(file, buf, sizeof(buf))) {\n\t\terr = bpf_object__process_kconfig_line(obj, buf, data);\n\t\tif (err) {\n\t\t\tpr_warn(\"error parsing system Kconfig line '%s': %d\\n\",\n\t\t\t\tbuf, err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tgzclose(file);\n\treturn err;\n}\n\nstatic int bpf_object__read_kconfig_mem(struct bpf_object *obj,\n\t\t\t\t\tconst char *config, void *data)\n{\n\tchar buf[PATH_MAX];\n\tint err = 0;\n\tFILE *file;\n\n\tfile = fmemopen((void *)config, strlen(config), \"r\");\n\tif (!file) {\n\t\terr = -errno;\n\t\tpr_warn(\"failed to open in-memory Kconfig: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\twhile (fgets(buf, sizeof(buf), file)) {\n\t\terr = bpf_object__process_kconfig_line(obj, buf, data);\n\t\tif (err) {\n\t\t\tpr_warn(\"error parsing in-memory Kconfig line '%s': %d\\n\",\n\t\t\t\tbuf, err);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(file);\n\treturn err;\n}\n\nstatic int bpf_object__init_kconfig_map(struct bpf_object *obj)\n{\n\tstruct extern_desc *last_ext = NULL, *ext;\n\tsize_t map_sz;\n\tint i, err;\n\n\tfor (i = 0; i < obj->nr_extern; i++) {\n\t\text = &obj->externs[i];\n\t\tif (ext->type == EXT_KCFG)\n\t\t\tlast_ext = ext;\n\t}\n\n\tif (!last_ext)\n\t\treturn 0;\n\n\tmap_sz = last_ext->kcfg.data_off + last_ext->kcfg.sz;\n\terr = bpf_object__init_internal_map(obj, LIBBPF_MAP_KCONFIG,\n\t\t\t\t\t    obj->efile.symbols_shndx,\n\t\t\t\t\t    NULL, map_sz);\n\tif (err)\n\t\treturn err;\n\n\tobj->kconfig_map_idx = obj->nr_maps - 1;\n\n\treturn 0;\n}\n\nstatic int bpf_object__init_user_maps(struct bpf_object *obj, bool strict)\n{\n\tElf_Data *symbols = obj->efile.symbols;\n\tint i, map_def_sz = 0, nr_maps = 0, nr_syms;\n\tElf_Data *data = NULL;\n\tElf_Scn *scn;\n\n\tif (obj->efile.maps_shndx < 0)\n\t\treturn 0;\n\n\tif (!symbols)\n\t\treturn -EINVAL;\n\n\n\tscn = elf_sec_by_idx(obj, obj->efile.maps_shndx);\n\tdata = elf_sec_data(obj, scn);\n\tif (!scn || !data) {\n\t\tpr_warn(\"elf: failed to get legacy map definitions for %s\\n\",\n\t\t\tobj->path);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Count number of maps. Each map has a name.\n\t * Array of maps is not supported: only the first element is\n\t * considered.\n\t *\n\t * TODO: Detect array of map and report error.\n\t */\n\tnr_syms = symbols->d_size / sizeof(GElf_Sym);\n\tfor (i = 0; i < nr_syms; i++) {\n\t\tGElf_Sym sym;\n\n\t\tif (!gelf_getsym(symbols, i, &sym))\n\t\t\tcontinue;\n\t\tif (sym.st_shndx != obj->efile.maps_shndx)\n\t\t\tcontinue;\n\t\tnr_maps++;\n\t}\n\t/* Assume equally sized map definitions */\n\tpr_debug(\"elf: found %d legacy map definitions (%zd bytes) in %s\\n\",\n\t\t nr_maps, data->d_size, obj->path);\n\n\tif (!data->d_size || nr_maps == 0 || (data->d_size % nr_maps) != 0) {\n\t\tpr_warn(\"elf: unable to determine legacy map definition size in %s\\n\",\n\t\t\tobj->path);\n\t\treturn -EINVAL;\n\t}\n\tmap_def_sz = data->d_size / nr_maps;\n\n\t/* Fill obj->maps using data in \"maps\" section.  */\n\tfor (i = 0; i < nr_syms; i++) {\n\t\tGElf_Sym sym;\n\t\tconst char *map_name;\n\t\tstruct bpf_map_def *def;\n\t\tstruct bpf_map *map;\n\n\t\tif (!gelf_getsym(symbols, i, &sym))\n\t\t\tcontinue;\n\t\tif (sym.st_shndx != obj->efile.maps_shndx)\n\t\t\tcontinue;\n\n\t\tmap = bpf_object__add_map(obj);\n\t\tif (IS_ERR(map))\n\t\t\treturn PTR_ERR(map);\n\n\t\tmap_name = elf_sym_str(obj, sym.st_name);\n\t\tif (!map_name) {\n\t\t\tpr_warn(\"failed to get map #%d name sym string for obj %s\\n\",\n\t\t\t\ti, obj->path);\n\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t\t}\n\n\t\tmap->libbpf_type = LIBBPF_MAP_UNSPEC;\n\t\tmap->sec_idx = sym.st_shndx;\n\t\tmap->sec_offset = sym.st_value;\n\t\tpr_debug(\"map '%s' (legacy): at sec_idx %d, offset %zu.\\n\",\n\t\t\t map_name, map->sec_idx, map->sec_offset);\n\t\tif (sym.st_value + map_def_sz > data->d_size) {\n\t\t\tpr_warn(\"corrupted maps section in %s: last map \\\"%s\\\" too small\\n\",\n\t\t\t\tobj->path, map_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmap->name = strdup(map_name);\n\t\tif (!map->name) {\n\t\t\tpr_warn(\"failed to alloc map name\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpr_debug(\"map %d is \\\"%s\\\"\\n\", i, map->name);\n\t\tdef = (struct bpf_map_def *)(data->d_buf + sym.st_value);\n\t\t/*\n\t\t * If the definition of the map in the object file fits in\n\t\t * bpf_map_def, copy it.  Any extra fields in our version\n\t\t * of bpf_map_def will default to zero as a result of the\n\t\t * calloc above.\n\t\t */\n\t\tif (map_def_sz <= sizeof(struct bpf_map_def)) {\n\t\t\tmemcpy(&map->def, def, map_def_sz);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Here the map structure being read is bigger than what\n\t\t\t * we expect, truncate if the excess bits are all zero.\n\t\t\t * If they are not zero, reject this map as\n\t\t\t * incompatible.\n\t\t\t */\n\t\t\tchar *b;\n\n\t\t\tfor (b = ((char *)def) + sizeof(struct bpf_map_def);\n\t\t\t     b < ((char *)def) + map_def_sz; b++) {\n\t\t\t\tif (*b != 0) {\n\t\t\t\t\tpr_warn(\"maps section in %s: \\\"%s\\\" has unrecognized, non-zero options\\n\",\n\t\t\t\t\t\tobj->path, map_name);\n\t\t\t\t\tif (strict)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemcpy(&map->def, def, sizeof(struct bpf_map_def));\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct btf_type *\nskip_mods_and_typedefs(const struct btf *btf, __u32 id, __u32 *res_id)\n{\n\tconst struct btf_type *t = btf__type_by_id(btf, id);\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\twhile (btf_is_mod(t) || btf_is_typedef(t)) {\n\t\tif (res_id)\n\t\t\t*res_id = t->type;\n\t\tt = btf__type_by_id(btf, t->type);\n\t}\n\n\treturn t;\n}\n\nstatic const struct btf_type *\nresolve_func_ptr(const struct btf *btf, __u32 id, __u32 *res_id)\n{\n\tconst struct btf_type *t;\n\n\tt = skip_mods_and_typedefs(btf, id, NULL);\n\tif (!btf_is_ptr(t))\n\t\treturn NULL;\n\n\tt = skip_mods_and_typedefs(btf, t->type, res_id);\n\n\treturn btf_is_func_proto(t) ? t : NULL;\n}\n\nstatic const char *btf_kind_str(const struct btf_type *t)\n{\n\tswitch (btf_kind(t)) {\n\tcase BTF_KIND_UNKN: return \"void\";\n\tcase BTF_KIND_INT: return \"int\";\n\tcase BTF_KIND_PTR: return \"ptr\";\n\tcase BTF_KIND_ARRAY: return \"array\";\n\tcase BTF_KIND_STRUCT: return \"struct\";\n\tcase BTF_KIND_UNION: return \"union\";\n\tcase BTF_KIND_ENUM: return \"enum\";\n\tcase BTF_KIND_FWD: return \"fwd\";\n\tcase BTF_KIND_TYPEDEF: return \"typedef\";\n\tcase BTF_KIND_VOLATILE: return \"volatile\";\n\tcase BTF_KIND_CONST: return \"const\";\n\tcase BTF_KIND_RESTRICT: return \"restrict\";\n\tcase BTF_KIND_FUNC: return \"func\";\n\tcase BTF_KIND_FUNC_PROTO: return \"func_proto\";\n\tcase BTF_KIND_VAR: return \"var\";\n\tcase BTF_KIND_DATASEC: return \"datasec\";\n\tdefault: return \"unknown\";\n\t}\n}\n\n/*\n * Fetch integer attribute of BTF map definition. Such attributes are\n * represented using a pointer to an array, in which dimensionality of array\n * encodes specified integer value. E.g., int (*type)[BPF_MAP_TYPE_ARRAY];\n * encodes `type => BPF_MAP_TYPE_ARRAY` key/value pair completely using BTF\n * type definition, while using only sizeof(void *) space in ELF data section.\n */\nstatic bool get_map_field_int(const char *map_name, const struct btf *btf,\n\t\t\t      const struct btf_member *m, __u32 *res)\n{\n\tconst struct btf_type *t = skip_mods_and_typedefs(btf, m->type, NULL);\n\tconst char *name = btf__name_by_offset(btf, m->name_off);\n\tconst struct btf_array *arr_info;\n\tconst struct btf_type *arr_t;\n\n\tif (!btf_is_ptr(t)) {\n\t\tpr_warn(\"map '%s': attr '%s': expected PTR, got %s.\\n\",\n\t\t\tmap_name, name, btf_kind_str(t));\n\t\treturn false;\n\t}\n\n\tarr_t = btf__type_by_id(btf, t->type);\n\tif (!arr_t) {\n\t\tpr_warn(\"map '%s': attr '%s': type [%u] not found.\\n\",\n\t\t\tmap_name, name, t->type);\n\t\treturn false;\n\t}\n\tif (!btf_is_array(arr_t)) {\n\t\tpr_warn(\"map '%s': attr '%s': expected ARRAY, got %s.\\n\",\n\t\t\tmap_name, name, btf_kind_str(arr_t));\n\t\treturn false;\n\t}\n\tarr_info = btf_array(arr_t);\n\t*res = arr_info->nelems;\n\treturn true;\n}\n\nstatic int build_map_pin_path(struct bpf_map *map, const char *path)\n{\n\tchar buf[PATH_MAX];\n\tint len;\n\n\tif (!path)\n\t\tpath = \"/sys/fs/bpf\";\n\n\tlen = snprintf(buf, PATH_MAX, \"%s/%s\", path, bpf_map__name(map));\n\tif (len < 0)\n\t\treturn -EINVAL;\n\telse if (len >= PATH_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\treturn bpf_map__set_pin_path(map, buf);\n}\n\n\nstatic int parse_btf_map_def(struct bpf_object *obj,\n\t\t\t     struct bpf_map *map,\n\t\t\t     const struct btf_type *def,\n\t\t\t     bool strict, bool is_inner,\n\t\t\t     const char *pin_root_path)\n{\n\tconst struct btf_type *t;\n\tconst struct btf_member *m;\n\tint vlen, i;\n\n\tvlen = btf_vlen(def);\n\tm = btf_members(def);\n\tfor (i = 0; i < vlen; i++, m++) {\n\t\tconst char *name = btf__name_by_offset(obj->btf, m->name_off);\n\n\t\tif (!name) {\n\t\t\tpr_warn(\"map '%s': invalid field #%d.\\n\", map->name, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (strcmp(name, \"type\") == 0) {\n\t\t\tif (!get_map_field_int(map->name, obj->btf, m,\n\t\t\t\t\t       &map->def.type))\n\t\t\t\treturn -EINVAL;\n\t\t\tpr_debug(\"map '%s': found type = %u.\\n\",\n\t\t\t\t map->name, map->def.type);\n\t\t} else if (strcmp(name, \"max_entries\") == 0) {\n\t\t\tif (!get_map_field_int(map->name, obj->btf, m,\n\t\t\t\t\t       &map->def.max_entries))\n\t\t\t\treturn -EINVAL;\n\t\t\tpr_debug(\"map '%s': found max_entries = %u.\\n\",\n\t\t\t\t map->name, map->def.max_entries);\n\t\t} else if (strcmp(name, \"map_flags\") == 0) {\n\t\t\tif (!get_map_field_int(map->name, obj->btf, m,\n\t\t\t\t\t       &map->def.map_flags))\n\t\t\t\treturn -EINVAL;\n\t\t\tpr_debug(\"map '%s': found map_flags = %u.\\n\",\n\t\t\t\t map->name, map->def.map_flags);\n\t\t} else if (strcmp(name, \"numa_node\") == 0) {\n\t\t\tif (!get_map_field_int(map->name, obj->btf, m, &map->numa_node))\n\t\t\t\treturn -EINVAL;\n\t\t\tpr_debug(\"map '%s': found numa_node = %u.\\n\", map->name, map->numa_node);\n\t\t} else if (strcmp(name, \"key_size\") == 0) {\n\t\t\t__u32 sz;\n\n\t\t\tif (!get_map_field_int(map->name, obj->btf, m, &sz))\n\t\t\t\treturn -EINVAL;\n\t\t\tpr_debug(\"map '%s': found key_size = %u.\\n\",\n\t\t\t\t map->name, sz);\n\t\t\tif (map->def.key_size && map->def.key_size != sz) {\n\t\t\t\tpr_warn(\"map '%s': conflicting key size %u != %u.\\n\",\n\t\t\t\t\tmap->name, map->def.key_size, sz);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmap->def.key_size = sz;\n\t\t} else if (strcmp(name, \"key\") == 0) {\n\t\t\t__s64 sz;\n\n\t\t\tt = btf__type_by_id(obj->btf, m->type);\n\t\t\tif (!t) {\n\t\t\t\tpr_warn(\"map '%s': key type [%d] not found.\\n\",\n\t\t\t\t\tmap->name, m->type);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (!btf_is_ptr(t)) {\n\t\t\t\tpr_warn(\"map '%s': key spec is not PTR: %s.\\n\",\n\t\t\t\t\tmap->name, btf_kind_str(t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsz = btf__resolve_size(obj->btf, t->type);\n\t\t\tif (sz < 0) {\n\t\t\t\tpr_warn(\"map '%s': can't determine key size for type [%u]: %zd.\\n\",\n\t\t\t\t\tmap->name, t->type, (ssize_t)sz);\n\t\t\t\treturn sz;\n\t\t\t}\n\t\t\tpr_debug(\"map '%s': found key [%u], sz = %zd.\\n\",\n\t\t\t\t map->name, t->type, (ssize_t)sz);\n\t\t\tif (map->def.key_size && map->def.key_size != sz) {\n\t\t\t\tpr_warn(\"map '%s': conflicting key size %u != %zd.\\n\",\n\t\t\t\t\tmap->name, map->def.key_size, (ssize_t)sz);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmap->def.key_size = sz;\n\t\t\tmap->btf_key_type_id = t->type;\n\t\t} else if (strcmp(name, \"value_size\") == 0) {\n\t\t\t__u32 sz;\n\n\t\t\tif (!get_map_field_int(map->name, obj->btf, m, &sz))\n\t\t\t\treturn -EINVAL;\n\t\t\tpr_debug(\"map '%s': found value_size = %u.\\n\",\n\t\t\t\t map->name, sz);\n\t\t\tif (map->def.value_size && map->def.value_size != sz) {\n\t\t\t\tpr_warn(\"map '%s': conflicting value size %u != %u.\\n\",\n\t\t\t\t\tmap->name, map->def.value_size, sz);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmap->def.value_size = sz;\n\t\t} else if (strcmp(name, \"value\") == 0) {\n\t\t\t__s64 sz;\n\n\t\t\tt = btf__type_by_id(obj->btf, m->type);\n\t\t\tif (!t) {\n\t\t\t\tpr_warn(\"map '%s': value type [%d] not found.\\n\",\n\t\t\t\t\tmap->name, m->type);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (!btf_is_ptr(t)) {\n\t\t\t\tpr_warn(\"map '%s': value spec is not PTR: %s.\\n\",\n\t\t\t\t\tmap->name, btf_kind_str(t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsz = btf__resolve_size(obj->btf, t->type);\n\t\t\tif (sz < 0) {\n\t\t\t\tpr_warn(\"map '%s': can't determine value size for type [%u]: %zd.\\n\",\n\t\t\t\t\tmap->name, t->type, (ssize_t)sz);\n\t\t\t\treturn sz;\n\t\t\t}\n\t\t\tpr_debug(\"map '%s': found value [%u], sz = %zd.\\n\",\n\t\t\t\t map->name, t->type, (ssize_t)sz);\n\t\t\tif (map->def.value_size && map->def.value_size != sz) {\n\t\t\t\tpr_warn(\"map '%s': conflicting value size %u != %zd.\\n\",\n\t\t\t\t\tmap->name, map->def.value_size, (ssize_t)sz);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmap->def.value_size = sz;\n\t\t\tmap->btf_value_type_id = t->type;\n\t\t}\n\t\telse if (strcmp(name, \"values\") == 0) {\n\t\t\tint err;\n\n\t\t\tif (is_inner) {\n\t\t\t\tpr_warn(\"map '%s': multi-level inner maps not supported.\\n\",\n\t\t\t\t\tmap->name);\n\t\t\t\treturn -ENOTSUP;\n\t\t\t}\n\t\t\tif (i != vlen - 1) {\n\t\t\t\tpr_warn(\"map '%s': '%s' member should be last.\\n\",\n\t\t\t\t\tmap->name, name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (!bpf_map_type__is_map_in_map(map->def.type)) {\n\t\t\t\tpr_warn(\"map '%s': should be map-in-map.\\n\",\n\t\t\t\t\tmap->name);\n\t\t\t\treturn -ENOTSUP;\n\t\t\t}\n\t\t\tif (map->def.value_size && map->def.value_size != 4) {\n\t\t\t\tpr_warn(\"map '%s': conflicting value size %u != 4.\\n\",\n\t\t\t\t\tmap->name, map->def.value_size);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmap->def.value_size = 4;\n\t\t\tt = btf__type_by_id(obj->btf, m->type);\n\t\t\tif (!t) {\n\t\t\t\tpr_warn(\"map '%s': map-in-map inner type [%d] not found.\\n\",\n\t\t\t\t\tmap->name, m->type);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (!btf_is_array(t) || btf_array(t)->nelems) {\n\t\t\t\tpr_warn(\"map '%s': map-in-map inner spec is not a zero-sized array.\\n\",\n\t\t\t\t\tmap->name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tt = skip_mods_and_typedefs(obj->btf, btf_array(t)->type,\n\t\t\t\t\t\t   NULL);\n\t\t\tif (!btf_is_ptr(t)) {\n\t\t\t\tpr_warn(\"map '%s': map-in-map inner def is of unexpected kind %s.\\n\",\n\t\t\t\t\tmap->name, btf_kind_str(t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tt = skip_mods_and_typedefs(obj->btf, t->type, NULL);\n\t\t\tif (!btf_is_struct(t)) {\n\t\t\t\tpr_warn(\"map '%s': map-in-map inner def is of unexpected kind %s.\\n\",\n\t\t\t\t\tmap->name, btf_kind_str(t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmap->inner_map = calloc(1, sizeof(*map->inner_map));\n\t\t\tif (!map->inner_map)\n\t\t\t\treturn -ENOMEM;\n\t\t\tmap->inner_map->sec_idx = obj->efile.btf_maps_shndx;\n\t\t\tmap->inner_map->name = malloc(strlen(map->name) +\n\t\t\t\t\t\t      sizeof(\".inner\") + 1);\n\t\t\tif (!map->inner_map->name)\n\t\t\t\treturn -ENOMEM;\n\t\t\tsprintf(map->inner_map->name, \"%s.inner\", map->name);\n\n\t\t\terr = parse_btf_map_def(obj, map->inner_map, t, strict,\n\t\t\t\t\t\ttrue /* is_inner */, NULL);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else if (strcmp(name, \"pinning\") == 0) {\n\t\t\t__u32 val;\n\t\t\tint err;\n\n\t\t\tif (is_inner) {\n\t\t\t\tpr_debug(\"map '%s': inner def can't be pinned.\\n\",\n\t\t\t\t\t map->name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (!get_map_field_int(map->name, obj->btf, m, &val))\n\t\t\t\treturn -EINVAL;\n\t\t\tpr_debug(\"map '%s': found pinning = %u.\\n\",\n\t\t\t\t map->name, val);\n\n\t\t\tif (val != LIBBPF_PIN_NONE &&\n\t\t\t    val != LIBBPF_PIN_BY_NAME) {\n\t\t\t\tpr_warn(\"map '%s': invalid pinning value %u.\\n\",\n\t\t\t\t\tmap->name, val);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (val == LIBBPF_PIN_BY_NAME) {\n\t\t\t\terr = build_map_pin_path(map, pin_root_path);\n\t\t\t\tif (err) {\n\t\t\t\t\tpr_warn(\"map '%s': couldn't build pin path.\\n\",\n\t\t\t\t\t\tmap->name);\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (strict) {\n\t\t\t\tpr_warn(\"map '%s': unknown field '%s'.\\n\",\n\t\t\t\t\tmap->name, name);\n\t\t\t\treturn -ENOTSUP;\n\t\t\t}\n\t\t\tpr_debug(\"map '%s': ignoring unknown field '%s'.\\n\",\n\t\t\t\t map->name, name);\n\t\t}\n\t}\n\n\tif (map->def.type == BPF_MAP_TYPE_UNSPEC) {\n\t\tpr_warn(\"map '%s': map type isn't specified.\\n\", map->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int bpf_object__init_user_btf_map(struct bpf_object *obj,\n\t\t\t\t\t const struct btf_type *sec,\n\t\t\t\t\t int var_idx, int sec_idx,\n\t\t\t\t\t const Elf_Data *data, bool strict,\n\t\t\t\t\t const char *pin_root_path)\n{\n\tconst struct btf_type *var, *def;\n\tconst struct btf_var_secinfo *vi;\n\tconst struct btf_var *var_extra;\n\tconst char *map_name;\n\tstruct bpf_map *map;\n\n\tvi = btf_var_secinfos(sec) + var_idx;\n\tvar = btf__type_by_id(obj->btf, vi->type);\n\tvar_extra = btf_var(var);\n\tmap_name = btf__name_by_offset(obj->btf, var->name_off);\n\n\tif (map_name == NULL || map_name[0] == '\\0') {\n\t\tpr_warn(\"map #%d: empty name.\\n\", var_idx);\n\t\treturn -EINVAL;\n\t}\n\tif ((__u64)vi->offset + vi->size > data->d_size) {\n\t\tpr_warn(\"map '%s' BTF data is corrupted.\\n\", map_name);\n\t\treturn -EINVAL;\n\t}\n\tif (!btf_is_var(var)) {\n\t\tpr_warn(\"map '%s': unexpected var kind %s.\\n\",\n\t\t\tmap_name, btf_kind_str(var));\n\t\treturn -EINVAL;\n\t}\n\tif (var_extra->linkage != BTF_VAR_GLOBAL_ALLOCATED &&\n\t    var_extra->linkage != BTF_VAR_STATIC) {\n\t\tpr_warn(\"map '%s': unsupported var linkage %u.\\n\",\n\t\t\tmap_name, var_extra->linkage);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdef = skip_mods_and_typedefs(obj->btf, var->type, NULL);\n\tif (!btf_is_struct(def)) {\n\t\tpr_warn(\"map '%s': unexpected def kind %s.\\n\",\n\t\t\tmap_name, btf_kind_str(var));\n\t\treturn -EINVAL;\n\t}\n\tif (def->size > vi->size) {\n\t\tpr_warn(\"map '%s': invalid def size.\\n\", map_name);\n\t\treturn -EINVAL;\n\t}\n\n\tmap = bpf_object__add_map(obj);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\tmap->name = strdup(map_name);\n\tif (!map->name) {\n\t\tpr_warn(\"map '%s': failed to alloc map name.\\n\", map_name);\n\t\treturn -ENOMEM;\n\t}\n\tmap->libbpf_type = LIBBPF_MAP_UNSPEC;\n\tmap->def.type = BPF_MAP_TYPE_UNSPEC;\n\tmap->sec_idx = sec_idx;\n\tmap->sec_offset = vi->offset;\n\tmap->btf_var_idx = var_idx;\n\tpr_debug(\"map '%s': at sec_idx %d, offset %zu.\\n\",\n\t\t map_name, map->sec_idx, map->sec_offset);\n\n\treturn parse_btf_map_def(obj, map, def, strict, false, pin_root_path);\n}\n\nstatic int bpf_object__init_user_btf_maps(struct bpf_object *obj, bool strict,\n\t\t\t\t\t  const char *pin_root_path)\n{\n\tconst struct btf_type *sec = NULL;\n\tint nr_types, i, vlen, err;\n\tconst struct btf_type *t;\n\tconst char *name;\n\tElf_Data *data;\n\tElf_Scn *scn;\n\n\tif (obj->efile.btf_maps_shndx < 0)\n\t\treturn 0;\n\n\tscn = elf_sec_by_idx(obj, obj->efile.btf_maps_shndx);\n\tdata = elf_sec_data(obj, scn);\n\tif (!scn || !data) {\n\t\tpr_warn(\"elf: failed to get %s map definitions for %s\\n\",\n\t\t\tMAPS_ELF_SEC, obj->path);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_types = btf__get_nr_types(obj->btf);\n\tfor (i = 1; i <= nr_types; i++) {\n\t\tt = btf__type_by_id(obj->btf, i);\n\t\tif (!btf_is_datasec(t))\n\t\t\tcontinue;\n\t\tname = btf__name_by_offset(obj->btf, t->name_off);\n\t\tif (strcmp(name, MAPS_ELF_SEC) == 0) {\n\t\t\tsec = t;\n\t\t\tobj->efile.btf_maps_sec_btf_id = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!sec) {\n\t\tpr_warn(\"DATASEC '%s' not found.\\n\", MAPS_ELF_SEC);\n\t\treturn -ENOENT;\n\t}\n\n\tvlen = btf_vlen(sec);\n\tfor (i = 0; i < vlen; i++) {\n\t\terr = bpf_object__init_user_btf_map(obj, sec, i,\n\t\t\t\t\t\t    obj->efile.btf_maps_shndx,\n\t\t\t\t\t\t    data, strict,\n\t\t\t\t\t\t    pin_root_path);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int bpf_object__init_maps(struct bpf_object *obj,\n\t\t\t\t const struct bpf_object_open_opts *opts)\n{\n\tconst char *pin_root_path;\n\tbool strict;\n\tint err;\n\n\tstrict = !OPTS_GET(opts, relaxed_maps, false);\n\tpin_root_path = OPTS_GET(opts, pin_root_path, NULL);\n\n\terr = bpf_object__init_user_maps(obj, strict);\n\terr = err ?: bpf_object__init_user_btf_maps(obj, strict, pin_root_path);\n\terr = err ?: bpf_object__init_global_data_maps(obj);\n\terr = err ?: bpf_object__init_kconfig_map(obj);\n\terr = err ?: bpf_object__init_struct_ops_maps(obj);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic bool section_have_execinstr(struct bpf_object *obj, int idx)\n{\n\tGElf_Shdr sh;\n\n\tif (elf_sec_hdr(obj, elf_sec_by_idx(obj, idx), &sh))\n\t\treturn false;\n\n\treturn sh.sh_flags & SHF_EXECINSTR;\n}\n\nstatic bool btf_needs_sanitization(struct bpf_object *obj)\n{\n\tbool has_func_global = kernel_supports(FEAT_BTF_GLOBAL_FUNC);\n\tbool has_datasec = kernel_supports(FEAT_BTF_DATASEC);\n\tbool has_func = kernel_supports(FEAT_BTF_FUNC);\n\n\treturn !has_func || !has_datasec || !has_func_global;\n}\n\nstatic void bpf_object__sanitize_btf(struct bpf_object *obj, struct btf *btf)\n{\n\tbool has_func_global = kernel_supports(FEAT_BTF_GLOBAL_FUNC);\n\tbool has_datasec = kernel_supports(FEAT_BTF_DATASEC);\n\tbool has_func = kernel_supports(FEAT_BTF_FUNC);\n\tstruct btf_type *t;\n\tint i, j, vlen;\n\n\tfor (i = 1; i <= btf__get_nr_types(btf); i++) {\n\t\tt = (struct btf_type *)btf__type_by_id(btf, i);\n\n\t\tif (!has_datasec && btf_is_var(t)) {\n\t\t\t/* replace VAR with INT */\n\t\t\tt->info = BTF_INFO_ENC(BTF_KIND_INT, 0, 0);\n\t\t\t/*\n\t\t\t * using size = 1 is the safest choice, 4 will be too\n\t\t\t * big and cause kernel BTF validation failure if\n\t\t\t * original variable took less than 4 bytes\n\t\t\t */\n\t\t\tt->size = 1;\n\t\t\t*(int *)(t + 1) = BTF_INT_ENC(0, 0, 8);\n\t\t} else if (!has_datasec && btf_is_datasec(t)) {\n\t\t\t/* replace DATASEC with STRUCT */\n\t\t\tconst struct btf_var_secinfo *v = btf_var_secinfos(t);\n\t\t\tstruct btf_member *m = btf_members(t);\n\t\t\tstruct btf_type *vt;\n\t\t\tchar *name;\n\n\t\t\tname = (char *)btf__name_by_offset(btf, t->name_off);\n\t\t\twhile (*name) {\n\t\t\t\tif (*name == '.')\n\t\t\t\t\t*name = '_';\n\t\t\t\tname++;\n\t\t\t}\n\n\t\t\tvlen = btf_vlen(t);\n\t\t\tt->info = BTF_INFO_ENC(BTF_KIND_STRUCT, 0, vlen);\n\t\t\tfor (j = 0; j < vlen; j++, v++, m++) {\n\t\t\t\t/* order of field assignments is important */\n\t\t\t\tm->offset = v->offset * 8;\n\t\t\t\tm->type = v->type;\n\t\t\t\t/* preserve variable name as member name */\n\t\t\t\tvt = (void *)btf__type_by_id(btf, v->type);\n\t\t\t\tm->name_off = vt->name_off;\n\t\t\t}\n\t\t} else if (!has_func && btf_is_func_proto(t)) {\n\t\t\t/* replace FUNC_PROTO with ENUM */\n\t\t\tvlen = btf_vlen(t);\n\t\t\tt->info = BTF_INFO_ENC(BTF_KIND_ENUM, 0, vlen);\n\t\t\tt->size = sizeof(__u32); /* kernel enforced */\n\t\t} else if (!has_func && btf_is_func(t)) {\n\t\t\t/* replace FUNC with TYPEDEF */\n\t\t\tt->info = BTF_INFO_ENC(BTF_KIND_TYPEDEF, 0, 0);\n\t\t} else if (!has_func_global && btf_is_func(t)) {\n\t\t\t/* replace BTF_FUNC_GLOBAL with BTF_FUNC_STATIC */\n\t\t\tt->info = BTF_INFO_ENC(BTF_KIND_FUNC, 0, 0);\n\t\t}\n\t}\n}\n\nstatic bool libbpf_needs_btf(const struct bpf_object *obj)\n{\n\treturn obj->efile.btf_maps_shndx >= 0 ||\n\t       obj->efile.st_ops_shndx >= 0 ||\n\t       obj->nr_extern > 0;\n}\n\nstatic bool kernel_needs_btf(const struct bpf_object *obj)\n{\n\treturn obj->efile.st_ops_shndx >= 0;\n}\n\nstatic int bpf_object__init_btf(struct bpf_object *obj,\n\t\t\t\tElf_Data *btf_data,\n\t\t\t\tElf_Data *btf_ext_data)\n{\n\tint err = -ENOENT;\n\n\tif (btf_data) {\n\t\tobj->btf = btf__new(btf_data->d_buf, btf_data->d_size);\n\t\tif (IS_ERR(obj->btf)) {\n\t\t\terr = PTR_ERR(obj->btf);\n\t\t\tobj->btf = NULL;\n\t\t\tpr_warn(\"Error loading ELF section %s: %d.\\n\",\n\t\t\t\tBTF_ELF_SEC, err);\n\t\t\tgoto out;\n\t\t}\n\t\t/* enforce 8-byte pointers for BPF-targeted BTFs */\n\t\tbtf__set_pointer_size(obj->btf, 8);\n\t\terr = 0;\n\t}\n\tif (btf_ext_data) {\n\t\tif (!obj->btf) {\n\t\t\tpr_debug(\"Ignore ELF section %s because its depending ELF section %s is not found.\\n\",\n\t\t\t\t BTF_EXT_ELF_SEC, BTF_ELF_SEC);\n\t\t\tgoto out;\n\t\t}\n\t\tobj->btf_ext = btf_ext__new(btf_ext_data->d_buf,\n\t\t\t\t\t    btf_ext_data->d_size);\n\t\tif (IS_ERR(obj->btf_ext)) {\n\t\t\tpr_warn(\"Error loading ELF section %s: %ld. Ignored and continue.\\n\",\n\t\t\t\tBTF_EXT_ELF_SEC, PTR_ERR(obj->btf_ext));\n\t\t\tobj->btf_ext = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tif (err && libbpf_needs_btf(obj)) {\n\t\tpr_warn(\"BTF is required, but is missing or corrupted.\\n\");\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int bpf_object__finalize_btf(struct bpf_object *obj)\n{\n\tint err;\n\n\tif (!obj->btf)\n\t\treturn 0;\n\n\terr = btf__finalize_data(obj, obj->btf);\n\tif (err) {\n\t\tpr_warn(\"Error finalizing %s: %d.\\n\", BTF_ELF_SEC, err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic inline bool libbpf_prog_needs_vmlinux_btf(struct bpf_program *prog)\n{\n\tif (prog->type == BPF_PROG_TYPE_STRUCT_OPS ||\n\t    prog->type == BPF_PROG_TYPE_LSM)\n\t\treturn true;\n\n\t/* BPF_PROG_TYPE_TRACING programs which do not attach to other programs\n\t * also need vmlinux BTF\n\t */\n\tif (prog->type == BPF_PROG_TYPE_TRACING && !prog->attach_prog_fd)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int bpf_object__load_vmlinux_btf(struct bpf_object *obj)\n{\n\tbool need_vmlinux_btf = false;\n\tstruct bpf_program *prog;\n\tint i, err;\n\n\t/* CO-RE relocations need kernel BTF */\n\tif (obj->btf_ext && obj->btf_ext->core_relo_info.len)\n\t\tneed_vmlinux_btf = true;\n\n\t/* Support for typed ksyms needs kernel BTF */\n\tfor (i = 0; i < obj->nr_extern; i++) {\n\t\tconst struct extern_desc *ext;\n\n\t\text = &obj->externs[i];\n\t\tif (ext->type == EXT_KSYM && ext->ksym.type_id) {\n\t\t\tneed_vmlinux_btf = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tif (!prog->load)\n\t\t\tcontinue;\n\t\tif (libbpf_prog_needs_vmlinux_btf(prog)) {\n\t\t\tneed_vmlinux_btf = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!need_vmlinux_btf)\n\t\treturn 0;\n\n\tobj->btf_vmlinux = libbpf_find_kernel_btf();\n\tif (IS_ERR(obj->btf_vmlinux)) {\n\t\terr = PTR_ERR(obj->btf_vmlinux);\n\t\tpr_warn(\"Error loading vmlinux BTF: %d\\n\", err);\n\t\tobj->btf_vmlinux = NULL;\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int bpf_object__sanitize_and_load_btf(struct bpf_object *obj)\n{\n\tstruct btf *kern_btf = obj->btf;\n\tbool btf_mandatory, sanitize;\n\tint err = 0;\n\n\tif (!obj->btf)\n\t\treturn 0;\n\n\tif (!kernel_supports(FEAT_BTF)) {\n\t\tif (kernel_needs_btf(obj)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto report;\n\t\t}\n\t\tpr_debug(\"Kernel doesn't support BTF, skipping uploading it.\\n\");\n\t\treturn 0;\n\t}\n\n\tsanitize = btf_needs_sanitization(obj);\n\tif (sanitize) {\n\t\tconst void *raw_data;\n\t\t__u32 sz;\n\n\t\t/* clone BTF to sanitize a copy and leave the original intact */\n\t\traw_data = btf__get_raw_data(obj->btf, &sz);\n\t\tkern_btf = btf__new(raw_data, sz);\n\t\tif (IS_ERR(kern_btf))\n\t\t\treturn PTR_ERR(kern_btf);\n\n\t\t/* enforce 8-byte pointers for BPF-targeted BTFs */\n\t\tbtf__set_pointer_size(obj->btf, 8);\n\t\tbpf_object__sanitize_btf(obj, kern_btf);\n\t}\n\n\terr = btf__load(kern_btf);\n\tif (sanitize) {\n\t\tif (!err) {\n\t\t\t/* move fd to libbpf's BTF */\n\t\t\tbtf__set_fd(obj->btf, btf__fd(kern_btf));\n\t\t\tbtf__set_fd(kern_btf, -1);\n\t\t}\n\t\tbtf__free(kern_btf);\n\t}\nreport:\n\tif (err) {\n\t\tbtf_mandatory = kernel_needs_btf(obj);\n\t\tpr_warn(\"Error loading .BTF into kernel: %d. %s\\n\", err,\n\t\t\tbtf_mandatory ? \"BTF is mandatory, can't proceed.\"\n\t\t\t\t      : \"BTF is optional, ignoring.\");\n\t\tif (!btf_mandatory)\n\t\t\terr = 0;\n\t}\n\treturn err;\n}\n\nstatic const char *elf_sym_str(const struct bpf_object *obj, size_t off)\n{\n\tconst char *name;\n\n\tname = elf_strptr(obj->efile.elf, obj->efile.strtabidx, off);\n\tif (!name) {\n\t\tpr_warn(\"elf: failed to get section name string at offset %zu from %s: %s\\n\",\n\t\t\toff, obj->path, elf_errmsg(-1));\n\t\treturn NULL;\n\t}\n\n\treturn name;\n}\n\nstatic const char *elf_sec_str(const struct bpf_object *obj, size_t off)\n{\n\tconst char *name;\n\n\tname = elf_strptr(obj->efile.elf, obj->efile.shstrndx, off);\n\tif (!name) {\n\t\tpr_warn(\"elf: failed to get section name string at offset %zu from %s: %s\\n\",\n\t\t\toff, obj->path, elf_errmsg(-1));\n\t\treturn NULL;\n\t}\n\n\treturn name;\n}\n\nstatic Elf_Scn *elf_sec_by_idx(const struct bpf_object *obj, size_t idx)\n{\n\tElf_Scn *scn;\n\n\tscn = elf_getscn(obj->efile.elf, idx);\n\tif (!scn) {\n\t\tpr_warn(\"elf: failed to get section(%zu) from %s: %s\\n\",\n\t\t\tidx, obj->path, elf_errmsg(-1));\n\t\treturn NULL;\n\t}\n\treturn scn;\n}\n\nstatic Elf_Scn *elf_sec_by_name(const struct bpf_object *obj, const char *name)\n{\n\tElf_Scn *scn = NULL;\n\tElf *elf = obj->efile.elf;\n\tconst char *sec_name;\n\n\twhile ((scn = elf_nextscn(elf, scn)) != NULL) {\n\t\tsec_name = elf_sec_name(obj, scn);\n\t\tif (!sec_name)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(sec_name, name) != 0)\n\t\t\tcontinue;\n\n\t\treturn scn;\n\t}\n\treturn NULL;\n}\n\nstatic int elf_sec_hdr(const struct bpf_object *obj, Elf_Scn *scn, GElf_Shdr *hdr)\n{\n\tif (!scn)\n\t\treturn -EINVAL;\n\n\tif (gelf_getshdr(scn, hdr) != hdr) {\n\t\tpr_warn(\"elf: failed to get section(%zu) header from %s: %s\\n\",\n\t\t\telf_ndxscn(scn), obj->path, elf_errmsg(-1));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const char *elf_sec_name(const struct bpf_object *obj, Elf_Scn *scn)\n{\n\tconst char *name;\n\tGElf_Shdr sh;\n\n\tif (!scn)\n\t\treturn NULL;\n\n\tif (elf_sec_hdr(obj, scn, &sh))\n\t\treturn NULL;\n\n\tname = elf_sec_str(obj, sh.sh_name);\n\tif (!name) {\n\t\tpr_warn(\"elf: failed to get section(%zu) name from %s: %s\\n\",\n\t\t\telf_ndxscn(scn), obj->path, elf_errmsg(-1));\n\t\treturn NULL;\n\t}\n\n\treturn name;\n}\n\nstatic Elf_Data *elf_sec_data(const struct bpf_object *obj, Elf_Scn *scn)\n{\n\tElf_Data *data;\n\n\tif (!scn)\n\t\treturn NULL;\n\n\tdata = elf_getdata(scn, 0);\n\tif (!data) {\n\t\tpr_warn(\"elf: failed to get section(%zu) %s data from %s: %s\\n\",\n\t\t\telf_ndxscn(scn), elf_sec_name(obj, scn) ?: \"<?>\",\n\t\t\tobj->path, elf_errmsg(-1));\n\t\treturn NULL;\n\t}\n\n\treturn data;\n}\n\nstatic int elf_sym_by_sec_off(const struct bpf_object *obj, size_t sec_idx,\n\t\t\t      size_t off, __u32 sym_type, GElf_Sym *sym)\n{\n\tElf_Data *symbols = obj->efile.symbols;\n\tsize_t n = symbols->d_size / sizeof(GElf_Sym);\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (!gelf_getsym(symbols, i, sym))\n\t\t\tcontinue;\n\t\tif (sym->st_shndx != sec_idx || sym->st_value != off)\n\t\t\tcontinue;\n\t\tif (GELF_ST_TYPE(sym->st_info) != sym_type)\n\t\t\tcontinue;\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic bool is_sec_name_dwarf(const char *name)\n{\n\t/* approximation, but the actual list is too long */\n\treturn strncmp(name, \".debug_\", sizeof(\".debug_\") - 1) == 0;\n}\n\nstatic bool ignore_elf_section(GElf_Shdr *hdr, const char *name)\n{\n\t/* no special handling of .strtab */\n\tif (hdr->sh_type == SHT_STRTAB)\n\t\treturn true;\n\n\t/* ignore .llvm_addrsig section as well */\n\tif (hdr->sh_type == 0x6FFF4C03 /* SHT_LLVM_ADDRSIG */)\n\t\treturn true;\n\n\t/* no subprograms will lead to an empty .text section, ignore it */\n\tif (hdr->sh_type == SHT_PROGBITS && hdr->sh_size == 0 &&\n\t    strcmp(name, \".text\") == 0)\n\t\treturn true;\n\n\t/* DWARF sections */\n\tif (is_sec_name_dwarf(name))\n\t\treturn true;\n\n\tif (strncmp(name, \".rel\", sizeof(\".rel\") - 1) == 0) {\n\t\tname += sizeof(\".rel\") - 1;\n\t\t/* DWARF section relocations */\n\t\tif (is_sec_name_dwarf(name))\n\t\t\treturn true;\n\n\t\t/* .BTF and .BTF.ext don't need relocations */\n\t\tif (strcmp(name, BTF_ELF_SEC) == 0 ||\n\t\t    strcmp(name, BTF_EXT_ELF_SEC) == 0)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int cmp_progs(const void *_a, const void *_b)\n{\n\tconst struct bpf_program *a = _a;\n\tconst struct bpf_program *b = _b;\n\n\tif (a->sec_idx != b->sec_idx)\n\t\treturn a->sec_idx < b->sec_idx ? -1 : 1;\n\n\t/* sec_insn_off can't be the same within the section */\n\treturn a->sec_insn_off < b->sec_insn_off ? -1 : 1;\n}\n\nstatic int bpf_object__elf_collect(struct bpf_object *obj)\n{\n\tElf *elf = obj->efile.elf;\n\tElf_Data *btf_ext_data = NULL;\n\tElf_Data *btf_data = NULL;\n\tint idx = 0, err = 0;\n\tconst char *name;\n\tElf_Data *data;\n\tElf_Scn *scn;\n\tGElf_Shdr sh;\n\n\t/* a bunch of ELF parsing functionality depends on processing symbols,\n\t * so do the first pass and find the symbol table\n\t */\n\tscn = NULL;\n\twhile ((scn = elf_nextscn(elf, scn)) != NULL) {\n\t\tif (elf_sec_hdr(obj, scn, &sh))\n\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\n\t\tif (sh.sh_type == SHT_SYMTAB) {\n\t\t\tif (obj->efile.symbols) {\n\t\t\t\tpr_warn(\"elf: multiple symbol tables in %s\\n\", obj->path);\n\t\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t\t\t}\n\n\t\t\tdata = elf_sec_data(obj, scn);\n\t\t\tif (!data)\n\t\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\n\t\t\tobj->efile.symbols = data;\n\t\t\tobj->efile.symbols_shndx = elf_ndxscn(scn);\n\t\t\tobj->efile.strtabidx = sh.sh_link;\n\t\t}\n\t}\n\n\tscn = NULL;\n\twhile ((scn = elf_nextscn(elf, scn)) != NULL) {\n\t\tidx++;\n\n\t\tif (elf_sec_hdr(obj, scn, &sh))\n\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\n\t\tname = elf_sec_str(obj, sh.sh_name);\n\t\tif (!name)\n\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\n\t\tif (ignore_elf_section(&sh, name))\n\t\t\tcontinue;\n\n\t\tdata = elf_sec_data(obj, scn);\n\t\tif (!data)\n\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\n\t\tpr_debug(\"elf: section(%d) %s, size %ld, link %d, flags %lx, type=%d\\n\",\n\t\t\t idx, name, (unsigned long)data->d_size,\n\t\t\t (int)sh.sh_link, (unsigned long)sh.sh_flags,\n\t\t\t (int)sh.sh_type);\n\n\t\tif (strcmp(name, \"license\") == 0) {\n\t\t\terr = bpf_object__init_license(obj, data->d_buf, data->d_size);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else if (strcmp(name, \"version\") == 0) {\n\t\t\terr = bpf_object__init_kversion(obj, data->d_buf, data->d_size);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else if (strcmp(name, \"maps\") == 0) {\n\t\t\tobj->efile.maps_shndx = idx;\n\t\t} else if (strcmp(name, MAPS_ELF_SEC) == 0) {\n\t\t\tobj->efile.btf_maps_shndx = idx;\n\t\t} else if (strcmp(name, BTF_ELF_SEC) == 0) {\n\t\t\tbtf_data = data;\n\t\t} else if (strcmp(name, BTF_EXT_ELF_SEC) == 0) {\n\t\t\tbtf_ext_data = data;\n\t\t} else if (sh.sh_type == SHT_SYMTAB) {\n\t\t\t/* already processed during the first pass above */\n\t\t} else if (sh.sh_type == SHT_PROGBITS && data->d_size > 0) {\n\t\t\tif (sh.sh_flags & SHF_EXECINSTR) {\n\t\t\t\tif (strcmp(name, \".text\") == 0)\n\t\t\t\t\tobj->efile.text_shndx = idx;\n\t\t\t\terr = bpf_object__add_programs(obj, data, name, idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else if (strcmp(name, DATA_SEC) == 0) {\n\t\t\t\tobj->efile.data = data;\n\t\t\t\tobj->efile.data_shndx = idx;\n\t\t\t} else if (strcmp(name, RODATA_SEC) == 0) {\n\t\t\t\tobj->efile.rodata = data;\n\t\t\t\tobj->efile.rodata_shndx = idx;\n\t\t\t} else if (strcmp(name, STRUCT_OPS_SEC) == 0) {\n\t\t\t\tobj->efile.st_ops_data = data;\n\t\t\t\tobj->efile.st_ops_shndx = idx;\n\t\t\t} else {\n\t\t\t\tpr_info(\"elf: skipping unrecognized data section(%d) %s\\n\",\n\t\t\t\t\tidx, name);\n\t\t\t}\n\t\t} else if (sh.sh_type == SHT_REL) {\n\t\t\tint nr_sects = obj->efile.nr_reloc_sects;\n\t\t\tvoid *sects = obj->efile.reloc_sects;\n\t\t\tint sec = sh.sh_info; /* points to other section */\n\n\t\t\t/* Only do relo for section with exec instructions */\n\t\t\tif (!section_have_execinstr(obj, sec) &&\n\t\t\t    strcmp(name, \".rel\" STRUCT_OPS_SEC) &&\n\t\t\t    strcmp(name, \".rel\" MAPS_ELF_SEC)) {\n\t\t\t\tpr_info(\"elf: skipping relo section(%d) %s for section(%d) %s\\n\",\n\t\t\t\t\tidx, name, sec,\n\t\t\t\t\telf_sec_name(obj, elf_sec_by_idx(obj, sec)) ?: \"<?>\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsects = libbpf_reallocarray(sects, nr_sects + 1,\n\t\t\t\t\t\t    sizeof(*obj->efile.reloc_sects));\n\t\t\tif (!sects)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tobj->efile.reloc_sects = sects;\n\t\t\tobj->efile.nr_reloc_sects++;\n\n\t\t\tobj->efile.reloc_sects[nr_sects].shdr = sh;\n\t\t\tobj->efile.reloc_sects[nr_sects].data = data;\n\t\t} else if (sh.sh_type == SHT_NOBITS && strcmp(name, BSS_SEC) == 0) {\n\t\t\tobj->efile.bss = data;\n\t\t\tobj->efile.bss_shndx = idx;\n\t\t} else {\n\t\t\tpr_info(\"elf: skipping section(%d) %s (size %zu)\\n\", idx, name,\n\t\t\t\t(size_t)sh.sh_size);\n\t\t}\n\t}\n\n\tif (!obj->efile.strtabidx || obj->efile.strtabidx > idx) {\n\t\tpr_warn(\"elf: symbol strings section missing or invalid in %s\\n\", obj->path);\n\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t}\n\n\t/* sort BPF programs by section name and in-section instruction offset\n\t * for faster search */\n\tqsort(obj->programs, obj->nr_programs, sizeof(*obj->programs), cmp_progs);\n\n\treturn bpf_object__init_btf(obj, btf_data, btf_ext_data);\n}\n\nstatic bool sym_is_extern(const GElf_Sym *sym)\n{\n\tint bind = GELF_ST_BIND(sym->st_info);\n\t/* externs are symbols w/ type=NOTYPE, bind=GLOBAL|WEAK, section=UND */\n\treturn sym->st_shndx == SHN_UNDEF &&\n\t       (bind == STB_GLOBAL || bind == STB_WEAK) &&\n\t       GELF_ST_TYPE(sym->st_info) == STT_NOTYPE;\n}\n\nstatic int find_extern_btf_id(const struct btf *btf, const char *ext_name)\n{\n\tconst struct btf_type *t;\n\tconst char *var_name;\n\tint i, n;\n\n\tif (!btf)\n\t\treturn -ESRCH;\n\n\tn = btf__get_nr_types(btf);\n\tfor (i = 1; i <= n; i++) {\n\t\tt = btf__type_by_id(btf, i);\n\n\t\tif (!btf_is_var(t))\n\t\t\tcontinue;\n\n\t\tvar_name = btf__name_by_offset(btf, t->name_off);\n\t\tif (strcmp(var_name, ext_name))\n\t\t\tcontinue;\n\n\t\tif (btf_var(t)->linkage != BTF_VAR_GLOBAL_EXTERN)\n\t\t\treturn -EINVAL;\n\n\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int find_extern_sec_btf_id(struct btf *btf, int ext_btf_id) {\n\tconst struct btf_var_secinfo *vs;\n\tconst struct btf_type *t;\n\tint i, j, n;\n\n\tif (!btf)\n\t\treturn -ESRCH;\n\n\tn = btf__get_nr_types(btf);\n\tfor (i = 1; i <= n; i++) {\n\t\tt = btf__type_by_id(btf, i);\n\n\t\tif (!btf_is_datasec(t))\n\t\t\tcontinue;\n\n\t\tvs = btf_var_secinfos(t);\n\t\tfor (j = 0; j < btf_vlen(t); j++, vs++) {\n\t\t\tif (vs->type == ext_btf_id)\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic enum kcfg_type find_kcfg_type(const struct btf *btf, int id,\n\t\t\t\t     bool *is_signed)\n{\n\tconst struct btf_type *t;\n\tconst char *name;\n\n\tt = skip_mods_and_typedefs(btf, id, NULL);\n\tname = btf__name_by_offset(btf, t->name_off);\n\n\tif (is_signed)\n\t\t*is_signed = false;\n\tswitch (btf_kind(t)) {\n\tcase BTF_KIND_INT: {\n\t\tint enc = btf_int_encoding(t);\n\n\t\tif (enc & BTF_INT_BOOL)\n\t\t\treturn t->size == 1 ? KCFG_BOOL : KCFG_UNKNOWN;\n\t\tif (is_signed)\n\t\t\t*is_signed = enc & BTF_INT_SIGNED;\n\t\tif (t->size == 1)\n\t\t\treturn KCFG_CHAR;\n\t\tif (t->size < 1 || t->size > 8 || (t->size & (t->size - 1)))\n\t\t\treturn KCFG_UNKNOWN;\n\t\treturn KCFG_INT;\n\t}\n\tcase BTF_KIND_ENUM:\n\t\tif (t->size != 4)\n\t\t\treturn KCFG_UNKNOWN;\n\t\tif (strcmp(name, \"libbpf_tristate\"))\n\t\t\treturn KCFG_UNKNOWN;\n\t\treturn KCFG_TRISTATE;\n\tcase BTF_KIND_ARRAY:\n\t\tif (btf_array(t)->nelems == 0)\n\t\t\treturn KCFG_UNKNOWN;\n\t\tif (find_kcfg_type(btf, btf_array(t)->type, NULL) != KCFG_CHAR)\n\t\t\treturn KCFG_UNKNOWN;\n\t\treturn KCFG_CHAR_ARR;\n\tdefault:\n\t\treturn KCFG_UNKNOWN;\n\t}\n}\n\nstatic int cmp_externs(const void *_a, const void *_b)\n{\n\tconst struct extern_desc *a = _a;\n\tconst struct extern_desc *b = _b;\n\n\tif (a->type != b->type)\n\t\treturn a->type < b->type ? -1 : 1;\n\n\tif (a->type == EXT_KCFG) {\n\t\t/* descending order by alignment requirements */\n\t\tif (a->kcfg.align != b->kcfg.align)\n\t\t\treturn a->kcfg.align > b->kcfg.align ? -1 : 1;\n\t\t/* ascending order by size, within same alignment class */\n\t\tif (a->kcfg.sz != b->kcfg.sz)\n\t\t\treturn a->kcfg.sz < b->kcfg.sz ? -1 : 1;\n\t}\n\n\t/* resolve ties by name */\n\treturn strcmp(a->name, b->name);\n}\n\nstatic int find_int_btf_id(const struct btf *btf)\n{\n\tconst struct btf_type *t;\n\tint i, n;\n\n\tn = btf__get_nr_types(btf);\n\tfor (i = 1; i <= n; i++) {\n\t\tt = btf__type_by_id(btf, i);\n\n\t\tif (btf_is_int(t) && btf_int_bits(t) == 32)\n\t\t\treturn i;\n\t}\n\n\treturn 0;\n}\n\nstatic int bpf_object__collect_externs(struct bpf_object *obj)\n{\n\tstruct btf_type *sec, *kcfg_sec = NULL, *ksym_sec = NULL;\n\tconst struct btf_type *t;\n\tstruct extern_desc *ext;\n\tint i, n, off;\n\tconst char *ext_name, *sec_name;\n\tElf_Scn *scn;\n\tGElf_Shdr sh;\n\n\tif (!obj->efile.symbols)\n\t\treturn 0;\n\n\tscn = elf_sec_by_idx(obj, obj->efile.symbols_shndx);\n\tif (elf_sec_hdr(obj, scn, &sh))\n\t\treturn -LIBBPF_ERRNO__FORMAT;\n\n\tn = sh.sh_size / sh.sh_entsize;\n\tpr_debug(\"looking for externs among %d symbols...\\n\", n);\n\n\tfor (i = 0; i < n; i++) {\n\t\tGElf_Sym sym;\n\n\t\tif (!gelf_getsym(obj->efile.symbols, i, &sym))\n\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t\tif (!sym_is_extern(&sym))\n\t\t\tcontinue;\n\t\text_name = elf_sym_str(obj, sym.st_name);\n\t\tif (!ext_name || !ext_name[0])\n\t\t\tcontinue;\n\n\t\text = obj->externs;\n\t\text = libbpf_reallocarray(ext, obj->nr_extern + 1, sizeof(*ext));\n\t\tif (!ext)\n\t\t\treturn -ENOMEM;\n\t\tobj->externs = ext;\n\t\text = &ext[obj->nr_extern];\n\t\tmemset(ext, 0, sizeof(*ext));\n\t\tobj->nr_extern++;\n\n\t\text->btf_id = find_extern_btf_id(obj->btf, ext_name);\n\t\tif (ext->btf_id <= 0) {\n\t\t\tpr_warn(\"failed to find BTF for extern '%s': %d\\n\",\n\t\t\t\text_name, ext->btf_id);\n\t\t\treturn ext->btf_id;\n\t\t}\n\t\tt = btf__type_by_id(obj->btf, ext->btf_id);\n\t\text->name = btf__name_by_offset(obj->btf, t->name_off);\n\t\text->sym_idx = i;\n\t\text->is_weak = GELF_ST_BIND(sym.st_info) == STB_WEAK;\n\n\t\text->sec_btf_id = find_extern_sec_btf_id(obj->btf, ext->btf_id);\n\t\tif (ext->sec_btf_id <= 0) {\n\t\t\tpr_warn(\"failed to find BTF for extern '%s' [%d] section: %d\\n\",\n\t\t\t\text_name, ext->btf_id, ext->sec_btf_id);\n\t\t\treturn ext->sec_btf_id;\n\t\t}\n\t\tsec = (void *)btf__type_by_id(obj->btf, ext->sec_btf_id);\n\t\tsec_name = btf__name_by_offset(obj->btf, sec->name_off);\n\n\t\tif (strcmp(sec_name, KCONFIG_SEC) == 0) {\n\t\t\tkcfg_sec = sec;\n\t\t\text->type = EXT_KCFG;\n\t\t\text->kcfg.sz = btf__resolve_size(obj->btf, t->type);\n\t\t\tif (ext->kcfg.sz <= 0) {\n\t\t\t\tpr_warn(\"failed to resolve size of extern (kcfg) '%s': %d\\n\",\n\t\t\t\t\text_name, ext->kcfg.sz);\n\t\t\t\treturn ext->kcfg.sz;\n\t\t\t}\n\t\t\text->kcfg.align = btf__align_of(obj->btf, t->type);\n\t\t\tif (ext->kcfg.align <= 0) {\n\t\t\t\tpr_warn(\"failed to determine alignment of extern (kcfg) '%s': %d\\n\",\n\t\t\t\t\text_name, ext->kcfg.align);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\text->kcfg.type = find_kcfg_type(obj->btf, t->type,\n\t\t\t\t\t\t        &ext->kcfg.is_signed);\n\t\t\tif (ext->kcfg.type == KCFG_UNKNOWN) {\n\t\t\t\tpr_warn(\"extern (kcfg) '%s' type is unsupported\\n\", ext_name);\n\t\t\t\treturn -ENOTSUP;\n\t\t\t}\n\t\t} else if (strcmp(sec_name, KSYMS_SEC) == 0) {\n\t\t\tksym_sec = sec;\n\t\t\text->type = EXT_KSYM;\n\t\t\tskip_mods_and_typedefs(obj->btf, t->type,\n\t\t\t\t\t       &ext->ksym.type_id);\n\t\t} else {\n\t\t\tpr_warn(\"unrecognized extern section '%s'\\n\", sec_name);\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t}\n\tpr_debug(\"collected %d externs total\\n\", obj->nr_extern);\n\n\tif (!obj->nr_extern)\n\t\treturn 0;\n\n\t/* sort externs by type, for kcfg ones also by (align, size, name) */\n\tqsort(obj->externs, obj->nr_extern, sizeof(*ext), cmp_externs);\n\n\t/* for .ksyms section, we need to turn all externs into allocated\n\t * variables in BTF to pass kernel verification; we do this by\n\t * pretending that each extern is a 8-byte variable\n\t */\n\tif (ksym_sec) {\n\t\t/* find existing 4-byte integer type in BTF to use for fake\n\t\t * extern variables in DATASEC\n\t\t */\n\t\tint int_btf_id = find_int_btf_id(obj->btf);\n\n\t\tfor (i = 0; i < obj->nr_extern; i++) {\n\t\t\text = &obj->externs[i];\n\t\t\tif (ext->type != EXT_KSYM)\n\t\t\t\tcontinue;\n\t\t\tpr_debug(\"extern (ksym) #%d: symbol %d, name %s\\n\",\n\t\t\t\t i, ext->sym_idx, ext->name);\n\t\t}\n\n\t\tsec = ksym_sec;\n\t\tn = btf_vlen(sec);\n\t\tfor (i = 0, off = 0; i < n; i++, off += sizeof(int)) {\n\t\t\tstruct btf_var_secinfo *vs = btf_var_secinfos(sec) + i;\n\t\t\tstruct btf_type *vt;\n\n\t\t\tvt = (void *)btf__type_by_id(obj->btf, vs->type);\n\t\t\text_name = btf__name_by_offset(obj->btf, vt->name_off);\n\t\t\text = find_extern_by_name(obj, ext_name);\n\t\t\tif (!ext) {\n\t\t\t\tpr_warn(\"failed to find extern definition for BTF var '%s'\\n\",\n\t\t\t\t\text_name);\n\t\t\t\treturn -ESRCH;\n\t\t\t}\n\t\t\tbtf_var(vt)->linkage = BTF_VAR_GLOBAL_ALLOCATED;\n\t\t\tvt->type = int_btf_id;\n\t\t\tvs->offset = off;\n\t\t\tvs->size = sizeof(int);\n\t\t}\n\t\tsec->size = off;\n\t}\n\n\tif (kcfg_sec) {\n\t\tsec = kcfg_sec;\n\t\t/* for kcfg externs calculate their offsets within a .kconfig map */\n\t\toff = 0;\n\t\tfor (i = 0; i < obj->nr_extern; i++) {\n\t\t\text = &obj->externs[i];\n\t\t\tif (ext->type != EXT_KCFG)\n\t\t\t\tcontinue;\n\n\t\t\text->kcfg.data_off = roundup(off, ext->kcfg.align);\n\t\t\toff = ext->kcfg.data_off + ext->kcfg.sz;\n\t\t\tpr_debug(\"extern (kcfg) #%d: symbol %d, off %u, name %s\\n\",\n\t\t\t\t i, ext->sym_idx, ext->kcfg.data_off, ext->name);\n\t\t}\n\t\tsec->size = off;\n\t\tn = btf_vlen(sec);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tstruct btf_var_secinfo *vs = btf_var_secinfos(sec) + i;\n\n\t\t\tt = btf__type_by_id(obj->btf, vs->type);\n\t\t\text_name = btf__name_by_offset(obj->btf, t->name_off);\n\t\t\text = find_extern_by_name(obj, ext_name);\n\t\t\tif (!ext) {\n\t\t\t\tpr_warn(\"failed to find extern definition for BTF var '%s'\\n\",\n\t\t\t\t\text_name);\n\t\t\t\treturn -ESRCH;\n\t\t\t}\n\t\t\tbtf_var(t)->linkage = BTF_VAR_GLOBAL_ALLOCATED;\n\t\t\tvs->offset = ext->kcfg.data_off;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstruct bpf_program *\nbpf_object__find_program_by_title(const struct bpf_object *obj,\n\t\t\t\t  const char *title)\n{\n\tstruct bpf_program *pos;\n\n\tbpf_object__for_each_program(pos, obj) {\n\t\tif (pos->sec_name && !strcmp(pos->sec_name, title))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\nstatic bool prog_is_subprog(const struct bpf_object *obj,\n\t\t\t    const struct bpf_program *prog)\n{\n\t/* For legacy reasons, libbpf supports an entry-point BPF programs\n\t * without SEC() attribute, i.e., those in the .text section. But if\n\t * there are 2 or more such programs in the .text section, they all\n\t * must be subprograms called from entry-point BPF programs in\n\t * designated SEC()'tions, otherwise there is no way to distinguish\n\t * which of those programs should be loaded vs which are a subprogram.\n\t * Similarly, if there is a function/program in .text and at least one\n\t * other BPF program with custom SEC() attribute, then we just assume\n\t * .text programs are subprograms (even if they are not called from\n\t * other programs), because libbpf never explicitly supported mixing\n\t * SEC()-designated BPF programs and .text entry-point BPF programs.\n\t */\n\treturn prog->sec_idx == obj->efile.text_shndx && obj->nr_programs > 1;\n}\n\nstruct bpf_program *\nbpf_object__find_program_by_name(const struct bpf_object *obj,\n\t\t\t\t const char *name)\n{\n\tstruct bpf_program *prog;\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tif (prog_is_subprog(obj, prog))\n\t\t\tcontinue;\n\t\tif (!strcmp(prog->name, name))\n\t\t\treturn prog;\n\t}\n\treturn NULL;\n}\n\nstatic bool bpf_object__shndx_is_data(const struct bpf_object *obj,\n\t\t\t\t      int shndx)\n{\n\treturn shndx == obj->efile.data_shndx ||\n\t       shndx == obj->efile.bss_shndx ||\n\t       shndx == obj->efile.rodata_shndx;\n}\n\nstatic bool bpf_object__shndx_is_maps(const struct bpf_object *obj,\n\t\t\t\t      int shndx)\n{\n\treturn shndx == obj->efile.maps_shndx ||\n\t       shndx == obj->efile.btf_maps_shndx;\n}\n\nstatic enum libbpf_map_type\nbpf_object__section_to_libbpf_map_type(const struct bpf_object *obj, int shndx)\n{\n\tif (shndx == obj->efile.data_shndx)\n\t\treturn LIBBPF_MAP_DATA;\n\telse if (shndx == obj->efile.bss_shndx)\n\t\treturn LIBBPF_MAP_BSS;\n\telse if (shndx == obj->efile.rodata_shndx)\n\t\treturn LIBBPF_MAP_RODATA;\n\telse if (shndx == obj->efile.symbols_shndx)\n\t\treturn LIBBPF_MAP_KCONFIG;\n\telse\n\t\treturn LIBBPF_MAP_UNSPEC;\n}\n\nstatic int bpf_program__record_reloc(struct bpf_program *prog,\n\t\t\t\t     struct reloc_desc *reloc_desc,\n\t\t\t\t     __u32 insn_idx, const char *sym_name,\n\t\t\t\t     const GElf_Sym *sym, const GElf_Rel *rel)\n{\n\tstruct bpf_insn *insn = &prog->insns[insn_idx];\n\tsize_t map_idx, nr_maps = prog->obj->nr_maps;\n\tstruct bpf_object *obj = prog->obj;\n\t__u32 shdr_idx = sym->st_shndx;\n\tenum libbpf_map_type type;\n\tconst char *sym_sec_name;\n\tstruct bpf_map *map;\n\n\treloc_desc->processed = false;\n\n\t/* sub-program call relocation */\n\tif (insn->code == (BPF_JMP | BPF_CALL)) {\n\t\tif (insn->src_reg != BPF_PSEUDO_CALL) {\n\t\t\tpr_warn(\"prog '%s': incorrect bpf_call opcode\\n\", prog->name);\n\t\t\treturn -LIBBPF_ERRNO__RELOC;\n\t\t}\n\t\t/* text_shndx can be 0, if no default \"main\" program exists */\n\t\tif (!shdr_idx || shdr_idx != obj->efile.text_shndx) {\n\t\t\tsym_sec_name = elf_sec_name(obj, elf_sec_by_idx(obj, shdr_idx));\n\t\t\tpr_warn(\"prog '%s': bad call relo against '%s' in section '%s'\\n\",\n\t\t\t\tprog->name, sym_name, sym_sec_name);\n\t\t\treturn -LIBBPF_ERRNO__RELOC;\n\t\t}\n\t\tif (sym->st_value % BPF_INSN_SZ) {\n\t\t\tpr_warn(\"prog '%s': bad call relo against '%s' at offset %zu\\n\",\n\t\t\t\tprog->name, sym_name, (size_t)sym->st_value);\n\t\t\treturn -LIBBPF_ERRNO__RELOC;\n\t\t}\n\t\treloc_desc->type = RELO_CALL;\n\t\treloc_desc->insn_idx = insn_idx;\n\t\treloc_desc->sym_off = sym->st_value;\n\t\treturn 0;\n\t}\n\n\tif (insn->code != (BPF_LD | BPF_IMM | BPF_DW)) {\n\t\tpr_warn(\"prog '%s': invalid relo against '%s' for insns[%d].code 0x%x\\n\",\n\t\t\tprog->name, sym_name, insn_idx, insn->code);\n\t\treturn -LIBBPF_ERRNO__RELOC;\n\t}\n\n\tif (sym_is_extern(sym)) {\n\t\tint sym_idx = GELF_R_SYM(rel->r_info);\n\t\tint i, n = obj->nr_extern;\n\t\tstruct extern_desc *ext;\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\text = &obj->externs[i];\n\t\t\tif (ext->sym_idx == sym_idx)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= n) {\n\t\t\tpr_warn(\"prog '%s': extern relo failed to find extern for '%s' (%d)\\n\",\n\t\t\t\tprog->name, sym_name, sym_idx);\n\t\t\treturn -LIBBPF_ERRNO__RELOC;\n\t\t}\n\t\tpr_debug(\"prog '%s': found extern #%d '%s' (sym %d) for insn #%u\\n\",\n\t\t\t prog->name, i, ext->name, ext->sym_idx, insn_idx);\n\t\treloc_desc->type = RELO_EXTERN;\n\t\treloc_desc->insn_idx = insn_idx;\n\t\treloc_desc->sym_off = i; /* sym_off stores extern index */\n\t\treturn 0;\n\t}\n\n\tif (!shdr_idx || shdr_idx >= SHN_LORESERVE) {\n\t\tpr_warn(\"prog '%s': invalid relo against '%s' in special section 0x%x; forgot to initialize global var?..\\n\",\n\t\t\tprog->name, sym_name, shdr_idx);\n\t\treturn -LIBBPF_ERRNO__RELOC;\n\t}\n\n\ttype = bpf_object__section_to_libbpf_map_type(obj, shdr_idx);\n\tsym_sec_name = elf_sec_name(obj, elf_sec_by_idx(obj, shdr_idx));\n\n\t/* generic map reference relocation */\n\tif (type == LIBBPF_MAP_UNSPEC) {\n\t\tif (!bpf_object__shndx_is_maps(obj, shdr_idx)) {\n\t\t\tpr_warn(\"prog '%s': bad map relo against '%s' in section '%s'\\n\",\n\t\t\t\tprog->name, sym_name, sym_sec_name);\n\t\t\treturn -LIBBPF_ERRNO__RELOC;\n\t\t}\n\t\tfor (map_idx = 0; map_idx < nr_maps; map_idx++) {\n\t\t\tmap = &obj->maps[map_idx];\n\t\t\tif (map->libbpf_type != type ||\n\t\t\t    map->sec_idx != sym->st_shndx ||\n\t\t\t    map->sec_offset != sym->st_value)\n\t\t\t\tcontinue;\n\t\t\tpr_debug(\"prog '%s': found map %zd (%s, sec %d, off %zu) for insn #%u\\n\",\n\t\t\t\t prog->name, map_idx, map->name, map->sec_idx,\n\t\t\t\t map->sec_offset, insn_idx);\n\t\t\tbreak;\n\t\t}\n\t\tif (map_idx >= nr_maps) {\n\t\t\tpr_warn(\"prog '%s': map relo failed to find map for section '%s', off %zu\\n\",\n\t\t\t\tprog->name, sym_sec_name, (size_t)sym->st_value);\n\t\t\treturn -LIBBPF_ERRNO__RELOC;\n\t\t}\n\t\treloc_desc->type = RELO_LD64;\n\t\treloc_desc->insn_idx = insn_idx;\n\t\treloc_desc->map_idx = map_idx;\n\t\treloc_desc->sym_off = 0; /* sym->st_value determines map_idx */\n\t\treturn 0;\n\t}\n\n\t/* global data map relocation */\n\tif (!bpf_object__shndx_is_data(obj, shdr_idx)) {\n\t\tpr_warn(\"prog '%s': bad data relo against section '%s'\\n\",\n\t\t\tprog->name, sym_sec_name);\n\t\treturn -LIBBPF_ERRNO__RELOC;\n\t}\n\tfor (map_idx = 0; map_idx < nr_maps; map_idx++) {\n\t\tmap = &obj->maps[map_idx];\n\t\tif (map->libbpf_type != type)\n\t\t\tcontinue;\n\t\tpr_debug(\"prog '%s': found data map %zd (%s, sec %d, off %zu) for insn %u\\n\",\n\t\t\t prog->name, map_idx, map->name, map->sec_idx,\n\t\t\t map->sec_offset, insn_idx);\n\t\tbreak;\n\t}\n\tif (map_idx >= nr_maps) {\n\t\tpr_warn(\"prog '%s': data relo failed to find map for section '%s'\\n\",\n\t\t\tprog->name, sym_sec_name);\n\t\treturn -LIBBPF_ERRNO__RELOC;\n\t}\n\n\treloc_desc->type = RELO_DATA;\n\treloc_desc->insn_idx = insn_idx;\n\treloc_desc->map_idx = map_idx;\n\treloc_desc->sym_off = sym->st_value;\n\treturn 0;\n}\n\nstatic bool prog_contains_insn(const struct bpf_program *prog, size_t insn_idx)\n{\n\treturn insn_idx >= prog->sec_insn_off &&\n\t       insn_idx < prog->sec_insn_off + prog->sec_insn_cnt;\n}\n\nstatic struct bpf_program *find_prog_by_sec_insn(const struct bpf_object *obj,\n\t\t\t\t\t\t size_t sec_idx, size_t insn_idx)\n{\n\tint l = 0, r = obj->nr_programs - 1, m;\n\tstruct bpf_program *prog;\n\n\twhile (l < r) {\n\t\tm = l + (r - l + 1) / 2;\n\t\tprog = &obj->programs[m];\n\n\t\tif (prog->sec_idx < sec_idx ||\n\t\t    (prog->sec_idx == sec_idx && prog->sec_insn_off <= insn_idx))\n\t\t\tl = m;\n\t\telse\n\t\t\tr = m - 1;\n\t}\n\t/* matching program could be at index l, but it still might be the\n\t * wrong one, so we need to double check conditions for the last time\n\t */\n\tprog = &obj->programs[l];\n\tif (prog->sec_idx == sec_idx && prog_contains_insn(prog, insn_idx))\n\t\treturn prog;\n\treturn NULL;\n}\n\nstatic int\nbpf_object__collect_prog_relos(struct bpf_object *obj, GElf_Shdr *shdr, Elf_Data *data)\n{\n\tElf_Data *symbols = obj->efile.symbols;\n\tconst char *relo_sec_name, *sec_name;\n\tsize_t sec_idx = shdr->sh_info;\n\tstruct bpf_program *prog;\n\tstruct reloc_desc *relos;\n\tint err, i, nrels;\n\tconst char *sym_name;\n\t__u32 insn_idx;\n\tGElf_Sym sym;\n\tGElf_Rel rel;\n\n\trelo_sec_name = elf_sec_str(obj, shdr->sh_name);\n\tsec_name = elf_sec_name(obj, elf_sec_by_idx(obj, sec_idx));\n\tif (!relo_sec_name || !sec_name)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"sec '%s': collecting relocation for section(%zu) '%s'\\n\",\n\t\t relo_sec_name, sec_idx, sec_name);\n\tnrels = shdr->sh_size / shdr->sh_entsize;\n\n\tfor (i = 0; i < nrels; i++) {\n\t\tif (!gelf_getrel(data, i, &rel)) {\n\t\t\tpr_warn(\"sec '%s': failed to get relo #%d\\n\", relo_sec_name, i);\n\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t\t}\n\t\tif (!gelf_getsym(symbols, GELF_R_SYM(rel.r_info), &sym)) {\n\t\t\tpr_warn(\"sec '%s': symbol 0x%zx not found for relo #%d\\n\",\n\t\t\t\trelo_sec_name, (size_t)GELF_R_SYM(rel.r_info), i);\n\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t\t}\n\t\tif (rel.r_offset % BPF_INSN_SZ) {\n\t\t\tpr_warn(\"sec '%s': invalid offset 0x%zx for relo #%d\\n\",\n\t\t\t\trelo_sec_name, (size_t)GELF_R_SYM(rel.r_info), i);\n\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t\t}\n\n\t\tinsn_idx = rel.r_offset / BPF_INSN_SZ;\n\t\t/* relocations against static functions are recorded as\n\t\t * relocations against the section that contains a function;\n\t\t * in such case, symbol will be STT_SECTION and sym.st_name\n\t\t * will point to empty string (0), so fetch section name\n\t\t * instead\n\t\t */\n\t\tif (GELF_ST_TYPE(sym.st_info) == STT_SECTION && sym.st_name == 0)\n\t\t\tsym_name = elf_sec_name(obj, elf_sec_by_idx(obj, sym.st_shndx));\n\t\telse\n\t\t\tsym_name = elf_sym_str(obj, sym.st_name);\n\t\tsym_name = sym_name ?: \"<?\";\n\n\t\tpr_debug(\"sec '%s': relo #%d: insn #%u against '%s'\\n\",\n\t\t\t relo_sec_name, i, insn_idx, sym_name);\n\n\t\tprog = find_prog_by_sec_insn(obj, sec_idx, insn_idx);\n\t\tif (!prog) {\n\t\t\tpr_warn(\"sec '%s': relo #%d: program not found in section '%s' for insn #%u\\n\",\n\t\t\t\trelo_sec_name, i, sec_name, insn_idx);\n\t\t\treturn -LIBBPF_ERRNO__RELOC;\n\t\t}\n\n\t\trelos = libbpf_reallocarray(prog->reloc_desc,\n\t\t\t\t\t    prog->nr_reloc + 1, sizeof(*relos));\n\t\tif (!relos)\n\t\t\treturn -ENOMEM;\n\t\tprog->reloc_desc = relos;\n\n\t\t/* adjust insn_idx to local BPF program frame of reference */\n\t\tinsn_idx -= prog->sec_insn_off;\n\t\terr = bpf_program__record_reloc(prog, &relos[prog->nr_reloc],\n\t\t\t\t\t\tinsn_idx, sym_name, &sym, &rel);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tprog->nr_reloc++;\n\t}\n\treturn 0;\n}\n\nstatic int bpf_map_find_btf_info(struct bpf_object *obj, struct bpf_map *map)\n{\n\tstruct bpf_map_def *def = &map->def;\n\t__u32 key_type_id = 0, value_type_id = 0;\n\tint ret;\n\n\t/* if it's BTF-defined map, we don't need to search for type IDs.\n\t * For struct_ops map, it does not need btf_key_type_id and\n\t * btf_value_type_id.\n\t */\n\tif (map->sec_idx == obj->efile.btf_maps_shndx ||\n\t    bpf_map__is_struct_ops(map))\n\t\treturn 0;\n\n\tif (!bpf_map__is_internal(map)) {\n\t\tret = btf__get_map_kv_tids(obj->btf, map->name, def->key_size,\n\t\t\t\t\t   def->value_size, &key_type_id,\n\t\t\t\t\t   &value_type_id);\n\t} else {\n\t\t/*\n\t\t * LLVM annotates global data differently in BTF, that is,\n\t\t * only as '.data', '.bss' or '.rodata'.\n\t\t */\n\t\tret = btf__find_by_name(obj->btf,\n\t\t\t\tlibbpf_type_to_btf_name[map->libbpf_type]);\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmap->btf_key_type_id = key_type_id;\n\tmap->btf_value_type_id = bpf_map__is_internal(map) ?\n\t\t\t\t ret : value_type_id;\n\treturn 0;\n}\n\nint bpf_map__reuse_fd(struct bpf_map *map, int fd)\n{\n\tstruct bpf_map_info info = {};\n\t__u32 len = sizeof(info);\n\tint new_fd, err;\n\tchar *new_name;\n\n\terr = bpf_obj_get_info_by_fd(fd, &info, &len);\n\tif (err)\n\t\treturn err;\n\n\tnew_name = strdup(info.name);\n\tif (!new_name)\n\t\treturn -errno;\n\n\tnew_fd = open(\"/\", O_RDONLY | O_CLOEXEC);\n\tif (new_fd < 0) {\n\t\terr = -errno;\n\t\tgoto err_free_new_name;\n\t}\n\n\tnew_fd = dup3(fd, new_fd, O_CLOEXEC);\n\tif (new_fd < 0) {\n\t\terr = -errno;\n\t\tgoto err_close_new_fd;\n\t}\n\n\terr = zclose(map->fd);\n\tif (err) {\n\t\terr = -errno;\n\t\tgoto err_close_new_fd;\n\t}\n\tfree(map->name);\n\n\tmap->fd = new_fd;\n\tmap->name = new_name;\n\tmap->def.type = info.type;\n\tmap->def.key_size = info.key_size;\n\tmap->def.value_size = info.value_size;\n\tmap->def.max_entries = info.max_entries;\n\tmap->def.map_flags = info.map_flags;\n\tmap->btf_key_type_id = info.btf_key_type_id;\n\tmap->btf_value_type_id = info.btf_value_type_id;\n\tmap->reused = true;\n\n\treturn 0;\n\nerr_close_new_fd:\n\tclose(new_fd);\nerr_free_new_name:\n\tfree(new_name);\n\treturn err;\n}\n\n__u32 bpf_map__max_entries(const struct bpf_map *map)\n{\n\treturn map->def.max_entries;\n}\n\nint bpf_map__set_max_entries(struct bpf_map *map, __u32 max_entries)\n{\n\tif (map->fd >= 0)\n\t\treturn -EBUSY;\n\tmap->def.max_entries = max_entries;\n\treturn 0;\n}\n\nint bpf_map__resize(struct bpf_map *map, __u32 max_entries)\n{\n\tif (!map || !max_entries)\n\t\treturn -EINVAL;\n\n\treturn bpf_map__set_max_entries(map, max_entries);\n}\n\nstatic int\nbpf_object__probe_loading(struct bpf_object *obj)\n{\n\tstruct bpf_load_program_attr attr;\n\tchar *cp, errmsg[STRERR_BUFSIZE];\n\tstruct bpf_insn insns[] = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_EXIT_INSN(),\n\t};\n\tint ret;\n\n\t/* make sure basic loading works */\n\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.prog_type = BPF_PROG_TYPE_SOCKET_FILTER;\n\tattr.insns = insns;\n\tattr.insns_cnt = ARRAY_SIZE(insns);\n\tattr.license = \"GPL\";\n\n\tret = bpf_load_program_xattr(&attr, NULL, 0);\n\tif (ret < 0) {\n\t\tret = errno;\n\t\tcp = libbpf_strerror_r(ret, errmsg, sizeof(errmsg));\n\t\tpr_warn(\"Error in %s():%s(%d). Couldn't load trivial BPF \"\n\t\t\t\"program. Make sure your kernel supports BPF \"\n\t\t\t\"(CONFIG_BPF_SYSCALL=y) and/or that RLIMIT_MEMLOCK is \"\n\t\t\t\"set to big enough value.\\n\", __func__, cp, ret);\n\t\treturn -ret;\n\t}\n\tclose(ret);\n\n\treturn 0;\n}\n\nstatic int probe_fd(int fd)\n{\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn fd >= 0;\n}\n\nstatic int probe_kern_prog_name(void)\n{\n\tstruct bpf_load_program_attr attr;\n\tstruct bpf_insn insns[] = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_EXIT_INSN(),\n\t};\n\tint ret;\n\n\t/* make sure loading with name works */\n\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.prog_type = BPF_PROG_TYPE_SOCKET_FILTER;\n\tattr.insns = insns;\n\tattr.insns_cnt = ARRAY_SIZE(insns);\n\tattr.license = \"GPL\";\n\tattr.name = \"test\";\n\tret = bpf_load_program_xattr(&attr, NULL, 0);\n\treturn probe_fd(ret);\n}\n\nstatic int probe_kern_global_data(void)\n{\n\tstruct bpf_load_program_attr prg_attr;\n\tstruct bpf_create_map_attr map_attr;\n\tchar *cp, errmsg[STRERR_BUFSIZE];\n\tstruct bpf_insn insns[] = {\n\t\tBPF_LD_MAP_VALUE(BPF_REG_1, 0, 16),\n\t\tBPF_ST_MEM(BPF_DW, BPF_REG_1, 0, 42),\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_EXIT_INSN(),\n\t};\n\tint ret, map;\n\n\tmemset(&map_attr, 0, sizeof(map_attr));\n\tmap_attr.map_type = BPF_MAP_TYPE_ARRAY;\n\tmap_attr.key_size = sizeof(int);\n\tmap_attr.value_size = 32;\n\tmap_attr.max_entries = 1;\n\n\tmap = bpf_create_map_xattr(&map_attr);\n\tif (map < 0) {\n\t\tret = -errno;\n\t\tcp = libbpf_strerror_r(ret, errmsg, sizeof(errmsg));\n\t\tpr_warn(\"Error in %s():%s(%d). Couldn't create simple array map.\\n\",\n\t\t\t__func__, cp, -ret);\n\t\treturn ret;\n\t}\n\n\tinsns[0].imm = map;\n\n\tmemset(&prg_attr, 0, sizeof(prg_attr));\n\tprg_attr.prog_type = BPF_PROG_TYPE_SOCKET_FILTER;\n\tprg_attr.insns = insns;\n\tprg_attr.insns_cnt = ARRAY_SIZE(insns);\n\tprg_attr.license = \"GPL\";\n\n\tret = bpf_load_program_xattr(&prg_attr, NULL, 0);\n\tclose(map);\n\treturn probe_fd(ret);\n}\n\nstatic int probe_kern_btf(void)\n{\n\tstatic const char strs[] = \"\\0int\";\n\t__u32 types[] = {\n\t\t/* int */\n\t\tBTF_TYPE_INT_ENC(1, BTF_INT_SIGNED, 0, 32, 4),\n\t};\n\n\treturn probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),\n\t\t\t\t\t     strs, sizeof(strs)));\n}\n\nstatic int probe_kern_btf_func(void)\n{\n\tstatic const char strs[] = \"\\0int\\0x\\0a\";\n\t/* void x(int a) {} */\n\t__u32 types[] = {\n\t\t/* int */\n\t\tBTF_TYPE_INT_ENC(1, BTF_INT_SIGNED, 0, 32, 4),  /* [1] */\n\t\t/* FUNC_PROTO */                                /* [2] */\n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_FUNC_PROTO, 0, 1), 0),\n\t\tBTF_PARAM_ENC(7, 1),\n\t\t/* FUNC x */                                    /* [3] */\n\t\tBTF_TYPE_ENC(5, BTF_INFO_ENC(BTF_KIND_FUNC, 0, 0), 2),\n\t};\n\n\treturn probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),\n\t\t\t\t\t     strs, sizeof(strs)));\n}\n\nstatic int probe_kern_btf_func_global(void)\n{\n\tstatic const char strs[] = \"\\0int\\0x\\0a\";\n\t/* static void x(int a) {} */\n\t__u32 types[] = {\n\t\t/* int */\n\t\tBTF_TYPE_INT_ENC(1, BTF_INT_SIGNED, 0, 32, 4),  /* [1] */\n\t\t/* FUNC_PROTO */                                /* [2] */\n\t\tBTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_FUNC_PROTO, 0, 1), 0),\n\t\tBTF_PARAM_ENC(7, 1),\n\t\t/* FUNC x BTF_FUNC_GLOBAL */                    /* [3] */\n\t\tBTF_TYPE_ENC(5, BTF_INFO_ENC(BTF_KIND_FUNC, 0, BTF_FUNC_GLOBAL), 2),\n\t};\n\n\treturn probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),\n\t\t\t\t\t     strs, sizeof(strs)));\n}\n\nstatic int probe_kern_btf_datasec(void)\n{\n\tstatic const char strs[] = \"\\0x\\0.data\";\n\t/* static int a; */\n\t__u32 types[] = {\n\t\t/* int */\n\t\tBTF_TYPE_INT_ENC(0, BTF_INT_SIGNED, 0, 32, 4),  /* [1] */\n\t\t/* VAR x */                                     /* [2] */\n\t\tBTF_TYPE_ENC(1, BTF_INFO_ENC(BTF_KIND_VAR, 0, 0), 1),\n\t\tBTF_VAR_STATIC,\n\t\t/* DATASEC val */                               /* [3] */\n\t\tBTF_TYPE_ENC(3, BTF_INFO_ENC(BTF_KIND_DATASEC, 0, 1), 4),\n\t\tBTF_VAR_SECINFO_ENC(2, 0, 4),\n\t};\n\n\treturn probe_fd(libbpf__load_raw_btf((char *)types, sizeof(types),\n\t\t\t\t\t     strs, sizeof(strs)));\n}\n\nstatic int probe_kern_array_mmap(void)\n{\n\tstruct bpf_create_map_attr attr = {\n\t\t.map_type = BPF_MAP_TYPE_ARRAY,\n\t\t.map_flags = BPF_F_MMAPABLE,\n\t\t.key_size = sizeof(int),\n\t\t.value_size = sizeof(int),\n\t\t.max_entries = 1,\n\t};\n\n\treturn probe_fd(bpf_create_map_xattr(&attr));\n}\n\nstatic int probe_kern_exp_attach_type(void)\n{\n\tstruct bpf_load_program_attr attr;\n\tstruct bpf_insn insns[] = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_EXIT_INSN(),\n\t};\n\n\tmemset(&attr, 0, sizeof(attr));\n\t/* use any valid combination of program type and (optional)\n\t * non-zero expected attach type (i.e., not a BPF_CGROUP_INET_INGRESS)\n\t * to see if kernel supports expected_attach_type field for\n\t * BPF_PROG_LOAD command\n\t */\n\tattr.prog_type = BPF_PROG_TYPE_CGROUP_SOCK;\n\tattr.expected_attach_type = BPF_CGROUP_INET_SOCK_CREATE;\n\tattr.insns = insns;\n\tattr.insns_cnt = ARRAY_SIZE(insns);\n\tattr.license = \"GPL\";\n\n\treturn probe_fd(bpf_load_program_xattr(&attr, NULL, 0));\n}\n\nstatic int probe_kern_probe_read_kernel(void)\n{\n\tstruct bpf_load_program_attr attr;\n\tstruct bpf_insn insns[] = {\n\t\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_10),\t/* r1 = r10 (fp) */\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_1, -8),\t/* r1 += -8 */\n\t\tBPF_MOV64_IMM(BPF_REG_2, 8),\t\t/* r2 = 8 */\n\t\tBPF_MOV64_IMM(BPF_REG_3, 0),\t\t/* r3 = 0 */\n\t\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_probe_read_kernel),\n\t\tBPF_EXIT_INSN(),\n\t};\n\n\tmemset(&attr, 0, sizeof(attr));\n\tattr.prog_type = BPF_PROG_TYPE_KPROBE;\n\tattr.insns = insns;\n\tattr.insns_cnt = ARRAY_SIZE(insns);\n\tattr.license = \"GPL\";\n\n\treturn probe_fd(bpf_load_program_xattr(&attr, NULL, 0));\n}\n\nstatic int probe_prog_bind_map(void)\n{\n\tstruct bpf_load_program_attr prg_attr;\n\tstruct bpf_create_map_attr map_attr;\n\tchar *cp, errmsg[STRERR_BUFSIZE];\n\tstruct bpf_insn insns[] = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 0),\n\t\tBPF_EXIT_INSN(),\n\t};\n\tint ret, map, prog;\n\n\tmemset(&map_attr, 0, sizeof(map_attr));\n\tmap_attr.map_type = BPF_MAP_TYPE_ARRAY;\n\tmap_attr.key_size = sizeof(int);\n\tmap_attr.value_size = 32;\n\tmap_attr.max_entries = 1;\n\n\tmap = bpf_create_map_xattr(&map_attr);\n\tif (map < 0) {\n\t\tret = -errno;\n\t\tcp = libbpf_strerror_r(ret, errmsg, sizeof(errmsg));\n\t\tpr_warn(\"Error in %s():%s(%d). Couldn't create simple array map.\\n\",\n\t\t\t__func__, cp, -ret);\n\t\treturn ret;\n\t}\n\n\tmemset(&prg_attr, 0, sizeof(prg_attr));\n\tprg_attr.prog_type = BPF_PROG_TYPE_SOCKET_FILTER;\n\tprg_attr.insns = insns;\n\tprg_attr.insns_cnt = ARRAY_SIZE(insns);\n\tprg_attr.license = \"GPL\";\n\n\tprog = bpf_load_program_xattr(&prg_attr, NULL, 0);\n\tif (prog < 0) {\n\t\tclose(map);\n\t\treturn 0;\n\t}\n\n\tret = bpf_prog_bind_map(prog, map, NULL);\n\n\tclose(map);\n\tclose(prog);\n\n\treturn ret >= 0;\n}\n\nenum kern_feature_result {\n\tFEAT_UNKNOWN = 0,\n\tFEAT_SUPPORTED = 1,\n\tFEAT_MISSING = 2,\n};\n\ntypedef int (*feature_probe_fn)(void);\n\nstatic struct kern_feature_desc {\n\tconst char *desc;\n\tfeature_probe_fn probe;\n\tenum kern_feature_result res;\n} feature_probes[__FEAT_CNT] = {\n\t[FEAT_PROG_NAME] = {\n\t\t\"BPF program name\", probe_kern_prog_name,\n\t},\n\t[FEAT_GLOBAL_DATA] = {\n\t\t\"global variables\", probe_kern_global_data,\n\t},\n\t[FEAT_BTF] = {\n\t\t\"minimal BTF\", probe_kern_btf,\n\t},\n\t[FEAT_BTF_FUNC] = {\n\t\t\"BTF functions\", probe_kern_btf_func,\n\t},\n\t[FEAT_BTF_GLOBAL_FUNC] = {\n\t\t\"BTF global function\", probe_kern_btf_func_global,\n\t},\n\t[FEAT_BTF_DATASEC] = {\n\t\t\"BTF data section and variable\", probe_kern_btf_datasec,\n\t},\n\t[FEAT_ARRAY_MMAP] = {\n\t\t\"ARRAY map mmap()\", probe_kern_array_mmap,\n\t},\n\t[FEAT_EXP_ATTACH_TYPE] = {\n\t\t\"BPF_PROG_LOAD expected_attach_type attribute\",\n\t\tprobe_kern_exp_attach_type,\n\t},\n\t[FEAT_PROBE_READ_KERN] = {\n\t\t\"bpf_probe_read_kernel() helper\", probe_kern_probe_read_kernel,\n\t},\n\t[FEAT_PROG_BIND_MAP] = {\n\t\t\"BPF_PROG_BIND_MAP support\", probe_prog_bind_map,\n\t}\n};\n\nstatic bool kernel_supports(enum kern_feature_id feat_id)\n{\n\tstruct kern_feature_desc *feat = &feature_probes[feat_id];\n\tint ret;\n\n\tif (READ_ONCE(feat->res) == FEAT_UNKNOWN) {\n\t\tret = feat->probe();\n\t\tif (ret > 0) {\n\t\t\tWRITE_ONCE(feat->res, FEAT_SUPPORTED);\n\t\t} else if (ret == 0) {\n\t\t\tWRITE_ONCE(feat->res, FEAT_MISSING);\n\t\t} else {\n\t\t\tpr_warn(\"Detection of kernel %s support failed: %d\\n\", feat->desc, ret);\n\t\t\tWRITE_ONCE(feat->res, FEAT_MISSING);\n\t\t}\n\t}\n\n\treturn READ_ONCE(feat->res) == FEAT_SUPPORTED;\n}\n\nstatic bool map_is_reuse_compat(const struct bpf_map *map, int map_fd)\n{\n\tstruct bpf_map_info map_info = {};\n\tchar msg[STRERR_BUFSIZE];\n\t__u32 map_info_len;\n\n\tmap_info_len = sizeof(map_info);\n\n\tif (bpf_obj_get_info_by_fd(map_fd, &map_info, &map_info_len)) {\n\t\tpr_warn(\"failed to get map info for map FD %d: %s\\n\",\n\t\t\tmap_fd, libbpf_strerror_r(errno, msg, sizeof(msg)));\n\t\treturn false;\n\t}\n\n\treturn (map_info.type == map->def.type &&\n\t\tmap_info.key_size == map->def.key_size &&\n\t\tmap_info.value_size == map->def.value_size &&\n\t\tmap_info.max_entries == map->def.max_entries &&\n\t\tmap_info.map_flags == map->def.map_flags);\n}\n\nstatic int\nbpf_object__reuse_map(struct bpf_map *map)\n{\n\tchar *cp, errmsg[STRERR_BUFSIZE];\n\tint err, pin_fd;\n\n\tpin_fd = bpf_obj_get(map->pin_path);\n\tif (pin_fd < 0) {\n\t\terr = -errno;\n\t\tif (err == -ENOENT) {\n\t\t\tpr_debug(\"found no pinned map to reuse at '%s'\\n\",\n\t\t\t\t map->pin_path);\n\t\t\treturn 0;\n\t\t}\n\n\t\tcp = libbpf_strerror_r(-err, errmsg, sizeof(errmsg));\n\t\tpr_warn(\"couldn't retrieve pinned map '%s': %s\\n\",\n\t\t\tmap->pin_path, cp);\n\t\treturn err;\n\t}\n\n\tif (!map_is_reuse_compat(map, pin_fd)) {\n\t\tpr_warn(\"couldn't reuse pinned map at '%s': parameter mismatch\\n\",\n\t\t\tmap->pin_path);\n\t\tclose(pin_fd);\n\t\treturn -EINVAL;\n\t}\n\n\terr = bpf_map__reuse_fd(map, pin_fd);\n\tif (err) {\n\t\tclose(pin_fd);\n\t\treturn err;\n\t}\n\tmap->pinned = true;\n\tpr_debug(\"reused pinned map at '%s'\\n\", map->pin_path);\n\n\treturn 0;\n}\n\nstatic int\nbpf_object__populate_internal_map(struct bpf_object *obj, struct bpf_map *map)\n{\n\tenum libbpf_map_type map_type = map->libbpf_type;\n\tchar *cp, errmsg[STRERR_BUFSIZE];\n\tint err, zero = 0;\n\n\terr = bpf_map_update_elem(map->fd, &zero, map->mmaped, 0);\n\tif (err) {\n\t\terr = -errno;\n\t\tcp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));\n\t\tpr_warn(\"Error setting initial map(%s) contents: %s\\n\",\n\t\t\tmap->name, cp);\n\t\treturn err;\n\t}\n\n\t/* Freeze .rodata and .kconfig map as read-only from syscall side. */\n\tif (map_type == LIBBPF_MAP_RODATA || map_type == LIBBPF_MAP_KCONFIG) {\n\t\terr = bpf_map_freeze(map->fd);\n\t\tif (err) {\n\t\t\terr = -errno;\n\t\t\tcp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));\n\t\t\tpr_warn(\"Error freezing map(%s) as read-only: %s\\n\",\n\t\t\t\tmap->name, cp);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void bpf_map__destroy(struct bpf_map *map);\n\nstatic int bpf_object__create_map(struct bpf_object *obj, struct bpf_map *map)\n{\n\tstruct bpf_create_map_attr create_attr;\n\tstruct bpf_map_def *def = &map->def;\n\n\tmemset(&create_attr, 0, sizeof(create_attr));\n\n\tif (kernel_supports(FEAT_PROG_NAME))\n\t\tcreate_attr.name = map->name;\n\tcreate_attr.map_ifindex = map->map_ifindex;\n\tcreate_attr.map_type = def->type;\n\tcreate_attr.map_flags = def->map_flags;\n\tcreate_attr.key_size = def->key_size;\n\tcreate_attr.value_size = def->value_size;\n\tcreate_attr.numa_node = map->numa_node;\n\n\tif (def->type == BPF_MAP_TYPE_PERF_EVENT_ARRAY && !def->max_entries) {\n\t\tint nr_cpus;\n\n\t\tnr_cpus = libbpf_num_possible_cpus();\n\t\tif (nr_cpus < 0) {\n\t\t\tpr_warn(\"map '%s': failed to determine number of system CPUs: %d\\n\",\n\t\t\t\tmap->name, nr_cpus);\n\t\t\treturn nr_cpus;\n\t\t}\n\t\tpr_debug(\"map '%s': setting size to %d\\n\", map->name, nr_cpus);\n\t\tcreate_attr.max_entries = nr_cpus;\n\t} else {\n\t\tcreate_attr.max_entries = def->max_entries;\n\t}\n\n\tif (bpf_map__is_struct_ops(map))\n\t\tcreate_attr.btf_vmlinux_value_type_id =\n\t\t\tmap->btf_vmlinux_value_type_id;\n\n\tcreate_attr.btf_fd = 0;\n\tcreate_attr.btf_key_type_id = 0;\n\tcreate_attr.btf_value_type_id = 0;\n\tif (obj->btf && btf__fd(obj->btf) >= 0 && !bpf_map_find_btf_info(obj, map)) {\n\t\tcreate_attr.btf_fd = btf__fd(obj->btf);\n\t\tcreate_attr.btf_key_type_id = map->btf_key_type_id;\n\t\tcreate_attr.btf_value_type_id = map->btf_value_type_id;\n\t}\n\n\tif (bpf_map_type__is_map_in_map(def->type)) {\n\t\tif (map->inner_map) {\n\t\t\tint err;\n\n\t\t\terr = bpf_object__create_map(obj, map->inner_map);\n\t\t\tif (err) {\n\t\t\t\tpr_warn(\"map '%s': failed to create inner map: %d\\n\",\n\t\t\t\t\tmap->name, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tmap->inner_map_fd = bpf_map__fd(map->inner_map);\n\t\t}\n\t\tif (map->inner_map_fd >= 0)\n\t\t\tcreate_attr.inner_map_fd = map->inner_map_fd;\n\t}\n\n\tmap->fd = bpf_create_map_xattr(&create_attr);\n\tif (map->fd < 0 && (create_attr.btf_key_type_id ||\n\t\t\t    create_attr.btf_value_type_id)) {\n\t\tchar *cp, errmsg[STRERR_BUFSIZE];\n\t\tint err = -errno;\n\n\t\tcp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));\n\t\tpr_warn(\"Error in bpf_create_map_xattr(%s):%s(%d). Retrying without BTF.\\n\",\n\t\t\tmap->name, cp, err);\n\t\tcreate_attr.btf_fd = 0;\n\t\tcreate_attr.btf_key_type_id = 0;\n\t\tcreate_attr.btf_value_type_id = 0;\n\t\tmap->btf_key_type_id = 0;\n\t\tmap->btf_value_type_id = 0;\n\t\tmap->fd = bpf_create_map_xattr(&create_attr);\n\t}\n\n\tif (map->fd < 0)\n\t\treturn -errno;\n\n\tif (bpf_map_type__is_map_in_map(def->type) && map->inner_map) {\n\t\tbpf_map__destroy(map->inner_map);\n\t\tzfree(&map->inner_map);\n\t}\n\n\treturn 0;\n}\n\nstatic int init_map_slots(struct bpf_map *map)\n{\n\tconst struct bpf_map *targ_map;\n\tunsigned int i;\n\tint fd, err;\n\n\tfor (i = 0; i < map->init_slots_sz; i++) {\n\t\tif (!map->init_slots[i])\n\t\t\tcontinue;\n\n\t\ttarg_map = map->init_slots[i];\n\t\tfd = bpf_map__fd(targ_map);\n\t\terr = bpf_map_update_elem(map->fd, &i, &fd, 0);\n\t\tif (err) {\n\t\t\terr = -errno;\n\t\t\tpr_warn(\"map '%s': failed to initialize slot [%d] to map '%s' fd=%d: %d\\n\",\n\t\t\t\tmap->name, i, targ_map->name,\n\t\t\t\tfd, err);\n\t\t\treturn err;\n\t\t}\n\t\tpr_debug(\"map '%s': slot [%d] set to map '%s' fd=%d\\n\",\n\t\t\t map->name, i, targ_map->name, fd);\n\t}\n\n\tzfree(&map->init_slots);\n\tmap->init_slots_sz = 0;\n\n\treturn 0;\n}\n\nstatic int\nbpf_object__create_maps(struct bpf_object *obj)\n{\n\tstruct bpf_map *map;\n\tchar *cp, errmsg[STRERR_BUFSIZE];\n\tunsigned int i, j;\n\tint err;\n\n\tfor (i = 0; i < obj->nr_maps; i++) {\n\t\tmap = &obj->maps[i];\n\n\t\tif (map->pin_path) {\n\t\t\terr = bpf_object__reuse_map(map);\n\t\t\tif (err) {\n\t\t\t\tpr_warn(\"map '%s': error reusing pinned map\\n\",\n\t\t\t\t\tmap->name);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\n\t\tif (map->fd >= 0) {\n\t\t\tpr_debug(\"map '%s': skipping creation (preset fd=%d)\\n\",\n\t\t\t\t map->name, map->fd);\n\t\t} else {\n\t\t\terr = bpf_object__create_map(obj, map);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\n\t\t\tpr_debug(\"map '%s': created successfully, fd=%d\\n\",\n\t\t\t\t map->name, map->fd);\n\n\t\t\tif (bpf_map__is_internal(map)) {\n\t\t\t\terr = bpf_object__populate_internal_map(obj, map);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tzclose(map->fd);\n\t\t\t\t\tgoto err_out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (map->init_slots_sz) {\n\t\t\t\terr = init_map_slots(map);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tzclose(map->fd);\n\t\t\t\t\tgoto err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (map->pin_path && !map->pinned) {\n\t\t\terr = bpf_map__pin(map, NULL);\n\t\t\tif (err) {\n\t\t\t\tpr_warn(\"map '%s': failed to auto-pin at '%s': %d\\n\",\n\t\t\t\t\tmap->name, map->pin_path, err);\n\t\t\t\tzclose(map->fd);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_out:\n\tcp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));\n\tpr_warn(\"map '%s': failed to create: %s(%d)\\n\", map->name, cp, err);\n\tpr_perm_msg(err);\n\tfor (j = 0; j < i; j++)\n\t\tzclose(obj->maps[j].fd);\n\treturn err;\n}\n\n#define BPF_CORE_SPEC_MAX_LEN 64\n\n/* represents BPF CO-RE field or array element accessor */\nstruct bpf_core_accessor {\n\t__u32 type_id;\t\t/* struct/union type or array element type */\n\t__u32 idx;\t\t/* field index or array index */\n\tconst char *name;\t/* field name or NULL for array accessor */\n};\n\nstruct bpf_core_spec {\n\tconst struct btf *btf;\n\t/* high-level spec: named fields and array indices only */\n\tstruct bpf_core_accessor spec[BPF_CORE_SPEC_MAX_LEN];\n\t/* original unresolved (no skip_mods_or_typedefs) root type ID */\n\t__u32 root_type_id;\n\t/* CO-RE relocation kind */\n\tenum bpf_core_relo_kind relo_kind;\n\t/* high-level spec length */\n\tint len;\n\t/* raw, low-level spec: 1-to-1 with accessor spec string */\n\tint raw_spec[BPF_CORE_SPEC_MAX_LEN];\n\t/* raw spec length */\n\tint raw_len;\n\t/* field bit offset represented by spec */\n\t__u32 bit_offset;\n};\n\nstatic bool str_is_empty(const char *s)\n{\n\treturn !s || !s[0];\n}\n\nstatic bool is_flex_arr(const struct btf *btf,\n\t\t\tconst struct bpf_core_accessor *acc,\n\t\t\tconst struct btf_array *arr)\n{\n\tconst struct btf_type *t;\n\n\t/* not a flexible array, if not inside a struct or has non-zero size */\n\tif (!acc->name || arr->nelems > 0)\n\t\treturn false;\n\n\t/* has to be the last member of enclosing struct */\n\tt = btf__type_by_id(btf, acc->type_id);\n\treturn acc->idx == btf_vlen(t) - 1;\n}\n\nstatic const char *core_relo_kind_str(enum bpf_core_relo_kind kind)\n{\n\tswitch (kind) {\n\tcase BPF_FIELD_BYTE_OFFSET: return \"byte_off\";\n\tcase BPF_FIELD_BYTE_SIZE: return \"byte_sz\";\n\tcase BPF_FIELD_EXISTS: return \"field_exists\";\n\tcase BPF_FIELD_SIGNED: return \"signed\";\n\tcase BPF_FIELD_LSHIFT_U64: return \"lshift_u64\";\n\tcase BPF_FIELD_RSHIFT_U64: return \"rshift_u64\";\n\tcase BPF_TYPE_ID_LOCAL: return \"local_type_id\";\n\tcase BPF_TYPE_ID_TARGET: return \"target_type_id\";\n\tcase BPF_TYPE_EXISTS: return \"type_exists\";\n\tcase BPF_TYPE_SIZE: return \"type_size\";\n\tcase BPF_ENUMVAL_EXISTS: return \"enumval_exists\";\n\tcase BPF_ENUMVAL_VALUE: return \"enumval_value\";\n\tdefault: return \"unknown\";\n\t}\n}\n\nstatic bool core_relo_is_field_based(enum bpf_core_relo_kind kind)\n{\n\tswitch (kind) {\n\tcase BPF_FIELD_BYTE_OFFSET:\n\tcase BPF_FIELD_BYTE_SIZE:\n\tcase BPF_FIELD_EXISTS:\n\tcase BPF_FIELD_SIGNED:\n\tcase BPF_FIELD_LSHIFT_U64:\n\tcase BPF_FIELD_RSHIFT_U64:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool core_relo_is_type_based(enum bpf_core_relo_kind kind)\n{\n\tswitch (kind) {\n\tcase BPF_TYPE_ID_LOCAL:\n\tcase BPF_TYPE_ID_TARGET:\n\tcase BPF_TYPE_EXISTS:\n\tcase BPF_TYPE_SIZE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool core_relo_is_enumval_based(enum bpf_core_relo_kind kind)\n{\n\tswitch (kind) {\n\tcase BPF_ENUMVAL_EXISTS:\n\tcase BPF_ENUMVAL_VALUE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/*\n * Turn bpf_core_relo into a low- and high-level spec representation,\n * validating correctness along the way, as well as calculating resulting\n * field bit offset, specified by accessor string. Low-level spec captures\n * every single level of nestedness, including traversing anonymous\n * struct/union members. High-level one only captures semantically meaningful\n * \"turning points\": named fields and array indicies.\n * E.g., for this case:\n *\n *   struct sample {\n *       int __unimportant;\n *       struct {\n *           int __1;\n *           int __2;\n *           int a[7];\n *       };\n *   };\n *\n *   struct sample *s = ...;\n *\n *   int x = &s->a[3]; // access string = '0:1:2:3'\n *\n * Low-level spec has 1:1 mapping with each element of access string (it's\n * just a parsed access string representation): [0, 1, 2, 3].\n *\n * High-level spec will capture only 3 points:\n *   - intial zero-index access by pointer (&s->... is the same as &s[0]...);\n *   - field 'a' access (corresponds to '2' in low-level spec);\n *   - array element #3 access (corresponds to '3' in low-level spec).\n *\n * Type-based relocations (TYPE_EXISTS/TYPE_SIZE,\n * TYPE_ID_LOCAL/TYPE_ID_TARGET) don't capture any field information. Their\n * spec and raw_spec are kept empty.\n *\n * Enum value-based relocations (ENUMVAL_EXISTS/ENUMVAL_VALUE) use access\n * string to specify enumerator's value index that need to be relocated.\n */\nstatic int bpf_core_parse_spec(const struct btf *btf,\n\t\t\t       __u32 type_id,\n\t\t\t       const char *spec_str,\n\t\t\t       enum bpf_core_relo_kind relo_kind,\n\t\t\t       struct bpf_core_spec *spec)\n{\n\tint access_idx, parsed_len, i;\n\tstruct bpf_core_accessor *acc;\n\tconst struct btf_type *t;\n\tconst char *name;\n\t__u32 id;\n\t__s64 sz;\n\n\tif (str_is_empty(spec_str) || *spec_str == ':')\n\t\treturn -EINVAL;\n\n\tmemset(spec, 0, sizeof(*spec));\n\tspec->btf = btf;\n\tspec->root_type_id = type_id;\n\tspec->relo_kind = relo_kind;\n\n\t/* type-based relocations don't have a field access string */\n\tif (core_relo_is_type_based(relo_kind)) {\n\t\tif (strcmp(spec_str, \"0\"))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t/* parse spec_str=\"0:1:2:3:4\" into array raw_spec=[0, 1, 2, 3, 4] */\n\twhile (*spec_str) {\n\t\tif (*spec_str == ':')\n\t\t\t++spec_str;\n\t\tif (sscanf(spec_str, \"%d%n\", &access_idx, &parsed_len) != 1)\n\t\t\treturn -EINVAL;\n\t\tif (spec->raw_len == BPF_CORE_SPEC_MAX_LEN)\n\t\t\treturn -E2BIG;\n\t\tspec_str += parsed_len;\n\t\tspec->raw_spec[spec->raw_len++] = access_idx;\n\t}\n\n\tif (spec->raw_len == 0)\n\t\treturn -EINVAL;\n\n\tt = skip_mods_and_typedefs(btf, type_id, &id);\n\tif (!t)\n\t\treturn -EINVAL;\n\n\taccess_idx = spec->raw_spec[0];\n\tacc = &spec->spec[0];\n\tacc->type_id = id;\n\tacc->idx = access_idx;\n\tspec->len++;\n\n\tif (core_relo_is_enumval_based(relo_kind)) {\n\t\tif (!btf_is_enum(t) || spec->raw_len > 1 || access_idx >= btf_vlen(t))\n\t\t\treturn -EINVAL;\n\n\t\t/* record enumerator name in a first accessor */\n\t\tacc->name = btf__name_by_offset(btf, btf_enum(t)[access_idx].name_off);\n\t\treturn 0;\n\t}\n\n\tif (!core_relo_is_field_based(relo_kind))\n\t\treturn -EINVAL;\n\n\tsz = btf__resolve_size(btf, id);\n\tif (sz < 0)\n\t\treturn sz;\n\tspec->bit_offset = access_idx * sz * 8;\n\n\tfor (i = 1; i < spec->raw_len; i++) {\n\t\tt = skip_mods_and_typedefs(btf, id, &id);\n\t\tif (!t)\n\t\t\treturn -EINVAL;\n\n\t\taccess_idx = spec->raw_spec[i];\n\t\tacc = &spec->spec[spec->len];\n\n\t\tif (btf_is_composite(t)) {\n\t\t\tconst struct btf_member *m;\n\t\t\t__u32 bit_offset;\n\n\t\t\tif (access_idx >= btf_vlen(t))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tbit_offset = btf_member_bit_offset(t, access_idx);\n\t\t\tspec->bit_offset += bit_offset;\n\n\t\t\tm = btf_members(t) + access_idx;\n\t\t\tif (m->name_off) {\n\t\t\t\tname = btf__name_by_offset(btf, m->name_off);\n\t\t\t\tif (str_is_empty(name))\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\tacc->type_id = id;\n\t\t\t\tacc->idx = access_idx;\n\t\t\t\tacc->name = name;\n\t\t\t\tspec->len++;\n\t\t\t}\n\n\t\t\tid = m->type;\n\t\t} else if (btf_is_array(t)) {\n\t\t\tconst struct btf_array *a = btf_array(t);\n\t\t\tbool flex;\n\n\t\t\tt = skip_mods_and_typedefs(btf, a->type, &id);\n\t\t\tif (!t)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tflex = is_flex_arr(btf, acc - 1, a);\n\t\t\tif (!flex && access_idx >= a->nelems)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tspec->spec[spec->len].type_id = id;\n\t\t\tspec->spec[spec->len].idx = access_idx;\n\t\t\tspec->len++;\n\n\t\t\tsz = btf__resolve_size(btf, id);\n\t\t\tif (sz < 0)\n\t\t\t\treturn sz;\n\t\t\tspec->bit_offset += access_idx * sz * 8;\n\t\t} else {\n\t\t\tpr_warn(\"relo for [%u] %s (at idx %d) captures type [%d] of unexpected kind %s\\n\",\n\t\t\t\ttype_id, spec_str, i, id, btf_kind_str(t));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool bpf_core_is_flavor_sep(const char *s)\n{\n\t/* check X___Y name pattern, where X and Y are not underscores */\n\treturn s[0] != '_' &&\t\t\t\t      /* X */\n\t       s[1] == '_' && s[2] == '_' && s[3] == '_' &&   /* ___ */\n\t       s[4] != '_';\t\t\t\t      /* Y */\n}\n\n/* Given 'some_struct_name___with_flavor' return the length of a name prefix\n * before last triple underscore. Struct name part after last triple\n * underscore is ignored by BPF CO-RE relocation during relocation matching.\n */\nstatic size_t bpf_core_essential_name_len(const char *name)\n{\n\tsize_t n = strlen(name);\n\tint i;\n\n\tfor (i = n - 5; i >= 0; i--) {\n\t\tif (bpf_core_is_flavor_sep(name + i))\n\t\t\treturn i + 1;\n\t}\n\treturn n;\n}\n\n/* dynamically sized list of type IDs */\nstruct ids_vec {\n\t__u32 *data;\n\tint len;\n};\n\nstatic void bpf_core_free_cands(struct ids_vec *cand_ids)\n{\n\tfree(cand_ids->data);\n\tfree(cand_ids);\n}\n\nstatic struct ids_vec *bpf_core_find_cands(const struct btf *local_btf,\n\t\t\t\t\t   __u32 local_type_id,\n\t\t\t\t\t   const struct btf *targ_btf)\n{\n\tsize_t local_essent_len, targ_essent_len;\n\tconst char *local_name, *targ_name;\n\tconst struct btf_type *t, *local_t;\n\tstruct ids_vec *cand_ids;\n\t__u32 *new_ids;\n\tint i, err, n;\n\n\tlocal_t = btf__type_by_id(local_btf, local_type_id);\n\tif (!local_t)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlocal_name = btf__name_by_offset(local_btf, local_t->name_off);\n\tif (str_is_empty(local_name))\n\t\treturn ERR_PTR(-EINVAL);\n\tlocal_essent_len = bpf_core_essential_name_len(local_name);\n\n\tcand_ids = calloc(1, sizeof(*cand_ids));\n\tif (!cand_ids)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tn = btf__get_nr_types(targ_btf);\n\tfor (i = 1; i <= n; i++) {\n\t\tt = btf__type_by_id(targ_btf, i);\n\t\tif (btf_kind(t) != btf_kind(local_t))\n\t\t\tcontinue;\n\n\t\ttarg_name = btf__name_by_offset(targ_btf, t->name_off);\n\t\tif (str_is_empty(targ_name))\n\t\t\tcontinue;\n\n\t\ttarg_essent_len = bpf_core_essential_name_len(targ_name);\n\t\tif (targ_essent_len != local_essent_len)\n\t\t\tcontinue;\n\n\t\tif (strncmp(local_name, targ_name, local_essent_len) == 0) {\n\t\t\tpr_debug(\"CO-RE relocating [%d] %s %s: found target candidate [%d] %s %s\\n\",\n\t\t\t\t local_type_id, btf_kind_str(local_t),\n\t\t\t\t local_name, i, btf_kind_str(t), targ_name);\n\t\t\tnew_ids = libbpf_reallocarray(cand_ids->data,\n\t\t\t\t\t\t      cand_ids->len + 1,\n\t\t\t\t\t\t      sizeof(*cand_ids->data));\n\t\t\tif (!new_ids) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tcand_ids->data = new_ids;\n\t\t\tcand_ids->data[cand_ids->len++] = i;\n\t\t}\n\t}\n\treturn cand_ids;\nerr_out:\n\tbpf_core_free_cands(cand_ids);\n\treturn ERR_PTR(err);\n}\n\n/* Check two types for compatibility for the purpose of field access\n * relocation. const/volatile/restrict and typedefs are skipped to ensure we\n * are relocating semantically compatible entities:\n *   - any two STRUCTs/UNIONs are compatible and can be mixed;\n *   - any two FWDs are compatible, if their names match (modulo flavor suffix);\n *   - any two PTRs are always compatible;\n *   - for ENUMs, names should be the same (ignoring flavor suffix) or at\n *     least one of enums should be anonymous;\n *   - for ENUMs, check sizes, names are ignored;\n *   - for INT, size and signedness are ignored;\n *   - for ARRAY, dimensionality is ignored, element types are checked for\n *     compatibility recursively;\n *   - everything else shouldn't be ever a target of relocation.\n * These rules are not set in stone and probably will be adjusted as we get\n * more experience with using BPF CO-RE relocations.\n */\nstatic int bpf_core_fields_are_compat(const struct btf *local_btf,\n\t\t\t\t      __u32 local_id,\n\t\t\t\t      const struct btf *targ_btf,\n\t\t\t\t      __u32 targ_id)\n{\n\tconst struct btf_type *local_type, *targ_type;\n\nrecur:\n\tlocal_type = skip_mods_and_typedefs(local_btf, local_id, &local_id);\n\ttarg_type = skip_mods_and_typedefs(targ_btf, targ_id, &targ_id);\n\tif (!local_type || !targ_type)\n\t\treturn -EINVAL;\n\n\tif (btf_is_composite(local_type) && btf_is_composite(targ_type))\n\t\treturn 1;\n\tif (btf_kind(local_type) != btf_kind(targ_type))\n\t\treturn 0;\n\n\tswitch (btf_kind(local_type)) {\n\tcase BTF_KIND_PTR:\n\t\treturn 1;\n\tcase BTF_KIND_FWD:\n\tcase BTF_KIND_ENUM: {\n\t\tconst char *local_name, *targ_name;\n\t\tsize_t local_len, targ_len;\n\n\t\tlocal_name = btf__name_by_offset(local_btf,\n\t\t\t\t\t\t local_type->name_off);\n\t\ttarg_name = btf__name_by_offset(targ_btf, targ_type->name_off);\n\t\tlocal_len = bpf_core_essential_name_len(local_name);\n\t\ttarg_len = bpf_core_essential_name_len(targ_name);\n\t\t/* one of them is anonymous or both w/ same flavor-less names */\n\t\treturn local_len == 0 || targ_len == 0 ||\n\t\t       (local_len == targ_len &&\n\t\t\tstrncmp(local_name, targ_name, local_len) == 0);\n\t}\n\tcase BTF_KIND_INT:\n\t\t/* just reject deprecated bitfield-like integers; all other\n\t\t * integers are by default compatible between each other\n\t\t */\n\t\treturn btf_int_offset(local_type) == 0 &&\n\t\t       btf_int_offset(targ_type) == 0;\n\tcase BTF_KIND_ARRAY:\n\t\tlocal_id = btf_array(local_type)->type;\n\t\ttarg_id = btf_array(targ_type)->type;\n\t\tgoto recur;\n\tdefault:\n\t\tpr_warn(\"unexpected kind %d relocated, local [%d], target [%d]\\n\",\n\t\t\tbtf_kind(local_type), local_id, targ_id);\n\t\treturn 0;\n\t}\n}\n\n/*\n * Given single high-level named field accessor in local type, find\n * corresponding high-level accessor for a target type. Along the way,\n * maintain low-level spec for target as well. Also keep updating target\n * bit offset.\n *\n * Searching is performed through recursive exhaustive enumeration of all\n * fields of a struct/union. If there are any anonymous (embedded)\n * structs/unions, they are recursively searched as well. If field with\n * desired name is found, check compatibility between local and target types,\n * before returning result.\n *\n * 1 is returned, if field is found.\n * 0 is returned if no compatible field is found.\n * <0 is returned on error.\n */\nstatic int bpf_core_match_member(const struct btf *local_btf,\n\t\t\t\t const struct bpf_core_accessor *local_acc,\n\t\t\t\t const struct btf *targ_btf,\n\t\t\t\t __u32 targ_id,\n\t\t\t\t struct bpf_core_spec *spec,\n\t\t\t\t __u32 *next_targ_id)\n{\n\tconst struct btf_type *local_type, *targ_type;\n\tconst struct btf_member *local_member, *m;\n\tconst char *local_name, *targ_name;\n\t__u32 local_id;\n\tint i, n, found;\n\n\ttarg_type = skip_mods_and_typedefs(targ_btf, targ_id, &targ_id);\n\tif (!targ_type)\n\t\treturn -EINVAL;\n\tif (!btf_is_composite(targ_type))\n\t\treturn 0;\n\n\tlocal_id = local_acc->type_id;\n\tlocal_type = btf__type_by_id(local_btf, local_id);\n\tlocal_member = btf_members(local_type) + local_acc->idx;\n\tlocal_name = btf__name_by_offset(local_btf, local_member->name_off);\n\n\tn = btf_vlen(targ_type);\n\tm = btf_members(targ_type);\n\tfor (i = 0; i < n; i++, m++) {\n\t\t__u32 bit_offset;\n\n\t\tbit_offset = btf_member_bit_offset(targ_type, i);\n\n\t\t/* too deep struct/union/array nesting */\n\t\tif (spec->raw_len == BPF_CORE_SPEC_MAX_LEN)\n\t\t\treturn -E2BIG;\n\n\t\t/* speculate this member will be the good one */\n\t\tspec->bit_offset += bit_offset;\n\t\tspec->raw_spec[spec->raw_len++] = i;\n\n\t\ttarg_name = btf__name_by_offset(targ_btf, m->name_off);\n\t\tif (str_is_empty(targ_name)) {\n\t\t\t/* embedded struct/union, we need to go deeper */\n\t\t\tfound = bpf_core_match_member(local_btf, local_acc,\n\t\t\t\t\t\t      targ_btf, m->type,\n\t\t\t\t\t\t      spec, next_targ_id);\n\t\t\tif (found) /* either found or error */\n\t\t\t\treturn found;\n\t\t} else if (strcmp(local_name, targ_name) == 0) {\n\t\t\t/* matching named field */\n\t\t\tstruct bpf_core_accessor *targ_acc;\n\n\t\t\ttarg_acc = &spec->spec[spec->len++];\n\t\t\ttarg_acc->type_id = targ_id;\n\t\t\ttarg_acc->idx = i;\n\t\t\ttarg_acc->name = targ_name;\n\n\t\t\t*next_targ_id = m->type;\n\t\t\tfound = bpf_core_fields_are_compat(local_btf,\n\t\t\t\t\t\t\t   local_member->type,\n\t\t\t\t\t\t\t   targ_btf, m->type);\n\t\t\tif (!found)\n\t\t\t\tspec->len--; /* pop accessor */\n\t\t\treturn found;\n\t\t}\n\t\t/* member turned out not to be what we looked for */\n\t\tspec->bit_offset -= bit_offset;\n\t\tspec->raw_len--;\n\t}\n\n\treturn 0;\n}\n\n/* Check local and target types for compatibility. This check is used for\n * type-based CO-RE relocations and follow slightly different rules than\n * field-based relocations. This function assumes that root types were already\n * checked for name match. Beyond that initial root-level name check, names\n * are completely ignored. Compatibility rules are as follows:\n *   - any two STRUCTs/UNIONs/FWDs/ENUMs/INTs are considered compatible, but\n *     kind should match for local and target types (i.e., STRUCT is not\n *     compatible with UNION);\n *   - for ENUMs, the size is ignored;\n *   - for INT, size and signedness are ignored;\n *   - for ARRAY, dimensionality is ignored, element types are checked for\n *     compatibility recursively;\n *   - CONST/VOLATILE/RESTRICT modifiers are ignored;\n *   - TYPEDEFs/PTRs are compatible if types they pointing to are compatible;\n *   - FUNC_PROTOs are compatible if they have compatible signature: same\n *     number of input args and compatible return and argument types.\n * These rules are not set in stone and probably will be adjusted as we get\n * more experience with using BPF CO-RE relocations.\n */\nstatic int bpf_core_types_are_compat(const struct btf *local_btf, __u32 local_id,\n\t\t\t\t     const struct btf *targ_btf, __u32 targ_id)\n{\n\tconst struct btf_type *local_type, *targ_type;\n\tint depth = 32; /* max recursion depth */\n\n\t/* caller made sure that names match (ignoring flavor suffix) */\n\tlocal_type = btf__type_by_id(local_btf, local_id);\n\ttarg_type = btf__type_by_id(targ_btf, targ_id);\n\tif (btf_kind(local_type) != btf_kind(targ_type))\n\t\treturn 0;\n\nrecur:\n\tdepth--;\n\tif (depth < 0)\n\t\treturn -EINVAL;\n\n\tlocal_type = skip_mods_and_typedefs(local_btf, local_id, &local_id);\n\ttarg_type = skip_mods_and_typedefs(targ_btf, targ_id, &targ_id);\n\tif (!local_type || !targ_type)\n\t\treturn -EINVAL;\n\n\tif (btf_kind(local_type) != btf_kind(targ_type))\n\t\treturn 0;\n\n\tswitch (btf_kind(local_type)) {\n\tcase BTF_KIND_UNKN:\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_FWD:\n\t\treturn 1;\n\tcase BTF_KIND_INT:\n\t\t/* just reject deprecated bitfield-like integers; all other\n\t\t * integers are by default compatible between each other\n\t\t */\n\t\treturn btf_int_offset(local_type) == 0 && btf_int_offset(targ_type) == 0;\n\tcase BTF_KIND_PTR:\n\t\tlocal_id = local_type->type;\n\t\ttarg_id = targ_type->type;\n\t\tgoto recur;\n\tcase BTF_KIND_ARRAY:\n\t\tlocal_id = btf_array(local_type)->type;\n\t\ttarg_id = btf_array(targ_type)->type;\n\t\tgoto recur;\n\tcase BTF_KIND_FUNC_PROTO: {\n\t\tstruct btf_param *local_p = btf_params(local_type);\n\t\tstruct btf_param *targ_p = btf_params(targ_type);\n\t\t__u16 local_vlen = btf_vlen(local_type);\n\t\t__u16 targ_vlen = btf_vlen(targ_type);\n\t\tint i, err;\n\n\t\tif (local_vlen != targ_vlen)\n\t\t\treturn 0;\n\n\t\tfor (i = 0; i < local_vlen; i++, local_p++, targ_p++) {\n\t\t\tskip_mods_and_typedefs(local_btf, local_p->type, &local_id);\n\t\t\tskip_mods_and_typedefs(targ_btf, targ_p->type, &targ_id);\n\t\t\terr = bpf_core_types_are_compat(local_btf, local_id, targ_btf, targ_id);\n\t\t\tif (err <= 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t/* tail recurse for return type check */\n\t\tskip_mods_and_typedefs(local_btf, local_type->type, &local_id);\n\t\tskip_mods_and_typedefs(targ_btf, targ_type->type, &targ_id);\n\t\tgoto recur;\n\t}\n\tdefault:\n\t\tpr_warn(\"unexpected kind %s relocated, local [%d], target [%d]\\n\",\n\t\t\tbtf_kind_str(local_type), local_id, targ_id);\n\t\treturn 0;\n\t}\n}\n\n/*\n * Try to match local spec to a target type and, if successful, produce full\n * target spec (high-level, low-level + bit offset).\n */\nstatic int bpf_core_spec_match(struct bpf_core_spec *local_spec,\n\t\t\t       const struct btf *targ_btf, __u32 targ_id,\n\t\t\t       struct bpf_core_spec *targ_spec)\n{\n\tconst struct btf_type *targ_type;\n\tconst struct bpf_core_accessor *local_acc;\n\tstruct bpf_core_accessor *targ_acc;\n\tint i, sz, matched;\n\n\tmemset(targ_spec, 0, sizeof(*targ_spec));\n\ttarg_spec->btf = targ_btf;\n\ttarg_spec->root_type_id = targ_id;\n\ttarg_spec->relo_kind = local_spec->relo_kind;\n\n\tif (core_relo_is_type_based(local_spec->relo_kind)) {\n\t\treturn bpf_core_types_are_compat(local_spec->btf,\n\t\t\t\t\t\t local_spec->root_type_id,\n\t\t\t\t\t\t targ_btf, targ_id);\n\t}\n\n\tlocal_acc = &local_spec->spec[0];\n\ttarg_acc = &targ_spec->spec[0];\n\n\tif (core_relo_is_enumval_based(local_spec->relo_kind)) {\n\t\tsize_t local_essent_len, targ_essent_len;\n\t\tconst struct btf_enum *e;\n\t\tconst char *targ_name;\n\n\t\t/* has to resolve to an enum */\n\t\ttarg_type = skip_mods_and_typedefs(targ_spec->btf, targ_id, &targ_id);\n\t\tif (!btf_is_enum(targ_type))\n\t\t\treturn 0;\n\n\t\tlocal_essent_len = bpf_core_essential_name_len(local_acc->name);\n\n\t\tfor (i = 0, e = btf_enum(targ_type); i < btf_vlen(targ_type); i++, e++) {\n\t\t\ttarg_name = btf__name_by_offset(targ_spec->btf, e->name_off);\n\t\t\ttarg_essent_len = bpf_core_essential_name_len(targ_name);\n\t\t\tif (targ_essent_len != local_essent_len)\n\t\t\t\tcontinue;\n\t\t\tif (strncmp(local_acc->name, targ_name, local_essent_len) == 0) {\n\t\t\t\ttarg_acc->type_id = targ_id;\n\t\t\t\ttarg_acc->idx = i;\n\t\t\t\ttarg_acc->name = targ_name;\n\t\t\t\ttarg_spec->len++;\n\t\t\t\ttarg_spec->raw_spec[targ_spec->raw_len] = targ_acc->idx;\n\t\t\t\ttarg_spec->raw_len++;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!core_relo_is_field_based(local_spec->relo_kind))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < local_spec->len; i++, local_acc++, targ_acc++) {\n\t\ttarg_type = skip_mods_and_typedefs(targ_spec->btf, targ_id,\n\t\t\t\t\t\t   &targ_id);\n\t\tif (!targ_type)\n\t\t\treturn -EINVAL;\n\n\t\tif (local_acc->name) {\n\t\t\tmatched = bpf_core_match_member(local_spec->btf,\n\t\t\t\t\t\t\tlocal_acc,\n\t\t\t\t\t\t\ttarg_btf, targ_id,\n\t\t\t\t\t\t\ttarg_spec, &targ_id);\n\t\t\tif (matched <= 0)\n\t\t\t\treturn matched;\n\t\t} else {\n\t\t\t/* for i=0, targ_id is already treated as array element\n\t\t\t * type (because it's the original struct), for others\n\t\t\t * we should find array element type first\n\t\t\t */\n\t\t\tif (i > 0) {\n\t\t\t\tconst struct btf_array *a;\n\t\t\t\tbool flex;\n\n\t\t\t\tif (!btf_is_array(targ_type))\n\t\t\t\t\treturn 0;\n\n\t\t\t\ta = btf_array(targ_type);\n\t\t\t\tflex = is_flex_arr(targ_btf, targ_acc - 1, a);\n\t\t\t\tif (!flex && local_acc->idx >= a->nelems)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!skip_mods_and_typedefs(targ_btf, a->type,\n\t\t\t\t\t\t\t    &targ_id))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* too deep struct/union/array nesting */\n\t\t\tif (targ_spec->raw_len == BPF_CORE_SPEC_MAX_LEN)\n\t\t\t\treturn -E2BIG;\n\n\t\t\ttarg_acc->type_id = targ_id;\n\t\t\ttarg_acc->idx = local_acc->idx;\n\t\t\ttarg_acc->name = NULL;\n\t\t\ttarg_spec->len++;\n\t\t\ttarg_spec->raw_spec[targ_spec->raw_len] = targ_acc->idx;\n\t\t\ttarg_spec->raw_len++;\n\n\t\t\tsz = btf__resolve_size(targ_btf, targ_id);\n\t\t\tif (sz < 0)\n\t\t\t\treturn sz;\n\t\t\ttarg_spec->bit_offset += local_acc->idx * sz * 8;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic int bpf_core_calc_field_relo(const struct bpf_program *prog,\n\t\t\t\t    const struct bpf_core_relo *relo,\n\t\t\t\t    const struct bpf_core_spec *spec,\n\t\t\t\t    __u32 *val, __u32 *field_sz, __u32 *type_id,\n\t\t\t\t    bool *validate)\n{\n\tconst struct bpf_core_accessor *acc;\n\tconst struct btf_type *t;\n\t__u32 byte_off, byte_sz, bit_off, bit_sz, field_type_id;\n\tconst struct btf_member *m;\n\tconst struct btf_type *mt;\n\tbool bitfield;\n\t__s64 sz;\n\n\t*field_sz = 0;\n\n\tif (relo->kind == BPF_FIELD_EXISTS) {\n\t\t*val = spec ? 1 : 0;\n\t\treturn 0;\n\t}\n\n\tif (!spec)\n\t\treturn -EUCLEAN; /* request instruction poisoning */\n\n\tacc = &spec->spec[spec->len - 1];\n\tt = btf__type_by_id(spec->btf, acc->type_id);\n\n\t/* a[n] accessor needs special handling */\n\tif (!acc->name) {\n\t\tif (relo->kind == BPF_FIELD_BYTE_OFFSET) {\n\t\t\t*val = spec->bit_offset / 8;\n\t\t\t/* remember field size for load/store mem size */\n\t\t\tsz = btf__resolve_size(spec->btf, acc->type_id);\n\t\t\tif (sz < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\t*field_sz = sz;\n\t\t\t*type_id = acc->type_id;\n\t\t} else if (relo->kind == BPF_FIELD_BYTE_SIZE) {\n\t\t\tsz = btf__resolve_size(spec->btf, acc->type_id);\n\t\t\tif (sz < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\t*val = sz;\n\t\t} else {\n\t\t\tpr_warn(\"prog '%s': relo %d at insn #%d can't be applied to array access\\n\",\n\t\t\t\tprog->name, relo->kind, relo->insn_off / 8);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (validate)\n\t\t\t*validate = true;\n\t\treturn 0;\n\t}\n\n\tm = btf_members(t) + acc->idx;\n\tmt = skip_mods_and_typedefs(spec->btf, m->type, &field_type_id);\n\tbit_off = spec->bit_offset;\n\tbit_sz = btf_member_bitfield_size(t, acc->idx);\n\n\tbitfield = bit_sz > 0;\n\tif (bitfield) {\n\t\tbyte_sz = mt->size;\n\t\tbyte_off = bit_off / 8 / byte_sz * byte_sz;\n\t\t/* figure out smallest int size necessary for bitfield load */\n\t\twhile (bit_off + bit_sz - byte_off * 8 > byte_sz * 8) {\n\t\t\tif (byte_sz >= 8) {\n\t\t\t\t/* bitfield can't be read with 64-bit read */\n\t\t\t\tpr_warn(\"prog '%s': relo %d at insn #%d can't be satisfied for bitfield\\n\",\n\t\t\t\t\tprog->name, relo->kind, relo->insn_off / 8);\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\t\t\tbyte_sz *= 2;\n\t\t\tbyte_off = bit_off / 8 / byte_sz * byte_sz;\n\t\t}\n\t} else {\n\t\tsz = btf__resolve_size(spec->btf, field_type_id);\n\t\tif (sz < 0)\n\t\t\treturn -EINVAL;\n\t\tbyte_sz = sz;\n\t\tbyte_off = spec->bit_offset / 8;\n\t\tbit_sz = byte_sz * 8;\n\t}\n\n\t/* for bitfields, all the relocatable aspects are ambiguous and we\n\t * might disagree with compiler, so turn off validation of expected\n\t * value, except for signedness\n\t */\n\tif (validate)\n\t\t*validate = !bitfield;\n\n\tswitch (relo->kind) {\n\tcase BPF_FIELD_BYTE_OFFSET:\n\t\t*val = byte_off;\n\t\tif (!bitfield) {\n\t\t\t*field_sz = byte_sz;\n\t\t\t*type_id = field_type_id;\n\t\t}\n\t\tbreak;\n\tcase BPF_FIELD_BYTE_SIZE:\n\t\t*val = byte_sz;\n\t\tbreak;\n\tcase BPF_FIELD_SIGNED:\n\t\t/* enums will be assumed unsigned */\n\t\t*val = btf_is_enum(mt) ||\n\t\t       (btf_int_encoding(mt) & BTF_INT_SIGNED);\n\t\tif (validate)\n\t\t\t*validate = true; /* signedness is never ambiguous */\n\t\tbreak;\n\tcase BPF_FIELD_LSHIFT_U64:\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n\t\t*val = 64 - (bit_off + bit_sz - byte_off  * 8);\n#else\n\t\t*val = (8 - byte_sz) * 8 + (bit_off - byte_off * 8);\n#endif\n\t\tbreak;\n\tcase BPF_FIELD_RSHIFT_U64:\n\t\t*val = 64 - bit_sz;\n\t\tif (validate)\n\t\t\t*validate = true; /* right shift is never ambiguous */\n\t\tbreak;\n\tcase BPF_FIELD_EXISTS:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int bpf_core_calc_type_relo(const struct bpf_core_relo *relo,\n\t\t\t\t   const struct bpf_core_spec *spec,\n\t\t\t\t   __u32 *val)\n{\n\t__s64 sz;\n\n\t/* type-based relos return zero when target type is not found */\n\tif (!spec) {\n\t\t*val = 0;\n\t\treturn 0;\n\t}\n\n\tswitch (relo->kind) {\n\tcase BPF_TYPE_ID_TARGET:\n\t\t*val = spec->root_type_id;\n\t\tbreak;\n\tcase BPF_TYPE_EXISTS:\n\t\t*val = 1;\n\t\tbreak;\n\tcase BPF_TYPE_SIZE:\n\t\tsz = btf__resolve_size(spec->btf, spec->root_type_id);\n\t\tif (sz < 0)\n\t\t\treturn -EINVAL;\n\t\t*val = sz;\n\t\tbreak;\n\tcase BPF_TYPE_ID_LOCAL:\n\t/* BPF_TYPE_ID_LOCAL is handled specially and shouldn't get here */\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int bpf_core_calc_enumval_relo(const struct bpf_core_relo *relo,\n\t\t\t\t      const struct bpf_core_spec *spec,\n\t\t\t\t      __u32 *val)\n{\n\tconst struct btf_type *t;\n\tconst struct btf_enum *e;\n\n\tswitch (relo->kind) {\n\tcase BPF_ENUMVAL_EXISTS:\n\t\t*val = spec ? 1 : 0;\n\t\tbreak;\n\tcase BPF_ENUMVAL_VALUE:\n\t\tif (!spec)\n\t\t\treturn -EUCLEAN; /* request instruction poisoning */\n\t\tt = btf__type_by_id(spec->btf, spec->spec[0].type_id);\n\t\te = btf_enum(t) + spec->spec[0].idx;\n\t\t*val = e->val;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstruct bpf_core_relo_res\n{\n\t/* expected value in the instruction, unless validate == false */\n\t__u32 orig_val;\n\t/* new value that needs to be patched up to */\n\t__u32 new_val;\n\t/* relocation unsuccessful, poison instruction, but don't fail load */\n\tbool poison;\n\t/* some relocations can't be validated against orig_val */\n\tbool validate;\n\t/* for field byte offset relocations or the forms:\n\t *     *(T *)(rX + <off>) = rY\n\t *     rX = *(T *)(rY + <off>),\n\t * we remember original and resolved field size to adjust direct\n\t * memory loads of pointers and integers; this is necessary for 32-bit\n\t * host kernel architectures, but also allows to automatically\n\t * relocate fields that were resized from, e.g., u32 to u64, etc.\n\t */\n\tbool fail_memsz_adjust;\n\t__u32 orig_sz;\n\t__u32 orig_type_id;\n\t__u32 new_sz;\n\t__u32 new_type_id;\n};\n\n/* Calculate original and target relocation values, given local and target\n * specs and relocation kind. These values are calculated for each candidate.\n * If there are multiple candidates, resulting values should all be consistent\n * with each other. Otherwise, libbpf will refuse to proceed due to ambiguity.\n * If instruction has to be poisoned, *poison will be set to true.\n */\nstatic int bpf_core_calc_relo(const struct bpf_program *prog,\n\t\t\t      const struct bpf_core_relo *relo,\n\t\t\t      int relo_idx,\n\t\t\t      const struct bpf_core_spec *local_spec,\n\t\t\t      const struct bpf_core_spec *targ_spec,\n\t\t\t      struct bpf_core_relo_res *res)\n{\n\tint err = -EOPNOTSUPP;\n\n\tres->orig_val = 0;\n\tres->new_val = 0;\n\tres->poison = false;\n\tres->validate = true;\n\tres->fail_memsz_adjust = false;\n\tres->orig_sz = res->new_sz = 0;\n\tres->orig_type_id = res->new_type_id = 0;\n\n\tif (core_relo_is_field_based(relo->kind)) {\n\t\terr = bpf_core_calc_field_relo(prog, relo, local_spec,\n\t\t\t\t\t       &res->orig_val, &res->orig_sz,\n\t\t\t\t\t       &res->orig_type_id, &res->validate);\n\t\terr = err ?: bpf_core_calc_field_relo(prog, relo, targ_spec,\n\t\t\t\t\t\t      &res->new_val, &res->new_sz,\n\t\t\t\t\t\t      &res->new_type_id, NULL);\n\t\tif (err)\n\t\t\tgoto done;\n\t\t/* Validate if it's safe to adjust load/store memory size.\n\t\t * Adjustments are performed only if original and new memory\n\t\t * sizes differ.\n\t\t */\n\t\tres->fail_memsz_adjust = false;\n\t\tif (res->orig_sz != res->new_sz) {\n\t\t\tconst struct btf_type *orig_t, *new_t;\n\n\t\t\torig_t = btf__type_by_id(local_spec->btf, res->orig_type_id);\n\t\t\tnew_t = btf__type_by_id(targ_spec->btf, res->new_type_id);\n\n\t\t\t/* There are two use cases in which it's safe to\n\t\t\t * adjust load/store's mem size:\n\t\t\t *   - reading a 32-bit kernel pointer, while on BPF\n\t\t\t *   size pointers are always 64-bit; in this case\n\t\t\t *   it's safe to \"downsize\" instruction size due to\n\t\t\t *   pointer being treated as unsigned integer with\n\t\t\t *   zero-extended upper 32-bits;\n\t\t\t *   - reading unsigned integers, again due to\n\t\t\t *   zero-extension is preserving the value correctly.\n\t\t\t *\n\t\t\t * In all other cases it's incorrect to attempt to\n\t\t\t * load/store field because read value will be\n\t\t\t * incorrect, so we poison relocated instruction.\n\t\t\t */\n\t\t\tif (btf_is_ptr(orig_t) && btf_is_ptr(new_t))\n\t\t\t\tgoto done;\n\t\t\tif (btf_is_int(orig_t) && btf_is_int(new_t) &&\n\t\t\t    btf_int_encoding(orig_t) != BTF_INT_SIGNED &&\n\t\t\t    btf_int_encoding(new_t) != BTF_INT_SIGNED)\n\t\t\t\tgoto done;\n\n\t\t\t/* mark as invalid mem size adjustment, but this will\n\t\t\t * only be checked for LDX/STX/ST insns\n\t\t\t */\n\t\t\tres->fail_memsz_adjust = true;\n\t\t}\n\t} else if (core_relo_is_type_based(relo->kind)) {\n\t\terr = bpf_core_calc_type_relo(relo, local_spec, &res->orig_val);\n\t\terr = err ?: bpf_core_calc_type_relo(relo, targ_spec, &res->new_val);\n\t} else if (core_relo_is_enumval_based(relo->kind)) {\n\t\terr = bpf_core_calc_enumval_relo(relo, local_spec, &res->orig_val);\n\t\terr = err ?: bpf_core_calc_enumval_relo(relo, targ_spec, &res->new_val);\n\t}\n\ndone:\n\tif (err == -EUCLEAN) {\n\t\t/* EUCLEAN is used to signal instruction poisoning request */\n\t\tres->poison = true;\n\t\terr = 0;\n\t} else if (err == -EOPNOTSUPP) {\n\t\t/* EOPNOTSUPP means unknown/unsupported relocation */\n\t\tpr_warn(\"prog '%s': relo #%d: unrecognized CO-RE relocation %s (%d) at insn #%d\\n\",\n\t\t\tprog->name, relo_idx, core_relo_kind_str(relo->kind),\n\t\t\trelo->kind, relo->insn_off / 8);\n\t}\n\n\treturn err;\n}\n\n/*\n * Turn instruction for which CO_RE relocation failed into invalid one with\n * distinct signature.\n */\nstatic void bpf_core_poison_insn(struct bpf_program *prog, int relo_idx,\n\t\t\t\t int insn_idx, struct bpf_insn *insn)\n{\n\tpr_debug(\"prog '%s': relo #%d: substituting insn #%d w/ invalid insn\\n\",\n\t\t prog->name, relo_idx, insn_idx);\n\tinsn->code = BPF_JMP | BPF_CALL;\n\tinsn->dst_reg = 0;\n\tinsn->src_reg = 0;\n\tinsn->off = 0;\n\t/* if this instruction is reachable (not a dead code),\n\t * verifier will complain with the following message:\n\t * invalid func unknown#195896080\n\t */\n\tinsn->imm = 195896080; /* => 0xbad2310 => \"bad relo\" */\n}\n\nstatic bool is_ldimm64(struct bpf_insn *insn)\n{\n\treturn insn->code == (BPF_LD | BPF_IMM | BPF_DW);\n}\n\nstatic int insn_bpf_size_to_bytes(struct bpf_insn *insn)\n{\n\tswitch (BPF_SIZE(insn->code)) {\n\tcase BPF_DW: return 8;\n\tcase BPF_W: return 4;\n\tcase BPF_H: return 2;\n\tcase BPF_B: return 1;\n\tdefault: return -1;\n\t}\n}\n\nstatic int insn_bytes_to_bpf_size(__u32 sz)\n{\n\tswitch (sz) {\n\tcase 8: return BPF_DW;\n\tcase 4: return BPF_W;\n\tcase 2: return BPF_H;\n\tcase 1: return BPF_B;\n\tdefault: return -1;\n\t}\n}\n\n/*\n * Patch relocatable BPF instruction.\n *\n * Patched value is determined by relocation kind and target specification.\n * For existence relocations target spec will be NULL if field/type is not found.\n * Expected insn->imm value is determined using relocation kind and local\n * spec, and is checked before patching instruction. If actual insn->imm value\n * is wrong, bail out with error.\n *\n * Currently supported classes of BPF instruction are:\n * 1. rX = <imm> (assignment with immediate operand);\n * 2. rX += <imm> (arithmetic operations with immediate operand);\n * 3. rX = <imm64> (load with 64-bit immediate value);\n * 4. rX = *(T *)(rY + <off>), where T is one of {u8, u16, u32, u64};\n * 5. *(T *)(rX + <off>) = rY, where T is one of {u8, u16, u32, u64};\n * 6. *(T *)(rX + <off>) = <imm>, where T is one of {u8, u16, u32, u64}.\n */\nstatic int bpf_core_patch_insn(struct bpf_program *prog,\n\t\t\t       const struct bpf_core_relo *relo,\n\t\t\t       int relo_idx,\n\t\t\t       const struct bpf_core_relo_res *res)\n{\n\t__u32 orig_val, new_val;\n\tstruct bpf_insn *insn;\n\tint insn_idx;\n\t__u8 class;\n\n\tif (relo->insn_off % BPF_INSN_SZ)\n\t\treturn -EINVAL;\n\tinsn_idx = relo->insn_off / BPF_INSN_SZ;\n\t/* adjust insn_idx from section frame of reference to the local\n\t * program's frame of reference; (sub-)program code is not yet\n\t * relocated, so it's enough to just subtract in-section offset\n\t */\n\tinsn_idx = insn_idx - prog->sec_insn_off;\n\tinsn = &prog->insns[insn_idx];\n\tclass = BPF_CLASS(insn->code);\n\n\tif (res->poison) {\npoison:\n\t\t/* poison second part of ldimm64 to avoid confusing error from\n\t\t * verifier about \"unknown opcode 00\"\n\t\t */\n\t\tif (is_ldimm64(insn))\n\t\t\tbpf_core_poison_insn(prog, relo_idx, insn_idx + 1, insn + 1);\n\t\tbpf_core_poison_insn(prog, relo_idx, insn_idx, insn);\n\t\treturn 0;\n\t}\n\n\torig_val = res->orig_val;\n\tnew_val = res->new_val;\n\n\tswitch (class) {\n\tcase BPF_ALU:\n\tcase BPF_ALU64:\n\t\tif (BPF_SRC(insn->code) != BPF_K)\n\t\t\treturn -EINVAL;\n\t\tif (res->validate && insn->imm != orig_val) {\n\t\t\tpr_warn(\"prog '%s': relo #%d: unexpected insn #%d (ALU/ALU64) value: got %u, exp %u -> %u\\n\",\n\t\t\t\tprog->name, relo_idx,\n\t\t\t\tinsn_idx, insn->imm, orig_val, new_val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\torig_val = insn->imm;\n\t\tinsn->imm = new_val;\n\t\tpr_debug(\"prog '%s': relo #%d: patched insn #%d (ALU/ALU64) imm %u -> %u\\n\",\n\t\t\t prog->name, relo_idx, insn_idx,\n\t\t\t orig_val, new_val);\n\t\tbreak;\n\tcase BPF_LDX:\n\tcase BPF_ST:\n\tcase BPF_STX:\n\t\tif (res->validate && insn->off != orig_val) {\n\t\t\tpr_warn(\"prog '%s': relo #%d: unexpected insn #%d (LDX/ST/STX) value: got %u, exp %u -> %u\\n\",\n\t\t\t\tprog->name, relo_idx, insn_idx, insn->off, orig_val, new_val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (new_val > SHRT_MAX) {\n\t\t\tpr_warn(\"prog '%s': relo #%d: insn #%d (LDX/ST/STX) value too big: %u\\n\",\n\t\t\t\tprog->name, relo_idx, insn_idx, new_val);\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tif (res->fail_memsz_adjust) {\n\t\t\tpr_warn(\"prog '%s': relo #%d: insn #%d (LDX/ST/STX) accesses field incorrectly. \"\n\t\t\t\t\"Make sure you are accessing pointers, unsigned integers, or fields of matching type and size.\\n\",\n\t\t\t\tprog->name, relo_idx, insn_idx);\n\t\t\tgoto poison;\n\t\t}\n\n\t\torig_val = insn->off;\n\t\tinsn->off = new_val;\n\t\tpr_debug(\"prog '%s': relo #%d: patched insn #%d (LDX/ST/STX) off %u -> %u\\n\",\n\t\t\t prog->name, relo_idx, insn_idx, orig_val, new_val);\n\n\t\tif (res->new_sz != res->orig_sz) {\n\t\t\tint insn_bytes_sz, insn_bpf_sz;\n\n\t\t\tinsn_bytes_sz = insn_bpf_size_to_bytes(insn);\n\t\t\tif (insn_bytes_sz != res->orig_sz) {\n\t\t\t\tpr_warn(\"prog '%s': relo #%d: insn #%d (LDX/ST/STX) unexpected mem size: got %d, exp %u\\n\",\n\t\t\t\t\tprog->name, relo_idx, insn_idx, insn_bytes_sz, res->orig_sz);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tinsn_bpf_sz = insn_bytes_to_bpf_size(res->new_sz);\n\t\t\tif (insn_bpf_sz < 0) {\n\t\t\t\tpr_warn(\"prog '%s': relo #%d: insn #%d (LDX/ST/STX) invalid new mem size: %u\\n\",\n\t\t\t\t\tprog->name, relo_idx, insn_idx, res->new_sz);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tinsn->code = BPF_MODE(insn->code) | insn_bpf_sz | BPF_CLASS(insn->code);\n\t\t\tpr_debug(\"prog '%s': relo #%d: patched insn #%d (LDX/ST/STX) mem_sz %u -> %u\\n\",\n\t\t\t\t prog->name, relo_idx, insn_idx, res->orig_sz, res->new_sz);\n\t\t}\n\t\tbreak;\n\tcase BPF_LD: {\n\t\t__u64 imm;\n\n\t\tif (!is_ldimm64(insn) ||\n\t\t    insn[0].src_reg != 0 || insn[0].off != 0 ||\n\t\t    insn_idx + 1 >= prog->insns_cnt ||\n\t\t    insn[1].code != 0 || insn[1].dst_reg != 0 ||\n\t\t    insn[1].src_reg != 0 || insn[1].off != 0) {\n\t\t\tpr_warn(\"prog '%s': relo #%d: insn #%d (LDIMM64) has unexpected form\\n\",\n\t\t\t\tprog->name, relo_idx, insn_idx);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\timm = insn[0].imm + ((__u64)insn[1].imm << 32);\n\t\tif (res->validate && imm != orig_val) {\n\t\t\tpr_warn(\"prog '%s': relo #%d: unexpected insn #%d (LDIMM64) value: got %llu, exp %u -> %u\\n\",\n\t\t\t\tprog->name, relo_idx,\n\t\t\t\tinsn_idx, (unsigned long long)imm,\n\t\t\t\torig_val, new_val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinsn[0].imm = new_val;\n\t\tinsn[1].imm = 0; /* currently only 32-bit values are supported */\n\t\tpr_debug(\"prog '%s': relo #%d: patched insn #%d (LDIMM64) imm64 %llu -> %u\\n\",\n\t\t\t prog->name, relo_idx, insn_idx,\n\t\t\t (unsigned long long)imm, new_val);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpr_warn(\"prog '%s': relo #%d: trying to relocate unrecognized insn #%d, code:0x%x, src:0x%x, dst:0x%x, off:0x%x, imm:0x%x\\n\",\n\t\t\tprog->name, relo_idx, insn_idx, insn->code,\n\t\t\tinsn->src_reg, insn->dst_reg, insn->off, insn->imm);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* Output spec definition in the format:\n * [<type-id>] (<type-name>) + <raw-spec> => <offset>@<spec>,\n * where <spec> is a C-syntax view of recorded field access, e.g.: x.a[3].b\n */\nstatic void bpf_core_dump_spec(int level, const struct bpf_core_spec *spec)\n{\n\tconst struct btf_type *t;\n\tconst struct btf_enum *e;\n\tconst char *s;\n\t__u32 type_id;\n\tint i;\n\n\ttype_id = spec->root_type_id;\n\tt = btf__type_by_id(spec->btf, type_id);\n\ts = btf__name_by_offset(spec->btf, t->name_off);\n\n\tlibbpf_print(level, \"[%u] %s %s\", type_id, btf_kind_str(t), str_is_empty(s) ? \"<anon>\" : s);\n\n\tif (core_relo_is_type_based(spec->relo_kind))\n\t\treturn;\n\n\tif (core_relo_is_enumval_based(spec->relo_kind)) {\n\t\tt = skip_mods_and_typedefs(spec->btf, type_id, NULL);\n\t\te = btf_enum(t) + spec->raw_spec[0];\n\t\ts = btf__name_by_offset(spec->btf, e->name_off);\n\n\t\tlibbpf_print(level, \"::%s = %u\", s, e->val);\n\t\treturn;\n\t}\n\n\tif (core_relo_is_field_based(spec->relo_kind)) {\n\t\tfor (i = 0; i < spec->len; i++) {\n\t\t\tif (spec->spec[i].name)\n\t\t\t\tlibbpf_print(level, \".%s\", spec->spec[i].name);\n\t\t\telse if (i > 0 || spec->spec[i].idx > 0)\n\t\t\t\tlibbpf_print(level, \"[%u]\", spec->spec[i].idx);\n\t\t}\n\n\t\tlibbpf_print(level, \" (\");\n\t\tfor (i = 0; i < spec->raw_len; i++)\n\t\t\tlibbpf_print(level, \"%s%d\", i == 0 ? \"\" : \":\", spec->raw_spec[i]);\n\n\t\tif (spec->bit_offset % 8)\n\t\t\tlibbpf_print(level, \" @ offset %u.%u)\",\n\t\t\t\t     spec->bit_offset / 8, spec->bit_offset % 8);\n\t\telse\n\t\t\tlibbpf_print(level, \" @ offset %u)\", spec->bit_offset / 8);\n\t\treturn;\n\t}\n}\n\nstatic size_t bpf_core_hash_fn(const void *key, void *ctx)\n{\n\treturn (size_t)key;\n}\n\nstatic bool bpf_core_equal_fn(const void *k1, const void *k2, void *ctx)\n{\n\treturn k1 == k2;\n}\n\nstatic void *u32_as_hash_key(__u32 x)\n{\n\treturn (void *)(uintptr_t)x;\n}\n\n/*\n * CO-RE relocate single instruction.\n *\n * The outline and important points of the algorithm:\n * 1. For given local type, find corresponding candidate target types.\n *    Candidate type is a type with the same \"essential\" name, ignoring\n *    everything after last triple underscore (___). E.g., `sample`,\n *    `sample___flavor_one`, `sample___flavor_another_one`, are all candidates\n *    for each other. Names with triple underscore are referred to as\n *    \"flavors\" and are useful, among other things, to allow to\n *    specify/support incompatible variations of the same kernel struct, which\n *    might differ between different kernel versions and/or build\n *    configurations.\n *\n *    N.B. Struct \"flavors\" could be generated by bpftool's BTF-to-C\n *    converter, when deduplicated BTF of a kernel still contains more than\n *    one different types with the same name. In that case, ___2, ___3, etc\n *    are appended starting from second name conflict. But start flavors are\n *    also useful to be defined \"locally\", in BPF program, to extract same\n *    data from incompatible changes between different kernel\n *    versions/configurations. For instance, to handle field renames between\n *    kernel versions, one can use two flavors of the struct name with the\n *    same common name and use conditional relocations to extract that field,\n *    depending on target kernel version.\n * 2. For each candidate type, try to match local specification to this\n *    candidate target type. Matching involves finding corresponding\n *    high-level spec accessors, meaning that all named fields should match,\n *    as well as all array accesses should be within the actual bounds. Also,\n *    types should be compatible (see bpf_core_fields_are_compat for details).\n * 3. It is supported and expected that there might be multiple flavors\n *    matching the spec. As long as all the specs resolve to the same set of\n *    offsets across all candidates, there is no error. If there is any\n *    ambiguity, CO-RE relocation will fail. This is necessary to accomodate\n *    imprefection of BTF deduplication, which can cause slight duplication of\n *    the same BTF type, if some directly or indirectly referenced (by\n *    pointer) type gets resolved to different actual types in different\n *    object files. If such situation occurs, deduplicated BTF will end up\n *    with two (or more) structurally identical types, which differ only in\n *    types they refer to through pointer. This should be OK in most cases and\n *    is not an error.\n * 4. Candidate types search is performed by linearly scanning through all\n *    types in target BTF. It is anticipated that this is overall more\n *    efficient memory-wise and not significantly worse (if not better)\n *    CPU-wise compared to prebuilding a map from all local type names to\n *    a list of candidate type names. It's also sped up by caching resolved\n *    list of matching candidates per each local \"root\" type ID, that has at\n *    least one bpf_core_relo associated with it. This list is shared\n *    between multiple relocations for the same type ID and is updated as some\n *    of the candidates are pruned due to structural incompatibility.\n */\nstatic int bpf_core_apply_relo(struct bpf_program *prog,\n\t\t\t       const struct bpf_core_relo *relo,\n\t\t\t       int relo_idx,\n\t\t\t       const struct btf *local_btf,\n\t\t\t       const struct btf *targ_btf,\n\t\t\t       struct hashmap *cand_cache)\n{\n\tstruct bpf_core_spec local_spec, cand_spec, targ_spec = {};\n\tconst void *type_key = u32_as_hash_key(relo->type_id);\n\tstruct bpf_core_relo_res cand_res, targ_res;\n\tconst struct btf_type *local_type;\n\tconst char *local_name;\n\tstruct ids_vec *cand_ids;\n\t__u32 local_id, cand_id;\n\tconst char *spec_str;\n\tint i, j, err;\n\n\tlocal_id = relo->type_id;\n\tlocal_type = btf__type_by_id(local_btf, local_id);\n\tif (!local_type)\n\t\treturn -EINVAL;\n\n\tlocal_name = btf__name_by_offset(local_btf, local_type->name_off);\n\tif (!local_name)\n\t\treturn -EINVAL;\n\n\tspec_str = btf__name_by_offset(local_btf, relo->access_str_off);\n\tif (str_is_empty(spec_str))\n\t\treturn -EINVAL;\n\n\terr = bpf_core_parse_spec(local_btf, local_id, spec_str, relo->kind, &local_spec);\n\tif (err) {\n\t\tpr_warn(\"prog '%s': relo #%d: parsing [%d] %s %s + %s failed: %d\\n\",\n\t\t\tprog->name, relo_idx, local_id, btf_kind_str(local_type),\n\t\t\tstr_is_empty(local_name) ? \"<anon>\" : local_name,\n\t\t\tspec_str, err);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"prog '%s': relo #%d: kind <%s> (%d), spec is \", prog->name,\n\t\t relo_idx, core_relo_kind_str(relo->kind), relo->kind);\n\tbpf_core_dump_spec(LIBBPF_DEBUG, &local_spec);\n\tlibbpf_print(LIBBPF_DEBUG, \"\\n\");\n\n\t/* TYPE_ID_LOCAL relo is special and doesn't need candidate search */\n\tif (relo->kind == BPF_TYPE_ID_LOCAL) {\n\t\ttarg_res.validate = true;\n\t\ttarg_res.poison = false;\n\t\ttarg_res.orig_val = local_spec.root_type_id;\n\t\ttarg_res.new_val = local_spec.root_type_id;\n\t\tgoto patch_insn;\n\t}\n\n\t/* libbpf doesn't support candidate search for anonymous types */\n\tif (str_is_empty(spec_str)) {\n\t\tpr_warn(\"prog '%s': relo #%d: <%s> (%d) relocation doesn't support anonymous types\\n\",\n\t\t\tprog->name, relo_idx, core_relo_kind_str(relo->kind), relo->kind);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!hashmap__find(cand_cache, type_key, (void **)&cand_ids)) {\n\t\tcand_ids = bpf_core_find_cands(local_btf, local_id, targ_btf);\n\t\tif (IS_ERR(cand_ids)) {\n\t\t\tpr_warn(\"prog '%s': relo #%d: target candidate search failed for [%d] %s %s: %ld\",\n\t\t\t\tprog->name, relo_idx, local_id, btf_kind_str(local_type),\n\t\t\t\tlocal_name, PTR_ERR(cand_ids));\n\t\t\treturn PTR_ERR(cand_ids);\n\t\t}\n\t\terr = hashmap__set(cand_cache, type_key, cand_ids, NULL, NULL);\n\t\tif (err) {\n\t\t\tbpf_core_free_cands(cand_ids);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tfor (i = 0, j = 0; i < cand_ids->len; i++) {\n\t\tcand_id = cand_ids->data[i];\n\t\terr = bpf_core_spec_match(&local_spec, targ_btf, cand_id, &cand_spec);\n\t\tif (err < 0) {\n\t\t\tpr_warn(\"prog '%s': relo #%d: error matching candidate #%d \",\n\t\t\t\tprog->name, relo_idx, i);\n\t\t\tbpf_core_dump_spec(LIBBPF_WARN, &cand_spec);\n\t\t\tlibbpf_print(LIBBPF_WARN, \": %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\tpr_debug(\"prog '%s': relo #%d: %s candidate #%d \", prog->name,\n\t\t\t relo_idx, err == 0 ? \"non-matching\" : \"matching\", i);\n\t\tbpf_core_dump_spec(LIBBPF_DEBUG, &cand_spec);\n\t\tlibbpf_print(LIBBPF_DEBUG, \"\\n\");\n\n\t\tif (err == 0)\n\t\t\tcontinue;\n\n\t\terr = bpf_core_calc_relo(prog, relo, relo_idx, &local_spec, &cand_spec, &cand_res);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (j == 0) {\n\t\t\ttarg_res = cand_res;\n\t\t\ttarg_spec = cand_spec;\n\t\t} else if (cand_spec.bit_offset != targ_spec.bit_offset) {\n\t\t\t/* if there are many field relo candidates, they\n\t\t\t * should all resolve to the same bit offset\n\t\t\t */\n\t\t\tpr_warn(\"prog '%s': relo #%d: field offset ambiguity: %u != %u\\n\",\n\t\t\t\tprog->name, relo_idx, cand_spec.bit_offset,\n\t\t\t\ttarg_spec.bit_offset);\n\t\t\treturn -EINVAL;\n\t\t} else if (cand_res.poison != targ_res.poison || cand_res.new_val != targ_res.new_val) {\n\t\t\t/* all candidates should result in the same relocation\n\t\t\t * decision and value, otherwise it's dangerous to\n\t\t\t * proceed due to ambiguity\n\t\t\t */\n\t\t\tpr_warn(\"prog '%s': relo #%d: relocation decision ambiguity: %s %u != %s %u\\n\",\n\t\t\t\tprog->name, relo_idx,\n\t\t\t\tcand_res.poison ? \"failure\" : \"success\", cand_res.new_val,\n\t\t\t\ttarg_res.poison ? \"failure\" : \"success\", targ_res.new_val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcand_ids->data[j++] = cand_spec.root_type_id;\n\t}\n\n\t/*\n\t * For BPF_FIELD_EXISTS relo or when used BPF program has field\n\t * existence checks or kernel version/config checks, it's expected\n\t * that we might not find any candidates. In this case, if field\n\t * wasn't found in any candidate, the list of candidates shouldn't\n\t * change at all, we'll just handle relocating appropriately,\n\t * depending on relo's kind.\n\t */\n\tif (j > 0)\n\t\tcand_ids->len = j;\n\n\t/*\n\t * If no candidates were found, it might be both a programmer error,\n\t * as well as expected case, depending whether instruction w/\n\t * relocation is guarded in some way that makes it unreachable (dead\n\t * code) if relocation can't be resolved. This is handled in\n\t * bpf_core_patch_insn() uniformly by replacing that instruction with\n\t * BPF helper call insn (using invalid helper ID). If that instruction\n\t * is indeed unreachable, then it will be ignored and eliminated by\n\t * verifier. If it was an error, then verifier will complain and point\n\t * to a specific instruction number in its log.\n\t */\n\tif (j == 0) {\n\t\tpr_debug(\"prog '%s': relo #%d: no matching targets found\\n\",\n\t\t\t prog->name, relo_idx);\n\n\t\t/* calculate single target relo result explicitly */\n\t\terr = bpf_core_calc_relo(prog, relo, relo_idx, &local_spec, NULL, &targ_res);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\npatch_insn:\n\t/* bpf_core_patch_insn() should know how to handle missing targ_spec */\n\terr = bpf_core_patch_insn(prog, relo, relo_idx, &targ_res);\n\tif (err) {\n\t\tpr_warn(\"prog '%s': relo #%d: failed to patch insn at offset %d: %d\\n\",\n\t\t\tprog->name, relo_idx, relo->insn_off, err);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbpf_object__relocate_core(struct bpf_object *obj, const char *targ_btf_path)\n{\n\tconst struct btf_ext_info_sec *sec;\n\tconst struct bpf_core_relo *rec;\n\tconst struct btf_ext_info *seg;\n\tstruct hashmap_entry *entry;\n\tstruct hashmap *cand_cache = NULL;\n\tstruct bpf_program *prog;\n\tstruct btf *targ_btf;\n\tconst char *sec_name;\n\tint i, err = 0, insn_idx, sec_idx;\n\n\tif (obj->btf_ext->core_relo_info.len == 0)\n\t\treturn 0;\n\n\tif (targ_btf_path)\n\t\ttarg_btf = btf__parse(targ_btf_path, NULL);\n\telse\n\t\ttarg_btf = obj->btf_vmlinux;\n\tif (IS_ERR_OR_NULL(targ_btf)) {\n\t\tpr_warn(\"failed to get target BTF: %ld\\n\", PTR_ERR(targ_btf));\n\t\treturn PTR_ERR(targ_btf);\n\t}\n\n\tcand_cache = hashmap__new(bpf_core_hash_fn, bpf_core_equal_fn, NULL);\n\tif (IS_ERR(cand_cache)) {\n\t\terr = PTR_ERR(cand_cache);\n\t\tgoto out;\n\t}\n\n\tseg = &obj->btf_ext->core_relo_info;\n\tfor_each_btf_ext_sec(seg, sec) {\n\t\tsec_name = btf__name_by_offset(obj->btf, sec->sec_name_off);\n\t\tif (str_is_empty(sec_name)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\t/* bpf_object's ELF is gone by now so it's not easy to find\n\t\t * section index by section name, but we can find *any*\n\t\t * bpf_program within desired section name and use it's\n\t\t * prog->sec_idx to do a proper search by section index and\n\t\t * instruction offset\n\t\t */\n\t\tprog = NULL;\n\t\tfor (i = 0; i < obj->nr_programs; i++) {\n\t\t\tprog = &obj->programs[i];\n\t\t\tif (strcmp(prog->sec_name, sec_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!prog) {\n\t\t\tpr_warn(\"sec '%s': failed to find a BPF program\\n\", sec_name);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tsec_idx = prog->sec_idx;\n\n\t\tpr_debug(\"sec '%s': found %d CO-RE relocations\\n\",\n\t\t\t sec_name, sec->num_info);\n\n\t\tfor_each_btf_ext_rec(seg, sec, i, rec) {\n\t\t\tinsn_idx = rec->insn_off / BPF_INSN_SZ;\n\t\t\tprog = find_prog_by_sec_insn(obj, sec_idx, insn_idx);\n\t\t\tif (!prog) {\n\t\t\t\tpr_warn(\"sec '%s': failed to find program at insn #%d for CO-RE offset relocation #%d\\n\",\n\t\t\t\t\tsec_name, insn_idx, i);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* no need to apply CO-RE relocation if the program is\n\t\t\t * not going to be loaded\n\t\t\t */\n\t\t\tif (!prog->load)\n\t\t\t\tcontinue;\n\n\t\t\terr = bpf_core_apply_relo(prog, rec, i, obj->btf,\n\t\t\t\t\t\t  targ_btf, cand_cache);\n\t\t\tif (err) {\n\t\t\t\tpr_warn(\"prog '%s': relo #%d: failed to relocate: %d\\n\",\n\t\t\t\t\tprog->name, i, err);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\t/* obj->btf_vmlinux is freed at the end of object load phase */\n\tif (targ_btf != obj->btf_vmlinux)\n\t\tbtf__free(targ_btf);\n\tif (!IS_ERR_OR_NULL(cand_cache)) {\n\t\thashmap__for_each_entry(cand_cache, entry, i) {\n\t\t\tbpf_core_free_cands(entry->value);\n\t\t}\n\t\thashmap__free(cand_cache);\n\t}\n\treturn err;\n}\n\n/* Relocate data references within program code:\n *  - map references;\n *  - global variable references;\n *  - extern references.\n */\nstatic int\nbpf_object__relocate_data(struct bpf_object *obj, struct bpf_program *prog)\n{\n\tint i;\n\n\tfor (i = 0; i < prog->nr_reloc; i++) {\n\t\tstruct reloc_desc *relo = &prog->reloc_desc[i];\n\t\tstruct bpf_insn *insn = &prog->insns[relo->insn_idx];\n\t\tstruct extern_desc *ext;\n\n\t\tswitch (relo->type) {\n\t\tcase RELO_LD64:\n\t\t\tinsn[0].src_reg = BPF_PSEUDO_MAP_FD;\n\t\t\tinsn[0].imm = obj->maps[relo->map_idx].fd;\n\t\t\trelo->processed = true;\n\t\t\tbreak;\n\t\tcase RELO_DATA:\n\t\t\tinsn[0].src_reg = BPF_PSEUDO_MAP_VALUE;\n\t\t\tinsn[1].imm = insn[0].imm + relo->sym_off;\n\t\t\tinsn[0].imm = obj->maps[relo->map_idx].fd;\n\t\t\trelo->processed = true;\n\t\t\tbreak;\n\t\tcase RELO_EXTERN:\n\t\t\text = &obj->externs[relo->sym_off];\n\t\t\tif (ext->type == EXT_KCFG) {\n\t\t\t\tinsn[0].src_reg = BPF_PSEUDO_MAP_VALUE;\n\t\t\t\tinsn[0].imm = obj->maps[obj->kconfig_map_idx].fd;\n\t\t\t\tinsn[1].imm = ext->kcfg.data_off;\n\t\t\t} else /* EXT_KSYM */ {\n\t\t\t\tif (ext->ksym.type_id) { /* typed ksyms */\n\t\t\t\t\tinsn[0].src_reg = BPF_PSEUDO_BTF_ID;\n\t\t\t\t\tinsn[0].imm = ext->ksym.vmlinux_btf_id;\n\t\t\t\t} else { /* typeless ksyms */\n\t\t\t\t\tinsn[0].imm = (__u32)ext->ksym.addr;\n\t\t\t\t\tinsn[1].imm = ext->ksym.addr >> 32;\n\t\t\t\t}\n\t\t\t}\n\t\t\trelo->processed = true;\n\t\t\tbreak;\n\t\tcase RELO_CALL:\n\t\t\t/* will be handled as a follow up pass */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"prog '%s': relo #%d: bad relo type %d\\n\",\n\t\t\t\tprog->name, i, relo->type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int adjust_prog_btf_ext_info(const struct bpf_object *obj,\n\t\t\t\t    const struct bpf_program *prog,\n\t\t\t\t    const struct btf_ext_info *ext_info,\n\t\t\t\t    void **prog_info, __u32 *prog_rec_cnt,\n\t\t\t\t    __u32 *prog_rec_sz)\n{\n\tvoid *copy_start = NULL, *copy_end = NULL;\n\tvoid *rec, *rec_end, *new_prog_info;\n\tconst struct btf_ext_info_sec *sec;\n\tsize_t old_sz, new_sz;\n\tconst char *sec_name;\n\tint i, off_adj;\n\n\tfor_each_btf_ext_sec(ext_info, sec) {\n\t\tsec_name = btf__name_by_offset(obj->btf, sec->sec_name_off);\n\t\tif (!sec_name)\n\t\t\treturn -EINVAL;\n\t\tif (strcmp(sec_name, prog->sec_name) != 0)\n\t\t\tcontinue;\n\n\t\tfor_each_btf_ext_rec(ext_info, sec, i, rec) {\n\t\t\t__u32 insn_off = *(__u32 *)rec / BPF_INSN_SZ;\n\n\t\t\tif (insn_off < prog->sec_insn_off)\n\t\t\t\tcontinue;\n\t\t\tif (insn_off >= prog->sec_insn_off + prog->sec_insn_cnt)\n\t\t\t\tbreak;\n\n\t\t\tif (!copy_start)\n\t\t\t\tcopy_start = rec;\n\t\t\tcopy_end = rec + ext_info->rec_size;\n\t\t}\n\n\t\tif (!copy_start)\n\t\t\treturn -ENOENT;\n\n\t\t/* append func/line info of a given (sub-)program to the main\n\t\t * program func/line info\n\t\t */\n\t\told_sz = (size_t)(*prog_rec_cnt) * ext_info->rec_size;\n\t\tnew_sz = old_sz + (copy_end - copy_start);\n\t\tnew_prog_info = realloc(*prog_info, new_sz);\n\t\tif (!new_prog_info)\n\t\t\treturn -ENOMEM;\n\t\t*prog_info = new_prog_info;\n\t\t*prog_rec_cnt = new_sz / ext_info->rec_size;\n\t\tmemcpy(new_prog_info + old_sz, copy_start, copy_end - copy_start);\n\n\t\t/* Kernel instruction offsets are in units of 8-byte\n\t\t * instructions, while .BTF.ext instruction offsets generated\n\t\t * by Clang are in units of bytes. So convert Clang offsets\n\t\t * into kernel offsets and adjust offset according to program\n\t\t * relocated position.\n\t\t */\n\t\toff_adj = prog->sub_insn_off - prog->sec_insn_off;\n\t\trec = new_prog_info + old_sz;\n\t\trec_end = new_prog_info + new_sz;\n\t\tfor (; rec < rec_end; rec += ext_info->rec_size) {\n\t\t\t__u32 *insn_off = rec;\n\n\t\t\t*insn_off = *insn_off / BPF_INSN_SZ + off_adj;\n\t\t}\n\t\t*prog_rec_sz = ext_info->rec_size;\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int\nreloc_prog_func_and_line_info(const struct bpf_object *obj,\n\t\t\t      struct bpf_program *main_prog,\n\t\t\t      const struct bpf_program *prog)\n{\n\tint err;\n\n\t/* no .BTF.ext relocation if .BTF.ext is missing or kernel doesn't\n\t * supprot func/line info\n\t */\n\tif (!obj->btf_ext || !kernel_supports(FEAT_BTF_FUNC))\n\t\treturn 0;\n\n\t/* only attempt func info relocation if main program's func_info\n\t * relocation was successful\n\t */\n\tif (main_prog != prog && !main_prog->func_info)\n\t\tgoto line_info;\n\n\terr = adjust_prog_btf_ext_info(obj, prog, &obj->btf_ext->func_info,\n\t\t\t\t       &main_prog->func_info,\n\t\t\t\t       &main_prog->func_info_cnt,\n\t\t\t\t       &main_prog->func_info_rec_size);\n\tif (err) {\n\t\tif (err != -ENOENT) {\n\t\t\tpr_warn(\"prog '%s': error relocating .BTF.ext function info: %d\\n\",\n\t\t\t\tprog->name, err);\n\t\t\treturn err;\n\t\t}\n\t\tif (main_prog->func_info) {\n\t\t\t/*\n\t\t\t * Some info has already been found but has problem\n\t\t\t * in the last btf_ext reloc. Must have to error out.\n\t\t\t */\n\t\t\tpr_warn(\"prog '%s': missing .BTF.ext function info.\\n\", prog->name);\n\t\t\treturn err;\n\t\t}\n\t\t/* Have problem loading the very first info. Ignore the rest. */\n\t\tpr_warn(\"prog '%s': missing .BTF.ext function info for the main program, skipping all of .BTF.ext func info.\\n\",\n\t\t\tprog->name);\n\t}\n\nline_info:\n\t/* don't relocate line info if main program's relocation failed */\n\tif (main_prog != prog && !main_prog->line_info)\n\t\treturn 0;\n\n\terr = adjust_prog_btf_ext_info(obj, prog, &obj->btf_ext->line_info,\n\t\t\t\t       &main_prog->line_info,\n\t\t\t\t       &main_prog->line_info_cnt,\n\t\t\t\t       &main_prog->line_info_rec_size);\n\tif (err) {\n\t\tif (err != -ENOENT) {\n\t\t\tpr_warn(\"prog '%s': error relocating .BTF.ext line info: %d\\n\",\n\t\t\t\tprog->name, err);\n\t\t\treturn err;\n\t\t}\n\t\tif (main_prog->line_info) {\n\t\t\t/*\n\t\t\t * Some info has already been found but has problem\n\t\t\t * in the last btf_ext reloc. Must have to error out.\n\t\t\t */\n\t\t\tpr_warn(\"prog '%s': missing .BTF.ext line info.\\n\", prog->name);\n\t\t\treturn err;\n\t\t}\n\t\t/* Have problem loading the very first info. Ignore the rest. */\n\t\tpr_warn(\"prog '%s': missing .BTF.ext line info for the main program, skipping all of .BTF.ext line info.\\n\",\n\t\t\tprog->name);\n\t}\n\treturn 0;\n}\n\nstatic int cmp_relo_by_insn_idx(const void *key, const void *elem)\n{\n\tsize_t insn_idx = *(const size_t *)key;\n\tconst struct reloc_desc *relo = elem;\n\n\tif (insn_idx == relo->insn_idx)\n\t\treturn 0;\n\treturn insn_idx < relo->insn_idx ? -1 : 1;\n}\n\nstatic struct reloc_desc *find_prog_insn_relo(const struct bpf_program *prog, size_t insn_idx)\n{\n\treturn bsearch(&insn_idx, prog->reloc_desc, prog->nr_reloc,\n\t\t       sizeof(*prog->reloc_desc), cmp_relo_by_insn_idx);\n}\n\nstatic int\nbpf_object__reloc_code(struct bpf_object *obj, struct bpf_program *main_prog,\n\t\t       struct bpf_program *prog)\n{\n\tsize_t sub_insn_idx, insn_idx, new_cnt;\n\tstruct bpf_program *subprog;\n\tstruct bpf_insn *insns, *insn;\n\tstruct reloc_desc *relo;\n\tint err;\n\n\terr = reloc_prog_func_and_line_info(obj, main_prog, prog);\n\tif (err)\n\t\treturn err;\n\n\tfor (insn_idx = 0; insn_idx < prog->sec_insn_cnt; insn_idx++) {\n\t\tinsn = &main_prog->insns[prog->sub_insn_off + insn_idx];\n\t\tif (!insn_is_subprog_call(insn))\n\t\t\tcontinue;\n\n\t\trelo = find_prog_insn_relo(prog, insn_idx);\n\t\tif (relo && relo->type != RELO_CALL) {\n\t\t\tpr_warn(\"prog '%s': unexpected relo for insn #%zu, type %d\\n\",\n\t\t\t\tprog->name, insn_idx, relo->type);\n\t\t\treturn -LIBBPF_ERRNO__RELOC;\n\t\t}\n\t\tif (relo) {\n\t\t\t/* sub-program instruction index is a combination of\n\t\t\t * an offset of a symbol pointed to by relocation and\n\t\t\t * call instruction's imm field; for global functions,\n\t\t\t * call always has imm = -1, but for static functions\n\t\t\t * relocation is against STT_SECTION and insn->imm\n\t\t\t * points to a start of a static function\n\t\t\t */\n\t\t\tsub_insn_idx = relo->sym_off / BPF_INSN_SZ + insn->imm + 1;\n\t\t} else {\n\t\t\t/* if subprogram call is to a static function within\n\t\t\t * the same ELF section, there won't be any relocation\n\t\t\t * emitted, but it also means there is no additional\n\t\t\t * offset necessary, insns->imm is relative to\n\t\t\t * instruction's original position within the section\n\t\t\t */\n\t\t\tsub_insn_idx = prog->sec_insn_off + insn_idx + insn->imm + 1;\n\t\t}\n\n\t\t/* we enforce that sub-programs should be in .text section */\n\t\tsubprog = find_prog_by_sec_insn(obj, obj->efile.text_shndx, sub_insn_idx);\n\t\tif (!subprog) {\n\t\t\tpr_warn(\"prog '%s': no .text section found yet sub-program call exists\\n\",\n\t\t\t\tprog->name);\n\t\t\treturn -LIBBPF_ERRNO__RELOC;\n\t\t}\n\n\t\t/* if it's the first call instruction calling into this\n\t\t * subprogram (meaning this subprog hasn't been processed\n\t\t * yet) within the context of current main program:\n\t\t *   - append it at the end of main program's instructions blog;\n\t\t *   - process is recursively, while current program is put on hold;\n\t\t *   - if that subprogram calls some other not yet processes\n\t\t *   subprogram, same thing will happen recursively until\n\t\t *   there are no more unprocesses subprograms left to append\n\t\t *   and relocate.\n\t\t */\n\t\tif (subprog->sub_insn_off == 0) {\n\t\t\tsubprog->sub_insn_off = main_prog->insns_cnt;\n\n\t\t\tnew_cnt = main_prog->insns_cnt + subprog->insns_cnt;\n\t\t\tinsns = libbpf_reallocarray(main_prog->insns, new_cnt, sizeof(*insns));\n\t\t\tif (!insns) {\n\t\t\t\tpr_warn(\"prog '%s': failed to realloc prog code\\n\", main_prog->name);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmain_prog->insns = insns;\n\t\t\tmain_prog->insns_cnt = new_cnt;\n\n\t\t\tmemcpy(main_prog->insns + subprog->sub_insn_off, subprog->insns,\n\t\t\t       subprog->insns_cnt * sizeof(*insns));\n\n\t\t\tpr_debug(\"prog '%s': added %zu insns from sub-prog '%s'\\n\",\n\t\t\t\t main_prog->name, subprog->insns_cnt, subprog->name);\n\n\t\t\terr = bpf_object__reloc_code(obj, main_prog, subprog);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t/* main_prog->insns memory could have been re-allocated, so\n\t\t * calculate pointer again\n\t\t */\n\t\tinsn = &main_prog->insns[prog->sub_insn_off + insn_idx];\n\t\t/* calculate correct instruction position within current main\n\t\t * prog; each main prog can have a different set of\n\t\t * subprograms appended (potentially in different order as\n\t\t * well), so position of any subprog can be different for\n\t\t * different main programs */\n\t\tinsn->imm = subprog->sub_insn_off - (prog->sub_insn_off + insn_idx) - 1;\n\n\t\tif (relo)\n\t\t\trelo->processed = true;\n\n\t\tpr_debug(\"prog '%s': insn #%zu relocated, imm %d points to subprog '%s' (now at %zu offset)\\n\",\n\t\t\t prog->name, insn_idx, insn->imm, subprog->name, subprog->sub_insn_off);\n\t}\n\n\treturn 0;\n}\n\n/*\n * Relocate sub-program calls.\n *\n * Algorithm operates as follows. Each entry-point BPF program (referred to as\n * main prog) is processed separately. For each subprog (non-entry functions,\n * that can be called from either entry progs or other subprogs) gets their\n * sub_insn_off reset to zero. This serves as indicator that this subprogram\n * hasn't been yet appended and relocated within current main prog. Once its\n * relocated, sub_insn_off will point at the position within current main prog\n * where given subprog was appended. This will further be used to relocate all\n * the call instructions jumping into this subprog.\n *\n * We start with main program and process all call instructions. If the call\n * is into a subprog that hasn't been processed (i.e., subprog->sub_insn_off\n * is zero), subprog instructions are appended at the end of main program's\n * instruction array. Then main program is \"put on hold\" while we recursively\n * process newly appended subprogram. If that subprogram calls into another\n * subprogram that hasn't been appended, new subprogram is appended again to\n * the *main* prog's instructions (subprog's instructions are always left\n * untouched, as they need to be in unmodified state for subsequent main progs\n * and subprog instructions are always sent only as part of a main prog) and\n * the process continues recursively. Once all the subprogs called from a main\n * prog or any of its subprogs are appended (and relocated), all their\n * positions within finalized instructions array are known, so it's easy to\n * rewrite call instructions with correct relative offsets, corresponding to\n * desired target subprog.\n *\n * Its important to realize that some subprogs might not be called from some\n * main prog and any of its called/used subprogs. Those will keep their\n * subprog->sub_insn_off as zero at all times and won't be appended to current\n * main prog and won't be relocated within the context of current main prog.\n * They might still be used from other main progs later.\n *\n * Visually this process can be shown as below. Suppose we have two main\n * programs mainA and mainB and BPF object contains three subprogs: subA,\n * subB, and subC. mainA calls only subA, mainB calls only subC, but subA and\n * subC both call subB:\n *\n *        +--------+ +-------+\n *        |        v v       |\n *     +--+---+ +--+-+-+ +---+--+\n *     | subA | | subB | | subC |\n *     +--+---+ +------+ +---+--+\n *        ^                  ^\n *        |                  |\n *    +---+-------+   +------+----+\n *    |   mainA   |   |   mainB   |\n *    +-----------+   +-----------+\n *\n * We'll start relocating mainA, will find subA, append it and start\n * processing sub A recursively:\n *\n *    +-----------+------+\n *    |   mainA   | subA |\n *    +-----------+------+\n *\n * At this point we notice that subB is used from subA, so we append it and\n * relocate (there are no further subcalls from subB):\n *\n *    +-----------+------+------+\n *    |   mainA   | subA | subB |\n *    +-----------+------+------+\n *\n * At this point, we relocate subA calls, then go one level up and finish with\n * relocatin mainA calls. mainA is done.\n *\n * For mainB process is similar but results in different order. We start with\n * mainB and skip subA and subB, as mainB never calls them (at least\n * directly), but we see subC is needed, so we append and start processing it:\n *\n *    +-----------+------+\n *    |   mainB   | subC |\n *    +-----------+------+\n * Now we see subC needs subB, so we go back to it, append and relocate it:\n *\n *    +-----------+------+------+\n *    |   mainB   | subC | subB |\n *    +-----------+------+------+\n *\n * At this point we unwind recursion, relocate calls in subC, then in mainB.\n */\nstatic int\nbpf_object__relocate_calls(struct bpf_object *obj, struct bpf_program *prog)\n{\n\tstruct bpf_program *subprog;\n\tint i, j, err;\n\n\t/* mark all subprogs as not relocated (yet) within the context of\n\t * current main program\n\t */\n\tfor (i = 0; i < obj->nr_programs; i++) {\n\t\tsubprog = &obj->programs[i];\n\t\tif (!prog_is_subprog(obj, subprog))\n\t\t\tcontinue;\n\n\t\tsubprog->sub_insn_off = 0;\n\t\tfor (j = 0; j < subprog->nr_reloc; j++)\n\t\t\tif (subprog->reloc_desc[j].type == RELO_CALL)\n\t\t\t\tsubprog->reloc_desc[j].processed = false;\n\t}\n\n\terr = bpf_object__reloc_code(obj, prog, prog);\n\tif (err)\n\t\treturn err;\n\n\n\treturn 0;\n}\n\nstatic int\nbpf_object__relocate(struct bpf_object *obj, const char *targ_btf_path)\n{\n\tstruct bpf_program *prog;\n\tsize_t i;\n\tint err;\n\n\tif (obj->btf_ext) {\n\t\terr = bpf_object__relocate_core(obj, targ_btf_path);\n\t\tif (err) {\n\t\t\tpr_warn(\"failed to perform CO-RE relocations: %d\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t}\n\t/* relocate data references first for all programs and sub-programs,\n\t * as they don't change relative to code locations, so subsequent\n\t * subprogram processing won't need to re-calculate any of them\n\t */\n\tfor (i = 0; i < obj->nr_programs; i++) {\n\t\tprog = &obj->programs[i];\n\t\terr = bpf_object__relocate_data(obj, prog);\n\t\tif (err) {\n\t\t\tpr_warn(\"prog '%s': failed to relocate data references: %d\\n\",\n\t\t\t\tprog->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\t/* now relocate subprogram calls and append used subprograms to main\n\t * programs; each copy of subprogram code needs to be relocated\n\t * differently for each main program, because its code location might\n\t * have changed\n\t */\n\tfor (i = 0; i < obj->nr_programs; i++) {\n\t\tprog = &obj->programs[i];\n\t\t/* sub-program's sub-calls are relocated within the context of\n\t\t * its main program only\n\t\t */\n\t\tif (prog_is_subprog(obj, prog))\n\t\t\tcontinue;\n\n\t\terr = bpf_object__relocate_calls(obj, prog);\n\t\tif (err) {\n\t\t\tpr_warn(\"prog '%s': failed to relocate calls: %d\\n\",\n\t\t\t\tprog->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\t/* free up relocation descriptors */\n\tfor (i = 0; i < obj->nr_programs; i++) {\n\t\tprog = &obj->programs[i];\n\t\tzfree(&prog->reloc_desc);\n\t\tprog->nr_reloc = 0;\n\t}\n\treturn 0;\n}\n\nstatic int bpf_object__collect_st_ops_relos(struct bpf_object *obj,\n\t\t\t\t\t    GElf_Shdr *shdr, Elf_Data *data);\n\nstatic int bpf_object__collect_map_relos(struct bpf_object *obj,\n\t\t\t\t\t GElf_Shdr *shdr, Elf_Data *data)\n{\n\tconst int bpf_ptr_sz = 8, host_ptr_sz = sizeof(void *);\n\tint i, j, nrels, new_sz;\n\tconst struct btf_var_secinfo *vi = NULL;\n\tconst struct btf_type *sec, *var, *def;\n\tstruct bpf_map *map = NULL, *targ_map;\n\tconst struct btf_member *member;\n\tconst char *name, *mname;\n\tElf_Data *symbols;\n\tunsigned int moff;\n\tGElf_Sym sym;\n\tGElf_Rel rel;\n\tvoid *tmp;\n\n\tif (!obj->efile.btf_maps_sec_btf_id || !obj->btf)\n\t\treturn -EINVAL;\n\tsec = btf__type_by_id(obj->btf, obj->efile.btf_maps_sec_btf_id);\n\tif (!sec)\n\t\treturn -EINVAL;\n\n\tsymbols = obj->efile.symbols;\n\tnrels = shdr->sh_size / shdr->sh_entsize;\n\tfor (i = 0; i < nrels; i++) {\n\t\tif (!gelf_getrel(data, i, &rel)) {\n\t\t\tpr_warn(\".maps relo #%d: failed to get ELF relo\\n\", i);\n\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t\t}\n\t\tif (!gelf_getsym(symbols, GELF_R_SYM(rel.r_info), &sym)) {\n\t\t\tpr_warn(\".maps relo #%d: symbol %zx not found\\n\",\n\t\t\t\ti, (size_t)GELF_R_SYM(rel.r_info));\n\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t\t}\n\t\tname = elf_sym_str(obj, sym.st_name) ?: \"<?>\";\n\t\tif (sym.st_shndx != obj->efile.btf_maps_shndx) {\n\t\t\tpr_warn(\".maps relo #%d: '%s' isn't a BTF-defined map\\n\",\n\t\t\t\ti, name);\n\t\t\treturn -LIBBPF_ERRNO__RELOC;\n\t\t}\n\n\t\tpr_debug(\".maps relo #%d: for %zd value %zd rel.r_offset %zu name %d ('%s')\\n\",\n\t\t\t i, (ssize_t)(rel.r_info >> 32), (size_t)sym.st_value,\n\t\t\t (size_t)rel.r_offset, sym.st_name, name);\n\n\t\tfor (j = 0; j < obj->nr_maps; j++) {\n\t\t\tmap = &obj->maps[j];\n\t\t\tif (map->sec_idx != obj->efile.btf_maps_shndx)\n\t\t\t\tcontinue;\n\n\t\t\tvi = btf_var_secinfos(sec) + map->btf_var_idx;\n\t\t\tif (vi->offset <= rel.r_offset &&\n\t\t\t    rel.r_offset + bpf_ptr_sz <= vi->offset + vi->size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == obj->nr_maps) {\n\t\t\tpr_warn(\".maps relo #%d: cannot find map '%s' at rel.r_offset %zu\\n\",\n\t\t\t\ti, name, (size_t)rel.r_offset);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!bpf_map_type__is_map_in_map(map->def.type))\n\t\t\treturn -EINVAL;\n\t\tif (map->def.type == BPF_MAP_TYPE_HASH_OF_MAPS &&\n\t\t    map->def.key_size != sizeof(int)) {\n\t\t\tpr_warn(\".maps relo #%d: hash-of-maps '%s' should have key size %zu.\\n\",\n\t\t\t\ti, map->name, sizeof(int));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttarg_map = bpf_object__find_map_by_name(obj, name);\n\t\tif (!targ_map)\n\t\t\treturn -ESRCH;\n\n\t\tvar = btf__type_by_id(obj->btf, vi->type);\n\t\tdef = skip_mods_and_typedefs(obj->btf, var->type, NULL);\n\t\tif (btf_vlen(def) == 0)\n\t\t\treturn -EINVAL;\n\t\tmember = btf_members(def) + btf_vlen(def) - 1;\n\t\tmname = btf__name_by_offset(obj->btf, member->name_off);\n\t\tif (strcmp(mname, \"values\"))\n\t\t\treturn -EINVAL;\n\n\t\tmoff = btf_member_bit_offset(def, btf_vlen(def) - 1) / 8;\n\t\tif (rel.r_offset - vi->offset < moff)\n\t\t\treturn -EINVAL;\n\n\t\tmoff = rel.r_offset - vi->offset - moff;\n\t\t/* here we use BPF pointer size, which is always 64 bit, as we\n\t\t * are parsing ELF that was built for BPF target\n\t\t */\n\t\tif (moff % bpf_ptr_sz)\n\t\t\treturn -EINVAL;\n\t\tmoff /= bpf_ptr_sz;\n\t\tif (moff >= map->init_slots_sz) {\n\t\t\tnew_sz = moff + 1;\n\t\t\ttmp = libbpf_reallocarray(map->init_slots, new_sz, host_ptr_sz);\n\t\t\tif (!tmp)\n\t\t\t\treturn -ENOMEM;\n\t\t\tmap->init_slots = tmp;\n\t\t\tmemset(map->init_slots + map->init_slots_sz, 0,\n\t\t\t       (new_sz - map->init_slots_sz) * host_ptr_sz);\n\t\t\tmap->init_slots_sz = new_sz;\n\t\t}\n\t\tmap->init_slots[moff] = targ_map;\n\n\t\tpr_debug(\".maps relo #%d: map '%s' slot [%d] points to map '%s'\\n\",\n\t\t\t i, map->name, moff, name);\n\t}\n\n\treturn 0;\n}\n\nstatic int cmp_relocs(const void *_a, const void *_b)\n{\n\tconst struct reloc_desc *a = _a;\n\tconst struct reloc_desc *b = _b;\n\n\tif (a->insn_idx != b->insn_idx)\n\t\treturn a->insn_idx < b->insn_idx ? -1 : 1;\n\n\t/* no two relocations should have the same insn_idx, but ... */\n\tif (a->type != b->type)\n\t\treturn a->type < b->type ? -1 : 1;\n\n\treturn 0;\n}\n\nstatic int bpf_object__collect_relos(struct bpf_object *obj)\n{\n\tint i, err;\n\n\tfor (i = 0; i < obj->efile.nr_reloc_sects; i++) {\n\t\tGElf_Shdr *shdr = &obj->efile.reloc_sects[i].shdr;\n\t\tElf_Data *data = obj->efile.reloc_sects[i].data;\n\t\tint idx = shdr->sh_info;\n\n\t\tif (shdr->sh_type != SHT_REL) {\n\t\t\tpr_warn(\"internal error at %d\\n\", __LINE__);\n\t\t\treturn -LIBBPF_ERRNO__INTERNAL;\n\t\t}\n\n\t\tif (idx == obj->efile.st_ops_shndx)\n\t\t\terr = bpf_object__collect_st_ops_relos(obj, shdr, data);\n\t\telse if (idx == obj->efile.btf_maps_shndx)\n\t\t\terr = bpf_object__collect_map_relos(obj, shdr, data);\n\t\telse\n\t\t\terr = bpf_object__collect_prog_relos(obj, shdr, data);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < obj->nr_programs; i++) {\n\t\tstruct bpf_program *p = &obj->programs[i];\n\t\t\n\t\tif (!p->nr_reloc)\n\t\t\tcontinue;\n\n\t\tqsort(p->reloc_desc, p->nr_reloc, sizeof(*p->reloc_desc), cmp_relocs);\n\t}\n\treturn 0;\n}\n\nstatic bool insn_is_helper_call(struct bpf_insn *insn, enum bpf_func_id *func_id)\n{\n\tif (BPF_CLASS(insn->code) == BPF_JMP &&\n\t    BPF_OP(insn->code) == BPF_CALL &&\n\t    BPF_SRC(insn->code) == BPF_K &&\n\t    insn->src_reg == 0 &&\n\t    insn->dst_reg == 0) {\n\t\t    *func_id = insn->imm;\n\t\t    return true;\n\t}\n\treturn false;\n}\n\nstatic int bpf_object__sanitize_prog(struct bpf_object* obj, struct bpf_program *prog)\n{\n\tstruct bpf_insn *insn = prog->insns;\n\tenum bpf_func_id func_id;\n\tint i;\n\n\tfor (i = 0; i < prog->insns_cnt; i++, insn++) {\n\t\tif (!insn_is_helper_call(insn, &func_id))\n\t\t\tcontinue;\n\n\t\t/* on kernels that don't yet support\n\t\t * bpf_probe_read_{kernel,user}[_str] helpers, fall back\n\t\t * to bpf_probe_read() which works well for old kernels\n\t\t */\n\t\tswitch (func_id) {\n\t\tcase BPF_FUNC_probe_read_kernel:\n\t\tcase BPF_FUNC_probe_read_user:\n\t\t\tif (!kernel_supports(FEAT_PROBE_READ_KERN))\n\t\t\t\tinsn->imm = BPF_FUNC_probe_read;\n\t\t\tbreak;\n\t\tcase BPF_FUNC_probe_read_kernel_str:\n\t\tcase BPF_FUNC_probe_read_user_str:\n\t\t\tif (!kernel_supports(FEAT_PROBE_READ_KERN))\n\t\t\t\tinsn->imm = BPF_FUNC_probe_read_str;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\nload_program(struct bpf_program *prog, struct bpf_insn *insns, int insns_cnt,\n\t     char *license, __u32 kern_version, int *pfd)\n{\n\tstruct bpf_load_program_attr load_attr;\n\tchar *cp, errmsg[STRERR_BUFSIZE];\n\tsize_t log_buf_size = 0;\n\tchar *log_buf = NULL;\n\tint btf_fd, ret;\n\n\tif (!insns || !insns_cnt)\n\t\treturn -EINVAL;\n\n\tmemset(&load_attr, 0, sizeof(struct bpf_load_program_attr));\n\tload_attr.prog_type = prog->type;\n\t/* old kernels might not support specifying expected_attach_type */\n\tif (!kernel_supports(FEAT_EXP_ATTACH_TYPE) && prog->sec_def &&\n\t    prog->sec_def->is_exp_attach_type_optional)\n\t\tload_attr.expected_attach_type = 0;\n\telse\n\t\tload_attr.expected_attach_type = prog->expected_attach_type;\n\tif (kernel_supports(FEAT_PROG_NAME))\n\t\tload_attr.name = prog->name;\n\tload_attr.insns = insns;\n\tload_attr.insns_cnt = insns_cnt;\n\tload_attr.license = license;\n\tif (prog->type == BPF_PROG_TYPE_STRUCT_OPS ||\n\t    prog->type == BPF_PROG_TYPE_LSM) {\n\t\tload_attr.attach_btf_id = prog->attach_btf_id;\n\t} else if (prog->type == BPF_PROG_TYPE_TRACING ||\n\t\t   prog->type == BPF_PROG_TYPE_EXT) {\n\t\tload_attr.attach_prog_fd = prog->attach_prog_fd;\n\t\tload_attr.attach_btf_id = prog->attach_btf_id;\n\t} else {\n\t\tload_attr.kern_version = kern_version;\n\t\tload_attr.prog_ifindex = prog->prog_ifindex;\n\t}\n\t/* specify func_info/line_info only if kernel supports them */\n\tbtf_fd = bpf_object__btf_fd(prog->obj);\n\tif (btf_fd >= 0 && kernel_supports(FEAT_BTF_FUNC)) {\n\t\tload_attr.prog_btf_fd = btf_fd;\n\t\tload_attr.func_info = prog->func_info;\n\t\tload_attr.func_info_rec_size = prog->func_info_rec_size;\n\t\tload_attr.func_info_cnt = prog->func_info_cnt;\n\t\tload_attr.line_info = prog->line_info;\n\t\tload_attr.line_info_rec_size = prog->line_info_rec_size;\n\t\tload_attr.line_info_cnt = prog->line_info_cnt;\n\t}\n\tload_attr.log_level = prog->log_level;\n\tload_attr.prog_flags = prog->prog_flags;\n\nretry_load:\n\tif (log_buf_size) {\n\t\tlog_buf = malloc(log_buf_size);\n\t\tif (!log_buf)\n\t\t\treturn -ENOMEM;\n\n\t\t*log_buf = 0;\n\t}\n\n\tret = bpf_load_program_xattr(&load_attr, log_buf, log_buf_size);\n\n\tif (ret >= 0) {\n\t\tif (log_buf && load_attr.log_level)\n\t\t\tpr_debug(\"verifier log:\\n%s\", log_buf);\n\n\t\tif (prog->obj->rodata_map_idx >= 0 &&\n\t\t    kernel_supports(FEAT_PROG_BIND_MAP)) {\n\t\t\tstruct bpf_map *rodata_map =\n\t\t\t\t&prog->obj->maps[prog->obj->rodata_map_idx];\n\n\t\t\tif (bpf_prog_bind_map(ret, bpf_map__fd(rodata_map), NULL)) {\n\t\t\t\tcp = libbpf_strerror_r(errno, errmsg, sizeof(errmsg));\n\t\t\t\tpr_warn(\"prog '%s': failed to bind .rodata map: %s\\n\",\n\t\t\t\t\tprog->name, cp);\n\t\t\t\t/* Don't fail hard if can't bind rodata. */\n\t\t\t}\n\t\t}\n\n\t\t*pfd = ret;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (!log_buf || errno == ENOSPC) {\n\t\tlog_buf_size = max((size_t)BPF_LOG_BUF_SIZE,\n\t\t\t\t   log_buf_size << 1);\n\n\t\tfree(log_buf);\n\t\tgoto retry_load;\n\t}\n\tret = errno ? -errno : -LIBBPF_ERRNO__LOAD;\n\tcp = libbpf_strerror_r(errno, errmsg, sizeof(errmsg));\n\tpr_warn(\"load bpf program failed: %s\\n\", cp);\n\tpr_perm_msg(ret);\n\n\tif (log_buf && log_buf[0] != '\\0') {\n\t\tret = -LIBBPF_ERRNO__VERIFY;\n\t\tpr_warn(\"-- BEGIN DUMP LOG ---\\n\");\n\t\tpr_warn(\"\\n%s\\n\", log_buf);\n\t\tpr_warn(\"-- END LOG --\\n\");\n\t} else if (load_attr.insns_cnt >= BPF_MAXINSNS) {\n\t\tpr_warn(\"Program too large (%zu insns), at most %d insns\\n\",\n\t\t\tload_attr.insns_cnt, BPF_MAXINSNS);\n\t\tret = -LIBBPF_ERRNO__PROG2BIG;\n\t} else if (load_attr.prog_type != BPF_PROG_TYPE_KPROBE) {\n\t\t/* Wrong program type? */\n\t\tint fd;\n\n\t\tload_attr.prog_type = BPF_PROG_TYPE_KPROBE;\n\t\tload_attr.expected_attach_type = 0;\n\t\tfd = bpf_load_program_xattr(&load_attr, NULL, 0);\n\t\tif (fd >= 0) {\n\t\t\tclose(fd);\n\t\t\tret = -LIBBPF_ERRNO__PROGTYPE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfree(log_buf);\n\treturn ret;\n}\n\nstatic int libbpf_find_attach_btf_id(struct bpf_program *prog);\n\nint bpf_program__load(struct bpf_program *prog, char *license, __u32 kern_ver)\n{\n\tint err = 0, fd, i, btf_id;\n\n\tif (prog->obj->loaded) {\n\t\tpr_warn(\"prog '%s': can't load after object was loaded\\n\", prog->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((prog->type == BPF_PROG_TYPE_TRACING ||\n\t     prog->type == BPF_PROG_TYPE_LSM ||\n\t     prog->type == BPF_PROG_TYPE_EXT) && !prog->attach_btf_id) {\n\t\tbtf_id = libbpf_find_attach_btf_id(prog);\n\t\tif (btf_id <= 0)\n\t\t\treturn btf_id;\n\t\tprog->attach_btf_id = btf_id;\n\t}\n\n\tif (prog->instances.nr < 0 || !prog->instances.fds) {\n\t\tif (prog->preprocessor) {\n\t\t\tpr_warn(\"Internal error: can't load program '%s'\\n\",\n\t\t\t\tprog->name);\n\t\t\treturn -LIBBPF_ERRNO__INTERNAL;\n\t\t}\n\n\t\tprog->instances.fds = malloc(sizeof(int));\n\t\tif (!prog->instances.fds) {\n\t\t\tpr_warn(\"Not enough memory for BPF fds\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprog->instances.nr = 1;\n\t\tprog->instances.fds[0] = -1;\n\t}\n\n\tif (!prog->preprocessor) {\n\t\tif (prog->instances.nr != 1) {\n\t\t\tpr_warn(\"prog '%s': inconsistent nr(%d) != 1\\n\",\n\t\t\t\tprog->name, prog->instances.nr);\n\t\t}\n\t\terr = load_program(prog, prog->insns, prog->insns_cnt,\n\t\t\t\t   license, kern_ver, &fd);\n\t\tif (!err)\n\t\t\tprog->instances.fds[0] = fd;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < prog->instances.nr; i++) {\n\t\tstruct bpf_prog_prep_result result;\n\t\tbpf_program_prep_t preprocessor = prog->preprocessor;\n\n\t\tmemset(&result, 0, sizeof(result));\n\t\terr = preprocessor(prog, i, prog->insns,\n\t\t\t\t   prog->insns_cnt, &result);\n\t\tif (err) {\n\t\t\tpr_warn(\"Preprocessing the %dth instance of program '%s' failed\\n\",\n\t\t\t\ti, prog->name);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!result.new_insn_ptr || !result.new_insn_cnt) {\n\t\t\tpr_debug(\"Skip loading the %dth instance of program '%s'\\n\",\n\t\t\t\t i, prog->name);\n\t\t\tprog->instances.fds[i] = -1;\n\t\t\tif (result.pfd)\n\t\t\t\t*result.pfd = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = load_program(prog, result.new_insn_ptr,\n\t\t\t\t   result.new_insn_cnt, license, kern_ver, &fd);\n\t\tif (err) {\n\t\t\tpr_warn(\"Loading the %dth instance of program '%s' failed\\n\",\n\t\t\t\ti, prog->name);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (result.pfd)\n\t\t\t*result.pfd = fd;\n\t\tprog->instances.fds[i] = fd;\n\t}\nout:\n\tif (err)\n\t\tpr_warn(\"failed to load program '%s'\\n\", prog->name);\n\tzfree(&prog->insns);\n\tprog->insns_cnt = 0;\n\treturn err;\n}\n\nstatic int\nbpf_object__load_progs(struct bpf_object *obj, int log_level)\n{\n\tstruct bpf_program *prog;\n\tsize_t i;\n\tint err;\n\n\tfor (i = 0; i < obj->nr_programs; i++) {\n\t\tprog = &obj->programs[i];\n\t\terr = bpf_object__sanitize_prog(obj, prog);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < obj->nr_programs; i++) {\n\t\tprog = &obj->programs[i];\n\t\tif (prog_is_subprog(obj, prog))\n\t\t\tcontinue;\n\t\tif (!prog->load) {\n\t\t\tpr_debug(\"prog '%s': skipped loading\\n\", prog->name);\n\t\t\tcontinue;\n\t\t}\n\t\tprog->log_level |= log_level;\n\t\terr = bpf_program__load(prog, obj->license, obj->kern_version);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic const struct bpf_sec_def *find_sec_def(const char *sec_name);\n\nstatic struct bpf_object *\n__bpf_object__open(const char *path, const void *obj_buf, size_t obj_buf_sz,\n\t\t   const struct bpf_object_open_opts *opts)\n{\n\tconst char *obj_name, *kconfig;\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tchar tmp_name[64];\n\tint err;\n\n\tif (elf_version(EV_CURRENT) == EV_NONE) {\n\t\tpr_warn(\"failed to init libelf for %s\\n\",\n\t\t\tpath ? : \"(mem buf)\");\n\t\treturn ERR_PTR(-LIBBPF_ERRNO__LIBELF);\n\t}\n\n\tif (!OPTS_VALID(opts, bpf_object_open_opts))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tobj_name = OPTS_GET(opts, object_name, NULL);\n\tif (obj_buf) {\n\t\tif (!obj_name) {\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), \"%lx-%lx\",\n\t\t\t\t (unsigned long)obj_buf,\n\t\t\t\t (unsigned long)obj_buf_sz);\n\t\t\tobj_name = tmp_name;\n\t\t}\n\t\tpath = obj_name;\n\t\tpr_debug(\"loading object '%s' from buffer\\n\", obj_name);\n\t}\n\n\tobj = bpf_object__new(path, obj_buf, obj_buf_sz, obj_name);\n\tif (IS_ERR(obj))\n\t\treturn obj;\n\n\tkconfig = OPTS_GET(opts, kconfig, NULL);\n\tif (kconfig) {\n\t\tobj->kconfig = strdup(kconfig);\n\t\tif (!obj->kconfig)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = bpf_object__elf_init(obj);\n\terr = err ? : bpf_object__check_endianness(obj);\n\terr = err ? : bpf_object__elf_collect(obj);\n\terr = err ? : bpf_object__collect_externs(obj);\n\terr = err ? : bpf_object__finalize_btf(obj);\n\terr = err ? : bpf_object__init_maps(obj, opts);\n\terr = err ? : bpf_object__collect_relos(obj);\n\tif (err)\n\t\tgoto out;\n\tbpf_object__elf_finish(obj);\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tprog->sec_def = find_sec_def(prog->sec_name);\n\t\tif (!prog->sec_def)\n\t\t\t/* couldn't guess, but user might manually specify */\n\t\t\tcontinue;\n\n\t\tif (prog->sec_def->is_sleepable)\n\t\t\tprog->prog_flags |= BPF_F_SLEEPABLE;\n\t\tbpf_program__set_type(prog, prog->sec_def->prog_type);\n\t\tbpf_program__set_expected_attach_type(prog,\n\t\t\t\tprog->sec_def->expected_attach_type);\n\n\t\tif (prog->sec_def->prog_type == BPF_PROG_TYPE_TRACING ||\n\t\t    prog->sec_def->prog_type == BPF_PROG_TYPE_EXT)\n\t\t\tprog->attach_prog_fd = OPTS_GET(opts, attach_prog_fd, 0);\n\t}\n\n\treturn obj;\nout:\n\tbpf_object__close(obj);\n\treturn ERR_PTR(err);\n}\n\nstatic struct bpf_object *\n__bpf_object__open_xattr(struct bpf_object_open_attr *attr, int flags)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_object_open_opts, opts,\n\t\t.relaxed_maps = flags & MAPS_RELAX_COMPAT,\n\t);\n\n\t/* param validation */\n\tif (!attr->file)\n\t\treturn NULL;\n\n\tpr_debug(\"loading %s\\n\", attr->file);\n\treturn __bpf_object__open(attr->file, NULL, 0, &opts);\n}\n\nstruct bpf_object *bpf_object__open_xattr(struct bpf_object_open_attr *attr)\n{\n\treturn __bpf_object__open_xattr(attr, 0);\n}\n\nstruct bpf_object *bpf_object__open(const char *path)\n{\n\tstruct bpf_object_open_attr attr = {\n\t\t.file\t\t= path,\n\t\t.prog_type\t= BPF_PROG_TYPE_UNSPEC,\n\t};\n\n\treturn bpf_object__open_xattr(&attr);\n}\n\nstruct bpf_object *\nbpf_object__open_file(const char *path, const struct bpf_object_open_opts *opts)\n{\n\tif (!path)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpr_debug(\"loading %s\\n\", path);\n\n\treturn __bpf_object__open(path, NULL, 0, opts);\n}\n\nstruct bpf_object *\nbpf_object__open_mem(const void *obj_buf, size_t obj_buf_sz,\n\t\t     const struct bpf_object_open_opts *opts)\n{\n\tif (!obj_buf || obj_buf_sz == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn __bpf_object__open(NULL, obj_buf, obj_buf_sz, opts);\n}\n\nstruct bpf_object *\nbpf_object__open_buffer(const void *obj_buf, size_t obj_buf_sz,\n\t\t\tconst char *name)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_object_open_opts, opts,\n\t\t.object_name = name,\n\t\t/* wrong default, but backwards-compatible */\n\t\t.relaxed_maps = true,\n\t);\n\n\t/* returning NULL is wrong, but backwards-compatible */\n\tif (!obj_buf || obj_buf_sz == 0)\n\t\treturn NULL;\n\n\treturn bpf_object__open_mem(obj_buf, obj_buf_sz, &opts);\n}\n\nint bpf_object__unload(struct bpf_object *obj)\n{\n\tsize_t i;\n\n\tif (!obj)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < obj->nr_maps; i++) {\n\t\tzclose(obj->maps[i].fd);\n\t\tif (obj->maps[i].st_ops)\n\t\t\tzfree(&obj->maps[i].st_ops->kern_vdata);\n\t}\n\n\tfor (i = 0; i < obj->nr_programs; i++)\n\t\tbpf_program__unload(&obj->programs[i]);\n\n\treturn 0;\n}\n\nstatic int bpf_object__sanitize_maps(struct bpf_object *obj)\n{\n\tstruct bpf_map *m;\n\n\tbpf_object__for_each_map(m, obj) {\n\t\tif (!bpf_map__is_internal(m))\n\t\t\tcontinue;\n\t\tif (!kernel_supports(FEAT_GLOBAL_DATA)) {\n\t\t\tpr_warn(\"kernel doesn't support global data\\n\");\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t\tif (!kernel_supports(FEAT_ARRAY_MMAP))\n\t\t\tm->def.map_flags ^= BPF_F_MMAPABLE;\n\t}\n\n\treturn 0;\n}\n\nstatic int bpf_object__read_kallsyms_file(struct bpf_object *obj)\n{\n\tchar sym_type, sym_name[500];\n\tunsigned long long sym_addr;\n\tstruct extern_desc *ext;\n\tint ret, err = 0;\n\tFILE *f;\n\n\tf = fopen(\"/proc/kallsyms\", \"r\");\n\tif (!f) {\n\t\terr = -errno;\n\t\tpr_warn(\"failed to open /proc/kallsyms: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\twhile (true) {\n\t\tret = fscanf(f, \"%llx %c %499s%*[^\\n]\\n\",\n\t\t\t     &sym_addr, &sym_type, sym_name);\n\t\tif (ret == EOF && feof(f))\n\t\t\tbreak;\n\t\tif (ret != 3) {\n\t\t\tpr_warn(\"failed to read kallsyms entry: %d\\n\", ret);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\text = find_extern_by_name(obj, sym_name);\n\t\tif (!ext || ext->type != EXT_KSYM)\n\t\t\tcontinue;\n\n\t\tif (ext->is_set && ext->ksym.addr != sym_addr) {\n\t\t\tpr_warn(\"extern (ksym) '%s' resolution is ambiguous: 0x%llx or 0x%llx\\n\",\n\t\t\t\tsym_name, ext->ksym.addr, sym_addr);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!ext->is_set) {\n\t\t\text->is_set = true;\n\t\t\text->ksym.addr = sym_addr;\n\t\t\tpr_debug(\"extern (ksym) %s=0x%llx\\n\", sym_name, sym_addr);\n\t\t}\n\t}\n\nout:\n\tfclose(f);\n\treturn err;\n}\n\nstatic int bpf_object__resolve_ksyms_btf_id(struct bpf_object *obj)\n{\n\tstruct extern_desc *ext;\n\tint i, id;\n\n\tfor (i = 0; i < obj->nr_extern; i++) {\n\t\tconst struct btf_type *targ_var, *targ_type;\n\t\t__u32 targ_type_id, local_type_id;\n\t\tconst char *targ_var_name;\n\t\tint ret;\n\n\t\text = &obj->externs[i];\n\t\tif (ext->type != EXT_KSYM || !ext->ksym.type_id)\n\t\t\tcontinue;\n\n\t\tid = btf__find_by_name_kind(obj->btf_vmlinux, ext->name,\n\t\t\t\t\t    BTF_KIND_VAR);\n\t\tif (id <= 0) {\n\t\t\tpr_warn(\"extern (ksym) '%s': failed to find BTF ID in vmlinux BTF.\\n\",\n\t\t\t\text->name);\n\t\t\treturn -ESRCH;\n\t\t}\n\n\t\t/* find local type_id */\n\t\tlocal_type_id = ext->ksym.type_id;\n\n\t\t/* find target type_id */\n\t\ttarg_var = btf__type_by_id(obj->btf_vmlinux, id);\n\t\ttarg_var_name = btf__name_by_offset(obj->btf_vmlinux,\n\t\t\t\t\t\t    targ_var->name_off);\n\t\ttarg_type = skip_mods_and_typedefs(obj->btf_vmlinux,\n\t\t\t\t\t\t   targ_var->type,\n\t\t\t\t\t\t   &targ_type_id);\n\n\t\tret = bpf_core_types_are_compat(obj->btf, local_type_id,\n\t\t\t\t\t\tobj->btf_vmlinux, targ_type_id);\n\t\tif (ret <= 0) {\n\t\t\tconst struct btf_type *local_type;\n\t\t\tconst char *targ_name, *local_name;\n\n\t\t\tlocal_type = btf__type_by_id(obj->btf, local_type_id);\n\t\t\tlocal_name = btf__name_by_offset(obj->btf,\n\t\t\t\t\t\t\t local_type->name_off);\n\t\t\ttarg_name = btf__name_by_offset(obj->btf_vmlinux,\n\t\t\t\t\t\t\ttarg_type->name_off);\n\n\t\t\tpr_warn(\"extern (ksym) '%s': incompatible types, expected [%d] %s %s, but kernel has [%d] %s %s\\n\",\n\t\t\t\text->name, local_type_id,\n\t\t\t\tbtf_kind_str(local_type), local_name, targ_type_id,\n\t\t\t\tbtf_kind_str(targ_type), targ_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\text->is_set = true;\n\t\text->ksym.vmlinux_btf_id = id;\n\t\tpr_debug(\"extern (ksym) '%s': resolved to [%d] %s %s\\n\",\n\t\t\t ext->name, id, btf_kind_str(targ_var), targ_var_name);\n\t}\n\treturn 0;\n}\n\nstatic int bpf_object__resolve_externs(struct bpf_object *obj,\n\t\t\t\t       const char *extra_kconfig)\n{\n\tbool need_config = false, need_kallsyms = false;\n\tbool need_vmlinux_btf = false;\n\tstruct extern_desc *ext;\n\tvoid *kcfg_data = NULL;\n\tint err, i;\n\n\tif (obj->nr_extern == 0)\n\t\treturn 0;\n\n\tif (obj->kconfig_map_idx >= 0)\n\t\tkcfg_data = obj->maps[obj->kconfig_map_idx].mmaped;\n\n\tfor (i = 0; i < obj->nr_extern; i++) {\n\t\text = &obj->externs[i];\n\n\t\tif (ext->type == EXT_KCFG &&\n\t\t    strcmp(ext->name, \"LINUX_KERNEL_VERSION\") == 0) {\n\t\t\tvoid *ext_val = kcfg_data + ext->kcfg.data_off;\n\t\t\t__u32 kver = get_kernel_version();\n\n\t\t\tif (!kver) {\n\t\t\t\tpr_warn(\"failed to get kernel version\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = set_kcfg_value_num(ext, ext_val, kver);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tpr_debug(\"extern (kcfg) %s=0x%x\\n\", ext->name, kver);\n\t\t} else if (ext->type == EXT_KCFG &&\n\t\t\t   strncmp(ext->name, \"CONFIG_\", 7) == 0) {\n\t\t\tneed_config = true;\n\t\t} else if (ext->type == EXT_KSYM) {\n\t\t\tif (ext->ksym.type_id)\n\t\t\t\tneed_vmlinux_btf = true;\n\t\t\telse\n\t\t\t\tneed_kallsyms = true;\n\t\t} else {\n\t\t\tpr_warn(\"unrecognized extern '%s'\\n\", ext->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (need_config && extra_kconfig) {\n\t\terr = bpf_object__read_kconfig_mem(obj, extra_kconfig, kcfg_data);\n\t\tif (err)\n\t\t\treturn -EINVAL;\n\t\tneed_config = false;\n\t\tfor (i = 0; i < obj->nr_extern; i++) {\n\t\t\text = &obj->externs[i];\n\t\t\tif (ext->type == EXT_KCFG && !ext->is_set) {\n\t\t\t\tneed_config = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (need_config) {\n\t\terr = bpf_object__read_kconfig_file(obj, kcfg_data);\n\t\tif (err)\n\t\t\treturn -EINVAL;\n\t}\n\tif (need_kallsyms) {\n\t\terr = bpf_object__read_kallsyms_file(obj);\n\t\tif (err)\n\t\t\treturn -EINVAL;\n\t}\n\tif (need_vmlinux_btf) {\n\t\terr = bpf_object__resolve_ksyms_btf_id(obj);\n\t\tif (err)\n\t\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < obj->nr_extern; i++) {\n\t\text = &obj->externs[i];\n\n\t\tif (!ext->is_set && !ext->is_weak) {\n\t\t\tpr_warn(\"extern %s (strong) not resolved\\n\", ext->name);\n\t\t\treturn -ESRCH;\n\t\t} else if (!ext->is_set) {\n\t\t\tpr_debug(\"extern %s (weak) not resolved, defaulting to zero\\n\",\n\t\t\t\t ext->name);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint bpf_object__load_xattr(struct bpf_object_load_attr *attr)\n{\n\tstruct bpf_object *obj;\n\tint err, i;\n\n\tif (!attr)\n\t\treturn -EINVAL;\n\tobj = attr->obj;\n\tif (!obj)\n\t\treturn -EINVAL;\n\n\tif (obj->loaded) {\n\t\tpr_warn(\"object '%s': load can't be attempted twice\\n\", obj->name);\n\t\treturn -EINVAL;\n\t}\n\n\terr = bpf_object__probe_loading(obj);\n\terr = err ? : bpf_object__load_vmlinux_btf(obj);\n\terr = err ? : bpf_object__resolve_externs(obj, obj->kconfig);\n\terr = err ? : bpf_object__sanitize_and_load_btf(obj);\n\terr = err ? : bpf_object__sanitize_maps(obj);\n\terr = err ? : bpf_object__init_kern_struct_ops_maps(obj);\n\terr = err ? : bpf_object__create_maps(obj);\n\terr = err ? : bpf_object__relocate(obj, attr->target_btf_path);\n\terr = err ? : bpf_object__load_progs(obj, attr->log_level);\n\n\tbtf__free(obj->btf_vmlinux);\n\tobj->btf_vmlinux = NULL;\n\n\tobj->loaded = true; /* doesn't matter if successfully or not */\n\n\tif (err)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\t/* unpin any maps that were auto-pinned during load */\n\tfor (i = 0; i < obj->nr_maps; i++)\n\t\tif (obj->maps[i].pinned && !obj->maps[i].reused)\n\t\t\tbpf_map__unpin(&obj->maps[i], NULL);\n\n\tbpf_object__unload(obj);\n\tpr_warn(\"failed to load object '%s'\\n\", obj->path);\n\treturn err;\n}\n\nint bpf_object__load(struct bpf_object *obj)\n{\n\tstruct bpf_object_load_attr attr = {\n\t\t.obj = obj,\n\t};\n\n\treturn bpf_object__load_xattr(&attr);\n}\n\nstatic int make_parent_dir(const char *path)\n{\n\tchar *cp, errmsg[STRERR_BUFSIZE];\n\tchar *dname, *dir;\n\tint err = 0;\n\n\tdname = strdup(path);\n\tif (dname == NULL)\n\t\treturn -ENOMEM;\n\n\tdir = dirname(dname);\n\tif (mkdir(dir, 0700) && errno != EEXIST)\n\t\terr = -errno;\n\n\tfree(dname);\n\tif (err) {\n\t\tcp = libbpf_strerror_r(-err, errmsg, sizeof(errmsg));\n\t\tpr_warn(\"failed to mkdir %s: %s\\n\", path, cp);\n\t}\n\treturn err;\n}\n\nstatic int check_path(const char *path)\n{\n\tchar *cp, errmsg[STRERR_BUFSIZE];\n\tstruct statfs st_fs;\n\tchar *dname, *dir;\n\tint err = 0;\n\n\tif (path == NULL)\n\t\treturn -EINVAL;\n\n\tdname = strdup(path);\n\tif (dname == NULL)\n\t\treturn -ENOMEM;\n\n\tdir = dirname(dname);\n\tif (statfs(dir, &st_fs)) {\n\t\tcp = libbpf_strerror_r(errno, errmsg, sizeof(errmsg));\n\t\tpr_warn(\"failed to statfs %s: %s\\n\", dir, cp);\n\t\terr = -errno;\n\t}\n\tfree(dname);\n\n\tif (!err && st_fs.f_type != BPF_FS_MAGIC) {\n\t\tpr_warn(\"specified path %s is not on BPF FS\\n\", path);\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nint bpf_program__pin_instance(struct bpf_program *prog, const char *path,\n\t\t\t      int instance)\n{\n\tchar *cp, errmsg[STRERR_BUFSIZE];\n\tint err;\n\n\terr = make_parent_dir(path);\n\tif (err)\n\t\treturn err;\n\n\terr = check_path(path);\n\tif (err)\n\t\treturn err;\n\n\tif (prog == NULL) {\n\t\tpr_warn(\"invalid program pointer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (instance < 0 || instance >= prog->instances.nr) {\n\t\tpr_warn(\"invalid prog instance %d of prog %s (max %d)\\n\",\n\t\t\tinstance, prog->name, prog->instances.nr);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bpf_obj_pin(prog->instances.fds[instance], path)) {\n\t\terr = -errno;\n\t\tcp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));\n\t\tpr_warn(\"failed to pin program: %s\\n\", cp);\n\t\treturn err;\n\t}\n\tpr_debug(\"pinned program '%s'\\n\", path);\n\n\treturn 0;\n}\n\nint bpf_program__unpin_instance(struct bpf_program *prog, const char *path,\n\t\t\t\tint instance)\n{\n\tint err;\n\n\terr = check_path(path);\n\tif (err)\n\t\treturn err;\n\n\tif (prog == NULL) {\n\t\tpr_warn(\"invalid program pointer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (instance < 0 || instance >= prog->instances.nr) {\n\t\tpr_warn(\"invalid prog instance %d of prog %s (max %d)\\n\",\n\t\t\tinstance, prog->name, prog->instances.nr);\n\t\treturn -EINVAL;\n\t}\n\n\terr = unlink(path);\n\tif (err != 0)\n\t\treturn -errno;\n\tpr_debug(\"unpinned program '%s'\\n\", path);\n\n\treturn 0;\n}\n\nint bpf_program__pin(struct bpf_program *prog, const char *path)\n{\n\tint i, err;\n\n\terr = make_parent_dir(path);\n\tif (err)\n\t\treturn err;\n\n\terr = check_path(path);\n\tif (err)\n\t\treturn err;\n\n\tif (prog == NULL) {\n\t\tpr_warn(\"invalid program pointer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (prog->instances.nr <= 0) {\n\t\tpr_warn(\"no instances of prog %s to pin\\n\", prog->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (prog->instances.nr == 1) {\n\t\t/* don't create subdirs when pinning single instance */\n\t\treturn bpf_program__pin_instance(prog, path, 0);\n\t}\n\n\tfor (i = 0; i < prog->instances.nr; i++) {\n\t\tchar buf[PATH_MAX];\n\t\tint len;\n\n\t\tlen = snprintf(buf, PATH_MAX, \"%s/%d\", path, i);\n\t\tif (len < 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_unpin;\n\t\t} else if (len >= PATH_MAX) {\n\t\t\terr = -ENAMETOOLONG;\n\t\t\tgoto err_unpin;\n\t\t}\n\n\t\terr = bpf_program__pin_instance(prog, buf, i);\n\t\tif (err)\n\t\t\tgoto err_unpin;\n\t}\n\n\treturn 0;\n\nerr_unpin:\n\tfor (i = i - 1; i >= 0; i--) {\n\t\tchar buf[PATH_MAX];\n\t\tint len;\n\n\t\tlen = snprintf(buf, PATH_MAX, \"%s/%d\", path, i);\n\t\tif (len < 0)\n\t\t\tcontinue;\n\t\telse if (len >= PATH_MAX)\n\t\t\tcontinue;\n\n\t\tbpf_program__unpin_instance(prog, buf, i);\n\t}\n\n\trmdir(path);\n\n\treturn err;\n}\n\nint bpf_program__unpin(struct bpf_program *prog, const char *path)\n{\n\tint i, err;\n\n\terr = check_path(path);\n\tif (err)\n\t\treturn err;\n\n\tif (prog == NULL) {\n\t\tpr_warn(\"invalid program pointer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (prog->instances.nr <= 0) {\n\t\tpr_warn(\"no instances of prog %s to pin\\n\", prog->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (prog->instances.nr == 1) {\n\t\t/* don't create subdirs when pinning single instance */\n\t\treturn bpf_program__unpin_instance(prog, path, 0);\n\t}\n\n\tfor (i = 0; i < prog->instances.nr; i++) {\n\t\tchar buf[PATH_MAX];\n\t\tint len;\n\n\t\tlen = snprintf(buf, PATH_MAX, \"%s/%d\", path, i);\n\t\tif (len < 0)\n\t\t\treturn -EINVAL;\n\t\telse if (len >= PATH_MAX)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\terr = bpf_program__unpin_instance(prog, buf, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = rmdir(path);\n\tif (err)\n\t\treturn -errno;\n\n\treturn 0;\n}\n\nint bpf_map__pin(struct bpf_map *map, const char *path)\n{\n\tchar *cp, errmsg[STRERR_BUFSIZE];\n\tint err;\n\n\tif (map == NULL) {\n\t\tpr_warn(\"invalid map pointer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (map->pin_path) {\n\t\tif (path && strcmp(path, map->pin_path)) {\n\t\t\tpr_warn(\"map '%s' already has pin path '%s' different from '%s'\\n\",\n\t\t\t\tbpf_map__name(map), map->pin_path, path);\n\t\t\treturn -EINVAL;\n\t\t} else if (map->pinned) {\n\t\t\tpr_debug(\"map '%s' already pinned at '%s'; not re-pinning\\n\",\n\t\t\t\t bpf_map__name(map), map->pin_path);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (!path) {\n\t\t\tpr_warn(\"missing a path to pin map '%s' at\\n\",\n\t\t\t\tbpf_map__name(map));\n\t\t\treturn -EINVAL;\n\t\t} else if (map->pinned) {\n\t\t\tpr_warn(\"map '%s' already pinned\\n\", bpf_map__name(map));\n\t\t\treturn -EEXIST;\n\t\t}\n\n\t\tmap->pin_path = strdup(path);\n\t\tif (!map->pin_path) {\n\t\t\terr = -errno;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\terr = make_parent_dir(map->pin_path);\n\tif (err)\n\t\treturn err;\n\n\terr = check_path(map->pin_path);\n\tif (err)\n\t\treturn err;\n\n\tif (bpf_obj_pin(map->fd, map->pin_path)) {\n\t\terr = -errno;\n\t\tgoto out_err;\n\t}\n\n\tmap->pinned = true;\n\tpr_debug(\"pinned map '%s'\\n\", map->pin_path);\n\n\treturn 0;\n\nout_err:\n\tcp = libbpf_strerror_r(-err, errmsg, sizeof(errmsg));\n\tpr_warn(\"failed to pin map: %s\\n\", cp);\n\treturn err;\n}\n\nint bpf_map__unpin(struct bpf_map *map, const char *path)\n{\n\tint err;\n\n\tif (map == NULL) {\n\t\tpr_warn(\"invalid map pointer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (map->pin_path) {\n\t\tif (path && strcmp(path, map->pin_path)) {\n\t\t\tpr_warn(\"map '%s' already has pin path '%s' different from '%s'\\n\",\n\t\t\t\tbpf_map__name(map), map->pin_path, path);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpath = map->pin_path;\n\t} else if (!path) {\n\t\tpr_warn(\"no path to unpin map '%s' from\\n\",\n\t\t\tbpf_map__name(map));\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_path(path);\n\tif (err)\n\t\treturn err;\n\n\terr = unlink(path);\n\tif (err != 0)\n\t\treturn -errno;\n\n\tmap->pinned = false;\n\tpr_debug(\"unpinned map '%s' from '%s'\\n\", bpf_map__name(map), path);\n\n\treturn 0;\n}\n\nint bpf_map__set_pin_path(struct bpf_map *map, const char *path)\n{\n\tchar *new = NULL;\n\n\tif (path) {\n\t\tnew = strdup(path);\n\t\tif (!new)\n\t\t\treturn -errno;\n\t}\n\n\tfree(map->pin_path);\n\tmap->pin_path = new;\n\treturn 0;\n}\n\nconst char *bpf_map__get_pin_path(const struct bpf_map *map)\n{\n\treturn map->pin_path;\n}\n\nbool bpf_map__is_pinned(const struct bpf_map *map)\n{\n\treturn map->pinned;\n}\n\nint bpf_object__pin_maps(struct bpf_object *obj, const char *path)\n{\n\tstruct bpf_map *map;\n\tint err;\n\n\tif (!obj)\n\t\treturn -ENOENT;\n\n\tif (!obj->loaded) {\n\t\tpr_warn(\"object not yet loaded; load it first\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tbpf_object__for_each_map(map, obj) {\n\t\tchar *pin_path = NULL;\n\t\tchar buf[PATH_MAX];\n\n\t\tif (path) {\n\t\t\tint len;\n\n\t\t\tlen = snprintf(buf, PATH_MAX, \"%s/%s\", path,\n\t\t\t\t       bpf_map__name(map));\n\t\t\tif (len < 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_unpin_maps;\n\t\t\t} else if (len >= PATH_MAX) {\n\t\t\t\terr = -ENAMETOOLONG;\n\t\t\t\tgoto err_unpin_maps;\n\t\t\t}\n\t\t\tpin_path = buf;\n\t\t} else if (!map->pin_path) {\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = bpf_map__pin(map, pin_path);\n\t\tif (err)\n\t\t\tgoto err_unpin_maps;\n\t}\n\n\treturn 0;\n\nerr_unpin_maps:\n\twhile ((map = bpf_map__prev(map, obj))) {\n\t\tif (!map->pin_path)\n\t\t\tcontinue;\n\n\t\tbpf_map__unpin(map, NULL);\n\t}\n\n\treturn err;\n}\n\nint bpf_object__unpin_maps(struct bpf_object *obj, const char *path)\n{\n\tstruct bpf_map *map;\n\tint err;\n\n\tif (!obj)\n\t\treturn -ENOENT;\n\n\tbpf_object__for_each_map(map, obj) {\n\t\tchar *pin_path = NULL;\n\t\tchar buf[PATH_MAX];\n\n\t\tif (path) {\n\t\t\tint len;\n\n\t\t\tlen = snprintf(buf, PATH_MAX, \"%s/%s\", path,\n\t\t\t\t       bpf_map__name(map));\n\t\t\tif (len < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\telse if (len >= PATH_MAX)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tpin_path = buf;\n\t\t} else if (!map->pin_path) {\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = bpf_map__unpin(map, pin_path);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint bpf_object__pin_programs(struct bpf_object *obj, const char *path)\n{\n\tstruct bpf_program *prog;\n\tint err;\n\n\tif (!obj)\n\t\treturn -ENOENT;\n\n\tif (!obj->loaded) {\n\t\tpr_warn(\"object not yet loaded; load it first\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tchar buf[PATH_MAX];\n\t\tint len;\n\n\t\tlen = snprintf(buf, PATH_MAX, \"%s/%s\", path,\n\t\t\t       prog->pin_name);\n\t\tif (len < 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_unpin_programs;\n\t\t} else if (len >= PATH_MAX) {\n\t\t\terr = -ENAMETOOLONG;\n\t\t\tgoto err_unpin_programs;\n\t\t}\n\n\t\terr = bpf_program__pin(prog, buf);\n\t\tif (err)\n\t\t\tgoto err_unpin_programs;\n\t}\n\n\treturn 0;\n\nerr_unpin_programs:\n\twhile ((prog = bpf_program__prev(prog, obj))) {\n\t\tchar buf[PATH_MAX];\n\t\tint len;\n\n\t\tlen = snprintf(buf, PATH_MAX, \"%s/%s\", path,\n\t\t\t       prog->pin_name);\n\t\tif (len < 0)\n\t\t\tcontinue;\n\t\telse if (len >= PATH_MAX)\n\t\t\tcontinue;\n\n\t\tbpf_program__unpin(prog, buf);\n\t}\n\n\treturn err;\n}\n\nint bpf_object__unpin_programs(struct bpf_object *obj, const char *path)\n{\n\tstruct bpf_program *prog;\n\tint err;\n\n\tif (!obj)\n\t\treturn -ENOENT;\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tchar buf[PATH_MAX];\n\t\tint len;\n\n\t\tlen = snprintf(buf, PATH_MAX, \"%s/%s\", path,\n\t\t\t       prog->pin_name);\n\t\tif (len < 0)\n\t\t\treturn -EINVAL;\n\t\telse if (len >= PATH_MAX)\n\t\t\treturn -ENAMETOOLONG;\n\n\t\terr = bpf_program__unpin(prog, buf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint bpf_object__pin(struct bpf_object *obj, const char *path)\n{\n\tint err;\n\n\terr = bpf_object__pin_maps(obj, path);\n\tif (err)\n\t\treturn err;\n\n\terr = bpf_object__pin_programs(obj, path);\n\tif (err) {\n\t\tbpf_object__unpin_maps(obj, path);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void bpf_map__destroy(struct bpf_map *map)\n{\n\tif (map->clear_priv)\n\t\tmap->clear_priv(map, map->priv);\n\tmap->priv = NULL;\n\tmap->clear_priv = NULL;\n\n\tif (map->inner_map) {\n\t\tbpf_map__destroy(map->inner_map);\n\t\tzfree(&map->inner_map);\n\t}\n\n\tzfree(&map->init_slots);\n\tmap->init_slots_sz = 0;\n\n\tif (map->mmaped) {\n\t\tmunmap(map->mmaped, bpf_map_mmap_sz(map));\n\t\tmap->mmaped = NULL;\n\t}\n\n\tif (map->st_ops) {\n\t\tzfree(&map->st_ops->data);\n\t\tzfree(&map->st_ops->progs);\n\t\tzfree(&map->st_ops->kern_func_off);\n\t\tzfree(&map->st_ops);\n\t}\n\n\tzfree(&map->name);\n\tzfree(&map->pin_path);\n\n\tif (map->fd >= 0)\n\t\tzclose(map->fd);\n}\n\nvoid bpf_object__close(struct bpf_object *obj)\n{\n\tsize_t i;\n\n\tif (IS_ERR_OR_NULL(obj))\n\t\treturn;\n\n\tif (obj->clear_priv)\n\t\tobj->clear_priv(obj, obj->priv);\n\n\tbpf_object__elf_finish(obj);\n\tbpf_object__unload(obj);\n\tbtf__free(obj->btf);\n\tbtf_ext__free(obj->btf_ext);\n\n\tfor (i = 0; i < obj->nr_maps; i++)\n\t\tbpf_map__destroy(&obj->maps[i]);\n\n\tzfree(&obj->kconfig);\n\tzfree(&obj->externs);\n\tobj->nr_extern = 0;\n\n\tzfree(&obj->maps);\n\tobj->nr_maps = 0;\n\n\tif (obj->programs && obj->nr_programs) {\n\t\tfor (i = 0; i < obj->nr_programs; i++)\n\t\t\tbpf_program__exit(&obj->programs[i]);\n\t}\n\tzfree(&obj->programs);\n\n\tlist_del(&obj->list);\n\tfree(obj);\n}\n\nstruct bpf_object *\nbpf_object__next(struct bpf_object *prev)\n{\n\tstruct bpf_object *next;\n\n\tif (!prev)\n\t\tnext = list_first_entry(&bpf_objects_list,\n\t\t\t\t\tstruct bpf_object,\n\t\t\t\t\tlist);\n\telse\n\t\tnext = list_next_entry(prev, list);\n\n\t/* Empty list is noticed here so don't need checking on entry. */\n\tif (&next->list == &bpf_objects_list)\n\t\treturn NULL;\n\n\treturn next;\n}\n\nconst char *bpf_object__name(const struct bpf_object *obj)\n{\n\treturn obj ? obj->name : ERR_PTR(-EINVAL);\n}\n\nunsigned int bpf_object__kversion(const struct bpf_object *obj)\n{\n\treturn obj ? obj->kern_version : 0;\n}\n\nstruct btf *bpf_object__btf(const struct bpf_object *obj)\n{\n\treturn obj ? obj->btf : NULL;\n}\n\nint bpf_object__btf_fd(const struct bpf_object *obj)\n{\n\treturn obj->btf ? btf__fd(obj->btf) : -1;\n}\n\nint bpf_object__set_priv(struct bpf_object *obj, void *priv,\n\t\t\t bpf_object_clear_priv_t clear_priv)\n{\n\tif (obj->priv && obj->clear_priv)\n\t\tobj->clear_priv(obj, obj->priv);\n\n\tobj->priv = priv;\n\tobj->clear_priv = clear_priv;\n\treturn 0;\n}\n\nvoid *bpf_object__priv(const struct bpf_object *obj)\n{\n\treturn obj ? obj->priv : ERR_PTR(-EINVAL);\n}\n\nstatic struct bpf_program *\n__bpf_program__iter(const struct bpf_program *p, const struct bpf_object *obj,\n\t\t    bool forward)\n{\n\tsize_t nr_programs = obj->nr_programs;\n\tssize_t idx;\n\n\tif (!nr_programs)\n\t\treturn NULL;\n\n\tif (!p)\n\t\t/* Iter from the beginning */\n\t\treturn forward ? &obj->programs[0] :\n\t\t\t&obj->programs[nr_programs - 1];\n\n\tif (p->obj != obj) {\n\t\tpr_warn(\"error: program handler doesn't match object\\n\");\n\t\treturn NULL;\n\t}\n\n\tidx = (p - obj->programs) + (forward ? 1 : -1);\n\tif (idx >= obj->nr_programs || idx < 0)\n\t\treturn NULL;\n\treturn &obj->programs[idx];\n}\n\nstruct bpf_program *\nbpf_program__next(struct bpf_program *prev, const struct bpf_object *obj)\n{\n\tstruct bpf_program *prog = prev;\n\n\tdo {\n\t\tprog = __bpf_program__iter(prog, obj, true);\n\t} while (prog && prog_is_subprog(obj, prog));\n\n\treturn prog;\n}\n\nstruct bpf_program *\nbpf_program__prev(struct bpf_program *next, const struct bpf_object *obj)\n{\n\tstruct bpf_program *prog = next;\n\n\tdo {\n\t\tprog = __bpf_program__iter(prog, obj, false);\n\t} while (prog && prog_is_subprog(obj, prog));\n\n\treturn prog;\n}\n\nint bpf_program__set_priv(struct bpf_program *prog, void *priv,\n\t\t\t  bpf_program_clear_priv_t clear_priv)\n{\n\tif (prog->priv && prog->clear_priv)\n\t\tprog->clear_priv(prog, prog->priv);\n\n\tprog->priv = priv;\n\tprog->clear_priv = clear_priv;\n\treturn 0;\n}\n\nvoid *bpf_program__priv(const struct bpf_program *prog)\n{\n\treturn prog ? prog->priv : ERR_PTR(-EINVAL);\n}\n\nvoid bpf_program__set_ifindex(struct bpf_program *prog, __u32 ifindex)\n{\n\tprog->prog_ifindex = ifindex;\n}\n\nconst char *bpf_program__name(const struct bpf_program *prog)\n{\n\treturn prog->name;\n}\n\nconst char *bpf_program__section_name(const struct bpf_program *prog)\n{\n\treturn prog->sec_name;\n}\n\nconst char *bpf_program__title(const struct bpf_program *prog, bool needs_copy)\n{\n\tconst char *title;\n\n\ttitle = prog->sec_name;\n\tif (needs_copy) {\n\t\ttitle = strdup(title);\n\t\tif (!title) {\n\t\t\tpr_warn(\"failed to strdup program title\\n\");\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\treturn title;\n}\n\nbool bpf_program__autoload(const struct bpf_program *prog)\n{\n\treturn prog->load;\n}\n\nint bpf_program__set_autoload(struct bpf_program *prog, bool autoload)\n{\n\tif (prog->obj->loaded)\n\t\treturn -EINVAL;\n\n\tprog->load = autoload;\n\treturn 0;\n}\n\nint bpf_program__fd(const struct bpf_program *prog)\n{\n\treturn bpf_program__nth_fd(prog, 0);\n}\n\nsize_t bpf_program__size(const struct bpf_program *prog)\n{\n\treturn prog->insns_cnt * BPF_INSN_SZ;\n}\n\nint bpf_program__set_prep(struct bpf_program *prog, int nr_instances,\n\t\t\t  bpf_program_prep_t prep)\n{\n\tint *instances_fds;\n\n\tif (nr_instances <= 0 || !prep)\n\t\treturn -EINVAL;\n\n\tif (prog->instances.nr > 0 || prog->instances.fds) {\n\t\tpr_warn(\"Can't set pre-processor after loading\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinstances_fds = malloc(sizeof(int) * nr_instances);\n\tif (!instances_fds) {\n\t\tpr_warn(\"alloc memory failed for fds\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* fill all fd with -1 */\n\tmemset(instances_fds, -1, sizeof(int) * nr_instances);\n\n\tprog->instances.nr = nr_instances;\n\tprog->instances.fds = instances_fds;\n\tprog->preprocessor = prep;\n\treturn 0;\n}\n\nint bpf_program__nth_fd(const struct bpf_program *prog, int n)\n{\n\tint fd;\n\n\tif (!prog)\n\t\treturn -EINVAL;\n\n\tif (n >= prog->instances.nr || n < 0) {\n\t\tpr_warn(\"Can't get the %dth fd from program %s: only %d instances\\n\",\n\t\t\tn, prog->name, prog->instances.nr);\n\t\treturn -EINVAL;\n\t}\n\n\tfd = prog->instances.fds[n];\n\tif (fd < 0) {\n\t\tpr_warn(\"%dth instance of program '%s' is invalid\\n\",\n\t\t\tn, prog->name);\n\t\treturn -ENOENT;\n\t}\n\n\treturn fd;\n}\n\nenum bpf_prog_type bpf_program__get_type(struct bpf_program *prog)\n{\n\treturn prog->type;\n}\n\nvoid bpf_program__set_type(struct bpf_program *prog, enum bpf_prog_type type)\n{\n\tprog->type = type;\n}\n\nstatic bool bpf_program__is_type(const struct bpf_program *prog,\n\t\t\t\t enum bpf_prog_type type)\n{\n\treturn prog ? (prog->type == type) : false;\n}\n\n#define BPF_PROG_TYPE_FNS(NAME, TYPE)\t\t\t\t\\\nint bpf_program__set_##NAME(struct bpf_program *prog)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tif (!prog)\t\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\\\n\tbpf_program__set_type(prog, TYPE);\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\nbool bpf_program__is_##NAME(const struct bpf_program *prog)\t\\\n{\t\t\t\t\t\t\t\t\\\n\treturn bpf_program__is_type(prog, TYPE);\t\t\\\n}\t\t\t\t\t\t\t\t\\\n\nBPF_PROG_TYPE_FNS(socket_filter, BPF_PROG_TYPE_SOCKET_FILTER);\nBPF_PROG_TYPE_FNS(lsm, BPF_PROG_TYPE_LSM);\nBPF_PROG_TYPE_FNS(kprobe, BPF_PROG_TYPE_KPROBE);\nBPF_PROG_TYPE_FNS(sched_cls, BPF_PROG_TYPE_SCHED_CLS);\nBPF_PROG_TYPE_FNS(sched_act, BPF_PROG_TYPE_SCHED_ACT);\nBPF_PROG_TYPE_FNS(tracepoint, BPF_PROG_TYPE_TRACEPOINT);\nBPF_PROG_TYPE_FNS(raw_tracepoint, BPF_PROG_TYPE_RAW_TRACEPOINT);\nBPF_PROG_TYPE_FNS(xdp, BPF_PROG_TYPE_XDP);\nBPF_PROG_TYPE_FNS(perf_event, BPF_PROG_TYPE_PERF_EVENT);\nBPF_PROG_TYPE_FNS(tracing, BPF_PROG_TYPE_TRACING);\nBPF_PROG_TYPE_FNS(struct_ops, BPF_PROG_TYPE_STRUCT_OPS);\nBPF_PROG_TYPE_FNS(extension, BPF_PROG_TYPE_EXT);\nBPF_PROG_TYPE_FNS(sk_lookup, BPF_PROG_TYPE_SK_LOOKUP);\n\nenum bpf_attach_type\nbpf_program__get_expected_attach_type(struct bpf_program *prog)\n{\n\treturn prog->expected_attach_type;\n}\n\nvoid bpf_program__set_expected_attach_type(struct bpf_program *prog,\n\t\t\t\t\t   enum bpf_attach_type type)\n{\n\tprog->expected_attach_type = type;\n}\n\n#define BPF_PROG_SEC_IMPL(string, ptype, eatype, eatype_optional,\t    \\\n\t\t\t  attachable, attach_btf)\t\t\t    \\\n\t{\t\t\t\t\t\t\t\t    \\\n\t\t.sec = string,\t\t\t\t\t\t    \\\n\t\t.len = sizeof(string) - 1,\t\t\t\t    \\\n\t\t.prog_type = ptype,\t\t\t\t\t    \\\n\t\t.expected_attach_type = eatype,\t\t\t\t    \\\n\t\t.is_exp_attach_type_optional = eatype_optional,\t\t    \\\n\t\t.is_attachable = attachable,\t\t\t\t    \\\n\t\t.is_attach_btf = attach_btf,\t\t\t\t    \\\n\t}\n\n/* Programs that can NOT be attached. */\n#define BPF_PROG_SEC(string, ptype) BPF_PROG_SEC_IMPL(string, ptype, 0, 0, 0, 0)\n\n/* Programs that can be attached. */\n#define BPF_APROG_SEC(string, ptype, atype) \\\n\tBPF_PROG_SEC_IMPL(string, ptype, atype, true, 1, 0)\n\n/* Programs that must specify expected attach type at load time. */\n#define BPF_EAPROG_SEC(string, ptype, eatype) \\\n\tBPF_PROG_SEC_IMPL(string, ptype, eatype, false, 1, 0)\n\n/* Programs that use BTF to identify attach point */\n#define BPF_PROG_BTF(string, ptype, eatype) \\\n\tBPF_PROG_SEC_IMPL(string, ptype, eatype, false, 0, 1)\n\n/* Programs that can be attached but attach type can't be identified by section\n * name. Kept for backward compatibility.\n */\n#define BPF_APROG_COMPAT(string, ptype) BPF_PROG_SEC(string, ptype)\n\n#define SEC_DEF(sec_pfx, ptype, ...) {\t\t\t\t\t    \\\n\t.sec = sec_pfx,\t\t\t\t\t\t\t    \\\n\t.len = sizeof(sec_pfx) - 1,\t\t\t\t\t    \\\n\t.prog_type = BPF_PROG_TYPE_##ptype,\t\t\t\t    \\\n\t__VA_ARGS__\t\t\t\t\t\t\t    \\\n}\n\nstatic struct bpf_link *attach_kprobe(const struct bpf_sec_def *sec,\n\t\t\t\t      struct bpf_program *prog);\nstatic struct bpf_link *attach_tp(const struct bpf_sec_def *sec,\n\t\t\t\t  struct bpf_program *prog);\nstatic struct bpf_link *attach_raw_tp(const struct bpf_sec_def *sec,\n\t\t\t\t      struct bpf_program *prog);\nstatic struct bpf_link *attach_trace(const struct bpf_sec_def *sec,\n\t\t\t\t     struct bpf_program *prog);\nstatic struct bpf_link *attach_lsm(const struct bpf_sec_def *sec,\n\t\t\t\t   struct bpf_program *prog);\nstatic struct bpf_link *attach_iter(const struct bpf_sec_def *sec,\n\t\t\t\t    struct bpf_program *prog);\n\nstatic const struct bpf_sec_def section_defs[] = {\n\tBPF_PROG_SEC(\"socket\",\t\t\tBPF_PROG_TYPE_SOCKET_FILTER),\n\tBPF_PROG_SEC(\"sk_reuseport\",\t\tBPF_PROG_TYPE_SK_REUSEPORT),\n\tSEC_DEF(\"kprobe/\", KPROBE,\n\t\t.attach_fn = attach_kprobe),\n\tBPF_PROG_SEC(\"uprobe/\",\t\t\tBPF_PROG_TYPE_KPROBE),\n\tSEC_DEF(\"kretprobe/\", KPROBE,\n\t\t.attach_fn = attach_kprobe),\n\tBPF_PROG_SEC(\"uretprobe/\",\t\tBPF_PROG_TYPE_KPROBE),\n\tBPF_PROG_SEC(\"classifier\",\t\tBPF_PROG_TYPE_SCHED_CLS),\n\tBPF_PROG_SEC(\"action\",\t\t\tBPF_PROG_TYPE_SCHED_ACT),\n\tSEC_DEF(\"tracepoint/\", TRACEPOINT,\n\t\t.attach_fn = attach_tp),\n\tSEC_DEF(\"tp/\", TRACEPOINT,\n\t\t.attach_fn = attach_tp),\n\tSEC_DEF(\"raw_tracepoint/\", RAW_TRACEPOINT,\n\t\t.attach_fn = attach_raw_tp),\n\tSEC_DEF(\"raw_tp/\", RAW_TRACEPOINT,\n\t\t.attach_fn = attach_raw_tp),\n\tSEC_DEF(\"tp_btf/\", TRACING,\n\t\t.expected_attach_type = BPF_TRACE_RAW_TP,\n\t\t.is_attach_btf = true,\n\t\t.attach_fn = attach_trace),\n\tSEC_DEF(\"fentry/\", TRACING,\n\t\t.expected_attach_type = BPF_TRACE_FENTRY,\n\t\t.is_attach_btf = true,\n\t\t.attach_fn = attach_trace),\n\tSEC_DEF(\"fmod_ret/\", TRACING,\n\t\t.expected_attach_type = BPF_MODIFY_RETURN,\n\t\t.is_attach_btf = true,\n\t\t.attach_fn = attach_trace),\n\tSEC_DEF(\"fexit/\", TRACING,\n\t\t.expected_attach_type = BPF_TRACE_FEXIT,\n\t\t.is_attach_btf = true,\n\t\t.attach_fn = attach_trace),\n\tSEC_DEF(\"fentry.s/\", TRACING,\n\t\t.expected_attach_type = BPF_TRACE_FENTRY,\n\t\t.is_attach_btf = true,\n\t\t.is_sleepable = true,\n\t\t.attach_fn = attach_trace),\n\tSEC_DEF(\"fmod_ret.s/\", TRACING,\n\t\t.expected_attach_type = BPF_MODIFY_RETURN,\n\t\t.is_attach_btf = true,\n\t\t.is_sleepable = true,\n\t\t.attach_fn = attach_trace),\n\tSEC_DEF(\"fexit.s/\", TRACING,\n\t\t.expected_attach_type = BPF_TRACE_FEXIT,\n\t\t.is_attach_btf = true,\n\t\t.is_sleepable = true,\n\t\t.attach_fn = attach_trace),\n\tSEC_DEF(\"freplace/\", EXT,\n\t\t.is_attach_btf = true,\n\t\t.attach_fn = attach_trace),\n\tSEC_DEF(\"lsm/\", LSM,\n\t\t.is_attach_btf = true,\n\t\t.expected_attach_type = BPF_LSM_MAC,\n\t\t.attach_fn = attach_lsm),\n\tSEC_DEF(\"lsm.s/\", LSM,\n\t\t.is_attach_btf = true,\n\t\t.is_sleepable = true,\n\t\t.expected_attach_type = BPF_LSM_MAC,\n\t\t.attach_fn = attach_lsm),\n\tSEC_DEF(\"iter/\", TRACING,\n\t\t.expected_attach_type = BPF_TRACE_ITER,\n\t\t.is_attach_btf = true,\n\t\t.attach_fn = attach_iter),\n\tBPF_EAPROG_SEC(\"xdp_devmap/\",\t\tBPF_PROG_TYPE_XDP,\n\t\t\t\t\t\tBPF_XDP_DEVMAP),\n\tBPF_EAPROG_SEC(\"xdp_cpumap/\",\t\tBPF_PROG_TYPE_XDP,\n\t\t\t\t\t\tBPF_XDP_CPUMAP),\n\tBPF_APROG_SEC(\"xdp\",\t\t\tBPF_PROG_TYPE_XDP,\n\t\t\t\t\t\tBPF_XDP),\n\tBPF_PROG_SEC(\"perf_event\",\t\tBPF_PROG_TYPE_PERF_EVENT),\n\tBPF_PROG_SEC(\"lwt_in\",\t\t\tBPF_PROG_TYPE_LWT_IN),\n\tBPF_PROG_SEC(\"lwt_out\",\t\t\tBPF_PROG_TYPE_LWT_OUT),\n\tBPF_PROG_SEC(\"lwt_xmit\",\t\tBPF_PROG_TYPE_LWT_XMIT),\n\tBPF_PROG_SEC(\"lwt_seg6local\",\t\tBPF_PROG_TYPE_LWT_SEG6LOCAL),\n\tBPF_APROG_SEC(\"cgroup_skb/ingress\",\tBPF_PROG_TYPE_CGROUP_SKB,\n\t\t\t\t\t\tBPF_CGROUP_INET_INGRESS),\n\tBPF_APROG_SEC(\"cgroup_skb/egress\",\tBPF_PROG_TYPE_CGROUP_SKB,\n\t\t\t\t\t\tBPF_CGROUP_INET_EGRESS),\n\tBPF_APROG_COMPAT(\"cgroup/skb\",\t\tBPF_PROG_TYPE_CGROUP_SKB),\n\tBPF_EAPROG_SEC(\"cgroup/sock_create\",\tBPF_PROG_TYPE_CGROUP_SOCK,\n\t\t\t\t\t\tBPF_CGROUP_INET_SOCK_CREATE),\n\tBPF_EAPROG_SEC(\"cgroup/sock_release\",\tBPF_PROG_TYPE_CGROUP_SOCK,\n\t\t\t\t\t\tBPF_CGROUP_INET_SOCK_RELEASE),\n\tBPF_APROG_SEC(\"cgroup/sock\",\t\tBPF_PROG_TYPE_CGROUP_SOCK,\n\t\t\t\t\t\tBPF_CGROUP_INET_SOCK_CREATE),\n\tBPF_EAPROG_SEC(\"cgroup/post_bind4\",\tBPF_PROG_TYPE_CGROUP_SOCK,\n\t\t\t\t\t\tBPF_CGROUP_INET4_POST_BIND),\n\tBPF_EAPROG_SEC(\"cgroup/post_bind6\",\tBPF_PROG_TYPE_CGROUP_SOCK,\n\t\t\t\t\t\tBPF_CGROUP_INET6_POST_BIND),\n\tBPF_APROG_SEC(\"cgroup/dev\",\t\tBPF_PROG_TYPE_CGROUP_DEVICE,\n\t\t\t\t\t\tBPF_CGROUP_DEVICE),\n\tBPF_APROG_SEC(\"sockops\",\t\tBPF_PROG_TYPE_SOCK_OPS,\n\t\t\t\t\t\tBPF_CGROUP_SOCK_OPS),\n\tBPF_APROG_SEC(\"sk_skb/stream_parser\",\tBPF_PROG_TYPE_SK_SKB,\n\t\t\t\t\t\tBPF_SK_SKB_STREAM_PARSER),\n\tBPF_APROG_SEC(\"sk_skb/stream_verdict\",\tBPF_PROG_TYPE_SK_SKB,\n\t\t\t\t\t\tBPF_SK_SKB_STREAM_VERDICT),\n\tBPF_APROG_COMPAT(\"sk_skb\",\t\tBPF_PROG_TYPE_SK_SKB),\n\tBPF_APROG_SEC(\"sk_msg\",\t\t\tBPF_PROG_TYPE_SK_MSG,\n\t\t\t\t\t\tBPF_SK_MSG_VERDICT),\n\tBPF_APROG_SEC(\"lirc_mode2\",\t\tBPF_PROG_TYPE_LIRC_MODE2,\n\t\t\t\t\t\tBPF_LIRC_MODE2),\n\tBPF_APROG_SEC(\"flow_dissector\",\t\tBPF_PROG_TYPE_FLOW_DISSECTOR,\n\t\t\t\t\t\tBPF_FLOW_DISSECTOR),\n\tBPF_EAPROG_SEC(\"cgroup/bind4\",\t\tBPF_PROG_TYPE_CGROUP_SOCK_ADDR,\n\t\t\t\t\t\tBPF_CGROUP_INET4_BIND),\n\tBPF_EAPROG_SEC(\"cgroup/bind6\",\t\tBPF_PROG_TYPE_CGROUP_SOCK_ADDR,\n\t\t\t\t\t\tBPF_CGROUP_INET6_BIND),\n\tBPF_EAPROG_SEC(\"cgroup/connect4\",\tBPF_PROG_TYPE_CGROUP_SOCK_ADDR,\n\t\t\t\t\t\tBPF_CGROUP_INET4_CONNECT),\n\tBPF_EAPROG_SEC(\"cgroup/connect6\",\tBPF_PROG_TYPE_CGROUP_SOCK_ADDR,\n\t\t\t\t\t\tBPF_CGROUP_INET6_CONNECT),\n\tBPF_EAPROG_SEC(\"cgroup/sendmsg4\",\tBPF_PROG_TYPE_CGROUP_SOCK_ADDR,\n\t\t\t\t\t\tBPF_CGROUP_UDP4_SENDMSG),\n\tBPF_EAPROG_SEC(\"cgroup/sendmsg6\",\tBPF_PROG_TYPE_CGROUP_SOCK_ADDR,\n\t\t\t\t\t\tBPF_CGROUP_UDP6_SENDMSG),\n\tBPF_EAPROG_SEC(\"cgroup/recvmsg4\",\tBPF_PROG_TYPE_CGROUP_SOCK_ADDR,\n\t\t\t\t\t\tBPF_CGROUP_UDP4_RECVMSG),\n\tBPF_EAPROG_SEC(\"cgroup/recvmsg6\",\tBPF_PROG_TYPE_CGROUP_SOCK_ADDR,\n\t\t\t\t\t\tBPF_CGROUP_UDP6_RECVMSG),\n\tBPF_EAPROG_SEC(\"cgroup/getpeername4\",\tBPF_PROG_TYPE_CGROUP_SOCK_ADDR,\n\t\t\t\t\t\tBPF_CGROUP_INET4_GETPEERNAME),\n\tBPF_EAPROG_SEC(\"cgroup/getpeername6\",\tBPF_PROG_TYPE_CGROUP_SOCK_ADDR,\n\t\t\t\t\t\tBPF_CGROUP_INET6_GETPEERNAME),\n\tBPF_EAPROG_SEC(\"cgroup/getsockname4\",\tBPF_PROG_TYPE_CGROUP_SOCK_ADDR,\n\t\t\t\t\t\tBPF_CGROUP_INET4_GETSOCKNAME),\n\tBPF_EAPROG_SEC(\"cgroup/getsockname6\",\tBPF_PROG_TYPE_CGROUP_SOCK_ADDR,\n\t\t\t\t\t\tBPF_CGROUP_INET6_GETSOCKNAME),\n\tBPF_EAPROG_SEC(\"cgroup/sysctl\",\t\tBPF_PROG_TYPE_CGROUP_SYSCTL,\n\t\t\t\t\t\tBPF_CGROUP_SYSCTL),\n\tBPF_EAPROG_SEC(\"cgroup/getsockopt\",\tBPF_PROG_TYPE_CGROUP_SOCKOPT,\n\t\t\t\t\t\tBPF_CGROUP_GETSOCKOPT),\n\tBPF_EAPROG_SEC(\"cgroup/setsockopt\",\tBPF_PROG_TYPE_CGROUP_SOCKOPT,\n\t\t\t\t\t\tBPF_CGROUP_SETSOCKOPT),\n\tBPF_PROG_SEC(\"struct_ops\",\t\tBPF_PROG_TYPE_STRUCT_OPS),\n\tBPF_EAPROG_SEC(\"sk_lookup/\",\t\tBPF_PROG_TYPE_SK_LOOKUP,\n\t\t\t\t\t\tBPF_SK_LOOKUP),\n};\n\n#undef BPF_PROG_SEC_IMPL\n#undef BPF_PROG_SEC\n#undef BPF_APROG_SEC\n#undef BPF_EAPROG_SEC\n#undef BPF_APROG_COMPAT\n#undef SEC_DEF\n\n#define MAX_TYPE_NAME_SIZE 32\n\nstatic const struct bpf_sec_def *find_sec_def(const char *sec_name)\n{\n\tint i, n = ARRAY_SIZE(section_defs);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (strncmp(sec_name,\n\t\t\t    section_defs[i].sec, section_defs[i].len))\n\t\t\tcontinue;\n\t\treturn &section_defs[i];\n\t}\n\treturn NULL;\n}\n\nstatic char *libbpf_get_type_names(bool attach_type)\n{\n\tint i, len = ARRAY_SIZE(section_defs) * MAX_TYPE_NAME_SIZE;\n\tchar *buf;\n\n\tbuf = malloc(len);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf[0] = '\\0';\n\t/* Forge string buf with all available names */\n\tfor (i = 0; i < ARRAY_SIZE(section_defs); i++) {\n\t\tif (attach_type && !section_defs[i].is_attachable)\n\t\t\tcontinue;\n\n\t\tif (strlen(buf) + strlen(section_defs[i].sec) + 2 > len) {\n\t\t\tfree(buf);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcat(buf, \" \");\n\t\tstrcat(buf, section_defs[i].sec);\n\t}\n\n\treturn buf;\n}\n\nint libbpf_prog_type_by_name(const char *name, enum bpf_prog_type *prog_type,\n\t\t\t     enum bpf_attach_type *expected_attach_type)\n{\n\tconst struct bpf_sec_def *sec_def;\n\tchar *type_names;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tsec_def = find_sec_def(name);\n\tif (sec_def) {\n\t\t*prog_type = sec_def->prog_type;\n\t\t*expected_attach_type = sec_def->expected_attach_type;\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"failed to guess program type from ELF section '%s'\\n\", name);\n\ttype_names = libbpf_get_type_names(false);\n\tif (type_names != NULL) {\n\t\tpr_debug(\"supported section(type) names are:%s\\n\", type_names);\n\t\tfree(type_names);\n\t}\n\n\treturn -ESRCH;\n}\n\nstatic struct bpf_map *find_struct_ops_map_by_offset(struct bpf_object *obj,\n\t\t\t\t\t\t     size_t offset)\n{\n\tstruct bpf_map *map;\n\tsize_t i;\n\n\tfor (i = 0; i < obj->nr_maps; i++) {\n\t\tmap = &obj->maps[i];\n\t\tif (!bpf_map__is_struct_ops(map))\n\t\t\tcontinue;\n\t\tif (map->sec_offset <= offset &&\n\t\t    offset - map->sec_offset < map->def.value_size)\n\t\t\treturn map;\n\t}\n\n\treturn NULL;\n}\n\n/* Collect the reloc from ELF and populate the st_ops->progs[] */\nstatic int bpf_object__collect_st_ops_relos(struct bpf_object *obj,\n\t\t\t\t\t    GElf_Shdr *shdr, Elf_Data *data)\n{\n\tconst struct btf_member *member;\n\tstruct bpf_struct_ops *st_ops;\n\tstruct bpf_program *prog;\n\tunsigned int shdr_idx;\n\tconst struct btf *btf;\n\tstruct bpf_map *map;\n\tElf_Data *symbols;\n\tunsigned int moff, insn_idx;\n\tconst char *name;\n\t__u32 member_idx;\n\tGElf_Sym sym;\n\tGElf_Rel rel;\n\tint i, nrels;\n\n\tsymbols = obj->efile.symbols;\n\tbtf = obj->btf;\n\tnrels = shdr->sh_size / shdr->sh_entsize;\n\tfor (i = 0; i < nrels; i++) {\n\t\tif (!gelf_getrel(data, i, &rel)) {\n\t\t\tpr_warn(\"struct_ops reloc: failed to get %d reloc\\n\", i);\n\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t\t}\n\n\t\tif (!gelf_getsym(symbols, GELF_R_SYM(rel.r_info), &sym)) {\n\t\t\tpr_warn(\"struct_ops reloc: symbol %zx not found\\n\",\n\t\t\t\t(size_t)GELF_R_SYM(rel.r_info));\n\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t\t}\n\n\t\tname = elf_sym_str(obj, sym.st_name) ?: \"<?>\";\n\t\tmap = find_struct_ops_map_by_offset(obj, rel.r_offset);\n\t\tif (!map) {\n\t\t\tpr_warn(\"struct_ops reloc: cannot find map at rel.r_offset %zu\\n\",\n\t\t\t\t(size_t)rel.r_offset);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmoff = rel.r_offset - map->sec_offset;\n\t\tshdr_idx = sym.st_shndx;\n\t\tst_ops = map->st_ops;\n\t\tpr_debug(\"struct_ops reloc %s: for %lld value %lld shdr_idx %u rel.r_offset %zu map->sec_offset %zu name %d (\\'%s\\')\\n\",\n\t\t\t map->name,\n\t\t\t (long long)(rel.r_info >> 32),\n\t\t\t (long long)sym.st_value,\n\t\t\t shdr_idx, (size_t)rel.r_offset,\n\t\t\t map->sec_offset, sym.st_name, name);\n\n\t\tif (shdr_idx >= SHN_LORESERVE) {\n\t\t\tpr_warn(\"struct_ops reloc %s: rel.r_offset %zu shdr_idx %u unsupported non-static function\\n\",\n\t\t\t\tmap->name, (size_t)rel.r_offset, shdr_idx);\n\t\t\treturn -LIBBPF_ERRNO__RELOC;\n\t\t}\n\t\tif (sym.st_value % BPF_INSN_SZ) {\n\t\t\tpr_warn(\"struct_ops reloc %s: invalid target program offset %llu\\n\",\n\t\t\t\tmap->name, (unsigned long long)sym.st_value);\n\t\t\treturn -LIBBPF_ERRNO__FORMAT;\n\t\t}\n\t\tinsn_idx = sym.st_value / BPF_INSN_SZ;\n\n\t\tmember = find_member_by_offset(st_ops->type, moff * 8);\n\t\tif (!member) {\n\t\t\tpr_warn(\"struct_ops reloc %s: cannot find member at moff %u\\n\",\n\t\t\t\tmap->name, moff);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmember_idx = member - btf_members(st_ops->type);\n\t\tname = btf__name_by_offset(btf, member->name_off);\n\n\t\tif (!resolve_func_ptr(btf, member->type, NULL)) {\n\t\t\tpr_warn(\"struct_ops reloc %s: cannot relocate non func ptr %s\\n\",\n\t\t\t\tmap->name, name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprog = find_prog_by_sec_insn(obj, shdr_idx, insn_idx);\n\t\tif (!prog) {\n\t\t\tpr_warn(\"struct_ops reloc %s: cannot find prog at shdr_idx %u to relocate func ptr %s\\n\",\n\t\t\t\tmap->name, shdr_idx, name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (prog->type == BPF_PROG_TYPE_UNSPEC) {\n\t\t\tconst struct bpf_sec_def *sec_def;\n\n\t\t\tsec_def = find_sec_def(prog->sec_name);\n\t\t\tif (sec_def &&\n\t\t\t    sec_def->prog_type != BPF_PROG_TYPE_STRUCT_OPS) {\n\t\t\t\t/* for pr_warn */\n\t\t\t\tprog->type = sec_def->prog_type;\n\t\t\t\tgoto invalid_prog;\n\t\t\t}\n\n\t\t\tprog->type = BPF_PROG_TYPE_STRUCT_OPS;\n\t\t\tprog->attach_btf_id = st_ops->type_id;\n\t\t\tprog->expected_attach_type = member_idx;\n\t\t} else if (prog->type != BPF_PROG_TYPE_STRUCT_OPS ||\n\t\t\t   prog->attach_btf_id != st_ops->type_id ||\n\t\t\t   prog->expected_attach_type != member_idx) {\n\t\t\tgoto invalid_prog;\n\t\t}\n\t\tst_ops->progs[member_idx] = prog;\n\t}\n\n\treturn 0;\n\ninvalid_prog:\n\tpr_warn(\"struct_ops reloc %s: cannot use prog %s in sec %s with type %u attach_btf_id %u expected_attach_type %u for func ptr %s\\n\",\n\t\tmap->name, prog->name, prog->sec_name, prog->type,\n\t\tprog->attach_btf_id, prog->expected_attach_type, name);\n\treturn -EINVAL;\n}\n\n#define BTF_TRACE_PREFIX \"btf_trace_\"\n#define BTF_LSM_PREFIX \"bpf_lsm_\"\n#define BTF_ITER_PREFIX \"bpf_iter_\"\n#define BTF_MAX_NAME_SIZE 128\n\nstatic int find_btf_by_prefix_kind(const struct btf *btf, const char *prefix,\n\t\t\t\t   const char *name, __u32 kind)\n{\n\tchar btf_type_name[BTF_MAX_NAME_SIZE];\n\tint ret;\n\n\tret = snprintf(btf_type_name, sizeof(btf_type_name),\n\t\t       \"%s%s\", prefix, name);\n\t/* snprintf returns the number of characters written excluding the\n\t * the terminating null. So, if >= BTF_MAX_NAME_SIZE are written, it\n\t * indicates truncation.\n\t */\n\tif (ret < 0 || ret >= sizeof(btf_type_name))\n\t\treturn -ENAMETOOLONG;\n\treturn btf__find_by_name_kind(btf, btf_type_name, kind);\n}\n\nstatic inline int __find_vmlinux_btf_id(struct btf *btf, const char *name,\n\t\t\t\t\tenum bpf_attach_type attach_type)\n{\n\tint err;\n\n\tif (attach_type == BPF_TRACE_RAW_TP)\n\t\terr = find_btf_by_prefix_kind(btf, BTF_TRACE_PREFIX, name,\n\t\t\t\t\t      BTF_KIND_TYPEDEF);\n\telse if (attach_type == BPF_LSM_MAC)\n\t\terr = find_btf_by_prefix_kind(btf, BTF_LSM_PREFIX, name,\n\t\t\t\t\t      BTF_KIND_FUNC);\n\telse if (attach_type == BPF_TRACE_ITER)\n\t\terr = find_btf_by_prefix_kind(btf, BTF_ITER_PREFIX, name,\n\t\t\t\t\t      BTF_KIND_FUNC);\n\telse\n\t\terr = btf__find_by_name_kind(btf, name, BTF_KIND_FUNC);\n\n\tif (err <= 0)\n\t\tpr_warn(\"%s is not found in vmlinux BTF\\n\", name);\n\n\treturn err;\n}\n\nint libbpf_find_vmlinux_btf_id(const char *name,\n\t\t\t       enum bpf_attach_type attach_type)\n{\n\tstruct btf *btf;\n\tint err;\n\n\tbtf = libbpf_find_kernel_btf();\n\tif (IS_ERR(btf)) {\n\t\tpr_warn(\"vmlinux BTF is not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = __find_vmlinux_btf_id(btf, name, attach_type);\n\tbtf__free(btf);\n\treturn err;\n}\n\nstatic int libbpf_find_prog_btf_id(const char *name, __u32 attach_prog_fd)\n{\n\tstruct bpf_prog_info_linear *info_linear;\n\tstruct bpf_prog_info *info;\n\tstruct btf *btf = NULL;\n\tint err = -EINVAL;\n\n\tinfo_linear = bpf_program__get_prog_info_linear(attach_prog_fd, 0);\n\tif (IS_ERR_OR_NULL(info_linear)) {\n\t\tpr_warn(\"failed get_prog_info_linear for FD %d\\n\",\n\t\t\tattach_prog_fd);\n\t\treturn -EINVAL;\n\t}\n\tinfo = &info_linear->info;\n\tif (!info->btf_id) {\n\t\tpr_warn(\"The target program doesn't have BTF\\n\");\n\t\tgoto out;\n\t}\n\tif (btf__get_from_id(info->btf_id, &btf)) {\n\t\tpr_warn(\"Failed to get BTF of the program\\n\");\n\t\tgoto out;\n\t}\n\terr = btf__find_by_name_kind(btf, name, BTF_KIND_FUNC);\n\tbtf__free(btf);\n\tif (err <= 0) {\n\t\tpr_warn(\"%s is not found in prog's BTF\\n\", name);\n\t\tgoto out;\n\t}\nout:\n\tfree(info_linear);\n\treturn err;\n}\n\nstatic int libbpf_find_attach_btf_id(struct bpf_program *prog)\n{\n\tenum bpf_attach_type attach_type = prog->expected_attach_type;\n\t__u32 attach_prog_fd = prog->attach_prog_fd;\n\tconst char *name = prog->sec_name;\n\tint i, err;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(section_defs); i++) {\n\t\tif (!section_defs[i].is_attach_btf)\n\t\t\tcontinue;\n\t\tif (strncmp(name, section_defs[i].sec, section_defs[i].len))\n\t\t\tcontinue;\n\t\tif (attach_prog_fd)\n\t\t\terr = libbpf_find_prog_btf_id(name + section_defs[i].len,\n\t\t\t\t\t\t      attach_prog_fd);\n\t\telse\n\t\t\terr = __find_vmlinux_btf_id(prog->obj->btf_vmlinux,\n\t\t\t\t\t\t    name + section_defs[i].len,\n\t\t\t\t\t\t    attach_type);\n\t\treturn err;\n\t}\n\tpr_warn(\"failed to identify btf_id based on ELF section name '%s'\\n\", name);\n\treturn -ESRCH;\n}\n\nint libbpf_attach_type_by_name(const char *name,\n\t\t\t       enum bpf_attach_type *attach_type)\n{\n\tchar *type_names;\n\tint i;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(section_defs); i++) {\n\t\tif (strncmp(name, section_defs[i].sec, section_defs[i].len))\n\t\t\tcontinue;\n\t\tif (!section_defs[i].is_attachable)\n\t\t\treturn -EINVAL;\n\t\t*attach_type = section_defs[i].expected_attach_type;\n\t\treturn 0;\n\t}\n\tpr_debug(\"failed to guess attach type based on ELF section name '%s'\\n\", name);\n\ttype_names = libbpf_get_type_names(true);\n\tif (type_names != NULL) {\n\t\tpr_debug(\"attachable section(type) names are:%s\\n\", type_names);\n\t\tfree(type_names);\n\t}\n\n\treturn -EINVAL;\n}\n\nint bpf_map__fd(const struct bpf_map *map)\n{\n\treturn map ? map->fd : -EINVAL;\n}\n\nconst struct bpf_map_def *bpf_map__def(const struct bpf_map *map)\n{\n\treturn map ? &map->def : ERR_PTR(-EINVAL);\n}\n\nconst char *bpf_map__name(const struct bpf_map *map)\n{\n\treturn map ? map->name : NULL;\n}\n\nenum bpf_map_type bpf_map__type(const struct bpf_map *map)\n{\n\treturn map->def.type;\n}\n\nint bpf_map__set_type(struct bpf_map *map, enum bpf_map_type type)\n{\n\tif (map->fd >= 0)\n\t\treturn -EBUSY;\n\tmap->def.type = type;\n\treturn 0;\n}\n\n__u32 bpf_map__map_flags(const struct bpf_map *map)\n{\n\treturn map->def.map_flags;\n}\n\nint bpf_map__set_map_flags(struct bpf_map *map, __u32 flags)\n{\n\tif (map->fd >= 0)\n\t\treturn -EBUSY;\n\tmap->def.map_flags = flags;\n\treturn 0;\n}\n\n__u32 bpf_map__numa_node(const struct bpf_map *map)\n{\n\treturn map->numa_node;\n}\n\nint bpf_map__set_numa_node(struct bpf_map *map, __u32 numa_node)\n{\n\tif (map->fd >= 0)\n\t\treturn -EBUSY;\n\tmap->numa_node = numa_node;\n\treturn 0;\n}\n\n__u32 bpf_map__key_size(const struct bpf_map *map)\n{\n\treturn map->def.key_size;\n}\n\nint bpf_map__set_key_size(struct bpf_map *map, __u32 size)\n{\n\tif (map->fd >= 0)\n\t\treturn -EBUSY;\n\tmap->def.key_size = size;\n\treturn 0;\n}\n\n__u32 bpf_map__value_size(const struct bpf_map *map)\n{\n\treturn map->def.value_size;\n}\n\nint bpf_map__set_value_size(struct bpf_map *map, __u32 size)\n{\n\tif (map->fd >= 0)\n\t\treturn -EBUSY;\n\tmap->def.value_size = size;\n\treturn 0;\n}\n\n__u32 bpf_map__btf_key_type_id(const struct bpf_map *map)\n{\n\treturn map ? map->btf_key_type_id : 0;\n}\n\n__u32 bpf_map__btf_value_type_id(const struct bpf_map *map)\n{\n\treturn map ? map->btf_value_type_id : 0;\n}\n\nint bpf_map__set_priv(struct bpf_map *map, void *priv,\n\t\t     bpf_map_clear_priv_t clear_priv)\n{\n\tif (!map)\n\t\treturn -EINVAL;\n\n\tif (map->priv) {\n\t\tif (map->clear_priv)\n\t\t\tmap->clear_priv(map, map->priv);\n\t}\n\n\tmap->priv = priv;\n\tmap->clear_priv = clear_priv;\n\treturn 0;\n}\n\nvoid *bpf_map__priv(const struct bpf_map *map)\n{\n\treturn map ? map->priv : ERR_PTR(-EINVAL);\n}\n\nint bpf_map__set_initial_value(struct bpf_map *map,\n\t\t\t       const void *data, size_t size)\n{\n\tif (!map->mmaped || map->libbpf_type == LIBBPF_MAP_KCONFIG ||\n\t    size != map->def.value_size || map->fd >= 0)\n\t\treturn -EINVAL;\n\n\tmemcpy(map->mmaped, data, size);\n\treturn 0;\n}\n\nbool bpf_map__is_offload_neutral(const struct bpf_map *map)\n{\n\treturn map->def.type == BPF_MAP_TYPE_PERF_EVENT_ARRAY;\n}\n\nbool bpf_map__is_internal(const struct bpf_map *map)\n{\n\treturn map->libbpf_type != LIBBPF_MAP_UNSPEC;\n}\n\n__u32 bpf_map__ifindex(const struct bpf_map *map)\n{\n\treturn map->map_ifindex;\n}\n\nint bpf_map__set_ifindex(struct bpf_map *map, __u32 ifindex)\n{\n\tif (map->fd >= 0)\n\t\treturn -EBUSY;\n\tmap->map_ifindex = ifindex;\n\treturn 0;\n}\n\nint bpf_map__set_inner_map_fd(struct bpf_map *map, int fd)\n{\n\tif (!bpf_map_type__is_map_in_map(map->def.type)) {\n\t\tpr_warn(\"error: unsupported map type\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (map->inner_map_fd != -1) {\n\t\tpr_warn(\"error: inner_map_fd already specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmap->inner_map_fd = fd;\n\treturn 0;\n}\n\nstatic struct bpf_map *\n__bpf_map__iter(const struct bpf_map *m, const struct bpf_object *obj, int i)\n{\n\tssize_t idx;\n\tstruct bpf_map *s, *e;\n\n\tif (!obj || !obj->maps)\n\t\treturn NULL;\n\n\ts = obj->maps;\n\te = obj->maps + obj->nr_maps;\n\n\tif ((m < s) || (m >= e)) {\n\t\tpr_warn(\"error in %s: map handler doesn't belong to object\\n\",\n\t\t\t __func__);\n\t\treturn NULL;\n\t}\n\n\tidx = (m - obj->maps) + i;\n\tif (idx >= obj->nr_maps || idx < 0)\n\t\treturn NULL;\n\treturn &obj->maps[idx];\n}\n\nstruct bpf_map *\nbpf_map__next(const struct bpf_map *prev, const struct bpf_object *obj)\n{\n\tif (prev == NULL)\n\t\treturn obj->maps;\n\n\treturn __bpf_map__iter(prev, obj, 1);\n}\n\nstruct bpf_map *\nbpf_map__prev(const struct bpf_map *next, const struct bpf_object *obj)\n{\n\tif (next == NULL) {\n\t\tif (!obj->nr_maps)\n\t\t\treturn NULL;\n\t\treturn obj->maps + obj->nr_maps - 1;\n\t}\n\n\treturn __bpf_map__iter(next, obj, -1);\n}\n\nstruct bpf_map *\nbpf_object__find_map_by_name(const struct bpf_object *obj, const char *name)\n{\n\tstruct bpf_map *pos;\n\n\tbpf_object__for_each_map(pos, obj) {\n\t\tif (pos->name && !strcmp(pos->name, name))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\nint\nbpf_object__find_map_fd_by_name(const struct bpf_object *obj, const char *name)\n{\n\treturn bpf_map__fd(bpf_object__find_map_by_name(obj, name));\n}\n\nstruct bpf_map *\nbpf_object__find_map_by_offset(struct bpf_object *obj, size_t offset)\n{\n\treturn ERR_PTR(-ENOTSUP);\n}\n\nlong libbpf_get_error(const void *ptr)\n{\n\treturn PTR_ERR_OR_ZERO(ptr);\n}\n\nint bpf_prog_load(const char *file, enum bpf_prog_type type,\n\t\t  struct bpf_object **pobj, int *prog_fd)\n{\n\tstruct bpf_prog_load_attr attr;\n\n\tmemset(&attr, 0, sizeof(struct bpf_prog_load_attr));\n\tattr.file = file;\n\tattr.prog_type = type;\n\tattr.expected_attach_type = 0;\n\n\treturn bpf_prog_load_xattr(&attr, pobj, prog_fd);\n}\n\nint bpf_prog_load_xattr(const struct bpf_prog_load_attr *attr,\n\t\t\tstruct bpf_object **pobj, int *prog_fd)\n{\n\tstruct bpf_object_open_attr open_attr = {};\n\tstruct bpf_program *prog, *first_prog = NULL;\n\tstruct bpf_object *obj;\n\tstruct bpf_map *map;\n\tint err;\n\n\tif (!attr)\n\t\treturn -EINVAL;\n\tif (!attr->file)\n\t\treturn -EINVAL;\n\n\topen_attr.file = attr->file;\n\topen_attr.prog_type = attr->prog_type;\n\n\tobj = bpf_object__open_xattr(&open_attr);\n\tif (IS_ERR_OR_NULL(obj))\n\t\treturn -ENOENT;\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tenum bpf_attach_type attach_type = attr->expected_attach_type;\n\t\t/*\n\t\t * to preserve backwards compatibility, bpf_prog_load treats\n\t\t * attr->prog_type, if specified, as an override to whatever\n\t\t * bpf_object__open guessed\n\t\t */\n\t\tif (attr->prog_type != BPF_PROG_TYPE_UNSPEC) {\n\t\t\tbpf_program__set_type(prog, attr->prog_type);\n\t\t\tbpf_program__set_expected_attach_type(prog,\n\t\t\t\t\t\t\t      attach_type);\n\t\t}\n\t\tif (bpf_program__get_type(prog) == BPF_PROG_TYPE_UNSPEC) {\n\t\t\t/*\n\t\t\t * we haven't guessed from section name and user\n\t\t\t * didn't provide a fallback type, too bad...\n\t\t\t */\n\t\t\tbpf_object__close(obj);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprog->prog_ifindex = attr->ifindex;\n\t\tprog->log_level = attr->log_level;\n\t\tprog->prog_flags |= attr->prog_flags;\n\t\tif (!first_prog)\n\t\t\tfirst_prog = prog;\n\t}\n\n\tbpf_object__for_each_map(map, obj) {\n\t\tif (!bpf_map__is_offload_neutral(map))\n\t\t\tmap->map_ifindex = attr->ifindex;\n\t}\n\n\tif (!first_prog) {\n\t\tpr_warn(\"object file doesn't contain bpf program\\n\");\n\t\tbpf_object__close(obj);\n\t\treturn -ENOENT;\n\t}\n\n\terr = bpf_object__load(obj);\n\tif (err) {\n\t\tbpf_object__close(obj);\n\t\treturn err;\n\t}\n\n\t*pobj = obj;\n\t*prog_fd = bpf_program__fd(first_prog);\n\treturn 0;\n}\n\nstruct bpf_link {\n\tint (*detach)(struct bpf_link *link);\n\tint (*destroy)(struct bpf_link *link);\n\tchar *pin_path;\t\t/* NULL, if not pinned */\n\tint fd;\t\t\t/* hook FD, -1 if not applicable */\n\tbool disconnected;\n};\n\n/* Replace link's underlying BPF program with the new one */\nint bpf_link__update_program(struct bpf_link *link, struct bpf_program *prog)\n{\n\treturn bpf_link_update(bpf_link__fd(link), bpf_program__fd(prog), NULL);\n}\n\n/* Release \"ownership\" of underlying BPF resource (typically, BPF program\n * attached to some BPF hook, e.g., tracepoint, kprobe, etc). Disconnected\n * link, when destructed through bpf_link__destroy() call won't attempt to\n * detach/unregisted that BPF resource. This is useful in situations where,\n * say, attached BPF program has to outlive userspace program that attached it\n * in the system. Depending on type of BPF program, though, there might be\n * additional steps (like pinning BPF program in BPF FS) necessary to ensure\n * exit of userspace program doesn't trigger automatic detachment and clean up\n * inside the kernel.\n */\nvoid bpf_link__disconnect(struct bpf_link *link)\n{\n\tlink->disconnected = true;\n}\n\nint bpf_link__destroy(struct bpf_link *link)\n{\n\tint err = 0;\n\n\tif (IS_ERR_OR_NULL(link))\n\t\treturn 0;\n\n\tif (!link->disconnected && link->detach)\n\t\terr = link->detach(link);\n\tif (link->destroy)\n\t\tlink->destroy(link);\n\tif (link->pin_path)\n\t\tfree(link->pin_path);\n\tfree(link);\n\n\treturn err;\n}\n\nint bpf_link__fd(const struct bpf_link *link)\n{\n\treturn link->fd;\n}\n\nconst char *bpf_link__pin_path(const struct bpf_link *link)\n{\n\treturn link->pin_path;\n}\n\nstatic int bpf_link__detach_fd(struct bpf_link *link)\n{\n\treturn close(link->fd);\n}\n\nstruct bpf_link *bpf_link__open(const char *path)\n{\n\tstruct bpf_link *link;\n\tint fd;\n\n\tfd = bpf_obj_get(path);\n\tif (fd < 0) {\n\t\tfd = -errno;\n\t\tpr_warn(\"failed to open link at %s: %d\\n\", path, fd);\n\t\treturn ERR_PTR(fd);\n\t}\n\n\tlink = calloc(1, sizeof(*link));\n\tif (!link) {\n\t\tclose(fd);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlink->detach = &bpf_link__detach_fd;\n\tlink->fd = fd;\n\n\tlink->pin_path = strdup(path);\n\tif (!link->pin_path) {\n\t\tbpf_link__destroy(link);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn link;\n}\n\nint bpf_link__detach(struct bpf_link *link)\n{\n\treturn bpf_link_detach(link->fd) ? -errno : 0;\n}\n\nint bpf_link__pin(struct bpf_link *link, const char *path)\n{\n\tint err;\n\n\tif (link->pin_path)\n\t\treturn -EBUSY;\n\terr = make_parent_dir(path);\n\tif (err)\n\t\treturn err;\n\terr = check_path(path);\n\tif (err)\n\t\treturn err;\n\n\tlink->pin_path = strdup(path);\n\tif (!link->pin_path)\n\t\treturn -ENOMEM;\n\n\tif (bpf_obj_pin(link->fd, link->pin_path)) {\n\t\terr = -errno;\n\t\tzfree(&link->pin_path);\n\t\treturn err;\n\t}\n\n\tpr_debug(\"link fd=%d: pinned at %s\\n\", link->fd, link->pin_path);\n\treturn 0;\n}\n\nint bpf_link__unpin(struct bpf_link *link)\n{\n\tint err;\n\n\tif (!link->pin_path)\n\t\treturn -EINVAL;\n\n\terr = unlink(link->pin_path);\n\tif (err != 0)\n\t\treturn -errno;\n\n\tpr_debug(\"link fd=%d: unpinned from %s\\n\", link->fd, link->pin_path);\n\tzfree(&link->pin_path);\n\treturn 0;\n}\n\nstatic int bpf_link__detach_perf_event(struct bpf_link *link)\n{\n\tint err;\n\n\terr = ioctl(link->fd, PERF_EVENT_IOC_DISABLE, 0);\n\tif (err)\n\t\terr = -errno;\n\n\tclose(link->fd);\n\treturn err;\n}\n\nstruct bpf_link *bpf_program__attach_perf_event(struct bpf_program *prog,\n\t\t\t\t\t\tint pfd)\n{\n\tchar errmsg[STRERR_BUFSIZE];\n\tstruct bpf_link *link;\n\tint prog_fd, err;\n\n\tif (pfd < 0) {\n\t\tpr_warn(\"prog '%s': invalid perf event FD %d\\n\",\n\t\t\tprog->name, pfd);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tprog_fd = bpf_program__fd(prog);\n\tif (prog_fd < 0) {\n\t\tpr_warn(\"prog '%s': can't attach BPF program w/o FD (did you load it?)\\n\",\n\t\t\tprog->name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlink = calloc(1, sizeof(*link));\n\tif (!link)\n\t\treturn ERR_PTR(-ENOMEM);\n\tlink->detach = &bpf_link__detach_perf_event;\n\tlink->fd = pfd;\n\n\tif (ioctl(pfd, PERF_EVENT_IOC_SET_BPF, prog_fd) < 0) {\n\t\terr = -errno;\n\t\tfree(link);\n\t\tpr_warn(\"prog '%s': failed to attach to pfd %d: %s\\n\",\n\t\t\tprog->name, pfd, libbpf_strerror_r(err, errmsg, sizeof(errmsg)));\n\t\tif (err == -EPROTO)\n\t\t\tpr_warn(\"prog '%s': try add PERF_SAMPLE_CALLCHAIN to or remove exclude_callchain_[kernel|user] from pfd %d\\n\",\n\t\t\t\tprog->name, pfd);\n\t\treturn ERR_PTR(err);\n\t}\n\tif (ioctl(pfd, PERF_EVENT_IOC_ENABLE, 0) < 0) {\n\t\terr = -errno;\n\t\tfree(link);\n\t\tpr_warn(\"prog '%s': failed to enable pfd %d: %s\\n\",\n\t\t\tprog->name, pfd, libbpf_strerror_r(err, errmsg, sizeof(errmsg)));\n\t\treturn ERR_PTR(err);\n\t}\n\treturn link;\n}\n\n/*\n * this function is expected to parse integer in the range of [0, 2^31-1] from\n * given file using scanf format string fmt. If actual parsed value is\n * negative, the result might be indistinguishable from error\n */\nstatic int parse_uint_from_file(const char *file, const char *fmt)\n{\n\tchar buf[STRERR_BUFSIZE];\n\tint err, ret;\n\tFILE *f;\n\n\tf = fopen(file, \"r\");\n\tif (!f) {\n\t\terr = -errno;\n\t\tpr_debug(\"failed to open '%s': %s\\n\", file,\n\t\t\t libbpf_strerror_r(err, buf, sizeof(buf)));\n\t\treturn err;\n\t}\n\terr = fscanf(f, fmt, &ret);\n\tif (err != 1) {\n\t\terr = err == EOF ? -EIO : -errno;\n\t\tpr_debug(\"failed to parse '%s': %s\\n\", file,\n\t\t\tlibbpf_strerror_r(err, buf, sizeof(buf)));\n\t\tfclose(f);\n\t\treturn err;\n\t}\n\tfclose(f);\n\treturn ret;\n}\n\nstatic int determine_kprobe_perf_type(void)\n{\n\tconst char *file = \"/sys/bus/event_source/devices/kprobe/type\";\n\n\treturn parse_uint_from_file(file, \"%d\\n\");\n}\n\nstatic int determine_uprobe_perf_type(void)\n{\n\tconst char *file = \"/sys/bus/event_source/devices/uprobe/type\";\n\n\treturn parse_uint_from_file(file, \"%d\\n\");\n}\n\nstatic int determine_kprobe_retprobe_bit(void)\n{\n\tconst char *file = \"/sys/bus/event_source/devices/kprobe/format/retprobe\";\n\n\treturn parse_uint_from_file(file, \"config:%d\\n\");\n}\n\nstatic int determine_uprobe_retprobe_bit(void)\n{\n\tconst char *file = \"/sys/bus/event_source/devices/uprobe/format/retprobe\";\n\n\treturn parse_uint_from_file(file, \"config:%d\\n\");\n}\n\nstatic int perf_event_open_probe(bool uprobe, bool retprobe, const char *name,\n\t\t\t\t uint64_t offset, int pid)\n{\n\tstruct perf_event_attr attr = {};\n\tchar errmsg[STRERR_BUFSIZE];\n\tint type, pfd, err;\n\n\ttype = uprobe ? determine_uprobe_perf_type()\n\t\t      : determine_kprobe_perf_type();\n\tif (type < 0) {\n\t\tpr_warn(\"failed to determine %s perf type: %s\\n\",\n\t\t\tuprobe ? \"uprobe\" : \"kprobe\",\n\t\t\tlibbpf_strerror_r(type, errmsg, sizeof(errmsg)));\n\t\treturn type;\n\t}\n\tif (retprobe) {\n\t\tint bit = uprobe ? determine_uprobe_retprobe_bit()\n\t\t\t\t : determine_kprobe_retprobe_bit();\n\n\t\tif (bit < 0) {\n\t\t\tpr_warn(\"failed to determine %s retprobe bit: %s\\n\",\n\t\t\t\tuprobe ? \"uprobe\" : \"kprobe\",\n\t\t\t\tlibbpf_strerror_r(bit, errmsg, sizeof(errmsg)));\n\t\t\treturn bit;\n\t\t}\n\t\tattr.config |= 1 << bit;\n\t}\n\tattr.size = sizeof(attr);\n\tattr.type = type;\n\tattr.config1 = ptr_to_u64(name); /* kprobe_func or uprobe_path */\n\tattr.config2 = offset;\t\t /* kprobe_addr or probe_offset */\n\n\t/* pid filter is meaningful only for uprobes */\n\tpfd = syscall(__NR_perf_event_open, &attr,\n\t\t      pid < 0 ? -1 : pid /* pid */,\n\t\t      pid == -1 ? 0 : -1 /* cpu */,\n\t\t      -1 /* group_fd */, PERF_FLAG_FD_CLOEXEC);\n\tif (pfd < 0) {\n\t\terr = -errno;\n\t\tpr_warn(\"%s perf_event_open() failed: %s\\n\",\n\t\t\tuprobe ? \"uprobe\" : \"kprobe\",\n\t\t\tlibbpf_strerror_r(err, errmsg, sizeof(errmsg)));\n\t\treturn err;\n\t}\n\treturn pfd;\n}\n\nstruct bpf_link *bpf_program__attach_kprobe(struct bpf_program *prog,\n\t\t\t\t\t    bool retprobe,\n\t\t\t\t\t    const char *func_name)\n{\n\tchar errmsg[STRERR_BUFSIZE];\n\tstruct bpf_link *link;\n\tint pfd, err;\n\n\tpfd = perf_event_open_probe(false /* uprobe */, retprobe, func_name,\n\t\t\t\t    0 /* offset */, -1 /* pid */);\n\tif (pfd < 0) {\n\t\tpr_warn(\"prog '%s': failed to create %s '%s' perf event: %s\\n\",\n\t\t\tprog->name, retprobe ? \"kretprobe\" : \"kprobe\", func_name,\n\t\t\tlibbpf_strerror_r(pfd, errmsg, sizeof(errmsg)));\n\t\treturn ERR_PTR(pfd);\n\t}\n\tlink = bpf_program__attach_perf_event(prog, pfd);\n\tif (IS_ERR(link)) {\n\t\tclose(pfd);\n\t\terr = PTR_ERR(link);\n\t\tpr_warn(\"prog '%s': failed to attach to %s '%s': %s\\n\",\n\t\t\tprog->name, retprobe ? \"kretprobe\" : \"kprobe\", func_name,\n\t\t\tlibbpf_strerror_r(err, errmsg, sizeof(errmsg)));\n\t\treturn link;\n\t}\n\treturn link;\n}\n\nstatic struct bpf_link *attach_kprobe(const struct bpf_sec_def *sec,\n\t\t\t\t      struct bpf_program *prog)\n{\n\tconst char *func_name;\n\tbool retprobe;\n\n\tfunc_name = prog->sec_name + sec->len;\n\tretprobe = strcmp(sec->sec, \"kretprobe/\") == 0;\n\n\treturn bpf_program__attach_kprobe(prog, retprobe, func_name);\n}\n\nstruct bpf_link *bpf_program__attach_uprobe(struct bpf_program *prog,\n\t\t\t\t\t    bool retprobe, pid_t pid,\n\t\t\t\t\t    const char *binary_path,\n\t\t\t\t\t    size_t func_offset)\n{\n\tchar errmsg[STRERR_BUFSIZE];\n\tstruct bpf_link *link;\n\tint pfd, err;\n\n\tpfd = perf_event_open_probe(true /* uprobe */, retprobe,\n\t\t\t\t    binary_path, func_offset, pid);\n\tif (pfd < 0) {\n\t\tpr_warn(\"prog '%s': failed to create %s '%s:0x%zx' perf event: %s\\n\",\n\t\t\tprog->name, retprobe ? \"uretprobe\" : \"uprobe\",\n\t\t\tbinary_path, func_offset,\n\t\t\tlibbpf_strerror_r(pfd, errmsg, sizeof(errmsg)));\n\t\treturn ERR_PTR(pfd);\n\t}\n\tlink = bpf_program__attach_perf_event(prog, pfd);\n\tif (IS_ERR(link)) {\n\t\tclose(pfd);\n\t\terr = PTR_ERR(link);\n\t\tpr_warn(\"prog '%s': failed to attach to %s '%s:0x%zx': %s\\n\",\n\t\t\tprog->name, retprobe ? \"uretprobe\" : \"uprobe\",\n\t\t\tbinary_path, func_offset,\n\t\t\tlibbpf_strerror_r(err, errmsg, sizeof(errmsg)));\n\t\treturn link;\n\t}\n\treturn link;\n}\n\nstatic int determine_tracepoint_id(const char *tp_category,\n\t\t\t\t   const char *tp_name)\n{\n\tchar file[PATH_MAX];\n\tint ret;\n\n\tret = snprintf(file, sizeof(file),\n\t\t       \"/sys/kernel/debug/tracing/events/%s/%s/id\",\n\t\t       tp_category, tp_name);\n\tif (ret < 0)\n\t\treturn -errno;\n\tif (ret >= sizeof(file)) {\n\t\tpr_debug(\"tracepoint %s/%s path is too long\\n\",\n\t\t\t tp_category, tp_name);\n\t\treturn -E2BIG;\n\t}\n\treturn parse_uint_from_file(file, \"%d\\n\");\n}\n\nstatic int perf_event_open_tracepoint(const char *tp_category,\n\t\t\t\t      const char *tp_name)\n{\n\tstruct perf_event_attr attr = {};\n\tchar errmsg[STRERR_BUFSIZE];\n\tint tp_id, pfd, err;\n\n\ttp_id = determine_tracepoint_id(tp_category, tp_name);\n\tif (tp_id < 0) {\n\t\tpr_warn(\"failed to determine tracepoint '%s/%s' perf event ID: %s\\n\",\n\t\t\ttp_category, tp_name,\n\t\t\tlibbpf_strerror_r(tp_id, errmsg, sizeof(errmsg)));\n\t\treturn tp_id;\n\t}\n\n\tattr.type = PERF_TYPE_TRACEPOINT;\n\tattr.size = sizeof(attr);\n\tattr.config = tp_id;\n\n\tpfd = syscall(__NR_perf_event_open, &attr, -1 /* pid */, 0 /* cpu */,\n\t\t      -1 /* group_fd */, PERF_FLAG_FD_CLOEXEC);\n\tif (pfd < 0) {\n\t\terr = -errno;\n\t\tpr_warn(\"tracepoint '%s/%s' perf_event_open() failed: %s\\n\",\n\t\t\ttp_category, tp_name,\n\t\t\tlibbpf_strerror_r(err, errmsg, sizeof(errmsg)));\n\t\treturn err;\n\t}\n\treturn pfd;\n}\n\nstruct bpf_link *bpf_program__attach_tracepoint(struct bpf_program *prog,\n\t\t\t\t\t\tconst char *tp_category,\n\t\t\t\t\t\tconst char *tp_name)\n{\n\tchar errmsg[STRERR_BUFSIZE];\n\tstruct bpf_link *link;\n\tint pfd, err;\n\n\tpfd = perf_event_open_tracepoint(tp_category, tp_name);\n\tif (pfd < 0) {\n\t\tpr_warn(\"prog '%s': failed to create tracepoint '%s/%s' perf event: %s\\n\",\n\t\t\tprog->name, tp_category, tp_name,\n\t\t\tlibbpf_strerror_r(pfd, errmsg, sizeof(errmsg)));\n\t\treturn ERR_PTR(pfd);\n\t}\n\tlink = bpf_program__attach_perf_event(prog, pfd);\n\tif (IS_ERR(link)) {\n\t\tclose(pfd);\n\t\terr = PTR_ERR(link);\n\t\tpr_warn(\"prog '%s': failed to attach to tracepoint '%s/%s': %s\\n\",\n\t\t\tprog->name, tp_category, tp_name,\n\t\t\tlibbpf_strerror_r(err, errmsg, sizeof(errmsg)));\n\t\treturn link;\n\t}\n\treturn link;\n}\n\nstatic struct bpf_link *attach_tp(const struct bpf_sec_def *sec,\n\t\t\t\t  struct bpf_program *prog)\n{\n\tchar *sec_name, *tp_cat, *tp_name;\n\tstruct bpf_link *link;\n\n\tsec_name = strdup(prog->sec_name);\n\tif (!sec_name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* extract \"tp/<category>/<name>\" */\n\ttp_cat = sec_name + sec->len;\n\ttp_name = strchr(tp_cat, '/');\n\tif (!tp_name) {\n\t\tlink = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\t*tp_name = '\\0';\n\ttp_name++;\n\n\tlink = bpf_program__attach_tracepoint(prog, tp_cat, tp_name);\nout:\n\tfree(sec_name);\n\treturn link;\n}\n\nstruct bpf_link *bpf_program__attach_raw_tracepoint(struct bpf_program *prog,\n\t\t\t\t\t\t    const char *tp_name)\n{\n\tchar errmsg[STRERR_BUFSIZE];\n\tstruct bpf_link *link;\n\tint prog_fd, pfd;\n\n\tprog_fd = bpf_program__fd(prog);\n\tif (prog_fd < 0) {\n\t\tpr_warn(\"prog '%s': can't attach before loaded\\n\", prog->name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlink = calloc(1, sizeof(*link));\n\tif (!link)\n\t\treturn ERR_PTR(-ENOMEM);\n\tlink->detach = &bpf_link__detach_fd;\n\n\tpfd = bpf_raw_tracepoint_open(tp_name, prog_fd);\n\tif (pfd < 0) {\n\t\tpfd = -errno;\n\t\tfree(link);\n\t\tpr_warn(\"prog '%s': failed to attach to raw tracepoint '%s': %s\\n\",\n\t\t\tprog->name, tp_name, libbpf_strerror_r(pfd, errmsg, sizeof(errmsg)));\n\t\treturn ERR_PTR(pfd);\n\t}\n\tlink->fd = pfd;\n\treturn link;\n}\n\nstatic struct bpf_link *attach_raw_tp(const struct bpf_sec_def *sec,\n\t\t\t\t      struct bpf_program *prog)\n{\n\tconst char *tp_name = prog->sec_name + sec->len;\n\n\treturn bpf_program__attach_raw_tracepoint(prog, tp_name);\n}\n\n/* Common logic for all BPF program types that attach to a btf_id */\nstatic struct bpf_link *bpf_program__attach_btf_id(struct bpf_program *prog)\n{\n\tchar errmsg[STRERR_BUFSIZE];\n\tstruct bpf_link *link;\n\tint prog_fd, pfd;\n\n\tprog_fd = bpf_program__fd(prog);\n\tif (prog_fd < 0) {\n\t\tpr_warn(\"prog '%s': can't attach before loaded\\n\", prog->name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlink = calloc(1, sizeof(*link));\n\tif (!link)\n\t\treturn ERR_PTR(-ENOMEM);\n\tlink->detach = &bpf_link__detach_fd;\n\n\tpfd = bpf_raw_tracepoint_open(NULL, prog_fd);\n\tif (pfd < 0) {\n\t\tpfd = -errno;\n\t\tfree(link);\n\t\tpr_warn(\"prog '%s': failed to attach: %s\\n\",\n\t\t\tprog->name, libbpf_strerror_r(pfd, errmsg, sizeof(errmsg)));\n\t\treturn ERR_PTR(pfd);\n\t}\n\tlink->fd = pfd;\n\treturn (struct bpf_link *)link;\n}\n\nstruct bpf_link *bpf_program__attach_trace(struct bpf_program *prog)\n{\n\treturn bpf_program__attach_btf_id(prog);\n}\n\nstruct bpf_link *bpf_program__attach_lsm(struct bpf_program *prog)\n{\n\treturn bpf_program__attach_btf_id(prog);\n}\n\nstatic struct bpf_link *attach_trace(const struct bpf_sec_def *sec,\n\t\t\t\t     struct bpf_program *prog)\n{\n\treturn bpf_program__attach_trace(prog);\n}\n\nstatic struct bpf_link *attach_lsm(const struct bpf_sec_def *sec,\n\t\t\t\t   struct bpf_program *prog)\n{\n\treturn bpf_program__attach_lsm(prog);\n}\n\nstatic struct bpf_link *attach_iter(const struct bpf_sec_def *sec,\n\t\t\t\t    struct bpf_program *prog)\n{\n\treturn bpf_program__attach_iter(prog, NULL);\n}\n\nstatic struct bpf_link *\nbpf_program__attach_fd(struct bpf_program *prog, int target_fd, int btf_id,\n\t\t       const char *target_name)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_link_create_opts, opts,\n\t\t\t    .target_btf_id = btf_id);\n\tenum bpf_attach_type attach_type;\n\tchar errmsg[STRERR_BUFSIZE];\n\tstruct bpf_link *link;\n\tint prog_fd, link_fd;\n\n\tprog_fd = bpf_program__fd(prog);\n\tif (prog_fd < 0) {\n\t\tpr_warn(\"prog '%s': can't attach before loaded\\n\", prog->name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlink = calloc(1, sizeof(*link));\n\tif (!link)\n\t\treturn ERR_PTR(-ENOMEM);\n\tlink->detach = &bpf_link__detach_fd;\n\n\tattach_type = bpf_program__get_expected_attach_type(prog);\n\tlink_fd = bpf_link_create(prog_fd, target_fd, attach_type, &opts);\n\tif (link_fd < 0) {\n\t\tlink_fd = -errno;\n\t\tfree(link);\n\t\tpr_warn(\"prog '%s': failed to attach to %s: %s\\n\",\n\t\t\tprog->name, target_name,\n\t\t\tlibbpf_strerror_r(link_fd, errmsg, sizeof(errmsg)));\n\t\treturn ERR_PTR(link_fd);\n\t}\n\tlink->fd = link_fd;\n\treturn link;\n}\n\nstruct bpf_link *\nbpf_program__attach_cgroup(struct bpf_program *prog, int cgroup_fd)\n{\n\treturn bpf_program__attach_fd(prog, cgroup_fd, 0, \"cgroup\");\n}\n\nstruct bpf_link *\nbpf_program__attach_netns(struct bpf_program *prog, int netns_fd)\n{\n\treturn bpf_program__attach_fd(prog, netns_fd, 0, \"netns\");\n}\n\nstruct bpf_link *bpf_program__attach_xdp(struct bpf_program *prog, int ifindex)\n{\n\t/* target_fd/target_ifindex use the same field in LINK_CREATE */\n\treturn bpf_program__attach_fd(prog, ifindex, 0, \"xdp\");\n}\n\nstruct bpf_link *bpf_program__attach_freplace(struct bpf_program *prog,\n\t\t\t\t\t      int target_fd,\n\t\t\t\t\t      const char *attach_func_name)\n{\n\tint btf_id;\n\n\tif (!!target_fd != !!attach_func_name) {\n\t\tpr_warn(\"prog '%s': supply none or both of target_fd and attach_func_name\\n\",\n\t\t\tprog->name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (prog->type != BPF_PROG_TYPE_EXT) {\n\t\tpr_warn(\"prog '%s': only BPF_PROG_TYPE_EXT can attach as freplace\",\n\t\t\tprog->name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (target_fd) {\n\t\tbtf_id = libbpf_find_prog_btf_id(attach_func_name, target_fd);\n\t\tif (btf_id < 0)\n\t\t\treturn ERR_PTR(btf_id);\n\n\t\treturn bpf_program__attach_fd(prog, target_fd, btf_id, \"freplace\");\n\t} else {\n\t\t/* no target, so use raw_tracepoint_open for compatibility\n\t\t * with old kernels\n\t\t */\n\t\treturn bpf_program__attach_trace(prog);\n\t}\n}\n\nstruct bpf_link *\nbpf_program__attach_iter(struct bpf_program *prog,\n\t\t\t const struct bpf_iter_attach_opts *opts)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_link_create_opts, link_create_opts);\n\tchar errmsg[STRERR_BUFSIZE];\n\tstruct bpf_link *link;\n\tint prog_fd, link_fd;\n\t__u32 target_fd = 0;\n\n\tif (!OPTS_VALID(opts, bpf_iter_attach_opts))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlink_create_opts.iter_info = OPTS_GET(opts, link_info, (void *)0);\n\tlink_create_opts.iter_info_len = OPTS_GET(opts, link_info_len, 0);\n\n\tprog_fd = bpf_program__fd(prog);\n\tif (prog_fd < 0) {\n\t\tpr_warn(\"prog '%s': can't attach before loaded\\n\", prog->name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlink = calloc(1, sizeof(*link));\n\tif (!link)\n\t\treturn ERR_PTR(-ENOMEM);\n\tlink->detach = &bpf_link__detach_fd;\n\n\tlink_fd = bpf_link_create(prog_fd, target_fd, BPF_TRACE_ITER,\n\t\t\t\t  &link_create_opts);\n\tif (link_fd < 0) {\n\t\tlink_fd = -errno;\n\t\tfree(link);\n\t\tpr_warn(\"prog '%s': failed to attach to iterator: %s\\n\",\n\t\t\tprog->name, libbpf_strerror_r(link_fd, errmsg, sizeof(errmsg)));\n\t\treturn ERR_PTR(link_fd);\n\t}\n\tlink->fd = link_fd;\n\treturn link;\n}\n\nstruct bpf_link *bpf_program__attach(struct bpf_program *prog)\n{\n\tconst struct bpf_sec_def *sec_def;\n\n\tsec_def = find_sec_def(prog->sec_name);\n\tif (!sec_def || !sec_def->attach_fn)\n\t\treturn ERR_PTR(-ESRCH);\n\n\treturn sec_def->attach_fn(sec_def, prog);\n}\n\nstatic int bpf_link__detach_struct_ops(struct bpf_link *link)\n{\n\t__u32 zero = 0;\n\n\tif (bpf_map_delete_elem(link->fd, &zero))\n\t\treturn -errno;\n\n\treturn 0;\n}\n\nstruct bpf_link *bpf_map__attach_struct_ops(struct bpf_map *map)\n{\n\tstruct bpf_struct_ops *st_ops;\n\tstruct bpf_link *link;\n\t__u32 i, zero = 0;\n\tint err;\n\n\tif (!bpf_map__is_struct_ops(map) || map->fd == -1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlink = calloc(1, sizeof(*link));\n\tif (!link)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tst_ops = map->st_ops;\n\tfor (i = 0; i < btf_vlen(st_ops->type); i++) {\n\t\tstruct bpf_program *prog = st_ops->progs[i];\n\t\tvoid *kern_data;\n\t\tint prog_fd;\n\n\t\tif (!prog)\n\t\t\tcontinue;\n\n\t\tprog_fd = bpf_program__fd(prog);\n\t\tkern_data = st_ops->kern_vdata + st_ops->kern_func_off[i];\n\t\t*(unsigned long *)kern_data = prog_fd;\n\t}\n\n\terr = bpf_map_update_elem(map->fd, &zero, st_ops->kern_vdata, 0);\n\tif (err) {\n\t\terr = -errno;\n\t\tfree(link);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlink->detach = bpf_link__detach_struct_ops;\n\tlink->fd = map->fd;\n\n\treturn link;\n}\n\nenum bpf_perf_event_ret\nbpf_perf_event_read_simple(void *mmap_mem, size_t mmap_size, size_t page_size,\n\t\t\t   void **copy_mem, size_t *copy_size,\n\t\t\t   bpf_perf_event_print_t fn, void *private_data)\n{\n\tstruct perf_event_mmap_page *header = mmap_mem;\n\t__u64 data_head = ring_buffer_read_head(header);\n\t__u64 data_tail = header->data_tail;\n\tvoid *base = ((__u8 *)header) + page_size;\n\tint ret = LIBBPF_PERF_EVENT_CONT;\n\tstruct perf_event_header *ehdr;\n\tsize_t ehdr_size;\n\n\twhile (data_head != data_tail) {\n\t\tehdr = base + (data_tail & (mmap_size - 1));\n\t\tehdr_size = ehdr->size;\n\n\t\tif (((void *)ehdr) + ehdr_size > base + mmap_size) {\n\t\t\tvoid *copy_start = ehdr;\n\t\t\tsize_t len_first = base + mmap_size - copy_start;\n\t\t\tsize_t len_secnd = ehdr_size - len_first;\n\n\t\t\tif (*copy_size < ehdr_size) {\n\t\t\t\tfree(*copy_mem);\n\t\t\t\t*copy_mem = malloc(ehdr_size);\n\t\t\t\tif (!*copy_mem) {\n\t\t\t\t\t*copy_size = 0;\n\t\t\t\t\tret = LIBBPF_PERF_EVENT_ERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*copy_size = ehdr_size;\n\t\t\t}\n\n\t\t\tmemcpy(*copy_mem, copy_start, len_first);\n\t\t\tmemcpy(*copy_mem + len_first, base, len_secnd);\n\t\t\tehdr = *copy_mem;\n\t\t}\n\n\t\tret = fn(ehdr, private_data);\n\t\tdata_tail += ehdr_size;\n\t\tif (ret != LIBBPF_PERF_EVENT_CONT)\n\t\t\tbreak;\n\t}\n\n\tring_buffer_write_tail(header, data_tail);\n\treturn ret;\n}\n\nstruct perf_buffer;\n\nstruct perf_buffer_params {\n\tstruct perf_event_attr *attr;\n\t/* if event_cb is specified, it takes precendence */\n\tperf_buffer_event_fn event_cb;\n\t/* sample_cb and lost_cb are higher-level common-case callbacks */\n\tperf_buffer_sample_fn sample_cb;\n\tperf_buffer_lost_fn lost_cb;\n\tvoid *ctx;\n\tint cpu_cnt;\n\tint *cpus;\n\tint *map_keys;\n};\n\nstruct perf_cpu_buf {\n\tstruct perf_buffer *pb;\n\tvoid *base; /* mmap()'ed memory */\n\tvoid *buf; /* for reconstructing segmented data */\n\tsize_t buf_size;\n\tint fd;\n\tint cpu;\n\tint map_key;\n};\n\nstruct perf_buffer {\n\tperf_buffer_event_fn event_cb;\n\tperf_buffer_sample_fn sample_cb;\n\tperf_buffer_lost_fn lost_cb;\n\tvoid *ctx; /* passed into callbacks */\n\n\tsize_t page_size;\n\tsize_t mmap_size;\n\tstruct perf_cpu_buf **cpu_bufs;\n\tstruct epoll_event *events;\n\tint cpu_cnt; /* number of allocated CPU buffers */\n\tint epoll_fd; /* perf event FD */\n\tint map_fd; /* BPF_MAP_TYPE_PERF_EVENT_ARRAY BPF map FD */\n};\n\nstatic void perf_buffer__free_cpu_buf(struct perf_buffer *pb,\n\t\t\t\t      struct perf_cpu_buf *cpu_buf)\n{\n\tif (!cpu_buf)\n\t\treturn;\n\tif (cpu_buf->base &&\n\t    munmap(cpu_buf->base, pb->mmap_size + pb->page_size))\n\t\tpr_warn(\"failed to munmap cpu_buf #%d\\n\", cpu_buf->cpu);\n\tif (cpu_buf->fd >= 0) {\n\t\tioctl(cpu_buf->fd, PERF_EVENT_IOC_DISABLE, 0);\n\t\tclose(cpu_buf->fd);\n\t}\n\tfree(cpu_buf->buf);\n\tfree(cpu_buf);\n}\n\nvoid perf_buffer__free(struct perf_buffer *pb)\n{\n\tint i;\n\n\tif (IS_ERR_OR_NULL(pb))\n\t\treturn;\n\tif (pb->cpu_bufs) {\n\t\tfor (i = 0; i < pb->cpu_cnt; i++) {\n\t\t\tstruct perf_cpu_buf *cpu_buf = pb->cpu_bufs[i];\n\n\t\t\tif (!cpu_buf)\n\t\t\t\tcontinue;\n\n\t\t\tbpf_map_delete_elem(pb->map_fd, &cpu_buf->map_key);\n\t\t\tperf_buffer__free_cpu_buf(pb, cpu_buf);\n\t\t}\n\t\tfree(pb->cpu_bufs);\n\t}\n\tif (pb->epoll_fd >= 0)\n\t\tclose(pb->epoll_fd);\n\tfree(pb->events);\n\tfree(pb);\n}\n\nstatic struct perf_cpu_buf *\nperf_buffer__open_cpu_buf(struct perf_buffer *pb, struct perf_event_attr *attr,\n\t\t\t  int cpu, int map_key)\n{\n\tstruct perf_cpu_buf *cpu_buf;\n\tchar msg[STRERR_BUFSIZE];\n\tint err;\n\n\tcpu_buf = calloc(1, sizeof(*cpu_buf));\n\tif (!cpu_buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcpu_buf->pb = pb;\n\tcpu_buf->cpu = cpu;\n\tcpu_buf->map_key = map_key;\n\n\tcpu_buf->fd = syscall(__NR_perf_event_open, attr, -1 /* pid */, cpu,\n\t\t\t      -1, PERF_FLAG_FD_CLOEXEC);\n\tif (cpu_buf->fd < 0) {\n\t\terr = -errno;\n\t\tpr_warn(\"failed to open perf buffer event on cpu #%d: %s\\n\",\n\t\t\tcpu, libbpf_strerror_r(err, msg, sizeof(msg)));\n\t\tgoto error;\n\t}\n\n\tcpu_buf->base = mmap(NULL, pb->mmap_size + pb->page_size,\n\t\t\t     PROT_READ | PROT_WRITE, MAP_SHARED,\n\t\t\t     cpu_buf->fd, 0);\n\tif (cpu_buf->base == MAP_FAILED) {\n\t\tcpu_buf->base = NULL;\n\t\terr = -errno;\n\t\tpr_warn(\"failed to mmap perf buffer on cpu #%d: %s\\n\",\n\t\t\tcpu, libbpf_strerror_r(err, msg, sizeof(msg)));\n\t\tgoto error;\n\t}\n\n\tif (ioctl(cpu_buf->fd, PERF_EVENT_IOC_ENABLE, 0) < 0) {\n\t\terr = -errno;\n\t\tpr_warn(\"failed to enable perf buffer event on cpu #%d: %s\\n\",\n\t\t\tcpu, libbpf_strerror_r(err, msg, sizeof(msg)));\n\t\tgoto error;\n\t}\n\n\treturn cpu_buf;\n\nerror:\n\tperf_buffer__free_cpu_buf(pb, cpu_buf);\n\treturn (struct perf_cpu_buf *)ERR_PTR(err);\n}\n\nstatic struct perf_buffer *__perf_buffer__new(int map_fd, size_t page_cnt,\n\t\t\t\t\t      struct perf_buffer_params *p);\n\nstruct perf_buffer *perf_buffer__new(int map_fd, size_t page_cnt,\n\t\t\t\t     const struct perf_buffer_opts *opts)\n{\n\tstruct perf_buffer_params p = {};\n\tstruct perf_event_attr attr = { 0, };\n\n\tattr.config = PERF_COUNT_SW_BPF_OUTPUT;\n\tattr.type = PERF_TYPE_SOFTWARE;\n\tattr.sample_type = PERF_SAMPLE_RAW;\n\tattr.sample_period = 1;\n\tattr.wakeup_events = 1;\n\n\tp.attr = &attr;\n\tp.sample_cb = opts ? opts->sample_cb : NULL;\n\tp.lost_cb = opts ? opts->lost_cb : NULL;\n\tp.ctx = opts ? opts->ctx : NULL;\n\n\treturn __perf_buffer__new(map_fd, page_cnt, &p);\n}\n\nstruct perf_buffer *\nperf_buffer__new_raw(int map_fd, size_t page_cnt,\n\t\t     const struct perf_buffer_raw_opts *opts)\n{\n\tstruct perf_buffer_params p = {};\n\n\tp.attr = opts->attr;\n\tp.event_cb = opts->event_cb;\n\tp.ctx = opts->ctx;\n\tp.cpu_cnt = opts->cpu_cnt;\n\tp.cpus = opts->cpus;\n\tp.map_keys = opts->map_keys;\n\n\treturn __perf_buffer__new(map_fd, page_cnt, &p);\n}\n\nstatic struct perf_buffer *__perf_buffer__new(int map_fd, size_t page_cnt,\n\t\t\t\t\t      struct perf_buffer_params *p)\n{\n\tconst char *online_cpus_file = \"/sys/devices/system/cpu/online\";\n\tstruct bpf_map_info map;\n\tchar msg[STRERR_BUFSIZE];\n\tstruct perf_buffer *pb;\n\tbool *online = NULL;\n\t__u32 map_info_len;\n\tint err, i, j, n;\n\n\tif (page_cnt & (page_cnt - 1)) {\n\t\tpr_warn(\"page count should be power of two, but is %zu\\n\",\n\t\t\tpage_cnt);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* best-effort sanity checks */\n\tmemset(&map, 0, sizeof(map));\n\tmap_info_len = sizeof(map);\n\terr = bpf_obj_get_info_by_fd(map_fd, &map, &map_info_len);\n\tif (err) {\n\t\terr = -errno;\n\t\t/* if BPF_OBJ_GET_INFO_BY_FD is supported, will return\n\t\t * -EBADFD, -EFAULT, or -E2BIG on real error\n\t\t */\n\t\tif (err != -EINVAL) {\n\t\t\tpr_warn(\"failed to get map info for map FD %d: %s\\n\",\n\t\t\t\tmap_fd, libbpf_strerror_r(err, msg, sizeof(msg)));\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\tpr_debug(\"failed to get map info for FD %d; API not supported? Ignoring...\\n\",\n\t\t\t map_fd);\n\t} else {\n\t\tif (map.type != BPF_MAP_TYPE_PERF_EVENT_ARRAY) {\n\t\t\tpr_warn(\"map '%s' should be BPF_MAP_TYPE_PERF_EVENT_ARRAY\\n\",\n\t\t\t\tmap.name);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\tpb = calloc(1, sizeof(*pb));\n\tif (!pb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpb->event_cb = p->event_cb;\n\tpb->sample_cb = p->sample_cb;\n\tpb->lost_cb = p->lost_cb;\n\tpb->ctx = p->ctx;\n\n\tpb->page_size = getpagesize();\n\tpb->mmap_size = pb->page_size * page_cnt;\n\tpb->map_fd = map_fd;\n\n\tpb->epoll_fd = epoll_create1(EPOLL_CLOEXEC);\n\tif (pb->epoll_fd < 0) {\n\t\terr = -errno;\n\t\tpr_warn(\"failed to create epoll instance: %s\\n\",\n\t\t\tlibbpf_strerror_r(err, msg, sizeof(msg)));\n\t\tgoto error;\n\t}\n\n\tif (p->cpu_cnt > 0) {\n\t\tpb->cpu_cnt = p->cpu_cnt;\n\t} else {\n\t\tpb->cpu_cnt = libbpf_num_possible_cpus();\n\t\tif (pb->cpu_cnt < 0) {\n\t\t\terr = pb->cpu_cnt;\n\t\t\tgoto error;\n\t\t}\n\t\tif (map.max_entries && map.max_entries < pb->cpu_cnt)\n\t\t\tpb->cpu_cnt = map.max_entries;\n\t}\n\n\tpb->events = calloc(pb->cpu_cnt, sizeof(*pb->events));\n\tif (!pb->events) {\n\t\terr = -ENOMEM;\n\t\tpr_warn(\"failed to allocate events: out of memory\\n\");\n\t\tgoto error;\n\t}\n\tpb->cpu_bufs = calloc(pb->cpu_cnt, sizeof(*pb->cpu_bufs));\n\tif (!pb->cpu_bufs) {\n\t\terr = -ENOMEM;\n\t\tpr_warn(\"failed to allocate buffers: out of memory\\n\");\n\t\tgoto error;\n\t}\n\n\terr = parse_cpu_mask_file(online_cpus_file, &online, &n);\n\tif (err) {\n\t\tpr_warn(\"failed to get online CPU mask: %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tfor (i = 0, j = 0; i < pb->cpu_cnt; i++) {\n\t\tstruct perf_cpu_buf *cpu_buf;\n\t\tint cpu, map_key;\n\n\t\tcpu = p->cpu_cnt > 0 ? p->cpus[i] : i;\n\t\tmap_key = p->cpu_cnt > 0 ? p->map_keys[i] : i;\n\n\t\t/* in case user didn't explicitly requested particular CPUs to\n\t\t * be attached to, skip offline/not present CPUs\n\t\t */\n\t\tif (p->cpu_cnt <= 0 && (cpu >= n || !online[cpu]))\n\t\t\tcontinue;\n\n\t\tcpu_buf = perf_buffer__open_cpu_buf(pb, p->attr, cpu, map_key);\n\t\tif (IS_ERR(cpu_buf)) {\n\t\t\terr = PTR_ERR(cpu_buf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tpb->cpu_bufs[j] = cpu_buf;\n\n\t\terr = bpf_map_update_elem(pb->map_fd, &map_key,\n\t\t\t\t\t  &cpu_buf->fd, 0);\n\t\tif (err) {\n\t\t\terr = -errno;\n\t\t\tpr_warn(\"failed to set cpu #%d, key %d -> perf FD %d: %s\\n\",\n\t\t\t\tcpu, map_key, cpu_buf->fd,\n\t\t\t\tlibbpf_strerror_r(err, msg, sizeof(msg)));\n\t\t\tgoto error;\n\t\t}\n\n\t\tpb->events[j].events = EPOLLIN;\n\t\tpb->events[j].data.ptr = cpu_buf;\n\t\tif (epoll_ctl(pb->epoll_fd, EPOLL_CTL_ADD, cpu_buf->fd,\n\t\t\t      &pb->events[j]) < 0) {\n\t\t\terr = -errno;\n\t\t\tpr_warn(\"failed to epoll_ctl cpu #%d perf FD %d: %s\\n\",\n\t\t\t\tcpu, cpu_buf->fd,\n\t\t\t\tlibbpf_strerror_r(err, msg, sizeof(msg)));\n\t\t\tgoto error;\n\t\t}\n\t\tj++;\n\t}\n\tpb->cpu_cnt = j;\n\tfree(online);\n\n\treturn pb;\n\nerror:\n\tfree(online);\n\tif (pb)\n\t\tperf_buffer__free(pb);\n\treturn ERR_PTR(err);\n}\n\nstruct perf_sample_raw {\n\tstruct perf_event_header header;\n\tuint32_t size;\n\tchar data[];\n};\n\nstruct perf_sample_lost {\n\tstruct perf_event_header header;\n\tuint64_t id;\n\tuint64_t lost;\n\tuint64_t sample_id;\n};\n\nstatic enum bpf_perf_event_ret\nperf_buffer__process_record(struct perf_event_header *e, void *ctx)\n{\n\tstruct perf_cpu_buf *cpu_buf = ctx;\n\tstruct perf_buffer *pb = cpu_buf->pb;\n\tvoid *data = e;\n\n\t/* user wants full control over parsing perf event */\n\tif (pb->event_cb)\n\t\treturn pb->event_cb(pb->ctx, cpu_buf->cpu, e);\n\n\tswitch (e->type) {\n\tcase PERF_RECORD_SAMPLE: {\n\t\tstruct perf_sample_raw *s = data;\n\n\t\tif (pb->sample_cb)\n\t\t\tpb->sample_cb(pb->ctx, cpu_buf->cpu, s->data, s->size);\n\t\tbreak;\n\t}\n\tcase PERF_RECORD_LOST: {\n\t\tstruct perf_sample_lost *s = data;\n\n\t\tif (pb->lost_cb)\n\t\t\tpb->lost_cb(pb->ctx, cpu_buf->cpu, s->lost);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpr_warn(\"unknown perf sample type %d\\n\", e->type);\n\t\treturn LIBBPF_PERF_EVENT_ERROR;\n\t}\n\treturn LIBBPF_PERF_EVENT_CONT;\n}\n\nstatic int perf_buffer__process_records(struct perf_buffer *pb,\n\t\t\t\t\tstruct perf_cpu_buf *cpu_buf)\n{\n\tenum bpf_perf_event_ret ret;\n\n\tret = bpf_perf_event_read_simple(cpu_buf->base, pb->mmap_size,\n\t\t\t\t\t pb->page_size, &cpu_buf->buf,\n\t\t\t\t\t &cpu_buf->buf_size,\n\t\t\t\t\t perf_buffer__process_record, cpu_buf);\n\tif (ret != LIBBPF_PERF_EVENT_CONT)\n\t\treturn ret;\n\treturn 0;\n}\n\nint perf_buffer__epoll_fd(const struct perf_buffer *pb)\n{\n\treturn pb->epoll_fd;\n}\n\nint perf_buffer__poll(struct perf_buffer *pb, int timeout_ms)\n{\n\tint i, cnt, err;\n\n\tcnt = epoll_wait(pb->epoll_fd, pb->events, pb->cpu_cnt, timeout_ms);\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct perf_cpu_buf *cpu_buf = pb->events[i].data.ptr;\n\n\t\terr = perf_buffer__process_records(pb, cpu_buf);\n\t\tif (err) {\n\t\t\tpr_warn(\"error while processing records: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn cnt < 0 ? -errno : cnt;\n}\n\n/* Return number of PERF_EVENT_ARRAY map slots set up by this perf_buffer\n * manager.\n */\nsize_t perf_buffer__buffer_cnt(const struct perf_buffer *pb)\n{\n\treturn pb->cpu_cnt;\n}\n\n/*\n * Return perf_event FD of a ring buffer in *buf_idx* slot of\n * PERF_EVENT_ARRAY BPF map. This FD can be polled for new data using\n * select()/poll()/epoll() Linux syscalls.\n */\nint perf_buffer__buffer_fd(const struct perf_buffer *pb, size_t buf_idx)\n{\n\tstruct perf_cpu_buf *cpu_buf;\n\n\tif (buf_idx >= pb->cpu_cnt)\n\t\treturn -EINVAL;\n\n\tcpu_buf = pb->cpu_bufs[buf_idx];\n\tif (!cpu_buf)\n\t\treturn -ENOENT;\n\n\treturn cpu_buf->fd;\n}\n\n/*\n * Consume data from perf ring buffer corresponding to slot *buf_idx* in\n * PERF_EVENT_ARRAY BPF map without waiting/polling. If there is no data to\n * consume, do nothing and return success.\n * Returns:\n *   - 0 on success;\n *   - <0 on failure.\n */\nint perf_buffer__consume_buffer(struct perf_buffer *pb, size_t buf_idx)\n{\n\tstruct perf_cpu_buf *cpu_buf;\n\n\tif (buf_idx >= pb->cpu_cnt)\n\t\treturn -EINVAL;\n\n\tcpu_buf = pb->cpu_bufs[buf_idx];\n\tif (!cpu_buf)\n\t\treturn -ENOENT;\n\n\treturn perf_buffer__process_records(pb, cpu_buf);\n}\n\nint perf_buffer__consume(struct perf_buffer *pb)\n{\n\tint i, err;\n\n\tfor (i = 0; i < pb->cpu_cnt; i++) {\n\t\tstruct perf_cpu_buf *cpu_buf = pb->cpu_bufs[i];\n\n\t\tif (!cpu_buf)\n\t\t\tcontinue;\n\n\t\terr = perf_buffer__process_records(pb, cpu_buf);\n\t\tif (err) {\n\t\t\tpr_warn(\"perf_buffer: failed to process records in buffer #%d: %d\\n\", i, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstruct bpf_prog_info_array_desc {\n\tint\tarray_offset;\t/* e.g. offset of jited_prog_insns */\n\tint\tcount_offset;\t/* e.g. offset of jited_prog_len */\n\tint\tsize_offset;\t/* > 0: offset of rec size,\n\t\t\t\t * < 0: fix size of -size_offset\n\t\t\t\t */\n};\n\nstatic struct bpf_prog_info_array_desc bpf_prog_info_array_desc[] = {\n\t[BPF_PROG_INFO_JITED_INSNS] = {\n\t\toffsetof(struct bpf_prog_info, jited_prog_insns),\n\t\toffsetof(struct bpf_prog_info, jited_prog_len),\n\t\t-1,\n\t},\n\t[BPF_PROG_INFO_XLATED_INSNS] = {\n\t\toffsetof(struct bpf_prog_info, xlated_prog_insns),\n\t\toffsetof(struct bpf_prog_info, xlated_prog_len),\n\t\t-1,\n\t},\n\t[BPF_PROG_INFO_MAP_IDS] = {\n\t\toffsetof(struct bpf_prog_info, map_ids),\n\t\toffsetof(struct bpf_prog_info, nr_map_ids),\n\t\t-(int)sizeof(__u32),\n\t},\n\t[BPF_PROG_INFO_JITED_KSYMS] = {\n\t\toffsetof(struct bpf_prog_info, jited_ksyms),\n\t\toffsetof(struct bpf_prog_info, nr_jited_ksyms),\n\t\t-(int)sizeof(__u64),\n\t},\n\t[BPF_PROG_INFO_JITED_FUNC_LENS] = {\n\t\toffsetof(struct bpf_prog_info, jited_func_lens),\n\t\toffsetof(struct bpf_prog_info, nr_jited_func_lens),\n\t\t-(int)sizeof(__u32),\n\t},\n\t[BPF_PROG_INFO_FUNC_INFO] = {\n\t\toffsetof(struct bpf_prog_info, func_info),\n\t\toffsetof(struct bpf_prog_info, nr_func_info),\n\t\toffsetof(struct bpf_prog_info, func_info_rec_size),\n\t},\n\t[BPF_PROG_INFO_LINE_INFO] = {\n\t\toffsetof(struct bpf_prog_info, line_info),\n\t\toffsetof(struct bpf_prog_info, nr_line_info),\n\t\toffsetof(struct bpf_prog_info, line_info_rec_size),\n\t},\n\t[BPF_PROG_INFO_JITED_LINE_INFO] = {\n\t\toffsetof(struct bpf_prog_info, jited_line_info),\n\t\toffsetof(struct bpf_prog_info, nr_jited_line_info),\n\t\toffsetof(struct bpf_prog_info, jited_line_info_rec_size),\n\t},\n\t[BPF_PROG_INFO_PROG_TAGS] = {\n\t\toffsetof(struct bpf_prog_info, prog_tags),\n\t\toffsetof(struct bpf_prog_info, nr_prog_tags),\n\t\t-(int)sizeof(__u8) * BPF_TAG_SIZE,\n\t},\n\n};\n\nstatic __u32 bpf_prog_info_read_offset_u32(struct bpf_prog_info *info,\n\t\t\t\t\t   int offset)\n{\n\t__u32 *array = (__u32 *)info;\n\n\tif (offset >= 0)\n\t\treturn array[offset / sizeof(__u32)];\n\treturn -(int)offset;\n}\n\nstatic __u64 bpf_prog_info_read_offset_u64(struct bpf_prog_info *info,\n\t\t\t\t\t   int offset)\n{\n\t__u64 *array = (__u64 *)info;\n\n\tif (offset >= 0)\n\t\treturn array[offset / sizeof(__u64)];\n\treturn -(int)offset;\n}\n\nstatic void bpf_prog_info_set_offset_u32(struct bpf_prog_info *info, int offset,\n\t\t\t\t\t __u32 val)\n{\n\t__u32 *array = (__u32 *)info;\n\n\tif (offset >= 0)\n\t\tarray[offset / sizeof(__u32)] = val;\n}\n\nstatic void bpf_prog_info_set_offset_u64(struct bpf_prog_info *info, int offset,\n\t\t\t\t\t __u64 val)\n{\n\t__u64 *array = (__u64 *)info;\n\n\tif (offset >= 0)\n\t\tarray[offset / sizeof(__u64)] = val;\n}\n\nstruct bpf_prog_info_linear *\nbpf_program__get_prog_info_linear(int fd, __u64 arrays)\n{\n\tstruct bpf_prog_info_linear *info_linear;\n\tstruct bpf_prog_info info = {};\n\t__u32 info_len = sizeof(info);\n\t__u32 data_len = 0;\n\tint i, err;\n\tvoid *ptr;\n\n\tif (arrays >> BPF_PROG_INFO_LAST_ARRAY)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* step 1: get array dimensions */\n\terr = bpf_obj_get_info_by_fd(fd, &info, &info_len);\n\tif (err) {\n\t\tpr_debug(\"can't get prog info: %s\", strerror(errno));\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\t/* step 2: calculate total size of all arrays */\n\tfor (i = BPF_PROG_INFO_FIRST_ARRAY; i < BPF_PROG_INFO_LAST_ARRAY; ++i) {\n\t\tbool include_array = (arrays & (1UL << i)) > 0;\n\t\tstruct bpf_prog_info_array_desc *desc;\n\t\t__u32 count, size;\n\n\t\tdesc = bpf_prog_info_array_desc + i;\n\n\t\t/* kernel is too old to support this field */\n\t\tif (info_len < desc->array_offset + sizeof(__u32) ||\n\t\t    info_len < desc->count_offset + sizeof(__u32) ||\n\t\t    (desc->size_offset > 0 && info_len < desc->size_offset))\n\t\t\tinclude_array = false;\n\n\t\tif (!include_array) {\n\t\t\tarrays &= ~(1UL << i);\t/* clear the bit */\n\t\t\tcontinue;\n\t\t}\n\n\t\tcount = bpf_prog_info_read_offset_u32(&info, desc->count_offset);\n\t\tsize  = bpf_prog_info_read_offset_u32(&info, desc->size_offset);\n\n\t\tdata_len += count * size;\n\t}\n\n\t/* step 3: allocate continuous memory */\n\tdata_len = roundup(data_len, sizeof(__u64));\n\tinfo_linear = malloc(sizeof(struct bpf_prog_info_linear) + data_len);\n\tif (!info_linear)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* step 4: fill data to info_linear->info */\n\tinfo_linear->arrays = arrays;\n\tmemset(&info_linear->info, 0, sizeof(info));\n\tptr = info_linear->data;\n\n\tfor (i = BPF_PROG_INFO_FIRST_ARRAY; i < BPF_PROG_INFO_LAST_ARRAY; ++i) {\n\t\tstruct bpf_prog_info_array_desc *desc;\n\t\t__u32 count, size;\n\n\t\tif ((arrays & (1UL << i)) == 0)\n\t\t\tcontinue;\n\n\t\tdesc  = bpf_prog_info_array_desc + i;\n\t\tcount = bpf_prog_info_read_offset_u32(&info, desc->count_offset);\n\t\tsize  = bpf_prog_info_read_offset_u32(&info, desc->size_offset);\n\t\tbpf_prog_info_set_offset_u32(&info_linear->info,\n\t\t\t\t\t     desc->count_offset, count);\n\t\tbpf_prog_info_set_offset_u32(&info_linear->info,\n\t\t\t\t\t     desc->size_offset, size);\n\t\tbpf_prog_info_set_offset_u64(&info_linear->info,\n\t\t\t\t\t     desc->array_offset,\n\t\t\t\t\t     ptr_to_u64(ptr));\n\t\tptr += count * size;\n\t}\n\n\t/* step 5: call syscall again to get required arrays */\n\terr = bpf_obj_get_info_by_fd(fd, &info_linear->info, &info_len);\n\tif (err) {\n\t\tpr_debug(\"can't get prog info: %s\", strerror(errno));\n\t\tfree(info_linear);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\t/* step 6: verify the data */\n\tfor (i = BPF_PROG_INFO_FIRST_ARRAY; i < BPF_PROG_INFO_LAST_ARRAY; ++i) {\n\t\tstruct bpf_prog_info_array_desc *desc;\n\t\t__u32 v1, v2;\n\n\t\tif ((arrays & (1UL << i)) == 0)\n\t\t\tcontinue;\n\n\t\tdesc = bpf_prog_info_array_desc + i;\n\t\tv1 = bpf_prog_info_read_offset_u32(&info, desc->count_offset);\n\t\tv2 = bpf_prog_info_read_offset_u32(&info_linear->info,\n\t\t\t\t\t\t   desc->count_offset);\n\t\tif (v1 != v2)\n\t\t\tpr_warn(\"%s: mismatch in element count\\n\", __func__);\n\n\t\tv1 = bpf_prog_info_read_offset_u32(&info, desc->size_offset);\n\t\tv2 = bpf_prog_info_read_offset_u32(&info_linear->info,\n\t\t\t\t\t\t   desc->size_offset);\n\t\tif (v1 != v2)\n\t\t\tpr_warn(\"%s: mismatch in rec size\\n\", __func__);\n\t}\n\n\t/* step 7: update info_len and data_len */\n\tinfo_linear->info_len = sizeof(struct bpf_prog_info);\n\tinfo_linear->data_len = data_len;\n\n\treturn info_linear;\n}\n\nvoid bpf_program__bpil_addr_to_offs(struct bpf_prog_info_linear *info_linear)\n{\n\tint i;\n\n\tfor (i = BPF_PROG_INFO_FIRST_ARRAY; i < BPF_PROG_INFO_LAST_ARRAY; ++i) {\n\t\tstruct bpf_prog_info_array_desc *desc;\n\t\t__u64 addr, offs;\n\n\t\tif ((info_linear->arrays & (1UL << i)) == 0)\n\t\t\tcontinue;\n\n\t\tdesc = bpf_prog_info_array_desc + i;\n\t\taddr = bpf_prog_info_read_offset_u64(&info_linear->info,\n\t\t\t\t\t\t     desc->array_offset);\n\t\toffs = addr - ptr_to_u64(info_linear->data);\n\t\tbpf_prog_info_set_offset_u64(&info_linear->info,\n\t\t\t\t\t     desc->array_offset, offs);\n\t}\n}\n\nvoid bpf_program__bpil_offs_to_addr(struct bpf_prog_info_linear *info_linear)\n{\n\tint i;\n\n\tfor (i = BPF_PROG_INFO_FIRST_ARRAY; i < BPF_PROG_INFO_LAST_ARRAY; ++i) {\n\t\tstruct bpf_prog_info_array_desc *desc;\n\t\t__u64 addr, offs;\n\n\t\tif ((info_linear->arrays & (1UL << i)) == 0)\n\t\t\tcontinue;\n\n\t\tdesc = bpf_prog_info_array_desc + i;\n\t\toffs = bpf_prog_info_read_offset_u64(&info_linear->info,\n\t\t\t\t\t\t     desc->array_offset);\n\t\taddr = offs + ptr_to_u64(info_linear->data);\n\t\tbpf_prog_info_set_offset_u64(&info_linear->info,\n\t\t\t\t\t     desc->array_offset, addr);\n\t}\n}\n\nint bpf_program__set_attach_target(struct bpf_program *prog,\n\t\t\t\t   int attach_prog_fd,\n\t\t\t\t   const char *attach_func_name)\n{\n\tint btf_id;\n\n\tif (!prog || attach_prog_fd < 0 || !attach_func_name)\n\t\treturn -EINVAL;\n\n\tif (attach_prog_fd)\n\t\tbtf_id = libbpf_find_prog_btf_id(attach_func_name,\n\t\t\t\t\t\t attach_prog_fd);\n\telse\n\t\tbtf_id = libbpf_find_vmlinux_btf_id(attach_func_name,\n\t\t\t\t\t\t    prog->expected_attach_type);\n\n\tif (btf_id < 0)\n\t\treturn btf_id;\n\n\tprog->attach_btf_id = btf_id;\n\tprog->attach_prog_fd = attach_prog_fd;\n\treturn 0;\n}\n\nint parse_cpu_mask_str(const char *s, bool **mask, int *mask_sz)\n{\n\tint err = 0, n, len, start, end = -1;\n\tbool *tmp;\n\n\t*mask = NULL;\n\t*mask_sz = 0;\n\n\t/* Each sub string separated by ',' has format \\d+-\\d+ or \\d+ */\n\twhile (*s) {\n\t\tif (*s == ',' || *s == '\\n') {\n\t\t\ts++;\n\t\t\tcontinue;\n\t\t}\n\t\tn = sscanf(s, \"%d%n-%d%n\", &start, &len, &end, &len);\n\t\tif (n <= 0 || n > 2) {\n\t\t\tpr_warn(\"Failed to get CPU range %s: %d\\n\", s, n);\n\t\t\terr = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t} else if (n == 1) {\n\t\t\tend = start;\n\t\t}\n\t\tif (start < 0 || start > end) {\n\t\t\tpr_warn(\"Invalid CPU range [%d,%d] in %s\\n\",\n\t\t\t\tstart, end, s);\n\t\t\terr = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\ttmp = realloc(*mask, end + 1);\n\t\tif (!tmp) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t*mask = tmp;\n\t\tmemset(tmp + *mask_sz, 0, start - *mask_sz);\n\t\tmemset(tmp + start, 1, end - start + 1);\n\t\t*mask_sz = end + 1;\n\t\ts += len;\n\t}\n\tif (!*mask_sz) {\n\t\tpr_warn(\"Empty CPU range\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\ncleanup:\n\tfree(*mask);\n\t*mask = NULL;\n\treturn err;\n}\n\nint parse_cpu_mask_file(const char *fcpu, bool **mask, int *mask_sz)\n{\n\tint fd, err = 0, len;\n\tchar buf[128];\n\n\tfd = open(fcpu, O_RDONLY);\n\tif (fd < 0) {\n\t\terr = -errno;\n\t\tpr_warn(\"Failed to open cpu mask file %s: %d\\n\", fcpu, err);\n\t\treturn err;\n\t}\n\tlen = read(fd, buf, sizeof(buf));\n\tclose(fd);\n\tif (len <= 0) {\n\t\terr = len ? -errno : -EINVAL;\n\t\tpr_warn(\"Failed to read cpu mask from %s: %d\\n\", fcpu, err);\n\t\treturn err;\n\t}\n\tif (len >= sizeof(buf)) {\n\t\tpr_warn(\"CPU mask is too big in file %s\\n\", fcpu);\n\t\treturn -E2BIG;\n\t}\n\tbuf[len] = '\\0';\n\n\treturn parse_cpu_mask_str(buf, mask, mask_sz);\n}\n\nint libbpf_num_possible_cpus(void)\n{\n\tstatic const char *fcpu = \"/sys/devices/system/cpu/possible\";\n\tstatic int cpus;\n\tint err, n, i, tmp_cpus;\n\tbool *mask;\n\n\ttmp_cpus = READ_ONCE(cpus);\n\tif (tmp_cpus > 0)\n\t\treturn tmp_cpus;\n\n\terr = parse_cpu_mask_file(fcpu, &mask, &n);\n\tif (err)\n\t\treturn err;\n\n\ttmp_cpus = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (mask[i])\n\t\t\ttmp_cpus++;\n\t}\n\tfree(mask);\n\n\tWRITE_ONCE(cpus, tmp_cpus);\n\treturn tmp_cpus;\n}\n\nint bpf_object__open_skeleton(struct bpf_object_skeleton *s,\n\t\t\t      const struct bpf_object_open_opts *opts)\n{\n\tDECLARE_LIBBPF_OPTS(bpf_object_open_opts, skel_opts,\n\t\t.object_name = s->name,\n\t);\n\tstruct bpf_object *obj;\n\tint i;\n\n\t/* Attempt to preserve opts->object_name, unless overriden by user\n\t * explicitly. Overwriting object name for skeletons is discouraged,\n\t * as it breaks global data maps, because they contain object name\n\t * prefix as their own map name prefix. When skeleton is generated,\n\t * bpftool is making an assumption that this name will stay the same.\n\t */\n\tif (opts) {\n\t\tmemcpy(&skel_opts, opts, sizeof(*opts));\n\t\tif (!opts->object_name)\n\t\t\tskel_opts.object_name = s->name;\n\t}\n\n\tobj = bpf_object__open_mem(s->data, s->data_sz, &skel_opts);\n\tif (IS_ERR(obj)) {\n\t\tpr_warn(\"failed to initialize skeleton BPF object '%s': %ld\\n\",\n\t\t\ts->name, PTR_ERR(obj));\n\t\treturn PTR_ERR(obj);\n\t}\n\n\t*s->obj = obj;\n\n\tfor (i = 0; i < s->map_cnt; i++) {\n\t\tstruct bpf_map **map = s->maps[i].map;\n\t\tconst char *name = s->maps[i].name;\n\t\tvoid **mmaped = s->maps[i].mmaped;\n\n\t\t*map = bpf_object__find_map_by_name(obj, name);\n\t\tif (!*map) {\n\t\t\tpr_warn(\"failed to find skeleton map '%s'\\n\", name);\n\t\t\treturn -ESRCH;\n\t\t}\n\n\t\t/* externs shouldn't be pre-setup from user code */\n\t\tif (mmaped && (*map)->libbpf_type != LIBBPF_MAP_KCONFIG)\n\t\t\t*mmaped = (*map)->mmaped;\n\t}\n\n\tfor (i = 0; i < s->prog_cnt; i++) {\n\t\tstruct bpf_program **prog = s->progs[i].prog;\n\t\tconst char *name = s->progs[i].name;\n\n\t\t*prog = bpf_object__find_program_by_name(obj, name);\n\t\tif (!*prog) {\n\t\t\tpr_warn(\"failed to find skeleton program '%s'\\n\", name);\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint bpf_object__load_skeleton(struct bpf_object_skeleton *s)\n{\n\tint i, err;\n\n\terr = bpf_object__load(*s->obj);\n\tif (err) {\n\t\tpr_warn(\"failed to load BPF skeleton '%s': %d\\n\", s->name, err);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < s->map_cnt; i++) {\n\t\tstruct bpf_map *map = *s->maps[i].map;\n\t\tsize_t mmap_sz = bpf_map_mmap_sz(map);\n\t\tint prot, map_fd = bpf_map__fd(map);\n\t\tvoid **mmaped = s->maps[i].mmaped;\n\n\t\tif (!mmaped)\n\t\t\tcontinue;\n\n\t\tif (!(map->def.map_flags & BPF_F_MMAPABLE)) {\n\t\t\t*mmaped = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (map->def.map_flags & BPF_F_RDONLY_PROG)\n\t\t\tprot = PROT_READ;\n\t\telse\n\t\t\tprot = PROT_READ | PROT_WRITE;\n\n\t\t/* Remap anonymous mmap()-ed \"map initialization image\" as\n\t\t * a BPF map-backed mmap()-ed memory, but preserving the same\n\t\t * memory address. This will cause kernel to change process'\n\t\t * page table to point to a different piece of kernel memory,\n\t\t * but from userspace point of view memory address (and its\n\t\t * contents, being identical at this point) will stay the\n\t\t * same. This mapping will be released by bpf_object__close()\n\t\t * as per normal clean up procedure, so we don't need to worry\n\t\t * about it from skeleton's clean up perspective.\n\t\t */\n\t\t*mmaped = mmap(map->mmaped, mmap_sz, prot,\n\t\t\t\tMAP_SHARED | MAP_FIXED, map_fd, 0);\n\t\tif (*mmaped == MAP_FAILED) {\n\t\t\terr = -errno;\n\t\t\t*mmaped = NULL;\n\t\t\tpr_warn(\"failed to re-mmap() map '%s': %d\\n\",\n\t\t\t\t bpf_map__name(map), err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint bpf_object__attach_skeleton(struct bpf_object_skeleton *s)\n{\n\tint i;\n\n\tfor (i = 0; i < s->prog_cnt; i++) {\n\t\tstruct bpf_program *prog = *s->progs[i].prog;\n\t\tstruct bpf_link **link = s->progs[i].link;\n\t\tconst struct bpf_sec_def *sec_def;\n\n\t\tif (!prog->load)\n\t\t\tcontinue;\n\n\t\tsec_def = find_sec_def(prog->sec_name);\n\t\tif (!sec_def || !sec_def->attach_fn)\n\t\t\tcontinue;\n\n\t\t*link = sec_def->attach_fn(sec_def, prog);\n\t\tif (IS_ERR(*link)) {\n\t\t\tpr_warn(\"failed to auto-attach program '%s': %ld\\n\",\n\t\t\t\tbpf_program__name(prog), PTR_ERR(*link));\n\t\t\treturn PTR_ERR(*link);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid bpf_object__detach_skeleton(struct bpf_object_skeleton *s)\n{\n\tint i;\n\n\tfor (i = 0; i < s->prog_cnt; i++) {\n\t\tstruct bpf_link **link = s->progs[i].link;\n\n\t\tbpf_link__destroy(*link);\n\t\t*link = NULL;\n\t}\n}\n\nvoid bpf_object__destroy_skeleton(struct bpf_object_skeleton *s)\n{\n\tif (s->progs)\n\t\tbpf_object__detach_skeleton(s);\n\tif (s->obj)\n\t\tbpf_object__close(*s->obj);\n\tfree(s->maps);\n\tfree(s->progs);\n\tfree(s);\n}\n"}}, "reports": [{"events": [{"location": {"col": 43, "file": 0, "line": 1469}, "message": "WARNING: conversion to bool not needed here"}], "macros": [], "notes": [], "path": "/src/tools/lib/bpf/libbpf.c", "reportHash": "21866134a01b55517edbe3d129478e96", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
