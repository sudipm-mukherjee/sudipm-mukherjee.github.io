<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/mm/mempolicy.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Simple NUMA memory policy for the Linux kernel.\n *\n * Copyright 2003,2004 Andi Kleen, SuSE Labs.\n * (C) Copyright 2005 Christoph Lameter, Silicon Graphics, Inc.\n *\n * NUMA policy allows the user to give hints in which node(s) memory should\n * be allocated.\n *\n * Support four policies per VMA and per process:\n *\n * The VMA policy has priority over the process policy for a page fault.\n *\n * interleave     Allocate memory interleaved over a set of nodes,\n *                with normal fallback if it fails.\n *                For VMA based allocations this interleaves based on the\n *                offset into the backing object or offset into the mapping\n *                for anonymous memory. For process policy an process counter\n *                is used.\n *\n * bind           Only allocate memory on a specific set of nodes,\n *                no fallback.\n *                FIXME: memory is allocated starting with the first node\n *                to the last. It would be better if bind would truly restrict\n *                the allocation to memory nodes instead\n *\n * preferred       Try a specific node first before normal fallback.\n *                As a special case NUMA_NO_NODE here means do the allocation\n *                on the local CPU. This is normally identical to default,\n *                but useful to set in a VMA when you have a non default\n *                process policy.\n *\n * default        Allocate on the local node first, or when on a VMA\n *                use the process policy. This is what Linux always did\n *\t\t  in a NUMA aware kernel and still does by, ahem, default.\n *\n * The process policy is applied for most non interrupt memory allocations\n * in that process' context. Interrupts ignore the policies and always\n * try to allocate on the local CPU. The VMA policy is only applied for memory\n * allocations for a VMA in the VM.\n *\n * Currently there are a few corner cases in swapping where the policy\n * is not applied, but the majority should be handled. When process policy\n * is used it is not remembered over swap outs/swap ins.\n *\n * Only the highest zone in the zone hierarchy gets policied. Allocations\n * requesting a lower zone just use default policy. This implies that\n * on systems with highmem kernel lowmem allocation don't get policied.\n * Same with GFP_DMA allocations.\n *\n * For shmfs/tmpfs/hugetlbfs shared memory the policy is shared between\n * all users and remembered even when nobody has memory mapped.\n */\n\n/* Notebook:\n   fix mmap readahead to honour policy and enable policy for any page cache\n   object\n   statistics for bigpages\n   global policy for page cache? currently it uses process policy. Requires\n   first item above.\n   handle mremap for shared memory (currently ignored for the policy)\n   grows down?\n   make bind policy root only? It can trigger oom much faster and the\n   kernel is not always grateful with that.\n*/\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/mempolicy.h>\n#include <linux/pagewalk.h>\n#include <linux/highmem.h>\n#include <linux/hugetlb.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/task.h>\n#include <linux/nodemask.h>\n#include <linux/cpuset.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/nsproxy.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/compat.h>\n#include <linux/ptrace.h>\n#include <linux/swap.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/migrate.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/ctype.h>\n#include <linux/mm_inline.h>\n#include <linux/mmu_notifier.h>\n#include <linux/printk.h>\n#include <linux/swapops.h>\n\n#include <asm/tlbflush.h>\n#include <linux/uaccess.h>\n\n#include \"internal.h\"\n\n/* Internal flags */\n#define MPOL_MF_DISCONTIG_OK (MPOL_MF_INTERNAL << 0)\t/* Skip checks for continuous vmas */\n#define MPOL_MF_INVERT (MPOL_MF_INTERNAL << 1)\t\t/* Invert check for nodemask */\n\nstatic struct kmem_cache *policy_cache;\nstatic struct kmem_cache *sn_cache;\n\n/* Highest zone. An specific allocation for a zone below that is not\n   policied. */\nenum zone_type policy_zone = 0;\n\n/*\n * run-time system-wide default policy => local allocation\n */\nstatic struct mempolicy default_policy = {\n\t.refcnt = ATOMIC_INIT(1), /* never free it */\n\t.mode = MPOL_PREFERRED,\n\t.flags = MPOL_F_LOCAL,\n};\n\nstatic struct mempolicy preferred_node_policy[MAX_NUMNODES];\n\n/**\n * numa_map_to_online_node - Find closest online node\n * @node: Node id to start the search\n *\n * Lookup the next closest node by distance if @nid is not online.\n */\nint numa_map_to_online_node(int node)\n{\n\tint min_dist = INT_MAX, dist, n, min_node;\n\n\tif (node == NUMA_NO_NODE || node_online(node))\n\t\treturn node;\n\n\tmin_node = node;\n\tfor_each_online_node(n) {\n\t\tdist = node_distance(node, n);\n\t\tif (dist < min_dist) {\n\t\t\tmin_dist = dist;\n\t\t\tmin_node = n;\n\t\t}\n\t}\n\n\treturn min_node;\n}\nEXPORT_SYMBOL_GPL(numa_map_to_online_node);\n\nstruct mempolicy *get_task_policy(struct task_struct *p)\n{\n\tstruct mempolicy *pol = p->mempolicy;\n\tint node;\n\n\tif (pol)\n\t\treturn pol;\n\n\tnode = numa_node_id();\n\tif (node != NUMA_NO_NODE) {\n\t\tpol = &preferred_node_policy[node];\n\t\t/* preferred_node_policy is not initialised early in boot */\n\t\tif (pol->mode)\n\t\t\treturn pol;\n\t}\n\n\treturn &default_policy;\n}\n\nstatic const struct mempolicy_operations {\n\tint (*create)(struct mempolicy *pol, const nodemask_t *nodes);\n\tvoid (*rebind)(struct mempolicy *pol, const nodemask_t *nodes);\n} mpol_ops[MPOL_MAX];\n\nstatic inline int mpol_store_user_nodemask(const struct mempolicy *pol)\n{\n\treturn pol->flags & MPOL_MODE_FLAGS;\n}\n\nstatic void mpol_relative_nodemask(nodemask_t *ret, const nodemask_t *orig,\n\t\t\t\t   const nodemask_t *rel)\n{\n\tnodemask_t tmp;\n\tnodes_fold(tmp, *orig, nodes_weight(*rel));\n\tnodes_onto(*ret, tmp, *rel);\n}\n\nstatic int mpol_new_interleave(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tif (nodes_empty(*nodes))\n\t\treturn -EINVAL;\n\tpol->v.nodes = *nodes;\n\treturn 0;\n}\n\nstatic int mpol_new_preferred(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tif (!nodes)\n\t\tpol->flags |= MPOL_F_LOCAL;\t/* local allocation */\n\telse if (nodes_empty(*nodes))\n\t\treturn -EINVAL;\t\t\t/*  no allowed nodes */\n\telse\n\t\tpol->v.preferred_node = first_node(*nodes);\n\treturn 0;\n}\n\nstatic int mpol_new_bind(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tif (nodes_empty(*nodes))\n\t\treturn -EINVAL;\n\tpol->v.nodes = *nodes;\n\treturn 0;\n}\n\n/*\n * mpol_set_nodemask is called after mpol_new() to set up the nodemask, if\n * any, for the new policy.  mpol_new() has already validated the nodes\n * parameter with respect to the policy mode and flags.  But, we need to\n * handle an empty nodemask with MPOL_PREFERRED here.\n *\n * Must be called holding task's alloc_lock to protect task's mems_allowed\n * and mempolicy.  May also be called holding the mmap_lock for write.\n */\nstatic int mpol_set_nodemask(struct mempolicy *pol,\n\t\t     const nodemask_t *nodes, struct nodemask_scratch *nsc)\n{\n\tint ret;\n\n\t/* if mode is MPOL_DEFAULT, pol is NULL. This is right. */\n\tif (pol == NULL)\n\t\treturn 0;\n\t/* Check N_MEMORY */\n\tnodes_and(nsc->mask1,\n\t\t  cpuset_current_mems_allowed, node_states[N_MEMORY]);\n\n\tVM_BUG_ON(!nodes);\n\tif (pol->mode == MPOL_PREFERRED && nodes_empty(*nodes))\n\t\tnodes = NULL;\t/* explicit local allocation */\n\telse {\n\t\tif (pol->flags & MPOL_F_RELATIVE_NODES)\n\t\t\tmpol_relative_nodemask(&nsc->mask2, nodes, &nsc->mask1);\n\t\telse\n\t\t\tnodes_and(nsc->mask2, *nodes, nsc->mask1);\n\n\t\tif (mpol_store_user_nodemask(pol))\n\t\t\tpol->w.user_nodemask = *nodes;\n\t\telse\n\t\t\tpol->w.cpuset_mems_allowed =\n\t\t\t\t\t\tcpuset_current_mems_allowed;\n\t}\n\n\tif (nodes)\n\t\tret = mpol_ops[pol->mode].create(pol, &nsc->mask2);\n\telse\n\t\tret = mpol_ops[pol->mode].create(pol, NULL);\n\treturn ret;\n}\n\n/*\n * This function just creates a new policy, does some check and simple\n * initialization. You must invoke mpol_set_nodemask() to set nodes.\n */\nstatic struct mempolicy *mpol_new(unsigned short mode, unsigned short flags,\n\t\t\t\t  nodemask_t *nodes)\n{\n\tstruct mempolicy *policy;\n\n\tpr_debug(\"setting mode %d flags %d nodes[0] %lx\\n\",\n\t\t mode, flags, nodes ? nodes_addr(*nodes)[0] : NUMA_NO_NODE);\n\n\tif (mode == MPOL_DEFAULT) {\n\t\tif (nodes && !nodes_empty(*nodes))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn NULL;\n\t}\n\tVM_BUG_ON(!nodes);\n\n\t/*\n\t * MPOL_PREFERRED cannot be used with MPOL_F_STATIC_NODES or\n\t * MPOL_F_RELATIVE_NODES if the nodemask is empty (local allocation).\n\t * All other modes require a valid pointer to a non-empty nodemask.\n\t */\n\tif (mode == MPOL_PREFERRED) {\n\t\tif (nodes_empty(*nodes)) {\n\t\t\tif (((flags & MPOL_F_STATIC_NODES) ||\n\t\t\t     (flags & MPOL_F_RELATIVE_NODES)))\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else if (mode == MPOL_LOCAL) {\n\t\tif (!nodes_empty(*nodes) ||\n\t\t    (flags & MPOL_F_STATIC_NODES) ||\n\t\t    (flags & MPOL_F_RELATIVE_NODES))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tmode = MPOL_PREFERRED;\n\t} else if (nodes_empty(*nodes))\n\t\treturn ERR_PTR(-EINVAL);\n\tpolicy = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!policy)\n\t\treturn ERR_PTR(-ENOMEM);\n\tatomic_set(&policy->refcnt, 1);\n\tpolicy->mode = mode;\n\tpolicy->flags = flags;\n\n\treturn policy;\n}\n\n/* Slow path of a mpol destructor. */\nvoid __mpol_put(struct mempolicy *p)\n{\n\tif (!atomic_dec_and_test(&p->refcnt))\n\t\treturn;\n\tkmem_cache_free(policy_cache, p);\n}\n\nstatic void mpol_rebind_default(struct mempolicy *pol, const nodemask_t *nodes)\n{\n}\n\nstatic void mpol_rebind_nodemask(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tnodemask_t tmp;\n\n\tif (pol->flags & MPOL_F_STATIC_NODES)\n\t\tnodes_and(tmp, pol->w.user_nodemask, *nodes);\n\telse if (pol->flags & MPOL_F_RELATIVE_NODES)\n\t\tmpol_relative_nodemask(&tmp, &pol->w.user_nodemask, nodes);\n\telse {\n\t\tnodes_remap(tmp, pol->v.nodes,pol->w.cpuset_mems_allowed,\n\t\t\t\t\t\t\t\t*nodes);\n\t\tpol->w.cpuset_mems_allowed = *nodes;\n\t}\n\n\tif (nodes_empty(tmp))\n\t\ttmp = *nodes;\n\n\tpol->v.nodes = tmp;\n}\n\nstatic void mpol_rebind_preferred(struct mempolicy *pol,\n\t\t\t\t\t\tconst nodemask_t *nodes)\n{\n\tnodemask_t tmp;\n\n\tif (pol->flags & MPOL_F_STATIC_NODES) {\n\t\tint node = first_node(pol->w.user_nodemask);\n\n\t\tif (node_isset(node, *nodes)) {\n\t\t\tpol->v.preferred_node = node;\n\t\t\tpol->flags &= ~MPOL_F_LOCAL;\n\t\t} else\n\t\t\tpol->flags |= MPOL_F_LOCAL;\n\t} else if (pol->flags & MPOL_F_RELATIVE_NODES) {\n\t\tmpol_relative_nodemask(&tmp, &pol->w.user_nodemask, nodes);\n\t\tpol->v.preferred_node = first_node(tmp);\n\t} else if (!(pol->flags & MPOL_F_LOCAL)) {\n\t\tpol->v.preferred_node = node_remap(pol->v.preferred_node,\n\t\t\t\t\t\t   pol->w.cpuset_mems_allowed,\n\t\t\t\t\t\t   *nodes);\n\t\tpol->w.cpuset_mems_allowed = *nodes;\n\t}\n}\n\n/*\n * mpol_rebind_policy - Migrate a policy to a different set of nodes\n *\n * Per-vma policies are protected by mmap_lock. Allocations using per-task\n * policies are protected by task->mems_allowed_seq to prevent a premature\n * OOM/allocation failure due to parallel nodemask modification.\n */\nstatic void mpol_rebind_policy(struct mempolicy *pol, const nodemask_t *newmask)\n{\n\tif (!pol)\n\t\treturn;\n\tif (!mpol_store_user_nodemask(pol) && !(pol->flags & MPOL_F_LOCAL) &&\n\t    nodes_equal(pol->w.cpuset_mems_allowed, *newmask))\n\t\treturn;\n\n\tmpol_ops[pol->mode].rebind(pol, newmask);\n}\n\n/*\n * Wrapper for mpol_rebind_policy() that just requires task\n * pointer, and updates task mempolicy.\n *\n * Called with task's alloc_lock held.\n */\n\nvoid mpol_rebind_task(struct task_struct *tsk, const nodemask_t *new)\n{\n\tmpol_rebind_policy(tsk->mempolicy, new);\n}\n\n/*\n * Rebind each vma in mm to new nodemask.\n *\n * Call holding a reference to mm.  Takes mm->mmap_lock during call.\n */\n\nvoid mpol_rebind_mm(struct mm_struct *mm, nodemask_t *new)\n{\n\tstruct vm_area_struct *vma;\n\n\tmmap_write_lock(mm);\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\tmpol_rebind_policy(vma->vm_policy, new);\n\tmmap_write_unlock(mm);\n}\n\nstatic const struct mempolicy_operations mpol_ops[MPOL_MAX] = {\n\t[MPOL_DEFAULT] = {\n\t\t.rebind = mpol_rebind_default,\n\t},\n\t[MPOL_INTERLEAVE] = {\n\t\t.create = mpol_new_interleave,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n\t[MPOL_PREFERRED] = {\n\t\t.create = mpol_new_preferred,\n\t\t.rebind = mpol_rebind_preferred,\n\t},\n\t[MPOL_BIND] = {\n\t\t.create = mpol_new_bind,\n\t\t.rebind = mpol_rebind_nodemask,\n\t},\n};\n\nstatic int migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags);\n\nstruct queue_pages {\n\tstruct list_head *pagelist;\n\tunsigned long flags;\n\tnodemask_t *nmask;\n\tunsigned long start;\n\tunsigned long end;\n\tstruct vm_area_struct *first;\n};\n\n/*\n * Check if the page's nid is in qp->nmask.\n *\n * If MPOL_MF_INVERT is set in qp->flags, check if the nid is\n * in the invert of qp->nmask.\n */\nstatic inline bool queue_pages_required(struct page *page,\n\t\t\t\t\tstruct queue_pages *qp)\n{\n\tint nid = page_to_nid(page);\n\tunsigned long flags = qp->flags;\n\n\treturn node_isset(nid, *qp->nmask) == !(flags & MPOL_MF_INVERT);\n}\n\n/*\n * queue_pages_pmd() has four possible return values:\n * 0 - pages are placed on the right node or queued successfully.\n * 1 - there is unmovable page, and MPOL_MF_MOVE* & MPOL_MF_STRICT were\n *     specified.\n * 2 - THP was split.\n * -EIO - is migration entry or only MPOL_MF_STRICT was specified and an\n *        existing page was already on a node that does not follow the\n *        policy.\n */\nstatic int queue_pages_pmd(pmd_t *pmd, spinlock_t *ptl, unsigned long addr,\n\t\t\t\tunsigned long end, struct mm_walk *walk)\n\t__releases(ptl)\n{\n\tint ret = 0;\n\tstruct page *page;\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long flags;\n\n\tif (unlikely(is_pmd_migration_entry(*pmd))) {\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\tpage = pmd_page(*pmd);\n\tif (is_huge_zero_page(page)) {\n\t\tspin_unlock(ptl);\n\t\t__split_huge_pmd(walk->vma, pmd, addr, false, NULL);\n\t\tret = 2;\n\t\tgoto out;\n\t}\n\tif (!queue_pages_required(page, qp))\n\t\tgoto unlock;\n\n\tflags = qp->flags;\n\t/* go to thp migration */\n\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)) {\n\t\tif (!vma_migratable(walk->vma) ||\n\t\t    migrate_page_add(page, qp->pagelist, flags)) {\n\t\t\tret = 1;\n\t\t\tgoto unlock;\n\t\t}\n\t} else\n\t\tret = -EIO;\nunlock:\n\tspin_unlock(ptl);\nout:\n\treturn ret;\n}\n\n/*\n * Scan through pages checking if pages follow certain conditions,\n * and move them to the pagelist if they do.\n *\n * queue_pages_pte_range() has three possible return values:\n * 0 - pages are placed on the right node or queued successfully.\n * 1 - there is unmovable page, and MPOL_MF_MOVE* & MPOL_MF_STRICT were\n *     specified.\n * -EIO - only MPOL_MF_STRICT was specified and an existing page was already\n *        on a node that does not follow the policy.\n */\nstatic int queue_pages_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct page *page;\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long flags = qp->flags;\n\tint ret;\n\tbool has_unmovable = false;\n\tpte_t *pte, *mapped_pte;\n\tspinlock_t *ptl;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tret = queue_pages_pmd(pmd, ptl, addr, end, walk);\n\t\tif (ret != 2)\n\t\t\treturn ret;\n\t}\n\t/* THP was split, fall through to pte walk */\n\n\tif (pmd_trans_unstable(pmd))\n\t\treturn 0;\n\n\tmapped_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tif (!pte_present(*pte))\n\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, addr, *pte);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\t/*\n\t\t * vm_normal_page() filters out zero pages, but there might\n\t\t * still be PageReserved pages to skip, perhaps in a VDSO.\n\t\t */\n\t\tif (PageReserved(page))\n\t\t\tcontinue;\n\t\tif (!queue_pages_required(page, qp))\n\t\t\tcontinue;\n\t\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)) {\n\t\t\t/* MPOL_MF_STRICT must be specified if we get here */\n\t\t\tif (!vma_migratable(vma)) {\n\t\t\t\thas_unmovable = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Do not abort immediately since there may be\n\t\t\t * temporary off LRU pages in the range.  Still\n\t\t\t * need migrate other LRU pages.\n\t\t\t */\n\t\t\tif (migrate_page_add(page, qp->pagelist, flags))\n\t\t\t\thas_unmovable = true;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tpte_unmap_unlock(mapped_pte, ptl);\n\tcond_resched();\n\n\tif (has_unmovable)\n\t\treturn 1;\n\n\treturn addr != end ? -EIO : 0;\n}\n\nstatic int queue_pages_hugetlb(pte_t *pte, unsigned long hmask,\n\t\t\t       unsigned long addr, unsigned long end,\n\t\t\t       struct mm_walk *walk)\n{\n\tint ret = 0;\n#ifdef CONFIG_HUGETLB_PAGE\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long flags = (qp->flags & MPOL_MF_VALID);\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\n\tptl = huge_pte_lock(hstate_vma(walk->vma), walk->mm, pte);\n\tentry = huge_ptep_get(pte);\n\tif (!pte_present(entry))\n\t\tgoto unlock;\n\tpage = pte_page(entry);\n\tif (!queue_pages_required(page, qp))\n\t\tgoto unlock;\n\n\tif (flags == MPOL_MF_STRICT) {\n\t\t/*\n\t\t * STRICT alone means only detecting misplaced page and no\n\t\t * need to further check other vma.\n\t\t */\n\t\tret = -EIO;\n\t\tgoto unlock;\n\t}\n\n\tif (!vma_migratable(walk->vma)) {\n\t\t/*\n\t\t * Must be STRICT with MOVE*, otherwise .test_walk() have\n\t\t * stopped walking current vma.\n\t\t * Detecting misplaced page but allow migrating pages which\n\t\t * have been queued.\n\t\t */\n\t\tret = 1;\n\t\tgoto unlock;\n\t}\n\n\t/* With MPOL_MF_MOVE, we migrate only unshared hugepage. */\n\tif (flags & (MPOL_MF_MOVE_ALL) ||\n\t    (flags & MPOL_MF_MOVE && page_mapcount(page) == 1)) {\n\t\tif (!isolate_huge_page(page, qp->pagelist) &&\n\t\t\t(flags & MPOL_MF_STRICT))\n\t\t\t/*\n\t\t\t * Failed to isolate page but allow migrating pages\n\t\t\t * which have been queued.\n\t\t\t */\n\t\t\tret = 1;\n\t}\nunlock:\n\tspin_unlock(ptl);\n#else\n\tBUG();\n#endif\n\treturn ret;\n}\n\n#ifdef CONFIG_NUMA_BALANCING\n/*\n * This is used to mark a range of virtual addresses to be inaccessible.\n * These are later cleared by a NUMA hinting fault. Depending on these\n * faults, pages may be migrated for better NUMA placement.\n *\n * This is assuming that NUMA faults are handled using PROT_NONE. If\n * an architecture makes a different choice, it will need further\n * changes to the core.\n */\nunsigned long change_prot_numa(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, unsigned long end)\n{\n\tint nr_updated;\n\n\tnr_updated = change_protection(vma, addr, end, PAGE_NONE, MM_CP_PROT_NUMA);\n\tif (nr_updated)\n\t\tcount_vm_numa_events(NUMA_PTE_UPDATES, nr_updated);\n\n\treturn nr_updated;\n}\n#else\nstatic unsigned long change_prot_numa(struct vm_area_struct *vma,\n\t\t\tunsigned long addr, unsigned long end)\n{\n\treturn 0;\n}\n#endif /* CONFIG_NUMA_BALANCING */\n\nstatic int queue_pages_test_walk(unsigned long start, unsigned long end,\n\t\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct queue_pages *qp = walk->private;\n\tunsigned long endvma = vma->vm_end;\n\tunsigned long flags = qp->flags;\n\n\t/* range check first */\n\tVM_BUG_ON_VMA((vma->vm_start > start) || (vma->vm_end < end), vma);\n\n\tif (!qp->first) {\n\t\tqp->first = vma;\n\t\tif (!(flags & MPOL_MF_DISCONTIG_OK) &&\n\t\t\t(qp->start < vma->vm_start))\n\t\t\t/* hole at head side of range */\n\t\t\treturn -EFAULT;\n\t}\n\tif (!(flags & MPOL_MF_DISCONTIG_OK) &&\n\t\t((vma->vm_end < qp->end) &&\n\t\t(!vma->vm_next || vma->vm_end < vma->vm_next->vm_start)))\n\t\t/* hole at middle or tail of range */\n\t\treturn -EFAULT;\n\n\t/*\n\t * Need check MPOL_MF_STRICT to return -EIO if possible\n\t * regardless of vma_migratable\n\t */\n\tif (!vma_migratable(vma) &&\n\t    !(flags & MPOL_MF_STRICT))\n\t\treturn 1;\n\n\tif (endvma > end)\n\t\tendvma = end;\n\n\tif (flags & MPOL_MF_LAZY) {\n\t\t/* Similar to task_numa_work, skip inaccessible VMAs */\n\t\tif (!is_vm_hugetlb_page(vma) && vma_is_accessible(vma) &&\n\t\t\t!(vma->vm_flags & VM_MIXEDMAP))\n\t\t\tchange_prot_numa(vma, start, endvma);\n\t\treturn 1;\n\t}\n\n\t/* queue pages from current vma */\n\tif (flags & MPOL_MF_VALID)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic const struct mm_walk_ops queue_pages_walk_ops = {\n\t.hugetlb_entry\t\t= queue_pages_hugetlb,\n\t.pmd_entry\t\t= queue_pages_pte_range,\n\t.test_walk\t\t= queue_pages_test_walk,\n};\n\n/*\n * Walk through page tables and collect pages to be migrated.\n *\n * If pages found in a given range are on a set of nodes (determined by\n * @nodes and @flags,) it's isolated and queued to the pagelist which is\n * passed via @private.\n *\n * queue_pages_range() has three possible return values:\n * 1 - there is unmovable page, but MPOL_MF_MOVE* & MPOL_MF_STRICT were\n *     specified.\n * 0 - queue pages successfully or no misplaced page.\n * errno - i.e. misplaced pages with MPOL_MF_STRICT specified (-EIO) or\n *         memory range specified by nodemask and maxnode points outside\n *         your accessible address space (-EFAULT)\n */\nstatic int\nqueue_pages_range(struct mm_struct *mm, unsigned long start, unsigned long end,\n\t\tnodemask_t *nodes, unsigned long flags,\n\t\tstruct list_head *pagelist)\n{\n\tint err;\n\tstruct queue_pages qp = {\n\t\t.pagelist = pagelist,\n\t\t.flags = flags,\n\t\t.nmask = nodes,\n\t\t.start = start,\n\t\t.end = end,\n\t\t.first = NULL,\n\t};\n\n\terr = walk_page_range(mm, start, end, &queue_pages_walk_ops, &qp);\n\n\tif (!qp.first)\n\t\t/* whole range in hole */\n\t\terr = -EFAULT;\n\n\treturn err;\n}\n\n/*\n * Apply policy to a single VMA\n * This must be called with the mmap_lock held for writing.\n */\nstatic int vma_replace_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tstruct mempolicy *pol)\n{\n\tint err;\n\tstruct mempolicy *old;\n\tstruct mempolicy *new;\n\n\tpr_debug(\"vma %lx-%lx/%lx vm_ops %p vm_file %p set_policy %p\\n\",\n\t\t vma->vm_start, vma->vm_end, vma->vm_pgoff,\n\t\t vma->vm_ops, vma->vm_file,\n\t\t vma->vm_ops ? vma->vm_ops->set_policy : NULL);\n\n\tnew = mpol_dup(pol);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tif (vma->vm_ops && vma->vm_ops->set_policy) {\n\t\terr = vma->vm_ops->set_policy(vma, new);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\told = vma->vm_policy;\n\tvma->vm_policy = new; /* protected by mmap_lock */\n\tmpol_put(old);\n\n\treturn 0;\n err_out:\n\tmpol_put(new);\n\treturn err;\n}\n\n/* Step 2: apply policy to a range and do splits. */\nstatic int mbind_range(struct mm_struct *mm, unsigned long start,\n\t\t       unsigned long end, struct mempolicy *new_pol)\n{\n\tstruct vm_area_struct *next;\n\tstruct vm_area_struct *prev;\n\tstruct vm_area_struct *vma;\n\tint err = 0;\n\tpgoff_t pgoff;\n\tunsigned long vmstart;\n\tunsigned long vmend;\n\n\tvma = find_vma(mm, start);\n\tVM_BUG_ON(!vma);\n\n\tprev = vma->vm_prev;\n\tif (start > vma->vm_start)\n\t\tprev = vma;\n\n\tfor (; vma && vma->vm_start < end; prev = vma, vma = next) {\n\t\tnext = vma->vm_next;\n\t\tvmstart = max(start, vma->vm_start);\n\t\tvmend   = min(end, vma->vm_end);\n\n\t\tif (mpol_equal(vma_policy(vma), new_pol))\n\t\t\tcontinue;\n\n\t\tpgoff = vma->vm_pgoff +\n\t\t\t((vmstart - vma->vm_start) >> PAGE_SHIFT);\n\t\tprev = vma_merge(mm, prev, vmstart, vmend, vma->vm_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, pgoff,\n\t\t\t\t new_pol, vma->vm_userfaultfd_ctx);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tnext = vma->vm_next;\n\t\t\tif (mpol_equal(vma_policy(vma), new_pol))\n\t\t\t\tcontinue;\n\t\t\t/* vma_merge() joined vma && vma->next, case 8 */\n\t\t\tgoto replace;\n\t\t}\n\t\tif (vma->vm_start != vmstart) {\n\t\t\terr = split_vma(vma->vm_mm, vma, vmstart, 1);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (vma->vm_end != vmend) {\n\t\t\terr = split_vma(vma->vm_mm, vma, vmend, 0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n replace:\n\t\terr = vma_replace_policy(vma, new_pol);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n out:\n\treturn err;\n}\n\n/* Set the process memory policy */\nstatic long do_set_mempolicy(unsigned short mode, unsigned short flags,\n\t\t\t     nodemask_t *nodes)\n{\n\tstruct mempolicy *new, *old;\n\tNODEMASK_SCRATCH(scratch);\n\tint ret;\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\tnew = mpol_new(mode, flags, nodes);\n\tif (IS_ERR(new)) {\n\t\tret = PTR_ERR(new);\n\t\tgoto out;\n\t}\n\n\tret = mpol_set_nodemask(new, nodes, scratch);\n\tif (ret) {\n\t\tmpol_put(new);\n\t\tgoto out;\n\t}\n\ttask_lock(current);\n\told = current->mempolicy;\n\tcurrent->mempolicy = new;\n\tif (new && new->mode == MPOL_INTERLEAVE)\n\t\tcurrent->il_prev = MAX_NUMNODES-1;\n\ttask_unlock(current);\n\tmpol_put(old);\n\tret = 0;\nout:\n\tNODEMASK_SCRATCH_FREE(scratch);\n\treturn ret;\n}\n\n/*\n * Return nodemask for policy for get_mempolicy() query\n *\n * Called with task's alloc_lock held\n */\nstatic void get_policy_nodemask(struct mempolicy *p, nodemask_t *nodes)\n{\n\tnodes_clear(*nodes);\n\tif (p == &default_policy)\n\t\treturn;\n\n\tswitch (p->mode) {\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\t*nodes = p->v.nodes;\n\t\tbreak;\n\tcase MPOL_PREFERRED:\n\t\tif (!(p->flags & MPOL_F_LOCAL))\n\t\t\tnode_set(p->v.preferred_node, *nodes);\n\t\t/* else return empty node mask for local allocation */\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic int lookup_node(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct page *p = NULL;\n\tint err;\n\n\tint locked = 1;\n\terr = get_user_pages_locked(addr & PAGE_MASK, 1, 0, &p, &locked);\n\tif (err > 0) {\n\t\terr = page_to_nid(p);\n\t\tput_page(p);\n\t}\n\tif (locked)\n\t\tmmap_read_unlock(mm);\n\treturn err;\n}\n\n/* Retrieve NUMA policy */\nstatic long do_get_mempolicy(int *policy, nodemask_t *nmask,\n\t\t\t     unsigned long addr, unsigned long flags)\n{\n\tint err;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mempolicy *pol = current->mempolicy, *pol_refcount = NULL;\n\n\tif (flags &\n\t\t~(unsigned long)(MPOL_F_NODE|MPOL_F_ADDR|MPOL_F_MEMS_ALLOWED))\n\t\treturn -EINVAL;\n\n\tif (flags & MPOL_F_MEMS_ALLOWED) {\n\t\tif (flags & (MPOL_F_NODE|MPOL_F_ADDR))\n\t\t\treturn -EINVAL;\n\t\t*policy = 0;\t/* just so it's initialized */\n\t\ttask_lock(current);\n\t\t*nmask  = cpuset_current_mems_allowed;\n\t\ttask_unlock(current);\n\t\treturn 0;\n\t}\n\n\tif (flags & MPOL_F_ADDR) {\n\t\t/*\n\t\t * Do NOT fall back to task policy if the\n\t\t * vma/shared policy at addr is NULL.  We\n\t\t * want to return MPOL_DEFAULT in this case.\n\t\t */\n\t\tmmap_read_lock(mm);\n\t\tvma = find_vma_intersection(mm, addr, addr+1);\n\t\tif (!vma) {\n\t\t\tmmap_read_unlock(mm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy)\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\telse\n\t\t\tpol = vma->vm_policy;\n\t} else if (addr)\n\t\treturn -EINVAL;\n\n\tif (!pol)\n\t\tpol = &default_policy;\t/* indicates default behavior */\n\n\tif (flags & MPOL_F_NODE) {\n\t\tif (flags & MPOL_F_ADDR) {\n\t\t\t/*\n\t\t\t * Take a refcount on the mpol, lookup_node()\n\t\t\t * wil drop the mmap_lock, so after calling\n\t\t\t * lookup_node() only \"pol\" remains valid, \"vma\"\n\t\t\t * is stale.\n\t\t\t */\n\t\t\tpol_refcount = pol;\n\t\t\tvma = NULL;\n\t\t\tmpol_get(pol);\n\t\t\terr = lookup_node(mm, addr);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\t*policy = err;\n\t\t} else if (pol == current->mempolicy &&\n\t\t\t\tpol->mode == MPOL_INTERLEAVE) {\n\t\t\t*policy = next_node_in(current->il_prev, pol->v.nodes);\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t*policy = pol == &default_policy ? MPOL_DEFAULT :\n\t\t\t\t\t\tpol->mode;\n\t\t/*\n\t\t * Internal mempolicy flags must be masked off before exposing\n\t\t * the policy to userspace.\n\t\t */\n\t\t*policy |= (pol->flags & MPOL_MODE_FLAGS);\n\t}\n\n\terr = 0;\n\tif (nmask) {\n\t\tif (mpol_store_user_nodemask(pol)) {\n\t\t\t*nmask = pol->w.user_nodemask;\n\t\t} else {\n\t\t\ttask_lock(current);\n\t\t\tget_policy_nodemask(pol, nmask);\n\t\t\ttask_unlock(current);\n\t\t}\n\t}\n\n out:\n\tmpol_cond_put(pol);\n\tif (vma)\n\t\tmmap_read_unlock(mm);\n\tif (pol_refcount)\n\t\tmpol_put(pol_refcount);\n\treturn err;\n}\n\n#ifdef CONFIG_MIGRATION\n/*\n * page migration, thp tail pages can be passed.\n */\nstatic int migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags)\n{\n\tstruct page *head = compound_head(page);\n\t/*\n\t * Avoid migrating a page that is shared with others.\n\t */\n\tif ((flags & MPOL_MF_MOVE_ALL) || page_mapcount(head) == 1) {\n\t\tif (!isolate_lru_page(head)) {\n\t\t\tlist_add_tail(&head->lru, pagelist);\n\t\t\tmod_node_page_state(page_pgdat(head),\n\t\t\t\tNR_ISOLATED_ANON + page_is_file_lru(head),\n\t\t\t\tthp_nr_pages(head));\n\t\t} else if (flags & MPOL_MF_STRICT) {\n\t\t\t/*\n\t\t\t * Non-movable page may reach here.  And, there may be\n\t\t\t * temporary off LRU pages or non-LRU movable pages.\n\t\t\t * Treat them as unmovable pages since they can't be\n\t\t\t * isolated, so they can't be moved at the moment.  It\n\t\t\t * should return -EIO for this case too.\n\t\t\t */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * Migrate pages from one node to a target node.\n * Returns error or the number of pages not migrated.\n */\nstatic int migrate_to_node(struct mm_struct *mm, int source, int dest,\n\t\t\t   int flags)\n{\n\tnodemask_t nmask;\n\tLIST_HEAD(pagelist);\n\tint err = 0;\n\tstruct migration_target_control mtc = {\n\t\t.nid = dest,\n\t\t.gfp_mask = GFP_HIGHUSER_MOVABLE | __GFP_THISNODE,\n\t};\n\n\tnodes_clear(nmask);\n\tnode_set(source, nmask);\n\n\t/*\n\t * This does not \"check\" the range but isolates all pages that\n\t * need migration.  Between passing in the full user address\n\t * space range and MPOL_MF_DISCONTIG_OK, this call can not fail.\n\t */\n\tVM_BUG_ON(!(flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)));\n\tqueue_pages_range(mm, mm->mmap->vm_start, mm->task_size, &nmask,\n\t\t\tflags | MPOL_MF_DISCONTIG_OK, &pagelist);\n\n\tif (!list_empty(&pagelist)) {\n\t\terr = migrate_pages(&pagelist, alloc_migration_target, NULL,\n\t\t\t\t(unsigned long)&mtc, MIGRATE_SYNC, MR_SYSCALL);\n\t\tif (err)\n\t\t\tputback_movable_pages(&pagelist);\n\t}\n\n\treturn err;\n}\n\n/*\n * Move pages between the two nodesets so as to preserve the physical\n * layout as much as possible.\n *\n * Returns the number of page that could not be moved.\n */\nint do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,\n\t\t     const nodemask_t *to, int flags)\n{\n\tint busy = 0;\n\tint err = 0;\n\tnodemask_t tmp;\n\n\tmigrate_prep();\n\n\tmmap_read_lock(mm);\n\n\t/*\n\t * Find a 'source' bit set in 'tmp' whose corresponding 'dest'\n\t * bit in 'to' is not also set in 'tmp'.  Clear the found 'source'\n\t * bit in 'tmp', and return that <source, dest> pair for migration.\n\t * The pair of nodemasks 'to' and 'from' define the map.\n\t *\n\t * If no pair of bits is found that way, fallback to picking some\n\t * pair of 'source' and 'dest' bits that are not the same.  If the\n\t * 'source' and 'dest' bits are the same, this represents a node\n\t * that will be migrating to itself, so no pages need move.\n\t *\n\t * If no bits are left in 'tmp', or if all remaining bits left\n\t * in 'tmp' correspond to the same bit in 'to', return false\n\t * (nothing left to migrate).\n\t *\n\t * This lets us pick a pair of nodes to migrate between, such that\n\t * if possible the dest node is not already occupied by some other\n\t * source node, minimizing the risk of overloading the memory on a\n\t * node that would happen if we migrated incoming memory to a node\n\t * before migrating outgoing memory source that same node.\n\t *\n\t * A single scan of tmp is sufficient.  As we go, we remember the\n\t * most recent <s, d> pair that moved (s != d).  If we find a pair\n\t * that not only moved, but what's better, moved to an empty slot\n\t * (d is not set in tmp), then we break out then, with that pair.\n\t * Otherwise when we finish scanning from_tmp, we at least have the\n\t * most recent <s, d> pair that moved.  If we get all the way through\n\t * the scan of tmp without finding any node that moved, much less\n\t * moved to an empty node, then there is nothing left worth migrating.\n\t */\n\n\ttmp = *from;\n\twhile (!nodes_empty(tmp)) {\n\t\tint s,d;\n\t\tint source = NUMA_NO_NODE;\n\t\tint dest = 0;\n\n\t\tfor_each_node_mask(s, tmp) {\n\n\t\t\t/*\n\t\t\t * do_migrate_pages() tries to maintain the relative\n\t\t\t * node relationship of the pages established between\n\t\t\t * threads and memory areas.\n                         *\n\t\t\t * However if the number of source nodes is not equal to\n\t\t\t * the number of destination nodes we can not preserve\n\t\t\t * this node relative relationship.  In that case, skip\n\t\t\t * copying memory from a node that is in the destination\n\t\t\t * mask.\n\t\t\t *\n\t\t\t * Example: [2,3,4] -> [3,4,5] moves everything.\n\t\t\t *          [0-7] - > [3,4,5] moves only 0,1,2,6,7.\n\t\t\t */\n\n\t\t\tif ((nodes_weight(*from) != nodes_weight(*to)) &&\n\t\t\t\t\t\t(node_isset(s, *to)))\n\t\t\t\tcontinue;\n\n\t\t\td = node_remap(s, *from, *to);\n\t\t\tif (s == d)\n\t\t\t\tcontinue;\n\n\t\t\tsource = s;\t/* Node moved. Memorize */\n\t\t\tdest = d;\n\n\t\t\t/* dest not in remaining from nodes? */\n\t\t\tif (!node_isset(dest, tmp))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (source == NUMA_NO_NODE)\n\t\t\tbreak;\n\n\t\tnode_clear(source, tmp);\n\t\terr = migrate_to_node(mm, source, dest, flags);\n\t\tif (err > 0)\n\t\t\tbusy += err;\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\tmmap_read_unlock(mm);\n\tif (err < 0)\n\t\treturn err;\n\treturn busy;\n\n}\n\n/*\n * Allocate a new page for page migration based on vma policy.\n * Start by assuming the page is mapped by the same vma as contains @start.\n * Search forward from there, if not.  N.B., this assumes that the\n * list of pages handed to migrate_pages()--which is how we get here--\n * is in virtual address order.\n */\nstatic struct page *new_page(struct page *page, unsigned long start)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned long address;\n\n\tvma = find_vma(current->mm, start);\n\twhile (vma) {\n\t\taddress = page_address_in_vma(page, vma);\n\t\tif (address != -EFAULT)\n\t\t\tbreak;\n\t\tvma = vma->vm_next;\n\t}\n\n\tif (PageHuge(page)) {\n\t\treturn alloc_huge_page_vma(page_hstate(compound_head(page)),\n\t\t\t\tvma, address);\n\t} else if (PageTransHuge(page)) {\n\t\tstruct page *thp;\n\n\t\tthp = alloc_hugepage_vma(GFP_TRANSHUGE, vma, address,\n\t\t\t\t\t HPAGE_PMD_ORDER);\n\t\tif (!thp)\n\t\t\treturn NULL;\n\t\tprep_transhuge_page(thp);\n\t\treturn thp;\n\t}\n\t/*\n\t * if !vma, alloc_page_vma() will use task or system default policy\n\t */\n\treturn alloc_page_vma(GFP_HIGHUSER_MOVABLE | __GFP_RETRY_MAYFAIL,\n\t\t\tvma, address);\n}\n#else\n\nstatic int migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags)\n{\n\treturn -EIO;\n}\n\nint do_migrate_pages(struct mm_struct *mm, const nodemask_t *from,\n\t\t     const nodemask_t *to, int flags)\n{\n\treturn -ENOSYS;\n}\n\nstatic struct page *new_page(struct page *page, unsigned long start)\n{\n\treturn NULL;\n}\n#endif\n\nstatic long do_mbind(unsigned long start, unsigned long len,\n\t\t     unsigned short mode, unsigned short mode_flags,\n\t\t     nodemask_t *nmask, unsigned long flags)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct mempolicy *new;\n\tunsigned long end;\n\tint err;\n\tint ret;\n\tLIST_HEAD(pagelist);\n\n\tif (flags & ~(unsigned long)MPOL_MF_VALID)\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\n\tif (start & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\tif (mode == MPOL_DEFAULT)\n\t\tflags &= ~MPOL_MF_STRICT;\n\n\tlen = (len + PAGE_SIZE - 1) & PAGE_MASK;\n\tend = start + len;\n\n\tif (end < start)\n\t\treturn -EINVAL;\n\tif (end == start)\n\t\treturn 0;\n\n\tnew = mpol_new(mode, mode_flags, nmask);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tif (flags & MPOL_MF_LAZY)\n\t\tnew->flags |= MPOL_F_MOF;\n\n\t/*\n\t * If we are using the default policy then operation\n\t * on discontinuous address spaces is okay after all\n\t */\n\tif (!new)\n\t\tflags |= MPOL_MF_DISCONTIG_OK;\n\n\tpr_debug(\"mbind %lx-%lx mode:%d flags:%d nodes:%lx\\n\",\n\t\t start, start + len, mode, mode_flags,\n\t\t nmask ? nodes_addr(*nmask)[0] : NUMA_NO_NODE);\n\n\tif (flags & (MPOL_MF_MOVE | MPOL_MF_MOVE_ALL)) {\n\n\t\tmigrate_prep();\n\t}\n\t{\n\t\tNODEMASK_SCRATCH(scratch);\n\t\tif (scratch) {\n\t\t\tmmap_write_lock(mm);\n\t\t\terr = mpol_set_nodemask(new, nmask, scratch);\n\t\t\tif (err)\n\t\t\t\tmmap_write_unlock(mm);\n\t\t} else\n\t\t\terr = -ENOMEM;\n\t\tNODEMASK_SCRATCH_FREE(scratch);\n\t}\n\tif (err)\n\t\tgoto mpol_out;\n\n\tret = queue_pages_range(mm, start, end, nmask,\n\t\t\t  flags | MPOL_MF_INVERT, &pagelist);\n\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto up_out;\n\t}\n\n\terr = mbind_range(mm, start, end, new);\n\n\tif (!err) {\n\t\tint nr_failed = 0;\n\n\t\tif (!list_empty(&pagelist)) {\n\t\t\tWARN_ON_ONCE(flags & MPOL_MF_LAZY);\n\t\t\tnr_failed = migrate_pages(&pagelist, new_page, NULL,\n\t\t\t\tstart, MIGRATE_SYNC, MR_MEMPOLICY_MBIND);\n\t\t\tif (nr_failed)\n\t\t\t\tputback_movable_pages(&pagelist);\n\t\t}\n\n\t\tif ((ret > 0) || (nr_failed && (flags & MPOL_MF_STRICT)))\n\t\t\terr = -EIO;\n\t} else {\nup_out:\n\t\tif (!list_empty(&pagelist))\n\t\t\tputback_movable_pages(&pagelist);\n\t}\n\n\tmmap_write_unlock(mm);\nmpol_out:\n\tmpol_put(new);\n\treturn err;\n}\n\n/*\n * User space interface with variable sized bitmaps for nodelists.\n */\n\n/* Copy a node mask from user space. */\nstatic int get_nodes(nodemask_t *nodes, const unsigned long __user *nmask,\n\t\t     unsigned long maxnode)\n{\n\tunsigned long k;\n\tunsigned long t;\n\tunsigned long nlongs;\n\tunsigned long endmask;\n\n\t--maxnode;\n\tnodes_clear(*nodes);\n\tif (maxnode == 0 || !nmask)\n\t\treturn 0;\n\tif (maxnode > PAGE_SIZE*BITS_PER_BYTE)\n\t\treturn -EINVAL;\n\n\tnlongs = BITS_TO_LONGS(maxnode);\n\tif ((maxnode % BITS_PER_LONG) == 0)\n\t\tendmask = ~0UL;\n\telse\n\t\tendmask = (1UL << (maxnode % BITS_PER_LONG)) - 1;\n\n\t/*\n\t * When the user specified more nodes than supported just check\n\t * if the non supported part is all zero.\n\t *\n\t * If maxnode have more longs than MAX_NUMNODES, check\n\t * the bits in that area first. And then go through to\n\t * check the rest bits which equal or bigger than MAX_NUMNODES.\n\t * Otherwise, just check bits [MAX_NUMNODES, maxnode).\n\t */\n\tif (nlongs > BITS_TO_LONGS(MAX_NUMNODES)) {\n\t\tfor (k = BITS_TO_LONGS(MAX_NUMNODES); k < nlongs; k++) {\n\t\t\tif (get_user(t, nmask + k))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (k == nlongs - 1) {\n\t\t\t\tif (t & endmask)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t} else if (t)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tnlongs = BITS_TO_LONGS(MAX_NUMNODES);\n\t\tendmask = ~0UL;\n\t}\n\n\tif (maxnode > MAX_NUMNODES && MAX_NUMNODES % BITS_PER_LONG != 0) {\n\t\tunsigned long valid_mask = endmask;\n\n\t\tvalid_mask &= ~((1UL << (MAX_NUMNODES % BITS_PER_LONG)) - 1);\n\t\tif (get_user(t, nmask + nlongs - 1))\n\t\t\treturn -EFAULT;\n\t\tif (t & valid_mask)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(nodes_addr(*nodes), nmask, nlongs*sizeof(unsigned long)))\n\t\treturn -EFAULT;\n\tnodes_addr(*nodes)[nlongs-1] &= endmask;\n\treturn 0;\n}\n\n/* Copy a kernel node mask to user space */\nstatic int copy_nodes_to_user(unsigned long __user *mask, unsigned long maxnode,\n\t\t\t      nodemask_t *nodes)\n{\n\tunsigned long copy = ALIGN(maxnode-1, 64) / 8;\n\tunsigned int nbytes = BITS_TO_LONGS(nr_node_ids) * sizeof(long);\n\n\tif (copy > nbytes) {\n\t\tif (copy > PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tif (clear_user((char __user *)mask + nbytes, copy - nbytes))\n\t\t\treturn -EFAULT;\n\t\tcopy = nbytes;\n\t}\n\treturn copy_to_user(mask, nodes_addr(*nodes), copy) ? -EFAULT : 0;\n}\n\nstatic long kernel_mbind(unsigned long start, unsigned long len,\n\t\t\t unsigned long mode, const unsigned long __user *nmask,\n\t\t\t unsigned long maxnode, unsigned int flags)\n{\n\tnodemask_t nodes;\n\tint err;\n\tunsigned short mode_flags;\n\n\tstart = untagged_addr(start);\n\tmode_flags = mode & MPOL_MODE_FLAGS;\n\tmode &= ~MPOL_MODE_FLAGS;\n\tif (mode >= MPOL_MAX)\n\t\treturn -EINVAL;\n\tif ((mode_flags & MPOL_F_STATIC_NODES) &&\n\t    (mode_flags & MPOL_F_RELATIVE_NODES))\n\t\treturn -EINVAL;\n\terr = get_nodes(&nodes, nmask, maxnode);\n\tif (err)\n\t\treturn err;\n\treturn do_mbind(start, len, mode, mode_flags, &nodes, flags);\n}\n\nSYSCALL_DEFINE6(mbind, unsigned long, start, unsigned long, len,\n\t\tunsigned long, mode, const unsigned long __user *, nmask,\n\t\tunsigned long, maxnode, unsigned int, flags)\n{\n\treturn kernel_mbind(start, len, mode, nmask, maxnode, flags);\n}\n\n/* Set the process memory policy */\nstatic long kernel_set_mempolicy(int mode, const unsigned long __user *nmask,\n\t\t\t\t unsigned long maxnode)\n{\n\tint err;\n\tnodemask_t nodes;\n\tunsigned short flags;\n\n\tflags = mode & MPOL_MODE_FLAGS;\n\tmode &= ~MPOL_MODE_FLAGS;\n\tif ((unsigned int)mode >= MPOL_MAX)\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_F_STATIC_NODES) && (flags & MPOL_F_RELATIVE_NODES))\n\t\treturn -EINVAL;\n\terr = get_nodes(&nodes, nmask, maxnode);\n\tif (err)\n\t\treturn err;\n\treturn do_set_mempolicy(mode, flags, &nodes);\n}\n\nSYSCALL_DEFINE3(set_mempolicy, int, mode, const unsigned long __user *, nmask,\n\t\tunsigned long, maxnode)\n{\n\treturn kernel_set_mempolicy(mode, nmask, maxnode);\n}\n\nstatic int kernel_migrate_pages(pid_t pid, unsigned long maxnode,\n\t\t\t\tconst unsigned long __user *old_nodes,\n\t\t\t\tconst unsigned long __user *new_nodes)\n{\n\tstruct mm_struct *mm = NULL;\n\tstruct task_struct *task;\n\tnodemask_t task_nodes;\n\tint err;\n\tnodemask_t *old;\n\tnodemask_t *new;\n\tNODEMASK_SCRATCH(scratch);\n\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\told = &scratch->mask1;\n\tnew = &scratch->mask2;\n\n\terr = get_nodes(old, old_nodes, maxnode);\n\tif (err)\n\t\tgoto out;\n\n\terr = get_nodes(new, new_nodes, maxnode);\n\tif (err)\n\t\tgoto out;\n\n\t/* Find the mm_struct */\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\tget_task_struct(task);\n\n\terr = -EINVAL;\n\n\t/*\n\t * Check if this process has the right to modify the specified process.\n\t * Use the regular \"mm_access()\" checks.\n\t */\n\tmm = mm_access(task, PTRACE_MODE_READ_REALCREDS);\n\tif (IS_ERR(mm)) {\n\t\trcu_read_unlock();\n\t\terr = PTR_ERR(mm);\n\t\tmm = NULL;\n\t\tgoto out_put;\n\t}\n\trcu_read_unlock();\n\n\ttask_nodes = cpuset_mems_allowed(task);\n\t/* Is the user allowed to access the target nodes? */\n\tif (!nodes_subset(*new, task_nodes) && !capable(CAP_SYS_NICE)) {\n\t\terr = -EPERM;\n\t\tgoto out_put;\n\t}\n\n\ttask_nodes = cpuset_mems_allowed(current);\n\tnodes_and(*new, *new, task_nodes);\n\tif (nodes_empty(*new))\n\t\tgoto out_put;\n\n\terr = security_task_movememory(task);\n\tif (err)\n\t\tgoto out_put;\n\n\tput_task_struct(task);\n\n\tif (!mm) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = do_migrate_pages(mm, old, new,\n\t\tcapable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE);\n\n\tmmput(mm);\nout:\n\tNODEMASK_SCRATCH_FREE(scratch);\n\n\treturn err;\n\nout_put:\n\tif (mm)\n\t\tmmput(mm);\n\tput_task_struct(task);\n\tgoto out;\n\n}\n\nSYSCALL_DEFINE4(migrate_pages, pid_t, pid, unsigned long, maxnode,\n\t\tconst unsigned long __user *, old_nodes,\n\t\tconst unsigned long __user *, new_nodes)\n{\n\treturn kernel_migrate_pages(pid, maxnode, old_nodes, new_nodes);\n}\n\n\n/* Retrieve NUMA policy */\nstatic int kernel_get_mempolicy(int __user *policy,\n\t\t\t\tunsigned long __user *nmask,\n\t\t\t\tunsigned long maxnode,\n\t\t\t\tunsigned long addr,\n\t\t\t\tunsigned long flags)\n{\n\tint err;\n\tint pval;\n\tnodemask_t nodes;\n\n\tif (nmask != NULL && maxnode < nr_node_ids)\n\t\treturn -EINVAL;\n\n\taddr = untagged_addr(addr);\n\n\terr = do_get_mempolicy(&pval, &nodes, addr, flags);\n\n\tif (err)\n\t\treturn err;\n\n\tif (policy && put_user(pval, policy))\n\t\treturn -EFAULT;\n\n\tif (nmask)\n\t\terr = copy_nodes_to_user(nmask, maxnode, &nodes);\n\n\treturn err;\n}\n\nSYSCALL_DEFINE5(get_mempolicy, int __user *, policy,\n\t\tunsigned long __user *, nmask, unsigned long, maxnode,\n\t\tunsigned long, addr, unsigned long, flags)\n{\n\treturn kernel_get_mempolicy(policy, nmask, maxnode, addr, flags);\n}\n\n#ifdef CONFIG_COMPAT\n\nCOMPAT_SYSCALL_DEFINE5(get_mempolicy, int __user *, policy,\n\t\t       compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode,\n\t\t       compat_ulong_t, addr, compat_ulong_t, flags)\n{\n\tlong err;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\n\tnr_bits = min_t(unsigned long, maxnode-1, nr_node_ids);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask)\n\t\tnm = compat_alloc_user_space(alloc_size);\n\n\terr = kernel_get_mempolicy(policy, nm, nr_bits+1, addr, flags);\n\n\tif (!err && nmask) {\n\t\tunsigned long copy_size;\n\t\tcopy_size = min_t(unsigned long, sizeof(bm), alloc_size);\n\t\terr = copy_from_user(bm, nm, copy_size);\n\t\t/* ensure entire bitmap is zeroed */\n\t\terr |= clear_user(nmask, ALIGN(maxnode-1, 8) / 8);\n\t\terr |= compat_put_bitmap(nmask, bm, nr_bits);\n\t}\n\n\treturn err;\n}\n\nCOMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode)\n{\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask) {\n\t\tif (compat_get_bitmap(bm, nmask, nr_bits))\n\t\t\treturn -EFAULT;\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\tif (copy_to_user(nm, bm, alloc_size))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn kernel_set_mempolicy(mode, nm, nr_bits+1);\n}\n\nCOMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,\n\t\t       compat_ulong_t, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode, compat_ulong_t, flags)\n{\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tnodemask_t bm;\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask) {\n\t\tif (compat_get_bitmap(nodes_addr(bm), nmask, nr_bits))\n\t\t\treturn -EFAULT;\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\tif (copy_to_user(nm, nodes_addr(bm), alloc_size))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn kernel_mbind(start, len, mode, nm, nr_bits+1, flags);\n}\n\nCOMPAT_SYSCALL_DEFINE4(migrate_pages, compat_pid_t, pid,\n\t\t       compat_ulong_t, maxnode,\n\t\t       const compat_ulong_t __user *, old_nodes,\n\t\t       const compat_ulong_t __user *, new_nodes)\n{\n\tunsigned long __user *old = NULL;\n\tunsigned long __user *new = NULL;\n\tnodemask_t tmp_mask;\n\tunsigned long nr_bits;\n\tunsigned long size;\n\n\tnr_bits = min_t(unsigned long, maxnode - 1, MAX_NUMNODES);\n\tsize = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\tif (old_nodes) {\n\t\tif (compat_get_bitmap(nodes_addr(tmp_mask), old_nodes, nr_bits))\n\t\t\treturn -EFAULT;\n\t\told = compat_alloc_user_space(new_nodes ? size * 2 : size);\n\t\tif (new_nodes)\n\t\t\tnew = old + size / sizeof(unsigned long);\n\t\tif (copy_to_user(old, nodes_addr(tmp_mask), size))\n\t\t\treturn -EFAULT;\n\t}\n\tif (new_nodes) {\n\t\tif (compat_get_bitmap(nodes_addr(tmp_mask), new_nodes, nr_bits))\n\t\t\treturn -EFAULT;\n\t\tif (new == NULL)\n\t\t\tnew = compat_alloc_user_space(size);\n\t\tif (copy_to_user(new, nodes_addr(tmp_mask), size))\n\t\t\treturn -EFAULT;\n\t}\n\treturn kernel_migrate_pages(pid, nr_bits + 1, old, new);\n}\n\n#endif /* CONFIG_COMPAT */\n\nbool vma_migratable(struct vm_area_struct *vma)\n{\n\tif (vma->vm_flags & (VM_IO | VM_PFNMAP))\n\t\treturn false;\n\n\t/*\n\t * DAX device mappings require predictable access latency, so avoid\n\t * incurring periodic faults.\n\t */\n\tif (vma_is_dax(vma))\n\t\treturn false;\n\n\tif (is_vm_hugetlb_page(vma) &&\n\t\t!hugepage_migration_supported(hstate_vma(vma)))\n\t\treturn false;\n\n\t/*\n\t * Migration allocates pages in the highest zone. If we cannot\n\t * do so then migration (at least from node to node) is not\n\t * possible.\n\t */\n\tif (vma->vm_file &&\n\t\tgfp_zone(mapping_gfp_mask(vma->vm_file->f_mapping))\n\t\t\t< policy_zone)\n\t\treturn false;\n\treturn true;\n}\n\nstruct mempolicy *__get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = NULL;\n\n\tif (vma) {\n\t\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\t\tpol = vma->vm_ops->get_policy(vma, addr);\n\t\t} else if (vma->vm_policy) {\n\t\t\tpol = vma->vm_policy;\n\n\t\t\t/*\n\t\t\t * shmem_alloc_page() passes MPOL_F_SHARED policy with\n\t\t\t * a pseudo vma whose vma->vm_ops=NULL. Take a reference\n\t\t\t * count on these policies which will be dropped by\n\t\t\t * mpol_cond_put() later\n\t\t\t */\n\t\t\tif (mpol_needs_cond_ref(pol))\n\t\t\t\tmpol_get(pol);\n\t\t}\n\t}\n\n\treturn pol;\n}\n\n/*\n * get_vma_policy(@vma, @addr)\n * @vma: virtual memory area whose policy is sought\n * @addr: address in @vma for shared policy lookup\n *\n * Returns effective policy for a VMA at specified address.\n * Falls back to current->mempolicy or system default policy, as necessary.\n * Shared policies [those marked as MPOL_F_SHARED] require an extra reference\n * count--added by the get_policy() vm_op, as appropriate--to protect against\n * freeing by another task.  It is the caller's responsibility to free the\n * extra reference for shared policies.\n */\nstatic struct mempolicy *get_vma_policy(struct vm_area_struct *vma,\n\t\t\t\t\t\tunsigned long addr)\n{\n\tstruct mempolicy *pol = __get_vma_policy(vma, addr);\n\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol;\n}\n\nbool vma_policy_mof(struct vm_area_struct *vma)\n{\n\tstruct mempolicy *pol;\n\n\tif (vma->vm_ops && vma->vm_ops->get_policy) {\n\t\tbool ret = false;\n\n\t\tpol = vma->vm_ops->get_policy(vma, vma->vm_start);\n\t\tif (pol && (pol->flags & MPOL_F_MOF))\n\t\t\tret = true;\n\t\tmpol_cond_put(pol);\n\n\t\treturn ret;\n\t}\n\n\tpol = vma->vm_policy;\n\tif (!pol)\n\t\tpol = get_task_policy(current);\n\n\treturn pol->flags & MPOL_F_MOF;\n}\n\nstatic int apply_policy_zone(struct mempolicy *policy, enum zone_type zone)\n{\n\tenum zone_type dynamic_policy_zone = policy_zone;\n\n\tBUG_ON(dynamic_policy_zone == ZONE_MOVABLE);\n\n\t/*\n\t * if policy->v.nodes has movable memory only,\n\t * we apply policy when gfp_zone(gfp) = ZONE_MOVABLE only.\n\t *\n\t * policy->v.nodes is intersect with node_states[N_MEMORY].\n\t * so if the following test faile, it implies\n\t * policy->v.nodes has movable memory only.\n\t */\n\tif (!nodes_intersects(policy->v.nodes, node_states[N_HIGH_MEMORY]))\n\t\tdynamic_policy_zone = ZONE_MOVABLE;\n\n\treturn zone >= dynamic_policy_zone;\n}\n\n/*\n * Return a nodemask representing a mempolicy for filtering nodes for\n * page allocation\n */\nnodemask_t *policy_nodemask(gfp_t gfp, struct mempolicy *policy)\n{\n\t/* Lower zones don't get a nodemask applied for MPOL_BIND */\n\tif (unlikely(policy->mode == MPOL_BIND) &&\n\t\t\tapply_policy_zone(policy, gfp_zone(gfp)) &&\n\t\t\tcpuset_nodemask_valid_mems_allowed(&policy->v.nodes))\n\t\treturn &policy->v.nodes;\n\n\treturn NULL;\n}\n\n/* Return the node id preferred by the given mempolicy, or the given id */\nstatic int policy_node(gfp_t gfp, struct mempolicy *policy, int nd)\n{\n\tif (policy->mode == MPOL_PREFERRED && !(policy->flags & MPOL_F_LOCAL))\n\t\tnd = policy->v.preferred_node;\n\telse {\n\t\t/*\n\t\t * __GFP_THISNODE shouldn't even be used with the bind policy\n\t\t * because we might easily break the expectation to stay on the\n\t\t * requested node and not break the policy.\n\t\t */\n\t\tWARN_ON_ONCE(policy->mode == MPOL_BIND && (gfp & __GFP_THISNODE));\n\t}\n\n\treturn nd;\n}\n\n/* Do dynamic interleaving for a process */\nstatic unsigned interleave_nodes(struct mempolicy *policy)\n{\n\tunsigned next;\n\tstruct task_struct *me = current;\n\n\tnext = next_node_in(me->il_prev, policy->v.nodes);\n\tif (next < MAX_NUMNODES)\n\t\tme->il_prev = next;\n\treturn next;\n}\n\n/*\n * Depending on the memory policy provide a node from which to allocate the\n * next slab entry.\n */\nunsigned int mempolicy_slab_node(void)\n{\n\tstruct mempolicy *policy;\n\tint node = numa_mem_id();\n\n\tif (in_interrupt())\n\t\treturn node;\n\n\tpolicy = current->mempolicy;\n\tif (!policy || policy->flags & MPOL_F_LOCAL)\n\t\treturn node;\n\n\tswitch (policy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * handled MPOL_F_LOCAL above\n\t\t */\n\t\treturn policy->v.preferred_node;\n\n\tcase MPOL_INTERLEAVE:\n\t\treturn interleave_nodes(policy);\n\n\tcase MPOL_BIND: {\n\t\tstruct zoneref *z;\n\n\t\t/*\n\t\t * Follow bind policy behavior and start allocation at the\n\t\t * first node.\n\t\t */\n\t\tstruct zonelist *zonelist;\n\t\tenum zone_type highest_zoneidx = gfp_zone(GFP_KERNEL);\n\t\tzonelist = &NODE_DATA(node)->node_zonelists[ZONELIST_FALLBACK];\n\t\tz = first_zones_zonelist(zonelist, highest_zoneidx,\n\t\t\t\t\t\t\t&policy->v.nodes);\n\t\treturn z->zone ? zone_to_nid(z->zone) : node;\n\t}\n\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n/*\n * Do static interleaving for a VMA with known offset @n.  Returns the n'th\n * node in pol->v.nodes (starting from n=0), wrapping around if n exceeds the\n * number of present nodes.\n */\nstatic unsigned offset_il_node(struct mempolicy *pol, unsigned long n)\n{\n\tunsigned nnodes = nodes_weight(pol->v.nodes);\n\tunsigned target;\n\tint i;\n\tint nid;\n\n\tif (!nnodes)\n\t\treturn numa_node_id();\n\ttarget = (unsigned int)n % nnodes;\n\tnid = first_node(pol->v.nodes);\n\tfor (i = 0; i < target; i++)\n\t\tnid = next_node(nid, pol->v.nodes);\n\treturn nid;\n}\n\n/* Determine a node number for interleave */\nstatic inline unsigned interleave_nid(struct mempolicy *pol,\n\t\t struct vm_area_struct *vma, unsigned long addr, int shift)\n{\n\tif (vma) {\n\t\tunsigned long off;\n\n\t\t/*\n\t\t * for small pages, there is no difference between\n\t\t * shift and PAGE_SHIFT, so the bit-shift is safe.\n\t\t * for huge pages, since vm_pgoff is in units of small\n\t\t * pages, we need to shift off the always 0 bits to get\n\t\t * a useful offset.\n\t\t */\n\t\tBUG_ON(shift < PAGE_SHIFT);\n\t\toff = vma->vm_pgoff >> (shift - PAGE_SHIFT);\n\t\toff += (addr - vma->vm_start) >> shift;\n\t\treturn offset_il_node(pol, off);\n\t} else\n\t\treturn interleave_nodes(pol);\n}\n\n#ifdef CONFIG_HUGETLBFS\n/*\n * huge_node(@vma, @addr, @gfp_flags, @mpol)\n * @vma: virtual memory area whose policy is sought\n * @addr: address in @vma for shared policy lookup and interleave policy\n * @gfp_flags: for requested zone\n * @mpol: pointer to mempolicy pointer for reference counted mempolicy\n * @nodemask: pointer to nodemask pointer for MPOL_BIND nodemask\n *\n * Returns a nid suitable for a huge page allocation and a pointer\n * to the struct mempolicy for conditional unref after allocation.\n * If the effective policy is 'BIND, returns a pointer to the mempolicy's\n * @nodemask for filtering the zonelist.\n *\n * Must be protected by read_mems_allowed_begin()\n */\nint huge_node(struct vm_area_struct *vma, unsigned long addr, gfp_t gfp_flags,\n\t\t\t\tstruct mempolicy **mpol, nodemask_t **nodemask)\n{\n\tint nid;\n\n\t*mpol = get_vma_policy(vma, addr);\n\t*nodemask = NULL;\t/* assume !MPOL_BIND */\n\n\tif (unlikely((*mpol)->mode == MPOL_INTERLEAVE)) {\n\t\tnid = interleave_nid(*mpol, vma, addr,\n\t\t\t\t\thuge_page_shift(hstate_vma(vma)));\n\t} else {\n\t\tnid = policy_node(gfp_flags, *mpol, numa_node_id());\n\t\tif ((*mpol)->mode == MPOL_BIND)\n\t\t\t*nodemask = &(*mpol)->v.nodes;\n\t}\n\treturn nid;\n}\n\n/*\n * init_nodemask_of_mempolicy\n *\n * If the current task's mempolicy is \"default\" [NULL], return 'false'\n * to indicate default policy.  Otherwise, extract the policy nodemask\n * for 'bind' or 'interleave' policy into the argument nodemask, or\n * initialize the argument nodemask to contain the single node for\n * 'preferred' or 'local' policy and return 'true' to indicate presence\n * of non-default mempolicy.\n *\n * We don't bother with reference counting the mempolicy [mpol_get/put]\n * because the current task is examining it's own mempolicy and a task's\n * mempolicy is only ever changed by the task itself.\n *\n * N.B., it is the caller's responsibility to free a returned nodemask.\n */\nbool init_nodemask_of_mempolicy(nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tint nid;\n\n\tif (!(mask && current->mempolicy))\n\t\treturn false;\n\n\ttask_lock(current);\n\tmempolicy = current->mempolicy;\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\tif (mempolicy->flags & MPOL_F_LOCAL)\n\t\t\tnid = numa_node_id();\n\t\telse\n\t\t\tnid = mempolicy->v.preferred_node;\n\t\tinit_nodemask_of_node(mask, nid);\n\t\tbreak;\n\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\t*mask =  mempolicy->v.nodes;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\ttask_unlock(current);\n\n\treturn true;\n}\n#endif\n\n/*\n * mempolicy_nodemask_intersects\n *\n * If tsk's mempolicy is \"default\" [NULL], return 'true' to indicate default\n * policy.  Otherwise, check for intersection between mask and the policy\n * nodemask for 'bind' or 'interleave' policy.  For 'perferred' or 'local'\n * policy, always return true since it may allocate elsewhere on fallback.\n *\n * Takes task_lock(tsk) to prevent freeing of its mempolicy.\n */\nbool mempolicy_nodemask_intersects(struct task_struct *tsk,\n\t\t\t\t\tconst nodemask_t *mask)\n{\n\tstruct mempolicy *mempolicy;\n\tbool ret = true;\n\n\tif (!mask)\n\t\treturn ret;\n\ttask_lock(tsk);\n\tmempolicy = tsk->mempolicy;\n\tif (!mempolicy)\n\t\tgoto out;\n\n\tswitch (mempolicy->mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * MPOL_PREFERRED and MPOL_F_LOCAL are only preferred nodes to\n\t\t * allocate from, they may fallback to other nodes when oom.\n\t\t * Thus, it's possible for tsk to have allocated memory from\n\t\t * nodes in mask.\n\t\t */\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\tret = nodes_intersects(mempolicy->v.nodes, *mask);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\nout:\n\ttask_unlock(tsk);\n\treturn ret;\n}\n\n/* Allocate a page in interleaved policy.\n   Own path because it needs to do special accounting. */\nstatic struct page *alloc_page_interleave(gfp_t gfp, unsigned order,\n\t\t\t\t\tunsigned nid)\n{\n\tstruct page *page;\n\n\tpage = __alloc_pages(gfp, order, nid);\n\t/* skip NUMA_INTERLEAVE_HIT counter update if numa stats is disabled */\n\tif (!static_branch_likely(&vm_numa_stat_key))\n\t\treturn page;\n\tif (page && page_to_nid(page) == nid) {\n\t\tpreempt_disable();\n\t\t__inc_numa_state(page_zone(page), NUMA_INTERLEAVE_HIT);\n\t\tpreempt_enable();\n\t}\n\treturn page;\n}\n\n/**\n * \talloc_pages_vma\t- Allocate a page for a VMA.\n *\n * \t@gfp:\n *      %GFP_USER    user allocation.\n *      %GFP_KERNEL  kernel allocations,\n *      %GFP_HIGHMEM highmem/user allocations,\n *      %GFP_FS      allocation should not call back into a file system.\n *      %GFP_ATOMIC  don't sleep.\n *\n *\t@order:Order of the GFP allocation.\n * \t@vma:  Pointer to VMA or NULL if not available.\n *\t@addr: Virtual Address of the allocation. Must be inside the VMA.\n *\t@node: Which node to prefer for allocation (modulo policy).\n *\t@hugepage: for hugepages try only the preferred node if possible\n *\n * \tThis function allocates a page from the kernel page pool and applies\n *\ta NUMA policy associated with the VMA or the current process.\n *\tWhen VMA is not NULL caller must read-lock the mmap_lock of the\n *\tmm_struct of the VMA to prevent it from going away. Should be used for\n *\tall allocations for pages that will be mapped into user space. Returns\n *\tNULL when no page can be allocated.\n */\nstruct page *\nalloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,\n\t\tunsigned long addr, int node, bool hugepage)\n{\n\tstruct mempolicy *pol;\n\tstruct page *page;\n\tint preferred_nid;\n\tnodemask_t *nmask;\n\n\tpol = get_vma_policy(vma, addr);\n\n\tif (pol->mode == MPOL_INTERLEAVE) {\n\t\tunsigned nid;\n\n\t\tnid = interleave_nid(pol, vma, addr, PAGE_SHIFT + order);\n\t\tmpol_cond_put(pol);\n\t\tpage = alloc_page_interleave(gfp, order, nid);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) && hugepage)) {\n\t\tint hpage_node = node;\n\n\t\t/*\n\t\t * For hugepage allocation and non-interleave policy which\n\t\t * allows the current node (or other explicitly preferred\n\t\t * node) we only try to allocate from the current/preferred\n\t\t * node and don't fall back to other nodes, as the cost of\n\t\t * remote accesses would likely offset THP benefits.\n\t\t *\n\t\t * If the policy is interleave, or does not allow the current\n\t\t * node in its nodemask, we allocate the standard way.\n\t\t */\n\t\tif (pol->mode == MPOL_PREFERRED && !(pol->flags & MPOL_F_LOCAL))\n\t\t\thpage_node = pol->v.preferred_node;\n\n\t\tnmask = policy_nodemask(gfp, pol);\n\t\tif (!nmask || node_isset(hpage_node, *nmask)) {\n\t\t\tmpol_cond_put(pol);\n\t\t\t/*\n\t\t\t * First, try to allocate THP only on local node, but\n\t\t\t * don't reclaim unnecessarily, just compact.\n\t\t\t */\n\t\t\tpage = __alloc_pages_node(hpage_node,\n\t\t\t\tgfp | __GFP_THISNODE | __GFP_NORETRY, order);\n\n\t\t\t/*\n\t\t\t * If hugepage allocations are configured to always\n\t\t\t * synchronous compact or the vma has been madvised\n\t\t\t * to prefer hugepage backing, retry allowing remote\n\t\t\t * memory with both reclaim and compact as well.\n\t\t\t */\n\t\t\tif (!page && (gfp & __GFP_DIRECT_RECLAIM))\n\t\t\t\tpage = __alloc_pages_node(hpage_node,\n\t\t\t\t\t\t\t\tgfp, order);\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnmask = policy_nodemask(gfp, pol);\n\tpreferred_nid = policy_node(gfp, pol, node);\n\tpage = __alloc_pages_nodemask(gfp, order, preferred_nid, nmask);\n\tmpol_cond_put(pol);\nout:\n\treturn page;\n}\nEXPORT_SYMBOL(alloc_pages_vma);\n\n/**\n * \talloc_pages_current - Allocate pages.\n *\n *\t@gfp:\n *\t\t%GFP_USER   user allocation,\n *      \t%GFP_KERNEL kernel allocation,\n *      \t%GFP_HIGHMEM highmem allocation,\n *      \t%GFP_FS     don't call back into a file system.\n *      \t%GFP_ATOMIC don't sleep.\n *\t@order: Power of two of allocation size in pages. 0 is a single page.\n *\n *\tAllocate a page from the kernel page pool.  When not in\n *\tinterrupt context and apply the current process NUMA policy.\n *\tReturns NULL when no page can be allocated.\n */\nstruct page *alloc_pages_current(gfp_t gfp, unsigned order)\n{\n\tstruct mempolicy *pol = &default_policy;\n\tstruct page *page;\n\n\tif (!in_interrupt() && !(gfp & __GFP_THISNODE))\n\t\tpol = get_task_policy(current);\n\n\t/*\n\t * No reference counting needed for current->mempolicy\n\t * nor system default_policy\n\t */\n\tif (pol->mode == MPOL_INTERLEAVE)\n\t\tpage = alloc_page_interleave(gfp, order, interleave_nodes(pol));\n\telse\n\t\tpage = __alloc_pages_nodemask(gfp, order,\n\t\t\t\tpolicy_node(gfp, pol, numa_node_id()),\n\t\t\t\tpolicy_nodemask(gfp, pol));\n\n\treturn page;\n}\nEXPORT_SYMBOL(alloc_pages_current);\n\nint vma_dup_policy(struct vm_area_struct *src, struct vm_area_struct *dst)\n{\n\tstruct mempolicy *pol = mpol_dup(vma_policy(src));\n\n\tif (IS_ERR(pol))\n\t\treturn PTR_ERR(pol);\n\tdst->vm_policy = pol;\n\treturn 0;\n}\n\n/*\n * If mpol_dup() sees current->cpuset == cpuset_being_rebound, then it\n * rebinds the mempolicy its copying by calling mpol_rebind_policy()\n * with the mems_allowed returned by cpuset_mems_allowed().  This\n * keeps mempolicies cpuset relative after its cpuset moves.  See\n * further kernel/cpuset.c update_nodemask().\n *\n * current's mempolicy may be rebinded by the other task(the task that changes\n * cpuset's mems), so we needn't do rebind work for current task.\n */\n\n/* Slow path of a mempolicy duplicate */\nstruct mempolicy *__mpol_dup(struct mempolicy *old)\n{\n\tstruct mempolicy *new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\n\tif (!new)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* task's mempolicy is protected by alloc_lock */\n\tif (old == current->mempolicy) {\n\t\ttask_lock(current);\n\t\t*new = *old;\n\t\ttask_unlock(current);\n\t} else\n\t\t*new = *old;\n\n\tif (current_cpuset_is_being_rebound()) {\n\t\tnodemask_t mems = cpuset_mems_allowed(current);\n\t\tmpol_rebind_policy(new, &mems);\n\t}\n\tatomic_set(&new->refcnt, 1);\n\treturn new;\n}\n\n/* Slow path of a mempolicy comparison */\nbool __mpol_equal(struct mempolicy *a, struct mempolicy *b)\n{\n\tif (!a || !b)\n\t\treturn false;\n\tif (a->mode != b->mode)\n\t\treturn false;\n\tif (a->flags != b->flags)\n\t\treturn false;\n\tif (mpol_store_user_nodemask(a))\n\t\tif (!nodes_equal(a->w.user_nodemask, b->w.user_nodemask))\n\t\t\treturn false;\n\n\tswitch (a->mode) {\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\treturn !!nodes_equal(a->v.nodes, b->v.nodes);\n\tcase MPOL_PREFERRED:\n\t\t/* a's ->flags is the same as b's */\n\t\tif (a->flags & MPOL_F_LOCAL)\n\t\t\treturn true;\n\t\treturn a->v.preferred_node == b->v.preferred_node;\n\tdefault:\n\t\tBUG();\n\t\treturn false;\n\t}\n}\n\n/*\n * Shared memory backing store policy support.\n *\n * Remember policies even when nobody has shared memory mapped.\n * The policies are kept in Red-Black tree linked from the inode.\n * They are protected by the sp->lock rwlock, which should be held\n * for any accesses to the tree.\n */\n\n/*\n * lookup first element intersecting start-end.  Caller holds sp->lock for\n * reading or for writing\n */\nstatic struct sp_node *\nsp_lookup(struct shared_policy *sp, unsigned long start, unsigned long end)\n{\n\tstruct rb_node *n = sp->root.rb_node;\n\n\twhile (n) {\n\t\tstruct sp_node *p = rb_entry(n, struct sp_node, nd);\n\n\t\tif (start >= p->end)\n\t\t\tn = n->rb_right;\n\t\telse if (end <= p->start)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!n)\n\t\treturn NULL;\n\tfor (;;) {\n\t\tstruct sp_node *w = NULL;\n\t\tstruct rb_node *prev = rb_prev(n);\n\t\tif (!prev)\n\t\t\tbreak;\n\t\tw = rb_entry(prev, struct sp_node, nd);\n\t\tif (w->end <= start)\n\t\t\tbreak;\n\t\tn = prev;\n\t}\n\treturn rb_entry(n, struct sp_node, nd);\n}\n\n/*\n * Insert a new shared policy into the list.  Caller holds sp->lock for\n * writing.\n */\nstatic void sp_insert(struct shared_policy *sp, struct sp_node *new)\n{\n\tstruct rb_node **p = &sp->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct sp_node *nd;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tnd = rb_entry(parent, struct sp_node, nd);\n\t\tif (new->start < nd->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->end > nd->end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\trb_link_node(&new->nd, parent, p);\n\trb_insert_color(&new->nd, &sp->root);\n\tpr_debug(\"inserting %lx-%lx: %d\\n\", new->start, new->end,\n\t\t new->policy ? new->policy->mode : 0);\n}\n\n/* Find shared policy intersecting idx */\nstruct mempolicy *\nmpol_shared_policy_lookup(struct shared_policy *sp, unsigned long idx)\n{\n\tstruct mempolicy *pol = NULL;\n\tstruct sp_node *sn;\n\n\tif (!sp->root.rb_node)\n\t\treturn NULL;\n\tread_lock(&sp->lock);\n\tsn = sp_lookup(sp, idx, idx+1);\n\tif (sn) {\n\t\tmpol_get(sn->policy);\n\t\tpol = sn->policy;\n\t}\n\tread_unlock(&sp->lock);\n\treturn pol;\n}\n\nstatic void sp_free(struct sp_node *n)\n{\n\tmpol_put(n->policy);\n\tkmem_cache_free(sn_cache, n);\n}\n\n/**\n * mpol_misplaced - check whether current page node is valid in policy\n *\n * @page: page to be checked\n * @vma: vm area where page mapped\n * @addr: virtual address where page mapped\n *\n * Lookup current policy node id for vma,addr and \"compare to\" page's\n * node id.\n *\n * Returns:\n *\t-1\t- not misplaced, page is in the right node\n *\tnode\t- node id where the page should be\n *\n * Policy determination \"mimics\" alloc_page_vma().\n * Called from fault path where we know the vma and faulting address.\n */\nint mpol_misplaced(struct page *page, struct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct mempolicy *pol;\n\tstruct zoneref *z;\n\tint curnid = page_to_nid(page);\n\tunsigned long pgoff;\n\tint thiscpu = raw_smp_processor_id();\n\tint thisnid = cpu_to_node(thiscpu);\n\tint polnid = NUMA_NO_NODE;\n\tint ret = -1;\n\n\tpol = get_vma_policy(vma, addr);\n\tif (!(pol->flags & MPOL_F_MOF))\n\t\tgoto out;\n\n\tswitch (pol->mode) {\n\tcase MPOL_INTERLEAVE:\n\t\tpgoff = vma->vm_pgoff;\n\t\tpgoff += (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\tpolnid = offset_il_node(pol, pgoff);\n\t\tbreak;\n\n\tcase MPOL_PREFERRED:\n\t\tif (pol->flags & MPOL_F_LOCAL)\n\t\t\tpolnid = numa_node_id();\n\t\telse\n\t\t\tpolnid = pol->v.preferred_node;\n\t\tbreak;\n\n\tcase MPOL_BIND:\n\n\t\t/*\n\t\t * allows binding to multiple nodes.\n\t\t * use current page if in policy nodemask,\n\t\t * else select nearest allowed node, if any.\n\t\t * If no allowed nodes, use current [!misplaced].\n\t\t */\n\t\tif (node_isset(curnid, pol->v.nodes))\n\t\t\tgoto out;\n\t\tz = first_zones_zonelist(\n\t\t\t\tnode_zonelist(numa_node_id(), GFP_HIGHUSER),\n\t\t\t\tgfp_zone(GFP_HIGHUSER),\n\t\t\t\t&pol->v.nodes);\n\t\tpolnid = zone_to_nid(z->zone);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Migrate the page towards the node whose CPU is referencing it */\n\tif (pol->flags & MPOL_F_MORON) {\n\t\tpolnid = thisnid;\n\n\t\tif (!should_numa_migrate_memory(current, page, curnid, thiscpu))\n\t\t\tgoto out;\n\t}\n\n\tif (curnid != polnid)\n\t\tret = polnid;\nout:\n\tmpol_cond_put(pol);\n\n\treturn ret;\n}\n\n/*\n * Drop the (possibly final) reference to task->mempolicy.  It needs to be\n * dropped after task->mempolicy is set to NULL so that any allocation done as\n * part of its kmem_cache_free(), such as by KASAN, doesn't reference a freed\n * policy.\n */\nvoid mpol_put_task_policy(struct task_struct *task)\n{\n\tstruct mempolicy *pol;\n\n\ttask_lock(task);\n\tpol = task->mempolicy;\n\ttask->mempolicy = NULL;\n\ttask_unlock(task);\n\tmpol_put(pol);\n}\n\nstatic void sp_delete(struct shared_policy *sp, struct sp_node *n)\n{\n\tpr_debug(\"deleting %lx-l%lx\\n\", n->start, n->end);\n\trb_erase(&n->nd, &sp->root);\n\tsp_free(n);\n}\n\nstatic void sp_node_init(struct sp_node *node, unsigned long start,\n\t\t\tunsigned long end, struct mempolicy *pol)\n{\n\tnode->start = start;\n\tnode->end = end;\n\tnode->policy = pol;\n}\n\nstatic struct sp_node *sp_alloc(unsigned long start, unsigned long end,\n\t\t\t\tstruct mempolicy *pol)\n{\n\tstruct sp_node *n;\n\tstruct mempolicy *newpol;\n\n\tn = kmem_cache_alloc(sn_cache, GFP_KERNEL);\n\tif (!n)\n\t\treturn NULL;\n\n\tnewpol = mpol_dup(pol);\n\tif (IS_ERR(newpol)) {\n\t\tkmem_cache_free(sn_cache, n);\n\t\treturn NULL;\n\t}\n\tnewpol->flags |= MPOL_F_SHARED;\n\tsp_node_init(n, start, end, newpol);\n\n\treturn n;\n}\n\n/* Replace a policy range. */\nstatic int shared_policy_replace(struct shared_policy *sp, unsigned long start,\n\t\t\t\t unsigned long end, struct sp_node *new)\n{\n\tstruct sp_node *n;\n\tstruct sp_node *n_new = NULL;\n\tstruct mempolicy *mpol_new = NULL;\n\tint ret = 0;\n\nrestart:\n\twrite_lock(&sp->lock);\n\tn = sp_lookup(sp, start, end);\n\t/* Take care of old policies in the same range. */\n\twhile (n && n->start < end) {\n\t\tstruct rb_node *next = rb_next(&n->nd);\n\t\tif (n->start >= start) {\n\t\t\tif (n->end <= end)\n\t\t\t\tsp_delete(sp, n);\n\t\t\telse\n\t\t\t\tn->start = end;\n\t\t} else {\n\t\t\t/* Old policy spanning whole new range. */\n\t\t\tif (n->end > end) {\n\t\t\t\tif (!n_new)\n\t\t\t\t\tgoto alloc_new;\n\n\t\t\t\t*mpol_new = *n->policy;\n\t\t\t\tatomic_set(&mpol_new->refcnt, 1);\n\t\t\t\tsp_node_init(n_new, end, n->end, mpol_new);\n\t\t\t\tn->end = start;\n\t\t\t\tsp_insert(sp, n_new);\n\t\t\t\tn_new = NULL;\n\t\t\t\tmpol_new = NULL;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tn->end = start;\n\t\t}\n\t\tif (!next)\n\t\t\tbreak;\n\t\tn = rb_entry(next, struct sp_node, nd);\n\t}\n\tif (new)\n\t\tsp_insert(sp, new);\n\twrite_unlock(&sp->lock);\n\tret = 0;\n\nerr_out:\n\tif (mpol_new)\n\t\tmpol_put(mpol_new);\n\tif (n_new)\n\t\tkmem_cache_free(sn_cache, n_new);\n\n\treturn ret;\n\nalloc_new:\n\twrite_unlock(&sp->lock);\n\tret = -ENOMEM;\n\tn_new = kmem_cache_alloc(sn_cache, GFP_KERNEL);\n\tif (!n_new)\n\t\tgoto err_out;\n\tmpol_new = kmem_cache_alloc(policy_cache, GFP_KERNEL);\n\tif (!mpol_new)\n\t\tgoto err_out;\n\tgoto restart;\n}\n\n/**\n * mpol_shared_policy_init - initialize shared policy for inode\n * @sp: pointer to inode shared policy\n * @mpol:  struct mempolicy to install\n *\n * Install non-NULL @mpol in inode's shared policy rb-tree.\n * On entry, the current task has a reference on a non-NULL @mpol.\n * This must be released on exit.\n * This is called at get_inode() calls and we can use GFP_KERNEL.\n */\nvoid mpol_shared_policy_init(struct shared_policy *sp, struct mempolicy *mpol)\n{\n\tint ret;\n\n\tsp->root = RB_ROOT;\t\t/* empty tree == default mempolicy */\n\trwlock_init(&sp->lock);\n\n\tif (mpol) {\n\t\tstruct vm_area_struct pvma;\n\t\tstruct mempolicy *new;\n\t\tNODEMASK_SCRATCH(scratch);\n\n\t\tif (!scratch)\n\t\t\tgoto put_mpol;\n\t\t/* contextualize the tmpfs mount point mempolicy */\n\t\tnew = mpol_new(mpol->mode, mpol->flags, &mpol->w.user_nodemask);\n\t\tif (IS_ERR(new))\n\t\t\tgoto free_scratch; /* no valid nodemask intersection */\n\n\t\ttask_lock(current);\n\t\tret = mpol_set_nodemask(new, &mpol->w.user_nodemask, scratch);\n\t\ttask_unlock(current);\n\t\tif (ret)\n\t\t\tgoto put_new;\n\n\t\t/* Create pseudo-vma that contains just the policy */\n\t\tvma_init(&pvma, NULL);\n\t\tpvma.vm_end = TASK_SIZE;\t/* policy covers entire file */\n\t\tmpol_set_shared_policy(sp, &pvma, new); /* adds ref */\n\nput_new:\n\t\tmpol_put(new);\t\t\t/* drop initial ref */\nfree_scratch:\n\t\tNODEMASK_SCRATCH_FREE(scratch);\nput_mpol:\n\t\tmpol_put(mpol);\t/* drop our incoming ref on sb mpol */\n\t}\n}\n\nint mpol_set_shared_policy(struct shared_policy *info,\n\t\t\tstruct vm_area_struct *vma, struct mempolicy *npol)\n{\n\tint err;\n\tstruct sp_node *new = NULL;\n\tunsigned long sz = vma_pages(vma);\n\n\tpr_debug(\"set_shared_policy %lx sz %lu %d %d %lx\\n\",\n\t\t vma->vm_pgoff,\n\t\t sz, npol ? npol->mode : -1,\n\t\t npol ? npol->flags : -1,\n\t\t npol ? nodes_addr(npol->v.nodes)[0] : NUMA_NO_NODE);\n\n\tif (npol) {\n\t\tnew = sp_alloc(vma->vm_pgoff, vma->vm_pgoff + sz, npol);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t}\n\terr = shared_policy_replace(info, vma->vm_pgoff, vma->vm_pgoff+sz, new);\n\tif (err && new)\n\t\tsp_free(new);\n\treturn err;\n}\n\n/* Free a backing policy store on inode delete. */\nvoid mpol_free_shared_policy(struct shared_policy *p)\n{\n\tstruct sp_node *n;\n\tstruct rb_node *next;\n\n\tif (!p->root.rb_node)\n\t\treturn;\n\twrite_lock(&p->lock);\n\tnext = rb_first(&p->root);\n\twhile (next) {\n\t\tn = rb_entry(next, struct sp_node, nd);\n\t\tnext = rb_next(&n->nd);\n\t\tsp_delete(p, n);\n\t}\n\twrite_unlock(&p->lock);\n}\n\n#ifdef CONFIG_NUMA_BALANCING\nstatic int __initdata numabalancing_override;\n\nstatic void __init check_numabalancing_enable(void)\n{\n\tbool numabalancing_default = false;\n\n\tif (IS_ENABLED(CONFIG_NUMA_BALANCING_DEFAULT_ENABLED))\n\t\tnumabalancing_default = true;\n\n\t/* Parsed by setup_numabalancing. override == 1 enables, -1 disables */\n\tif (numabalancing_override)\n\t\tset_numabalancing_state(numabalancing_override == 1);\n\n\tif (num_online_nodes() > 1 && !numabalancing_override) {\n\t\tpr_info(\"%s automatic NUMA balancing. Configure with numa_balancing= or the kernel.numa_balancing sysctl\\n\",\n\t\t\tnumabalancing_default ? \"Enabling\" : \"Disabling\");\n\t\tset_numabalancing_state(numabalancing_default);\n\t}\n}\n\nstatic int __init setup_numabalancing(char *str)\n{\n\tint ret = 0;\n\tif (!str)\n\t\tgoto out;\n\n\tif (!strcmp(str, \"enable\")) {\n\t\tnumabalancing_override = 1;\n\t\tret = 1;\n\t} else if (!strcmp(str, \"disable\")) {\n\t\tnumabalancing_override = -1;\n\t\tret = 1;\n\t}\nout:\n\tif (!ret)\n\t\tpr_warn(\"Unable to parse numa_balancing=\\n\");\n\n\treturn ret;\n}\n__setup(\"numa_balancing=\", setup_numabalancing);\n#else\nstatic inline void __init check_numabalancing_enable(void)\n{\n}\n#endif /* CONFIG_NUMA_BALANCING */\n\n/* assumes fs == KERNEL_DS */\nvoid __init numa_policy_init(void)\n{\n\tnodemask_t interleave_nodes;\n\tunsigned long largest = 0;\n\tint nid, prefer = 0;\n\n\tpolicy_cache = kmem_cache_create(\"numa_policy\",\n\t\t\t\t\t sizeof(struct mempolicy),\n\t\t\t\t\t 0, SLAB_PANIC, NULL);\n\n\tsn_cache = kmem_cache_create(\"shared_policy_node\",\n\t\t\t\t     sizeof(struct sp_node),\n\t\t\t\t     0, SLAB_PANIC, NULL);\n\n\tfor_each_node(nid) {\n\t\tpreferred_node_policy[nid] = (struct mempolicy) {\n\t\t\t.refcnt = ATOMIC_INIT(1),\n\t\t\t.mode = MPOL_PREFERRED,\n\t\t\t.flags = MPOL_F_MOF | MPOL_F_MORON,\n\t\t\t.v = { .preferred_node = nid, },\n\t\t};\n\t}\n\n\t/*\n\t * Set interleaving policy for system init. Interleaving is only\n\t * enabled across suitably sized nodes (default is >= 16MB), or\n\t * fall back to the largest node if they're all smaller.\n\t */\n\tnodes_clear(interleave_nodes);\n\tfor_each_node_state(nid, N_MEMORY) {\n\t\tunsigned long total_pages = node_present_pages(nid);\n\n\t\t/* Preserve the largest node */\n\t\tif (largest < total_pages) {\n\t\t\tlargest = total_pages;\n\t\t\tprefer = nid;\n\t\t}\n\n\t\t/* Interleave this node? */\n\t\tif ((total_pages << PAGE_SHIFT) >= (16 << 20))\n\t\t\tnode_set(nid, interleave_nodes);\n\t}\n\n\t/* All too small, use the largest */\n\tif (unlikely(nodes_empty(interleave_nodes)))\n\t\tnode_set(prefer, interleave_nodes);\n\n\tif (do_set_mempolicy(MPOL_INTERLEAVE, 0, &interleave_nodes))\n\t\tpr_err(\"%s: interleaving failed\\n\", __func__);\n\n\tcheck_numabalancing_enable();\n}\n\n/* Reset policy of current process to default */\nvoid numa_default_policy(void)\n{\n\tdo_set_mempolicy(MPOL_DEFAULT, 0, NULL);\n}\n\n/*\n * Parse and format mempolicy from/to strings\n */\n\n/*\n * \"local\" is implemented internally by MPOL_PREFERRED with MPOL_F_LOCAL flag.\n */\nstatic const char * const policy_modes[] =\n{\n\t[MPOL_DEFAULT]    = \"default\",\n\t[MPOL_PREFERRED]  = \"prefer\",\n\t[MPOL_BIND]       = \"bind\",\n\t[MPOL_INTERLEAVE] = \"interleave\",\n\t[MPOL_LOCAL]      = \"local\",\n};\n\n\n#ifdef CONFIG_TMPFS\n/**\n * mpol_parse_str - parse string to mempolicy, for tmpfs mpol mount option.\n * @str:  string containing mempolicy to parse\n * @mpol:  pointer to struct mempolicy pointer, returned on success.\n *\n * Format of input:\n *\t<mode>[=<flags>][:<nodelist>]\n *\n * On success, returns 0, else 1\n */\nint mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1, mode;\n\n\tif (flags)\n\t\t*flags++ = '\\0';\t/* terminate mode string */\n\n\tif (nodelist) {\n\t\t/* NUL-terminate mode or flags string */\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\n\tmode = match_string(policy_modes, MPOL_MAX, str);\n\tif (mode < 0)\n\t\tgoto out;\n\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\t/*\n\t\t * Insist on a nodelist of one node only, although later\n\t\t * we use first_node(nodes) to grab a single node, so here\n\t\t * nodelist (or nodes) cannot be empty.\n\t\t */\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t\tif (nodes_empty(nodes))\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\t/*\n\t\t * Default to online nodes with memory if no nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\t/*\n\t\t * Don't allow a nodelist;  mpol_new() checks flags\n\t\t */\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\t/*\n\t\t * Insist on a empty nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\t/*\n\t\t * Insist on a nodelist\n\t\t */\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\n\tmode_flags = 0;\n\tif (flags) {\n\t\t/*\n\t\t * Currently, we only support two mutually exclusive\n\t\t * mode flags.\n\t\t */\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\n\t/*\n\t * Save nodes for mpol_to_str() to show the tmpfs mount options\n\t * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo.\n\t */\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\n\t/*\n\t * Save nodes for contextualization: this will be used to \"clone\"\n\t * the mempolicy in a specific context [cpuset] at a later time.\n\t */\n\tnew->w.user_nodemask = nodes;\n\n\terr = 0;\n\nout:\n\t/* Restore string for error message */\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}\n#endif /* CONFIG_TMPFS */\n\n/**\n * mpol_to_str - format a mempolicy structure for printing\n * @buffer:  to contain formatted mempolicy string\n * @maxlen:  length of @buffer\n * @pol:  pointer to mempolicy to be formatted\n *\n * Convert @pol into a string.  If @buffer is too short, truncate the string.\n * Recommend a @maxlen of at least 32 for the longest mode, \"interleave\", the\n * longest flag, \"relative\", and to display at least a few node ids.\n */\nvoid mpol_to_str(char *buffer, int maxlen, struct mempolicy *pol)\n{\n\tchar *p = buffer;\n\tnodemask_t nodes = NODE_MASK_NONE;\n\tunsigned short mode = MPOL_DEFAULT;\n\tunsigned short flags = 0;\n\n\tif (pol && pol != &default_policy && !(pol->flags & MPOL_F_MORON)) {\n\t\tmode = pol->mode;\n\t\tflags = pol->flags;\n\t}\n\n\tswitch (mode) {\n\tcase MPOL_DEFAULT:\n\t\tbreak;\n\tcase MPOL_PREFERRED:\n\t\tif (flags & MPOL_F_LOCAL)\n\t\t\tmode = MPOL_LOCAL;\n\t\telse\n\t\t\tnode_set(pol->v.preferred_node, nodes);\n\t\tbreak;\n\tcase MPOL_BIND:\n\tcase MPOL_INTERLEAVE:\n\t\tnodes = pol->v.nodes;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tsnprintf(p, maxlen, \"unknown\");\n\t\treturn;\n\t}\n\n\tp += snprintf(p, maxlen, \"%s\", policy_modes[mode]);\n\n\tif (flags & MPOL_MODE_FLAGS) {\n\t\tp += snprintf(p, buffer + maxlen - p, \"=\");\n\n\t\t/*\n\t\t * Currently, the only defined flags are mutually exclusive\n\t\t */\n\t\tif (flags & MPOL_F_STATIC_NODES)\n\t\t\tp += snprintf(p, buffer + maxlen - p, \"static\");\n\t\telse if (flags & MPOL_F_RELATIVE_NODES)\n\t\t\tp += snprintf(p, buffer + maxlen - p, \"relative\");\n\t}\n\n\tif (!nodes_empty(nodes))\n\t\tp += scnprintf(p, buffer + maxlen - p, \":%*pbl\",\n\t\t\t       nodemask_pr_args(&nodes));\n}\n"}, "1": {"id": 1, "path": "/src/include/linux/stddef.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_STDDEF_H\n#define _LINUX_STDDEF_H\n\n#include <uapi/linux/stddef.h>\n\n#undef NULL\n#define NULL ((void *)0)\n\nenum {\n\tfalse\t= 0,\n\ttrue\t= 1\n};\n\n#undef offsetof\n#ifdef __compiler_offsetof\n#define offsetof(TYPE, MEMBER)\t__compiler_offsetof(TYPE, MEMBER)\n#else\n#define offsetof(TYPE, MEMBER)\t((size_t)&((TYPE *)0)->MEMBER)\n#endif\n\n/**\n * sizeof_field(TYPE, MEMBER)\n *\n * @TYPE: The structure containing the field of interest\n * @MEMBER: The field to return the size of\n */\n#define sizeof_field(TYPE, MEMBER) sizeof((((TYPE *)0)->MEMBER))\n\n/**\n * offsetofend(TYPE, MEMBER)\n *\n * @TYPE: The type of the structure\n * @MEMBER: The member within the structure to get the end offset of\n */\n#define offsetofend(TYPE, MEMBER) \\\n\t(offsetof(TYPE, MEMBER)\t+ sizeof_field(TYPE, MEMBER))\n\n#endif\n"}, "2": {"id": 2, "path": "/src/include/linux/err.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_ERR_H\n#define _LINUX_ERR_H\n\n#include <linux/compiler.h>\n#include <linux/types.h>\n\n#include <asm/errno.h>\n\n/*\n * Kernel pointers have redundant information, so we can use a\n * scheme where we can return either an error code or a normal\n * pointer with the same return value.\n *\n * This should be a per-architecture thing, to allow different\n * error and pointer decisions.\n */\n#define MAX_ERRNO\t4095\n\n#ifndef __ASSEMBLY__\n\n#define IS_ERR_VALUE(x) unlikely((unsigned long)(void *)(x) >= (unsigned long)-MAX_ERRNO)\n\nstatic inline void * __must_check ERR_PTR(long error)\n{\n\treturn (void *) error;\n}\n\nstatic inline long __must_check PTR_ERR(__force const void *ptr)\n{\n\treturn (long) ptr;\n}\n\nstatic inline bool __must_check IS_ERR(__force const void *ptr)\n{\n\treturn IS_ERR_VALUE((unsigned long)ptr);\n}\n\nstatic inline bool __must_check IS_ERR_OR_NULL(__force const void *ptr)\n{\n\treturn unlikely(!ptr) || IS_ERR_VALUE((unsigned long)ptr);\n}\n\n/**\n * ERR_CAST - Explicitly cast an error-valued pointer to another pointer type\n * @ptr: The pointer to cast.\n *\n * Explicitly cast an error-valued pointer to another pointer type in such a\n * way as to make it clear that's what's going on.\n */\nstatic inline void * __must_check ERR_CAST(__force const void *ptr)\n{\n\t/* cast away the const */\n\treturn (void *) ptr;\n}\n\nstatic inline int __must_check PTR_ERR_OR_ZERO(__force const void *ptr)\n{\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\telse\n\t\treturn 0;\n}\n\n#endif\n\n#endif /* _LINUX_ERR_H */\n"}, "3": {"id": 3, "path": "/src/include/linux/compiler.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_H\n#define __LINUX_COMPILER_H\n\n#include <linux/compiler_types.h>\n\n#ifndef __ASSEMBLY__\n\n#ifdef __KERNEL__\n\n/*\n * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code\n * to disable branch tracing on a per file basis.\n */\n#if defined(CONFIG_TRACE_BRANCH_PROFILING) \\\n    && !defined(DISABLE_BRANCH_PROFILING) && !defined(__CHECKER__)\nvoid ftrace_likely_update(struct ftrace_likely_data *f, int val,\n\t\t\t  int expect, int is_constant);\n\n#define likely_notrace(x)\t__builtin_expect(!!(x), 1)\n#define unlikely_notrace(x)\t__builtin_expect(!!(x), 0)\n\n#define __branch_check__(x, expect, is_constant) ({\t\t\t\\\n\t\t\tlong ______r;\t\t\t\t\t\\\n\t\t\tstatic struct ftrace_likely_data\t\t\\\n\t\t\t\t__aligned(4)\t\t\t\t\\\n\t\t\t\t__section(\"_ftrace_annotated_branch\")\t\\\n\t\t\t\t______f = {\t\t\t\t\\\n\t\t\t\t.data.func = __func__,\t\t\t\\\n\t\t\t\t.data.file = __FILE__,\t\t\t\\\n\t\t\t\t.data.line = __LINE__,\t\t\t\\\n\t\t\t};\t\t\t\t\t\t\\\n\t\t\t______r = __builtin_expect(!!(x), expect);\t\\\n\t\t\tftrace_likely_update(&______f, ______r,\t\t\\\n\t\t\t\t\t     expect, is_constant);\t\\\n\t\t\t______r;\t\t\t\t\t\\\n\t\t})\n\n/*\n * Using __builtin_constant_p(x) to ignore cases where the return\n * value is always the same.  This idea is taken from a similar patch\n * written by Daniel Walker.\n */\n# ifndef likely\n#  define likely(x)\t(__branch_check__(x, 1, __builtin_constant_p(x)))\n# endif\n# ifndef unlikely\n#  define unlikely(x)\t(__branch_check__(x, 0, __builtin_constant_p(x)))\n# endif\n\n#ifdef CONFIG_PROFILE_ALL_BRANCHES\n/*\n * \"Define 'is'\", Bill Clinton\n * \"Define 'if'\", Steven Rostedt\n */\n#define if(cond, ...) if ( __trace_if_var( !!(cond , ## __VA_ARGS__) ) )\n\n#define __trace_if_var(cond) (__builtin_constant_p(cond) ? (cond) : __trace_if_value(cond))\n\n#define __trace_if_value(cond) ({\t\t\t\\\n\tstatic struct ftrace_branch_data\t\t\\\n\t\t__aligned(4)\t\t\t\t\\\n\t\t__section(\"_ftrace_branch\")\t\t\\\n\t\t__if_trace = {\t\t\t\t\\\n\t\t\t.func = __func__,\t\t\\\n\t\t\t.file = __FILE__,\t\t\\\n\t\t\t.line = __LINE__,\t\t\\\n\t\t};\t\t\t\t\t\\\n\t(cond) ?\t\t\t\t\t\\\n\t\t(__if_trace.miss_hit[1]++,1) :\t\t\\\n\t\t(__if_trace.miss_hit[0]++,0);\t\t\\\n})\n\n#endif /* CONFIG_PROFILE_ALL_BRANCHES */\n\n#else\n# define likely(x)\t__builtin_expect(!!(x), 1)\n# define unlikely(x)\t__builtin_expect(!!(x), 0)\n#endif\n\n/* Optimization barrier */\n#ifndef barrier\n/* The \"volatile\" is due to gcc bugs */\n# define barrier() __asm__ __volatile__(\"\": : :\"memory\")\n#endif\n\n#ifndef barrier_data\n/*\n * This version is i.e. to prevent dead stores elimination on @ptr\n * where gcc and llvm may behave differently when otherwise using\n * normal barrier(): while gcc behavior gets along with a normal\n * barrier(), llvm needs an explicit input variable to be assumed\n * clobbered. The issue is as follows: while the inline asm might\n * access any memory it wants, the compiler could have fit all of\n * @ptr into memory registers instead, and since @ptr never escaped\n * from that, it proved that the inline asm wasn't touching any of\n * it. This version works well with both compilers, i.e. we're telling\n * the compiler that the inline asm absolutely may see the contents\n * of @ptr. See also: https://llvm.org/bugs/show_bug.cgi?id=15495\n */\n# define barrier_data(ptr) __asm__ __volatile__(\"\": :\"r\"(ptr) :\"memory\")\n#endif\n\n/* workaround for GCC PR82365 if needed */\n#ifndef barrier_before_unreachable\n# define barrier_before_unreachable() do { } while (0)\n#endif\n\n/* Unreachable code */\n#ifdef CONFIG_STACK_VALIDATION\n/*\n * These macros help objtool understand GCC code flow for unreachable code.\n * The __COUNTER__ based labels are a hack to make each instance of the macros\n * unique, to convince GCC not to merge duplicate inline asm statements.\n */\n#define annotate_reachable() ({\t\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.reachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define annotate_unreachable() ({\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.unreachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define ASM_UNREACHABLE\t\t\t\t\t\t\t\\\n\t\"999:\\n\\t\"\t\t\t\t\t\t\t\\\n\t\".pushsection .discard.unreachable\\n\\t\"\t\t\t\t\\\n\t\".long 999b - .\\n\\t\"\t\t\t\t\t\t\\\n\t\".popsection\\n\\t\"\n\n/* Annotate a C jump table to allow objtool to follow the code flow */\n#define __annotate_jump_table __section(\".rodata..c_jump_table\")\n\n#else\n#define annotate_reachable()\n#define annotate_unreachable()\n#define __annotate_jump_table\n#endif\n\n#ifndef ASM_UNREACHABLE\n# define ASM_UNREACHABLE\n#endif\n#ifndef unreachable\n# define unreachable() do {\t\t\\\n\tannotate_unreachable();\t\t\\\n\t__builtin_unreachable();\t\\\n} while (0)\n#endif\n\n/*\n * KENTRY - kernel entry point\n * This can be used to annotate symbols (functions or data) that are used\n * without their linker symbol being referenced explicitly. For example,\n * interrupt vector handlers, or functions in the kernel image that are found\n * programatically.\n *\n * Not required for symbols exported with EXPORT_SYMBOL, or initcalls. Those\n * are handled in their own way (with KEEP() in linker scripts).\n *\n * KENTRY can be avoided if the symbols in question are marked as KEEP() in the\n * linker script. For example an architecture could KEEP() its entire\n * boot/exception vector code rather than annotate each function and data.\n */\n#ifndef KENTRY\n# define KENTRY(sym)\t\t\t\t\t\t\\\n\textern typeof(sym) sym;\t\t\t\t\t\\\n\tstatic const unsigned long __kentry_##sym\t\t\\\n\t__used\t\t\t\t\t\t\t\\\n\t__attribute__((__section__(\"___kentry+\" #sym)))\t\t\\\n\t= (unsigned long)&sym;\n#endif\n\n#ifndef RELOC_HIDE\n# define RELOC_HIDE(ptr, off)\t\t\t\t\t\\\n  ({ unsigned long __ptr;\t\t\t\t\t\\\n     __ptr = (unsigned long) (ptr);\t\t\t\t\\\n    (typeof(ptr)) (__ptr + (off)); })\n#endif\n\n#ifndef OPTIMIZER_HIDE_VAR\n/* Make the optimizer believe the variable can be manipulated arbitrarily. */\n#define OPTIMIZER_HIDE_VAR(var)\t\t\t\t\t\t\\\n\t__asm__ (\"\" : \"=r\" (var) : \"0\" (var))\n#endif\n\n/* Not-quite-unique ID. */\n#ifndef __UNIQUE_ID\n# define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)\n#endif\n\n/**\n * data_race - mark an expression as containing intentional data races\n *\n * This data_race() macro is useful for situations in which data races\n * should be forgiven.  One example is diagnostic code that accesses\n * shared variables but is not a part of the core synchronization design.\n *\n * This macro *does not* affect normal code generation, but is a hint\n * to tooling that data races here are to be ignored.\n */\n#define data_race(expr)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__unqual_scalar_typeof(({ expr; })) __v = ({\t\t\t\\\n\t\t__kcsan_disable_current();\t\t\t\t\\\n\t\texpr;\t\t\t\t\t\t\t\\\n\t});\t\t\t\t\t\t\t\t\\\n\t__kcsan_enable_current();\t\t\t\t\t\\\n\t__v;\t\t\t\t\t\t\t\t\\\n})\n\n#endif /* __KERNEL__ */\n\n/*\n * Force the compiler to emit 'sym' as a symbol, so that we can reference\n * it from inline assembler. Necessary in case 'sym' could be inlined\n * otherwise, or eliminated entirely due to lack of references that are\n * visible to the compiler.\n */\n#define __ADDRESSABLE(sym) \\\n\tstatic void * __section(\".discard.addressable\") __used \\\n\t\t__UNIQUE_ID(__PASTE(__addressable_,sym)) = (void *)&sym;\n\n/**\n * offset_to_ptr - convert a relative memory offset to an absolute pointer\n * @off:\tthe address of the 32-bit offset value\n */\nstatic inline void *offset_to_ptr(const int *off)\n{\n\treturn (void *)((unsigned long)off + *off);\n}\n\n#endif /* __ASSEMBLY__ */\n\n/* &a[0] degrades to a pointer: a different type from an array */\n#define __must_be_array(a)\tBUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))\n\n/*\n * This is needed in functions which generate the stack canary, see\n * arch/x86/kernel/smpboot.c::start_secondary() for an example.\n */\n#define prevent_tail_call_optimization()\tmb()\n\n#include <asm/rwonce.h>\n\n#endif /* __LINUX_COMPILER_H */\n"}, "4": {"id": 4, "path": "/src/include/linux/gfp.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_GFP_H\n#define __LINUX_GFP_H\n\n#include <linux/mmdebug.h>\n#include <linux/mmzone.h>\n#include <linux/stddef.h>\n#include <linux/linkage.h>\n#include <linux/topology.h>\n\nstruct vm_area_struct;\n\n/*\n * In case of changes, please don't forget to update\n * include/trace/events/mmflags.h and tools/perf/builtin-kmem.c\n */\n\n/* Plain integer GFP bitmasks. Do not use this directly. */\n#define ___GFP_DMA\t\t0x01u\n#define ___GFP_HIGHMEM\t\t0x02u\n#define ___GFP_DMA32\t\t0x04u\n#define ___GFP_MOVABLE\t\t0x08u\n#define ___GFP_RECLAIMABLE\t0x10u\n#define ___GFP_HIGH\t\t0x20u\n#define ___GFP_IO\t\t0x40u\n#define ___GFP_FS\t\t0x80u\n#define ___GFP_ZERO\t\t0x100u\n#define ___GFP_ATOMIC\t\t0x200u\n#define ___GFP_DIRECT_RECLAIM\t0x400u\n#define ___GFP_KSWAPD_RECLAIM\t0x800u\n#define ___GFP_WRITE\t\t0x1000u\n#define ___GFP_NOWARN\t\t0x2000u\n#define ___GFP_RETRY_MAYFAIL\t0x4000u\n#define ___GFP_NOFAIL\t\t0x8000u\n#define ___GFP_NORETRY\t\t0x10000u\n#define ___GFP_MEMALLOC\t\t0x20000u\n#define ___GFP_COMP\t\t0x40000u\n#define ___GFP_NOMEMALLOC\t0x80000u\n#define ___GFP_HARDWALL\t\t0x100000u\n#define ___GFP_THISNODE\t\t0x200000u\n#define ___GFP_ACCOUNT\t\t0x400000u\n#ifdef CONFIG_LOCKDEP\n#define ___GFP_NOLOCKDEP\t0x800000u\n#else\n#define ___GFP_NOLOCKDEP\t0\n#endif\n/* If the above are modified, __GFP_BITS_SHIFT may need updating */\n\n/*\n * Physical address zone modifiers (see linux/mmzone.h - low four bits)\n *\n * Do not put any conditional on these. If necessary modify the definitions\n * without the underscores and use them consistently. The definitions here may\n * be used in bit comparisons.\n */\n#define __GFP_DMA\t((__force gfp_t)___GFP_DMA)\n#define __GFP_HIGHMEM\t((__force gfp_t)___GFP_HIGHMEM)\n#define __GFP_DMA32\t((__force gfp_t)___GFP_DMA32)\n#define __GFP_MOVABLE\t((__force gfp_t)___GFP_MOVABLE)  /* ZONE_MOVABLE allowed */\n#define GFP_ZONEMASK\t(__GFP_DMA|__GFP_HIGHMEM|__GFP_DMA32|__GFP_MOVABLE)\n\n/**\n * DOC: Page mobility and placement hints\n *\n * Page mobility and placement hints\n * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n *\n * These flags provide hints about how mobile the page is. Pages with similar\n * mobility are placed within the same pageblocks to minimise problems due\n * to external fragmentation.\n *\n * %__GFP_MOVABLE (also a zone modifier) indicates that the page can be\n * moved by page migration during memory compaction or can be reclaimed.\n *\n * %__GFP_RECLAIMABLE is used for slab allocations that specify\n * SLAB_RECLAIM_ACCOUNT and whose pages can be freed via shrinkers.\n *\n * %__GFP_WRITE indicates the caller intends to dirty the page. Where possible,\n * these pages will be spread between local zones to avoid all the dirty\n * pages being in one zone (fair zone allocation policy).\n *\n * %__GFP_HARDWALL enforces the cpuset memory allocation policy.\n *\n * %__GFP_THISNODE forces the allocation to be satisfied from the requested\n * node with no fallbacks or placement policy enforcements.\n *\n * %__GFP_ACCOUNT causes the allocation to be accounted to kmemcg.\n */\n#define __GFP_RECLAIMABLE ((__force gfp_t)___GFP_RECLAIMABLE)\n#define __GFP_WRITE\t((__force gfp_t)___GFP_WRITE)\n#define __GFP_HARDWALL   ((__force gfp_t)___GFP_HARDWALL)\n#define __GFP_THISNODE\t((__force gfp_t)___GFP_THISNODE)\n#define __GFP_ACCOUNT\t((__force gfp_t)___GFP_ACCOUNT)\n\n/**\n * DOC: Watermark modifiers\n *\n * Watermark modifiers -- controls access to emergency reserves\n * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n *\n * %__GFP_HIGH indicates that the caller is high-priority and that granting\n * the request is necessary before the system can make forward progress.\n * For example, creating an IO context to clean pages.\n *\n * %__GFP_ATOMIC indicates that the caller cannot reclaim or sleep and is\n * high priority. Users are typically interrupt handlers. This may be\n * used in conjunction with %__GFP_HIGH\n *\n * %__GFP_MEMALLOC allows access to all memory. This should only be used when\n * the caller guarantees the allocation will allow more memory to be freed\n * very shortly e.g. process exiting or swapping. Users either should\n * be the MM or co-ordinating closely with the VM (e.g. swap over NFS).\n * Users of this flag have to be extremely careful to not deplete the reserve\n * completely and implement a throttling mechanism which controls the\n * consumption of the reserve based on the amount of freed memory.\n * Usage of a pre-allocated pool (e.g. mempool) should be always considered\n * before using this flag.\n *\n * %__GFP_NOMEMALLOC is used to explicitly forbid access to emergency reserves.\n * This takes precedence over the %__GFP_MEMALLOC flag if both are set.\n */\n#define __GFP_ATOMIC\t((__force gfp_t)___GFP_ATOMIC)\n#define __GFP_HIGH\t((__force gfp_t)___GFP_HIGH)\n#define __GFP_MEMALLOC\t((__force gfp_t)___GFP_MEMALLOC)\n#define __GFP_NOMEMALLOC ((__force gfp_t)___GFP_NOMEMALLOC)\n\n/**\n * DOC: Reclaim modifiers\n *\n * Reclaim modifiers\n * ~~~~~~~~~~~~~~~~~\n * Please note that all the following flags are only applicable to sleepable\n * allocations (e.g. %GFP_NOWAIT and %GFP_ATOMIC will ignore them).\n *\n * %__GFP_IO can start physical IO.\n *\n * %__GFP_FS can call down to the low-level FS. Clearing the flag avoids the\n * allocator recursing into the filesystem which might already be holding\n * locks.\n *\n * %__GFP_DIRECT_RECLAIM indicates that the caller may enter direct reclaim.\n * This flag can be cleared to avoid unnecessary delays when a fallback\n * option is available.\n *\n * %__GFP_KSWAPD_RECLAIM indicates that the caller wants to wake kswapd when\n * the low watermark is reached and have it reclaim pages until the high\n * watermark is reached. A caller may wish to clear this flag when fallback\n * options are available and the reclaim is likely to disrupt the system. The\n * canonical example is THP allocation where a fallback is cheap but\n * reclaim/compaction may cause indirect stalls.\n *\n * %__GFP_RECLAIM is shorthand to allow/forbid both direct and kswapd reclaim.\n *\n * The default allocator behavior depends on the request size. We have a concept\n * of so called costly allocations (with order > %PAGE_ALLOC_COSTLY_ORDER).\n * !costly allocations are too essential to fail so they are implicitly\n * non-failing by default (with some exceptions like OOM victims might fail so\n * the caller still has to check for failures) while costly requests try to be\n * not disruptive and back off even without invoking the OOM killer.\n * The following three modifiers might be used to override some of these\n * implicit rules\n *\n * %__GFP_NORETRY: The VM implementation will try only very lightweight\n * memory direct reclaim to get some memory under memory pressure (thus\n * it can sleep). It will avoid disruptive actions like OOM killer. The\n * caller must handle the failure which is quite likely to happen under\n * heavy memory pressure. The flag is suitable when failure can easily be\n * handled at small cost, such as reduced throughput\n *\n * %__GFP_RETRY_MAYFAIL: The VM implementation will retry memory reclaim\n * procedures that have previously failed if there is some indication\n * that progress has been made else where.  It can wait for other\n * tasks to attempt high level approaches to freeing memory such as\n * compaction (which removes fragmentation) and page-out.\n * There is still a definite limit to the number of retries, but it is\n * a larger limit than with %__GFP_NORETRY.\n * Allocations with this flag may fail, but only when there is\n * genuinely little unused memory. While these allocations do not\n * directly trigger the OOM killer, their failure indicates that\n * the system is likely to need to use the OOM killer soon.  The\n * caller must handle failure, but can reasonably do so by failing\n * a higher-level request, or completing it only in a much less\n * efficient manner.\n * If the allocation does fail, and the caller is in a position to\n * free some non-essential memory, doing so could benefit the system\n * as a whole.\n *\n * %__GFP_NOFAIL: The VM implementation _must_ retry infinitely: the caller\n * cannot handle allocation failures. The allocation could block\n * indefinitely but will never return with failure. Testing for\n * failure is pointless.\n * New users should be evaluated carefully (and the flag should be\n * used only when there is no reasonable failure policy) but it is\n * definitely preferable to use the flag rather than opencode endless\n * loop around allocator.\n * Using this flag for costly allocations is _highly_ discouraged.\n */\n#define __GFP_IO\t((__force gfp_t)___GFP_IO)\n#define __GFP_FS\t((__force gfp_t)___GFP_FS)\n#define __GFP_DIRECT_RECLAIM\t((__force gfp_t)___GFP_DIRECT_RECLAIM) /* Caller can reclaim */\n#define __GFP_KSWAPD_RECLAIM\t((__force gfp_t)___GFP_KSWAPD_RECLAIM) /* kswapd can wake */\n#define __GFP_RECLAIM ((__force gfp_t)(___GFP_DIRECT_RECLAIM|___GFP_KSWAPD_RECLAIM))\n#define __GFP_RETRY_MAYFAIL\t((__force gfp_t)___GFP_RETRY_MAYFAIL)\n#define __GFP_NOFAIL\t((__force gfp_t)___GFP_NOFAIL)\n#define __GFP_NORETRY\t((__force gfp_t)___GFP_NORETRY)\n\n/**\n * DOC: Action modifiers\n *\n * Action modifiers\n * ~~~~~~~~~~~~~~~~\n *\n * %__GFP_NOWARN suppresses allocation failure reports.\n *\n * %__GFP_COMP address compound page metadata.\n *\n * %__GFP_ZERO returns a zeroed page on success.\n */\n#define __GFP_NOWARN\t((__force gfp_t)___GFP_NOWARN)\n#define __GFP_COMP\t((__force gfp_t)___GFP_COMP)\n#define __GFP_ZERO\t((__force gfp_t)___GFP_ZERO)\n\n/* Disable lockdep for GFP context tracking */\n#define __GFP_NOLOCKDEP ((__force gfp_t)___GFP_NOLOCKDEP)\n\n/* Room for N __GFP_FOO bits */\n#define __GFP_BITS_SHIFT (23 + IS_ENABLED(CONFIG_LOCKDEP))\n#define __GFP_BITS_MASK ((__force gfp_t)((1 << __GFP_BITS_SHIFT) - 1))\n\n/**\n * DOC: Useful GFP flag combinations\n *\n * Useful GFP flag combinations\n * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n *\n * Useful GFP flag combinations that are commonly used. It is recommended\n * that subsystems start with one of these combinations and then set/clear\n * %__GFP_FOO flags as necessary.\n *\n * %GFP_ATOMIC users can not sleep and need the allocation to succeed. A lower\n * watermark is applied to allow access to \"atomic reserves\".\n * The current implementation doesn't support NMI and few other strict\n * non-preemptive contexts (e.g. raw_spin_lock). The same applies to %GFP_NOWAIT.\n *\n * %GFP_KERNEL is typical for kernel-internal allocations. The caller requires\n * %ZONE_NORMAL or a lower zone for direct access but can direct reclaim.\n *\n * %GFP_KERNEL_ACCOUNT is the same as GFP_KERNEL, except the allocation is\n * accounted to kmemcg.\n *\n * %GFP_NOWAIT is for kernel allocations that should not stall for direct\n * reclaim, start physical IO or use any filesystem callback.\n *\n * %GFP_NOIO will use direct reclaim to discard clean pages or slab pages\n * that do not require the starting of any physical IO.\n * Please try to avoid using this flag directly and instead use\n * memalloc_noio_{save,restore} to mark the whole scope which cannot\n * perform any IO with a short explanation why. All allocation requests\n * will inherit GFP_NOIO implicitly.\n *\n * %GFP_NOFS will use direct reclaim but will not use any filesystem interfaces.\n * Please try to avoid using this flag directly and instead use\n * memalloc_nofs_{save,restore} to mark the whole scope which cannot/shouldn't\n * recurse into the FS layer with a short explanation why. All allocation\n * requests will inherit GFP_NOFS implicitly.\n *\n * %GFP_USER is for userspace allocations that also need to be directly\n * accessibly by the kernel or hardware. It is typically used by hardware\n * for buffers that are mapped to userspace (e.g. graphics) that hardware\n * still must DMA to. cpuset limits are enforced for these allocations.\n *\n * %GFP_DMA exists for historical reasons and should be avoided where possible.\n * The flags indicates that the caller requires that the lowest zone be\n * used (%ZONE_DMA or 16M on x86-64). Ideally, this would be removed but\n * it would require careful auditing as some users really require it and\n * others use the flag to avoid lowmem reserves in %ZONE_DMA and treat the\n * lowest zone as a type of emergency reserve.\n *\n * %GFP_DMA32 is similar to %GFP_DMA except that the caller requires a 32-bit\n * address.\n *\n * %GFP_HIGHUSER is for userspace allocations that may be mapped to userspace,\n * do not need to be directly accessible by the kernel but that cannot\n * move once in use. An example may be a hardware allocation that maps\n * data directly into userspace but has no addressing limitations.\n *\n * %GFP_HIGHUSER_MOVABLE is for userspace allocations that the kernel does not\n * need direct access to but can use kmap() when access is required. They\n * are expected to be movable via page reclaim or page migration. Typically,\n * pages on the LRU would also be allocated with %GFP_HIGHUSER_MOVABLE.\n *\n * %GFP_TRANSHUGE and %GFP_TRANSHUGE_LIGHT are used for THP allocations. They\n * are compound allocations that will generally fail quickly if memory is not\n * available and will not wake kswapd/kcompactd on failure. The _LIGHT\n * version does not attempt reclaim/compaction at all and is by default used\n * in page fault path, while the non-light is used by khugepaged.\n */\n#define GFP_ATOMIC\t(__GFP_HIGH|__GFP_ATOMIC|__GFP_KSWAPD_RECLAIM)\n#define GFP_KERNEL\t(__GFP_RECLAIM | __GFP_IO | __GFP_FS)\n#define GFP_KERNEL_ACCOUNT (GFP_KERNEL | __GFP_ACCOUNT)\n#define GFP_NOWAIT\t(__GFP_KSWAPD_RECLAIM)\n#define GFP_NOIO\t(__GFP_RECLAIM)\n#define GFP_NOFS\t(__GFP_RECLAIM | __GFP_IO)\n#define GFP_USER\t(__GFP_RECLAIM | __GFP_IO | __GFP_FS | __GFP_HARDWALL)\n#define GFP_DMA\t\t__GFP_DMA\n#define GFP_DMA32\t__GFP_DMA32\n#define GFP_HIGHUSER\t(GFP_USER | __GFP_HIGHMEM)\n#define GFP_HIGHUSER_MOVABLE\t(GFP_HIGHUSER | __GFP_MOVABLE)\n#define GFP_TRANSHUGE_LIGHT\t((GFP_HIGHUSER_MOVABLE | __GFP_COMP | \\\n\t\t\t __GFP_NOMEMALLOC | __GFP_NOWARN) & ~__GFP_RECLAIM)\n#define GFP_TRANSHUGE\t(GFP_TRANSHUGE_LIGHT | __GFP_DIRECT_RECLAIM)\n\n/* Convert GFP flags to their corresponding migrate type */\n#define GFP_MOVABLE_MASK (__GFP_RECLAIMABLE|__GFP_MOVABLE)\n#define GFP_MOVABLE_SHIFT 3\n\nstatic inline int gfp_migratetype(const gfp_t gfp_flags)\n{\n\tVM_WARN_ON((gfp_flags & GFP_MOVABLE_MASK) == GFP_MOVABLE_MASK);\n\tBUILD_BUG_ON((1UL << GFP_MOVABLE_SHIFT) != ___GFP_MOVABLE);\n\tBUILD_BUG_ON((___GFP_MOVABLE >> GFP_MOVABLE_SHIFT) != MIGRATE_MOVABLE);\n\n\tif (unlikely(page_group_by_mobility_disabled))\n\t\treturn MIGRATE_UNMOVABLE;\n\n\t/* Group based on mobility */\n\treturn (gfp_flags & GFP_MOVABLE_MASK) >> GFP_MOVABLE_SHIFT;\n}\n#undef GFP_MOVABLE_MASK\n#undef GFP_MOVABLE_SHIFT\n\nstatic inline bool gfpflags_allow_blocking(const gfp_t gfp_flags)\n{\n\treturn !!(gfp_flags & __GFP_DIRECT_RECLAIM);\n}\n\n/**\n * gfpflags_normal_context - is gfp_flags a normal sleepable context?\n * @gfp_flags: gfp_flags to test\n *\n * Test whether @gfp_flags indicates that the allocation is from the\n * %current context and allowed to sleep.\n *\n * An allocation being allowed to block doesn't mean it owns the %current\n * context.  When direct reclaim path tries to allocate memory, the\n * allocation context is nested inside whatever %current was doing at the\n * time of the original allocation.  The nested allocation may be allowed\n * to block but modifying anything %current owns can corrupt the outer\n * context's expectations.\n *\n * %true result from this function indicates that the allocation context\n * can sleep and use anything that's associated with %current.\n */\nstatic inline bool gfpflags_normal_context(const gfp_t gfp_flags)\n{\n\treturn (gfp_flags & (__GFP_DIRECT_RECLAIM | __GFP_MEMALLOC)) ==\n\t\t__GFP_DIRECT_RECLAIM;\n}\n\n#ifdef CONFIG_HIGHMEM\n#define OPT_ZONE_HIGHMEM ZONE_HIGHMEM\n#else\n#define OPT_ZONE_HIGHMEM ZONE_NORMAL\n#endif\n\n#ifdef CONFIG_ZONE_DMA\n#define OPT_ZONE_DMA ZONE_DMA\n#else\n#define OPT_ZONE_DMA ZONE_NORMAL\n#endif\n\n#ifdef CONFIG_ZONE_DMA32\n#define OPT_ZONE_DMA32 ZONE_DMA32\n#else\n#define OPT_ZONE_DMA32 ZONE_NORMAL\n#endif\n\n/*\n * GFP_ZONE_TABLE is a word size bitstring that is used for looking up the\n * zone to use given the lowest 4 bits of gfp_t. Entries are GFP_ZONES_SHIFT\n * bits long and there are 16 of them to cover all possible combinations of\n * __GFP_DMA, __GFP_DMA32, __GFP_MOVABLE and __GFP_HIGHMEM.\n *\n * The zone fallback order is MOVABLE=>HIGHMEM=>NORMAL=>DMA32=>DMA.\n * But GFP_MOVABLE is not only a zone specifier but also an allocation\n * policy. Therefore __GFP_MOVABLE plus another zone selector is valid.\n * Only 1 bit of the lowest 3 bits (DMA,DMA32,HIGHMEM) can be set to \"1\".\n *\n *       bit       result\n *       =================\n *       0x0    => NORMAL\n *       0x1    => DMA or NORMAL\n *       0x2    => HIGHMEM or NORMAL\n *       0x3    => BAD (DMA+HIGHMEM)\n *       0x4    => DMA32 or NORMAL\n *       0x5    => BAD (DMA+DMA32)\n *       0x6    => BAD (HIGHMEM+DMA32)\n *       0x7    => BAD (HIGHMEM+DMA32+DMA)\n *       0x8    => NORMAL (MOVABLE+0)\n *       0x9    => DMA or NORMAL (MOVABLE+DMA)\n *       0xa    => MOVABLE (Movable is valid only if HIGHMEM is set too)\n *       0xb    => BAD (MOVABLE+HIGHMEM+DMA)\n *       0xc    => DMA32 or NORMAL (MOVABLE+DMA32)\n *       0xd    => BAD (MOVABLE+DMA32+DMA)\n *       0xe    => BAD (MOVABLE+DMA32+HIGHMEM)\n *       0xf    => BAD (MOVABLE+DMA32+HIGHMEM+DMA)\n *\n * GFP_ZONES_SHIFT must be <= 2 on 32 bit platforms.\n */\n\n#if defined(CONFIG_ZONE_DEVICE) && (MAX_NR_ZONES-1) <= 4\n/* ZONE_DEVICE is not a valid GFP zone specifier */\n#define GFP_ZONES_SHIFT 2\n#else\n#define GFP_ZONES_SHIFT ZONES_SHIFT\n#endif\n\n#if 16 * GFP_ZONES_SHIFT > BITS_PER_LONG\n#error GFP_ZONES_SHIFT too large to create GFP_ZONE_TABLE integer\n#endif\n\n#define GFP_ZONE_TABLE ( \\\n\t(ZONE_NORMAL << 0 * GFP_ZONES_SHIFT)\t\t\t\t       \\\n\t| (OPT_ZONE_DMA << ___GFP_DMA * GFP_ZONES_SHIFT)\t\t       \\\n\t| (OPT_ZONE_HIGHMEM << ___GFP_HIGHMEM * GFP_ZONES_SHIFT)\t       \\\n\t| (OPT_ZONE_DMA32 << ___GFP_DMA32 * GFP_ZONES_SHIFT)\t\t       \\\n\t| (ZONE_NORMAL << ___GFP_MOVABLE * GFP_ZONES_SHIFT)\t\t       \\\n\t| (OPT_ZONE_DMA << (___GFP_MOVABLE | ___GFP_DMA) * GFP_ZONES_SHIFT)    \\\n\t| (ZONE_MOVABLE << (___GFP_MOVABLE | ___GFP_HIGHMEM) * GFP_ZONES_SHIFT)\\\n\t| (OPT_ZONE_DMA32 << (___GFP_MOVABLE | ___GFP_DMA32) * GFP_ZONES_SHIFT)\\\n)\n\n/*\n * GFP_ZONE_BAD is a bitmap for all combinations of __GFP_DMA, __GFP_DMA32\n * __GFP_HIGHMEM and __GFP_MOVABLE that are not permitted. One flag per\n * entry starting with bit 0. Bit is set if the combination is not\n * allowed.\n */\n#define GFP_ZONE_BAD ( \\\n\t1 << (___GFP_DMA | ___GFP_HIGHMEM)\t\t\t\t      \\\n\t| 1 << (___GFP_DMA | ___GFP_DMA32)\t\t\t\t      \\\n\t| 1 << (___GFP_DMA32 | ___GFP_HIGHMEM)\t\t\t\t      \\\n\t| 1 << (___GFP_DMA | ___GFP_DMA32 | ___GFP_HIGHMEM)\t\t      \\\n\t| 1 << (___GFP_MOVABLE | ___GFP_HIGHMEM | ___GFP_DMA)\t\t      \\\n\t| 1 << (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_DMA)\t\t      \\\n\t| 1 << (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_HIGHMEM)\t\t      \\\n\t| 1 << (___GFP_MOVABLE | ___GFP_DMA32 | ___GFP_DMA | ___GFP_HIGHMEM)  \\\n)\n\nstatic inline enum zone_type gfp_zone(gfp_t flags)\n{\n\tenum zone_type z;\n\tint bit = (__force int) (flags & GFP_ZONEMASK);\n\n\tz = (GFP_ZONE_TABLE >> (bit * GFP_ZONES_SHIFT)) &\n\t\t\t\t\t ((1 << GFP_ZONES_SHIFT) - 1);\n\tVM_BUG_ON((GFP_ZONE_BAD >> bit) & 1);\n\treturn z;\n}\n\n/*\n * There is only one page-allocator function, and two main namespaces to\n * it. The alloc_page*() variants return 'struct page *' and as such\n * can allocate highmem pages, the *get*page*() variants return\n * virtual kernel addresses to the allocated page(s).\n */\n\nstatic inline int gfp_zonelist(gfp_t flags)\n{\n#ifdef CONFIG_NUMA\n\tif (unlikely(flags & __GFP_THISNODE))\n\t\treturn ZONELIST_NOFALLBACK;\n#endif\n\treturn ZONELIST_FALLBACK;\n}\n\n/*\n * We get the zone list from the current node and the gfp_mask.\n * This zone list contains a maximum of MAXNODES*MAX_NR_ZONES zones.\n * There are two zonelists per node, one for all zones with memory and\n * one containing just zones from the node the zonelist belongs to.\n *\n * For the normal case of non-DISCONTIGMEM systems the NODE_DATA() gets\n * optimized to &contig_page_data at compile-time.\n */\nstatic inline struct zonelist *node_zonelist(int nid, gfp_t flags)\n{\n\treturn NODE_DATA(nid)->node_zonelists + gfp_zonelist(flags);\n}\n\n#ifndef HAVE_ARCH_FREE_PAGE\nstatic inline void arch_free_page(struct page *page, int order) { }\n#endif\n#ifndef HAVE_ARCH_ALLOC_PAGE\nstatic inline void arch_alloc_page(struct page *page, int order) { }\n#endif\n#ifndef HAVE_ARCH_MAKE_PAGE_ACCESSIBLE\nstatic inline int arch_make_page_accessible(struct page *page)\n{\n\treturn 0;\n}\n#endif\n\nstruct page *\n__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,\n\t\t\t\t\t\t\tnodemask_t *nodemask);\n\nstatic inline struct page *\n__alloc_pages(gfp_t gfp_mask, unsigned int order, int preferred_nid)\n{\n\treturn __alloc_pages_nodemask(gfp_mask, order, preferred_nid, NULL);\n}\n\n/*\n * Allocate pages, preferring the node given as nid. The node must be valid and\n * online. For more general interface, see alloc_pages_node().\n */\nstatic inline struct page *\n__alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order)\n{\n\tVM_BUG_ON(nid < 0 || nid >= MAX_NUMNODES);\n\tVM_WARN_ON((gfp_mask & __GFP_THISNODE) && !node_online(nid));\n\n\treturn __alloc_pages(gfp_mask, order, nid);\n}\n\n/*\n * Allocate pages, preferring the node given as nid. When nid == NUMA_NO_NODE,\n * prefer the current CPU's closest node. Otherwise node must be valid and\n * online.\n */\nstatic inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask,\n\t\t\t\t\t\tunsigned int order)\n{\n\tif (nid == NUMA_NO_NODE)\n\t\tnid = numa_mem_id();\n\n\treturn __alloc_pages_node(nid, gfp_mask, order);\n}\n\n#ifdef CONFIG_NUMA\nextern struct page *alloc_pages_current(gfp_t gfp_mask, unsigned order);\n\nstatic inline struct page *\nalloc_pages(gfp_t gfp_mask, unsigned int order)\n{\n\treturn alloc_pages_current(gfp_mask, order);\n}\nextern struct page *alloc_pages_vma(gfp_t gfp_mask, int order,\n\t\t\tstruct vm_area_struct *vma, unsigned long addr,\n\t\t\tint node, bool hugepage);\n#define alloc_hugepage_vma(gfp_mask, vma, addr, order) \\\n\talloc_pages_vma(gfp_mask, order, vma, addr, numa_node_id(), true)\n#else\nstatic inline struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)\n{\n\treturn alloc_pages_node(numa_node_id(), gfp_mask, order);\n}\n#define alloc_pages_vma(gfp_mask, order, vma, addr, node, false)\\\n\talloc_pages(gfp_mask, order)\n#define alloc_hugepage_vma(gfp_mask, vma, addr, order) \\\n\talloc_pages(gfp_mask, order)\n#endif\n#define alloc_page(gfp_mask) alloc_pages(gfp_mask, 0)\n#define alloc_page_vma(gfp_mask, vma, addr)\t\t\t\\\n\talloc_pages_vma(gfp_mask, 0, vma, addr, numa_node_id(), false)\n\nextern unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order);\nextern unsigned long get_zeroed_page(gfp_t gfp_mask);\n\nvoid *alloc_pages_exact(size_t size, gfp_t gfp_mask);\nvoid free_pages_exact(void *virt, size_t size);\nvoid * __meminit alloc_pages_exact_nid(int nid, size_t size, gfp_t gfp_mask);\n\n#define __get_free_page(gfp_mask) \\\n\t\t__get_free_pages((gfp_mask), 0)\n\n#define __get_dma_pages(gfp_mask, order) \\\n\t\t__get_free_pages((gfp_mask) | GFP_DMA, (order))\n\nextern void __free_pages(struct page *page, unsigned int order);\nextern void free_pages(unsigned long addr, unsigned int order);\n\nstruct page_frag_cache;\nextern void __page_frag_cache_drain(struct page *page, unsigned int count);\nextern void *page_frag_alloc(struct page_frag_cache *nc,\n\t\t\t     unsigned int fragsz, gfp_t gfp_mask);\nextern void page_frag_free(void *addr);\n\n#define __free_page(page) __free_pages((page), 0)\n#define free_page(addr) free_pages((addr), 0)\n\nvoid page_alloc_init(void);\nvoid drain_zone_pages(struct zone *zone, struct per_cpu_pages *pcp);\nvoid drain_all_pages(struct zone *zone);\nvoid drain_local_pages(struct zone *zone);\n\nvoid page_alloc_init_late(void);\n\n/*\n * gfp_allowed_mask is set to GFP_BOOT_MASK during early boot to restrict what\n * GFP flags are used before interrupts are enabled. Once interrupts are\n * enabled, it is set to __GFP_BITS_MASK while the system is running. During\n * hibernation, it is used by PM to avoid I/O during memory allocation while\n * devices are suspended.\n */\nextern gfp_t gfp_allowed_mask;\n\n/* Returns true if the gfp_mask allows use of ALLOC_NO_WATERMARK */\nbool gfp_pfmemalloc_allowed(gfp_t gfp_mask);\n\nextern void pm_restrict_gfp_mask(void);\nextern void pm_restore_gfp_mask(void);\n\nextern gfp_t vma_thp_gfp_mask(struct vm_area_struct *vma);\n\n#ifdef CONFIG_PM_SLEEP\nextern bool pm_suspended_storage(void);\n#else\nstatic inline bool pm_suspended_storage(void)\n{\n\treturn false;\n}\n#endif /* CONFIG_PM_SLEEP */\n\n#ifdef CONFIG_CONTIG_ALLOC\n/* The below functions must be run on a range from a single zone. */\nextern int alloc_contig_range(unsigned long start, unsigned long end,\n\t\t\t      unsigned migratetype, gfp_t gfp_mask);\nextern struct page *alloc_contig_pages(unsigned long nr_pages, gfp_t gfp_mask,\n\t\t\t\t       int nid, nodemask_t *nodemask);\n#endif\nvoid free_contig_range(unsigned long pfn, unsigned int nr_pages);\n\n#ifdef CONFIG_CMA\n/* CMA stuff */\nextern void init_cma_reserved_pageblock(struct page *page);\n#endif\n\n#endif /* __LINUX_GFP_H */\n"}, "5": {"id": 5, "path": "/src/include/linux/page-flags.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * Macros for manipulating and testing page->flags\n */\n\n#ifndef PAGE_FLAGS_H\n#define PAGE_FLAGS_H\n\n#include <linux/types.h>\n#include <linux/bug.h>\n#include <linux/mmdebug.h>\n#ifndef __GENERATING_BOUNDS_H\n#include <linux/mm_types.h>\n#include <generated/bounds.h>\n#endif /* !__GENERATING_BOUNDS_H */\n\n/*\n * Various page->flags bits:\n *\n * PG_reserved is set for special pages. The \"struct page\" of such a page\n * should in general not be touched (e.g. set dirty) except by its owner.\n * Pages marked as PG_reserved include:\n * - Pages part of the kernel image (including vDSO) and similar (e.g. BIOS,\n *   initrd, HW tables)\n * - Pages reserved or allocated early during boot (before the page allocator\n *   was initialized). This includes (depending on the architecture) the\n *   initial vmemmap, initial page tables, crashkernel, elfcorehdr, and much\n *   much more. Once (if ever) freed, PG_reserved is cleared and they will\n *   be given to the page allocator.\n * - Pages falling into physical memory gaps - not IORESOURCE_SYSRAM. Trying\n *   to read/write these pages might end badly. Don't touch!\n * - The zero page(s)\n * - Pages not added to the page allocator when onlining a section because\n *   they were excluded via the online_page_callback() or because they are\n *   PG_hwpoison.\n * - Pages allocated in the context of kexec/kdump (loaded kernel image,\n *   control pages, vmcoreinfo)\n * - MMIO/DMA pages. Some architectures don't allow to ioremap pages that are\n *   not marked PG_reserved (as they might be in use by somebody else who does\n *   not respect the caching strategy).\n * - Pages part of an offline section (struct pages of offline sections should\n *   not be trusted as they will be initialized when first onlined).\n * - MCA pages on ia64\n * - Pages holding CPU notes for POWER Firmware Assisted Dump\n * - Device memory (e.g. PMEM, DAX, HMM)\n * Some PG_reserved pages will be excluded from the hibernation image.\n * PG_reserved does in general not hinder anybody from dumping or swapping\n * and is no longer required for remap_pfn_range(). ioremap might require it.\n * Consequently, PG_reserved for a page mapped into user space can indicate\n * the zero page, the vDSO, MMIO pages or device memory.\n *\n * The PG_private bitflag is set on pagecache pages if they contain filesystem\n * specific data (which is normally at page->private). It can be used by\n * private allocations for its own usage.\n *\n * During initiation of disk I/O, PG_locked is set. This bit is set before I/O\n * and cleared when writeback _starts_ or when read _completes_. PG_writeback\n * is set before writeback starts and cleared when it finishes.\n *\n * PG_locked also pins a page in pagecache, and blocks truncation of the file\n * while it is held.\n *\n * page_waitqueue(page) is a wait queue of all tasks waiting for the page\n * to become unlocked.\n *\n * PG_swapbacked is set when a page uses swap as a backing storage.  This are\n * usually PageAnon or shmem pages but please note that even anonymous pages\n * might lose their PG_swapbacked flag when they simply can be dropped (e.g. as\n * a result of MADV_FREE).\n *\n * PG_uptodate tells whether the page's contents is valid.  When a read\n * completes, the page becomes uptodate, unless a disk I/O error happened.\n *\n * PG_referenced, PG_reclaim are used for page reclaim for anonymous and\n * file-backed pagecache (see mm/vmscan.c).\n *\n * PG_error is set to indicate that an I/O error occurred on this page.\n *\n * PG_arch_1 is an architecture specific page state bit.  The generic code\n * guarantees that this bit is cleared for a page when it first is entered into\n * the page cache.\n *\n * PG_hwpoison indicates that a page got corrupted in hardware and contains\n * data with incorrect ECC bits that triggered a machine check. Accessing is\n * not safe since it may cause another machine check. Don't touch!\n */\n\n/*\n * Don't use the pageflags directly.  Use the PageFoo macros.\n *\n * The page flags field is split into two parts, the main flags area\n * which extends from the low bits upwards, and the fields area which\n * extends from the high bits downwards.\n *\n *  | FIELD | ... | FLAGS |\n *  N-1           ^       0\n *               (NR_PAGEFLAGS)\n *\n * The fields area is reserved for fields mapping zone, node (for NUMA) and\n * SPARSEMEM section (for variants of SPARSEMEM that require section ids like\n * SPARSEMEM_EXTREME with !SPARSEMEM_VMEMMAP).\n */\nenum pageflags {\n\tPG_locked,\t\t/* Page is locked. Don't touch. */\n\tPG_referenced,\n\tPG_uptodate,\n\tPG_dirty,\n\tPG_lru,\n\tPG_active,\n\tPG_workingset,\n\tPG_waiters,\t\t/* Page has waiters, check its waitqueue. Must be bit #7 and in the same byte as \"PG_locked\" */\n\tPG_error,\n\tPG_slab,\n\tPG_owner_priv_1,\t/* Owner use. If pagecache, fs may use*/\n\tPG_arch_1,\n\tPG_reserved,\n\tPG_private,\t\t/* If pagecache, has fs-private data */\n\tPG_private_2,\t\t/* If pagecache, has fs aux data */\n\tPG_writeback,\t\t/* Page is under writeback */\n\tPG_head,\t\t/* A head page */\n\tPG_mappedtodisk,\t/* Has blocks allocated on-disk */\n\tPG_reclaim,\t\t/* To be reclaimed asap */\n\tPG_swapbacked,\t\t/* Page is backed by RAM/swap */\n\tPG_unevictable,\t\t/* Page is \"unevictable\"  */\n#ifdef CONFIG_MMU\n\tPG_mlocked,\t\t/* Page is vma mlocked */\n#endif\n#ifdef CONFIG_ARCH_USES_PG_UNCACHED\n\tPG_uncached,\t\t/* Page has been mapped as uncached */\n#endif\n#ifdef CONFIG_MEMORY_FAILURE\n\tPG_hwpoison,\t\t/* hardware poisoned page. Don't touch */\n#endif\n#if defined(CONFIG_IDLE_PAGE_TRACKING) && defined(CONFIG_64BIT)\n\tPG_young,\n\tPG_idle,\n#endif\n#ifdef CONFIG_64BIT\n\tPG_arch_2,\n#endif\n\t__NR_PAGEFLAGS,\n\n\t/* Filesystems */\n\tPG_checked = PG_owner_priv_1,\n\n\t/* SwapBacked */\n\tPG_swapcache = PG_owner_priv_1,\t/* Swap page: swp_entry_t in private */\n\n\t/* Two page bits are conscripted by FS-Cache to maintain local caching\n\t * state.  These bits are set on pages belonging to the netfs's inodes\n\t * when those inodes are being locally cached.\n\t */\n\tPG_fscache = PG_private_2,\t/* page backed by cache */\n\n\t/* XEN */\n\t/* Pinned in Xen as a read-only pagetable page. */\n\tPG_pinned = PG_owner_priv_1,\n\t/* Pinned as part of domain save (see xen_mm_pin_all()). */\n\tPG_savepinned = PG_dirty,\n\t/* Has a grant mapping of another (foreign) domain's page. */\n\tPG_foreign = PG_owner_priv_1,\n\t/* Remapped by swiotlb-xen. */\n\tPG_xen_remapped = PG_owner_priv_1,\n\n\t/* SLOB */\n\tPG_slob_free = PG_private,\n\n\t/* Compound pages. Stored in first tail page's flags */\n\tPG_double_map = PG_workingset,\n\n\t/* non-lru isolated movable page */\n\tPG_isolated = PG_reclaim,\n\n\t/* Only valid for buddy pages. Used to track pages that are reported */\n\tPG_reported = PG_uptodate,\n};\n\n#ifndef __GENERATING_BOUNDS_H\n\nstruct page;\t/* forward declaration */\n\nstatic inline struct page *compound_head(struct page *page)\n{\n\tunsigned long head = READ_ONCE(page->compound_head);\n\n\tif (unlikely(head & 1))\n\t\treturn (struct page *) (head - 1);\n\treturn page;\n}\n\nstatic __always_inline int PageTail(struct page *page)\n{\n\treturn READ_ONCE(page->compound_head) & 1;\n}\n\nstatic __always_inline int PageCompound(struct page *page)\n{\n\treturn test_bit(PG_head, &page->flags) || PageTail(page);\n}\n\n#define\tPAGE_POISON_PATTERN\t-1l\nstatic inline int PagePoisoned(const struct page *page)\n{\n\treturn page->flags == PAGE_POISON_PATTERN;\n}\n\n#ifdef CONFIG_DEBUG_VM\nvoid page_init_poison(struct page *page, size_t size);\n#else\nstatic inline void page_init_poison(struct page *page, size_t size)\n{\n}\n#endif\n\n/*\n * Page flags policies wrt compound pages\n *\n * PF_POISONED_CHECK\n *     check if this struct page poisoned/uninitialized\n *\n * PF_ANY:\n *     the page flag is relevant for small, head and tail pages.\n *\n * PF_HEAD:\n *     for compound page all operations related to the page flag applied to\n *     head page.\n *\n * PF_ONLY_HEAD:\n *     for compound page, callers only ever operate on the head page.\n *\n * PF_NO_TAIL:\n *     modifications of the page flag must be done on small or head pages,\n *     checks can be done on tail pages too.\n *\n * PF_NO_COMPOUND:\n *     the page flag is not relevant for compound pages.\n *\n * PF_SECOND:\n *     the page flag is stored in the first tail page.\n */\n#define PF_POISONED_CHECK(page) ({\t\t\t\t\t\\\n\t\tVM_BUG_ON_PGFLAGS(PagePoisoned(page), page);\t\t\\\n\t\tpage; })\n#define PF_ANY(page, enforce)\tPF_POISONED_CHECK(page)\n#define PF_HEAD(page, enforce)\tPF_POISONED_CHECK(compound_head(page))\n#define PF_ONLY_HEAD(page, enforce) ({\t\t\t\t\t\\\n\t\tVM_BUG_ON_PGFLAGS(PageTail(page), page);\t\t\\\n\t\tPF_POISONED_CHECK(page); })\n#define PF_NO_TAIL(page, enforce) ({\t\t\t\t\t\\\n\t\tVM_BUG_ON_PGFLAGS(enforce && PageTail(page), page);\t\\\n\t\tPF_POISONED_CHECK(compound_head(page)); })\n#define PF_NO_COMPOUND(page, enforce) ({\t\t\t\t\\\n\t\tVM_BUG_ON_PGFLAGS(enforce && PageCompound(page), page);\t\\\n\t\tPF_POISONED_CHECK(page); })\n#define PF_SECOND(page, enforce) ({\t\t\t\t\t\\\n\t\tVM_BUG_ON_PGFLAGS(!PageHead(page), page);\t\t\\\n\t\tPF_POISONED_CHECK(&page[1]); })\n\n/*\n * Macros to create function definitions for page flags\n */\n#define TESTPAGEFLAG(uname, lname, policy)\t\t\t\t\\\nstatic __always_inline int Page##uname(struct page *page)\t\t\\\n\t{ return test_bit(PG_##lname, &policy(page, 0)->flags); }\n\n#define SETPAGEFLAG(uname, lname, policy)\t\t\t\t\\\nstatic __always_inline void SetPage##uname(struct page *page)\t\t\\\n\t{ set_bit(PG_##lname, &policy(page, 1)->flags); }\n\n#define CLEARPAGEFLAG(uname, lname, policy)\t\t\t\t\\\nstatic __always_inline void ClearPage##uname(struct page *page)\t\t\\\n\t{ clear_bit(PG_##lname, &policy(page, 1)->flags); }\n\n#define __SETPAGEFLAG(uname, lname, policy)\t\t\t\t\\\nstatic __always_inline void __SetPage##uname(struct page *page)\t\t\\\n\t{ __set_bit(PG_##lname, &policy(page, 1)->flags); }\n\n#define __CLEARPAGEFLAG(uname, lname, policy)\t\t\t\t\\\nstatic __always_inline void __ClearPage##uname(struct page *page)\t\\\n\t{ __clear_bit(PG_##lname, &policy(page, 1)->flags); }\n\n#define TESTSETFLAG(uname, lname, policy)\t\t\t\t\\\nstatic __always_inline int TestSetPage##uname(struct page *page)\t\\\n\t{ return test_and_set_bit(PG_##lname, &policy(page, 1)->flags); }\n\n#define TESTCLEARFLAG(uname, lname, policy)\t\t\t\t\\\nstatic __always_inline int TestClearPage##uname(struct page *page)\t\\\n\t{ return test_and_clear_bit(PG_##lname, &policy(page, 1)->flags); }\n\n#define PAGEFLAG(uname, lname, policy)\t\t\t\t\t\\\n\tTESTPAGEFLAG(uname, lname, policy)\t\t\t\t\\\n\tSETPAGEFLAG(uname, lname, policy)\t\t\t\t\\\n\tCLEARPAGEFLAG(uname, lname, policy)\n\n#define __PAGEFLAG(uname, lname, policy)\t\t\t\t\\\n\tTESTPAGEFLAG(uname, lname, policy)\t\t\t\t\\\n\t__SETPAGEFLAG(uname, lname, policy)\t\t\t\t\\\n\t__CLEARPAGEFLAG(uname, lname, policy)\n\n#define TESTSCFLAG(uname, lname, policy)\t\t\t\t\\\n\tTESTSETFLAG(uname, lname, policy)\t\t\t\t\\\n\tTESTCLEARFLAG(uname, lname, policy)\n\n#define TESTPAGEFLAG_FALSE(uname)\t\t\t\t\t\\\nstatic inline int Page##uname(const struct page *page) { return 0; }\n\n#define SETPAGEFLAG_NOOP(uname)\t\t\t\t\t\t\\\nstatic inline void SetPage##uname(struct page *page) {  }\n\n#define CLEARPAGEFLAG_NOOP(uname)\t\t\t\t\t\\\nstatic inline void ClearPage##uname(struct page *page) {  }\n\n#define __CLEARPAGEFLAG_NOOP(uname)\t\t\t\t\t\\\nstatic inline void __ClearPage##uname(struct page *page) {  }\n\n#define TESTSETFLAG_FALSE(uname)\t\t\t\t\t\\\nstatic inline int TestSetPage##uname(struct page *page) { return 0; }\n\n#define TESTCLEARFLAG_FALSE(uname)\t\t\t\t\t\\\nstatic inline int TestClearPage##uname(struct page *page) { return 0; }\n\n#define PAGEFLAG_FALSE(uname) TESTPAGEFLAG_FALSE(uname)\t\t\t\\\n\tSETPAGEFLAG_NOOP(uname) CLEARPAGEFLAG_NOOP(uname)\n\n#define TESTSCFLAG_FALSE(uname)\t\t\t\t\t\t\\\n\tTESTSETFLAG_FALSE(uname) TESTCLEARFLAG_FALSE(uname)\n\n__PAGEFLAG(Locked, locked, PF_NO_TAIL)\nPAGEFLAG(Waiters, waiters, PF_ONLY_HEAD) __CLEARPAGEFLAG(Waiters, waiters, PF_ONLY_HEAD)\nPAGEFLAG(Error, error, PF_NO_TAIL) TESTCLEARFLAG(Error, error, PF_NO_TAIL)\nPAGEFLAG(Referenced, referenced, PF_HEAD)\n\tTESTCLEARFLAG(Referenced, referenced, PF_HEAD)\n\t__SETPAGEFLAG(Referenced, referenced, PF_HEAD)\nPAGEFLAG(Dirty, dirty, PF_HEAD) TESTSCFLAG(Dirty, dirty, PF_HEAD)\n\t__CLEARPAGEFLAG(Dirty, dirty, PF_HEAD)\nPAGEFLAG(LRU, lru, PF_HEAD) __CLEARPAGEFLAG(LRU, lru, PF_HEAD)\n\tTESTCLEARFLAG(LRU, lru, PF_HEAD)\nPAGEFLAG(Active, active, PF_HEAD) __CLEARPAGEFLAG(Active, active, PF_HEAD)\n\tTESTCLEARFLAG(Active, active, PF_HEAD)\nPAGEFLAG(Workingset, workingset, PF_HEAD)\n\tTESTCLEARFLAG(Workingset, workingset, PF_HEAD)\n__PAGEFLAG(Slab, slab, PF_NO_TAIL)\n__PAGEFLAG(SlobFree, slob_free, PF_NO_TAIL)\nPAGEFLAG(Checked, checked, PF_NO_COMPOUND)\t   /* Used by some filesystems */\n\n/* Xen */\nPAGEFLAG(Pinned, pinned, PF_NO_COMPOUND)\n\tTESTSCFLAG(Pinned, pinned, PF_NO_COMPOUND)\nPAGEFLAG(SavePinned, savepinned, PF_NO_COMPOUND);\nPAGEFLAG(Foreign, foreign, PF_NO_COMPOUND);\nPAGEFLAG(XenRemapped, xen_remapped, PF_NO_COMPOUND)\n\tTESTCLEARFLAG(XenRemapped, xen_remapped, PF_NO_COMPOUND)\n\nPAGEFLAG(Reserved, reserved, PF_NO_COMPOUND)\n\t__CLEARPAGEFLAG(Reserved, reserved, PF_NO_COMPOUND)\n\t__SETPAGEFLAG(Reserved, reserved, PF_NO_COMPOUND)\nPAGEFLAG(SwapBacked, swapbacked, PF_NO_TAIL)\n\t__CLEARPAGEFLAG(SwapBacked, swapbacked, PF_NO_TAIL)\n\t__SETPAGEFLAG(SwapBacked, swapbacked, PF_NO_TAIL)\n\n/*\n * Private page markings that may be used by the filesystem that owns the page\n * for its own purposes.\n * - PG_private and PG_private_2 cause releasepage() and co to be invoked\n */\nPAGEFLAG(Private, private, PF_ANY)\nPAGEFLAG(Private2, private_2, PF_ANY) TESTSCFLAG(Private2, private_2, PF_ANY)\nPAGEFLAG(OwnerPriv1, owner_priv_1, PF_ANY)\n\tTESTCLEARFLAG(OwnerPriv1, owner_priv_1, PF_ANY)\n\n/*\n * Only test-and-set exist for PG_writeback.  The unconditional operators are\n * risky: they bypass page accounting.\n */\nTESTPAGEFLAG(Writeback, writeback, PF_NO_TAIL)\n\tTESTSCFLAG(Writeback, writeback, PF_NO_TAIL)\nPAGEFLAG(MappedToDisk, mappedtodisk, PF_NO_TAIL)\n\n/* PG_readahead is only used for reads; PG_reclaim is only for writes */\nPAGEFLAG(Reclaim, reclaim, PF_NO_TAIL)\n\tTESTCLEARFLAG(Reclaim, reclaim, PF_NO_TAIL)\nPAGEFLAG(Readahead, reclaim, PF_NO_COMPOUND)\n\tTESTCLEARFLAG(Readahead, reclaim, PF_NO_COMPOUND)\n\n#ifdef CONFIG_HIGHMEM\n/*\n * Must use a macro here due to header dependency issues. page_zone() is not\n * available at this point.\n */\n#define PageHighMem(__p) is_highmem_idx(page_zonenum(__p))\n#else\nPAGEFLAG_FALSE(HighMem)\n#endif\n\n#ifdef CONFIG_SWAP\nstatic __always_inline int PageSwapCache(struct page *page)\n{\n#ifdef CONFIG_THP_SWAP\n\tpage = compound_head(page);\n#endif\n\treturn PageSwapBacked(page) && test_bit(PG_swapcache, &page->flags);\n\n}\nSETPAGEFLAG(SwapCache, swapcache, PF_NO_TAIL)\nCLEARPAGEFLAG(SwapCache, swapcache, PF_NO_TAIL)\n#else\nPAGEFLAG_FALSE(SwapCache)\n#endif\n\nPAGEFLAG(Unevictable, unevictable, PF_HEAD)\n\t__CLEARPAGEFLAG(Unevictable, unevictable, PF_HEAD)\n\tTESTCLEARFLAG(Unevictable, unevictable, PF_HEAD)\n\n#ifdef CONFIG_MMU\nPAGEFLAG(Mlocked, mlocked, PF_NO_TAIL)\n\t__CLEARPAGEFLAG(Mlocked, mlocked, PF_NO_TAIL)\n\tTESTSCFLAG(Mlocked, mlocked, PF_NO_TAIL)\n#else\nPAGEFLAG_FALSE(Mlocked) __CLEARPAGEFLAG_NOOP(Mlocked)\n\tTESTSCFLAG_FALSE(Mlocked)\n#endif\n\n#ifdef CONFIG_ARCH_USES_PG_UNCACHED\nPAGEFLAG(Uncached, uncached, PF_NO_COMPOUND)\n#else\nPAGEFLAG_FALSE(Uncached)\n#endif\n\n#ifdef CONFIG_MEMORY_FAILURE\nPAGEFLAG(HWPoison, hwpoison, PF_ANY)\nTESTSCFLAG(HWPoison, hwpoison, PF_ANY)\n#define __PG_HWPOISON (1UL << PG_hwpoison)\nextern bool take_page_off_buddy(struct page *page);\n#else\nPAGEFLAG_FALSE(HWPoison)\n#define __PG_HWPOISON 0\n#endif\n\n#if defined(CONFIG_IDLE_PAGE_TRACKING) && defined(CONFIG_64BIT)\nTESTPAGEFLAG(Young, young, PF_ANY)\nSETPAGEFLAG(Young, young, PF_ANY)\nTESTCLEARFLAG(Young, young, PF_ANY)\nPAGEFLAG(Idle, idle, PF_ANY)\n#endif\n\n/*\n * PageReported() is used to track reported free pages within the Buddy\n * allocator. We can use the non-atomic version of the test and set\n * operations as both should be shielded with the zone lock to prevent\n * any possible races on the setting or clearing of the bit.\n */\n__PAGEFLAG(Reported, reported, PF_NO_COMPOUND)\n\n/*\n * On an anonymous page mapped into a user virtual memory area,\n * page->mapping points to its anon_vma, not to a struct address_space;\n * with the PAGE_MAPPING_ANON bit set to distinguish it.  See rmap.h.\n *\n * On an anonymous page in a VM_MERGEABLE area, if CONFIG_KSM is enabled,\n * the PAGE_MAPPING_MOVABLE bit may be set along with the PAGE_MAPPING_ANON\n * bit; and then page->mapping points, not to an anon_vma, but to a private\n * structure which KSM associates with that merged page.  See ksm.h.\n *\n * PAGE_MAPPING_KSM without PAGE_MAPPING_ANON is used for non-lru movable\n * page and then page->mapping points a struct address_space.\n *\n * Please note that, confusingly, \"page_mapping\" refers to the inode\n * address_space which maps the page from disk; whereas \"page_mapped\"\n * refers to user virtual address space into which the page is mapped.\n */\n#define PAGE_MAPPING_ANON\t0x1\n#define PAGE_MAPPING_MOVABLE\t0x2\n#define PAGE_MAPPING_KSM\t(PAGE_MAPPING_ANON | PAGE_MAPPING_MOVABLE)\n#define PAGE_MAPPING_FLAGS\t(PAGE_MAPPING_ANON | PAGE_MAPPING_MOVABLE)\n\nstatic __always_inline int PageMappingFlags(struct page *page)\n{\n\treturn ((unsigned long)page->mapping & PAGE_MAPPING_FLAGS) != 0;\n}\n\nstatic __always_inline int PageAnon(struct page *page)\n{\n\tpage = compound_head(page);\n\treturn ((unsigned long)page->mapping & PAGE_MAPPING_ANON) != 0;\n}\n\nstatic __always_inline int __PageMovable(struct page *page)\n{\n\treturn ((unsigned long)page->mapping & PAGE_MAPPING_FLAGS) ==\n\t\t\t\tPAGE_MAPPING_MOVABLE;\n}\n\n#ifdef CONFIG_KSM\n/*\n * A KSM page is one of those write-protected \"shared pages\" or \"merged pages\"\n * which KSM maps into multiple mms, wherever identical anonymous page content\n * is found in VM_MERGEABLE vmas.  It's a PageAnon page, pointing not to any\n * anon_vma, but to that page's node of the stable tree.\n */\nstatic __always_inline int PageKsm(struct page *page)\n{\n\tpage = compound_head(page);\n\treturn ((unsigned long)page->mapping & PAGE_MAPPING_FLAGS) ==\n\t\t\t\tPAGE_MAPPING_KSM;\n}\n#else\nTESTPAGEFLAG_FALSE(Ksm)\n#endif\n\nu64 stable_page_flags(struct page *page);\n\nstatic inline int PageUptodate(struct page *page)\n{\n\tint ret;\n\tpage = compound_head(page);\n\tret = test_bit(PG_uptodate, &(page)->flags);\n\t/*\n\t * Must ensure that the data we read out of the page is loaded\n\t * _after_ we've loaded page->flags to check for PageUptodate.\n\t * We can skip the barrier if the page is not uptodate, because\n\t * we wouldn't be reading anything from it.\n\t *\n\t * See SetPageUptodate() for the other side of the story.\n\t */\n\tif (ret)\n\t\tsmp_rmb();\n\n\treturn ret;\n}\n\nstatic __always_inline void __SetPageUptodate(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tsmp_wmb();\n\t__set_bit(PG_uptodate, &page->flags);\n}\n\nstatic __always_inline void SetPageUptodate(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\t/*\n\t * Memory barrier must be issued before setting the PG_uptodate bit,\n\t * so that all previous stores issued in order to bring the page\n\t * uptodate are actually visible before PageUptodate becomes true.\n\t */\n\tsmp_wmb();\n\tset_bit(PG_uptodate, &page->flags);\n}\n\nCLEARPAGEFLAG(Uptodate, uptodate, PF_NO_TAIL)\n\nint test_clear_page_writeback(struct page *page);\nint __test_set_page_writeback(struct page *page, bool keep_write);\n\n#define test_set_page_writeback(page)\t\t\t\\\n\t__test_set_page_writeback(page, false)\n#define test_set_page_writeback_keepwrite(page)\t\\\n\t__test_set_page_writeback(page, true)\n\nstatic inline void set_page_writeback(struct page *page)\n{\n\ttest_set_page_writeback(page);\n}\n\nstatic inline void set_page_writeback_keepwrite(struct page *page)\n{\n\ttest_set_page_writeback_keepwrite(page);\n}\n\n__PAGEFLAG(Head, head, PF_ANY) CLEARPAGEFLAG(Head, head, PF_ANY)\n\nstatic __always_inline void set_compound_head(struct page *page, struct page *head)\n{\n\tWRITE_ONCE(page->compound_head, (unsigned long)head + 1);\n}\n\nstatic __always_inline void clear_compound_head(struct page *page)\n{\n\tWRITE_ONCE(page->compound_head, 0);\n}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\nstatic inline void ClearPageCompound(struct page *page)\n{\n\tBUG_ON(!PageHead(page));\n\tClearPageHead(page);\n}\n#endif\n\n#define PG_head_mask ((1UL << PG_head))\n\n#ifdef CONFIG_HUGETLB_PAGE\nint PageHuge(struct page *page);\nint PageHeadHuge(struct page *page);\nbool page_huge_active(struct page *page);\n#else\nTESTPAGEFLAG_FALSE(Huge)\nTESTPAGEFLAG_FALSE(HeadHuge)\n\nstatic inline bool page_huge_active(struct page *page)\n{\n\treturn 0;\n}\n#endif\n\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n/*\n * PageHuge() only returns true for hugetlbfs pages, but not for\n * normal or transparent huge pages.\n *\n * PageTransHuge() returns true for both transparent huge and\n * hugetlbfs pages, but not normal pages. PageTransHuge() can only be\n * called only in the core VM paths where hugetlbfs pages can't exist.\n */\nstatic inline int PageTransHuge(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\treturn PageHead(page);\n}\n\n/*\n * PageTransCompound returns true for both transparent huge pages\n * and hugetlbfs pages, so it should only be called when it's known\n * that hugetlbfs pages aren't involved.\n */\nstatic inline int PageTransCompound(struct page *page)\n{\n\treturn PageCompound(page);\n}\n\n/*\n * PageTransCompoundMap is the same as PageTransCompound, but it also\n * guarantees the primary MMU has the entire compound page mapped\n * through pmd_trans_huge, which in turn guarantees the secondary MMUs\n * can also map the entire compound page. This allows the secondary\n * MMUs to call get_user_pages() only once for each compound page and\n * to immediately map the entire compound page with a single secondary\n * MMU fault. If there will be a pmd split later, the secondary MMUs\n * will get an update through the MMU notifier invalidation through\n * split_huge_pmd().\n *\n * Unlike PageTransCompound, this is safe to be called only while\n * split_huge_pmd() cannot run from under us, like if protected by the\n * MMU notifier, otherwise it may result in page->_mapcount check false\n * positives.\n *\n * We have to treat page cache THP differently since every subpage of it\n * would get _mapcount inc'ed once it is PMD mapped.  But, it may be PTE\n * mapped in the current process so comparing subpage's _mapcount to\n * compound_mapcount to filter out PTE mapped case.\n */\nstatic inline int PageTransCompoundMap(struct page *page)\n{\n\tstruct page *head;\n\n\tif (!PageTransCompound(page))\n\t\treturn 0;\n\n\tif (PageAnon(page))\n\t\treturn atomic_read(&page->_mapcount) < 0;\n\n\thead = compound_head(page);\n\t/* File THP is PMD mapped and not PTE mapped */\n\treturn atomic_read(&page->_mapcount) ==\n\t       atomic_read(compound_mapcount_ptr(head));\n}\n\n/*\n * PageTransTail returns true for both transparent huge pages\n * and hugetlbfs pages, so it should only be called when it's known\n * that hugetlbfs pages aren't involved.\n */\nstatic inline int PageTransTail(struct page *page)\n{\n\treturn PageTail(page);\n}\n\n/*\n * PageDoubleMap indicates that the compound page is mapped with PTEs as well\n * as PMDs.\n *\n * This is required for optimization of rmap operations for THP: we can postpone\n * per small page mapcount accounting (and its overhead from atomic operations)\n * until the first PMD split.\n *\n * For the page PageDoubleMap means ->_mapcount in all sub-pages is offset up\n * by one. This reference will go away with last compound_mapcount.\n *\n * See also __split_huge_pmd_locked() and page_remove_anon_compound_rmap().\n */\nPAGEFLAG(DoubleMap, double_map, PF_SECOND)\n\tTESTSCFLAG(DoubleMap, double_map, PF_SECOND)\n#else\nTESTPAGEFLAG_FALSE(TransHuge)\nTESTPAGEFLAG_FALSE(TransCompound)\nTESTPAGEFLAG_FALSE(TransCompoundMap)\nTESTPAGEFLAG_FALSE(TransTail)\nPAGEFLAG_FALSE(DoubleMap)\n\tTESTSCFLAG_FALSE(DoubleMap)\n#endif\n\n/*\n * For pages that are never mapped to userspace (and aren't PageSlab),\n * page_type may be used.  Because it is initialised to -1, we invert the\n * sense of the bit, so __SetPageFoo *clears* the bit used for PageFoo, and\n * __ClearPageFoo *sets* the bit used for PageFoo.  We reserve a few high and\n * low bits so that an underflow or overflow of page_mapcount() won't be\n * mistaken for a page type value.\n */\n\n#define PAGE_TYPE_BASE\t0xf0000000\n/* Reserve\t\t0x0000007f to catch underflows of page_mapcount */\n#define PAGE_MAPCOUNT_RESERVE\t-128\n#define PG_buddy\t0x00000080\n#define PG_offline\t0x00000100\n#define PG_table\t0x00000200\n#define PG_guard\t0x00000400\n\n#define PageType(page, flag)\t\t\t\t\t\t\\\n\t((page->page_type & (PAGE_TYPE_BASE | flag)) == PAGE_TYPE_BASE)\n\nstatic inline int page_has_type(struct page *page)\n{\n\treturn (int)page->page_type < PAGE_MAPCOUNT_RESERVE;\n}\n\n#define PAGE_TYPE_OPS(uname, lname)\t\t\t\t\t\\\nstatic __always_inline int Page##uname(struct page *page)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn PageType(page, PG_##lname);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic __always_inline void __SetPage##uname(struct page *page)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tVM_BUG_ON_PAGE(!PageType(page, 0), page);\t\t\t\\\n\tpage->page_type &= ~PG_##lname;\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic __always_inline void __ClearPage##uname(struct page *page)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tVM_BUG_ON_PAGE(!Page##uname(page), page);\t\t\t\\\n\tpage->page_type |= PG_##lname;\t\t\t\t\t\\\n}\n\n/*\n * PageBuddy() indicates that the page is free and in the buddy system\n * (see mm/page_alloc.c).\n */\nPAGE_TYPE_OPS(Buddy, buddy)\n\n/*\n * PageOffline() indicates that the page is logically offline although the\n * containing section is online. (e.g. inflated in a balloon driver or\n * not onlined when onlining the section).\n * The content of these pages is effectively stale. Such pages should not\n * be touched (read/write/dump/save) except by their owner.\n *\n * If a driver wants to allow to offline unmovable PageOffline() pages without\n * putting them back to the buddy, it can do so via the memory notifier by\n * decrementing the reference count in MEM_GOING_OFFLINE and incrementing the\n * reference count in MEM_CANCEL_OFFLINE. When offlining, the PageOffline()\n * pages (now with a reference count of zero) are treated like free pages,\n * allowing the containing memory block to get offlined. A driver that\n * relies on this feature is aware that re-onlining the memory block will\n * require to re-set the pages PageOffline() and not giving them to the\n * buddy via online_page_callback_t.\n */\nPAGE_TYPE_OPS(Offline, offline)\n\n/*\n * Marks pages in use as page tables.\n */\nPAGE_TYPE_OPS(Table, table)\n\n/*\n * Marks guardpages used with debug_pagealloc.\n */\nPAGE_TYPE_OPS(Guard, guard)\n\nextern bool is_free_buddy_page(struct page *page);\n\n__PAGEFLAG(Isolated, isolated, PF_ANY);\n\n/*\n * If network-based swap is enabled, sl*b must keep track of whether pages\n * were allocated from pfmemalloc reserves.\n */\nstatic inline int PageSlabPfmemalloc(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageSlab(page), page);\n\treturn PageActive(page);\n}\n\nstatic inline void SetPageSlabPfmemalloc(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageSlab(page), page);\n\tSetPageActive(page);\n}\n\nstatic inline void __ClearPageSlabPfmemalloc(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageSlab(page), page);\n\t__ClearPageActive(page);\n}\n\nstatic inline void ClearPageSlabPfmemalloc(struct page *page)\n{\n\tVM_BUG_ON_PAGE(!PageSlab(page), page);\n\tClearPageActive(page);\n}\n\n#ifdef CONFIG_MMU\n#define __PG_MLOCKED\t\t(1UL << PG_mlocked)\n#else\n#define __PG_MLOCKED\t\t0\n#endif\n\n/*\n * Flags checked when a page is freed.  Pages being freed should not have\n * these flags set.  If they are, there is a problem.\n */\n#define PAGE_FLAGS_CHECK_AT_FREE\t\t\t\t\\\n\t(1UL << PG_lru\t\t| 1UL << PG_locked\t|\t\\\n\t 1UL << PG_private\t| 1UL << PG_private_2\t|\t\\\n\t 1UL << PG_writeback\t| 1UL << PG_reserved\t|\t\\\n\t 1UL << PG_slab\t\t| 1UL << PG_active \t|\t\\\n\t 1UL << PG_unevictable\t| __PG_MLOCKED)\n\n/*\n * Flags checked when a page is prepped for return by the page allocator.\n * Pages being prepped should not have these flags set.  If they are set,\n * there has been a kernel bug or struct page corruption.\n *\n * __PG_HWPOISON is exceptional because it needs to be kept beyond page's\n * alloc-free cycle to prevent from reusing the page.\n */\n#define PAGE_FLAGS_CHECK_AT_PREP\t\\\n\t(((1UL << NR_PAGEFLAGS) - 1) & ~__PG_HWPOISON)\n\n#define PAGE_FLAGS_PRIVATE\t\t\t\t\\\n\t(1UL << PG_private | 1UL << PG_private_2)\n/**\n * page_has_private - Determine if page has private stuff\n * @page: The page to be checked\n *\n * Determine if a page has private stuff, indicating that release routines\n * should be invoked upon it.\n */\nstatic inline int page_has_private(struct page *page)\n{\n\treturn !!(page->flags & PAGE_FLAGS_PRIVATE);\n}\n\n#undef PF_ANY\n#undef PF_HEAD\n#undef PF_ONLY_HEAD\n#undef PF_NO_TAIL\n#undef PF_NO_COMPOUND\n#undef PF_SECOND\n#endif /* !__GENERATING_BOUNDS_H */\n\n#endif\t/* PAGE_FLAGS_H */\n"}}, "reports": [{"events": [{"location": {"col": 36, "file": 0, "line": 2842}, "message": "Passing null pointer value via 3rd parameter 'nodes'"}, {"location": {"col": 14, "file": 1, "line": 8}, "message": "expanded from macro 'NULL'"}, {"location": {"col": 2, "file": 0, "line": 2842}, "message": "Calling 'do_set_mempolicy'"}, {"location": {"col": 7, "file": 0, "line": 869}, "message": "'scratch' is non-null"}, {"location": {"col": 2, "file": 0, "line": 869}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 873}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 2, "line": 36}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 2, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 3, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 2, "line": 36}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 873}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 2, "file": 0, "line": 873}, "message": "Taking false branch"}, {"location": {"col": 31, "file": 0, "line": 878}, "message": "Passing null pointer value via 2nd parameter 'nodes'"}, {"location": {"col": 8, "file": 0, "line": 878}, "message": "Calling 'mpol_set_nodemask'"}, {"location": {"col": 6, "file": 0, "line": 235}, "message": "Assuming 'pol' is not equal to NULL"}, {"location": {"col": 2, "file": 0, "line": 235}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 242}, "message": "Assuming field 'mode' is not equal to MPOL_PREFERRED"}, {"location": {"col": 34, "file": 0, "line": 242}, "message": "Left side of '&&' is false"}, {"location": {"col": 7, "file": 0, "line": 245}, "message": "Assuming the condition is false"}, {"location": {"col": 3, "file": 0, "line": 245}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 250}, "message": "Assuming the condition is true"}, {"location": {"col": 3, "file": 0, "line": 250}, "message": "Taking true branch"}, {"location": {"col": 27, "file": 0, "line": 251}, "message": "Dereference of null pointer (loaded from variable 'nodes')"}, {"location": {"col": 27, "file": 0, "line": 251}, "message": "Dereference of null pointer (loaded from variable 'nodes')"}], "macros": [], "notes": [], "path": "/src/mm/mempolicy.c", "reportHash": "a70437f4bdce60867b95d9f8555594fe", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 1217}, "message": "'address' declared without an initial value"}, {"location": {"col": 2, "file": 0, "line": 1220}, "message": "Loop condition is false. Execution continues on line 1227"}, {"location": {"col": 6, "file": 0, "line": 1227}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 0, "line": 1227}, "message": "Taking true branch"}, {"location": {"col": 10, "file": 0, "line": 1228}, "message": "3rd function call argument is an uninitialized value"}, {"location": {"col": 10, "file": 0, "line": 1228}, "message": "3rd function call argument is an uninitialized value"}], "macros": [], "notes": [], "path": "/src/mm/mempolicy.c", "reportHash": "77fb593b9738760defdc6caf94301704", "checkerName": "clang-analyzer-core.CallAndMessage", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 4, "line": 566}, "message": "expanded from macro 'alloc_page_vma'"}, {"location": {"col": 2, "file": 0, "line": 1217}, "message": "'address' declared without an initial value"}, {"location": {"col": 2, "file": 0, "line": 1220}, "message": "Loop condition is false. Execution continues on line 1227"}, {"location": {"col": 6, "file": 0, "line": 1227}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1227}, "message": "Taking false branch"}, {"location": {"col": 13, "file": 0, "line": 1230}, "message": "Calling 'PageTransHuge'"}, {"location": {"col": 1, "file": 5, "line": 695}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 58, "file": 5, "line": 305}, "message": "expanded from macro 'TESTPAGEFLAG_FALSE'"}, {"location": {"col": 13, "file": 0, "line": 1230}, "message": "Returning from 'PageTransHuge'"}, {"location": {"col": 9, "file": 0, "line": 1230}, "message": "Taking false branch"}, {"location": {"col": 9, "file": 0, "line": 1243}, "message": "4th function call argument is an uninitialized value"}, {"location": {"col": 2, "file": 4, "line": 566}, "message": "expanded from macro 'alloc_page_vma'"}, {"location": {"col": 9, "file": 0, "line": 1243}, "message": "4th function call argument is an uninitialized value"}], "macros": [], "notes": [], "path": "/src/mm/mempolicy.c", "reportHash": "0761b4db47504999db41bad708521cd9", "checkerName": "clang-analyzer-core.CallAndMessage", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 3051}, "message": "Value stored to 'p' is never read"}, {"location": {"col": 3, "file": 0, "line": 3051}, "message": "Value stored to 'p' is never read"}], "macros": [], "notes": [], "path": "/src/mm/mempolicy.c", "reportHash": "6e16af53a162bad2e4f969e8ae55aad6", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
