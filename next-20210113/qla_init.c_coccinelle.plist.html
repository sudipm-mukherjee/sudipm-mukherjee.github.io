<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/scsi/qla2xxx/qla_init.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * QLogic Fibre Channel HBA Driver\n * Copyright (c)  2003-2014 QLogic Corporation\n */\n#include \"qla_def.h\"\n#include \"qla_gbl.h\"\n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\n#include \"qla_devtbl.h\"\n\n#ifdef CONFIG_SPARC\n#include <asm/prom.h>\n#endif\n\n#include \"qla_target.h\"\n\n/*\n*  QLogic ISP2x00 Hardware Support Function Prototypes.\n*/\nstatic int qla2x00_isp_firmware(scsi_qla_host_t *);\nstatic int qla2x00_setup_chip(scsi_qla_host_t *);\nstatic int qla2x00_fw_ready(scsi_qla_host_t *);\nstatic int qla2x00_configure_hba(scsi_qla_host_t *);\nstatic int qla2x00_configure_loop(scsi_qla_host_t *);\nstatic int qla2x00_configure_local_loop(scsi_qla_host_t *);\nstatic int qla2x00_configure_fabric(scsi_qla_host_t *);\nstatic int qla2x00_find_all_fabric_devs(scsi_qla_host_t *);\nstatic int qla2x00_restart_isp(scsi_qla_host_t *);\n\nstatic struct qla_chip_state_84xx *qla84xx_get_chip(struct scsi_qla_host *);\nstatic int qla84xx_init_chip(scsi_qla_host_t *);\nstatic int qla25xx_init_queues(struct qla_hw_data *);\nstatic int qla24xx_post_prli_work(struct scsi_qla_host*, fc_port_t *);\nstatic void qla24xx_handle_gpdb_event(scsi_qla_host_t *vha,\n\t\t\t\t      struct event_arg *ea);\nstatic void qla24xx_handle_prli_done_event(struct scsi_qla_host *,\n    struct event_arg *);\nstatic void __qla24xx_handle_gpdb_event(scsi_qla_host_t *, struct event_arg *);\n\n/* SRB Extensions ---------------------------------------------------------- */\n\nvoid\nqla2x00_sp_timeout(struct timer_list *t)\n{\n\tsrb_t *sp = from_timer(sp, t, u.iocb_cmd.timer);\n\tstruct srb_iocb *iocb;\n\n\tWARN_ON(irqs_disabled());\n\tiocb = &sp->u.iocb_cmd;\n\tiocb->timeout(sp);\n}\n\nvoid qla2x00_sp_free(srb_t *sp)\n{\n\tstruct srb_iocb *iocb = &sp->u.iocb_cmd;\n\n\tdel_timer(&iocb->timer);\n\tqla2x00_rel_sp(sp);\n}\n\nvoid qla2xxx_rel_done_warning(srb_t *sp, int res)\n{\n\tWARN_ONCE(1, \"Calling done() of an already freed srb %p object\\n\", sp);\n}\n\nvoid qla2xxx_rel_free_warning(srb_t *sp)\n{\n\tWARN_ONCE(1, \"Calling free() of an already freed srb %p object\\n\", sp);\n}\n\n/* Asynchronous Login/Logout Routines -------------------------------------- */\n\nunsigned long\nqla2x00_get_async_timeout(struct scsi_qla_host *vha)\n{\n\tunsigned long tmo;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t/* Firmware should use switch negotiated r_a_tov for timeout. */\n\ttmo = ha->r_a_tov / 10 * 2;\n\tif (IS_QLAFX00(ha)) {\n\t\ttmo = FX00_DEF_RATOV * 2;\n\t} else if (!IS_FWI2_CAPABLE(ha)) {\n\t\t/*\n\t\t * Except for earlier ISPs where the timeout is seeded from the\n\t\t * initialization control block.\n\t\t */\n\t\ttmo = ha->login_timeout;\n\t}\n\treturn tmo;\n}\n\nstatic void qla24xx_abort_iocb_timeout(void *data)\n{\n\tsrb_t *sp = data;\n\tstruct srb_iocb *abt = &sp->u.iocb_cmd;\n\tstruct qla_qpair *qpair = sp->qpair;\n\tu32 handle;\n\tunsigned long flags;\n\n\tif (sp->cmd_sp)\n\t\tql_dbg(ql_dbg_async, sp->vha, 0x507c,\n\t\t    \"Abort timeout - cmd hdl=%x, cmd type=%x hdl=%x, type=%x\\n\",\n\t\t    sp->cmd_sp->handle, sp->cmd_sp->type,\n\t\t    sp->handle, sp->type);\n\telse\n\t\tql_dbg(ql_dbg_async, sp->vha, 0x507c,\n\t\t    \"Abort timeout 2 - hdl=%x, type=%x\\n\",\n\t\t    sp->handle, sp->type);\n\n\tspin_lock_irqsave(qpair->qp_lock_ptr, flags);\n\tfor (handle = 1; handle < qpair->req->num_outstanding_cmds; handle++) {\n\t\tif (sp->cmd_sp && (qpair->req->outstanding_cmds[handle] ==\n\t\t    sp->cmd_sp))\n\t\t\tqpair->req->outstanding_cmds[handle] = NULL;\n\n\t\t/* removing the abort */\n\t\tif (qpair->req->outstanding_cmds[handle] == sp) {\n\t\t\tqpair->req->outstanding_cmds[handle] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\n\tif (sp->cmd_sp)\n\t\tsp->cmd_sp->done(sp->cmd_sp, QLA_OS_TIMER_EXPIRED);\n\n\tabt->u.abt.comp_status = cpu_to_le16(CS_TIMEOUT);\n\tsp->done(sp, QLA_OS_TIMER_EXPIRED);\n}\n\nstatic void qla24xx_abort_sp_done(srb_t *sp, int res)\n{\n\tstruct srb_iocb *abt = &sp->u.iocb_cmd;\n\n\tdel_timer(&sp->u.iocb_cmd.timer);\n\tif (sp->flags & SRB_WAKEUP_ON_COMP)\n\t\tcomplete(&abt->u.abt.comp);\n\telse\n\t\tsp->free(sp);\n}\n\nint qla24xx_async_abort_cmd(srb_t *cmd_sp, bool wait)\n{\n\tscsi_qla_host_t *vha = cmd_sp->vha;\n\tstruct srb_iocb *abt_iocb;\n\tsrb_t *sp;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tsp = qla2xxx_get_qpair_sp(cmd_sp->vha, cmd_sp->qpair, cmd_sp->fcport,\n\t\t\t\t  GFP_ATOMIC);\n\tif (!sp)\n\t\treturn rval;\n\n\tabt_iocb = &sp->u.iocb_cmd;\n\tsp->type = SRB_ABT_CMD;\n\tsp->name = \"abort\";\n\tsp->qpair = cmd_sp->qpair;\n\tsp->cmd_sp = cmd_sp;\n\tif (wait)\n\t\tsp->flags = SRB_WAKEUP_ON_COMP;\n\n\tabt_iocb->timeout = qla24xx_abort_iocb_timeout;\n\tinit_completion(&abt_iocb->u.abt.comp);\n\t/* FW can send 2 x ABTS's timeout/20s */\n\tqla2x00_init_timer(sp, 42);\n\n\tabt_iocb->u.abt.cmd_hndl = cmd_sp->handle;\n\tabt_iocb->u.abt.req_que_no = cpu_to_le16(cmd_sp->qpair->req->id);\n\n\tsp->done = qla24xx_abort_sp_done;\n\n\tql_dbg(ql_dbg_async, vha, 0x507c,\n\t       \"Abort command issued - hdl=%x, type=%x\\n\", cmd_sp->handle,\n\t       cmd_sp->type);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tsp->free(sp);\n\t\treturn rval;\n\t}\n\n\tif (wait) {\n\t\twait_for_completion(&abt_iocb->u.abt.comp);\n\t\trval = abt_iocb->u.abt.comp_status == CS_COMPLETE ?\n\t\t\tQLA_SUCCESS : QLA_FUNCTION_FAILED;\n\t\tsp->free(sp);\n\t}\n\n\treturn rval;\n}\n\nvoid\nqla2x00_async_iocb_timeout(void *data)\n{\n\tsrb_t *sp = data;\n\tfc_port_t *fcport = sp->fcport;\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\tint rc, h;\n\tunsigned long flags;\n\n\tif (fcport) {\n\t\tql_dbg(ql_dbg_disc, fcport->vha, 0x2071,\n\t\t    \"Async-%s timeout - hdl=%x portid=%06x %8phC.\\n\",\n\t\t    sp->name, sp->handle, fcport->d_id.b24, fcport->port_name);\n\n\t\tfcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\t} else {\n\t\tpr_info(\"Async-%s timeout - hdl=%x.\\n\",\n\t\t    sp->name, sp->handle);\n\t}\n\n\tswitch (sp->type) {\n\tcase SRB_LOGIN_CMD:\n\t\trc = qla24xx_async_abort_cmd(sp, false);\n\t\tif (rc) {\n\t\t\t/* Retry as needed. */\n\t\t\tlio->u.logio.data[0] = MBS_COMMAND_ERROR;\n\t\t\tlio->u.logio.data[1] =\n\t\t\t\tlio->u.logio.flags & SRB_LOGIN_RETRIED ?\n\t\t\t\tQLA_LOGIO_LOGIN_RETRIED : 0;\n\t\t\tspin_lock_irqsave(sp->qpair->qp_lock_ptr, flags);\n\t\t\tfor (h = 1; h < sp->qpair->req->num_outstanding_cmds;\n\t\t\t    h++) {\n\t\t\t\tif (sp->qpair->req->outstanding_cmds[h] ==\n\t\t\t\t    sp) {\n\t\t\t\t\tsp->qpair->req->outstanding_cmds[h] =\n\t\t\t\t\t    NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(sp->qpair->qp_lock_ptr, flags);\n\t\t\tsp->done(sp, QLA_FUNCTION_TIMEOUT);\n\t\t}\n\t\tbreak;\n\tcase SRB_LOGOUT_CMD:\n\tcase SRB_CT_PTHRU_CMD:\n\tcase SRB_MB_IOCB:\n\tcase SRB_NACK_PLOGI:\n\tcase SRB_NACK_PRLI:\n\tcase SRB_NACK_LOGO:\n\tcase SRB_CTRL_VP:\n\tdefault:\n\t\trc = qla24xx_async_abort_cmd(sp, false);\n\t\tif (rc) {\n\t\t\tspin_lock_irqsave(sp->qpair->qp_lock_ptr, flags);\n\t\t\tfor (h = 1; h < sp->qpair->req->num_outstanding_cmds;\n\t\t\t    h++) {\n\t\t\t\tif (sp->qpair->req->outstanding_cmds[h] ==\n\t\t\t\t    sp) {\n\t\t\t\t\tsp->qpair->req->outstanding_cmds[h] =\n\t\t\t\t\t    NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(sp->qpair->qp_lock_ptr, flags);\n\t\t\tsp->done(sp, QLA_FUNCTION_TIMEOUT);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void qla2x00_async_login_sp_done(srb_t *sp, int res)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\tstruct event_arg ea;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20dd,\n\t    \"%s %8phC res %d \\n\", __func__, sp->fcport->port_name, res);\n\n\tsp->fcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\n\tif (!test_bit(UNLOADING, &vha->dpc_flags)) {\n\t\tmemset(&ea, 0, sizeof(ea));\n\t\tea.fcport = sp->fcport;\n\t\tea.data[0] = lio->u.logio.data[0];\n\t\tea.data[1] = lio->u.logio.data[1];\n\t\tea.iop[0] = lio->u.logio.iop[0];\n\t\tea.iop[1] = lio->u.logio.iop[1];\n\t\tea.sp = sp;\n\t\tqla24xx_handle_plogi_done_event(vha, &ea);\n\t}\n\n\tsp->free(sp);\n}\n\nstatic inline bool\nfcport_is_smaller(fc_port_t *fcport)\n{\n\tif (wwn_to_u64(fcport->port_name) <\n\t    wwn_to_u64(fcport->vha->port_name))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic inline bool\nfcport_is_bigger(fc_port_t *fcport)\n{\n\treturn !fcport_is_smaller(fcport);\n}\n\nint\nqla2x00_async_login(struct scsi_qla_host *vha, fc_port_t *fcport,\n    uint16_t *data)\n{\n\tsrb_t *sp;\n\tstruct srb_iocb *lio;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tif (!vha->flags.online || (fcport->flags & FCF_ASYNC_SENT) ||\n\t    fcport->loop_id == FC_NO_LOOP_ID) {\n\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t    \"%s: %8phC - not sending command.\\n\",\n\t\t    __func__, fcport->port_name);\n\t\treturn rval;\n\t}\n\n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tqla2x00_set_fcport_disc_state(fcport, DSC_LOGIN_PEND);\n\tfcport->flags |= FCF_ASYNC_SENT;\n\tfcport->logout_completed = 0;\n\n\tsp->type = SRB_LOGIN_CMD;\n\tsp->name = \"login\";\n\tsp->gen1 = fcport->rscn_gen;\n\tsp->gen2 = fcport->login_gen;\n\n\tlio = &sp->u.iocb_cmd;\n\tlio->timeout = qla2x00_async_iocb_timeout;\n\tqla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);\n\n\tsp->done = qla2x00_async_login_sp_done;\n\tif (N2N_TOPO(fcport->vha->hw) && fcport_is_bigger(fcport))\n\t\tlio->u.logio.flags |= SRB_LOGIN_PRLI_ONLY;\n\telse\n\t\tlio->u.logio.flags |= SRB_LOGIN_COND_PLOGI;\n\n\tif (NVME_TARGET(vha->hw, fcport))\n\t\tlio->u.logio.flags |= SRB_LOGIN_SKIP_PRLI;\n\n\tql_dbg(ql_dbg_disc, vha, 0x2072,\n\t    \"Async-login - %8phC hdl=%x, loopid=%x portid=%02x%02x%02x \"\n\t\t\"retries=%d.\\n\", fcport->port_name, sp->handle, fcport->loop_id,\n\t    fcport->d_id.b.domain, fcport->d_id.b.area, fcport->d_id.b.al_pa,\n\t    fcport->login_retry);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tfcport->flags |= FCF_LOGIN_NEEDED;\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\tgoto done_free_sp;\n\t}\n\n\treturn rval;\n\ndone_free_sp:\n\tsp->free(sp);\n\tfcport->flags &= ~FCF_ASYNC_SENT;\ndone:\n\tfcport->flags &= ~FCF_ASYNC_ACTIVE;\n\treturn rval;\n}\n\nstatic void qla2x00_async_logout_sp_done(srb_t *sp, int res)\n{\n\tsp->fcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\tsp->fcport->login_gen++;\n\tqlt_logo_completion_handler(sp->fcport, res);\n\tsp->free(sp);\n}\n\nint\nqla2x00_async_logout(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tsrb_t *sp;\n\tstruct srb_iocb *lio;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tfcport->flags |= FCF_ASYNC_SENT;\n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->type = SRB_LOGOUT_CMD;\n\tsp->name = \"logout\";\n\n\tlio = &sp->u.iocb_cmd;\n\tlio->timeout = qla2x00_async_iocb_timeout;\n\tqla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);\n\n\tsp->done = qla2x00_async_logout_sp_done;\n\n\tql_dbg(ql_dbg_disc, vha, 0x2070,\n\t    \"Async-logout - hdl=%x loop-id=%x portid=%02x%02x%02x %8phC.\\n\",\n\t    sp->handle, fcport->loop_id, fcport->d_id.b.domain,\n\t\tfcport->d_id.b.area, fcport->d_id.b.al_pa,\n\t\tfcport->port_name);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done_free_sp;\n\treturn rval;\n\ndone_free_sp:\n\tsp->free(sp);\ndone:\n\tfcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\treturn rval;\n}\n\nvoid\nqla2x00_async_prlo_done(struct scsi_qla_host *vha, fc_port_t *fcport,\n    uint16_t *data)\n{\n\tfcport->flags &= ~FCF_ASYNC_ACTIVE;\n\t/* Don't re-login in target mode */\n\tif (!fcport->tgt_session)\n\t\tqla2x00_mark_device_lost(vha, fcport, 1);\n\tqlt_logo_completion_handler(fcport, data[0]);\n}\n\nstatic void qla2x00_async_prlo_sp_done(srb_t *sp, int res)\n{\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\tstruct scsi_qla_host *vha = sp->vha;\n\n\tsp->fcport->flags &= ~FCF_ASYNC_ACTIVE;\n\tif (!test_bit(UNLOADING, &vha->dpc_flags))\n\t\tqla2x00_post_async_prlo_done_work(sp->fcport->vha, sp->fcport,\n\t\t    lio->u.logio.data);\n\tsp->free(sp);\n}\n\nint\nqla2x00_async_prlo(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tsrb_t *sp;\n\tstruct srb_iocb *lio;\n\tint rval;\n\n\trval = QLA_FUNCTION_FAILED;\n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->type = SRB_PRLO_CMD;\n\tsp->name = \"prlo\";\n\n\tlio = &sp->u.iocb_cmd;\n\tlio->timeout = qla2x00_async_iocb_timeout;\n\tqla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);\n\n\tsp->done = qla2x00_async_prlo_sp_done;\n\n\tql_dbg(ql_dbg_disc, vha, 0x2070,\n\t    \"Async-prlo - hdl=%x loop-id=%x portid=%02x%02x%02x.\\n\",\n\t    sp->handle, fcport->loop_id, fcport->d_id.b.domain,\n\t    fcport->d_id.b.area, fcport->d_id.b.al_pa);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done_free_sp;\n\n\treturn rval;\n\ndone_free_sp:\n\tsp->free(sp);\ndone:\n\tfcport->flags &= ~FCF_ASYNC_ACTIVE;\n\treturn rval;\n}\n\nstatic\nvoid qla24xx_handle_adisc_event(scsi_qla_host_t *vha, struct event_arg *ea)\n{\n\tstruct fc_port *fcport = ea->fcport;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20d2,\n\t    \"%s %8phC DS %d LS %d rc %d login %d|%d rscn %d|%d lid %d\\n\",\n\t    __func__, fcport->port_name, fcport->disc_state,\n\t    fcport->fw_login_state, ea->rc, fcport->login_gen, ea->sp->gen2,\n\t    fcport->rscn_gen, ea->sp->gen1, fcport->loop_id);\n\n\tWARN_ONCE(!qla2xxx_is_valid_mbs(ea->data[0]), \"mbs: %#x\\n\",\n\t\t  ea->data[0]);\n\n\tif (ea->data[0] != MBS_COMMAND_COMPLETE) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2066,\n\t\t    \"%s %8phC: adisc fail: post delete\\n\",\n\t\t    __func__, ea->fcport->port_name);\n\t\t/* deleted = 0 & logout_on_delete = force fw cleanup */\n\t\tfcport->deleted = 0;\n\t\tfcport->logout_on_delete = 1;\n\t\tqlt_schedule_sess_for_deletion(ea->fcport);\n\t\treturn;\n\t}\n\n\tif (ea->fcport->disc_state == DSC_DELETE_PEND)\n\t\treturn;\n\n\tif (ea->sp->gen2 != ea->fcport->login_gen) {\n\t\t/* target side must have changed it. */\n\t\tql_dbg(ql_dbg_disc, vha, 0x20d3,\n\t\t    \"%s %8phC generation changed\\n\",\n\t\t    __func__, ea->fcport->port_name);\n\t\treturn;\n\t} else if (ea->sp->gen1 != ea->fcport->rscn_gen) {\n\t\tqla_rscn_replay(fcport);\n\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\treturn;\n\t}\n\n\t__qla24xx_handle_gpdb_event(vha, ea);\n}\n\nstatic int qla_post_els_plogi_work(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_ELS_PLOGI);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.fcport.fcport = fcport;\n\tfcport->flags |= FCF_ASYNC_ACTIVE;\n\tqla2x00_set_fcport_disc_state(fcport, DSC_LOGIN_PEND);\n\treturn qla2x00_post_work(vha, e);\n}\n\nstatic void qla2x00_async_adisc_sp_done(srb_t *sp, int res)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct event_arg ea;\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\n\tql_dbg(ql_dbg_disc, vha, 0x2066,\n\t    \"Async done-%s res %x %8phC\\n\",\n\t    sp->name, res, sp->fcport->port_name);\n\n\tsp->fcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\n\tmemset(&ea, 0, sizeof(ea));\n\tea.rc = res;\n\tea.data[0] = lio->u.logio.data[0];\n\tea.data[1] = lio->u.logio.data[1];\n\tea.iop[0] = lio->u.logio.iop[0];\n\tea.iop[1] = lio->u.logio.iop[1];\n\tea.fcport = sp->fcport;\n\tea.sp = sp;\n\n\tqla24xx_handle_adisc_event(vha, &ea);\n\n\tsp->free(sp);\n}\n\nint\nqla2x00_async_adisc(struct scsi_qla_host *vha, fc_port_t *fcport,\n    uint16_t *data)\n{\n\tsrb_t *sp;\n\tstruct srb_iocb *lio;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tif (!vha->flags.online || (fcport->flags & FCF_ASYNC_SENT))\n\t\treturn rval;\n\n\tfcport->flags |= FCF_ASYNC_SENT;\n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->type = SRB_ADISC_CMD;\n\tsp->name = \"adisc\";\n\n\tlio = &sp->u.iocb_cmd;\n\tlio->timeout = qla2x00_async_iocb_timeout;\n\tsp->gen1 = fcport->rscn_gen;\n\tsp->gen2 = fcport->login_gen;\n\tqla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);\n\n\tsp->done = qla2x00_async_adisc_sp_done;\n\tif (data[1] & QLA_LOGIO_LOGIN_RETRIED)\n\t\tlio->u.logio.flags |= SRB_LOGIN_RETRIED;\n\n\tql_dbg(ql_dbg_disc, vha, 0x206f,\n\t    \"Async-adisc - hdl=%x loopid=%x portid=%06x %8phC.\\n\",\n\t    sp->handle, fcport->loop_id, fcport->d_id.b24, fcport->port_name);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done_free_sp;\n\n\treturn rval;\n\ndone_free_sp:\n\tsp->free(sp);\ndone:\n\tfcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\tqla2x00_post_async_adisc_work(vha, fcport, data);\n\treturn rval;\n}\n\nstatic bool qla2x00_is_reserved_id(scsi_qla_host_t *vha, uint16_t loop_id)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (IS_FWI2_CAPABLE(ha))\n\t\treturn loop_id > NPH_LAST_HANDLE;\n\n\treturn (loop_id > ha->max_loop_id && loop_id < SNS_FIRST_LOOP_ID) ||\n\t\tloop_id == MANAGEMENT_SERVER || loop_id == BROADCAST;\n}\n\n/**\n * qla2x00_find_new_loop_id - scan through our port list and find a new usable loop ID\n * @vha: adapter state pointer.\n * @dev: port structure pointer.\n *\n * Returns:\n *\tqla2x00 local function return status code.\n *\n * Context:\n *\tKernel context.\n */\nstatic int qla2x00_find_new_loop_id(scsi_qla_host_t *vha, fc_port_t *dev)\n{\n\tint\trval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags = 0;\n\n\trval = QLA_SUCCESS;\n\n\tspin_lock_irqsave(&ha->vport_slock, flags);\n\n\tdev->loop_id = find_first_zero_bit(ha->loop_id_map, LOOPID_MAP_SIZE);\n\tif (dev->loop_id >= LOOPID_MAP_SIZE ||\n\t    qla2x00_is_reserved_id(vha, dev->loop_id)) {\n\t\tdev->loop_id = FC_NO_LOOP_ID;\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else {\n\t\tset_bit(dev->loop_id, ha->loop_id_map);\n\t}\n\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\tif (rval == QLA_SUCCESS)\n\t\tql_dbg(ql_dbg_disc, dev->vha, 0x2086,\n\t\t       \"Assigning new loopid=%x, portid=%x.\\n\",\n\t\t       dev->loop_id, dev->d_id.b24);\n\telse\n\t\tql_log(ql_log_warn, dev->vha, 0x2087,\n\t\t       \"No loop_id's available, portid=%x.\\n\",\n\t\t       dev->d_id.b24);\n\n\treturn rval;\n}\n\nvoid qla2x00_clear_loop_id(fc_port_t *fcport)\n{\n\tstruct qla_hw_data *ha = fcport->vha->hw;\n\n\tif (fcport->loop_id == FC_NO_LOOP_ID ||\n\t    qla2x00_is_reserved_id(fcport->vha, fcport->loop_id))\n\t\treturn;\n\n\tclear_bit(fcport->loop_id, ha->loop_id_map);\n\tfcport->loop_id = FC_NO_LOOP_ID;\n}\n\nstatic void qla24xx_handle_gnl_done_event(scsi_qla_host_t *vha,\n\tstruct event_arg *ea)\n{\n\tfc_port_t *fcport, *conflict_fcport;\n\tstruct get_name_list_extended *e;\n\tu16 i, n, found = 0, loop_id;\n\tport_id_t id;\n\tu64 wwn;\n\tu16 data[2];\n\tu8 current_login_state, nvme_cls;\n\n\tfcport = ea->fcport;\n\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t    \"%s %8phC DS %d LS rc %d %d login %d|%d rscn %d|%d lid %d\\n\",\n\t    __func__, fcport->port_name, fcport->disc_state,\n\t    fcport->fw_login_state, ea->rc,\n\t    fcport->login_gen, fcport->last_login_gen,\n\t    fcport->rscn_gen, fcport->last_rscn_gen, vha->loop_id);\n\n\tif (fcport->disc_state == DSC_DELETE_PEND)\n\t\treturn;\n\n\tif (ea->rc) { /* rval */\n\t\tif (fcport->login_retry == 0) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20de,\n\t\t\t    \"GNL failed Port login retry %8phN, retry cnt=%d.\\n\",\n\t\t\t    fcport->port_name, fcport->login_retry);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (fcport->last_rscn_gen != fcport->rscn_gen) {\n\t\tqla_rscn_replay(fcport);\n\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\treturn;\n\t} else if (fcport->last_login_gen != fcport->login_gen) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x20e0,\n\t\t    \"%s %8phC login gen changed\\n\",\n\t\t    __func__, fcport->port_name);\n\t\treturn;\n\t}\n\n\tn = ea->data[0] / sizeof(struct get_name_list_extended);\n\n\tql_dbg(ql_dbg_disc, vha, 0x20e1,\n\t    \"%s %d %8phC n %d %02x%02x%02x lid %d \\n\",\n\t    __func__, __LINE__, fcport->port_name, n,\n\t    fcport->d_id.b.domain, fcport->d_id.b.area,\n\t    fcport->d_id.b.al_pa, fcport->loop_id);\n\n\tfor (i = 0; i < n; i++) {\n\t\te = &vha->gnl.l[i];\n\t\twwn = wwn_to_u64(e->port_name);\n\t\tid.b.domain = e->port_id[2];\n\t\tid.b.area = e->port_id[1];\n\t\tid.b.al_pa = e->port_id[0];\n\t\tid.b.rsvd_1 = 0;\n\n\t\tif (memcmp((u8 *)&wwn, fcport->port_name, WWN_SIZE))\n\t\t\tcontinue;\n\n\t\tif (IS_SW_RESV_ADDR(id))\n\t\t\tcontinue;\n\n\t\tfound = 1;\n\n\t\tloop_id = le16_to_cpu(e->nport_handle);\n\t\tloop_id = (loop_id & 0x7fff);\n\t\tnvme_cls = e->current_login_state >> 4;\n\t\tcurrent_login_state = e->current_login_state & 0xf;\n\n\t\tif (PRLI_PHASE(nvme_cls)) {\n\t\t\tcurrent_login_state = nvme_cls;\n\t\t\tfcport->fc4_type &= ~FS_FC4TYPE_FCP;\n\t\t\tfcport->fc4_type |= FS_FC4TYPE_NVME;\n\t\t} else if (PRLI_PHASE(current_login_state)) {\n\t\t\tfcport->fc4_type |= FS_FC4TYPE_FCP;\n\t\t\tfcport->fc4_type &= ~FS_FC4TYPE_NVME;\n\t\t}\n\n\t\tql_dbg(ql_dbg_disc, vha, 0x20e2,\n\t\t    \"%s found %8phC CLS [%x|%x] fc4_type %d ID[%06x|%06x] lid[%d|%d]\\n\",\n\t\t    __func__, fcport->port_name,\n\t\t    e->current_login_state, fcport->fw_login_state,\n\t\t    fcport->fc4_type, id.b24, fcport->d_id.b24,\n\t\t    loop_id, fcport->loop_id);\n\n\t\tswitch (fcport->disc_state) {\n\t\tcase DSC_DELETE_PEND:\n\t\tcase DSC_DELETED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((id.b24 != fcport->d_id.b24 &&\n\t\t\t    fcport->d_id.b24 &&\n\t\t\t    fcport->loop_id != FC_NO_LOOP_ID) ||\n\t\t\t    (fcport->loop_id != FC_NO_LOOP_ID &&\n\t\t\t\tfcport->loop_id != loop_id)) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20e3,\n\t\t\t\t    \"%s %d %8phC post del sess\\n\",\n\t\t\t\t    __func__, __LINE__, fcport->port_name);\n\t\t\t\tif (fcport->n2n_flag)\n\t\t\t\t\tfcport->d_id.b24 = 0;\n\t\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tfcport->loop_id = loop_id;\n\t\tif (fcport->n2n_flag)\n\t\t\tfcport->d_id.b24 = id.b24;\n\n\t\twwn = wwn_to_u64(fcport->port_name);\n\t\tqlt_find_sess_invalidate_other(vha, wwn,\n\t\t\tid, loop_id, &conflict_fcport);\n\n\t\tif (conflict_fcport) {\n\t\t\t/*\n\t\t\t * Another share fcport share the same loop_id &\n\t\t\t * nport id. Conflict fcport needs to finish\n\t\t\t * cleanup before this fcport can proceed to login.\n\t\t\t */\n\t\t\tconflict_fcport->conflict = fcport;\n\t\t\tfcport->login_pause = 1;\n\t\t}\n\n\t\tswitch (vha->hw->current_topology) {\n\t\tdefault:\n\t\t\tswitch (current_login_state) {\n\t\t\tcase DSC_LS_PRLI_COMP:\n\t\t\t\tql_dbg(ql_dbg_disc + ql_dbg_verbose,\n\t\t\t\t    vha, 0x20e4, \"%s %d %8phC post gpdb\\n\",\n\t\t\t\t    __func__, __LINE__, fcport->port_name);\n\n\t\t\t\tif ((e->prli_svc_param_word_3[0] & BIT_4) == 0)\n\t\t\t\t\tfcport->port_type = FCT_INITIATOR;\n\t\t\t\telse\n\t\t\t\t\tfcport->port_type = FCT_TARGET;\n\t\t\t\tdata[0] = data[1] = 0;\n\t\t\t\tqla2x00_post_async_adisc_work(vha, fcport,\n\t\t\t\t    data);\n\t\t\t\tbreak;\n\t\t\tcase DSC_LS_PORT_UNAVAIL:\n\t\t\tdefault:\n\t\t\t\tif (fcport->loop_id == FC_NO_LOOP_ID) {\n\t\t\t\t\tqla2x00_find_new_loop_id(vha, fcport);\n\t\t\t\t\tfcport->fw_login_state =\n\t\t\t\t\t    DSC_LS_PORT_UNAVAIL;\n\t\t\t\t}\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20e5,\n\t\t\t\t    \"%s %d %8phC\\n\", __func__, __LINE__,\n\t\t\t\t    fcport->port_name);\n\t\t\t\tqla24xx_fcport_handle_login(vha, fcport);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ISP_CFG_N:\n\t\t\tfcport->fw_login_state = current_login_state;\n\t\t\tfcport->d_id = id;\n\t\t\tswitch (current_login_state) {\n\t\t\tcase DSC_LS_PRLI_PEND:\n\t\t\t\t/*\n\t\t\t\t * In the middle of PRLI. Let it finish.\n\t\t\t\t * Allow relogin code to recheck state again\n\t\t\t\t * with GNL. Push disc_state back to DELETED\n\t\t\t\t * so GNL can go out again\n\t\t\t\t */\n\t\t\t\tqla2x00_set_fcport_disc_state(fcport,\n\t\t\t\t    DSC_DELETED);\n\t\t\t\tbreak;\n\t\t\tcase DSC_LS_PRLI_COMP:\n\t\t\t\tif ((e->prli_svc_param_word_3[0] & BIT_4) == 0)\n\t\t\t\t\tfcport->port_type = FCT_INITIATOR;\n\t\t\t\telse\n\t\t\t\t\tfcport->port_type = FCT_TARGET;\n\n\t\t\t\tdata[0] = data[1] = 0;\n\t\t\t\tqla2x00_post_async_adisc_work(vha, fcport,\n\t\t\t\t    data);\n\t\t\t\tbreak;\n\t\t\tcase DSC_LS_PLOGI_COMP:\n\t\t\t\tif (fcport_is_bigger(fcport)) {\n\t\t\t\t\t/* local adapter is smaller */\n\t\t\t\t\tif (fcport->loop_id != FC_NO_LOOP_ID)\n\t\t\t\t\t\tqla2x00_clear_loop_id(fcport);\n\n\t\t\t\t\tfcport->loop_id = loop_id;\n\t\t\t\t\tqla24xx_fcport_handle_login(vha,\n\t\t\t\t\t    fcport);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tif (fcport_is_smaller(fcport)) {\n\t\t\t\t\t/* local adapter is bigger */\n\t\t\t\t\tif (fcport->loop_id != FC_NO_LOOP_ID)\n\t\t\t\t\t\tqla2x00_clear_loop_id(fcport);\n\n\t\t\t\t\tfcport->loop_id = loop_id;\n\t\t\t\t\tqla24xx_fcport_handle_login(vha,\n\t\t\t\t\t    fcport);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t} /* switch (ha->current_topology) */\n\t}\n\n\tif (!found) {\n\t\tswitch (vha->hw->current_topology) {\n\t\tcase ISP_CFG_F:\n\t\tcase ISP_CFG_FL:\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\te = &vha->gnl.l[i];\n\t\t\t\tid.b.domain = e->port_id[0];\n\t\t\t\tid.b.area = e->port_id[1];\n\t\t\t\tid.b.al_pa = e->port_id[2];\n\t\t\t\tid.b.rsvd_1 = 0;\n\t\t\t\tloop_id = le16_to_cpu(e->nport_handle);\n\n\t\t\t\tif (fcport->d_id.b24 == id.b24) {\n\t\t\t\t\tconflict_fcport =\n\t\t\t\t\t    qla2x00_find_fcport_by_wwpn(vha,\n\t\t\t\t\t\te->port_name, 0);\n\t\t\t\t\tif (conflict_fcport) {\n\t\t\t\t\t\tql_dbg(ql_dbg_disc + ql_dbg_verbose,\n\t\t\t\t\t\t    vha, 0x20e5,\n\t\t\t\t\t\t    \"%s %d %8phC post del sess\\n\",\n\t\t\t\t\t\t    __func__, __LINE__,\n\t\t\t\t\t\t    conflict_fcport->port_name);\n\t\t\t\t\t\tqlt_schedule_sess_for_deletion\n\t\t\t\t\t\t\t(conflict_fcport);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * FW already picked this loop id for\n\t\t\t\t * another fcport\n\t\t\t\t */\n\t\t\t\tif (fcport->loop_id == loop_id)\n\t\t\t\t\tfcport->loop_id = FC_NO_LOOP_ID;\n\t\t\t}\n\t\t\tqla24xx_fcport_handle_login(vha, fcport);\n\t\t\tbreak;\n\t\tcase ISP_CFG_N:\n\t\t\tqla2x00_set_fcport_disc_state(fcport, DSC_DELETED);\n\t\t\tif (time_after_eq(jiffies, fcport->dm_login_expire)) {\n\t\t\t\tif (fcport->n2n_link_reset_cnt < 2) {\n\t\t\t\t\tfcport->n2n_link_reset_cnt++;\n\t\t\t\t\t/*\n\t\t\t\t\t * remote port is not sending PLOGI.\n\t\t\t\t\t * Reset link to kick start his state\n\t\t\t\t\t * machine\n\t\t\t\t\t */\n\t\t\t\t\tset_bit(N2N_LINK_RESET,\n\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t} else {\n\t\t\t\t\tif (fcport->n2n_chip_reset < 1) {\n\t\t\t\t\t\tql_log(ql_log_info, vha, 0x705d,\n\t\t\t\t\t\t    \"Chip reset to bring laser down\");\n\t\t\t\t\t\tset_bit(ISP_ABORT_NEEDED,\n\t\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t\t\tfcport->n2n_chip_reset++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tql_log(ql_log_info, vha, 0x705d,\n\t\t\t\t\t\t    \"Remote port %8ph is not coming back\\n\",\n\t\t\t\t\t\t    fcport->port_name);\n\t\t\t\t\t\tfcport->scan_state = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * report port suppose to do PLOGI. Give him\n\t\t\t\t * more time. FW will catch it.\n\t\t\t\t */\n\t\t\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n} /* gnl_event */\n\nstatic void qla24xx_async_gnl_sp_done(srb_t *sp, int res)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tunsigned long flags;\n\tstruct fc_port *fcport = NULL, *tf;\n\tu16 i, n = 0, loop_id;\n\tstruct event_arg ea;\n\tstruct get_name_list_extended *e;\n\tu64 wwn;\n\tstruct list_head h;\n\tbool found = false;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20e7,\n\t    \"Async done-%s res %x mb[1]=%x mb[2]=%x \\n\",\n\t    sp->name, res, sp->u.iocb_cmd.u.mbx.in_mb[1],\n\t    sp->u.iocb_cmd.u.mbx.in_mb[2]);\n\n\tif (res == QLA_FUNCTION_TIMEOUT)\n\t\treturn;\n\n\tsp->fcport->flags &= ~(FCF_ASYNC_SENT|FCF_ASYNC_ACTIVE);\n\tmemset(&ea, 0, sizeof(ea));\n\tea.sp = sp;\n\tea.rc = res;\n\n\tif (sp->u.iocb_cmd.u.mbx.in_mb[1] >=\n\t    sizeof(struct get_name_list_extended)) {\n\t\tn = sp->u.iocb_cmd.u.mbx.in_mb[1] /\n\t\t    sizeof(struct get_name_list_extended);\n\t\tea.data[0] = sp->u.iocb_cmd.u.mbx.in_mb[1]; /* amnt xfered */\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\te = &vha->gnl.l[i];\n\t\tloop_id = le16_to_cpu(e->nport_handle);\n\t\t/* mask out reserve bit */\n\t\tloop_id = (loop_id & 0x7fff);\n\t\tset_bit(loop_id, vha->hw->loop_id_map);\n\t\twwn = wwn_to_u64(e->port_name);\n\n\t\tql_dbg(ql_dbg_disc, vha, 0x20e8,\n\t\t    \"%s %8phC %02x:%02x:%02x CLS %x/%x lid %x \\n\",\n\t\t    __func__, &wwn, e->port_id[2], e->port_id[1],\n\t\t    e->port_id[0], e->current_login_state, e->last_login_state,\n\t\t    (loop_id & 0x7fff));\n\t}\n\n\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\n\tINIT_LIST_HEAD(&h);\n\tfcport = tf = NULL;\n\tif (!list_empty(&vha->gnl.fcports))\n\t\tlist_splice_init(&vha->gnl.fcports, &h);\n\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\tlist_for_each_entry_safe(fcport, tf, &h, gnl_entry) {\n\t\tlist_del_init(&fcport->gnl_entry);\n\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\t\tfcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\t\tea.fcport = fcport;\n\n\t\tqla24xx_handle_gnl_done_event(vha, &ea);\n\t}\n\n\t/* create new fcport if fw has knowledge of new sessions */\n\tfor (i = 0; i < n; i++) {\n\t\tport_id_t id;\n\t\tu64 wwnn;\n\n\t\te = &vha->gnl.l[i];\n\t\twwn = wwn_to_u64(e->port_name);\n\n\t\tfound = false;\n\t\tlist_for_each_entry_safe(fcport, tf, &vha->vp_fcports, list) {\n\t\t\tif (!memcmp((u8 *)&wwn, fcport->port_name,\n\t\t\t    WWN_SIZE)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tid.b.domain = e->port_id[2];\n\t\tid.b.area = e->port_id[1];\n\t\tid.b.al_pa = e->port_id[0];\n\t\tid.b.rsvd_1 = 0;\n\n\t\tif (!found && wwn && !IS_SW_RESV_ADDR(id)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2065,\n\t\t\t    \"%s %d %8phC %06x post new sess\\n\",\n\t\t\t    __func__, __LINE__, (u8 *)&wwn, id.b24);\n\t\t\twwnn = wwn_to_u64(e->node_name);\n\t\t\tqla24xx_post_newsess_work(vha, &id, (u8 *)&wwn,\n\t\t\t    (u8 *)&wwnn, NULL, 0);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\tvha->gnl.sent = 0;\n\tif (!list_empty(&vha->gnl.fcports)) {\n\t\t/* retrigger gnl */\n\t\tlist_for_each_entry_safe(fcport, tf, &vha->gnl.fcports,\n\t\t    gnl_entry) {\n\t\t\tlist_del_init(&fcport->gnl_entry);\n\t\t\tfcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\t\t\tif (qla24xx_post_gnl_work(vha, fcport) == QLA_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\tsp->free(sp);\n}\n\nint qla24xx_async_gnl(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tsrb_t *sp;\n\tstruct srb_iocb *mbx;\n\tint rval = QLA_FUNCTION_FAILED;\n\tunsigned long flags;\n\tu16 *mb;\n\n\tif (!vha->flags.online || (fcport->flags & FCF_ASYNC_SENT))\n\t\treturn rval;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20d9,\n\t    \"Async-gnlist WWPN %8phC \\n\", fcport->port_name);\n\n\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\tfcport->flags |= FCF_ASYNC_SENT;\n\tqla2x00_set_fcport_disc_state(fcport, DSC_GNL);\n\tfcport->last_rscn_gen = fcport->rscn_gen;\n\tfcport->last_login_gen = fcport->login_gen;\n\n\tlist_add_tail(&fcport->gnl_entry, &vha->gnl.fcports);\n\tif (vha->gnl.sent) {\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\t\treturn QLA_SUCCESS;\n\t}\n\tvha->gnl.sent = 1;\n\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->type = SRB_MB_IOCB;\n\tsp->name = \"gnlist\";\n\tsp->gen1 = fcport->rscn_gen;\n\tsp->gen2 = fcport->login_gen;\n\n\tmbx = &sp->u.iocb_cmd;\n\tmbx->timeout = qla2x00_async_iocb_timeout;\n\tqla2x00_init_timer(sp, qla2x00_get_async_timeout(vha)+2);\n\n\tmb = sp->u.iocb_cmd.u.mbx.out_mb;\n\tmb[0] = MBC_PORT_NODE_NAME_LIST;\n\tmb[1] = BIT_2 | BIT_3;\n\tmb[2] = MSW(vha->gnl.ldma);\n\tmb[3] = LSW(vha->gnl.ldma);\n\tmb[6] = MSW(MSD(vha->gnl.ldma));\n\tmb[7] = LSW(MSD(vha->gnl.ldma));\n\tmb[8] = vha->gnl.size;\n\tmb[9] = vha->vp_idx;\n\n\tsp->done = qla24xx_async_gnl_sp_done;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20da,\n\t    \"Async-%s - OUT WWPN %8phC hndl %x\\n\",\n\t    sp->name, fcport->port_name, sp->handle);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done_free_sp;\n\n\treturn rval;\n\ndone_free_sp:\n\tsp->free(sp);\ndone:\n\tfcport->flags &= ~(FCF_ASYNC_ACTIVE | FCF_ASYNC_SENT);\n\treturn rval;\n}\n\nint qla24xx_post_gnl_work(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_GNL);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.fcport.fcport = fcport;\n\tfcport->flags |= FCF_ASYNC_ACTIVE;\n\treturn qla2x00_post_work(vha, e);\n}\n\nstatic void qla24xx_async_gpdb_sp_done(srb_t *sp, int res)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tfc_port_t *fcport = sp->fcport;\n\tu16 *mb = sp->u.iocb_cmd.u.mbx.in_mb;\n\tstruct event_arg ea;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20db,\n\t    \"Async done-%s res %x, WWPN %8phC mb[1]=%x mb[2]=%x \\n\",\n\t    sp->name, res, fcport->port_name, mb[1], mb[2]);\n\n\tfcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\n\tif (res == QLA_FUNCTION_TIMEOUT)\n\t\tgoto done;\n\n\tmemset(&ea, 0, sizeof(ea));\n\tea.fcport = fcport;\n\tea.sp = sp;\n\n\tqla24xx_handle_gpdb_event(vha, &ea);\n\ndone:\n\tdma_pool_free(ha->s_dma_pool, sp->u.iocb_cmd.u.mbx.in,\n\t\tsp->u.iocb_cmd.u.mbx.in_dma);\n\n\tsp->free(sp);\n}\n\nstatic int qla24xx_post_prli_work(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_PRLI);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.fcport.fcport = fcport;\n\n\treturn qla2x00_post_work(vha, e);\n}\n\nstatic void qla2x00_async_prli_sp_done(srb_t *sp, int res)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\tstruct event_arg ea;\n\n\tql_dbg(ql_dbg_disc, vha, 0x2129,\n\t    \"%s %8phC res %d \\n\", __func__,\n\t    sp->fcport->port_name, res);\n\n\tsp->fcport->flags &= ~FCF_ASYNC_SENT;\n\n\tif (!test_bit(UNLOADING, &vha->dpc_flags)) {\n\t\tmemset(&ea, 0, sizeof(ea));\n\t\tea.fcport = sp->fcport;\n\t\tea.data[0] = lio->u.logio.data[0];\n\t\tea.data[1] = lio->u.logio.data[1];\n\t\tea.iop[0] = lio->u.logio.iop[0];\n\t\tea.iop[1] = lio->u.logio.iop[1];\n\t\tea.sp = sp;\n\n\t\tqla24xx_handle_prli_done_event(vha, &ea);\n\t}\n\n\tsp->free(sp);\n}\n\nint\nqla24xx_async_prli(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tsrb_t *sp;\n\tstruct srb_iocb *lio;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tif (!vha->flags.online) {\n\t\tql_dbg(ql_dbg_disc, vha, 0xffff, \"%s %d %8phC exit\\n\",\n\t\t    __func__, __LINE__, fcport->port_name);\n\t\treturn rval;\n\t}\n\n\tif ((fcport->fw_login_state == DSC_LS_PLOGI_PEND ||\n\t    fcport->fw_login_state == DSC_LS_PRLI_PEND) &&\n\t    qla_dual_mode_enabled(vha)) {\n\t\tql_dbg(ql_dbg_disc, vha, 0xffff, \"%s %d %8phC exit\\n\",\n\t\t    __func__, __LINE__, fcport->port_name);\n\t\treturn rval;\n\t}\n\n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\treturn rval;\n\n\tfcport->flags |= FCF_ASYNC_SENT;\n\tfcport->logout_completed = 0;\n\n\tsp->type = SRB_PRLI_CMD;\n\tsp->name = \"prli\";\n\n\tlio = &sp->u.iocb_cmd;\n\tlio->timeout = qla2x00_async_iocb_timeout;\n\tqla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);\n\n\tsp->done = qla2x00_async_prli_sp_done;\n\tlio->u.logio.flags = 0;\n\n\tif (NVME_TARGET(vha->hw, fcport))\n\t\tlio->u.logio.flags |= SRB_LOGIN_NVME_PRLI;\n\n\tql_dbg(ql_dbg_disc, vha, 0x211b,\n\t    \"Async-prli - %8phC hdl=%x, loopid=%x portid=%06x retries=%d fc4type %x priority %x %s.\\n\",\n\t    fcport->port_name, sp->handle, fcport->loop_id, fcport->d_id.b24,\n\t    fcport->login_retry, fcport->fc4_type, vha->hw->fc4_type_priority,\n\t    NVME_TARGET(vha->hw, fcport) ? \"nvme\" : \"fcp\");\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tfcport->flags |= FCF_LOGIN_NEEDED;\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\tgoto done_free_sp;\n\t}\n\n\treturn rval;\n\ndone_free_sp:\n\tsp->free(sp);\n\tfcport->flags &= ~FCF_ASYNC_SENT;\n\treturn rval;\n}\n\nint qla24xx_post_gpdb_work(struct scsi_qla_host *vha, fc_port_t *fcport, u8 opt)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_GPDB);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.fcport.fcport = fcport;\n\te->u.fcport.opt = opt;\n\tfcport->flags |= FCF_ASYNC_ACTIVE;\n\treturn qla2x00_post_work(vha, e);\n}\n\nint qla24xx_async_gpdb(struct scsi_qla_host *vha, fc_port_t *fcport, u8 opt)\n{\n\tsrb_t *sp;\n\tstruct srb_iocb *mbx;\n\tint rval = QLA_FUNCTION_FAILED;\n\tu16 *mb;\n\tdma_addr_t pd_dma;\n\tstruct port_database_24xx *pd;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!vha->flags.online || (fcport->flags & FCF_ASYNC_SENT) ||\n\t    fcport->loop_id == FC_NO_LOOP_ID) {\n\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t    \"%s: %8phC - not sending command.\\n\",\n\t\t    __func__, fcport->port_name);\n\t\treturn rval;\n\t}\n\n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tqla2x00_set_fcport_disc_state(fcport, DSC_GPDB);\n\n\tfcport->flags |= FCF_ASYNC_SENT;\n\tsp->type = SRB_MB_IOCB;\n\tsp->name = \"gpdb\";\n\tsp->gen1 = fcport->rscn_gen;\n\tsp->gen2 = fcport->login_gen;\n\n\tmbx = &sp->u.iocb_cmd;\n\tmbx->timeout = qla2x00_async_iocb_timeout;\n\tqla2x00_init_timer(sp, qla2x00_get_async_timeout(vha) + 2);\n\n\tpd = dma_pool_zalloc(ha->s_dma_pool, GFP_KERNEL, &pd_dma);\n\tif (pd == NULL) {\n\t\tql_log(ql_log_warn, vha, 0xd043,\n\t\t    \"Failed to allocate port database structure.\\n\");\n\t\tgoto done_free_sp;\n\t}\n\n\tmb = sp->u.iocb_cmd.u.mbx.out_mb;\n\tmb[0] = MBC_GET_PORT_DATABASE;\n\tmb[1] = fcport->loop_id;\n\tmb[2] = MSW(pd_dma);\n\tmb[3] = LSW(pd_dma);\n\tmb[6] = MSW(MSD(pd_dma));\n\tmb[7] = LSW(MSD(pd_dma));\n\tmb[9] = vha->vp_idx;\n\tmb[10] = opt;\n\n\tmbx->u.mbx.in = pd;\n\tmbx->u.mbx.in_dma = pd_dma;\n\n\tsp->done = qla24xx_async_gpdb_sp_done;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20dc,\n\t    \"Async-%s %8phC hndl %x opt %x\\n\",\n\t    sp->name, fcport->port_name, sp->handle, opt);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done_free_sp;\n\treturn rval;\n\ndone_free_sp:\n\tif (pd)\n\t\tdma_pool_free(ha->s_dma_pool, pd, pd_dma);\n\n\tsp->free(sp);\n\tfcport->flags &= ~FCF_ASYNC_SENT;\ndone:\n\tfcport->flags &= ~FCF_ASYNC_ACTIVE;\n\tqla24xx_post_gpdb_work(vha, fcport, opt);\n\treturn rval;\n}\n\nstatic\nvoid __qla24xx_handle_gpdb_event(scsi_qla_host_t *vha, struct event_arg *ea)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\tea->fcport->login_gen++;\n\tea->fcport->deleted = 0;\n\tea->fcport->logout_on_delete = 1;\n\n\tif (!ea->fcport->login_succ && !IS_SW_RESV_ADDR(ea->fcport->d_id)) {\n\t\tvha->fcport_count++;\n\t\tea->fcport->login_succ = 1;\n\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\t\tqla24xx_sched_upd_fcport(ea->fcport);\n\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\t} else if (ea->fcport->login_succ) {\n\t\t/*\n\t\t * We have an existing session. A late RSCN delivery\n\t\t * must have triggered the session to be re-validate.\n\t\t * Session is still valid.\n\t\t */\n\t\tql_dbg(ql_dbg_disc, vha, 0x20d6,\n\t\t    \"%s %d %8phC session revalidate success\\n\",\n\t\t    __func__, __LINE__, ea->fcport->port_name);\n\t\tqla2x00_set_fcport_disc_state(ea->fcport, DSC_LOGIN_COMPLETE);\n\t}\n\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n}\n\nstatic\nvoid qla24xx_handle_gpdb_event(scsi_qla_host_t *vha, struct event_arg *ea)\n{\n\tfc_port_t *fcport = ea->fcport;\n\tstruct port_database_24xx *pd;\n\tstruct srb *sp = ea->sp;\n\tuint8_t\tls;\n\n\tpd = (struct port_database_24xx *)sp->u.iocb_cmd.u.mbx.in;\n\n\tfcport->flags &= ~FCF_ASYNC_SENT;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20d2,\n\t    \"%s %8phC DS %d LS %d fc4_type %x rc %d\\n\", __func__,\n\t    fcport->port_name, fcport->disc_state, pd->current_login_state,\n\t    fcport->fc4_type, ea->rc);\n\n\tif (fcport->disc_state == DSC_DELETE_PEND)\n\t\treturn;\n\n\tif (NVME_TARGET(vha->hw, fcport))\n\t\tls = pd->current_login_state >> 4;\n\telse\n\t\tls = pd->current_login_state & 0xf;\n\n\tif (ea->sp->gen2 != fcport->login_gen) {\n\t\t/* target side must have changed it. */\n\n\t\tql_dbg(ql_dbg_disc, vha, 0x20d3,\n\t\t    \"%s %8phC generation changed\\n\",\n\t\t    __func__, fcport->port_name);\n\t\treturn;\n\t} else if (ea->sp->gen1 != fcport->rscn_gen) {\n\t\tqla_rscn_replay(fcport);\n\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\treturn;\n\t}\n\n\tswitch (ls) {\n\tcase PDS_PRLI_COMPLETE:\n\t\t__qla24xx_parse_gpdb(vha, fcport, pd);\n\t\tbreak;\n\tcase PDS_PLOGI_PENDING:\n\tcase PDS_PLOGI_COMPLETE:\n\tcase PDS_PRLI_PENDING:\n\tcase PDS_PRLI2_PENDING:\n\t\t/* Set discovery state back to GNL to Relogin attempt */\n\t\tif (qla_dual_mode_enabled(vha) ||\n\t\t    qla_ini_mode_enabled(vha)) {\n\t\t\tqla2x00_set_fcport_disc_state(fcport, DSC_GNL);\n\t\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\t}\n\t\treturn;\n\tcase PDS_LOGO_PENDING:\n\tcase PDS_PORT_UNAVAILABLE:\n\tdefault:\n\t\tql_dbg(ql_dbg_disc, vha, 0x20d5, \"%s %d %8phC post del sess\\n\",\n\t\t    __func__, __LINE__, fcport->port_name);\n\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\treturn;\n\t}\n\t__qla24xx_handle_gpdb_event(vha, ea);\n} /* gpdb event */\n\nstatic void qla_chk_n2n_b4_login(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tu8 login = 0;\n\tint rc;\n\n\tif (qla_tgt_mode_enabled(vha))\n\t\treturn;\n\n\tif (qla_dual_mode_enabled(vha)) {\n\t\tif (N2N_TOPO(vha->hw)) {\n\t\t\tu64 mywwn, wwn;\n\n\t\t\tmywwn = wwn_to_u64(vha->port_name);\n\t\t\twwn = wwn_to_u64(fcport->port_name);\n\t\t\tif (mywwn > wwn)\n\t\t\t\tlogin = 1;\n\t\t\telse if ((fcport->fw_login_state == DSC_LS_PLOGI_COMP)\n\t\t\t    && time_after_eq(jiffies,\n\t\t\t\t    fcport->plogi_nack_done_deadline))\n\t\t\t\tlogin = 1;\n\t\t} else {\n\t\t\tlogin = 1;\n\t\t}\n\t} else {\n\t\t/* initiator mode */\n\t\tlogin = 1;\n\t}\n\n\tif (login && fcport->login_retry) {\n\t\tfcport->login_retry--;\n\t\tif (fcport->loop_id == FC_NO_LOOP_ID) {\n\t\t\tfcport->fw_login_state = DSC_LS_PORT_UNAVAIL;\n\t\t\trc = qla2x00_find_new_loop_id(vha, fcport);\n\t\t\tif (rc) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20e6,\n\t\t\t\t    \"%s %d %8phC post del sess - out of loopid\\n\",\n\t\t\t\t    __func__, __LINE__, fcport->port_name);\n\t\t\t\tfcport->scan_state = 0;\n\t\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tql_dbg(ql_dbg_disc, vha, 0x20bf,\n\t\t    \"%s %d %8phC post login\\n\",\n\t\t    __func__, __LINE__, fcport->port_name);\n\t\tqla2x00_post_async_login_work(vha, fcport, NULL);\n\t}\n}\n\nint qla24xx_fcport_handle_login(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tu16 data[2];\n\tu64 wwn;\n\tu16 sec;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20d8,\n\t    \"%s %8phC DS %d LS %d P %d fl %x confl %p rscn %d|%d login %d lid %d scan %d\\n\",\n\t    __func__, fcport->port_name, fcport->disc_state,\n\t    fcport->fw_login_state, fcport->login_pause, fcport->flags,\n\t    fcport->conflict, fcport->last_rscn_gen, fcport->rscn_gen,\n\t    fcport->login_gen, fcport->loop_id, fcport->scan_state);\n\n\tif (fcport->scan_state != QLA_FCPORT_FOUND)\n\t\treturn 0;\n\n\tif ((fcport->loop_id != FC_NO_LOOP_ID) &&\n\t    qla_dual_mode_enabled(vha) &&\n\t    ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||\n\t     (fcport->fw_login_state == DSC_LS_PRLI_PEND)))\n\t\treturn 0;\n\n\tif (fcport->fw_login_state == DSC_LS_PLOGI_COMP &&\n\t    !N2N_TOPO(vha->hw)) {\n\t\tif (time_before_eq(jiffies, fcport->plogi_nack_done_deadline)) {\n\t\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Target won't initiate port login if fabric is present */\n\tif (vha->host->active_mode == MODE_TARGET && !N2N_TOPO(vha->hw))\n\t\treturn 0;\n\n\tif (fcport->flags & FCF_ASYNC_SENT) {\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\treturn 0;\n\t}\n\n\tswitch (fcport->disc_state) {\n\tcase DSC_DELETED:\n\t\twwn = wwn_to_u64(fcport->node_name);\n\t\tswitch (vha->hw->current_topology) {\n\t\tcase ISP_CFG_N:\n\t\t\tif (fcport_is_smaller(fcport)) {\n\t\t\t\t/* this adapter is bigger */\n\t\t\t\tif (fcport->login_retry) {\n\t\t\t\t\tif (fcport->loop_id == FC_NO_LOOP_ID) {\n\t\t\t\t\t\tqla2x00_find_new_loop_id(vha,\n\t\t\t\t\t\t    fcport);\n\t\t\t\t\t\tfcport->fw_login_state =\n\t\t\t\t\t\t    DSC_LS_PORT_UNAVAIL;\n\t\t\t\t\t}\n\t\t\t\t\tfcport->login_retry--;\n\t\t\t\t\tqla_post_els_plogi_work(vha, fcport);\n\t\t\t\t} else {\n\t\t\t\t\tql_log(ql_log_info, vha, 0x705d,\n\t\t\t\t\t    \"Unable to reach remote port %8phC\",\n\t\t\t\t\t    fcport->port_name);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tqla24xx_post_gnl_work(vha, fcport);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (wwn == 0)    {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t\t\t    \"%s %d %8phC post GNNID\\n\",\n\t\t\t\t    __func__, __LINE__, fcport->port_name);\n\t\t\t\tqla24xx_post_gnnid_work(vha, fcport);\n\t\t\t} else if (fcport->loop_id == FC_NO_LOOP_ID) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20bd,\n\t\t\t\t    \"%s %d %8phC post gnl\\n\",\n\t\t\t\t    __func__, __LINE__, fcport->port_name);\n\t\t\t\tqla24xx_post_gnl_work(vha, fcport);\n\t\t\t} else {\n\t\t\t\tqla_chk_n2n_b4_login(vha, fcport);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase DSC_GNL:\n\t\tswitch (vha->hw->current_topology) {\n\t\tcase ISP_CFG_N:\n\t\t\tif ((fcport->current_login_state & 0xf) == 0x6) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x2118,\n\t\t\t\t    \"%s %d %8phC post GPDB work\\n\",\n\t\t\t\t    __func__, __LINE__, fcport->port_name);\n\t\t\t\tfcport->chip_reset =\n\t\t\t\t\tvha->hw->base_qpair->chip_reset;\n\t\t\t\tqla24xx_post_gpdb_work(vha, fcport, 0);\n\t\t\t}  else {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x2118,\n\t\t\t\t    \"%s %d %8phC post %s PRLI\\n\",\n\t\t\t\t    __func__, __LINE__, fcport->port_name,\n\t\t\t\t    NVME_TARGET(vha->hw, fcport) ? \"NVME\" :\n\t\t\t\t    \"FC\");\n\t\t\t\tqla24xx_post_prli_work(vha, fcport);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (fcport->login_pause) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20d8,\n\t\t\t\t    \"%s %d %8phC exit\\n\",\n\t\t\t\t    __func__, __LINE__,\n\t\t\t\t    fcport->port_name);\n\t\t\t\tfcport->last_rscn_gen = fcport->rscn_gen;\n\t\t\t\tfcport->last_login_gen = fcport->login_gen;\n\t\t\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tqla_chk_n2n_b4_login(vha, fcport);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase DSC_LOGIN_FAILED:\n\t\tif (N2N_TOPO(vha->hw))\n\t\t\tqla_chk_n2n_b4_login(vha, fcport);\n\t\telse\n\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\tbreak;\n\n\tcase DSC_LOGIN_COMPLETE:\n\t\t/* recheck login state */\n\t\tdata[0] = data[1] = 0;\n\t\tqla2x00_post_async_adisc_work(vha, fcport, data);\n\t\tbreak;\n\n\tcase DSC_LOGIN_PEND:\n\t\tif (fcport->fw_login_state == DSC_LS_PLOGI_COMP)\n\t\t\tqla24xx_post_prli_work(vha, fcport);\n\t\tbreak;\n\n\tcase DSC_UPD_FCPORT:\n\t\tsec =  jiffies_to_msecs(jiffies -\n\t\t    fcport->jiffies_at_registration)/1000;\n\t\tif (fcport->sec_since_registration < sec && sec &&\n\t\t    !(sec % 60)) {\n\t\t\tfcport->sec_since_registration = sec;\n\t\t\tql_dbg(ql_dbg_disc, fcport->vha, 0xffff,\n\t\t\t    \"%s %8phC - Slow Rport registration(%d Sec)\\n\",\n\t\t\t    __func__, fcport->port_name, sec);\n\t\t}\n\n\t\tif (fcport->next_disc_state != DSC_DELETE_PEND)\n\t\t\tfcport->next_disc_state = DSC_ADISC;\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint qla24xx_post_newsess_work(struct scsi_qla_host *vha, port_id_t *id,\n    u8 *port_name, u8 *node_name, void *pla, u8 fc4_type)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_NEW_SESS);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.new_sess.id = *id;\n\te->u.new_sess.pla = pla;\n\te->u.new_sess.fc4_type = fc4_type;\n\tmemcpy(e->u.new_sess.port_name, port_name, WWN_SIZE);\n\tif (node_name)\n\t\tmemcpy(e->u.new_sess.node_name, node_name, WWN_SIZE);\n\n\treturn qla2x00_post_work(vha, e);\n}\n\nvoid qla2x00_handle_rscn(scsi_qla_host_t *vha, struct event_arg *ea)\n{\n\tfc_port_t *fcport;\n\tunsigned long flags;\n\n\tfcport = qla2x00_find_fcport_by_nportid(vha, &ea->id, 1);\n\tif (fcport) {\n\t\tfcport->scan_needed = 1;\n\t\tfcport->rscn_gen++;\n\t}\n\n\tspin_lock_irqsave(&vha->work_lock, flags);\n\tif (vha->scan.scan_flags == 0) {\n\t\tql_dbg(ql_dbg_disc, vha, 0xffff, \"%s: schedule\\n\", __func__);\n\t\tvha->scan.scan_flags |= SF_QUEUED;\n\t\tschedule_delayed_work(&vha->scan.scan_work, 5);\n\t}\n\tspin_unlock_irqrestore(&vha->work_lock, flags);\n}\n\nvoid qla24xx_handle_relogin_event(scsi_qla_host_t *vha,\n\tstruct event_arg *ea)\n{\n\tfc_port_t *fcport = ea->fcport;\n\n\tif (test_bit(UNLOADING, &vha->dpc_flags))\n\t\treturn;\n\n\tql_dbg(ql_dbg_disc, vha, 0x2102,\n\t    \"%s %8phC DS %d LS %d P %d del %d cnfl %p rscn %d|%d login %d|%d fl %x\\n\",\n\t    __func__, fcport->port_name, fcport->disc_state,\n\t    fcport->fw_login_state, fcport->login_pause,\n\t    fcport->deleted, fcport->conflict,\n\t    fcport->last_rscn_gen, fcport->rscn_gen,\n\t    fcport->last_login_gen, fcport->login_gen,\n\t    fcport->flags);\n\n\tif (fcport->last_rscn_gen != fcport->rscn_gen) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x20e9, \"%s %d %8phC post gnl\\n\",\n\t\t    __func__, __LINE__, fcport->port_name);\n\t\tqla24xx_post_gnl_work(vha, fcport);\n\t\treturn;\n\t}\n\n\tqla24xx_fcport_handle_login(vha, fcport);\n}\n\nvoid qla_handle_els_plogi_done(scsi_qla_host_t *vha,\n\t\t\t\t      struct event_arg *ea)\n{\n\t/* for pure Target Mode, PRLI will not be initiated */\n\tif (vha->host->active_mode == MODE_TARGET)\n\t\treturn;\n\n\tql_dbg(ql_dbg_disc, vha, 0x2118,\n\t    \"%s %d %8phC post PRLI\\n\",\n\t    __func__, __LINE__, ea->fcport->port_name);\n\tqla24xx_post_prli_work(vha, ea->fcport);\n}\n\n/*\n * RSCN(s) came in for this fcport, but the RSCN(s) was not able\n * to be consumed by the fcport\n */\nvoid qla_rscn_replay(fc_port_t *fcport)\n{\n\tstruct event_arg ea;\n\n\tswitch (fcport->disc_state) {\n\tcase DSC_DELETE_PEND:\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (fcport->scan_needed) {\n\t\tmemset(&ea, 0, sizeof(ea));\n\t\tea.id = fcport->d_id;\n\t\tea.id.b.rsvd_1 = RSCN_PORT_ADDR;\n\t\tqla2x00_handle_rscn(fcport->vha, &ea);\n\t}\n}\n\nstatic void\nqla2x00_tmf_iocb_timeout(void *data)\n{\n\tsrb_t *sp = data;\n\tstruct srb_iocb *tmf = &sp->u.iocb_cmd;\n\tint rc, h;\n\tunsigned long flags;\n\n\trc = qla24xx_async_abort_cmd(sp, false);\n\tif (rc) {\n\t\tspin_lock_irqsave(sp->qpair->qp_lock_ptr, flags);\n\t\tfor (h = 1; h < sp->qpair->req->num_outstanding_cmds; h++) {\n\t\t\tif (sp->qpair->req->outstanding_cmds[h] == sp) {\n\t\t\t\tsp->qpair->req->outstanding_cmds[h] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(sp->qpair->qp_lock_ptr, flags);\n\t\ttmf->u.tmf.comp_status = cpu_to_le16(CS_TIMEOUT);\n\t\ttmf->u.tmf.data = QLA_FUNCTION_FAILED;\n\t\tcomplete(&tmf->u.tmf.comp);\n\t}\n}\n\nstatic void qla2x00_tmf_sp_done(srb_t *sp, int res)\n{\n\tstruct srb_iocb *tmf = &sp->u.iocb_cmd;\n\n\tcomplete(&tmf->u.tmf.comp);\n}\n\nint\nqla2x00_async_tm_cmd(fc_port_t *fcport, uint32_t flags, uint32_t lun,\n\tuint32_t tag)\n{\n\tstruct scsi_qla_host *vha = fcport->vha;\n\tstruct srb_iocb *tm_iocb;\n\tsrb_t *sp;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\ttm_iocb = &sp->u.iocb_cmd;\n\tsp->type = SRB_TM_CMD;\n\tsp->name = \"tmf\";\n\n\ttm_iocb->timeout = qla2x00_tmf_iocb_timeout;\n\tinit_completion(&tm_iocb->u.tmf.comp);\n\tqla2x00_init_timer(sp, qla2x00_get_async_timeout(vha));\n\n\ttm_iocb->u.tmf.flags = flags;\n\ttm_iocb->u.tmf.lun = lun;\n\ttm_iocb->u.tmf.data = tag;\n\tsp->done = qla2x00_tmf_sp_done;\n\n\tql_dbg(ql_dbg_taskm, vha, 0x802f,\n\t    \"Async-tmf hdl=%x loop-id=%x portid=%02x%02x%02x.\\n\",\n\t    sp->handle, fcport->loop_id, fcport->d_id.b.domain,\n\t    fcport->d_id.b.area, fcport->d_id.b.al_pa);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done_free_sp;\n\twait_for_completion(&tm_iocb->u.tmf.comp);\n\n\trval = tm_iocb->u.tmf.data;\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x8030,\n\t\t    \"TM IOCB failed (%x).\\n\", rval);\n\t}\n\n\tif (!test_bit(UNLOADING, &vha->dpc_flags) && !IS_QLAFX00(vha->hw)) {\n\t\tflags = tm_iocb->u.tmf.flags;\n\t\tlun = (uint16_t)tm_iocb->u.tmf.lun;\n\n\t\t/* Issue Marker IOCB */\n\t\tqla2x00_marker(vha, vha->hw->base_qpair,\n\t\t    fcport->loop_id, lun,\n\t\t    flags == TCF_LUN_RESET ? MK_SYNC_ID_LUN : MK_SYNC_ID);\n\t}\n\ndone_free_sp:\n\tsp->free(sp);\n\tfcport->flags &= ~FCF_ASYNC_SENT;\ndone:\n\treturn rval;\n}\n\nint\nqla24xx_async_abort_command(srb_t *sp)\n{\n\tunsigned long   flags = 0;\n\n\tuint32_t\thandle;\n\tfc_port_t\t*fcport = sp->fcport;\n\tstruct qla_qpair *qpair = sp->qpair;\n\tstruct scsi_qla_host *vha = fcport->vha;\n\tstruct req_que *req = qpair->req;\n\n\tspin_lock_irqsave(qpair->qp_lock_ptr, flags);\n\tfor (handle = 1; handle < req->num_outstanding_cmds; handle++) {\n\t\tif (req->outstanding_cmds[handle] == sp)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\n\tif (handle == req->num_outstanding_cmds) {\n\t\t/* Command not found. */\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\tif (sp->type == SRB_FXIOCB_DCMD)\n\t\treturn qlafx00_fx_disc(vha, &vha->hw->mr.fcport,\n\t\t    FXDISC_ABORT_IOCTL);\n\n\treturn qla24xx_async_abort_cmd(sp, true);\n}\n\nstatic void\nqla24xx_handle_prli_done_event(struct scsi_qla_host *vha, struct event_arg *ea)\n{\n\tWARN_ONCE(!qla2xxx_is_valid_mbs(ea->data[0]), \"mbs: %#x\\n\",\n\t\t  ea->data[0]);\n\n\tswitch (ea->data[0]) {\n\tcase MBS_COMMAND_COMPLETE:\n\t\tql_dbg(ql_dbg_disc, vha, 0x2118,\n\t\t    \"%s %d %8phC post gpdb\\n\",\n\t\t    __func__, __LINE__, ea->fcport->port_name);\n\n\t\tea->fcport->chip_reset = vha->hw->base_qpair->chip_reset;\n\t\tea->fcport->logout_on_delete = 1;\n\t\tea->fcport->nvme_prli_service_param = ea->iop[0];\n\t\tif (ea->iop[0] & NVME_PRLI_SP_FIRST_BURST)\n\t\t\tea->fcport->nvme_first_burst_size =\n\t\t\t    (ea->iop[1] & 0xffff) * 512;\n\t\telse\n\t\t\tea->fcport->nvme_first_burst_size = 0;\n\t\tqla24xx_post_gpdb_work(vha, ea->fcport, 0);\n\t\tbreak;\n\tdefault:\n\t\tif ((ea->iop[0] == LSC_SCODE_ELS_REJECT) &&\n\t\t    (ea->iop[1] == 0x50000)) {   /* reson 5=busy expl:0x0 */\n\t\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\t\tea->fcport->fw_login_state = DSC_LS_PLOGI_COMP;\n\t\t\tbreak;\n\t\t}\n\n\t\tql_dbg(ql_dbg_disc, vha, 0x2118,\n\t\t       \"%s %d %8phC priority %s, fc4type %x\\n\",\n\t\t       __func__, __LINE__, ea->fcport->port_name,\n\t\t       vha->hw->fc4_type_priority == FC4_PRIORITY_FCP ?\n\t\t       \"FCP\" : \"NVMe\", ea->fcport->fc4_type);\n\n\t\tif (N2N_TOPO(vha->hw)) {\n\t\t\tif (vha->hw->fc4_type_priority == FC4_PRIORITY_NVME) {\n\t\t\t\tea->fcport->fc4_type &= ~FS_FC4TYPE_NVME;\n\t\t\t\tea->fcport->fc4_type |= FS_FC4TYPE_FCP;\n\t\t\t} else {\n\t\t\t\tea->fcport->fc4_type &= ~FS_FC4TYPE_FCP;\n\t\t\t\tea->fcport->fc4_type |= FS_FC4TYPE_NVME;\n\t\t\t}\n\n\t\t\tif (ea->fcport->n2n_link_reset_cnt < 3) {\n\t\t\t\tea->fcport->n2n_link_reset_cnt++;\n\t\t\t\tvha->relogin_jif = jiffies + 2 * HZ;\n\t\t\t\t/*\n\t\t\t\t * PRLI failed. Reset link to kick start\n\t\t\t\t * state machine\n\t\t\t\t */\n\t\t\t\tset_bit(N2N_LINK_RESET, &vha->dpc_flags);\n\t\t\t} else {\n\t\t\t\tql_log(ql_log_warn, vha, 0x2119,\n\t\t\t\t       \"%s %d %8phC Unable to reconnect\\n\",\n\t\t\t\t       __func__, __LINE__,\n\t\t\t\t       ea->fcport->port_name);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * switch connect. login failed. Take connection down\n\t\t\t * and allow relogin to retrigger\n\t\t\t */\n\t\t\tif (NVME_FCP_TARGET(ea->fcport)) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x2118,\n\t\t\t\t       \"%s %d %8phC post %s prli\\n\",\n\t\t\t\t       __func__, __LINE__,\n\t\t\t\t       ea->fcport->port_name,\n\t\t\t\t       (ea->fcport->fc4_type & FS_FC4TYPE_NVME)\n\t\t\t\t       ? \"NVMe\" : \"FCP\");\n\t\t\t\tif (vha->hw->fc4_type_priority == FC4_PRIORITY_NVME)\n\t\t\t\t\tea->fcport->fc4_type &= ~FS_FC4TYPE_NVME;\n\t\t\t\telse\n\t\t\t\t\tea->fcport->fc4_type &= ~FS_FC4TYPE_FCP;\n\t\t\t}\n\n\t\t\tea->fcport->flags &= ~FCF_ASYNC_SENT;\n\t\t\tea->fcport->keep_nport_handle = 0;\n\t\t\tea->fcport->logout_on_delete = 1;\n\t\t\tqlt_schedule_sess_for_deletion(ea->fcport);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nvoid\nqla24xx_handle_plogi_done_event(struct scsi_qla_host *vha, struct event_arg *ea)\n{\n\tport_id_t cid;\t/* conflict Nport id */\n\tu16 lid;\n\tstruct fc_port *conflict_fcport;\n\tunsigned long flags;\n\tstruct fc_port *fcport = ea->fcport;\n\n\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t    \"%s %8phC DS %d LS %d rc %d login %d|%d rscn %d|%d data %x|%x iop %x|%x\\n\",\n\t    __func__, fcport->port_name, fcport->disc_state,\n\t    fcport->fw_login_state, ea->rc, ea->sp->gen2, fcport->login_gen,\n\t    ea->sp->gen1, fcport->rscn_gen,\n\t    ea->data[0], ea->data[1], ea->iop[0], ea->iop[1]);\n\n\tif ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||\n\t    (fcport->fw_login_state == DSC_LS_PRLI_PEND)) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x20ea,\n\t\t    \"%s %d %8phC Remote is trying to login\\n\",\n\t\t    __func__, __LINE__, fcport->port_name);\n\t\treturn;\n\t}\n\n\tif ((fcport->disc_state == DSC_DELETE_PEND) ||\n\t    (fcport->disc_state == DSC_DELETED)) {\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\treturn;\n\t}\n\n\tif (ea->sp->gen2 != fcport->login_gen) {\n\t\t/* target side must have changed it. */\n\t\tql_dbg(ql_dbg_disc, vha, 0x20d3,\n\t\t    \"%s %8phC generation changed\\n\",\n\t\t    __func__, fcport->port_name);\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\treturn;\n\t} else if (ea->sp->gen1 != fcport->rscn_gen) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x20d3,\n\t\t    \"%s %8phC RSCN generation changed\\n\",\n\t\t    __func__, fcport->port_name);\n\t\tqla_rscn_replay(fcport);\n\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\treturn;\n\t}\n\n\tWARN_ONCE(!qla2xxx_is_valid_mbs(ea->data[0]), \"mbs: %#x\\n\",\n\t\t  ea->data[0]);\n\n\tswitch (ea->data[0]) {\n\tcase MBS_COMMAND_COMPLETE:\n\t\t/*\n\t\t * Driver must validate login state - If PRLI not complete,\n\t\t * force a relogin attempt via implicit LOGO, PLOGI, and PRLI\n\t\t * requests.\n\t\t */\n\t\tif (NVME_TARGET(vha->hw, ea->fcport)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2117,\n\t\t\t\t\"%s %d %8phC post prli\\n\",\n\t\t\t\t__func__, __LINE__, ea->fcport->port_name);\n\t\t\tqla24xx_post_prli_work(vha, ea->fcport);\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20ea,\n\t\t\t    \"%s %d %8phC LoopID 0x%x in use with %06x. post gpdb\\n\",\n\t\t\t    __func__, __LINE__, ea->fcport->port_name,\n\t\t\t    ea->fcport->loop_id, ea->fcport->d_id.b24);\n\n\t\t\tset_bit(ea->fcport->loop_id, vha->hw->loop_id_map);\n\t\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\t\t\tea->fcport->chip_reset = vha->hw->base_qpair->chip_reset;\n\t\t\tea->fcport->logout_on_delete = 1;\n\t\t\tea->fcport->send_els_logo = 0;\n\t\t\tea->fcport->fw_login_state = DSC_LS_PRLI_COMP;\n\t\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\t\t\tqla24xx_post_gpdb_work(vha, ea->fcport, 0);\n\t\t}\n\t\tbreak;\n\tcase MBS_COMMAND_ERROR:\n\t\tql_dbg(ql_dbg_disc, vha, 0x20eb, \"%s %d %8phC cmd error %x\\n\",\n\t\t    __func__, __LINE__, ea->fcport->port_name, ea->data[1]);\n\n\t\tea->fcport->flags &= ~FCF_ASYNC_SENT;\n\t\tqla2x00_set_fcport_disc_state(ea->fcport, DSC_LOGIN_FAILED);\n\t\tif (ea->data[1] & QLA_LOGIO_LOGIN_RETRIED)\n\t\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\telse\n\t\t\tqla2x00_mark_device_lost(vha, ea->fcport, 1);\n\t\tbreak;\n\tcase MBS_LOOP_ID_USED:\n\t\t/* data[1] = IO PARAM 1 = nport ID  */\n\t\tcid.b.domain = (ea->iop[1] >> 16) & 0xff;\n\t\tcid.b.area   = (ea->iop[1] >>  8) & 0xff;\n\t\tcid.b.al_pa  = ea->iop[1] & 0xff;\n\t\tcid.b.rsvd_1 = 0;\n\n\t\tql_dbg(ql_dbg_disc, vha, 0x20ec,\n\t\t    \"%s %d %8phC lid %#x in use with pid %06x post gnl\\n\",\n\t\t    __func__, __LINE__, ea->fcport->port_name,\n\t\t    ea->fcport->loop_id, cid.b24);\n\n\t\tset_bit(ea->fcport->loop_id, vha->hw->loop_id_map);\n\t\tea->fcport->loop_id = FC_NO_LOOP_ID;\n\t\tqla24xx_post_gnl_work(vha, ea->fcport);\n\t\tbreak;\n\tcase MBS_PORT_ID_USED:\n\t\tlid = ea->iop[1] & 0xffff;\n\t\tqlt_find_sess_invalidate_other(vha,\n\t\t    wwn_to_u64(ea->fcport->port_name),\n\t\t    ea->fcport->d_id, lid, &conflict_fcport);\n\n\t\tif (conflict_fcport) {\n\t\t\t/*\n\t\t\t * Another fcport share the same loop_id/nport id.\n\t\t\t * Conflict fcport needs to finish cleanup before this\n\t\t\t * fcport can proceed to login.\n\t\t\t */\n\t\t\tconflict_fcport->conflict = ea->fcport;\n\t\t\tea->fcport->login_pause = 1;\n\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20ed,\n\t\t\t    \"%s %d %8phC NPortId %06x inuse with loopid 0x%x. post gidpn\\n\",\n\t\t\t    __func__, __LINE__, ea->fcport->port_name,\n\t\t\t    ea->fcport->d_id.b24, lid);\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20ed,\n\t\t\t    \"%s %d %8phC NPortId %06x inuse with loopid 0x%x. sched delete\\n\",\n\t\t\t    __func__, __LINE__, ea->fcport->port_name,\n\t\t\t    ea->fcport->d_id.b24, lid);\n\n\t\t\tqla2x00_clear_loop_id(ea->fcport);\n\t\t\tset_bit(lid, vha->hw->loop_id_map);\n\t\t\tea->fcport->loop_id = lid;\n\t\t\tea->fcport->keep_nport_handle = 0;\n\t\t\tea->fcport->logout_on_delete = 1;\n\t\t\tqlt_schedule_sess_for_deletion(ea->fcport);\n\t\t}\n\t\tbreak;\n\t}\n\treturn;\n}\n\n/****************************************************************************/\n/*                QLogic ISP2x00 Hardware Support Functions.                */\n/****************************************************************************/\n\nstatic int\nqla83xx_nic_core_fw_load(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t idc_major_ver, idc_minor_ver;\n\tuint16_t config[4];\n\n\tqla83xx_idc_lock(vha, 0);\n\n\t/* SV: TODO: Assign initialization timeout from\n\t * flash-info / other param\n\t */\n\tha->fcoe_dev_init_timeout = QLA83XX_IDC_INITIALIZATION_TIMEOUT;\n\tha->fcoe_reset_timeout = QLA83XX_IDC_RESET_ACK_TIMEOUT;\n\n\t/* Set our fcoe function presence */\n\tif (__qla83xx_set_drv_presence(vha) != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb077,\n\t\t    \"Error while setting DRV-Presence.\\n\");\n\t\trval = QLA_FUNCTION_FAILED;\n\t\tgoto exit;\n\t}\n\n\t/* Decide the reset ownership */\n\tqla83xx_reset_ownership(vha);\n\n\t/*\n\t * On first protocol driver load:\n\t * Init-Owner: Set IDC-Major-Version and Clear IDC-Lock-Recovery\n\t * register.\n\t * Others: Check compatibility with current IDC Major version.\n\t */\n\tqla83xx_rd_reg(vha, QLA83XX_IDC_MAJOR_VERSION, &idc_major_ver);\n\tif (ha->flags.nic_core_reset_owner) {\n\t\t/* Set IDC Major version */\n\t\tidc_major_ver = QLA83XX_SUPP_IDC_MAJOR_VERSION;\n\t\tqla83xx_wr_reg(vha, QLA83XX_IDC_MAJOR_VERSION, idc_major_ver);\n\n\t\t/* Clearing IDC-Lock-Recovery register */\n\t\tqla83xx_wr_reg(vha, QLA83XX_IDC_LOCK_RECOVERY, 0);\n\t} else if (idc_major_ver != QLA83XX_SUPP_IDC_MAJOR_VERSION) {\n\t\t/*\n\t\t * Clear further IDC participation if we are not compatible with\n\t\t * the current IDC Major Version.\n\t\t */\n\t\tql_log(ql_log_warn, vha, 0xb07d,\n\t\t    \"Failing load, idc_major_ver=%d, expected_major_ver=%d.\\n\",\n\t\t    idc_major_ver, QLA83XX_SUPP_IDC_MAJOR_VERSION);\n\t\t__qla83xx_clear_drv_presence(vha);\n\t\trval = QLA_FUNCTION_FAILED;\n\t\tgoto exit;\n\t}\n\t/* Each function sets its supported Minor version. */\n\tqla83xx_rd_reg(vha, QLA83XX_IDC_MINOR_VERSION, &idc_minor_ver);\n\tidc_minor_ver |= (QLA83XX_SUPP_IDC_MINOR_VERSION << (ha->portnum * 2));\n\tqla83xx_wr_reg(vha, QLA83XX_IDC_MINOR_VERSION, idc_minor_ver);\n\n\tif (ha->flags.nic_core_reset_owner) {\n\t\tmemset(config, 0, sizeof(config));\n\t\tif (!qla81xx_get_port_config(vha, config))\n\t\t\tqla83xx_wr_reg(vha, QLA83XX_IDC_DEV_STATE,\n\t\t\t    QLA8XXX_DEV_READY);\n\t}\n\n\trval = qla83xx_idc_state_handler(vha);\n\nexit:\n\tqla83xx_idc_unlock(vha, 0);\n\n\treturn rval;\n}\n\n/*\n* qla2x00_initialize_adapter\n*      Initialize board.\n*\n* Input:\n*      ha = adapter block pointer.\n*\n* Returns:\n*      0 = success\n*/\nint\nqla2x00_initialize_adapter(scsi_qla_host_t *vha)\n{\n\tint\trval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\n\tmemset(&vha->qla_stats, 0, sizeof(vha->qla_stats));\n\tmemset(&vha->fc_host_stat, 0, sizeof(vha->fc_host_stat));\n\n\t/* Clear adapter flags. */\n\tvha->flags.online = 0;\n\tha->flags.chip_reset_done = 0;\n\tvha->flags.reset_active = 0;\n\tha->flags.pci_channel_io_perm_failure = 0;\n\tha->flags.eeh_busy = 0;\n\tvha->qla_stats.jiffies_at_last_reset = get_jiffies_64();\n\tatomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);\n\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\tvha->device_flags = DFLG_NO_CABLE;\n\tvha->dpc_flags = 0;\n\tvha->flags.management_server_logged_in = 0;\n\tvha->marker_needed = 0;\n\tha->isp_abort_cnt = 0;\n\tha->beacon_blink_led = 0;\n\n\tset_bit(0, ha->req_qid_map);\n\tset_bit(0, ha->rsp_qid_map);\n\n\tql_dbg(ql_dbg_init, vha, 0x0040,\n\t    \"Configuring PCI space...\\n\");\n\trval = ha->isp_ops->pci_config(vha);\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x0044,\n\t\t    \"Unable to configure PCI space.\\n\");\n\t\treturn (rval);\n\t}\n\n\tha->isp_ops->reset_chip(vha);\n\n\t/* Check for secure flash support */\n\tif (IS_QLA28XX(ha)) {\n\t\tif (rd_reg_word(&reg->mailbox12) & BIT_0)\n\t\t\tha->flags.secure_adapter = 1;\n\t\tql_log(ql_log_info, vha, 0xffff, \"Secure Adapter: %s\\n\",\n\t\t    (ha->flags.secure_adapter) ? \"Yes\" : \"No\");\n\t}\n\n\n\trval = qla2xxx_get_flash_info(vha);\n\tif (rval) {\n\t\tql_log(ql_log_fatal, vha, 0x004f,\n\t\t    \"Unable to validate FLASH data.\\n\");\n\t\treturn rval;\n\t}\n\n\tif (IS_QLA8044(ha)) {\n\t\tqla8044_read_reset_template(vha);\n\n\t\t/* NOTE: If ql2xdontresethba==1, set IDC_CTRL DONTRESET_BIT0.\n\t\t * If DONRESET_BIT0 is set, drivers should not set dev_state\n\t\t * to NEED_RESET. But if NEED_RESET is set, drivers should\n\t\t * should honor the reset. */\n\t\tif (ql2xdontresethba == 1)\n\t\t\tqla8044_set_idc_dontreset(vha);\n\t}\n\n\tha->isp_ops->get_flash_version(vha, req->ring);\n\tql_dbg(ql_dbg_init, vha, 0x0061,\n\t    \"Configure NVRAM parameters...\\n\");\n\n\t/* Let priority default to FCP, can be overridden by nvram_config */\n\tha->fc4_type_priority = FC4_PRIORITY_FCP;\n\n\tha->isp_ops->nvram_config(vha);\n\n\tif (ha->fc4_type_priority != FC4_PRIORITY_FCP &&\n\t    ha->fc4_type_priority != FC4_PRIORITY_NVME)\n\t\tha->fc4_type_priority = FC4_PRIORITY_FCP;\n\n\tql_log(ql_log_info, vha, 0xffff, \"FC4 priority set to %s\\n\",\n\t       ha->fc4_type_priority == FC4_PRIORITY_FCP ? \"FCP\" : \"NVMe\");\n\n\tif (ha->flags.disable_serdes) {\n\t\t/* Mask HBA via NVRAM settings? */\n\t\tql_log(ql_log_info, vha, 0x0077,\n\t\t    \"Masking HBA WWPN %8phN (via NVRAM).\\n\", vha->port_name);\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tql_dbg(ql_dbg_init, vha, 0x0078,\n\t    \"Verifying loaded RISC code...\\n\");\n\n\t/* If smartsan enabled then require fdmi and rdp enabled */\n\tif (ql2xsmartsan) {\n\t\tql2xfdmienable = 1;\n\t\tql2xrdpenable = 1;\n\t}\n\n\tif (qla2x00_isp_firmware(vha) != QLA_SUCCESS) {\n\t\trval = ha->isp_ops->chip_diag(vha);\n\t\tif (rval)\n\t\t\treturn (rval);\n\t\trval = qla2x00_setup_chip(vha);\n\t\tif (rval)\n\t\t\treturn (rval);\n\t}\n\n\tif (IS_QLA84XX(ha)) {\n\t\tha->cs84xx = qla84xx_get_chip(vha);\n\t\tif (!ha->cs84xx) {\n\t\t\tql_log(ql_log_warn, vha, 0x00d0,\n\t\t\t    \"Unable to configure ISP84XX.\\n\");\n\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t}\n\t}\n\n\tif (qla_ini_mode_enabled(vha) || qla_dual_mode_enabled(vha))\n\t\trval = qla2x00_init_rings(vha);\n\n\t/* No point in continuing if firmware initialization failed. */\n\tif (rval != QLA_SUCCESS)\n\t\treturn rval;\n\n\tha->flags.chip_reset_done = 1;\n\n\tif (rval == QLA_SUCCESS && IS_QLA84XX(ha)) {\n\t\t/* Issue verify 84xx FW IOCB to complete 84xx initialization */\n\t\trval = qla84xx_init_chip(vha);\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\tql_log(ql_log_warn, vha, 0x00d4,\n\t\t\t    \"Unable to initialize ISP84XX.\\n\");\n\t\t\tqla84xx_put_chip(vha);\n\t\t}\n\t}\n\n\t/* Load the NIC Core f/w if we are the first protocol driver. */\n\tif (IS_QLA8031(ha)) {\n\t\trval = qla83xx_nic_core_fw_load(vha);\n\t\tif (rval)\n\t\t\tql_log(ql_log_warn, vha, 0x0124,\n\t\t\t    \"Error in initializing NIC Core f/w.\\n\");\n\t}\n\n\tif (IS_QLA24XX_TYPE(ha) || IS_QLA25XX(ha))\n\t\tqla24xx_read_fcp_prio_cfg(vha);\n\n\tif (IS_P3P_TYPE(ha))\n\t\tqla82xx_set_driver_version(vha, QLA2XXX_VERSION);\n\telse\n\t\tqla25xx_set_driver_version(vha, QLA2XXX_VERSION);\n\n\treturn (rval);\n}\n\n/**\n * qla2100_pci_config() - Setup ISP21xx PCI configuration registers.\n * @vha: HA context\n *\n * Returns 0 on success.\n */\nint\nqla2100_pci_config(scsi_qla_host_t *vha)\n{\n\tuint16_t w;\n\tunsigned long flags;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\tpci_set_master(ha->pdev);\n\tpci_try_set_mwi(ha->pdev);\n\n\tpci_read_config_word(ha->pdev, PCI_COMMAND, &w);\n\tw |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\n\tpci_write_config_word(ha->pdev, PCI_COMMAND, w);\n\n\tpci_disable_rom(ha->pdev);\n\n\t/* Get PCI bus information. */\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tha->pci_attr = rd_reg_word(&reg->ctrl_status);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn QLA_SUCCESS;\n}\n\n/**\n * qla2300_pci_config() - Setup ISP23xx PCI configuration registers.\n * @vha: HA context\n *\n * Returns 0 on success.\n */\nint\nqla2300_pci_config(scsi_qla_host_t *vha)\n{\n\tuint16_t\tw;\n\tunsigned long   flags = 0;\n\tuint32_t\tcnt;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\tpci_set_master(ha->pdev);\n\tpci_try_set_mwi(ha->pdev);\n\n\tpci_read_config_word(ha->pdev, PCI_COMMAND, &w);\n\tw |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\n\n\tif (IS_QLA2322(ha) || IS_QLA6322(ha))\n\t\tw &= ~PCI_COMMAND_INTX_DISABLE;\n\tpci_write_config_word(ha->pdev, PCI_COMMAND, w);\n\n\t/*\n\t * If this is a 2300 card and not 2312, reset the\n\t * COMMAND_INVALIDATE due to a bug in the 2300. Unfortunately,\n\t * the 2310 also reports itself as a 2300 so we need to get the\n\t * fb revision level -- a 6 indicates it really is a 2300 and\n\t * not a 2310.\n\t */\n\tif (IS_QLA2300(ha)) {\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\t\t/* Pause RISC. */\n\t\twrt_reg_word(&reg->hccr, HCCR_PAUSE_RISC);\n\t\tfor (cnt = 0; cnt < 30000; cnt++) {\n\t\t\tif ((rd_reg_word(&reg->hccr) & HCCR_RISC_PAUSE) != 0)\n\t\t\t\tbreak;\n\n\t\t\tudelay(10);\n\t\t}\n\n\t\t/* Select FPM registers. */\n\t\twrt_reg_word(&reg->ctrl_status, 0x20);\n\t\trd_reg_word(&reg->ctrl_status);\n\n\t\t/* Get the fb rev level */\n\t\tha->fb_rev = RD_FB_CMD_REG(ha, reg);\n\n\t\tif (ha->fb_rev == FPM_2300)\n\t\t\tpci_clear_mwi(ha->pdev);\n\n\t\t/* Deselect FPM registers. */\n\t\twrt_reg_word(&reg->ctrl_status, 0x0);\n\t\trd_reg_word(&reg->ctrl_status);\n\n\t\t/* Release RISC module. */\n\t\twrt_reg_word(&reg->hccr, HCCR_RELEASE_RISC);\n\t\tfor (cnt = 0; cnt < 30000; cnt++) {\n\t\t\tif ((rd_reg_word(&reg->hccr) & HCCR_RISC_PAUSE) == 0)\n\t\t\t\tbreak;\n\n\t\t\tudelay(10);\n\t\t}\n\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t}\n\n\tpci_write_config_byte(ha->pdev, PCI_LATENCY_TIMER, 0x80);\n\n\tpci_disable_rom(ha->pdev);\n\n\t/* Get PCI bus information. */\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tha->pci_attr = rd_reg_word(&reg->ctrl_status);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn QLA_SUCCESS;\n}\n\n/**\n * qla24xx_pci_config() - Setup ISP24xx PCI configuration registers.\n * @vha: HA context\n *\n * Returns 0 on success.\n */\nint\nqla24xx_pci_config(scsi_qla_host_t *vha)\n{\n\tuint16_t w;\n\tunsigned long flags = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\n\tpci_set_master(ha->pdev);\n\tpci_try_set_mwi(ha->pdev);\n\n\tpci_read_config_word(ha->pdev, PCI_COMMAND, &w);\n\tw |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\n\tw &= ~PCI_COMMAND_INTX_DISABLE;\n\tpci_write_config_word(ha->pdev, PCI_COMMAND, w);\n\n\tpci_write_config_byte(ha->pdev, PCI_LATENCY_TIMER, 0x80);\n\n\t/* PCI-X -- adjust Maximum Memory Read Byte Count (2048). */\n\tif (pci_find_capability(ha->pdev, PCI_CAP_ID_PCIX))\n\t\tpcix_set_mmrbc(ha->pdev, 2048);\n\n\t/* PCIe -- adjust Maximum Read Request Size (2048). */\n\tif (pci_is_pcie(ha->pdev))\n\t\tpcie_set_readrq(ha->pdev, 4096);\n\n\tpci_disable_rom(ha->pdev);\n\n\tha->chip_revision = ha->pdev->revision;\n\n\t/* Get PCI bus information. */\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tha->pci_attr = rd_reg_dword(&reg->ctrl_status);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn QLA_SUCCESS;\n}\n\n/**\n * qla25xx_pci_config() - Setup ISP25xx PCI configuration registers.\n * @vha: HA context\n *\n * Returns 0 on success.\n */\nint\nqla25xx_pci_config(scsi_qla_host_t *vha)\n{\n\tuint16_t w;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tpci_set_master(ha->pdev);\n\tpci_try_set_mwi(ha->pdev);\n\n\tpci_read_config_word(ha->pdev, PCI_COMMAND, &w);\n\tw |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\n\tw &= ~PCI_COMMAND_INTX_DISABLE;\n\tpci_write_config_word(ha->pdev, PCI_COMMAND, w);\n\n\t/* PCIe -- adjust Maximum Read Request Size (2048). */\n\tif (pci_is_pcie(ha->pdev))\n\t\tpcie_set_readrq(ha->pdev, 4096);\n\n\tpci_disable_rom(ha->pdev);\n\n\tha->chip_revision = ha->pdev->revision;\n\n\treturn QLA_SUCCESS;\n}\n\n/**\n * qla2x00_isp_firmware() - Choose firmware image.\n * @vha: HA context\n *\n * Returns 0 on success.\n */\nstatic int\nqla2x00_isp_firmware(scsi_qla_host_t *vha)\n{\n\tint  rval;\n\tuint16_t loop_id, topo, sw_cap;\n\tuint8_t domain, area, al_pa;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t/* Assume loading risc code */\n\trval = QLA_FUNCTION_FAILED;\n\n\tif (ha->flags.disable_risc_code_load) {\n\t\tql_log(ql_log_info, vha, 0x0079, \"RISC CODE NOT loaded.\\n\");\n\n\t\t/* Verify checksum of loaded RISC code. */\n\t\trval = qla2x00_verify_checksum(vha, ha->fw_srisc_address);\n\t\tif (rval == QLA_SUCCESS) {\n\t\t\t/* And, verify we are not in ROM code. */\n\t\t\trval = qla2x00_get_adapter_id(vha, &loop_id, &al_pa,\n\t\t\t    &area, &domain, &topo, &sw_cap);\n\t\t}\n\t}\n\n\tif (rval)\n\t\tql_dbg(ql_dbg_init, vha, 0x007a,\n\t\t    \"**** Load RISC code ****.\\n\");\n\n\treturn (rval);\n}\n\n/**\n * qla2x00_reset_chip() - Reset ISP chip.\n * @vha: HA context\n *\n * Returns 0 on success.\n */\nint\nqla2x00_reset_chip(scsi_qla_host_t *vha)\n{\n\tunsigned long   flags = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\tuint32_t\tcnt;\n\tuint16_t\tcmd;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\treturn rval;\n\n\tha->isp_ops->disable_intrs(ha);\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\t/* Turn off master enable */\n\tcmd = 0;\n\tpci_read_config_word(ha->pdev, PCI_COMMAND, &cmd);\n\tcmd &= ~PCI_COMMAND_MASTER;\n\tpci_write_config_word(ha->pdev, PCI_COMMAND, cmd);\n\n\tif (!IS_QLA2100(ha)) {\n\t\t/* Pause RISC. */\n\t\twrt_reg_word(&reg->hccr, HCCR_PAUSE_RISC);\n\t\tif (IS_QLA2200(ha) || IS_QLA2300(ha)) {\n\t\t\tfor (cnt = 0; cnt < 30000; cnt++) {\n\t\t\t\tif ((rd_reg_word(&reg->hccr) &\n\t\t\t\t    HCCR_RISC_PAUSE) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(100);\n\t\t\t}\n\t\t} else {\n\t\t\trd_reg_word(&reg->hccr);\t/* PCI Posting. */\n\t\t\tudelay(10);\n\t\t}\n\n\t\t/* Select FPM registers. */\n\t\twrt_reg_word(&reg->ctrl_status, 0x20);\n\t\trd_reg_word(&reg->ctrl_status);\t\t/* PCI Posting. */\n\n\t\t/* FPM Soft Reset. */\n\t\twrt_reg_word(&reg->fpm_diag_config, 0x100);\n\t\trd_reg_word(&reg->fpm_diag_config);\t/* PCI Posting. */\n\n\t\t/* Toggle Fpm Reset. */\n\t\tif (!IS_QLA2200(ha)) {\n\t\t\twrt_reg_word(&reg->fpm_diag_config, 0x0);\n\t\t\trd_reg_word(&reg->fpm_diag_config); /* PCI Posting. */\n\t\t}\n\n\t\t/* Select frame buffer registers. */\n\t\twrt_reg_word(&reg->ctrl_status, 0x10);\n\t\trd_reg_word(&reg->ctrl_status);\t\t/* PCI Posting. */\n\n\t\t/* Reset frame buffer FIFOs. */\n\t\tif (IS_QLA2200(ha)) {\n\t\t\tWRT_FB_CMD_REG(ha, reg, 0xa000);\n\t\t\tRD_FB_CMD_REG(ha, reg);\t\t/* PCI Posting. */\n\t\t} else {\n\t\t\tWRT_FB_CMD_REG(ha, reg, 0x00fc);\n\n\t\t\t/* Read back fb_cmd until zero or 3 seconds max */\n\t\t\tfor (cnt = 0; cnt < 3000; cnt++) {\n\t\t\t\tif ((RD_FB_CMD_REG(ha, reg) & 0xff) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(100);\n\t\t\t}\n\t\t}\n\n\t\t/* Select RISC module registers. */\n\t\twrt_reg_word(&reg->ctrl_status, 0);\n\t\trd_reg_word(&reg->ctrl_status);\t\t/* PCI Posting. */\n\n\t\t/* Reset RISC processor. */\n\t\twrt_reg_word(&reg->hccr, HCCR_RESET_RISC);\n\t\trd_reg_word(&reg->hccr);\t\t/* PCI Posting. */\n\n\t\t/* Release RISC processor. */\n\t\twrt_reg_word(&reg->hccr, HCCR_RELEASE_RISC);\n\t\trd_reg_word(&reg->hccr);\t\t/* PCI Posting. */\n\t}\n\n\twrt_reg_word(&reg->hccr, HCCR_CLR_RISC_INT);\n\twrt_reg_word(&reg->hccr, HCCR_CLR_HOST_INT);\n\n\t/* Reset ISP chip. */\n\twrt_reg_word(&reg->ctrl_status, CSR_ISP_SOFT_RESET);\n\n\t/* Wait for RISC to recover from reset. */\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha) || IS_QLA2300(ha)) {\n\t\t/*\n\t\t * It is necessary to for a delay here since the card doesn't\n\t\t * respond to PCI reads during a reset. On some architectures\n\t\t * this will result in an MCA.\n\t\t */\n\t\tudelay(20);\n\t\tfor (cnt = 30000; cnt; cnt--) {\n\t\t\tif ((rd_reg_word(&reg->ctrl_status) &\n\t\t\t    CSR_ISP_SOFT_RESET) == 0)\n\t\t\t\tbreak;\n\t\t\tudelay(100);\n\t\t}\n\t} else\n\t\tudelay(10);\n\n\t/* Reset RISC processor. */\n\twrt_reg_word(&reg->hccr, HCCR_RESET_RISC);\n\n\twrt_reg_word(&reg->semaphore, 0);\n\n\t/* Release RISC processor. */\n\twrt_reg_word(&reg->hccr, HCCR_RELEASE_RISC);\n\trd_reg_word(&reg->hccr);\t\t\t/* PCI Posting. */\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha) || IS_QLA2300(ha)) {\n\t\tfor (cnt = 0; cnt < 30000; cnt++) {\n\t\t\tif (RD_MAILBOX_REG(ha, reg, 0) != MBS_BUSY)\n\t\t\t\tbreak;\n\n\t\t\tudelay(100);\n\t\t}\n\t} else\n\t\tudelay(100);\n\n\t/* Turn on master enable */\n\tcmd |= PCI_COMMAND_MASTER;\n\tpci_write_config_word(ha->pdev, PCI_COMMAND, cmd);\n\n\t/* Disable RISC pause on FPM parity error. */\n\tif (!IS_QLA2100(ha)) {\n\t\twrt_reg_word(&reg->hccr, HCCR_DISABLE_PARITY_PAUSE);\n\t\trd_reg_word(&reg->hccr);\t\t/* PCI Posting. */\n\t}\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn QLA_SUCCESS;\n}\n\n/**\n * qla81xx_reset_mpi() - Reset's MPI FW via Write MPI Register MBC.\n * @vha: HA context\n *\n * Returns 0 on success.\n */\nstatic int\nqla81xx_reset_mpi(scsi_qla_host_t *vha)\n{\n\tuint16_t mb[4] = {0x1010, 0, 1, 0};\n\n\tif (!IS_QLA81XX(vha->hw))\n\t\treturn QLA_SUCCESS;\n\n\treturn qla81xx_write_mpi_register(vha, mb);\n}\n\n/**\n * qla24xx_reset_risc() - Perform full reset of ISP24xx RISC.\n * @vha: HA context\n *\n * Returns 0 on success.\n */\nstatic inline int\nqla24xx_reset_risc(scsi_qla_host_t *vha)\n{\n\tunsigned long flags = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\tuint32_t cnt;\n\tuint16_t wd;\n\tstatic int abts_cnt; /* ISP abort retry counts */\n\tint rval = QLA_SUCCESS;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\t/* Reset RISC. */\n\twrt_reg_dword(&reg->ctrl_status, CSRX_DMA_SHUTDOWN|MWB_4096_BYTES);\n\tfor (cnt = 0; cnt < 30000; cnt++) {\n\t\tif ((rd_reg_dword(&reg->ctrl_status) & CSRX_DMA_ACTIVE) == 0)\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t}\n\n\tif (!(rd_reg_dword(&reg->ctrl_status) & CSRX_DMA_ACTIVE))\n\t\tset_bit(DMA_SHUTDOWN_CMPL, &ha->fw_dump_cap_flags);\n\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x017e,\n\t    \"HCCR: 0x%x, Control Status %x, DMA active status:0x%x\\n\",\n\t    rd_reg_dword(&reg->hccr),\n\t    rd_reg_dword(&reg->ctrl_status),\n\t    (rd_reg_dword(&reg->ctrl_status) & CSRX_DMA_ACTIVE));\n\n\twrt_reg_dword(&reg->ctrl_status,\n\t    CSRX_ISP_SOFT_RESET|CSRX_DMA_SHUTDOWN|MWB_4096_BYTES);\n\tpci_read_config_word(ha->pdev, PCI_COMMAND, &wd);\n\n\tudelay(100);\n\n\t/* Wait for firmware to complete NVRAM accesses. */\n\trd_reg_word(&reg->mailbox0);\n\tfor (cnt = 10000; rd_reg_word(&reg->mailbox0) != 0 &&\n\t    rval == QLA_SUCCESS; cnt--) {\n\t\tbarrier();\n\t\tif (cnt)\n\t\t\tudelay(5);\n\t\telse\n\t\t\trval = QLA_FUNCTION_TIMEOUT;\n\t}\n\n\tif (rval == QLA_SUCCESS)\n\t\tset_bit(ISP_MBX_RDY, &ha->fw_dump_cap_flags);\n\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x017f,\n\t    \"HCCR: 0x%x, MailBox0 Status 0x%x\\n\",\n\t    rd_reg_dword(&reg->hccr),\n\t    rd_reg_word(&reg->mailbox0));\n\n\t/* Wait for soft-reset to complete. */\n\trd_reg_dword(&reg->ctrl_status);\n\tfor (cnt = 0; cnt < 60; cnt++) {\n\t\tbarrier();\n\t\tif ((rd_reg_dword(&reg->ctrl_status) &\n\t\t    CSRX_ISP_SOFT_RESET) == 0)\n\t\t\tbreak;\n\n\t\tudelay(5);\n\t}\n\tif (!(rd_reg_dword(&reg->ctrl_status) & CSRX_ISP_SOFT_RESET))\n\t\tset_bit(ISP_SOFT_RESET_CMPL, &ha->fw_dump_cap_flags);\n\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x015d,\n\t    \"HCCR: 0x%x, Soft Reset status: 0x%x\\n\",\n\t    rd_reg_dword(&reg->hccr),\n\t    rd_reg_dword(&reg->ctrl_status));\n\n\t/* If required, do an MPI FW reset now */\n\tif (test_and_clear_bit(MPI_RESET_NEEDED, &vha->dpc_flags)) {\n\t\tif (qla81xx_reset_mpi(vha) != QLA_SUCCESS) {\n\t\t\tif (++abts_cnt < 5) {\n\t\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\t\tset_bit(MPI_RESET_NEEDED, &vha->dpc_flags);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We exhausted the ISP abort retries. We have to\n\t\t\t\t * set the board offline.\n\t\t\t\t */\n\t\t\t\tabts_cnt = 0;\n\t\t\t\tvha->flags.online = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\twrt_reg_dword(&reg->hccr, HCCRX_SET_RISC_RESET);\n\trd_reg_dword(&reg->hccr);\n\n\twrt_reg_dword(&reg->hccr, HCCRX_REL_RISC_PAUSE);\n\trd_reg_dword(&reg->hccr);\n\n\twrt_reg_dword(&reg->hccr, HCCRX_CLR_RISC_RESET);\n\trd_reg_dword(&reg->hccr);\n\n\trd_reg_word(&reg->mailbox0);\n\tfor (cnt = 60; rd_reg_word(&reg->mailbox0) != 0 &&\n\t    rval == QLA_SUCCESS; cnt--) {\n\t\tbarrier();\n\t\tif (cnt)\n\t\t\tudelay(5);\n\t\telse\n\t\t\trval = QLA_FUNCTION_TIMEOUT;\n\t}\n\tif (rval == QLA_SUCCESS)\n\t\tset_bit(RISC_RDY_AFT_RESET, &ha->fw_dump_cap_flags);\n\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x015e,\n\t    \"Host Risc 0x%x, mailbox0 0x%x\\n\",\n\t    rd_reg_dword(&reg->hccr),\n\t     rd_reg_word(&reg->mailbox0));\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x015f,\n\t    \"Driver in %s mode\\n\",\n\t    IS_NOPOLLING_TYPE(ha) ? \"Interrupt\" : \"Polling\");\n\n\tif (IS_NOPOLLING_TYPE(ha))\n\t\tha->isp_ops->enable_intrs(ha);\n\n\treturn rval;\n}\n\nstatic void\nqla25xx_read_risc_sema_reg(scsi_qla_host_t *vha, uint32_t *data)\n{\n\tstruct device_reg_24xx __iomem *reg = &vha->hw->iobase->isp24;\n\n\twrt_reg_dword(&reg->iobase_addr, RISC_REGISTER_BASE_OFFSET);\n\t*data = rd_reg_dword(&reg->iobase_window + RISC_REGISTER_WINDOW_OFFSET);\n}\n\nstatic void\nqla25xx_write_risc_sema_reg(scsi_qla_host_t *vha, uint32_t data)\n{\n\tstruct device_reg_24xx __iomem *reg = &vha->hw->iobase->isp24;\n\n\twrt_reg_dword(&reg->iobase_addr, RISC_REGISTER_BASE_OFFSET);\n\twrt_reg_dword(&reg->iobase_window + RISC_REGISTER_WINDOW_OFFSET, data);\n}\n\nstatic void\nqla25xx_manipulate_risc_semaphore(scsi_qla_host_t *vha)\n{\n\tuint32_t wd32 = 0;\n\tuint delta_msec = 100;\n\tuint elapsed_msec = 0;\n\tuint timeout_msec;\n\tulong n;\n\n\tif (vha->hw->pdev->subsystem_device != 0x0175 &&\n\t    vha->hw->pdev->subsystem_device != 0x0240)\n\t\treturn;\n\n\twrt_reg_dword(&vha->hw->iobase->isp24.hccr, HCCRX_SET_RISC_PAUSE);\n\tudelay(100);\n\nattempt:\n\ttimeout_msec = TIMEOUT_SEMAPHORE;\n\tn = timeout_msec / delta_msec;\n\twhile (n--) {\n\t\tqla25xx_write_risc_sema_reg(vha, RISC_SEMAPHORE_SET);\n\t\tqla25xx_read_risc_sema_reg(vha, &wd32);\n\t\tif (wd32 & RISC_SEMAPHORE)\n\t\t\tbreak;\n\t\tmsleep(delta_msec);\n\t\telapsed_msec += delta_msec;\n\t\tif (elapsed_msec > TIMEOUT_TOTAL_ELAPSED)\n\t\t\tgoto force;\n\t}\n\n\tif (!(wd32 & RISC_SEMAPHORE))\n\t\tgoto force;\n\n\tif (!(wd32 & RISC_SEMAPHORE_FORCE))\n\t\tgoto acquired;\n\n\tqla25xx_write_risc_sema_reg(vha, RISC_SEMAPHORE_CLR);\n\ttimeout_msec = TIMEOUT_SEMAPHORE_FORCE;\n\tn = timeout_msec / delta_msec;\n\twhile (n--) {\n\t\tqla25xx_read_risc_sema_reg(vha, &wd32);\n\t\tif (!(wd32 & RISC_SEMAPHORE_FORCE))\n\t\t\tbreak;\n\t\tmsleep(delta_msec);\n\t\telapsed_msec += delta_msec;\n\t\tif (elapsed_msec > TIMEOUT_TOTAL_ELAPSED)\n\t\t\tgoto force;\n\t}\n\n\tif (wd32 & RISC_SEMAPHORE_FORCE)\n\t\tqla25xx_write_risc_sema_reg(vha, RISC_SEMAPHORE_FORCE_CLR);\n\n\tgoto attempt;\n\nforce:\n\tqla25xx_write_risc_sema_reg(vha, RISC_SEMAPHORE_FORCE_SET);\n\nacquired:\n\treturn;\n}\n\n/**\n * qla24xx_reset_chip() - Reset ISP24xx chip.\n * @vha: HA context\n *\n * Returns 0 on success.\n */\nint\nqla24xx_reset_chip(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tif (pci_channel_offline(ha->pdev) &&\n\t    ha->flags.pci_channel_io_perm_failure) {\n\t\treturn rval;\n\t}\n\n\tha->isp_ops->disable_intrs(ha);\n\n\tqla25xx_manipulate_risc_semaphore(vha);\n\n\t/* Perform RISC reset. */\n\trval = qla24xx_reset_risc(vha);\n\n\treturn rval;\n}\n\n/**\n * qla2x00_chip_diag() - Test chip for proper operation.\n * @vha: HA context\n *\n * Returns 0 on success.\n */\nint\nqla2x00_chip_diag(scsi_qla_host_t *vha)\n{\n\tint\t\trval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\tunsigned long\tflags = 0;\n\tuint16_t\tdata;\n\tuint32_t\tcnt;\n\tuint16_t\tmb[5];\n\tstruct req_que *req = ha->req_q_map[0];\n\n\t/* Assume a failed state */\n\trval = QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_init, vha, 0x007b, \"Testing device at %p.\\n\",\n\t       &reg->flash_address);\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\t/* Reset ISP chip. */\n\twrt_reg_word(&reg->ctrl_status, CSR_ISP_SOFT_RESET);\n\n\t/*\n\t * We need to have a delay here since the card will not respond while\n\t * in reset causing an MCA on some architectures.\n\t */\n\tudelay(20);\n\tdata = qla2x00_debounce_register(&reg->ctrl_status);\n\tfor (cnt = 6000000 ; cnt && (data & CSR_ISP_SOFT_RESET); cnt--) {\n\t\tudelay(5);\n\t\tdata = rd_reg_word(&reg->ctrl_status);\n\t\tbarrier();\n\t}\n\n\tif (!cnt)\n\t\tgoto chip_diag_failed;\n\n\tql_dbg(ql_dbg_init, vha, 0x007c,\n\t    \"Reset register cleared by chip reset.\\n\");\n\n\t/* Reset RISC processor. */\n\twrt_reg_word(&reg->hccr, HCCR_RESET_RISC);\n\twrt_reg_word(&reg->hccr, HCCR_RELEASE_RISC);\n\n\t/* Workaround for QLA2312 PCI parity error */\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha) || IS_QLA2300(ha)) {\n\t\tdata = qla2x00_debounce_register(MAILBOX_REG(ha, reg, 0));\n\t\tfor (cnt = 6000000; cnt && (data == MBS_BUSY); cnt--) {\n\t\t\tudelay(5);\n\t\t\tdata = RD_MAILBOX_REG(ha, reg, 0);\n\t\t\tbarrier();\n\t\t}\n\t} else\n\t\tudelay(10);\n\n\tif (!cnt)\n\t\tgoto chip_diag_failed;\n\n\t/* Check product ID of chip */\n\tql_dbg(ql_dbg_init, vha, 0x007d, \"Checking product ID of chip.\\n\");\n\n\tmb[1] = RD_MAILBOX_REG(ha, reg, 1);\n\tmb[2] = RD_MAILBOX_REG(ha, reg, 2);\n\tmb[3] = RD_MAILBOX_REG(ha, reg, 3);\n\tmb[4] = qla2x00_debounce_register(MAILBOX_REG(ha, reg, 4));\n\tif (mb[1] != PROD_ID_1 || (mb[2] != PROD_ID_2 && mb[2] != PROD_ID_2a) ||\n\t    mb[3] != PROD_ID_3) {\n\t\tql_log(ql_log_warn, vha, 0x0062,\n\t\t    \"Wrong product ID = 0x%x,0x%x,0x%x.\\n\",\n\t\t    mb[1], mb[2], mb[3]);\n\n\t\tgoto chip_diag_failed;\n\t}\n\tha->product_id[0] = mb[1];\n\tha->product_id[1] = mb[2];\n\tha->product_id[2] = mb[3];\n\tha->product_id[3] = mb[4];\n\n\t/* Adjust fw RISC transfer size */\n\tif (req->length > 1024)\n\t\tha->fw_transfer_size = REQUEST_ENTRY_SIZE * 1024;\n\telse\n\t\tha->fw_transfer_size = REQUEST_ENTRY_SIZE *\n\t\t    req->length;\n\n\tif (IS_QLA2200(ha) &&\n\t    RD_MAILBOX_REG(ha, reg, 7) == QLA2200A_RISC_ROM_VER) {\n\t\t/* Limit firmware transfer size with a 2200A */\n\t\tql_dbg(ql_dbg_init, vha, 0x007e, \"Found QLA2200A Chip.\\n\");\n\n\t\tha->device_type |= DT_ISP2200A;\n\t\tha->fw_transfer_size = 128;\n\t}\n\n\t/* Wrap Incoming Mailboxes Test. */\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tql_dbg(ql_dbg_init, vha, 0x007f, \"Checking mailboxes.\\n\");\n\trval = qla2x00_mbx_reg_test(vha);\n\tif (rval)\n\t\tql_log(ql_log_warn, vha, 0x0080,\n\t\t    \"Failed mailbox send register test.\\n\");\n\telse\n\t\t/* Flag a successful rval */\n\t\trval = QLA_SUCCESS;\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\nchip_diag_failed:\n\tif (rval)\n\t\tql_log(ql_log_info, vha, 0x0081,\n\t\t    \"Chip diagnostics **** FAILED ****.\\n\");\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn (rval);\n}\n\n/**\n * qla24xx_chip_diag() - Test ISP24xx for proper operation.\n * @vha: HA context\n *\n * Returns 0 on success.\n */\nint\nqla24xx_chip_diag(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\n\tif (IS_P3P_TYPE(ha))\n\t\treturn QLA_SUCCESS;\n\n\tha->fw_transfer_size = REQUEST_ENTRY_SIZE * req->length;\n\n\trval = qla2x00_mbx_reg_test(vha);\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x0082,\n\t\t    \"Failed mailbox send register test.\\n\");\n\t} else {\n\t\t/* Flag a successful rval */\n\t\trval = QLA_SUCCESS;\n\t}\n\n\treturn rval;\n}\n\nstatic void\nqla2x00_init_fce_trace(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tdma_addr_t tc_dma;\n\tvoid *tc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_FWI2_CAPABLE(ha))\n\t\treturn;\n\n\tif (!IS_QLA25XX(ha) && !IS_QLA81XX(ha) && !IS_QLA83XX(ha) &&\n\t    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn;\n\n\tif (ha->fce) {\n\t\tql_dbg(ql_dbg_init, vha, 0x00bd,\n\t\t       \"%s: FCE Mem is already allocated.\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\n\t/* Allocate memory for Fibre Channel Event Buffer. */\n\ttc = dma_alloc_coherent(&ha->pdev->dev, FCE_SIZE, &tc_dma,\n\t\t\t\tGFP_KERNEL);\n\tif (!tc) {\n\t\tql_log(ql_log_warn, vha, 0x00be,\n\t\t       \"Unable to allocate (%d KB) for FCE.\\n\",\n\t\t       FCE_SIZE / 1024);\n\t\treturn;\n\t}\n\n\trval = qla2x00_enable_fce_trace(vha, tc_dma, FCE_NUM_BUFFERS,\n\t\t\t\t\tha->fce_mb, &ha->fce_bufs);\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x00bf,\n\t\t       \"Unable to initialize FCE (%d).\\n\", rval);\n\t\tdma_free_coherent(&ha->pdev->dev, FCE_SIZE, tc, tc_dma);\n\t\treturn;\n\t}\n\n\tql_dbg(ql_dbg_init, vha, 0x00c0,\n\t       \"Allocated (%d KB) for FCE...\\n\", FCE_SIZE / 1024);\n\n\tha->flags.fce_enabled = 1;\n\tha->fce_dma = tc_dma;\n\tha->fce = tc;\n}\n\nstatic void\nqla2x00_init_eft_trace(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tdma_addr_t tc_dma;\n\tvoid *tc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_FWI2_CAPABLE(ha))\n\t\treturn;\n\n\tif (ha->eft) {\n\t\tql_dbg(ql_dbg_init, vha, 0x00bd,\n\t\t    \"%s: EFT Mem is already allocated.\\n\",\n\t\t    __func__);\n\t\treturn;\n\t}\n\n\t/* Allocate memory for Extended Trace Buffer. */\n\ttc = dma_alloc_coherent(&ha->pdev->dev, EFT_SIZE, &tc_dma,\n\t\t\t\tGFP_KERNEL);\n\tif (!tc) {\n\t\tql_log(ql_log_warn, vha, 0x00c1,\n\t\t       \"Unable to allocate (%d KB) for EFT.\\n\",\n\t\t       EFT_SIZE / 1024);\n\t\treturn;\n\t}\n\n\trval = qla2x00_enable_eft_trace(vha, tc_dma, EFT_NUM_BUFFERS);\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x00c2,\n\t\t       \"Unable to initialize EFT (%d).\\n\", rval);\n\t\tdma_free_coherent(&ha->pdev->dev, EFT_SIZE, tc, tc_dma);\n\t\treturn;\n\t}\n\n\tql_dbg(ql_dbg_init, vha, 0x00c3,\n\t       \"Allocated (%d KB) EFT ...\\n\", EFT_SIZE / 1024);\n\n\tha->eft_dma = tc_dma;\n\tha->eft = tc;\n}\n\nstatic void\nqla2x00_alloc_offload_mem(scsi_qla_host_t *vha)\n{\n\tqla2x00_init_fce_trace(vha);\n\tqla2x00_init_eft_trace(vha);\n}\n\nvoid\nqla2x00_alloc_fw_dump(scsi_qla_host_t *vha)\n{\n\tuint32_t dump_size, fixed_size, mem_size, req_q_size, rsp_q_size,\n\t    eft_size, fce_size, mq_size;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\tstruct rsp_que *rsp = ha->rsp_q_map[0];\n\tstruct qla2xxx_fw_dump *fw_dump;\n\n\tdump_size = fixed_size = mem_size = eft_size = fce_size = mq_size = 0;\n\treq_q_size = rsp_q_size = 0;\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha)) {\n\t\tfixed_size = sizeof(struct qla2100_fw_dump);\n\t} else if (IS_QLA23XX(ha)) {\n\t\tfixed_size = offsetof(struct qla2300_fw_dump, data_ram);\n\t\tmem_size = (ha->fw_memory_size - 0x11000 + 1) *\n\t\t    sizeof(uint16_t);\n\t} else if (IS_FWI2_CAPABLE(ha)) {\n\t\tif (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\tfixed_size = offsetof(struct qla83xx_fw_dump, ext_mem);\n\t\telse if (IS_QLA81XX(ha))\n\t\t\tfixed_size = offsetof(struct qla81xx_fw_dump, ext_mem);\n\t\telse if (IS_QLA25XX(ha))\n\t\t\tfixed_size = offsetof(struct qla25xx_fw_dump, ext_mem);\n\t\telse\n\t\t\tfixed_size = offsetof(struct qla24xx_fw_dump, ext_mem);\n\n\t\tmem_size = (ha->fw_memory_size - 0x100000 + 1) *\n\t\t    sizeof(uint32_t);\n\t\tif (ha->mqenable) {\n\t\t\tif (!IS_QLA83XX(ha) && !IS_QLA27XX(ha) &&\n\t\t\t    !IS_QLA28XX(ha))\n\t\t\t\tmq_size = sizeof(struct qla2xxx_mq_chain);\n\t\t\t/*\n\t\t\t * Allocate maximum buffer size for all queues - Q0.\n\t\t\t * Resizing must be done at end-of-dump processing.\n\t\t\t */\n\t\t\tmq_size += (ha->max_req_queues - 1) *\n\t\t\t    (req->length * sizeof(request_t));\n\t\t\tmq_size += (ha->max_rsp_queues - 1) *\n\t\t\t    (rsp->length * sizeof(response_t));\n\t\t}\n\t\tif (ha->tgt.atio_ring)\n\t\t\tmq_size += ha->tgt.atio_q_length * sizeof(request_t);\n\n\t\tqla2x00_init_fce_trace(vha);\n\t\tif (ha->fce)\n\t\t\tfce_size = sizeof(struct qla2xxx_fce_chain) + FCE_SIZE;\n\t\tqla2x00_init_eft_trace(vha);\n\t\tif (ha->eft)\n\t\t\teft_size = EFT_SIZE;\n\t}\n\n\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\tstruct fwdt *fwdt = ha->fwdt;\n\t\tuint j;\n\n\t\tfor (j = 0; j < 2; j++, fwdt++) {\n\t\t\tif (!fwdt->template) {\n\t\t\t\tql_dbg(ql_dbg_init, vha, 0x00ba,\n\t\t\t\t    \"-> fwdt%u no template\\n\", j);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tql_dbg(ql_dbg_init, vha, 0x00fa,\n\t\t\t    \"-> fwdt%u calculating fwdump size...\\n\", j);\n\t\t\tfwdt->dump_size = qla27xx_fwdt_calculate_dump_size(\n\t\t\t    vha, fwdt->template);\n\t\t\tql_dbg(ql_dbg_init, vha, 0x00fa,\n\t\t\t    \"-> fwdt%u calculated fwdump size = %#lx bytes\\n\",\n\t\t\t    j, fwdt->dump_size);\n\t\t\tdump_size += fwdt->dump_size;\n\t\t}\n\t\t/* Add space for spare MPI fw dump. */\n\t\tdump_size += ha->fwdt[1].dump_size;\n\t} else {\n\t\treq_q_size = req->length * sizeof(request_t);\n\t\trsp_q_size = rsp->length * sizeof(response_t);\n\t\tdump_size = offsetof(struct qla2xxx_fw_dump, isp);\n\t\tdump_size += fixed_size + mem_size + req_q_size + rsp_q_size\n\t\t\t+ eft_size;\n\t\tha->chain_offset = dump_size;\n\t\tdump_size += mq_size + fce_size;\n\t\tif (ha->exchoffld_buf)\n\t\t\tdump_size += sizeof(struct qla2xxx_offld_chain) +\n\t\t\t\tha->exchoffld_size;\n\t\tif (ha->exlogin_buf)\n\t\t\tdump_size += sizeof(struct qla2xxx_offld_chain) +\n\t\t\t\tha->exlogin_size;\n\t}\n\n\tif (!ha->fw_dump_len || dump_size > ha->fw_dump_alloc_len) {\n\n\t\tql_dbg(ql_dbg_init, vha, 0x00c5,\n\t\t    \"%s dump_size %d fw_dump_len %d fw_dump_alloc_len %d\\n\",\n\t\t    __func__, dump_size, ha->fw_dump_len,\n\t\t    ha->fw_dump_alloc_len);\n\n\t\tfw_dump = vmalloc(dump_size);\n\t\tif (!fw_dump) {\n\t\t\tql_log(ql_log_warn, vha, 0x00c4,\n\t\t\t    \"Unable to allocate (%d KB) for firmware dump.\\n\",\n\t\t\t    dump_size / 1024);\n\t\t} else {\n\t\t\tmutex_lock(&ha->optrom_mutex);\n\t\t\tif (ha->fw_dumped) {\n\t\t\t\tmemcpy(fw_dump, ha->fw_dump, ha->fw_dump_len);\n\t\t\t\tvfree(ha->fw_dump);\n\t\t\t\tha->fw_dump = fw_dump;\n\t\t\t\tha->fw_dump_alloc_len =  dump_size;\n\t\t\t\tql_dbg(ql_dbg_init, vha, 0x00c5,\n\t\t\t\t    \"Re-Allocated (%d KB) and save firmware dump.\\n\",\n\t\t\t\t    dump_size / 1024);\n\t\t\t} else {\n\t\t\t\tif (ha->fw_dump)\n\t\t\t\t\tvfree(ha->fw_dump);\n\t\t\t\tha->fw_dump = fw_dump;\n\n\t\t\t\tha->fw_dump_len = ha->fw_dump_alloc_len =\n\t\t\t\t    dump_size;\n\t\t\t\tql_dbg(ql_dbg_init, vha, 0x00c5,\n\t\t\t\t    \"Allocated (%d KB) for firmware dump.\\n\",\n\t\t\t\t    dump_size / 1024);\n\n\t\t\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\t\t\t\tha->mpi_fw_dump = (char *)fw_dump +\n\t\t\t\t\t\tha->fwdt[1].dump_size;\n\t\t\t\t\tmutex_unlock(&ha->optrom_mutex);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tha->fw_dump->signature[0] = 'Q';\n\t\t\t\tha->fw_dump->signature[1] = 'L';\n\t\t\t\tha->fw_dump->signature[2] = 'G';\n\t\t\t\tha->fw_dump->signature[3] = 'C';\n\t\t\t\tha->fw_dump->version = htonl(1);\n\n\t\t\t\tha->fw_dump->fixed_size = htonl(fixed_size);\n\t\t\t\tha->fw_dump->mem_size = htonl(mem_size);\n\t\t\t\tha->fw_dump->req_q_size = htonl(req_q_size);\n\t\t\t\tha->fw_dump->rsp_q_size = htonl(rsp_q_size);\n\n\t\t\t\tha->fw_dump->eft_size = htonl(eft_size);\n\t\t\t\tha->fw_dump->eft_addr_l =\n\t\t\t\t    htonl(LSD(ha->eft_dma));\n\t\t\t\tha->fw_dump->eft_addr_h =\n\t\t\t\t    htonl(MSD(ha->eft_dma));\n\n\t\t\t\tha->fw_dump->header_size =\n\t\t\t\t\thtonl(offsetof\n\t\t\t\t\t    (struct qla2xxx_fw_dump, isp));\n\t\t\t}\n\t\t\tmutex_unlock(&ha->optrom_mutex);\n\t\t}\n\t}\n}\n\nstatic int\nqla81xx_mpi_sync(scsi_qla_host_t *vha)\n{\n#define MPS_MASK\t0xe0\n\tint rval;\n\tuint16_t dc;\n\tuint32_t dw;\n\n\tif (!IS_QLA81XX(vha->hw))\n\t\treturn QLA_SUCCESS;\n\n\trval = qla2x00_write_ram_word(vha, 0x7c00, 1);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x0105,\n\t\t    \"Unable to acquire semaphore.\\n\");\n\t\tgoto done;\n\t}\n\n\tpci_read_config_word(vha->hw->pdev, 0x54, &dc);\n\trval = qla2x00_read_ram_word(vha, 0x7a15, &dw);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x0067, \"Unable to read sync.\\n\");\n\t\tgoto done_release;\n\t}\n\n\tdc &= MPS_MASK;\n\tif (dc == (dw & MPS_MASK))\n\t\tgoto done_release;\n\n\tdw &= ~MPS_MASK;\n\tdw |= dc;\n\trval = qla2x00_write_ram_word(vha, 0x7a15, dw);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x0114, \"Unable to gain sync.\\n\");\n\t}\n\ndone_release:\n\trval = qla2x00_write_ram_word(vha, 0x7c00, 0);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x006d,\n\t\t    \"Unable to release semaphore.\\n\");\n\t}\n\ndone:\n\treturn rval;\n}\n\nint\nqla2x00_alloc_outstanding_cmds(struct qla_hw_data *ha, struct req_que *req)\n{\n\t/* Don't try to reallocate the array */\n\tif (req->outstanding_cmds)\n\t\treturn QLA_SUCCESS;\n\n\tif (!IS_FWI2_CAPABLE(ha))\n\t\treq->num_outstanding_cmds = DEFAULT_OUTSTANDING_COMMANDS;\n\telse {\n\t\tif (ha->cur_fw_xcb_count <= ha->cur_fw_iocb_count)\n\t\t\treq->num_outstanding_cmds = ha->cur_fw_xcb_count;\n\t\telse\n\t\t\treq->num_outstanding_cmds = ha->cur_fw_iocb_count;\n\t}\n\n\treq->outstanding_cmds = kcalloc(req->num_outstanding_cmds,\n\t\t\t\t\tsizeof(srb_t *),\n\t\t\t\t\tGFP_KERNEL);\n\n\tif (!req->outstanding_cmds) {\n\t\t/*\n\t\t * Try to allocate a minimal size just so we can get through\n\t\t * initialization.\n\t\t */\n\t\treq->num_outstanding_cmds = MIN_OUTSTANDING_COMMANDS;\n\t\treq->outstanding_cmds = kcalloc(req->num_outstanding_cmds,\n\t\t\t\t\t\tsizeof(srb_t *),\n\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!req->outstanding_cmds) {\n\t\t\tql_log(ql_log_fatal, NULL, 0x0126,\n\t\t\t    \"Failed to allocate memory for \"\n\t\t\t    \"outstanding_cmds for req_que %p.\\n\", req);\n\t\t\treq->num_outstanding_cmds = 0;\n\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t}\n\t}\n\n\treturn QLA_SUCCESS;\n}\n\n#define PRINT_FIELD(_field, _flag, _str) {\t\t\\\n\tif (a0->_field & _flag) {\\\n\t\tif (p) {\\\n\t\t\tstrcat(ptr, \"|\");\\\n\t\t\tptr++;\\\n\t\t\tleftover--;\\\n\t\t} \\\n\t\tlen = snprintf(ptr, leftover, \"%s\", _str);\t\\\n\t\tp = 1;\\\n\t\tleftover -= len;\\\n\t\tptr += len; \\\n\t} \\\n}\n\nstatic void qla2xxx_print_sfp_info(struct scsi_qla_host *vha)\n{\n#define STR_LEN 64\n\tstruct sff_8247_a0 *a0 = (struct sff_8247_a0 *)vha->hw->sfp_data;\n\tu8 str[STR_LEN], *ptr, p;\n\tint leftover, len;\n\n\tmemset(str, 0, STR_LEN);\n\tsnprintf(str, SFF_VEN_NAME_LEN+1, a0->vendor_name);\n\tql_dbg(ql_dbg_init, vha, 0x015a,\n\t    \"SFP MFG Name: %s\\n\", str);\n\n\tmemset(str, 0, STR_LEN);\n\tsnprintf(str, SFF_PART_NAME_LEN+1, a0->vendor_pn);\n\tql_dbg(ql_dbg_init, vha, 0x015c,\n\t    \"SFP Part Name: %s\\n\", str);\n\n\t/* media */\n\tmemset(str, 0, STR_LEN);\n\tptr = str;\n\tleftover = STR_LEN;\n\tp = len = 0;\n\tPRINT_FIELD(fc_med_cc9, FC_MED_TW, \"Twin AX\");\n\tPRINT_FIELD(fc_med_cc9, FC_MED_TP, \"Twisted Pair\");\n\tPRINT_FIELD(fc_med_cc9, FC_MED_MI, \"Min Coax\");\n\tPRINT_FIELD(fc_med_cc9, FC_MED_TV, \"Video Coax\");\n\tPRINT_FIELD(fc_med_cc9, FC_MED_M6, \"MultiMode 62.5um\");\n\tPRINT_FIELD(fc_med_cc9, FC_MED_M5, \"MultiMode 50um\");\n\tPRINT_FIELD(fc_med_cc9, FC_MED_SM, \"SingleMode\");\n\tql_dbg(ql_dbg_init, vha, 0x0160,\n\t    \"SFP Media: %s\\n\", str);\n\n\t/* link length */\n\tmemset(str, 0, STR_LEN);\n\tptr = str;\n\tleftover = STR_LEN;\n\tp = len = 0;\n\tPRINT_FIELD(fc_ll_cc7, FC_LL_VL, \"Very Long\");\n\tPRINT_FIELD(fc_ll_cc7, FC_LL_S, \"Short\");\n\tPRINT_FIELD(fc_ll_cc7, FC_LL_I, \"Intermediate\");\n\tPRINT_FIELD(fc_ll_cc7, FC_LL_L, \"Long\");\n\tPRINT_FIELD(fc_ll_cc7, FC_LL_M, \"Medium\");\n\tql_dbg(ql_dbg_init, vha, 0x0196,\n\t    \"SFP Link Length: %s\\n\", str);\n\n\tmemset(str, 0, STR_LEN);\n\tptr = str;\n\tleftover = STR_LEN;\n\tp = len = 0;\n\tPRINT_FIELD(fc_ll_cc7, FC_LL_SA, \"Short Wave (SA)\");\n\tPRINT_FIELD(fc_ll_cc7, FC_LL_LC, \"Long Wave(LC)\");\n\tPRINT_FIELD(fc_tec_cc8, FC_TEC_SN, \"Short Wave (SN)\");\n\tPRINT_FIELD(fc_tec_cc8, FC_TEC_SL, \"Short Wave (SL)\");\n\tPRINT_FIELD(fc_tec_cc8, FC_TEC_LL, \"Long Wave (LL)\");\n\tql_dbg(ql_dbg_init, vha, 0x016e,\n\t    \"SFP FC Link Tech: %s\\n\", str);\n\n\tif (a0->length_km)\n\t\tql_dbg(ql_dbg_init, vha, 0x016f,\n\t\t    \"SFP Distant: %d km\\n\", a0->length_km);\n\tif (a0->length_100m)\n\t\tql_dbg(ql_dbg_init, vha, 0x0170,\n\t\t    \"SFP Distant: %d m\\n\", a0->length_100m*100);\n\tif (a0->length_50um_10m)\n\t\tql_dbg(ql_dbg_init, vha, 0x0189,\n\t\t    \"SFP Distant (WL=50um): %d m\\n\", a0->length_50um_10m * 10);\n\tif (a0->length_62um_10m)\n\t\tql_dbg(ql_dbg_init, vha, 0x018a,\n\t\t  \"SFP Distant (WL=62.5um): %d m\\n\", a0->length_62um_10m * 10);\n\tif (a0->length_om4_10m)\n\t\tql_dbg(ql_dbg_init, vha, 0x0194,\n\t\t    \"SFP Distant (OM4): %d m\\n\", a0->length_om4_10m * 10);\n\tif (a0->length_om3_10m)\n\t\tql_dbg(ql_dbg_init, vha, 0x0195,\n\t\t    \"SFP Distant (OM3): %d m\\n\", a0->length_om3_10m * 10);\n}\n\n\n/**\n * qla24xx_detect_sfp()\n *\n * @vha: adapter state pointer.\n *\n * @return\n *\t0 -- Configure firmware to use short-range settings -- normal\n *\t     buffer-to-buffer credits.\n *\n *\t1 -- Configure firmware to use long-range settings -- extra\n *\t     buffer-to-buffer credits should be allocated with\n *\t     ha->lr_distance containing distance settings from NVRAM or SFP\n *\t     (if supported).\n */\nint\nqla24xx_detect_sfp(scsi_qla_host_t *vha)\n{\n\tint rc, used_nvram;\n\tstruct sff_8247_a0 *a;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct nvram_81xx *nv = ha->nvram;\n#define LR_DISTANCE_UNKNOWN\t2\n\tstatic const char * const types[] = { \"Short\", \"Long\" };\n\tstatic const char * const lengths[] = { \"(10km)\", \"(5km)\", \"\" };\n\tu8 ll = 0;\n\n\t/* Seed with NVRAM settings. */\n\tused_nvram = 0;\n\tha->flags.lr_detected = 0;\n\tif (IS_BPM_RANGE_CAPABLE(ha) &&\n\t    (nv->enhanced_features & NEF_LR_DIST_ENABLE)) {\n\t\tused_nvram = 1;\n\t\tha->flags.lr_detected = 1;\n\t\tha->lr_distance =\n\t\t    (nv->enhanced_features >> LR_DIST_NV_POS)\n\t\t     & LR_DIST_NV_MASK;\n\t}\n\n\tif (!IS_BPM_ENABLED(vha))\n\t\tgoto out;\n\t/* Determine SR/LR capabilities of SFP/Transceiver. */\n\trc = qla2x00_read_sfp_dev(vha, NULL, 0);\n\tif (rc)\n\t\tgoto out;\n\n\tused_nvram = 0;\n\ta = (struct sff_8247_a0 *)vha->hw->sfp_data;\n\tqla2xxx_print_sfp_info(vha);\n\n\tha->flags.lr_detected = 0;\n\tll = a->fc_ll_cc7;\n\tif (ll & FC_LL_VL || ll & FC_LL_L) {\n\t\t/* Long range, track length. */\n\t\tha->flags.lr_detected = 1;\n\n\t\tif (a->length_km > 5 || a->length_100m > 50)\n\t\t\tha->lr_distance = LR_DISTANCE_10K;\n\t\telse\n\t\t\tha->lr_distance = LR_DISTANCE_5K;\n\t}\n\nout:\n\tql_dbg(ql_dbg_async, vha, 0x507b,\n\t    \"SFP detect: %s-Range SFP %s (nvr=%x ll=%x lr=%x lrd=%x).\\n\",\n\t    types[ha->flags.lr_detected],\n\t    ha->flags.lr_detected ? lengths[ha->lr_distance] :\n\t       lengths[LR_DISTANCE_UNKNOWN],\n\t    used_nvram, ll, ha->flags.lr_detected, ha->lr_distance);\n\treturn ha->flags.lr_detected;\n}\n\nvoid qla_init_iocb_limit(scsi_qla_host_t *vha)\n{\n\tu16 i, num_qps;\n\tu32 limit;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tnum_qps = ha->num_qpairs + 1;\n\tlimit = (ha->orig_fw_iocb_count * QLA_IOCB_PCT_LIMIT) / 100;\n\n\tha->base_qpair->fwres.iocbs_total = ha->orig_fw_iocb_count;\n\tha->base_qpair->fwres.iocbs_limit = limit;\n\tha->base_qpair->fwres.iocbs_qp_limit = limit / num_qps;\n\tha->base_qpair->fwres.iocbs_used = 0;\n\tfor (i = 0; i < ha->max_qpairs; i++) {\n\t\tif (ha->queue_pair_map[i])  {\n\t\t\tha->queue_pair_map[i]->fwres.iocbs_total =\n\t\t\t\tha->orig_fw_iocb_count;\n\t\t\tha->queue_pair_map[i]->fwres.iocbs_limit = limit;\n\t\t\tha->queue_pair_map[i]->fwres.iocbs_qp_limit =\n\t\t\t\tlimit / num_qps;\n\t\t\tha->queue_pair_map[i]->fwres.iocbs_used = 0;\n\t\t}\n\t}\n}\n\n/**\n * qla2x00_setup_chip() - Load and start RISC firmware.\n * @vha: HA context\n *\n * Returns 0 on success.\n */\nstatic int\nqla2x00_setup_chip(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tuint32_t srisc_address = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\tunsigned long flags;\n\tuint16_t fw_major_version;\n\tint done_once = 0;\n\n\tif (IS_P3P_TYPE(ha)) {\n\t\trval = ha->isp_ops->load_risc(vha, &srisc_address);\n\t\tif (rval == QLA_SUCCESS) {\n\t\t\tqla2x00_stop_firmware(vha);\n\t\t\tgoto enable_82xx_npiv;\n\t\t} else\n\t\t\tgoto failed;\n\t}\n\n\tif (!IS_FWI2_CAPABLE(ha) && !IS_QLA2100(ha) && !IS_QLA2200(ha)) {\n\t\t/* Disable SRAM, Instruction RAM and GP RAM parity.  */\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\twrt_reg_word(&reg->hccr, (HCCR_ENABLE_PARITY + 0x0));\n\t\trd_reg_word(&reg->hccr);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t}\n\n\tqla81xx_mpi_sync(vha);\n\nexecute_fw_with_lr:\n\t/* Load firmware sequences */\n\trval = ha->isp_ops->load_risc(vha, &srisc_address);\n\tif (rval == QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_init, vha, 0x00c9,\n\t\t    \"Verifying Checksum of loaded RISC code.\\n\");\n\n\t\trval = qla2x00_verify_checksum(vha, srisc_address);\n\t\tif (rval == QLA_SUCCESS) {\n\t\t\t/* Start firmware execution. */\n\t\t\tql_dbg(ql_dbg_init, vha, 0x00ca,\n\t\t\t    \"Starting firmware.\\n\");\n\n\t\t\tif (ql2xexlogins)\n\t\t\t\tha->flags.exlogins_enabled = 1;\n\n\t\t\tif (qla_is_exch_offld_enabled(vha))\n\t\t\t\tha->flags.exchoffld_enabled = 1;\n\n\t\t\trval = qla2x00_execute_fw(vha, srisc_address);\n\t\t\t/* Retrieve firmware information. */\n\t\t\tif (rval == QLA_SUCCESS) {\n\t\t\t\t/* Enable BPM support? */\n\t\t\t\tif (!done_once++ && qla24xx_detect_sfp(vha)) {\n\t\t\t\t\tql_dbg(ql_dbg_init, vha, 0x00ca,\n\t\t\t\t\t    \"Re-starting firmware -- BPM.\\n\");\n\t\t\t\t\t/* Best-effort - re-init. */\n\t\t\t\t\tha->isp_ops->reset_chip(vha);\n\t\t\t\t\tha->isp_ops->chip_diag(vha);\n\t\t\t\t\tgoto execute_fw_with_lr;\n\t\t\t\t}\n\n\t\t\t\tif (IS_ZIO_THRESHOLD_CAPABLE(ha))\n\t\t\t\t\tqla27xx_set_zio_threshold(vha,\n\t\t\t\t\t    ha->last_zio_threshold);\n\n\t\t\t\trval = qla2x00_set_exlogins_buffer(vha);\n\t\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\t\tgoto failed;\n\n\t\t\t\trval = qla2x00_set_exchoffld_buffer(vha);\n\t\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\t\tgoto failed;\n\nenable_82xx_npiv:\n\t\t\t\tfw_major_version = ha->fw_major_version;\n\t\t\t\tif (IS_P3P_TYPE(ha))\n\t\t\t\t\tqla82xx_check_md_needed(vha);\n\t\t\t\telse\n\t\t\t\t\trval = qla2x00_get_fw_version(vha);\n\t\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\t\tgoto failed;\n\t\t\t\tha->flags.npiv_supported = 0;\n\t\t\t\tif (IS_QLA2XXX_MIDTYPE(ha) &&\n\t\t\t\t\t (ha->fw_attributes & BIT_2)) {\n\t\t\t\t\tha->flags.npiv_supported = 1;\n\t\t\t\t\tif ((!ha->max_npiv_vports) ||\n\t\t\t\t\t    ((ha->max_npiv_vports + 1) %\n\t\t\t\t\t    MIN_MULTI_ID_FABRIC))\n\t\t\t\t\t\tha->max_npiv_vports =\n\t\t\t\t\t\t    MIN_MULTI_ID_FABRIC - 1;\n\t\t\t\t}\n\t\t\t\tqla2x00_get_resource_cnts(vha);\n\t\t\t\tqla_init_iocb_limit(vha);\n\n\t\t\t\t/*\n\t\t\t\t * Allocate the array of outstanding commands\n\t\t\t\t * now that we know the firmware resources.\n\t\t\t\t */\n\t\t\t\trval = qla2x00_alloc_outstanding_cmds(ha,\n\t\t\t\t    vha->req);\n\t\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\t\tgoto failed;\n\n\t\t\t\tif (!fw_major_version && !(IS_P3P_TYPE(ha)))\n\t\t\t\t\tqla2x00_alloc_offload_mem(vha);\n\n\t\t\t\tif (ql2xallocfwdump && !(IS_P3P_TYPE(ha)))\n\t\t\t\t\tqla2x00_alloc_fw_dump(vha);\n\n\t\t\t} else {\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t} else {\n\t\t\tql_log(ql_log_fatal, vha, 0x00cd,\n\t\t\t    \"ISP Firmware failed checksum.\\n\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\t/* Enable PUREX PASSTHRU */\n\t\tif (ql2xrdpenable || ha->flags.scm_supported_f)\n\t\t\tqla25xx_set_els_cmds_supported(vha);\n\t} else\n\t\tgoto failed;\n\n\tif (!IS_FWI2_CAPABLE(ha) && !IS_QLA2100(ha) && !IS_QLA2200(ha)) {\n\t\t/* Enable proper parity. */\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\tif (IS_QLA2300(ha))\n\t\t\t/* SRAM parity */\n\t\t\twrt_reg_word(&reg->hccr, HCCR_ENABLE_PARITY + 0x1);\n\t\telse\n\t\t\t/* SRAM, Instruction RAM and GP RAM parity */\n\t\t\twrt_reg_word(&reg->hccr, HCCR_ENABLE_PARITY + 0x7);\n\t\trd_reg_word(&reg->hccr);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t}\n\n\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\tha->flags.fac_supported = 1;\n\telse if (rval == QLA_SUCCESS && IS_FAC_REQUIRED(ha)) {\n\t\tuint32_t size;\n\n\t\trval = qla81xx_fac_get_sector_size(vha, &size);\n\t\tif (rval == QLA_SUCCESS) {\n\t\t\tha->flags.fac_supported = 1;\n\t\t\tha->fdt_block_size = size << 2;\n\t\t} else {\n\t\t\tql_log(ql_log_warn, vha, 0x00ce,\n\t\t\t    \"Unsupported FAC firmware (%d.%02d.%02d).\\n\",\n\t\t\t    ha->fw_major_version, ha->fw_minor_version,\n\t\t\t    ha->fw_subminor_version);\n\n\t\t\tif (IS_QLA83XX(ha) || IS_QLA27XX(ha) ||\n\t\t\t    IS_QLA28XX(ha)) {\n\t\t\t\tha->flags.fac_supported = 0;\n\t\t\t\trval = QLA_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\nfailed:\n\tif (rval) {\n\t\tql_log(ql_log_fatal, vha, 0x00cf,\n\t\t    \"Setup chip ****FAILED****.\\n\");\n\t}\n\n\treturn (rval);\n}\n\n/**\n * qla2x00_init_response_q_entries() - Initializes response queue entries.\n * @rsp: response queue\n *\n * Beginning of request ring has initialization control block already built\n * by nvram config routine.\n *\n * Returns 0 on success.\n */\nvoid\nqla2x00_init_response_q_entries(struct rsp_que *rsp)\n{\n\tuint16_t cnt;\n\tresponse_t *pkt;\n\n\trsp->ring_ptr = rsp->ring;\n\trsp->ring_index    = 0;\n\trsp->status_srb = NULL;\n\tpkt = rsp->ring_ptr;\n\tfor (cnt = 0; cnt < rsp->length; cnt++) {\n\t\tpkt->signature = RESPONSE_PROCESSED;\n\t\tpkt++;\n\t}\n}\n\n/**\n * qla2x00_update_fw_options() - Read and process firmware options.\n * @vha: HA context\n *\n * Returns 0 on success.\n */\nvoid\nqla2x00_update_fw_options(scsi_qla_host_t *vha)\n{\n\tuint16_t swing, emphasis, tx_sens, rx_sens;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tmemset(ha->fw_options, 0, sizeof(ha->fw_options));\n\tqla2x00_get_fw_options(vha, ha->fw_options);\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha))\n\t\treturn;\n\n\t/* Serial Link options. */\n\tql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x0115,\n\t    \"Serial link options.\\n\");\n\tql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0109,\n\t    ha->fw_seriallink_options, sizeof(ha->fw_seriallink_options));\n\n\tha->fw_options[1] &= ~FO1_SET_EMPHASIS_SWING;\n\tif (ha->fw_seriallink_options[3] & BIT_2) {\n\t\tha->fw_options[1] |= FO1_SET_EMPHASIS_SWING;\n\n\t\t/*  1G settings */\n\t\tswing = ha->fw_seriallink_options[2] & (BIT_2 | BIT_1 | BIT_0);\n\t\temphasis = (ha->fw_seriallink_options[2] &\n\t\t    (BIT_4 | BIT_3)) >> 3;\n\t\ttx_sens = ha->fw_seriallink_options[0] &\n\t\t    (BIT_3 | BIT_2 | BIT_1 | BIT_0);\n\t\trx_sens = (ha->fw_seriallink_options[0] &\n\t\t    (BIT_7 | BIT_6 | BIT_5 | BIT_4)) >> 4;\n\t\tha->fw_options[10] = (emphasis << 14) | (swing << 8);\n\t\tif (IS_QLA2300(ha) || IS_QLA2312(ha) || IS_QLA6312(ha)) {\n\t\t\tif (rx_sens == 0x0)\n\t\t\t\trx_sens = 0x3;\n\t\t\tha->fw_options[10] |= (tx_sens << 4) | rx_sens;\n\t\t} else if (IS_QLA2322(ha) || IS_QLA6322(ha))\n\t\t\tha->fw_options[10] |= BIT_5 |\n\t\t\t    ((rx_sens & (BIT_1 | BIT_0)) << 2) |\n\t\t\t    (tx_sens & (BIT_1 | BIT_0));\n\n\t\t/*  2G settings */\n\t\tswing = (ha->fw_seriallink_options[2] &\n\t\t    (BIT_7 | BIT_6 | BIT_5)) >> 5;\n\t\temphasis = ha->fw_seriallink_options[3] & (BIT_1 | BIT_0);\n\t\ttx_sens = ha->fw_seriallink_options[1] &\n\t\t    (BIT_3 | BIT_2 | BIT_1 | BIT_0);\n\t\trx_sens = (ha->fw_seriallink_options[1] &\n\t\t    (BIT_7 | BIT_6 | BIT_5 | BIT_4)) >> 4;\n\t\tha->fw_options[11] = (emphasis << 14) | (swing << 8);\n\t\tif (IS_QLA2300(ha) || IS_QLA2312(ha) || IS_QLA6312(ha)) {\n\t\t\tif (rx_sens == 0x0)\n\t\t\t\trx_sens = 0x3;\n\t\t\tha->fw_options[11] |= (tx_sens << 4) | rx_sens;\n\t\t} else if (IS_QLA2322(ha) || IS_QLA6322(ha))\n\t\t\tha->fw_options[11] |= BIT_5 |\n\t\t\t    ((rx_sens & (BIT_1 | BIT_0)) << 2) |\n\t\t\t    (tx_sens & (BIT_1 | BIT_0));\n\t}\n\n\t/* FCP2 options. */\n\t/*  Return command IOCBs without waiting for an ABTS to complete. */\n\tha->fw_options[3] |= BIT_13;\n\n\t/* LED scheme. */\n\tif (ha->flags.enable_led_scheme)\n\t\tha->fw_options[2] |= BIT_12;\n\n\t/* Detect ISP6312. */\n\tif (IS_QLA6312(ha))\n\t\tha->fw_options[2] |= BIT_13;\n\n\t/* Set Retry FLOGI in case of P2P connection */\n\tif (ha->operating_mode == P2P) {\n\t\tha->fw_options[2] |= BIT_3;\n\t\tql_dbg(ql_dbg_disc, vha, 0x2100,\n\t\t    \"(%s): Setting FLOGI retry BIT in fw_options[2]: 0x%x\\n\",\n\t\t\t__func__, ha->fw_options[2]);\n\t}\n\n\t/* Update firmware options. */\n\tqla2x00_set_fw_options(vha, ha->fw_options);\n}\n\nvoid\nqla24xx_update_fw_options(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (IS_P3P_TYPE(ha))\n\t\treturn;\n\n\t/*  Hold status IOCBs until ABTS response received. */\n\tif (ql2xfwholdabts)\n\t\tha->fw_options[3] |= BIT_12;\n\n\t/* Set Retry FLOGI in case of P2P connection */\n\tif (ha->operating_mode == P2P) {\n\t\tha->fw_options[2] |= BIT_3;\n\t\tql_dbg(ql_dbg_disc, vha, 0x2101,\n\t\t    \"(%s): Setting FLOGI retry BIT in fw_options[2]: 0x%x\\n\",\n\t\t\t__func__, ha->fw_options[2]);\n\t}\n\n\t/* Move PUREX, ABTS RX & RIDA to ATIOQ */\n\tif (ql2xmvasynctoatio &&\n\t    (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))) {\n\t\tif (qla_tgt_mode_enabled(vha) ||\n\t\t    qla_dual_mode_enabled(vha))\n\t\t\tha->fw_options[2] |= BIT_11;\n\t\telse\n\t\t\tha->fw_options[2] &= ~BIT_11;\n\t}\n\n\tif (IS_QLA25XX(ha) || IS_QLA83XX(ha) || IS_QLA27XX(ha) ||\n\t    IS_QLA28XX(ha)) {\n\t\t/*\n\t\t * Tell FW to track each exchange to prevent\n\t\t * driver from using stale exchange.\n\t\t */\n\t\tif (qla_tgt_mode_enabled(vha) ||\n\t\t    qla_dual_mode_enabled(vha))\n\t\t\tha->fw_options[2] |= BIT_4;\n\t\telse\n\t\t\tha->fw_options[2] &= ~BIT_4;\n\n\t\t/* Reserve 1/2 of emergency exchanges for ELS.*/\n\t\tif (qla2xuseresexchforels)\n\t\t\tha->fw_options[2] |= BIT_8;\n\t\telse\n\t\t\tha->fw_options[2] &= ~BIT_8;\n\t}\n\n\tif (ql2xrdpenable || ha->flags.scm_supported_f)\n\t\tha->fw_options[1] |= ADD_FO1_ENABLE_PUREX_IOCB;\n\n\t/* Enable Async 8130/8131 events -- transceiver insertion/removal */\n\tif (IS_BPM_RANGE_CAPABLE(ha))\n\t\tha->fw_options[3] |= BIT_10;\n\n\tql_dbg(ql_dbg_init, vha, 0x00e8,\n\t    \"%s, add FW options 1-3 = 0x%04x 0x%04x 0x%04x mode %x\\n\",\n\t    __func__, ha->fw_options[1], ha->fw_options[2],\n\t    ha->fw_options[3], vha->host->active_mode);\n\n\tif (ha->fw_options[1] || ha->fw_options[2] || ha->fw_options[3])\n\t\tqla2x00_set_fw_options(vha, ha->fw_options);\n\n\t/* Update Serial Link options. */\n\tif ((le16_to_cpu(ha->fw_seriallink_options24[0]) & BIT_0) == 0)\n\t\treturn;\n\n\trval = qla2x00_set_serdes_params(vha,\n\t    le16_to_cpu(ha->fw_seriallink_options24[1]),\n\t    le16_to_cpu(ha->fw_seriallink_options24[2]),\n\t    le16_to_cpu(ha->fw_seriallink_options24[3]));\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x0104,\n\t\t    \"Unable to update Serial Link options (%x).\\n\", rval);\n\t}\n}\n\nvoid\nqla2x00_config_rings(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\tstruct req_que *req = ha->req_q_map[0];\n\tstruct rsp_que *rsp = ha->rsp_q_map[0];\n\n\t/* Setup ring parameters in initialization control block. */\n\tha->init_cb->request_q_outpointer = cpu_to_le16(0);\n\tha->init_cb->response_q_inpointer = cpu_to_le16(0);\n\tha->init_cb->request_q_length = cpu_to_le16(req->length);\n\tha->init_cb->response_q_length = cpu_to_le16(rsp->length);\n\tput_unaligned_le64(req->dma, &ha->init_cb->request_q_address);\n\tput_unaligned_le64(rsp->dma, &ha->init_cb->response_q_address);\n\n\twrt_reg_word(ISP_REQ_Q_IN(ha, reg), 0);\n\twrt_reg_word(ISP_REQ_Q_OUT(ha, reg), 0);\n\twrt_reg_word(ISP_RSP_Q_IN(ha, reg), 0);\n\twrt_reg_word(ISP_RSP_Q_OUT(ha, reg), 0);\n\trd_reg_word(ISP_RSP_Q_OUT(ha, reg));\t\t/* PCI Posting. */\n}\n\nvoid\nqla24xx_config_rings(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tdevice_reg_t *reg = ISP_QUE_REG(ha, 0);\n\tstruct device_reg_2xxx __iomem *ioreg = &ha->iobase->isp;\n\tstruct qla_msix_entry *msix;\n\tstruct init_cb_24xx *icb;\n\tuint16_t rid = 0;\n\tstruct req_que *req = ha->req_q_map[0];\n\tstruct rsp_que *rsp = ha->rsp_q_map[0];\n\n\t/* Setup ring parameters in initialization control block. */\n\ticb = (struct init_cb_24xx *)ha->init_cb;\n\ticb->request_q_outpointer = cpu_to_le16(0);\n\ticb->response_q_inpointer = cpu_to_le16(0);\n\ticb->request_q_length = cpu_to_le16(req->length);\n\ticb->response_q_length = cpu_to_le16(rsp->length);\n\tput_unaligned_le64(req->dma, &icb->request_q_address);\n\tput_unaligned_le64(rsp->dma, &icb->response_q_address);\n\n\t/* Setup ATIO queue dma pointers for target mode */\n\ticb->atio_q_inpointer = cpu_to_le16(0);\n\ticb->atio_q_length = cpu_to_le16(ha->tgt.atio_q_length);\n\tput_unaligned_le64(ha->tgt.atio_dma, &icb->atio_q_address);\n\n\tif (IS_SHADOW_REG_CAPABLE(ha))\n\t\ticb->firmware_options_2 |= cpu_to_le32(BIT_30|BIT_29);\n\n\tif (ha->mqenable || IS_QLA83XX(ha) || IS_QLA27XX(ha) ||\n\t    IS_QLA28XX(ha)) {\n\t\ticb->qos = cpu_to_le16(QLA_DEFAULT_QUE_QOS);\n\t\ticb->rid = cpu_to_le16(rid);\n\t\tif (ha->flags.msix_enabled) {\n\t\t\tmsix = &ha->msix_entries[1];\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0019,\n\t\t\t    \"Registering vector 0x%x for base que.\\n\",\n\t\t\t    msix->entry);\n\t\t\ticb->msix = cpu_to_le16(msix->entry);\n\t\t}\n\t\t/* Use alternate PCI bus number */\n\t\tif (MSB(rid))\n\t\t\ticb->firmware_options_2 |= cpu_to_le32(BIT_19);\n\t\t/* Use alternate PCI devfn */\n\t\tif (LSB(rid))\n\t\t\ticb->firmware_options_2 |= cpu_to_le32(BIT_18);\n\n\t\t/* Use Disable MSIX Handshake mode for capable adapters */\n\t\tif ((ha->fw_attributes & BIT_6) && (IS_MSIX_NACK_CAPABLE(ha)) &&\n\t\t    (ha->flags.msix_enabled)) {\n\t\t\ticb->firmware_options_2 &= cpu_to_le32(~BIT_22);\n\t\t\tha->flags.disable_msix_handshake = 1;\n\t\t\tql_dbg(ql_dbg_init, vha, 0x00fe,\n\t\t\t    \"MSIX Handshake Disable Mode turned on.\\n\");\n\t\t} else {\n\t\t\ticb->firmware_options_2 |= cpu_to_le32(BIT_22);\n\t\t}\n\t\ticb->firmware_options_2 |= cpu_to_le32(BIT_23);\n\n\t\twrt_reg_dword(&reg->isp25mq.req_q_in, 0);\n\t\twrt_reg_dword(&reg->isp25mq.req_q_out, 0);\n\t\twrt_reg_dword(&reg->isp25mq.rsp_q_in, 0);\n\t\twrt_reg_dword(&reg->isp25mq.rsp_q_out, 0);\n\t} else {\n\t\twrt_reg_dword(&reg->isp24.req_q_in, 0);\n\t\twrt_reg_dword(&reg->isp24.req_q_out, 0);\n\t\twrt_reg_dword(&reg->isp24.rsp_q_in, 0);\n\t\twrt_reg_dword(&reg->isp24.rsp_q_out, 0);\n\t}\n\n\tqlt_24xx_config_rings(vha);\n\n\t/* If the user has configured the speed, set it here */\n\tif (ha->set_data_rate) {\n\t\tql_dbg(ql_dbg_init, vha, 0x00fd,\n\t\t    \"Speed set by user : %s Gbps \\n\",\n\t\t    qla2x00_get_link_speed_str(ha, ha->set_data_rate));\n\t\ticb->firmware_options_3 = cpu_to_le32(ha->set_data_rate << 13);\n\t}\n\n\t/* PCI posting */\n\trd_reg_word(&ioreg->hccr);\n}\n\n/**\n * qla2x00_init_rings() - Initializes firmware.\n * @vha: HA context\n *\n * Beginning of request ring has initialization control block already built\n * by nvram config routine.\n *\n * Returns 0 on success.\n */\nint\nqla2x00_init_rings(scsi_qla_host_t *vha)\n{\n\tint\trval;\n\tunsigned long flags = 0;\n\tint cnt, que;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req;\n\tstruct rsp_que *rsp;\n\tstruct mid_init_cb_24xx *mid_init_cb =\n\t    (struct mid_init_cb_24xx *) ha->init_cb;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\t/* Clear outstanding commands array. */\n\tfor (que = 0; que < ha->max_req_queues; que++) {\n\t\treq = ha->req_q_map[que];\n\t\tif (!req || !test_bit(que, ha->req_qid_map))\n\t\t\tcontinue;\n\t\treq->out_ptr = (uint16_t *)(req->ring + req->length);\n\t\t*req->out_ptr = 0;\n\t\tfor (cnt = 1; cnt < req->num_outstanding_cmds; cnt++)\n\t\t\treq->outstanding_cmds[cnt] = NULL;\n\n\t\treq->current_outstanding_cmd = 1;\n\n\t\t/* Initialize firmware. */\n\t\treq->ring_ptr  = req->ring;\n\t\treq->ring_index    = 0;\n\t\treq->cnt      = req->length;\n\t}\n\n\tfor (que = 0; que < ha->max_rsp_queues; que++) {\n\t\trsp = ha->rsp_q_map[que];\n\t\tif (!rsp || !test_bit(que, ha->rsp_qid_map))\n\t\t\tcontinue;\n\t\trsp->in_ptr = (uint16_t *)(rsp->ring + rsp->length);\n\t\t*rsp->in_ptr = 0;\n\t\t/* Initialize response queue entries */\n\t\tif (IS_QLAFX00(ha))\n\t\t\tqlafx00_init_response_q_entries(rsp);\n\t\telse\n\t\t\tqla2x00_init_response_q_entries(rsp);\n\t}\n\n\tha->tgt.atio_ring_ptr = ha->tgt.atio_ring;\n\tha->tgt.atio_ring_index = 0;\n\t/* Initialize ATIO queue entries */\n\tqlt_init_atio_q_entries(vha);\n\n\tha->isp_ops->config_rings(vha);\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tql_dbg(ql_dbg_init, vha, 0x00d1, \"Issue init firmware.\\n\");\n\n\tif (IS_QLAFX00(ha)) {\n\t\trval = qlafx00_init_firmware(vha, ha->init_cb_size);\n\t\tgoto next_check;\n\t}\n\n\t/* Update any ISP specific firmware options before initialization. */\n\tha->isp_ops->update_fw_options(vha);\n\n\tif (ha->flags.npiv_supported) {\n\t\tif (ha->operating_mode == LOOP && !IS_CNA_CAPABLE(ha))\n\t\t\tha->max_npiv_vports = MIN_MULTI_ID_FABRIC - 1;\n\t\tmid_init_cb->count = cpu_to_le16(ha->max_npiv_vports);\n\t}\n\n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\tmid_init_cb->options = cpu_to_le16(BIT_1);\n\t\tmid_init_cb->init_cb.execution_throttle =\n\t\t    cpu_to_le16(ha->cur_fw_xcb_count);\n\t\tha->flags.dport_enabled =\n\t\t\t(le32_to_cpu(mid_init_cb->init_cb.firmware_options_1) &\n\t\t\t BIT_7) != 0;\n\t\tql_dbg(ql_dbg_init, vha, 0x0191, \"DPORT Support: %s.\\n\",\n\t\t    (ha->flags.dport_enabled) ? \"enabled\" : \"disabled\");\n\t\t/* FA-WWPN Status */\n\t\tha->flags.fawwpn_enabled =\n\t\t\t(le32_to_cpu(mid_init_cb->init_cb.firmware_options_1) &\n\t\t\t BIT_6) != 0;\n\t\tql_dbg(ql_dbg_init, vha, 0x00bc, \"FA-WWPN Support: %s.\\n\",\n\t\t    (ha->flags.fawwpn_enabled) ? \"enabled\" : \"disabled\");\n\t}\n\n\trval = qla2x00_init_firmware(vha, ha->init_cb_size);\nnext_check:\n\tif (rval) {\n\t\tql_log(ql_log_fatal, vha, 0x00d2,\n\t\t    \"Init Firmware **** FAILED ****.\\n\");\n\t} else {\n\t\tql_dbg(ql_dbg_init, vha, 0x00d3,\n\t\t    \"Init Firmware -- success.\\n\");\n\t\tQLA_FW_STARTED(ha);\n\t\tvha->u_ql2xexchoffld = vha->u_ql2xiniexchg = 0;\n\t}\n\n\treturn (rval);\n}\n\n/**\n * qla2x00_fw_ready() - Waits for firmware ready.\n * @vha: HA context\n *\n * Returns 0 on success.\n */\nstatic int\nqla2x00_fw_ready(scsi_qla_host_t *vha)\n{\n\tint\t\trval;\n\tunsigned long\twtime, mtime, cs84xx_time;\n\tuint16_t\tmin_wait;\t/* Minimum wait time if loop is down */\n\tuint16_t\twait_time;\t/* Wait time if loop is coming ready */\n\tuint16_t\tstate[6];\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (IS_QLAFX00(vha->hw))\n\t\treturn qlafx00_fw_ready(vha);\n\n\trval = QLA_SUCCESS;\n\n\t/* Time to wait for loop down */\n\tif (IS_P3P_TYPE(ha))\n\t\tmin_wait = 30;\n\telse\n\t\tmin_wait = 20;\n\n\t/*\n\t * Firmware should take at most one RATOV to login, plus 5 seconds for\n\t * our own processing.\n\t */\n\tif ((wait_time = (ha->retry_count*ha->login_timeout) + 5) < min_wait) {\n\t\twait_time = min_wait;\n\t}\n\n\t/* Min wait time if loop down */\n\tmtime = jiffies + (min_wait * HZ);\n\n\t/* wait time before firmware ready */\n\twtime = jiffies + (wait_time * HZ);\n\n\t/* Wait for ISP to finish LIP */\n\tif (!vha->flags.init_done)\n\t\tql_log(ql_log_info, vha, 0x801e,\n\t\t    \"Waiting for LIP to complete.\\n\");\n\n\tdo {\n\t\tmemset(state, -1, sizeof(state));\n\t\trval = qla2x00_get_firmware_state(vha, state);\n\t\tif (rval == QLA_SUCCESS) {\n\t\t\tif (state[0] < FSTATE_LOSS_OF_SYNC) {\n\t\t\t\tvha->device_flags &= ~DFLG_NO_CABLE;\n\t\t\t}\n\t\t\tif (IS_QLA84XX(ha) && state[0] != FSTATE_READY) {\n\t\t\t\tql_dbg(ql_dbg_taskm, vha, 0x801f,\n\t\t\t\t    \"fw_state=%x 84xx=%x.\\n\", state[0],\n\t\t\t\t    state[2]);\n\t\t\t\tif ((state[2] & FSTATE_LOGGED_IN) &&\n\t\t\t\t     (state[2] & FSTATE_WAITING_FOR_VERIFY)) {\n\t\t\t\t\tql_dbg(ql_dbg_taskm, vha, 0x8028,\n\t\t\t\t\t    \"Sending verify iocb.\\n\");\n\n\t\t\t\t\tcs84xx_time = jiffies;\n\t\t\t\t\trval = qla84xx_init_chip(vha);\n\t\t\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\t\t\tql_log(ql_log_warn,\n\t\t\t\t\t\t    vha, 0x8007,\n\t\t\t\t\t\t    \"Init chip failed.\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Add time taken to initialize. */\n\t\t\t\t\tcs84xx_time = jiffies - cs84xx_time;\n\t\t\t\t\twtime += cs84xx_time;\n\t\t\t\t\tmtime += cs84xx_time;\n\t\t\t\t\tql_dbg(ql_dbg_taskm, vha, 0x8008,\n\t\t\t\t\t    \"Increasing wait time by %ld. \"\n\t\t\t\t\t    \"New time %ld.\\n\", cs84xx_time,\n\t\t\t\t\t    wtime);\n\t\t\t\t}\n\t\t\t} else if (state[0] == FSTATE_READY) {\n\t\t\t\tql_dbg(ql_dbg_taskm, vha, 0x8037,\n\t\t\t\t    \"F/W Ready - OK.\\n\");\n\n\t\t\t\tqla2x00_get_retry_cnt(vha, &ha->retry_count,\n\t\t\t\t    &ha->login_timeout, &ha->r_a_tov);\n\n\t\t\t\trval = QLA_SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trval = QLA_FUNCTION_FAILED;\n\n\t\t\tif (atomic_read(&vha->loop_down_timer) &&\n\t\t\t    state[0] != FSTATE_READY) {\n\t\t\t\t/* Loop down. Timeout on min_wait for states\n\t\t\t\t * other than Wait for Login.\n\t\t\t\t */\n\t\t\t\tif (time_after_eq(jiffies, mtime)) {\n\t\t\t\t\tql_log(ql_log_info, vha, 0x8038,\n\t\t\t\t\t    \"Cable is unplugged...\\n\");\n\n\t\t\t\t\tvha->device_flags |= DFLG_NO_CABLE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* Mailbox cmd failed. Timeout on min_wait. */\n\t\t\tif (time_after_eq(jiffies, mtime) ||\n\t\t\t\tha->flags.isp82xx_fw_hung)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (time_after_eq(jiffies, wtime))\n\t\t\tbreak;\n\n\t\t/* Delay for a while */\n\t\tmsleep(500);\n\t} while (1);\n\n\tql_dbg(ql_dbg_taskm, vha, 0x803a,\n\t    \"fw_state=%x (%x, %x, %x, %x %x) curr time=%lx.\\n\", state[0],\n\t    state[1], state[2], state[3], state[4], state[5], jiffies);\n\n\tif (rval && !(vha->device_flags & DFLG_NO_CABLE)) {\n\t\tql_log(ql_log_warn, vha, 0x803b,\n\t\t    \"Firmware ready **** FAILED ****.\\n\");\n\t}\n\n\treturn (rval);\n}\n\n/*\n*  qla2x00_configure_hba\n*      Setup adapter context.\n*\n* Input:\n*      ha = adapter state pointer.\n*\n* Returns:\n*      0 = success\n*\n* Context:\n*      Kernel context.\n*/\nstatic int\nqla2x00_configure_hba(scsi_qla_host_t *vha)\n{\n\tint       rval;\n\tuint16_t      loop_id;\n\tuint16_t      topo;\n\tuint16_t      sw_cap;\n\tuint8_t       al_pa;\n\tuint8_t       area;\n\tuint8_t       domain;\n\tchar\t\tconnect_type[22];\n\tstruct qla_hw_data *ha = vha->hw;\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\tport_id_t id;\n\tunsigned long flags;\n\n\t/* Get host addresses. */\n\trval = qla2x00_get_adapter_id(vha,\n\t    &loop_id, &al_pa, &area, &domain, &topo, &sw_cap);\n\tif (rval != QLA_SUCCESS) {\n\t\tif (LOOP_TRANSITION(vha) || atomic_read(&ha->loop_down_timer) ||\n\t\t    IS_CNA_CAPABLE(ha) ||\n\t\t    (rval == QLA_COMMAND_ERROR && loop_id == 0x7)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2008,\n\t\t\t    \"Loop is in a transition state.\\n\");\n\t\t} else {\n\t\t\tql_log(ql_log_warn, vha, 0x2009,\n\t\t\t    \"Unable to get host loop ID.\\n\");\n\t\t\tif (IS_FWI2_CAPABLE(ha) && (vha == base_vha) &&\n\t\t\t    (rval == QLA_COMMAND_ERROR && loop_id == 0x1b)) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x1151,\n\t\t\t\t    \"Doing link init.\\n\");\n\t\t\t\tif (qla24xx_link_initialize(vha) == QLA_SUCCESS)\n\t\t\t\t\treturn rval;\n\t\t\t}\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t}\n\t\treturn (rval);\n\t}\n\n\tif (topo == 4) {\n\t\tql_log(ql_log_info, vha, 0x200a,\n\t\t    \"Cannot get topology - retrying.\\n\");\n\t\treturn (QLA_FUNCTION_FAILED);\n\t}\n\n\tvha->loop_id = loop_id;\n\n\t/* initialize */\n\tha->min_external_loopid = SNS_FIRST_LOOP_ID;\n\tha->operating_mode = LOOP;\n\tha->switch_cap = 0;\n\n\tswitch (topo) {\n\tcase 0:\n\t\tql_dbg(ql_dbg_disc, vha, 0x200b, \"HBA in NL topology.\\n\");\n\t\tha->current_topology = ISP_CFG_NL;\n\t\tstrcpy(connect_type, \"(Loop)\");\n\t\tbreak;\n\n\tcase 1:\n\t\tql_dbg(ql_dbg_disc, vha, 0x200c, \"HBA in FL topology.\\n\");\n\t\tha->switch_cap = sw_cap;\n\t\tha->current_topology = ISP_CFG_FL;\n\t\tstrcpy(connect_type, \"(FL_Port)\");\n\t\tbreak;\n\n\tcase 2:\n\t\tql_dbg(ql_dbg_disc, vha, 0x200d, \"HBA in N P2P topology.\\n\");\n\t\tha->operating_mode = P2P;\n\t\tha->current_topology = ISP_CFG_N;\n\t\tstrcpy(connect_type, \"(N_Port-to-N_Port)\");\n\t\tbreak;\n\n\tcase 3:\n\t\tql_dbg(ql_dbg_disc, vha, 0x200e, \"HBA in F P2P topology.\\n\");\n\t\tha->switch_cap = sw_cap;\n\t\tha->operating_mode = P2P;\n\t\tha->current_topology = ISP_CFG_F;\n\t\tstrcpy(connect_type, \"(F_Port)\");\n\t\tbreak;\n\n\tdefault:\n\t\tql_dbg(ql_dbg_disc, vha, 0x200f,\n\t\t    \"HBA in unknown topology %x, using NL.\\n\", topo);\n\t\tha->current_topology = ISP_CFG_NL;\n\t\tstrcpy(connect_type, \"(Loop)\");\n\t\tbreak;\n\t}\n\n\t/* Save Host port and loop ID. */\n\t/* byte order - Big Endian */\n\tid.b.domain = domain;\n\tid.b.area = area;\n\tid.b.al_pa = al_pa;\n\tid.b.rsvd_1 = 0;\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tif (!(topo == 2 && ha->flags.n2n_bigger))\n\t\tqlt_update_host_map(vha, id);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tif (!vha->flags.init_done)\n\t\tql_log(ql_log_info, vha, 0x2010,\n\t\t    \"Topology - %s, Host Loop address 0x%x.\\n\",\n\t\t    connect_type, vha->loop_id);\n\n\treturn(rval);\n}\n\ninline void\nqla2x00_set_model_info(scsi_qla_host_t *vha, uint8_t *model, size_t len,\n\t\t       const char *def)\n{\n\tchar *st, *en;\n\tuint16_t index;\n\tuint64_t zero[2] = { 0 };\n\tstruct qla_hw_data *ha = vha->hw;\n\tint use_tbl = !IS_QLA24XX_TYPE(ha) && !IS_QLA25XX(ha) &&\n\t    !IS_CNA_CAPABLE(ha) && !IS_QLA2031(ha);\n\n\tif (len > sizeof(zero))\n\t\tlen = sizeof(zero);\n\tif (memcmp(model, &zero, len) != 0) {\n\t\tmemcpy(ha->model_number, model, len);\n\t\tst = en = ha->model_number;\n\t\ten += len - 1;\n\t\twhile (en > st) {\n\t\t\tif (*en != 0x20 && *en != 0x00)\n\t\t\t\tbreak;\n\t\t\t*en-- = '\\0';\n\t\t}\n\n\t\tindex = (ha->pdev->subsystem_device & 0xff);\n\t\tif (use_tbl &&\n\t\t    ha->pdev->subsystem_vendor == PCI_VENDOR_ID_QLOGIC &&\n\t\t    index < QLA_MODEL_NAMES)\n\t\t\tstrlcpy(ha->model_desc,\n\t\t\t    qla2x00_model_name[index * 2 + 1],\n\t\t\t    sizeof(ha->model_desc));\n\t} else {\n\t\tindex = (ha->pdev->subsystem_device & 0xff);\n\t\tif (use_tbl &&\n\t\t    ha->pdev->subsystem_vendor == PCI_VENDOR_ID_QLOGIC &&\n\t\t    index < QLA_MODEL_NAMES) {\n\t\t\tstrlcpy(ha->model_number,\n\t\t\t\tqla2x00_model_name[index * 2],\n\t\t\t\tsizeof(ha->model_number));\n\t\t\tstrlcpy(ha->model_desc,\n\t\t\t    qla2x00_model_name[index * 2 + 1],\n\t\t\t    sizeof(ha->model_desc));\n\t\t} else {\n\t\t\tstrlcpy(ha->model_number, def,\n\t\t\t\tsizeof(ha->model_number));\n\t\t}\n\t}\n\tif (IS_FWI2_CAPABLE(ha))\n\t\tqla2xxx_get_vpd_field(vha, \"\\x82\", ha->model_desc,\n\t\t    sizeof(ha->model_desc));\n}\n\n/* On sparc systems, obtain port and node WWN from firmware\n * properties.\n */\nstatic void qla2xxx_nvram_wwn_from_ofw(scsi_qla_host_t *vha, nvram_t *nv)\n{\n#ifdef CONFIG_SPARC\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct pci_dev *pdev = ha->pdev;\n\tstruct device_node *dp = pci_device_to_OF_node(pdev);\n\tconst u8 *val;\n\tint len;\n\n\tval = of_get_property(dp, \"port-wwn\", &len);\n\tif (val && len >= WWN_SIZE)\n\t\tmemcpy(nv->port_name, val, WWN_SIZE);\n\n\tval = of_get_property(dp, \"node-wwn\", &len);\n\tif (val && len >= WWN_SIZE)\n\t\tmemcpy(nv->node_name, val, WWN_SIZE);\n#endif\n}\n\n/*\n* NVRAM configuration for ISP 2xxx\n*\n* Input:\n*      ha                = adapter block pointer.\n*\n* Output:\n*      initialization control block in response_ring\n*      host adapters parameters in host adapter block\n*\n* Returns:\n*      0 = success.\n*/\nint\nqla2x00_nvram_config(scsi_qla_host_t *vha)\n{\n\tint             rval;\n\tuint8_t         chksum = 0;\n\tuint16_t        cnt;\n\tuint8_t         *dptr1, *dptr2;\n\tstruct qla_hw_data *ha = vha->hw;\n\tinit_cb_t       *icb = ha->init_cb;\n\tnvram_t         *nv = ha->nvram;\n\tuint8_t         *ptr = ha->nvram;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\trval = QLA_SUCCESS;\n\n\t/* Determine NVRAM starting address. */\n\tha->nvram_size = sizeof(*nv);\n\tha->nvram_base = 0;\n\tif (!IS_QLA2100(ha) && !IS_QLA2200(ha) && !IS_QLA2300(ha))\n\t\tif ((rd_reg_word(&reg->ctrl_status) >> 14) == 1)\n\t\t\tha->nvram_base = 0x80;\n\n\t/* Get NVRAM data and calculate checksum. */\n\tha->isp_ops->read_nvram(vha, ptr, ha->nvram_base, ha->nvram_size);\n\tfor (cnt = 0, chksum = 0; cnt < ha->nvram_size; cnt++)\n\t\tchksum += *ptr++;\n\n\tql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x010f,\n\t    \"Contents of NVRAM.\\n\");\n\tql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0110,\n\t    nv, ha->nvram_size);\n\n\t/* Bad NVRAM data, set defaults parameters. */\n\tif (chksum || memcmp(\"ISP \", nv->id, sizeof(nv->id)) ||\n\t    nv->nvram_version < 1) {\n\t\t/* Reset NVRAM data. */\n\t\tql_log(ql_log_warn, vha, 0x0064,\n\t\t    \"Inconsistent NVRAM detected: checksum=%#x id=%.4s version=%#x.\\n\",\n\t\t    chksum, nv->id, nv->nvram_version);\n\t\tql_log(ql_log_warn, vha, 0x0065,\n\t\t    \"Falling back to \"\n\t\t    \"functioning (yet invalid -- WWPN) defaults.\\n\");\n\n\t\t/*\n\t\t * Set default initialization control block.\n\t\t */\n\t\tmemset(nv, 0, ha->nvram_size);\n\t\tnv->parameter_block_version = ICB_VERSION;\n\n\t\tif (IS_QLA23XX(ha)) {\n\t\t\tnv->firmware_options[0] = BIT_2 | BIT_1;\n\t\t\tnv->firmware_options[1] = BIT_7 | BIT_5;\n\t\t\tnv->add_firmware_options[0] = BIT_5;\n\t\t\tnv->add_firmware_options[1] = BIT_5 | BIT_4;\n\t\t\tnv->frame_payload_size = cpu_to_le16(2048);\n\t\t\tnv->special_options[1] = BIT_7;\n\t\t} else if (IS_QLA2200(ha)) {\n\t\t\tnv->firmware_options[0] = BIT_2 | BIT_1;\n\t\t\tnv->firmware_options[1] = BIT_7 | BIT_5;\n\t\t\tnv->add_firmware_options[0] = BIT_5;\n\t\t\tnv->add_firmware_options[1] = BIT_5 | BIT_4;\n\t\t\tnv->frame_payload_size = cpu_to_le16(1024);\n\t\t} else if (IS_QLA2100(ha)) {\n\t\t\tnv->firmware_options[0] = BIT_3 | BIT_1;\n\t\t\tnv->firmware_options[1] = BIT_5;\n\t\t\tnv->frame_payload_size = cpu_to_le16(1024);\n\t\t}\n\n\t\tnv->max_iocb_allocation = cpu_to_le16(256);\n\t\tnv->execution_throttle = cpu_to_le16(16);\n\t\tnv->retry_count = 8;\n\t\tnv->retry_delay = 1;\n\n\t\tnv->port_name[0] = 33;\n\t\tnv->port_name[3] = 224;\n\t\tnv->port_name[4] = 139;\n\n\t\tqla2xxx_nvram_wwn_from_ofw(vha, nv);\n\n\t\tnv->login_timeout = 4;\n\n\t\t/*\n\t\t * Set default host adapter parameters\n\t\t */\n\t\tnv->host_p[1] = BIT_2;\n\t\tnv->reset_delay = 5;\n\t\tnv->port_down_retry_count = 8;\n\t\tnv->max_luns_per_target = cpu_to_le16(8);\n\t\tnv->link_down_timeout = 60;\n\n\t\trval = 1;\n\t}\n\n\t/* Reset Initialization control block */\n\tmemset(icb, 0, ha->init_cb_size);\n\n\t/*\n\t * Setup driver NVRAM options.\n\t */\n\tnv->firmware_options[0] |= (BIT_6 | BIT_1);\n\tnv->firmware_options[0] &= ~(BIT_5 | BIT_4);\n\tnv->firmware_options[1] |= (BIT_5 | BIT_0);\n\tnv->firmware_options[1] &= ~BIT_4;\n\n\tif (IS_QLA23XX(ha)) {\n\t\tnv->firmware_options[0] |= BIT_2;\n\t\tnv->firmware_options[0] &= ~BIT_3;\n\t\tnv->special_options[0] &= ~BIT_6;\n\t\tnv->add_firmware_options[1] |= BIT_5 | BIT_4;\n\n\t\tif (IS_QLA2300(ha)) {\n\t\t\tif (ha->fb_rev == FPM_2310) {\n\t\t\t\tstrcpy(ha->model_number, \"QLA2310\");\n\t\t\t} else {\n\t\t\t\tstrcpy(ha->model_number, \"QLA2300\");\n\t\t\t}\n\t\t} else {\n\t\t\tqla2x00_set_model_info(vha, nv->model_number,\n\t\t\t    sizeof(nv->model_number), \"QLA23xx\");\n\t\t}\n\t} else if (IS_QLA2200(ha)) {\n\t\tnv->firmware_options[0] |= BIT_2;\n\t\t/*\n\t\t * 'Point-to-point preferred, else loop' is not a safe\n\t\t * connection mode setting.\n\t\t */\n\t\tif ((nv->add_firmware_options[0] & (BIT_6 | BIT_5 | BIT_4)) ==\n\t\t    (BIT_5 | BIT_4)) {\n\t\t\t/* Force 'loop preferred, else point-to-point'. */\n\t\t\tnv->add_firmware_options[0] &= ~(BIT_6 | BIT_5 | BIT_4);\n\t\t\tnv->add_firmware_options[0] |= BIT_5;\n\t\t}\n\t\tstrcpy(ha->model_number, \"QLA22xx\");\n\t} else /*if (IS_QLA2100(ha))*/ {\n\t\tstrcpy(ha->model_number, \"QLA2100\");\n\t}\n\n\t/*\n\t * Copy over NVRAM RISC parameter block to initialization control block.\n\t */\n\tdptr1 = (uint8_t *)icb;\n\tdptr2 = (uint8_t *)&nv->parameter_block_version;\n\tcnt = (uint8_t *)&icb->request_q_outpointer - (uint8_t *)&icb->version;\n\twhile (cnt--)\n\t\t*dptr1++ = *dptr2++;\n\n\t/* Copy 2nd half. */\n\tdptr1 = (uint8_t *)icb->add_firmware_options;\n\tcnt = (uint8_t *)icb->reserved_3 - (uint8_t *)icb->add_firmware_options;\n\twhile (cnt--)\n\t\t*dptr1++ = *dptr2++;\n\tha->frame_payload_size = le16_to_cpu(icb->frame_payload_size);\n\t/* Use alternate WWN? */\n\tif (nv->host_p[1] & BIT_7) {\n\t\tmemcpy(icb->node_name, nv->alternate_node_name, WWN_SIZE);\n\t\tmemcpy(icb->port_name, nv->alternate_port_name, WWN_SIZE);\n\t}\n\n\t/* Prepare nodename */\n\tif ((icb->firmware_options[1] & BIT_6) == 0) {\n\t\t/*\n\t\t * Firmware will apply the following mask if the nodename was\n\t\t * not provided.\n\t\t */\n\t\tmemcpy(icb->node_name, icb->port_name, WWN_SIZE);\n\t\ticb->node_name[0] &= 0xF0;\n\t}\n\n\t/*\n\t * Set host adapter parameters.\n\t */\n\n\t/*\n\t * BIT_7 in the host-parameters section allows for modification to\n\t * internal driver logging.\n\t */\n\tif (nv->host_p[0] & BIT_7)\n\t\tql2xextended_error_logging = QL_DBG_DEFAULT1_MASK;\n\tha->flags.disable_risc_code_load = ((nv->host_p[0] & BIT_4) ? 1 : 0);\n\t/* Always load RISC code on non ISP2[12]00 chips. */\n\tif (!IS_QLA2100(ha) && !IS_QLA2200(ha))\n\t\tha->flags.disable_risc_code_load = 0;\n\tha->flags.enable_lip_reset = ((nv->host_p[1] & BIT_1) ? 1 : 0);\n\tha->flags.enable_lip_full_login = ((nv->host_p[1] & BIT_2) ? 1 : 0);\n\tha->flags.enable_target_reset = ((nv->host_p[1] & BIT_3) ? 1 : 0);\n\tha->flags.enable_led_scheme = (nv->special_options[1] & BIT_4) ? 1 : 0;\n\tha->flags.disable_serdes = 0;\n\n\tha->operating_mode =\n\t    (icb->add_firmware_options[0] & (BIT_6 | BIT_5 | BIT_4)) >> 4;\n\n\tmemcpy(ha->fw_seriallink_options, nv->seriallink_options,\n\t    sizeof(ha->fw_seriallink_options));\n\n\t/* save HBA serial number */\n\tha->serial0 = icb->port_name[5];\n\tha->serial1 = icb->port_name[6];\n\tha->serial2 = icb->port_name[7];\n\tmemcpy(vha->node_name, icb->node_name, WWN_SIZE);\n\tmemcpy(vha->port_name, icb->port_name, WWN_SIZE);\n\n\ticb->execution_throttle = cpu_to_le16(0xFFFF);\n\n\tha->retry_count = nv->retry_count;\n\n\t/* Set minimum login_timeout to 4 seconds. */\n\tif (nv->login_timeout != ql2xlogintimeout)\n\t\tnv->login_timeout = ql2xlogintimeout;\n\tif (nv->login_timeout < 4)\n\t\tnv->login_timeout = 4;\n\tha->login_timeout = nv->login_timeout;\n\n\t/* Set minimum RATOV to 100 tenths of a second. */\n\tha->r_a_tov = 100;\n\n\tha->loop_reset_delay = nv->reset_delay;\n\n\t/* Link Down Timeout = 0:\n\t *\n\t * \tWhen Port Down timer expires we will start returning\n\t *\tI/O's to OS with \"DID_NO_CONNECT\".\n\t *\n\t * Link Down Timeout != 0:\n\t *\n\t *\t The driver waits for the link to come up after link down\n\t *\t before returning I/Os to OS with \"DID_NO_CONNECT\".\n\t */\n\tif (nv->link_down_timeout == 0) {\n\t\tha->loop_down_abort_time =\n\t\t    (LOOP_DOWN_TIME - LOOP_DOWN_TIMEOUT);\n\t} else {\n\t\tha->link_down_timeout =\t nv->link_down_timeout;\n\t\tha->loop_down_abort_time =\n\t\t    (LOOP_DOWN_TIME - ha->link_down_timeout);\n\t}\n\n\t/*\n\t * Need enough time to try and get the port back.\n\t */\n\tha->port_down_retry_count = nv->port_down_retry_count;\n\tif (qlport_down_retry)\n\t\tha->port_down_retry_count = qlport_down_retry;\n\t/* Set login_retry_count */\n\tha->login_retry_count  = nv->retry_count;\n\tif (ha->port_down_retry_count == nv->port_down_retry_count &&\n\t    ha->port_down_retry_count > 3)\n\t\tha->login_retry_count = ha->port_down_retry_count;\n\telse if (ha->port_down_retry_count > (int)ha->login_retry_count)\n\t\tha->login_retry_count = ha->port_down_retry_count;\n\tif (ql2xloginretrycount)\n\t\tha->login_retry_count = ql2xloginretrycount;\n\n\ticb->lun_enables = cpu_to_le16(0);\n\ticb->command_resource_count = 0;\n\ticb->immediate_notify_resource_count = 0;\n\ticb->timeout = cpu_to_le16(0);\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha)) {\n\t\t/* Enable RIO */\n\t\ticb->firmware_options[0] &= ~BIT_3;\n\t\ticb->add_firmware_options[0] &=\n\t\t    ~(BIT_3 | BIT_2 | BIT_1 | BIT_0);\n\t\ticb->add_firmware_options[0] |= BIT_2;\n\t\ticb->response_accumulation_timer = 3;\n\t\ticb->interrupt_delay_timer = 5;\n\n\t\tvha->flags.process_response_queue = 1;\n\t} else {\n\t\t/* Enable ZIO. */\n\t\tif (!vha->flags.init_done) {\n\t\t\tha->zio_mode = icb->add_firmware_options[0] &\n\t\t\t    (BIT_3 | BIT_2 | BIT_1 | BIT_0);\n\t\t\tha->zio_timer = icb->interrupt_delay_timer ?\n\t\t\t    icb->interrupt_delay_timer : 2;\n\t\t}\n\t\ticb->add_firmware_options[0] &=\n\t\t    ~(BIT_3 | BIT_2 | BIT_1 | BIT_0);\n\t\tvha->flags.process_response_queue = 0;\n\t\tif (ha->zio_mode != QLA_ZIO_DISABLED) {\n\t\t\tha->zio_mode = QLA_ZIO_MODE_6;\n\n\t\t\tql_log(ql_log_info, vha, 0x0068,\n\t\t\t    \"ZIO mode %d enabled; timer delay (%d us).\\n\",\n\t\t\t    ha->zio_mode, ha->zio_timer * 100);\n\n\t\t\ticb->add_firmware_options[0] |= (uint8_t)ha->zio_mode;\n\t\t\ticb->interrupt_delay_timer = (uint8_t)ha->zio_timer;\n\t\t\tvha->flags.process_response_queue = 1;\n\t\t}\n\t}\n\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x0069,\n\t\t    \"NVRAM configuration failed.\\n\");\n\t}\n\treturn (rval);\n}\n\nstatic void\nqla2x00_rport_del(void *data)\n{\n\tfc_port_t *fcport = data;\n\tstruct fc_rport *rport;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(fcport->vha->host->host_lock, flags);\n\trport = fcport->drport ? fcport->drport : fcport->rport;\n\tfcport->drport = NULL;\n\tspin_unlock_irqrestore(fcport->vha->host->host_lock, flags);\n\tif (rport) {\n\t\tql_dbg(ql_dbg_disc, fcport->vha, 0x210b,\n\t\t    \"%s %8phN. rport %p roles %x\\n\",\n\t\t    __func__, fcport->port_name, rport,\n\t\t    rport->roles);\n\n\t\tfc_remote_port_delete(rport);\n\t}\n}\n\nvoid qla2x00_set_fcport_state(fc_port_t *fcport, int state)\n{\n\tint old_state;\n\n\told_state = atomic_read(&fcport->state);\n\tatomic_set(&fcport->state, state);\n\n\t/* Don't print state transitions during initial allocation of fcport */\n\tif (old_state && old_state != state) {\n\t\tql_dbg(ql_dbg_disc, fcport->vha, 0x207d,\n\t\t       \"FCPort %8phC state transitioned from %s to %s - portid=%02x%02x%02x.\\n\",\n\t\t       fcport->port_name, port_state_str[old_state],\n\t\t       port_state_str[state], fcport->d_id.b.domain,\n\t\t       fcport->d_id.b.area, fcport->d_id.b.al_pa);\n\t}\n}\n\n/**\n * qla2x00_alloc_fcport() - Allocate a generic fcport.\n * @vha: HA context\n * @flags: allocation flags\n *\n * Returns a pointer to the allocated fcport, or NULL, if none available.\n */\nfc_port_t *\nqla2x00_alloc_fcport(scsi_qla_host_t *vha, gfp_t flags)\n{\n\tfc_port_t *fcport;\n\n\tfcport = kzalloc(sizeof(fc_port_t), flags);\n\tif (!fcport)\n\t\treturn NULL;\n\n\tfcport->ct_desc.ct_sns = dma_alloc_coherent(&vha->hw->pdev->dev,\n\t\tsizeof(struct ct_sns_pkt), &fcport->ct_desc.ct_sns_dma,\n\t\tflags);\n\tif (!fcport->ct_desc.ct_sns) {\n\t\tql_log(ql_log_warn, vha, 0xd049,\n\t\t    \"Failed to allocate ct_sns request.\\n\");\n\t\tkfree(fcport);\n\t\treturn NULL;\n\t}\n\n\t/* Setup fcport template structure. */\n\tfcport->vha = vha;\n\tfcport->port_type = FCT_UNKNOWN;\n\tfcport->loop_id = FC_NO_LOOP_ID;\n\tqla2x00_set_fcport_state(fcport, FCS_UNCONFIGURED);\n\tfcport->supported_classes = FC_COS_UNSPECIFIED;\n\tfcport->fp_speed = PORT_SPEED_UNKNOWN;\n\n\tfcport->disc_state = DSC_DELETED;\n\tfcport->fw_login_state = DSC_LS_PORT_UNAVAIL;\n\tfcport->deleted = QLA_SESS_DELETED;\n\tfcport->login_retry = vha->hw->login_retry_count;\n\tfcport->chip_reset = vha->hw->base_qpair->chip_reset;\n\tfcport->logout_on_delete = 1;\n\n\tif (!fcport->ct_desc.ct_sns) {\n\t\tql_log(ql_log_warn, vha, 0xd049,\n\t\t    \"Failed to allocate ct_sns request.\\n\");\n\t\tkfree(fcport);\n\t\treturn NULL;\n\t}\n\n\tINIT_WORK(&fcport->del_work, qla24xx_delete_sess_fn);\n\tINIT_WORK(&fcport->free_work, qlt_free_session_done);\n\tINIT_WORK(&fcport->reg_work, qla_register_fcport_fn);\n\tINIT_LIST_HEAD(&fcport->gnl_entry);\n\tINIT_LIST_HEAD(&fcport->list);\n\n\tINIT_LIST_HEAD(&fcport->sess_cmd_list);\n\tspin_lock_init(&fcport->sess_cmd_lock);\n\n\treturn fcport;\n}\n\nvoid\nqla2x00_free_fcport(fc_port_t *fcport)\n{\n\tif (fcport->ct_desc.ct_sns) {\n\t\tdma_free_coherent(&fcport->vha->hw->pdev->dev,\n\t\t\tsizeof(struct ct_sns_pkt), fcport->ct_desc.ct_sns,\n\t\t\tfcport->ct_desc.ct_sns_dma);\n\n\t\tfcport->ct_desc.ct_sns = NULL;\n\t}\n\tlist_del(&fcport->list);\n\tqla2x00_clear_loop_id(fcport);\n\tkfree(fcport);\n}\n\nstatic void qla_get_login_template(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval;\n\tu32 *bp, sz;\n\t__be32 *q;\n\n\tmemset(ha->init_cb, 0, ha->init_cb_size);\n\tsz = min_t(int, sizeof(struct fc_els_flogi), ha->init_cb_size);\n\trval = qla24xx_get_port_login_templ(vha, ha->init_cb_dma,\n\t\t\t\t\t    ha->init_cb, sz);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_init, vha, 0x00d1,\n\t\t       \"PLOGI ELS param read fail.\\n\");\n\t\treturn;\n\t}\n\tq = (__be32 *)&ha->plogi_els_payld.fl_csp;\n\n\tbp = (uint32_t *)ha->init_cb;\n\tcpu_to_be32_array(q, bp, sz / 4);\n\tha->flags.plogi_template_valid = 1;\n}\n\n/*\n * qla2x00_configure_loop\n *      Updates Fibre Channel Device Database with what is actually on loop.\n *\n * Input:\n *      ha                = adapter block pointer.\n *\n * Returns:\n *      0 = success.\n *      1 = error.\n *      2 = database was full and device was not configured.\n */\nstatic int\nqla2x00_configure_loop(scsi_qla_host_t *vha)\n{\n\tint  rval;\n\tunsigned long flags, save_flags;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\trval = QLA_SUCCESS;\n\n\t/* Get Initiator ID */\n\tif (test_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags)) {\n\t\trval = qla2x00_configure_hba(vha);\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2013,\n\t\t\t    \"Unable to configure HBA.\\n\");\n\t\t\treturn (rval);\n\t\t}\n\t}\n\n\tsave_flags = flags = vha->dpc_flags;\n\tql_dbg(ql_dbg_disc, vha, 0x2014,\n\t    \"Configure loop -- dpc flags = 0x%lx.\\n\", flags);\n\n\t/*\n\t * If we have both an RSCN and PORT UPDATE pending then handle them\n\t * both at the same time.\n\t */\n\tclear_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\tclear_bit(RSCN_UPDATE, &vha->dpc_flags);\n\n\tqla2x00_get_data_rate(vha);\n\tqla_get_login_template(vha);\n\n\t/* Determine what we need to do */\n\tif ((ha->current_topology == ISP_CFG_FL ||\n\t    ha->current_topology == ISP_CFG_F) &&\n\t    (test_bit(LOCAL_LOOP_UPDATE, &flags))) {\n\n\t\tset_bit(RSCN_UPDATE, &flags);\n\t\tclear_bit(LOCAL_LOOP_UPDATE, &flags);\n\n\t} else if (ha->current_topology == ISP_CFG_NL ||\n\t\t   ha->current_topology == ISP_CFG_N) {\n\t\tclear_bit(RSCN_UPDATE, &flags);\n\t\tset_bit(LOCAL_LOOP_UPDATE, &flags);\n\t} else if (!vha->flags.online ||\n\t    (test_bit(ABORT_ISP_ACTIVE, &flags))) {\n\t\tset_bit(RSCN_UPDATE, &flags);\n\t\tset_bit(LOCAL_LOOP_UPDATE, &flags);\n\t}\n\n\tif (test_bit(LOCAL_LOOP_UPDATE, &flags)) {\n\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2015,\n\t\t\t    \"Loop resync needed, failing.\\n\");\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t} else\n\t\t\trval = qla2x00_configure_local_loop(vha);\n\t}\n\n\tif (rval == QLA_SUCCESS && test_bit(RSCN_UPDATE, &flags)) {\n\t\tif (LOOP_TRANSITION(vha)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2099,\n\t\t\t    \"Needs RSCN update and loop transition.\\n\");\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t}\n\t\telse\n\t\t\trval = qla2x00_configure_fabric(vha);\n\t}\n\n\tif (rval == QLA_SUCCESS) {\n\t\tif (atomic_read(&vha->loop_down_timer) ||\n\t\t    test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags)) {\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t} else {\n\t\t\tatomic_set(&vha->loop_state, LOOP_READY);\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2069,\n\t\t\t    \"LOOP READY.\\n\");\n\t\t\tha->flags.fw_init_done = 1;\n\n\t\t\t/*\n\t\t\t * Process any ATIO queue entries that came in\n\t\t\t * while we weren't online.\n\t\t\t */\n\t\t\tif (qla_tgt_mode_enabled(vha) ||\n\t\t\t    qla_dual_mode_enabled(vha)) {\n\t\t\t\tspin_lock_irqsave(&ha->tgt.atio_lock, flags);\n\t\t\t\tqlt_24xx_process_atio_queue(vha, 0);\n\t\t\t\tspin_unlock_irqrestore(&ha->tgt.atio_lock,\n\t\t\t\t    flags);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rval) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x206a,\n\t\t    \"%s *** FAILED ***.\\n\", __func__);\n\t} else {\n\t\tql_dbg(ql_dbg_disc, vha, 0x206b,\n\t\t    \"%s: exiting normally.\\n\", __func__);\n\t}\n\n\t/* Restore state if a resync event occurred during processing */\n\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags)) {\n\t\tif (test_bit(LOCAL_LOOP_UPDATE, &save_flags))\n\t\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\tif (test_bit(RSCN_UPDATE, &save_flags)) {\n\t\t\tset_bit(RSCN_UPDATE, &vha->dpc_flags);\n\t\t}\n\t}\n\n\treturn (rval);\n}\n\nstatic int qla2x00_configure_n2n_loop(scsi_qla_host_t *vha)\n{\n\tunsigned long flags;\n\tfc_port_t *fcport;\n\n\tif (test_and_clear_bit(N2N_LOGIN_NEEDED, &vha->dpc_flags))\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (fcport->n2n_flag) {\n\t\t\tqla24xx_fcport_handle_login(vha, fcport);\n\t\t\treturn QLA_SUCCESS;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&vha->work_lock, flags);\n\tvha->scan.scan_retry++;\n\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\n\tif (vha->scan.scan_retry < MAX_SCAN_RETRIES) {\n\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t}\n\treturn QLA_FUNCTION_FAILED;\n}\n\n/*\n * qla2x00_configure_local_loop\n *\tUpdates Fibre Channel Device Database with local loop devices.\n *\n * Input:\n *\tha = adapter block pointer.\n *\n * Returns:\n *\t0 = success.\n */\nstatic int\nqla2x00_configure_local_loop(scsi_qla_host_t *vha)\n{\n\tint\t\trval, rval2;\n\tint\t\tfound_devs;\n\tint\t\tfound;\n\tfc_port_t\t*fcport, *new_fcport;\n\tuint16_t\tindex;\n\tuint16_t\tentries;\n\tstruct gid_list_info *gid;\n\tuint16_t\tloop_id;\n\tuint8_t\t\tdomain, area, al_pa;\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags;\n\n\t/* Inititae N2N login. */\n\tif (N2N_TOPO(ha))\n\t\treturn qla2x00_configure_n2n_loop(vha);\n\n\tfound_devs = 0;\n\tnew_fcport = NULL;\n\tentries = MAX_FIBRE_DEVICES_LOOP;\n\n\t/* Get list of logged in devices. */\n\tmemset(ha->gid_list, 0, qla2x00_gid_list_size(ha));\n\trval = qla2x00_get_id_list(vha, ha->gid_list, ha->gid_list_dma,\n\t    &entries);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto err;\n\n\tql_dbg(ql_dbg_disc, vha, 0x2011,\n\t    \"Entries in ID list (%d).\\n\", entries);\n\tql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x2075,\n\t    ha->gid_list, entries * sizeof(*ha->gid_list));\n\n\tif (entries == 0) {\n\t\tspin_lock_irqsave(&vha->work_lock, flags);\n\t\tvha->scan.scan_retry++;\n\t\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\n\t\tif (vha->scan.scan_retry < MAX_SCAN_RETRIES) {\n\t\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t}\n\t} else {\n\t\tvha->scan.scan_retry = 0;\n\t}\n\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tfcport->scan_state = QLA_FCPORT_SCAN;\n\t}\n\n\t/* Allocate temporary fcport for any new fcports discovered. */\n\tnew_fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\n\tif (new_fcport == NULL) {\n\t\tql_log(ql_log_warn, vha, 0x2012,\n\t\t    \"Memory allocation failed for fcport.\\n\");\n\t\trval = QLA_MEMORY_ALLOC_FAILED;\n\t\tgoto err;\n\t}\n\tnew_fcport->flags &= ~FCF_FABRIC_DEVICE;\n\n\t/* Add devices to port list. */\n\tgid = ha->gid_list;\n\tfor (index = 0; index < entries; index++) {\n\t\tdomain = gid->domain;\n\t\tarea = gid->area;\n\t\tal_pa = gid->al_pa;\n\t\tif (IS_QLA2100(ha) || IS_QLA2200(ha))\n\t\t\tloop_id = gid->loop_id_2100;\n\t\telse\n\t\t\tloop_id = le16_to_cpu(gid->loop_id);\n\t\tgid = (void *)gid + ha->gid_list_info_size;\n\n\t\t/* Bypass reserved domain fields. */\n\t\tif ((domain & 0xf0) == 0xf0)\n\t\t\tcontinue;\n\n\t\t/* Bypass if not same domain and area of adapter. */\n\t\tif (area && domain && ((area != vha->d_id.b.area) ||\n\t\t    (domain != vha->d_id.b.domain)) &&\n\t\t    (ha->current_topology == ISP_CFG_NL))\n\t\t\tcontinue;\n\n\n\t\t/* Bypass invalid local loop ID. */\n\t\tif (loop_id > LAST_LOCAL_LOOP_ID)\n\t\t\tcontinue;\n\n\t\tmemset(new_fcport->port_name, 0, WWN_SIZE);\n\n\t\t/* Fill in member data. */\n\t\tnew_fcport->d_id.b.domain = domain;\n\t\tnew_fcport->d_id.b.area = area;\n\t\tnew_fcport->d_id.b.al_pa = al_pa;\n\t\tnew_fcport->loop_id = loop_id;\n\t\tnew_fcport->scan_state = QLA_FCPORT_FOUND;\n\n\t\trval2 = qla2x00_get_port_database(vha, new_fcport, 0);\n\t\tif (rval2 != QLA_SUCCESS) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2097,\n\t\t\t    \"Failed to retrieve fcport information \"\n\t\t\t    \"-- get_port_database=%x, loop_id=0x%04x.\\n\",\n\t\t\t    rval2, new_fcport->loop_id);\n\t\t\t/* Skip retry if N2N */\n\t\t\tif (ha->current_topology != ISP_CFG_N) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x2105,\n\t\t\t\t    \"Scheduling resync.\\n\");\n\t\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\t\t/* Check for matching device in port list. */\n\t\tfound = 0;\n\t\tfcport = NULL;\n\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t\tif (memcmp(new_fcport->port_name, fcport->port_name,\n\t\t\t    WWN_SIZE))\n\t\t\t\tcontinue;\n\n\t\t\tfcport->flags &= ~FCF_FABRIC_DEVICE;\n\t\t\tfcport->loop_id = new_fcport->loop_id;\n\t\t\tfcport->port_type = new_fcport->port_type;\n\t\t\tfcport->d_id.b24 = new_fcport->d_id.b24;\n\t\t\tmemcpy(fcport->node_name, new_fcport->node_name,\n\t\t\t    WWN_SIZE);\n\t\t\tfcport->scan_state = QLA_FCPORT_FOUND;\n\t\t\tfound++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!found) {\n\t\t\t/* New device, add to fcports list. */\n\t\t\tlist_add_tail(&new_fcport->list, &vha->vp_fcports);\n\n\t\t\t/* Allocate a new replacement fcport. */\n\t\t\tfcport = new_fcport;\n\n\t\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\t\t\tnew_fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\n\n\t\t\tif (new_fcport == NULL) {\n\t\t\t\tql_log(ql_log_warn, vha, 0xd031,\n\t\t\t\t    \"Failed to allocate memory for fcport.\\n\");\n\t\t\t\trval = QLA_MEMORY_ALLOC_FAILED;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\t\t\tnew_fcport->flags &= ~FCF_FABRIC_DEVICE;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\t\t/* Base iIDMA settings on HBA port speed. */\n\t\tfcport->fp_speed = ha->link_data_rate;\n\n\t\tfound_devs++;\n\t}\n\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\tbreak;\n\n\t\tif (fcport->scan_state == QLA_FCPORT_SCAN) {\n\t\t\tif ((qla_dual_mode_enabled(vha) ||\n\t\t\t    qla_ini_mode_enabled(vha)) &&\n\t\t\t    atomic_read(&fcport->state) == FCS_ONLINE) {\n\t\t\t\tqla2x00_mark_device_lost(vha, fcport,\n\t\t\t\t\tql2xplogiabsentdevice);\n\t\t\t\tif (fcport->loop_id != FC_NO_LOOP_ID &&\n\t\t\t\t    (fcport->flags & FCF_FCP2_DEVICE) == 0 &&\n\t\t\t\t    fcport->port_type != FCT_INITIATOR &&\n\t\t\t\t    fcport->port_type != FCT_BROADCAST) {\n\t\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20f0,\n\t\t\t\t\t    \"%s %d %8phC post del sess\\n\",\n\t\t\t\t\t    __func__, __LINE__,\n\t\t\t\t\t    fcport->port_name);\n\n\t\t\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (fcport->scan_state == QLA_FCPORT_FOUND)\n\t\t\tqla24xx_fcport_handle_login(vha, fcport);\n\t}\n\n\tqla2x00_free_fcport(new_fcport);\n\n\treturn rval;\n\nerr:\n\tql_dbg(ql_dbg_disc, vha, 0x2098,\n\t       \"Configure local loop error exit: rval=%x.\\n\", rval);\n\treturn rval;\n}\n\nstatic void\nqla2x00_iidma_fcport(scsi_qla_host_t *vha, fc_port_t *fcport)\n{\n\tint rval;\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_IIDMA_CAPABLE(ha))\n\t\treturn;\n\n\tif (atomic_read(&fcport->state) != FCS_ONLINE)\n\t\treturn;\n\n\tif (fcport->fp_speed == PORT_SPEED_UNKNOWN ||\n\t    fcport->fp_speed > ha->link_data_rate ||\n\t    !ha->flags.gpsc_supported)\n\t\treturn;\n\n\trval = qla2x00_set_idma_speed(vha, fcport->loop_id, fcport->fp_speed,\n\t    mb);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2004,\n\t\t    \"Unable to adjust iIDMA %8phN -- %04x %x %04x %04x.\\n\",\n\t\t    fcport->port_name, rval, fcport->fp_speed, mb[0], mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2005,\n\t\t    \"iIDMA adjusted to %s GB/s (%X) on %8phN.\\n\",\n\t\t    qla2x00_get_link_speed_str(ha, fcport->fp_speed),\n\t\t    fcport->fp_speed, fcport->port_name);\n\t}\n}\n\nvoid qla_do_iidma_work(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tqla2x00_iidma_fcport(vha, fcport);\n\tqla24xx_update_fcport_fcp_prio(vha, fcport);\n}\n\nint qla_post_iidma_work(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_IIDMA);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.fcport.fcport = fcport;\n\treturn qla2x00_post_work(vha, e);\n}\n\n/* qla2x00_reg_remote_port is reserved for Initiator Mode only.*/\nstatic void\nqla2x00_reg_remote_port(scsi_qla_host_t *vha, fc_port_t *fcport)\n{\n\tstruct fc_rport_identifiers rport_ids;\n\tstruct fc_rport *rport;\n\tunsigned long flags;\n\n\tif (atomic_read(&fcport->state) == FCS_ONLINE)\n\t\treturn;\n\n\trport_ids.node_name = wwn_to_u64(fcport->node_name);\n\trport_ids.port_name = wwn_to_u64(fcport->port_name);\n\trport_ids.port_id = fcport->d_id.b.domain << 16 |\n\t    fcport->d_id.b.area << 8 | fcport->d_id.b.al_pa;\n\trport_ids.roles = FC_RPORT_ROLE_UNKNOWN;\n\tfcport->rport = rport = fc_remote_port_add(vha->host, 0, &rport_ids);\n\tif (!rport) {\n\t\tql_log(ql_log_warn, vha, 0x2006,\n\t\t    \"Unable to allocate fc remote port.\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(fcport->vha->host->host_lock, flags);\n\t*((fc_port_t **)rport->dd_data) = fcport;\n\tspin_unlock_irqrestore(fcport->vha->host->host_lock, flags);\n\n\trport->supported_classes = fcport->supported_classes;\n\n\trport_ids.roles = FC_PORT_ROLE_UNKNOWN;\n\tif (fcport->port_type == FCT_INITIATOR)\n\t\trport_ids.roles |= FC_PORT_ROLE_FCP_INITIATOR;\n\tif (fcport->port_type == FCT_TARGET)\n\t\trport_ids.roles |= FC_PORT_ROLE_FCP_TARGET;\n\tif (fcport->port_type & FCT_NVME_INITIATOR)\n\t\trport_ids.roles |= FC_PORT_ROLE_NVME_INITIATOR;\n\tif (fcport->port_type & FCT_NVME_TARGET)\n\t\trport_ids.roles |= FC_PORT_ROLE_NVME_TARGET;\n\tif (fcport->port_type & FCT_NVME_DISCOVERY)\n\t\trport_ids.roles |= FC_PORT_ROLE_NVME_DISCOVERY;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20ee,\n\t    \"%s %8phN. rport %p is %s mode\\n\",\n\t    __func__, fcport->port_name, rport,\n\t    (fcport->port_type == FCT_TARGET) ? \"tgt\" :\n\t    ((fcport->port_type & FCT_NVME) ? \"nvme\" : \"ini\"));\n\n\tfc_remote_port_rolechg(rport, rport_ids.roles);\n}\n\n/*\n * qla2x00_update_fcport\n *\tUpdates device on list.\n *\n * Input:\n *\tha = adapter block pointer.\n *\tfcport = port structure pointer.\n *\n * Return:\n *\t0  - Success\n *  BIT_0 - error\n *\n * Context:\n *\tKernel context.\n */\nvoid\nqla2x00_update_fcport(scsi_qla_host_t *vha, fc_port_t *fcport)\n{\n\tif (IS_SW_RESV_ADDR(fcport->d_id))\n\t\treturn;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20ef, \"%s %8phC\\n\",\n\t    __func__, fcport->port_name);\n\n\tqla2x00_set_fcport_disc_state(fcport, DSC_UPD_FCPORT);\n\tfcport->login_retry = vha->hw->login_retry_count;\n\tfcport->flags &= ~(FCF_LOGIN_NEEDED | FCF_ASYNC_SENT);\n\tfcport->deleted = 0;\n\tif (vha->hw->current_topology == ISP_CFG_NL)\n\t\tfcport->logout_on_delete = 0;\n\telse\n\t\tfcport->logout_on_delete = 1;\n\tfcport->n2n_chip_reset = fcport->n2n_link_reset_cnt = 0;\n\n\tswitch (vha->hw->current_topology) {\n\tcase ISP_CFG_N:\n\tcase ISP_CFG_NL:\n\t\tfcport->keep_nport_handle = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tqla2x00_iidma_fcport(vha, fcport);\n\n\tqla2x00_dfs_create_rport(vha, fcport);\n\n\tif (NVME_TARGET(vha->hw, fcport)) {\n\t\tqla_nvme_register_remote(vha, fcport);\n\t\tqla2x00_set_fcport_disc_state(fcport, DSC_LOGIN_COMPLETE);\n\t\tqla2x00_set_fcport_state(fcport, FCS_ONLINE);\n\t\treturn;\n\t}\n\n\tqla24xx_update_fcport_fcp_prio(vha, fcport);\n\n\tswitch (vha->host->active_mode) {\n\tcase MODE_INITIATOR:\n\t\tqla2x00_reg_remote_port(vha, fcport);\n\t\tbreak;\n\tcase MODE_TARGET:\n\t\tif (!vha->vha_tgt.qla_tgt->tgt_stop &&\n\t\t\t!vha->vha_tgt.qla_tgt->tgt_stopped)\n\t\t\tqlt_fc_port_added(vha, fcport);\n\t\tbreak;\n\tcase MODE_DUAL:\n\t\tqla2x00_reg_remote_port(vha, fcport);\n\t\tif (!vha->vha_tgt.qla_tgt->tgt_stop &&\n\t\t\t!vha->vha_tgt.qla_tgt->tgt_stopped)\n\t\t\tqlt_fc_port_added(vha, fcport);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tqla2x00_set_fcport_state(fcport, FCS_ONLINE);\n\n\tif (IS_IIDMA_CAPABLE(vha->hw) && vha->hw->flags.gpsc_supported) {\n\t\tif (fcport->id_changed) {\n\t\t\tfcport->id_changed = 0;\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20d7,\n\t\t\t    \"%s %d %8phC post gfpnid fcp_cnt %d\\n\",\n\t\t\t    __func__, __LINE__, fcport->port_name,\n\t\t\t    vha->fcport_count);\n\t\t\tqla24xx_post_gfpnid_work(vha, fcport);\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20d7,\n\t\t\t    \"%s %d %8phC post gpsc fcp_cnt %d\\n\",\n\t\t\t    __func__, __LINE__, fcport->port_name,\n\t\t\t    vha->fcport_count);\n\t\t\tqla24xx_post_gpsc_work(vha, fcport);\n\t\t}\n\t}\n\n\tqla2x00_set_fcport_disc_state(fcport, DSC_LOGIN_COMPLETE);\n}\n\nvoid qla_register_fcport_fn(struct work_struct *work)\n{\n\tfc_port_t *fcport = container_of(work, struct fc_port, reg_work);\n\tu32 rscn_gen = fcport->rscn_gen;\n\tu16 data[2];\n\n\tif (IS_SW_RESV_ADDR(fcport->d_id))\n\t\treturn;\n\n\tqla2x00_update_fcport(fcport->vha, fcport);\n\n\tif (rscn_gen != fcport->rscn_gen) {\n\t\t/* RSCN(s) came in while registration */\n\t\tswitch (fcport->next_disc_state) {\n\t\tcase DSC_DELETE_PEND:\n\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\tbreak;\n\t\tcase DSC_ADISC:\n\t\t\tdata[0] = data[1] = 0;\n\t\t\tqla2x00_post_async_adisc_work(fcport->vha, fcport,\n\t\t\t    data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*\n * qla2x00_configure_fabric\n *      Setup SNS devices with loop ID's.\n *\n * Input:\n *      ha = adapter block pointer.\n *\n * Returns:\n *      0 = success.\n *      BIT_0 = error\n */\nstatic int\nqla2x00_configure_fabric(scsi_qla_host_t *vha)\n{\n\tint\trval;\n\tfc_port_t\t*fcport;\n\tuint16_t\tmb[MAILBOX_REGISTER_COUNT];\n\tuint16_t\tloop_id;\n\tLIST_HEAD(new_fcports);\n\tstruct qla_hw_data *ha = vha->hw;\n\tint\t\tdiscovery_gen;\n\n\t/* If FL port exists, then SNS is present */\n\tif (IS_FWI2_CAPABLE(ha))\n\t\tloop_id = NPH_F_PORT;\n\telse\n\t\tloop_id = SNS_FL_PORT;\n\trval = qla2x00_get_port_name(vha, loop_id, vha->fabric_node_name, 1);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x20a0,\n\t\t    \"MBX_GET_PORT_NAME failed, No FL Port.\\n\");\n\n\t\tvha->device_flags &= ~SWITCH_FOUND;\n\t\treturn (QLA_SUCCESS);\n\t}\n\tvha->device_flags |= SWITCH_FOUND;\n\n\trval = qla2x00_get_port_name(vha, loop_id, vha->fabric_port_name, 0);\n\tif (rval != QLA_SUCCESS)\n\t\tql_dbg(ql_dbg_disc, vha, 0x20ff,\n\t\t    \"Failed to get Fabric Port Name\\n\");\n\n\tif (qla_tgt_mode_enabled(vha) || qla_dual_mode_enabled(vha)) {\n\t\trval = qla2x00_send_change_request(vha, 0x3, 0);\n\t\tif (rval != QLA_SUCCESS)\n\t\t\tql_log(ql_log_warn, vha, 0x121,\n\t\t\t    \"Failed to enable receiving of RSCN requests: 0x%x.\\n\",\n\t\t\t    rval);\n\t}\n\n\tdo {\n\t\tqla2x00_mgmt_svr_login(vha);\n\n\t\t/* Ensure we are logged into the SNS. */\n\t\tloop_id = NPH_SNS_LID(ha);\n\t\trval = ha->isp_ops->fabric_login(vha, loop_id, 0xff, 0xff,\n\t\t    0xfc, mb, BIT_1|BIT_0);\n\t\tif (rval != QLA_SUCCESS || mb[0] != MBS_COMMAND_COMPLETE) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20a1,\n\t\t\t    \"Failed SNS login: loop_id=%x mb[0]=%x mb[1]=%x mb[2]=%x mb[6]=%x mb[7]=%x (%x).\\n\",\n\t\t\t    loop_id, mb[0], mb[1], mb[2], mb[6], mb[7], rval);\n\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t\treturn rval;\n\t\t}\n\n\t\t/* FDMI support. */\n\t\tif (ql2xfdmienable &&\n\t\t    test_and_clear_bit(REGISTER_FDMI_NEEDED, &vha->dpc_flags))\n\t\t\tqla2x00_fdmi_register(vha);\n\n\t\tif (test_and_clear_bit(REGISTER_FC4_NEEDED, &vha->dpc_flags)) {\n\t\t\tif (qla2x00_rft_id(vha)) {\n\t\t\t\t/* EMPTY */\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20a2,\n\t\t\t\t    \"Register FC-4 TYPE failed.\\n\");\n\t\t\t\tif (test_bit(LOOP_RESYNC_NEEDED,\n\t\t\t\t    &vha->dpc_flags))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (qla2x00_rff_id(vha, FC4_TYPE_FCP_SCSI)) {\n\t\t\t\t/* EMPTY */\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x209a,\n\t\t\t\t    \"Register FC-4 Features failed.\\n\");\n\t\t\t\tif (test_bit(LOOP_RESYNC_NEEDED,\n\t\t\t\t    &vha->dpc_flags))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (vha->flags.nvme_enabled) {\n\t\t\t\tif (qla2x00_rff_id(vha, FC_TYPE_NVME)) {\n\t\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x2049,\n\t\t\t\t\t    \"Register NVME FC Type Features failed.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (qla2x00_rnn_id(vha)) {\n\t\t\t\t/* EMPTY */\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x2104,\n\t\t\t\t    \"Register Node Name failed.\\n\");\n\t\t\t\tif (test_bit(LOOP_RESYNC_NEEDED,\n\t\t\t\t    &vha->dpc_flags))\n\t\t\t\t\tbreak;\n\t\t\t} else if (qla2x00_rsnn_nn(vha)) {\n\t\t\t\t/* EMPTY */\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x209b,\n\t\t\t\t    \"Register Symbolic Node Name failed.\\n\");\n\t\t\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\t/* Mark the time right before querying FW for connected ports.\n\t\t * This process is long, asynchronous and by the time it's done,\n\t\t * collected information might not be accurate anymore. E.g.\n\t\t * disconnected port might have re-connected and a brand new\n\t\t * session has been created. In this case session's generation\n\t\t * will be newer than discovery_gen. */\n\t\tqlt_do_generation_tick(vha, &discovery_gen);\n\n\t\tif (USE_ASYNC_SCAN(ha)) {\n\t\t\trval = qla24xx_async_gpnft(vha, FC4_TYPE_FCP_SCSI,\n\t\t\t    NULL);\n\t\t\tif (rval)\n\t\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t} else  {\n\t\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list)\n\t\t\t\tfcport->scan_state = QLA_FCPORT_SCAN;\n\n\t\t\trval = qla2x00_find_all_fabric_devs(vha);\n\t\t}\n\t\tif (rval != QLA_SUCCESS)\n\t\t\tbreak;\n\t} while (0);\n\n\tif (!vha->nvme_local_port && vha->flags.nvme_enabled)\n\t\tqla_nvme_register_hba(vha);\n\n\tif (rval)\n\t\tql_dbg(ql_dbg_disc, vha, 0x2068,\n\t\t    \"Configure fabric error exit rval=%d.\\n\", rval);\n\n\treturn (rval);\n}\n\n/*\n * qla2x00_find_all_fabric_devs\n *\n * Input:\n *\tha = adapter block pointer.\n *\tdev = database device entry pointer.\n *\n * Returns:\n *\t0 = success.\n *\n * Context:\n *\tKernel context.\n */\nstatic int\nqla2x00_find_all_fabric_devs(scsi_qla_host_t *vha)\n{\n\tint\t\trval;\n\tuint16_t\tloop_id;\n\tfc_port_t\t*fcport, *new_fcport;\n\tint\t\tfound;\n\n\tsw_info_t\t*swl;\n\tint\t\tswl_idx;\n\tint\t\tfirst_dev, last_dev;\n\tport_id_t\twrap = {}, nxt_d_id;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\tunsigned long flags;\n\n\trval = QLA_SUCCESS;\n\n\t/* Try GID_PT to get device list, else GAN. */\n\tif (!ha->swl)\n\t\tha->swl = kcalloc(ha->max_fibre_devices, sizeof(sw_info_t),\n\t\t    GFP_KERNEL);\n\tswl = ha->swl;\n\tif (!swl) {\n\t\t/*EMPTY*/\n\t\tql_dbg(ql_dbg_disc, vha, 0x209c,\n\t\t    \"GID_PT allocations failed, fallback on GA_NXT.\\n\");\n\t} else {\n\t\tmemset(swl, 0, ha->max_fibre_devices * sizeof(sw_info_t));\n\t\tif (qla2x00_gid_pt(vha, swl) != QLA_SUCCESS) {\n\t\t\tswl = NULL;\n\t\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\t\treturn rval;\n\t\t} else if (qla2x00_gpn_id(vha, swl) != QLA_SUCCESS) {\n\t\t\tswl = NULL;\n\t\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\t\treturn rval;\n\t\t} else if (qla2x00_gnn_id(vha, swl) != QLA_SUCCESS) {\n\t\t\tswl = NULL;\n\t\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\t\treturn rval;\n\t\t} else if (qla2x00_gfpn_id(vha, swl) != QLA_SUCCESS) {\n\t\t\tswl = NULL;\n\t\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\t\treturn rval;\n\t\t}\n\n\t\t/* If other queries succeeded probe for FC-4 type */\n\t\tif (swl) {\n\t\t\tqla2x00_gff_id(vha, swl);\n\t\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\t\treturn rval;\n\t\t}\n\t}\n\tswl_idx = 0;\n\n\t/* Allocate temporary fcport for any new fcports discovered. */\n\tnew_fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\n\tif (new_fcport == NULL) {\n\t\tql_log(ql_log_warn, vha, 0x209d,\n\t\t    \"Failed to allocate memory for fcport.\\n\");\n\t\treturn (QLA_MEMORY_ALLOC_FAILED);\n\t}\n\tnew_fcport->flags |= (FCF_FABRIC_DEVICE | FCF_LOGIN_NEEDED);\n\t/* Set start port ID scan at adapter ID. */\n\tfirst_dev = 1;\n\tlast_dev = 0;\n\n\t/* Starting free loop ID. */\n\tloop_id = ha->min_external_loopid;\n\tfor (; loop_id <= ha->max_loop_id; loop_id++) {\n\t\tif (qla2x00_is_reserved_id(vha, loop_id))\n\t\t\tcontinue;\n\n\t\tif (ha->current_topology == ISP_CFG_FL &&\n\t\t    (atomic_read(&vha->loop_down_timer) ||\n\t\t     LOOP_TRANSITION(vha))) {\n\t\t\tatomic_set(&vha->loop_down_timer, 0);\n\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (swl != NULL) {\n\t\t\tif (last_dev) {\n\t\t\t\twrap.b24 = new_fcport->d_id.b24;\n\t\t\t} else {\n\t\t\t\tnew_fcport->d_id.b24 = swl[swl_idx].d_id.b24;\n\t\t\t\tmemcpy(new_fcport->node_name,\n\t\t\t\t    swl[swl_idx].node_name, WWN_SIZE);\n\t\t\t\tmemcpy(new_fcport->port_name,\n\t\t\t\t    swl[swl_idx].port_name, WWN_SIZE);\n\t\t\t\tmemcpy(new_fcport->fabric_port_name,\n\t\t\t\t    swl[swl_idx].fabric_port_name, WWN_SIZE);\n\t\t\t\tnew_fcport->fp_speed = swl[swl_idx].fp_speed;\n\t\t\t\tnew_fcport->fc4_type = swl[swl_idx].fc4_type;\n\n\t\t\t\tnew_fcport->nvme_flag = 0;\n\t\t\t\tif (vha->flags.nvme_enabled &&\n\t\t\t\t    swl[swl_idx].fc4_type & FS_FC4TYPE_NVME) {\n\t\t\t\t\tql_log(ql_log_info, vha, 0x2131,\n\t\t\t\t\t    \"FOUND: NVME port %8phC as FC Type 28h\\n\",\n\t\t\t\t\t    new_fcport->port_name);\n\t\t\t\t}\n\n\t\t\t\tif (swl[swl_idx].d_id.b.rsvd_1 != 0) {\n\t\t\t\t\tlast_dev = 1;\n\t\t\t\t}\n\t\t\t\tswl_idx++;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Send GA_NXT to the switch */\n\t\t\trval = qla2x00_ga_nxt(vha, new_fcport);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x209e,\n\t\t\t\t    \"SNS scan failed -- assuming \"\n\t\t\t\t    \"zero-entry result.\\n\");\n\t\t\t\trval = QLA_SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* If wrap on switch device list, exit. */\n\t\tif (first_dev) {\n\t\t\twrap.b24 = new_fcport->d_id.b24;\n\t\t\tfirst_dev = 0;\n\t\t} else if (new_fcport->d_id.b24 == wrap.b24) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x209f,\n\t\t\t    \"Device wrap (%02x%02x%02x).\\n\",\n\t\t\t    new_fcport->d_id.b.domain,\n\t\t\t    new_fcport->d_id.b.area,\n\t\t\t    new_fcport->d_id.b.al_pa);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Bypass if same physical adapter. */\n\t\tif (new_fcport->d_id.b24 == base_vha->d_id.b24)\n\t\t\tcontinue;\n\n\t\t/* Bypass virtual ports of the same host. */\n\t\tif (qla2x00_is_a_vp_did(vha, new_fcport->d_id.b24))\n\t\t\tcontinue;\n\n\t\t/* Bypass if same domain and area of adapter. */\n\t\tif (((new_fcport->d_id.b24 & 0xffff00) ==\n\t\t    (vha->d_id.b24 & 0xffff00)) && ha->current_topology ==\n\t\t\tISP_CFG_FL)\n\t\t\t    continue;\n\n\t\t/* Bypass reserved domain fields. */\n\t\tif ((new_fcport->d_id.b.domain & 0xf0) == 0xf0)\n\t\t\tcontinue;\n\n\t\t/* Bypass ports whose FCP-4 type is not FCP_SCSI */\n\t\tif (ql2xgffidenable &&\n\t\t    (!(new_fcport->fc4_type & FS_FC4TYPE_FCP) &&\n\t\t    new_fcport->fc4_type != 0))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\n\t\t/* Locate matching device in database. */\n\t\tfound = 0;\n\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t\tif (memcmp(new_fcport->port_name, fcport->port_name,\n\t\t\t    WWN_SIZE))\n\t\t\t\tcontinue;\n\n\t\t\tfcport->scan_state = QLA_FCPORT_FOUND;\n\n\t\t\tfound++;\n\n\t\t\t/* Update port state. */\n\t\t\tmemcpy(fcport->fabric_port_name,\n\t\t\t    new_fcport->fabric_port_name, WWN_SIZE);\n\t\t\tfcport->fp_speed = new_fcport->fp_speed;\n\n\t\t\t/*\n\t\t\t * If address the same and state FCS_ONLINE\n\t\t\t * (or in target mode), nothing changed.\n\t\t\t */\n\t\t\tif (fcport->d_id.b24 == new_fcport->d_id.b24 &&\n\t\t\t    (atomic_read(&fcport->state) == FCS_ONLINE ||\n\t\t\t     (vha->host->active_mode == MODE_TARGET))) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (fcport->login_retry == 0)\n\t\t\t\tfcport->login_retry =\n\t\t\t\t\tvha->hw->login_retry_count;\n\t\t\t/*\n\t\t\t * If device was not a fabric device before.\n\t\t\t */\n\t\t\tif ((fcport->flags & FCF_FABRIC_DEVICE) == 0) {\n\t\t\t\tfcport->d_id.b24 = new_fcport->d_id.b24;\n\t\t\t\tqla2x00_clear_loop_id(fcport);\n\t\t\t\tfcport->flags |= (FCF_FABRIC_DEVICE |\n\t\t\t\t    FCF_LOGIN_NEEDED);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Port ID changed or device was marked to be updated;\n\t\t\t * Log it out if still logged in and mark it for\n\t\t\t * relogin later.\n\t\t\t */\n\t\t\tif (qla_tgt_mode_enabled(base_vha)) {\n\t\t\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf080,\n\t\t\t\t\t \"port changed FC ID, %8phC\"\n\t\t\t\t\t \" old %x:%x:%x (loop_id 0x%04x)-> new %x:%x:%x\\n\",\n\t\t\t\t\t fcport->port_name,\n\t\t\t\t\t fcport->d_id.b.domain,\n\t\t\t\t\t fcport->d_id.b.area,\n\t\t\t\t\t fcport->d_id.b.al_pa,\n\t\t\t\t\t fcport->loop_id,\n\t\t\t\t\t new_fcport->d_id.b.domain,\n\t\t\t\t\t new_fcport->d_id.b.area,\n\t\t\t\t\t new_fcport->d_id.b.al_pa);\n\t\t\t\tfcport->d_id.b24 = new_fcport->d_id.b24;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfcport->d_id.b24 = new_fcport->d_id.b24;\n\t\t\tfcport->flags |= FCF_LOGIN_NEEDED;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (found && NVME_TARGET(vha->hw, fcport)) {\n\t\t\tif (fcport->disc_state == DSC_DELETE_PEND) {\n\t\t\t\tqla2x00_set_fcport_disc_state(fcport, DSC_GNL);\n\t\t\t\tvha->fcport_count--;\n\t\t\t\tfcport->login_succ = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (found) {\n\t\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\t/* If device was not in our fcports list, then add it. */\n\t\tnew_fcport->scan_state = QLA_FCPORT_FOUND;\n\t\tlist_add_tail(&new_fcport->list, &vha->vp_fcports);\n\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\n\t\t/* Allocate a new replacement fcport. */\n\t\tnxt_d_id.b24 = new_fcport->d_id.b24;\n\t\tnew_fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\n\t\tif (new_fcport == NULL) {\n\t\t\tql_log(ql_log_warn, vha, 0xd032,\n\t\t\t    \"Memory allocation failed for fcport.\\n\");\n\t\t\treturn (QLA_MEMORY_ALLOC_FAILED);\n\t\t}\n\t\tnew_fcport->flags |= (FCF_FABRIC_DEVICE | FCF_LOGIN_NEEDED);\n\t\tnew_fcport->d_id.b24 = nxt_d_id.b24;\n\t}\n\n\tqla2x00_free_fcport(new_fcport);\n\n\t/*\n\t * Logout all previous fabric dev marked lost, except FCP2 devices.\n\t */\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\tbreak;\n\n\t\tif ((fcport->flags & FCF_FABRIC_DEVICE) == 0)\n\t\t\tcontinue;\n\n\t\tif (fcport->scan_state == QLA_FCPORT_SCAN) {\n\t\t\tif ((qla_dual_mode_enabled(vha) ||\n\t\t\t    qla_ini_mode_enabled(vha)) &&\n\t\t\t    atomic_read(&fcport->state) == FCS_ONLINE) {\n\t\t\t\tqla2x00_mark_device_lost(vha, fcport,\n\t\t\t\t\tql2xplogiabsentdevice);\n\t\t\t\tif (fcport->loop_id != FC_NO_LOOP_ID &&\n\t\t\t\t    (fcport->flags & FCF_FCP2_DEVICE) == 0 &&\n\t\t\t\t    fcport->port_type != FCT_INITIATOR &&\n\t\t\t\t    fcport->port_type != FCT_BROADCAST) {\n\t\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20f0,\n\t\t\t\t\t    \"%s %d %8phC post del sess\\n\",\n\t\t\t\t\t    __func__, __LINE__,\n\t\t\t\t\t    fcport->port_name);\n\t\t\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (fcport->scan_state == QLA_FCPORT_FOUND &&\n\t\t    (fcport->flags & FCF_LOGIN_NEEDED) != 0)\n\t\t\tqla24xx_fcport_handle_login(vha, fcport);\n\t}\n\treturn (rval);\n}\n\n/* FW does not set aside Loop id for MGMT Server/FFFFFAh */\nint\nqla2x00_reserve_mgmt_server_loop_id(scsi_qla_host_t *vha)\n{\n\tint loop_id = FC_NO_LOOP_ID;\n\tint lid = NPH_MGMT_SERVER - vha->vp_idx;\n\tunsigned long flags;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (vha->vp_idx == 0) {\n\t\tset_bit(NPH_MGMT_SERVER, ha->loop_id_map);\n\t\treturn NPH_MGMT_SERVER;\n\t}\n\n\t/* pick id from high and work down to low */\n\tspin_lock_irqsave(&ha->vport_slock, flags);\n\tfor (; lid > 0; lid--) {\n\t\tif (!test_bit(lid, vha->hw->loop_id_map)) {\n\t\t\tset_bit(lid, vha->hw->loop_id_map);\n\t\t\tloop_id = lid;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\treturn loop_id;\n}\n\n/*\n * qla2x00_fabric_login\n *\tIssue fabric login command.\n *\n * Input:\n *\tha = adapter block pointer.\n *\tdevice = pointer to FC device type structure.\n *\n * Returns:\n *      0 - Login successfully\n *      1 - Login failed\n *      2 - Initiator device\n *      3 - Fatal error\n */\nint\nqla2x00_fabric_login(scsi_qla_host_t *vha, fc_port_t *fcport,\n    uint16_t *next_loopid)\n{\n\tint\trval;\n\tint\tretry;\n\tuint16_t tmp_loopid;\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tretry = 0;\n\ttmp_loopid = 0;\n\n\tfor (;;) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2000,\n\t\t    \"Trying Fabric Login w/loop id 0x%04x for port \"\n\t\t    \"%02x%02x%02x.\\n\",\n\t\t    fcport->loop_id, fcport->d_id.b.domain,\n\t\t    fcport->d_id.b.area, fcport->d_id.b.al_pa);\n\n\t\t/* Login fcport on switch. */\n\t\trval = ha->isp_ops->fabric_login(vha, fcport->loop_id,\n\t\t    fcport->d_id.b.domain, fcport->d_id.b.area,\n\t\t    fcport->d_id.b.al_pa, mb, BIT_0);\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\treturn rval;\n\t\t}\n\t\tif (mb[0] == MBS_PORT_ID_USED) {\n\t\t\t/*\n\t\t\t * Device has another loop ID.  The firmware team\n\t\t\t * recommends the driver perform an implicit login with\n\t\t\t * the specified ID again. The ID we just used is save\n\t\t\t * here so we return with an ID that can be tried by\n\t\t\t * the next login.\n\t\t\t */\n\t\t\tretry++;\n\t\t\ttmp_loopid = fcport->loop_id;\n\t\t\tfcport->loop_id = mb[1];\n\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2001,\n\t\t\t    \"Fabric Login: port in use - next loop \"\n\t\t\t    \"id=0x%04x, port id= %02x%02x%02x.\\n\",\n\t\t\t    fcport->loop_id, fcport->d_id.b.domain,\n\t\t\t    fcport->d_id.b.area, fcport->d_id.b.al_pa);\n\n\t\t} else if (mb[0] == MBS_COMMAND_COMPLETE) {\n\t\t\t/*\n\t\t\t * Login succeeded.\n\t\t\t */\n\t\t\tif (retry) {\n\t\t\t\t/* A retry occurred before. */\n\t\t\t\t*next_loopid = tmp_loopid;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * No retry occurred before. Just increment the\n\t\t\t\t * ID value for next login.\n\t\t\t\t */\n\t\t\t\t*next_loopid = (fcport->loop_id + 1);\n\t\t\t}\n\n\t\t\tif (mb[1] & BIT_0) {\n\t\t\t\tfcport->port_type = FCT_INITIATOR;\n\t\t\t} else {\n\t\t\t\tfcport->port_type = FCT_TARGET;\n\t\t\t\tif (mb[1] & BIT_1) {\n\t\t\t\t\tfcport->flags |= FCF_FCP2_DEVICE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (mb[10] & BIT_0)\n\t\t\t\tfcport->supported_classes |= FC_COS_CLASS2;\n\t\t\tif (mb[10] & BIT_1)\n\t\t\t\tfcport->supported_classes |= FC_COS_CLASS3;\n\n\t\t\tif (IS_FWI2_CAPABLE(ha)) {\n\t\t\t\tif (mb[10] & BIT_7)\n\t\t\t\t\tfcport->flags |=\n\t\t\t\t\t    FCF_CONF_COMP_SUPPORTED;\n\t\t\t}\n\n\t\t\trval = QLA_SUCCESS;\n\t\t\tbreak;\n\t\t} else if (mb[0] == MBS_LOOP_ID_USED) {\n\t\t\t/*\n\t\t\t * Loop ID already used, try next loop ID.\n\t\t\t */\n\t\t\tfcport->loop_id++;\n\t\t\trval = qla2x00_find_new_loop_id(vha, fcport);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\t/* Ran out of loop IDs to use */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (mb[0] == MBS_COMMAND_ERROR) {\n\t\t\t/*\n\t\t\t * Firmware possibly timed out during login. If NO\n\t\t\t * retries are left to do then the device is declared\n\t\t\t * dead.\n\t\t\t */\n\t\t\t*next_loopid = fcport->loop_id;\n\t\t\tha->isp_ops->fabric_logout(vha, fcport->loop_id,\n\t\t\t    fcport->d_id.b.domain, fcport->d_id.b.area,\n\t\t\t    fcport->d_id.b.al_pa);\n\t\t\tqla2x00_mark_device_lost(vha, fcport, 1);\n\n\t\t\trval = 1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * unrecoverable / not handled error\n\t\t\t */\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2002,\n\t\t\t    \"Failed=%x port_id=%02x%02x%02x loop_id=%x \"\n\t\t\t    \"jiffies=%lx.\\n\", mb[0], fcport->d_id.b.domain,\n\t\t\t    fcport->d_id.b.area, fcport->d_id.b.al_pa,\n\t\t\t    fcport->loop_id, jiffies);\n\n\t\t\t*next_loopid = fcport->loop_id;\n\t\t\tha->isp_ops->fabric_logout(vha, fcport->loop_id,\n\t\t\t    fcport->d_id.b.domain, fcport->d_id.b.area,\n\t\t\t    fcport->d_id.b.al_pa);\n\t\t\tqla2x00_clear_loop_id(fcport);\n\t\t\tfcport->login_retry = 0;\n\n\t\t\trval = 3;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (rval);\n}\n\n/*\n * qla2x00_local_device_login\n *\tIssue local device login command.\n *\n * Input:\n *\tha = adapter block pointer.\n *\tloop_id = loop id of device to login to.\n *\n * Returns (Where's the #define!!!!):\n *      0 - Login successfully\n *      1 - Login failed\n *      3 - Fatal error\n */\nint\nqla2x00_local_device_login(scsi_qla_host_t *vha, fc_port_t *fcport)\n{\n\tint\t\trval;\n\tuint16_t\tmb[MAILBOX_REGISTER_COUNT];\n\n\tmemset(mb, 0, sizeof(mb));\n\trval = qla2x00_login_local_device(vha, fcport, mb, BIT_0);\n\tif (rval == QLA_SUCCESS) {\n\t\t/* Interrogate mailbox registers for any errors */\n\t\tif (mb[0] == MBS_COMMAND_ERROR)\n\t\t\trval = 1;\n\t\telse if (mb[0] == MBS_COMMAND_PARAMETER_ERROR)\n\t\t\t/* device not in PCB table */\n\t\t\trval = 3;\n\t}\n\n\treturn (rval);\n}\n\n/*\n *  qla2x00_loop_resync\n *      Resync with fibre channel devices.\n *\n * Input:\n *      ha = adapter block pointer.\n *\n * Returns:\n *      0 = success\n */\nint\nqla2x00_loop_resync(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tuint32_t wait_time;\n\n\tclear_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\n\tif (vha->flags.online) {\n\t\tif (!(rval = qla2x00_fw_ready(vha))) {\n\t\t\t/* Wait at most MAX_TARGET RSCNs for a stable link. */\n\t\t\twait_time = 256;\n\t\t\tdo {\n\t\t\t\tif (!IS_QLAFX00(vha->hw)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Issue a marker after FW becomes\n\t\t\t\t\t * ready.\n\t\t\t\t\t */\n\t\t\t\t\tqla2x00_marker(vha, vha->hw->base_qpair,\n\t\t\t\t\t    0, 0, MK_SYNC_ALL);\n\t\t\t\t\tvha->marker_needed = 0;\n\t\t\t\t}\n\n\t\t\t\t/* Remap devices on Loop. */\n\t\t\t\tclear_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\n\t\t\t\tif (IS_QLAFX00(vha->hw))\n\t\t\t\t\tqlafx00_configure_devices(vha);\n\t\t\t\telse\n\t\t\t\t\tqla2x00_configure_loop(vha);\n\n\t\t\t\twait_time--;\n\t\t\t} while (!atomic_read(&vha->loop_down_timer) &&\n\t\t\t\t!(test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags))\n\t\t\t\t&& wait_time && (test_bit(LOOP_RESYNC_NEEDED,\n\t\t\t\t&vha->dpc_flags)));\n\t\t}\n\t}\n\n\tif (test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags))\n\t\treturn (QLA_FUNCTION_FAILED);\n\n\tif (rval)\n\t\tql_dbg(ql_dbg_disc, vha, 0x206c,\n\t\t    \"%s *** FAILED ***.\\n\", __func__);\n\n\treturn (rval);\n}\n\n/*\n* qla2x00_perform_loop_resync\n* Description: This function will set the appropriate flags and call\n*              qla2x00_loop_resync. If successful loop will be resynced\n* Arguments : scsi_qla_host_t pointer\n* returm    : Success or Failure\n*/\n\nint qla2x00_perform_loop_resync(scsi_qla_host_t *ha)\n{\n\tint32_t rval = 0;\n\n\tif (!test_and_set_bit(LOOP_RESYNC_ACTIVE, &ha->dpc_flags)) {\n\t\t/*Configure the flags so that resync happens properly*/\n\t\tatomic_set(&ha->loop_down_timer, 0);\n\t\tif (!(ha->device_flags & DFLG_NO_CABLE)) {\n\t\t\tatomic_set(&ha->loop_state, LOOP_UP);\n\t\t\tset_bit(LOCAL_LOOP_UPDATE, &ha->dpc_flags);\n\t\t\tset_bit(REGISTER_FC4_NEEDED, &ha->dpc_flags);\n\t\t\tset_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags);\n\n\t\t\trval = qla2x00_loop_resync(ha);\n\t\t} else\n\t\t\tatomic_set(&ha->loop_state, LOOP_DEAD);\n\n\t\tclear_bit(LOOP_RESYNC_ACTIVE, &ha->dpc_flags);\n\t}\n\n\treturn rval;\n}\n\nvoid\nqla2x00_update_fcports(scsi_qla_host_t *base_vha)\n{\n\tfc_port_t *fcport;\n\tstruct scsi_qla_host *vha;\n\tstruct qla_hw_data *ha = base_vha->hw;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t/* Go with deferred removal of rport references. */\n\tlist_for_each_entry(vha, &base_vha->hw->vp_list, list) {\n\t\tatomic_inc(&vha->vref_count);\n\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t\tif (fcport->drport &&\n\t\t\t    atomic_read(&fcport->state) != FCS_UNCONFIGURED) {\n\t\t\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\t\t\t\tqla2x00_rport_del(fcport);\n\n\t\t\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\t\t}\n\t\t}\n\t\tatomic_dec(&vha->vref_count);\n\t\twake_up(&vha->vref_waitq);\n\t}\n\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n}\n\n/* Assumes idc_lock always held on entry */\nvoid\nqla83xx_reset_ownership(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t drv_presence, drv_presence_mask;\n\tuint32_t dev_part_info1, dev_part_info2, class_type;\n\tuint32_t class_type_mask = 0x3;\n\tuint16_t fcoe_other_function = 0xffff, i;\n\n\tif (IS_QLA8044(ha)) {\n\t\tdrv_presence = qla8044_rd_direct(vha,\n\t\t    QLA8044_CRB_DRV_ACTIVE_INDEX);\n\t\tdev_part_info1 = qla8044_rd_direct(vha,\n\t\t    QLA8044_CRB_DEV_PART_INFO_INDEX);\n\t\tdev_part_info2 = qla8044_rd_direct(vha,\n\t\t    QLA8044_CRB_DEV_PART_INFO2);\n\t} else {\n\t\tqla83xx_rd_reg(vha, QLA83XX_IDC_DRV_PRESENCE, &drv_presence);\n\t\tqla83xx_rd_reg(vha, QLA83XX_DEV_PARTINFO1, &dev_part_info1);\n\t\tqla83xx_rd_reg(vha, QLA83XX_DEV_PARTINFO2, &dev_part_info2);\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\tclass_type = ((dev_part_info1 >> (i * 4)) & class_type_mask);\n\t\tif ((class_type == QLA83XX_CLASS_TYPE_FCOE) &&\n\t\t    (i != ha->portnum)) {\n\t\t\tfcoe_other_function = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fcoe_other_function == 0xffff) {\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tclass_type = ((dev_part_info2 >> (i * 4)) &\n\t\t\t    class_type_mask);\n\t\t\tif ((class_type == QLA83XX_CLASS_TYPE_FCOE) &&\n\t\t\t    ((i + 8) != ha->portnum)) {\n\t\t\t\tfcoe_other_function = i + 8;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Prepare drv-presence mask based on fcoe functions present.\n\t * However consider only valid physical fcoe function numbers (0-15).\n\t */\n\tdrv_presence_mask = ~((1 << (ha->portnum)) |\n\t\t\t((fcoe_other_function == 0xffff) ?\n\t\t\t 0 : (1 << (fcoe_other_function))));\n\n\t/* We are the reset owner iff:\n\t *    - No other protocol drivers present.\n\t *    - This is the lowest among fcoe functions. */\n\tif (!(drv_presence & drv_presence_mask) &&\n\t\t\t(ha->portnum < fcoe_other_function)) {\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb07f,\n\t\t    \"This host is Reset owner.\\n\");\n\t\tha->flags.nic_core_reset_owner = 1;\n\t}\n}\n\nstatic int\n__qla83xx_set_drv_ack(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t drv_ack;\n\n\trval = qla83xx_rd_reg(vha, QLA83XX_IDC_DRIVER_ACK, &drv_ack);\n\tif (rval == QLA_SUCCESS) {\n\t\tdrv_ack |= (1 << ha->portnum);\n\t\trval = qla83xx_wr_reg(vha, QLA83XX_IDC_DRIVER_ACK, drv_ack);\n\t}\n\n\treturn rval;\n}\n\nstatic int\n__qla83xx_clear_drv_ack(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t drv_ack;\n\n\trval = qla83xx_rd_reg(vha, QLA83XX_IDC_DRIVER_ACK, &drv_ack);\n\tif (rval == QLA_SUCCESS) {\n\t\tdrv_ack &= ~(1 << ha->portnum);\n\t\trval = qla83xx_wr_reg(vha, QLA83XX_IDC_DRIVER_ACK, drv_ack);\n\t}\n\n\treturn rval;\n}\n\nstatic const char *\nqla83xx_dev_state_to_string(uint32_t dev_state)\n{\n\tswitch (dev_state) {\n\tcase QLA8XXX_DEV_COLD:\n\t\treturn \"COLD/RE-INIT\";\n\tcase QLA8XXX_DEV_INITIALIZING:\n\t\treturn \"INITIALIZING\";\n\tcase QLA8XXX_DEV_READY:\n\t\treturn \"READY\";\n\tcase QLA8XXX_DEV_NEED_RESET:\n\t\treturn \"NEED RESET\";\n\tcase QLA8XXX_DEV_NEED_QUIESCENT:\n\t\treturn \"NEED QUIESCENT\";\n\tcase QLA8XXX_DEV_FAILED:\n\t\treturn \"FAILED\";\n\tcase QLA8XXX_DEV_QUIESCENT:\n\t\treturn \"QUIESCENT\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\n/* Assumes idc-lock always held on entry */\nvoid\nqla83xx_idc_audit(scsi_qla_host_t *vha, int audit_type)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t idc_audit_reg = 0, duration_secs = 0;\n\n\tswitch (audit_type) {\n\tcase IDC_AUDIT_TIMESTAMP:\n\t\tha->idc_audit_ts = (jiffies_to_msecs(jiffies) / 1000);\n\t\tidc_audit_reg = (ha->portnum) |\n\t\t    (IDC_AUDIT_TIMESTAMP << 7) | (ha->idc_audit_ts << 8);\n\t\tqla83xx_wr_reg(vha, QLA83XX_IDC_AUDIT, idc_audit_reg);\n\t\tbreak;\n\n\tcase IDC_AUDIT_COMPLETION:\n\t\tduration_secs = ((jiffies_to_msecs(jiffies) -\n\t\t    jiffies_to_msecs(ha->idc_audit_ts)) / 1000);\n\t\tidc_audit_reg = (ha->portnum) |\n\t\t    (IDC_AUDIT_COMPLETION << 7) | (duration_secs << 8);\n\t\tqla83xx_wr_reg(vha, QLA83XX_IDC_AUDIT, idc_audit_reg);\n\t\tbreak;\n\n\tdefault:\n\t\tql_log(ql_log_warn, vha, 0xb078,\n\t\t    \"Invalid audit type specified.\\n\");\n\t\tbreak;\n\t}\n}\n\n/* Assumes idc_lock always held on entry */\nstatic int\nqla83xx_initiating_reset(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t  idc_control, dev_state;\n\n\t__qla83xx_get_idc_control(vha, &idc_control);\n\tif ((idc_control & QLA83XX_IDC_RESET_DISABLED)) {\n\t\tql_log(ql_log_info, vha, 0xb080,\n\t\t    \"NIC Core reset has been disabled. idc-control=0x%x\\n\",\n\t\t    idc_control);\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\t/* Set NEED-RESET iff in READY state and we are the reset-owner */\n\tqla83xx_rd_reg(vha, QLA83XX_IDC_DEV_STATE, &dev_state);\n\tif (ha->flags.nic_core_reset_owner && dev_state == QLA8XXX_DEV_READY) {\n\t\tqla83xx_wr_reg(vha, QLA83XX_IDC_DEV_STATE,\n\t\t    QLA8XXX_DEV_NEED_RESET);\n\t\tql_log(ql_log_info, vha, 0xb056, \"HW State: NEED RESET.\\n\");\n\t\tqla83xx_idc_audit(vha, IDC_AUDIT_TIMESTAMP);\n\t} else {\n\t\tconst char *state = qla83xx_dev_state_to_string(dev_state);\n\n\t\tql_log(ql_log_info, vha, 0xb057, \"HW State: %s.\\n\", state);\n\n\t\t/* SV: XXX: Is timeout required here? */\n\t\t/* Wait for IDC state change READY -> NEED_RESET */\n\t\twhile (dev_state == QLA8XXX_DEV_READY) {\n\t\t\tqla83xx_idc_unlock(vha, 0);\n\t\t\tmsleep(200);\n\t\t\tqla83xx_idc_lock(vha, 0);\n\t\t\tqla83xx_rd_reg(vha, QLA83XX_IDC_DEV_STATE, &dev_state);\n\t\t}\n\t}\n\n\t/* Send IDC ack by writing to drv-ack register */\n\t__qla83xx_set_drv_ack(vha);\n\n\treturn QLA_SUCCESS;\n}\n\nint\n__qla83xx_set_idc_control(scsi_qla_host_t *vha, uint32_t idc_control)\n{\n\treturn qla83xx_wr_reg(vha, QLA83XX_IDC_CONTROL, idc_control);\n}\n\nint\n__qla83xx_get_idc_control(scsi_qla_host_t *vha, uint32_t *idc_control)\n{\n\treturn qla83xx_rd_reg(vha, QLA83XX_IDC_CONTROL, idc_control);\n}\n\nstatic int\nqla83xx_check_driver_presence(scsi_qla_host_t *vha)\n{\n\tuint32_t drv_presence = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tqla83xx_rd_reg(vha, QLA83XX_IDC_DRV_PRESENCE, &drv_presence);\n\tif (drv_presence & (1 << ha->portnum))\n\t\treturn QLA_SUCCESS;\n\telse\n\t\treturn QLA_TEST_FAILED;\n}\n\nint\nqla83xx_nic_core_reset(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb058,\n\t    \"Entered  %s().\\n\", __func__);\n\n\tif (vha->device_flags & DFLG_DEV_FAILED) {\n\t\tql_log(ql_log_warn, vha, 0xb059,\n\t\t    \"Device in unrecoverable FAILED state.\\n\");\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tqla83xx_idc_lock(vha, 0);\n\n\tif (qla83xx_check_driver_presence(vha) != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0xb05a,\n\t\t    \"Function=0x%x has been removed from IDC participation.\\n\",\n\t\t    ha->portnum);\n\t\trval = QLA_FUNCTION_FAILED;\n\t\tgoto exit;\n\t}\n\n\tqla83xx_reset_ownership(vha);\n\n\trval = qla83xx_initiating_reset(vha);\n\n\t/*\n\t * Perform reset if we are the reset-owner,\n\t * else wait till IDC state changes to READY/FAILED.\n\t */\n\tif (rval == QLA_SUCCESS) {\n\t\trval = qla83xx_idc_state_handler(vha);\n\n\t\tif (rval == QLA_SUCCESS)\n\t\t\tha->flags.nic_core_hung = 0;\n\t\t__qla83xx_clear_drv_ack(vha);\n\t}\n\nexit:\n\tqla83xx_idc_unlock(vha, 0);\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb05b, \"Exiting %s.\\n\", __func__);\n\n\treturn rval;\n}\n\nint\nqla2xxx_mctp_dump(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tif (!IS_MCTP_CAPABLE(ha)) {\n\t\t/* This message can be removed from the final version */\n\t\tql_log(ql_log_info, vha, 0x506d,\n\t\t    \"This board is not MCTP capable\\n\");\n\t\treturn rval;\n\t}\n\n\tif (!ha->mctp_dump) {\n\t\tha->mctp_dump = dma_alloc_coherent(&ha->pdev->dev,\n\t\t    MCTP_DUMP_SIZE, &ha->mctp_dump_dma, GFP_KERNEL);\n\n\t\tif (!ha->mctp_dump) {\n\t\t\tql_log(ql_log_warn, vha, 0x506e,\n\t\t\t    \"Failed to allocate memory for mctp dump\\n\");\n\t\t\treturn rval;\n\t\t}\n\t}\n\n#define MCTP_DUMP_STR_ADDR\t0x00000000\n\trval = qla2x00_dump_mctp_data(vha, ha->mctp_dump_dma,\n\t    MCTP_DUMP_STR_ADDR, MCTP_DUMP_SIZE/4);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x506f,\n\t\t    \"Failed to capture mctp dump\\n\");\n\t} else {\n\t\tql_log(ql_log_info, vha, 0x5070,\n\t\t    \"Mctp dump capture for host (%ld/%p).\\n\",\n\t\t    vha->host_no, ha->mctp_dump);\n\t\tha->mctp_dumped = 1;\n\t}\n\n\tif (!ha->flags.nic_core_reset_hdlr_active && !ha->portnum) {\n\t\tha->flags.nic_core_reset_hdlr_active = 1;\n\t\trval = qla83xx_restart_nic_firmware(vha);\n\t\tif (rval)\n\t\t\t/* NIC Core reset failed. */\n\t\t\tql_log(ql_log_warn, vha, 0x5071,\n\t\t\t    \"Failed to restart nic firmware\\n\");\n\t\telse\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb084,\n\t\t\t    \"Restarted NIC firmware successfully.\\n\");\n\t\tha->flags.nic_core_reset_hdlr_active = 0;\n\t}\n\n\treturn rval;\n\n}\n\n/*\n* qla2x00_quiesce_io\n* Description: This function will block the new I/Os\n*              Its not aborting any I/Os as context\n*              is not destroyed during quiescence\n* Arguments: scsi_qla_host_t\n* return   : void\n*/\nvoid\nqla2x00_quiesce_io(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *vp;\n\n\tql_dbg(ql_dbg_dpc, vha, 0x401d,\n\t    \"Quiescing I/O - ha=%p.\\n\", ha);\n\n\tatomic_set(&ha->loop_down_timer, LOOP_DOWN_TIME);\n\tif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\n\t\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\t\tqla2x00_mark_all_devices_lost(vha);\n\t\tlist_for_each_entry(vp, &ha->vp_list, list)\n\t\t\tqla2x00_mark_all_devices_lost(vp);\n\t} else {\n\t\tif (!atomic_read(&vha->loop_down_timer))\n\t\t\tatomic_set(&vha->loop_down_timer,\n\t\t\t\t\tLOOP_DOWN_TIME);\n\t}\n\t/* Wait for pending cmds to complete */\n\tWARN_ON_ONCE(qla2x00_eh_wait_for_pending_commands(vha, 0, 0, WAIT_HOST)\n\t\t     != QLA_SUCCESS);\n}\n\nvoid\nqla2x00_abort_isp_cleanup(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *vp;\n\tunsigned long flags;\n\tfc_port_t *fcport;\n\tu16 i;\n\n\t/* For ISP82XX, driver waits for completion of the commands.\n\t * online flag should be set.\n\t */\n\tif (!(IS_P3P_TYPE(ha)))\n\t\tvha->flags.online = 0;\n\tha->flags.chip_reset_done = 0;\n\tclear_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\tvha->qla_stats.total_isp_aborts++;\n\n\tql_log(ql_log_info, vha, 0x00af,\n\t    \"Performing ISP error recovery - ha=%p.\\n\", ha);\n\n\tha->flags.purge_mbox = 1;\n\t/* For ISP82XX, reset_chip is just disabling interrupts.\n\t * Driver waits for the completion of the commands.\n\t * the interrupts need to be enabled.\n\t */\n\tif (!(IS_P3P_TYPE(ha)))\n\t\tha->isp_ops->reset_chip(vha);\n\n\tha->link_data_rate = PORT_SPEED_UNKNOWN;\n\tSAVE_TOPO(ha);\n\tha->flags.rida_fmt2 = 0;\n\tha->flags.n2n_ae = 0;\n\tha->flags.lip_ae = 0;\n\tha->current_topology = 0;\n\tQLA_FW_STOPPED(ha);\n\tha->flags.fw_init_done = 0;\n\tha->chip_reset++;\n\tha->base_qpair->chip_reset = ha->chip_reset;\n\tfor (i = 0; i < ha->max_qpairs; i++) {\n\t\tif (ha->queue_pair_map[i])\n\t\t\tha->queue_pair_map[i]->chip_reset =\n\t\t\t\tha->base_qpair->chip_reset;\n\t}\n\n\t/* purge MBox commands */\n\tif (atomic_read(&ha->num_pend_mbx_stage3)) {\n\t\tclear_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags);\n\t\tcomplete(&ha->mbx_intr_comp);\n\t}\n\n\ti = 0;\n\twhile (atomic_read(&ha->num_pend_mbx_stage3) ||\n\t    atomic_read(&ha->num_pend_mbx_stage2) ||\n\t    atomic_read(&ha->num_pend_mbx_stage1)) {\n\t\tmsleep(20);\n\t\ti++;\n\t\tif (i > 50)\n\t\t\tbreak;\n\t}\n\tha->flags.purge_mbox = 0;\n\n\tatomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);\n\tif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\n\t\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\t\tqla2x00_mark_all_devices_lost(vha);\n\n\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\tlist_for_each_entry(vp, &ha->vp_list, list) {\n\t\t\tatomic_inc(&vp->vref_count);\n\t\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\t\t\tqla2x00_mark_all_devices_lost(vp);\n\n\t\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\t\tatomic_dec(&vp->vref_count);\n\t\t}\n\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\t} else {\n\t\tif (!atomic_read(&vha->loop_down_timer))\n\t\t\tatomic_set(&vha->loop_down_timer,\n\t\t\t    LOOP_DOWN_TIME);\n\t}\n\n\t/* Clear all async request states across all VPs. */\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tfcport->flags &= ~(FCF_LOGIN_NEEDED | FCF_ASYNC_SENT);\n\t\tfcport->scan_state = 0;\n\t}\n\tspin_lock_irqsave(&ha->vport_slock, flags);\n\tlist_for_each_entry(vp, &ha->vp_list, list) {\n\t\tatomic_inc(&vp->vref_count);\n\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\t\tlist_for_each_entry(fcport, &vp->vp_fcports, list)\n\t\t\tfcport->flags &= ~(FCF_LOGIN_NEEDED | FCF_ASYNC_SENT);\n\n\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\tatomic_dec(&vp->vref_count);\n\t}\n\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\tif (!ha->flags.eeh_busy) {\n\t\t/* Make sure for ISP 82XX IO DMA is complete */\n\t\tif (IS_P3P_TYPE(ha)) {\n\t\t\tqla82xx_chip_reset_cleanup(vha);\n\t\t\tql_log(ql_log_info, vha, 0x00b4,\n\t\t\t    \"Done chip reset cleanup.\\n\");\n\n\t\t\t/* Done waiting for pending commands.\n\t\t\t * Reset the online flag.\n\t\t\t */\n\t\t\tvha->flags.online = 0;\n\t\t}\n\n\t\t/* Requeue all commands in outstanding command list. */\n\t\tqla2x00_abort_all_cmds(vha, DID_RESET << 16);\n\t}\n\t/* memory barrier */\n\twmb();\n}\n\n/*\n*  qla2x00_abort_isp\n*      Resets ISP and aborts all outstanding commands.\n*\n* Input:\n*      ha           = adapter block pointer.\n*\n* Returns:\n*      0 = success\n*/\nint\nqla2x00_abort_isp(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tuint8_t        status = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *vp;\n\tstruct req_que *req = ha->req_q_map[0];\n\tunsigned long flags;\n\n\tif (vha->flags.online) {\n\t\tqla2x00_abort_isp_cleanup(vha);\n\n\t\tif (test_and_clear_bit(ISP_ABORT_TO_ROM, &vha->dpc_flags)) {\n\t\t\tha->flags.chip_reset_done = 1;\n\t\t\tvha->flags.online = 1;\n\t\t\tstatus = 0;\n\t\t\tclear_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\n\t\t\treturn status;\n\t\t}\n\n\t\tif (IS_QLA8031(ha)) {\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb05c,\n\t\t\t    \"Clearing fcoe driver presence.\\n\");\n\t\t\tif (qla83xx_clear_drv_presence(vha) != QLA_SUCCESS)\n\t\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb073,\n\t\t\t\t    \"Error while clearing DRV-Presence.\\n\");\n\t\t}\n\n\t\tif (unlikely(pci_channel_offline(ha->pdev) &&\n\t\t    ha->flags.pci_channel_io_perm_failure)) {\n\t\t\tclear_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\n\t\t\tstatus = 0;\n\t\t\treturn status;\n\t\t}\n\n\t\tswitch (vha->qlini_mode) {\n\t\tcase QLA2XXX_INI_MODE_DISABLED:\n\t\t\tif (!qla_tgt_mode_enabled(vha))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase QLA2XXX_INI_MODE_DUAL:\n\t\t\tif (!qla_dual_mode_enabled(vha))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase QLA2XXX_INI_MODE_ENABLED:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tha->isp_ops->get_flash_version(vha, req->ring);\n\n\t\tha->isp_ops->nvram_config(vha);\n\n\t\tif (!qla2x00_restart_isp(vha)) {\n\t\t\tclear_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\n\n\t\t\tif (!atomic_read(&vha->loop_down_timer)) {\n\t\t\t\t/*\n\t\t\t\t * Issue marker command only when we are going\n\t\t\t\t * to start the I/O .\n\t\t\t\t */\n\t\t\t\tvha->marker_needed = 1;\n\t\t\t}\n\n\t\t\tvha->flags.online = 1;\n\n\t\t\tha->isp_ops->enable_intrs(ha);\n\n\t\t\tha->isp_abort_cnt = 0;\n\t\t\tclear_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\n\n\t\t\tif (IS_QLA81XX(ha) || IS_QLA8031(ha))\n\t\t\t\tqla2x00_get_fw_version(vha);\n\t\t\tif (ha->fce) {\n\t\t\t\tha->flags.fce_enabled = 1;\n\t\t\t\tmemset(ha->fce, 0,\n\t\t\t\t    fce_calc_size(ha->fce_bufs));\n\t\t\t\trval = qla2x00_enable_fce_trace(vha,\n\t\t\t\t    ha->fce_dma, ha->fce_bufs, ha->fce_mb,\n\t\t\t\t    &ha->fce_bufs);\n\t\t\t\tif (rval) {\n\t\t\t\t\tql_log(ql_log_warn, vha, 0x8033,\n\t\t\t\t\t    \"Unable to reinitialize FCE \"\n\t\t\t\t\t    \"(%d).\\n\", rval);\n\t\t\t\t\tha->flags.fce_enabled = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ha->eft) {\n\t\t\t\tmemset(ha->eft, 0, EFT_SIZE);\n\t\t\t\trval = qla2x00_enable_eft_trace(vha,\n\t\t\t\t    ha->eft_dma, EFT_NUM_BUFFERS);\n\t\t\t\tif (rval) {\n\t\t\t\t\tql_log(ql_log_warn, vha, 0x8034,\n\t\t\t\t\t    \"Unable to reinitialize EFT \"\n\t\t\t\t\t    \"(%d).\\n\", rval);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\t/* failed the ISP abort */\n\t\t\tvha->flags.online = 1;\n\t\t\tif (test_bit(ISP_ABORT_RETRY, &vha->dpc_flags)) {\n\t\t\t\tif (ha->isp_abort_cnt == 0) {\n\t\t\t\t\tql_log(ql_log_fatal, vha, 0x8035,\n\t\t\t\t\t    \"ISP error recover failed - \"\n\t\t\t\t\t    \"board disabled.\\n\");\n\t\t\t\t\t/*\n\t\t\t\t\t * The next call disables the board\n\t\t\t\t\t * completely.\n\t\t\t\t\t */\n\t\t\t\t\tqla2x00_abort_isp_cleanup(vha);\n\t\t\t\t\tvha->flags.online = 0;\n\t\t\t\t\tclear_bit(ISP_ABORT_RETRY,\n\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t\tstatus = 0;\n\t\t\t\t} else { /* schedule another ISP abort */\n\t\t\t\t\tha->isp_abort_cnt--;\n\t\t\t\t\tql_dbg(ql_dbg_taskm, vha, 0x8020,\n\t\t\t\t\t    \"ISP abort - retry remaining %d.\\n\",\n\t\t\t\t\t    ha->isp_abort_cnt);\n\t\t\t\t\tstatus = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tha->isp_abort_cnt = MAX_RETRIES_OF_ISP_ABORT;\n\t\t\t\tql_dbg(ql_dbg_taskm, vha, 0x8021,\n\t\t\t\t    \"ISP error recovery - retrying (%d) \"\n\t\t\t\t    \"more times.\\n\", ha->isp_abort_cnt);\n\t\t\t\tset_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\n\t\t\t\tstatus = 1;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif (!status) {\n\t\tql_dbg(ql_dbg_taskm, vha, 0x8022, \"%s succeeded.\\n\", __func__);\n\t\tqla2x00_configure_hba(vha);\n\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\tlist_for_each_entry(vp, &ha->vp_list, list) {\n\t\t\tif (vp->vp_idx) {\n\t\t\t\tatomic_inc(&vp->vref_count);\n\t\t\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\t\t\t\tqla2x00_vp_abort_isp(vp);\n\n\t\t\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\t\t\tatomic_dec(&vp->vref_count);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\t\tif (IS_QLA8031(ha)) {\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb05d,\n\t\t\t    \"Setting back fcoe driver presence.\\n\");\n\t\t\tif (qla83xx_set_drv_presence(vha) != QLA_SUCCESS)\n\t\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb074,\n\t\t\t\t    \"Error while setting DRV-Presence.\\n\");\n\t\t}\n\t} else {\n\t\tql_log(ql_log_warn, vha, 0x8023, \"%s **** FAILED ****.\\n\",\n\t\t       __func__);\n\t}\n\n\treturn(status);\n}\n\n/*\n*  qla2x00_restart_isp\n*      restarts the ISP after a reset\n*\n* Input:\n*      ha = adapter block pointer.\n*\n* Returns:\n*      0 = success\n*/\nstatic int\nqla2x00_restart_isp(scsi_qla_host_t *vha)\n{\n\tint status;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t/* If firmware needs to be loaded */\n\tif (qla2x00_isp_firmware(vha)) {\n\t\tvha->flags.online = 0;\n\t\tstatus = ha->isp_ops->chip_diag(vha);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = qla2x00_setup_chip(vha);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tstatus = qla2x00_init_rings(vha);\n\tif (status)\n\t\treturn status;\n\n\tclear_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\n\tha->flags.chip_reset_done = 1;\n\n\t/* Initialize the queues in use */\n\tqla25xx_init_queues(ha);\n\n\tstatus = qla2x00_fw_ready(vha);\n\tif (status) {\n\t\t/* if no cable then assume it's good */\n\t\treturn vha->device_flags & DFLG_NO_CABLE ? 0 : status;\n\t}\n\n\t/* Issue a marker after FW becomes ready. */\n\tqla2x00_marker(vha, ha->base_qpair, 0, 0, MK_SYNC_ALL);\n\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\n\treturn 0;\n}\n\nstatic int\nqla25xx_init_queues(struct qla_hw_data *ha)\n{\n\tstruct rsp_que *rsp = NULL;\n\tstruct req_que *req = NULL;\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\tint ret = -1;\n\tint i;\n\n\tfor (i = 1; i < ha->max_rsp_queues; i++) {\n\t\trsp = ha->rsp_q_map[i];\n\t\tif (rsp && test_bit(i, ha->rsp_qid_map)) {\n\t\t\trsp->options &= ~BIT_0;\n\t\t\tret = qla25xx_init_rsp_que(base_vha, rsp);\n\t\t\tif (ret != QLA_SUCCESS)\n\t\t\t\tql_dbg(ql_dbg_init, base_vha, 0x00ff,\n\t\t\t\t    \"%s Rsp que: %d init failed.\\n\",\n\t\t\t\t    __func__, rsp->id);\n\t\t\telse\n\t\t\t\tql_dbg(ql_dbg_init, base_vha, 0x0100,\n\t\t\t\t    \"%s Rsp que: %d inited.\\n\",\n\t\t\t\t    __func__, rsp->id);\n\t\t}\n\t}\n\tfor (i = 1; i < ha->max_req_queues; i++) {\n\t\treq = ha->req_q_map[i];\n\t\tif (req && test_bit(i, ha->req_qid_map)) {\n\t\t\t/* Clear outstanding commands array. */\n\t\t\treq->options &= ~BIT_0;\n\t\t\tret = qla25xx_init_req_que(base_vha, req);\n\t\t\tif (ret != QLA_SUCCESS)\n\t\t\t\tql_dbg(ql_dbg_init, base_vha, 0x0101,\n\t\t\t\t    \"%s Req que: %d init failed.\\n\",\n\t\t\t\t    __func__, req->id);\n\t\t\telse\n\t\t\t\tql_dbg(ql_dbg_init, base_vha, 0x0102,\n\t\t\t\t    \"%s Req que: %d inited.\\n\",\n\t\t\t\t    __func__, req->id);\n\t\t}\n\t}\n\treturn ret;\n}\n\n/*\n* qla2x00_reset_adapter\n*      Reset adapter.\n*\n* Input:\n*      ha = adapter block pointer.\n*/\nint\nqla2x00_reset_adapter(scsi_qla_host_t *vha)\n{\n\tunsigned long flags = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\tvha->flags.online = 0;\n\tha->isp_ops->disable_intrs(ha);\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\twrt_reg_word(&reg->hccr, HCCR_RESET_RISC);\n\trd_reg_word(&reg->hccr);\t\t\t/* PCI Posting. */\n\twrt_reg_word(&reg->hccr, HCCR_RELEASE_RISC);\n\trd_reg_word(&reg->hccr);\t\t\t/* PCI Posting. */\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn QLA_SUCCESS;\n}\n\nint\nqla24xx_reset_adapter(scsi_qla_host_t *vha)\n{\n\tunsigned long flags = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\n\tif (IS_P3P_TYPE(ha))\n\t\treturn QLA_SUCCESS;\n\n\tvha->flags.online = 0;\n\tha->isp_ops->disable_intrs(ha);\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\twrt_reg_dword(&reg->hccr, HCCRX_SET_RISC_RESET);\n\trd_reg_dword(&reg->hccr);\n\twrt_reg_dword(&reg->hccr, HCCRX_REL_RISC_PAUSE);\n\trd_reg_dword(&reg->hccr);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tif (IS_NOPOLLING_TYPE(ha))\n\t\tha->isp_ops->enable_intrs(ha);\n\n\treturn QLA_SUCCESS;\n}\n\n/* On sparc systems, obtain port and node WWN from firmware\n * properties.\n */\nstatic void qla24xx_nvram_wwn_from_ofw(scsi_qla_host_t *vha,\n\tstruct nvram_24xx *nv)\n{\n#ifdef CONFIG_SPARC\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct pci_dev *pdev = ha->pdev;\n\tstruct device_node *dp = pci_device_to_OF_node(pdev);\n\tconst u8 *val;\n\tint len;\n\n\tval = of_get_property(dp, \"port-wwn\", &len);\n\tif (val && len >= WWN_SIZE)\n\t\tmemcpy(nv->port_name, val, WWN_SIZE);\n\n\tval = of_get_property(dp, \"node-wwn\", &len);\n\tif (val && len >= WWN_SIZE)\n\t\tmemcpy(nv->node_name, val, WWN_SIZE);\n#endif\n}\n\nint\nqla24xx_nvram_config(scsi_qla_host_t *vha)\n{\n\tint   rval;\n\tstruct init_cb_24xx *icb;\n\tstruct nvram_24xx *nv;\n\t__le32 *dptr;\n\tuint8_t  *dptr1, *dptr2;\n\tuint32_t chksum;\n\tuint16_t cnt;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\trval = QLA_SUCCESS;\n\ticb = (struct init_cb_24xx *)ha->init_cb;\n\tnv = ha->nvram;\n\n\t/* Determine NVRAM starting address. */\n\tif (ha->port_no == 0) {\n\t\tha->nvram_base = FA_NVRAM_FUNC0_ADDR;\n\t\tha->vpd_base = FA_NVRAM_VPD0_ADDR;\n\t} else {\n\t\tha->nvram_base = FA_NVRAM_FUNC1_ADDR;\n\t\tha->vpd_base = FA_NVRAM_VPD1_ADDR;\n\t}\n\n\tha->nvram_size = sizeof(*nv);\n\tha->vpd_size = FA_NVRAM_VPD_SIZE;\n\n\t/* Get VPD data into cache */\n\tha->vpd = ha->nvram + VPD_OFFSET;\n\tha->isp_ops->read_nvram(vha, ha->vpd,\n\t    ha->nvram_base - FA_NVRAM_FUNC0_ADDR, FA_NVRAM_VPD_SIZE * 4);\n\n\t/* Get NVRAM data into cache and calculate checksum. */\n\tdptr = (__force __le32 *)nv;\n\tha->isp_ops->read_nvram(vha, dptr, ha->nvram_base, ha->nvram_size);\n\tfor (cnt = 0, chksum = 0; cnt < ha->nvram_size >> 2; cnt++, dptr++)\n\t\tchksum += le32_to_cpu(*dptr);\n\n\tql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x006a,\n\t    \"Contents of NVRAM\\n\");\n\tql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x010d,\n\t    nv, ha->nvram_size);\n\n\t/* Bad NVRAM data, set defaults parameters. */\n\tif (chksum || memcmp(\"ISP \", nv->id, sizeof(nv->id)) ||\n\t    le16_to_cpu(nv->nvram_version) < ICB_VERSION) {\n\t\t/* Reset NVRAM data. */\n\t\tql_log(ql_log_warn, vha, 0x006b,\n\t\t    \"Inconsistent NVRAM checksum=%#x id=%.4s version=%#x.\\n\",\n\t\t    chksum, nv->id, nv->nvram_version);\n\t\tql_dump_buffer(ql_dbg_init, vha, 0x006b, nv, sizeof(*nv));\n\t\tql_log(ql_log_warn, vha, 0x006c,\n\t\t    \"Falling back to functioning (yet invalid -- WWPN) \"\n\t\t    \"defaults.\\n\");\n\n\t\t/*\n\t\t * Set default initialization control block.\n\t\t */\n\t\tmemset(nv, 0, ha->nvram_size);\n\t\tnv->nvram_version = cpu_to_le16(ICB_VERSION);\n\t\tnv->version = cpu_to_le16(ICB_VERSION);\n\t\tnv->frame_payload_size = cpu_to_le16(2048);\n\t\tnv->execution_throttle = cpu_to_le16(0xFFFF);\n\t\tnv->exchange_count = cpu_to_le16(0);\n\t\tnv->hard_address = cpu_to_le16(124);\n\t\tnv->port_name[0] = 0x21;\n\t\tnv->port_name[1] = 0x00 + ha->port_no + 1;\n\t\tnv->port_name[2] = 0x00;\n\t\tnv->port_name[3] = 0xe0;\n\t\tnv->port_name[4] = 0x8b;\n\t\tnv->port_name[5] = 0x1c;\n\t\tnv->port_name[6] = 0x55;\n\t\tnv->port_name[7] = 0x86;\n\t\tnv->node_name[0] = 0x20;\n\t\tnv->node_name[1] = 0x00;\n\t\tnv->node_name[2] = 0x00;\n\t\tnv->node_name[3] = 0xe0;\n\t\tnv->node_name[4] = 0x8b;\n\t\tnv->node_name[5] = 0x1c;\n\t\tnv->node_name[6] = 0x55;\n\t\tnv->node_name[7] = 0x86;\n\t\tqla24xx_nvram_wwn_from_ofw(vha, nv);\n\t\tnv->login_retry_count = cpu_to_le16(8);\n\t\tnv->interrupt_delay_timer = cpu_to_le16(0);\n\t\tnv->login_timeout = cpu_to_le16(0);\n\t\tnv->firmware_options_1 =\n\t\t    cpu_to_le32(BIT_14|BIT_13|BIT_2|BIT_1);\n\t\tnv->firmware_options_2 = cpu_to_le32(2 << 4);\n\t\tnv->firmware_options_2 |= cpu_to_le32(BIT_12);\n\t\tnv->firmware_options_3 = cpu_to_le32(2 << 13);\n\t\tnv->host_p = cpu_to_le32(BIT_11|BIT_10);\n\t\tnv->efi_parameters = cpu_to_le32(0);\n\t\tnv->reset_delay = 5;\n\t\tnv->max_luns_per_target = cpu_to_le16(128);\n\t\tnv->port_down_retry_count = cpu_to_le16(30);\n\t\tnv->link_down_timeout = cpu_to_le16(30);\n\n\t\trval = 1;\n\t}\n\n\tif (qla_tgt_mode_enabled(vha)) {\n\t\t/* Don't enable full login after initial LIP */\n\t\tnv->firmware_options_1 &= cpu_to_le32(~BIT_13);\n\t\t/* Don't enable LIP full login for initiator */\n\t\tnv->host_p &= cpu_to_le32(~BIT_10);\n\t}\n\n\tqlt_24xx_config_nvram_stage1(vha, nv);\n\n\t/* Reset Initialization control block */\n\tmemset(icb, 0, ha->init_cb_size);\n\n\t/* Copy 1st segment. */\n\tdptr1 = (uint8_t *)icb;\n\tdptr2 = (uint8_t *)&nv->version;\n\tcnt = (uint8_t *)&icb->response_q_inpointer - (uint8_t *)&icb->version;\n\twhile (cnt--)\n\t\t*dptr1++ = *dptr2++;\n\n\ticb->login_retry_count = nv->login_retry_count;\n\ticb->link_down_on_nos = nv->link_down_on_nos;\n\n\t/* Copy 2nd segment. */\n\tdptr1 = (uint8_t *)&icb->interrupt_delay_timer;\n\tdptr2 = (uint8_t *)&nv->interrupt_delay_timer;\n\tcnt = (uint8_t *)&icb->reserved_3 -\n\t    (uint8_t *)&icb->interrupt_delay_timer;\n\twhile (cnt--)\n\t\t*dptr1++ = *dptr2++;\n\tha->frame_payload_size = le16_to_cpu(icb->frame_payload_size);\n\t/*\n\t * Setup driver NVRAM options.\n\t */\n\tqla2x00_set_model_info(vha, nv->model_name, sizeof(nv->model_name),\n\t    \"QLA2462\");\n\n\tqlt_24xx_config_nvram_stage2(vha, icb);\n\n\tif (nv->host_p & cpu_to_le32(BIT_15)) {\n\t\t/* Use alternate WWN? */\n\t\tmemcpy(icb->node_name, nv->alternate_node_name, WWN_SIZE);\n\t\tmemcpy(icb->port_name, nv->alternate_port_name, WWN_SIZE);\n\t}\n\n\t/* Prepare nodename */\n\tif ((icb->firmware_options_1 & cpu_to_le32(BIT_14)) == 0) {\n\t\t/*\n\t\t * Firmware will apply the following mask if the nodename was\n\t\t * not provided.\n\t\t */\n\t\tmemcpy(icb->node_name, icb->port_name, WWN_SIZE);\n\t\ticb->node_name[0] &= 0xF0;\n\t}\n\n\t/* Set host adapter parameters. */\n\tha->flags.disable_risc_code_load = 0;\n\tha->flags.enable_lip_reset = 0;\n\tha->flags.enable_lip_full_login =\n\t    le32_to_cpu(nv->host_p) & BIT_10 ? 1 : 0;\n\tha->flags.enable_target_reset =\n\t    le32_to_cpu(nv->host_p) & BIT_11 ? 1 : 0;\n\tha->flags.enable_led_scheme = 0;\n\tha->flags.disable_serdes = le32_to_cpu(nv->host_p) & BIT_5 ? 1 : 0;\n\n\tha->operating_mode = (le32_to_cpu(icb->firmware_options_2) &\n\t    (BIT_6 | BIT_5 | BIT_4)) >> 4;\n\n\tmemcpy(ha->fw_seriallink_options24, nv->seriallink_options,\n\t    sizeof(ha->fw_seriallink_options24));\n\n\t/* save HBA serial number */\n\tha->serial0 = icb->port_name[5];\n\tha->serial1 = icb->port_name[6];\n\tha->serial2 = icb->port_name[7];\n\tmemcpy(vha->node_name, icb->node_name, WWN_SIZE);\n\tmemcpy(vha->port_name, icb->port_name, WWN_SIZE);\n\n\ticb->execution_throttle = cpu_to_le16(0xFFFF);\n\n\tha->retry_count = le16_to_cpu(nv->login_retry_count);\n\n\t/* Set minimum login_timeout to 4 seconds. */\n\tif (le16_to_cpu(nv->login_timeout) < ql2xlogintimeout)\n\t\tnv->login_timeout = cpu_to_le16(ql2xlogintimeout);\n\tif (le16_to_cpu(nv->login_timeout) < 4)\n\t\tnv->login_timeout = cpu_to_le16(4);\n\tha->login_timeout = le16_to_cpu(nv->login_timeout);\n\n\t/* Set minimum RATOV to 100 tenths of a second. */\n\tha->r_a_tov = 100;\n\n\tha->loop_reset_delay = nv->reset_delay;\n\n\t/* Link Down Timeout = 0:\n\t *\n\t * \tWhen Port Down timer expires we will start returning\n\t *\tI/O's to OS with \"DID_NO_CONNECT\".\n\t *\n\t * Link Down Timeout != 0:\n\t *\n\t *\t The driver waits for the link to come up after link down\n\t *\t before returning I/Os to OS with \"DID_NO_CONNECT\".\n\t */\n\tif (le16_to_cpu(nv->link_down_timeout) == 0) {\n\t\tha->loop_down_abort_time =\n\t\t    (LOOP_DOWN_TIME - LOOP_DOWN_TIMEOUT);\n\t} else {\n\t\tha->link_down_timeout =\tle16_to_cpu(nv->link_down_timeout);\n\t\tha->loop_down_abort_time =\n\t\t    (LOOP_DOWN_TIME - ha->link_down_timeout);\n\t}\n\n\t/* Need enough time to try and get the port back. */\n\tha->port_down_retry_count = le16_to_cpu(nv->port_down_retry_count);\n\tif (qlport_down_retry)\n\t\tha->port_down_retry_count = qlport_down_retry;\n\n\t/* Set login_retry_count */\n\tha->login_retry_count  = le16_to_cpu(nv->login_retry_count);\n\tif (ha->port_down_retry_count ==\n\t    le16_to_cpu(nv->port_down_retry_count) &&\n\t    ha->port_down_retry_count > 3)\n\t\tha->login_retry_count = ha->port_down_retry_count;\n\telse if (ha->port_down_retry_count > (int)ha->login_retry_count)\n\t\tha->login_retry_count = ha->port_down_retry_count;\n\tif (ql2xloginretrycount)\n\t\tha->login_retry_count = ql2xloginretrycount;\n\n\t/* N2N: driver will initiate Login instead of FW */\n\ticb->firmware_options_3 |= cpu_to_le32(BIT_8);\n\n\t/* Enable ZIO. */\n\tif (!vha->flags.init_done) {\n\t\tha->zio_mode = le32_to_cpu(icb->firmware_options_2) &\n\t\t    (BIT_3 | BIT_2 | BIT_1 | BIT_0);\n\t\tha->zio_timer = le16_to_cpu(icb->interrupt_delay_timer) ?\n\t\t    le16_to_cpu(icb->interrupt_delay_timer) : 2;\n\t}\n\ticb->firmware_options_2 &= cpu_to_le32(\n\t    ~(BIT_3 | BIT_2 | BIT_1 | BIT_0));\n\tif (ha->zio_mode != QLA_ZIO_DISABLED) {\n\t\tha->zio_mode = QLA_ZIO_MODE_6;\n\n\t\tql_log(ql_log_info, vha, 0x006f,\n\t\t    \"ZIO mode %d enabled; timer delay (%d us).\\n\",\n\t\t    ha->zio_mode, ha->zio_timer * 100);\n\n\t\ticb->firmware_options_2 |= cpu_to_le32(\n\t\t    (uint32_t)ha->zio_mode);\n\t\ticb->interrupt_delay_timer = cpu_to_le16(ha->zio_timer);\n\t}\n\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x0070,\n\t\t    \"NVRAM configuration failed.\\n\");\n\t}\n\treturn (rval);\n}\n\nstatic void\nqla27xx_print_image(struct scsi_qla_host *vha, char *name,\n    struct qla27xx_image_status *image_status)\n{\n\tql_dbg(ql_dbg_init, vha, 0x018b,\n\t    \"%s %s: mask=%#02x gen=%#04x ver=%u.%u map=%#01x sum=%#08x sig=%#08x\\n\",\n\t    name, \"status\",\n\t    image_status->image_status_mask,\n\t    le16_to_cpu(image_status->generation),\n\t    image_status->ver_major,\n\t    image_status->ver_minor,\n\t    image_status->bitmap,\n\t    le32_to_cpu(image_status->checksum),\n\t    le32_to_cpu(image_status->signature));\n}\n\nstatic bool\nqla28xx_check_aux_image_status_signature(\n    struct qla27xx_image_status *image_status)\n{\n\tulong signature = le32_to_cpu(image_status->signature);\n\n\treturn signature != QLA28XX_AUX_IMG_STATUS_SIGN;\n}\n\nstatic bool\nqla27xx_check_image_status_signature(struct qla27xx_image_status *image_status)\n{\n\tulong signature = le32_to_cpu(image_status->signature);\n\n\treturn\n\t    signature != QLA27XX_IMG_STATUS_SIGN &&\n\t    signature != QLA28XX_IMG_STATUS_SIGN;\n}\n\nstatic ulong\nqla27xx_image_status_checksum(struct qla27xx_image_status *image_status)\n{\n\t__le32 *p = (__force __le32 *)image_status;\n\tuint n = sizeof(*image_status) / sizeof(*p);\n\tuint32_t sum = 0;\n\n\tfor ( ; n--; p++)\n\t\tsum += le32_to_cpup(p);\n\n\treturn sum;\n}\n\nstatic inline uint\nqla28xx_component_bitmask(struct qla27xx_image_status *aux, uint bitmask)\n{\n\treturn aux->bitmap & bitmask ?\n\t    QLA27XX_SECONDARY_IMAGE : QLA27XX_PRIMARY_IMAGE;\n}\n\nstatic void\nqla28xx_component_status(\n    struct active_regions *active_regions, struct qla27xx_image_status *aux)\n{\n\tactive_regions->aux.board_config =\n\t    qla28xx_component_bitmask(aux, QLA28XX_AUX_IMG_BOARD_CONFIG);\n\n\tactive_regions->aux.vpd_nvram =\n\t    qla28xx_component_bitmask(aux, QLA28XX_AUX_IMG_VPD_NVRAM);\n\n\tactive_regions->aux.npiv_config_0_1 =\n\t    qla28xx_component_bitmask(aux, QLA28XX_AUX_IMG_NPIV_CONFIG_0_1);\n\n\tactive_regions->aux.npiv_config_2_3 =\n\t    qla28xx_component_bitmask(aux, QLA28XX_AUX_IMG_NPIV_CONFIG_2_3);\n}\n\nstatic int\nqla27xx_compare_image_generation(\n    struct qla27xx_image_status *pri_image_status,\n    struct qla27xx_image_status *sec_image_status)\n{\n\t/* calculate generation delta as uint16 (this accounts for wrap) */\n\tint16_t delta =\n\t    le16_to_cpu(pri_image_status->generation) -\n\t    le16_to_cpu(sec_image_status->generation);\n\n\tql_dbg(ql_dbg_init, NULL, 0x0180, \"generation delta = %d\\n\", delta);\n\n\treturn delta;\n}\n\nvoid\nqla28xx_get_aux_images(\n\tstruct scsi_qla_host *vha, struct active_regions *active_regions)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla27xx_image_status pri_aux_image_status, sec_aux_image_status;\n\tbool valid_pri_image = false, valid_sec_image = false;\n\tbool active_pri_image = false, active_sec_image = false;\n\n\tif (!ha->flt_region_aux_img_status_pri) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018a, \"Primary aux image not addressed\\n\");\n\t\tgoto check_sec_image;\n\t}\n\n\tqla24xx_read_flash_data(vha, (uint32_t *)&pri_aux_image_status,\n\t    ha->flt_region_aux_img_status_pri,\n\t    sizeof(pri_aux_image_status) >> 2);\n\tqla27xx_print_image(vha, \"Primary aux image\", &pri_aux_image_status);\n\n\tif (qla28xx_check_aux_image_status_signature(&pri_aux_image_status)) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018b,\n\t\t    \"Primary aux image signature (%#x) not valid\\n\",\n\t\t    le32_to_cpu(pri_aux_image_status.signature));\n\t\tgoto check_sec_image;\n\t}\n\n\tif (qla27xx_image_status_checksum(&pri_aux_image_status)) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018c,\n\t\t    \"Primary aux image checksum failed\\n\");\n\t\tgoto check_sec_image;\n\t}\n\n\tvalid_pri_image = true;\n\n\tif (pri_aux_image_status.image_status_mask & 1) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018d,\n\t\t    \"Primary aux image is active\\n\");\n\t\tactive_pri_image = true;\n\t}\n\ncheck_sec_image:\n\tif (!ha->flt_region_aux_img_status_sec) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018a,\n\t\t    \"Secondary aux image not addressed\\n\");\n\t\tgoto check_valid_image;\n\t}\n\n\tqla24xx_read_flash_data(vha, (uint32_t *)&sec_aux_image_status,\n\t    ha->flt_region_aux_img_status_sec,\n\t    sizeof(sec_aux_image_status) >> 2);\n\tqla27xx_print_image(vha, \"Secondary aux image\", &sec_aux_image_status);\n\n\tif (qla28xx_check_aux_image_status_signature(&sec_aux_image_status)) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018b,\n\t\t    \"Secondary aux image signature (%#x) not valid\\n\",\n\t\t    le32_to_cpu(sec_aux_image_status.signature));\n\t\tgoto check_valid_image;\n\t}\n\n\tif (qla27xx_image_status_checksum(&sec_aux_image_status)) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018c,\n\t\t    \"Secondary aux image checksum failed\\n\");\n\t\tgoto check_valid_image;\n\t}\n\n\tvalid_sec_image = true;\n\n\tif (sec_aux_image_status.image_status_mask & 1) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018d,\n\t\t    \"Secondary aux image is active\\n\");\n\t\tactive_sec_image = true;\n\t}\n\ncheck_valid_image:\n\tif (valid_pri_image && active_pri_image &&\n\t    valid_sec_image && active_sec_image) {\n\t\tif (qla27xx_compare_image_generation(&pri_aux_image_status,\n\t\t    &sec_aux_image_status) >= 0) {\n\t\t\tqla28xx_component_status(active_regions,\n\t\t\t    &pri_aux_image_status);\n\t\t} else {\n\t\t\tqla28xx_component_status(active_regions,\n\t\t\t    &sec_aux_image_status);\n\t\t}\n\t} else if (valid_pri_image && active_pri_image) {\n\t\tqla28xx_component_status(active_regions, &pri_aux_image_status);\n\t} else if (valid_sec_image && active_sec_image) {\n\t\tqla28xx_component_status(active_regions, &sec_aux_image_status);\n\t}\n\n\tql_dbg(ql_dbg_init, vha, 0x018f,\n\t    \"aux images active: BCFG=%u VPD/NVR=%u NPIV0/1=%u NPIV2/3=%u\\n\",\n\t    active_regions->aux.board_config,\n\t    active_regions->aux.vpd_nvram,\n\t    active_regions->aux.npiv_config_0_1,\n\t    active_regions->aux.npiv_config_2_3);\n}\n\nvoid\nqla27xx_get_active_image(struct scsi_qla_host *vha,\n    struct active_regions *active_regions)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla27xx_image_status pri_image_status, sec_image_status;\n\tbool valid_pri_image = false, valid_sec_image = false;\n\tbool active_pri_image = false, active_sec_image = false;\n\n\tif (!ha->flt_region_img_status_pri) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018a, \"Primary image not addressed\\n\");\n\t\tgoto check_sec_image;\n\t}\n\n\tif (qla24xx_read_flash_data(vha, (uint32_t *)&pri_image_status,\n\t    ha->flt_region_img_status_pri, sizeof(pri_image_status) >> 2) !=\n\t    QLA_SUCCESS) {\n\t\tWARN_ON_ONCE(true);\n\t\tgoto check_sec_image;\n\t}\n\tqla27xx_print_image(vha, \"Primary image\", &pri_image_status);\n\n\tif (qla27xx_check_image_status_signature(&pri_image_status)) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018b,\n\t\t    \"Primary image signature (%#x) not valid\\n\",\n\t\t    le32_to_cpu(pri_image_status.signature));\n\t\tgoto check_sec_image;\n\t}\n\n\tif (qla27xx_image_status_checksum(&pri_image_status)) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018c,\n\t\t    \"Primary image checksum failed\\n\");\n\t\tgoto check_sec_image;\n\t}\n\n\tvalid_pri_image = true;\n\n\tif (pri_image_status.image_status_mask & 1) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018d,\n\t\t    \"Primary image is active\\n\");\n\t\tactive_pri_image = true;\n\t}\n\ncheck_sec_image:\n\tif (!ha->flt_region_img_status_sec) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018a, \"Secondary image not addressed\\n\");\n\t\tgoto check_valid_image;\n\t}\n\n\tqla24xx_read_flash_data(vha, (uint32_t *)(&sec_image_status),\n\t    ha->flt_region_img_status_sec, sizeof(sec_image_status) >> 2);\n\tqla27xx_print_image(vha, \"Secondary image\", &sec_image_status);\n\n\tif (qla27xx_check_image_status_signature(&sec_image_status)) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018b,\n\t\t    \"Secondary image signature (%#x) not valid\\n\",\n\t\t    le32_to_cpu(sec_image_status.signature));\n\t\tgoto check_valid_image;\n\t}\n\n\tif (qla27xx_image_status_checksum(&sec_image_status)) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018c,\n\t\t    \"Secondary image checksum failed\\n\");\n\t\tgoto check_valid_image;\n\t}\n\n\tvalid_sec_image = true;\n\n\tif (sec_image_status.image_status_mask & 1) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018d,\n\t\t    \"Secondary image is active\\n\");\n\t\tactive_sec_image = true;\n\t}\n\ncheck_valid_image:\n\tif (valid_pri_image && active_pri_image)\n\t\tactive_regions->global = QLA27XX_PRIMARY_IMAGE;\n\n\tif (valid_sec_image && active_sec_image) {\n\t\tif (!active_regions->global ||\n\t\t    qla27xx_compare_image_generation(\n\t\t\t&pri_image_status, &sec_image_status) < 0) {\n\t\t\tactive_regions->global = QLA27XX_SECONDARY_IMAGE;\n\t\t}\n\t}\n\n\tql_dbg(ql_dbg_init, vha, 0x018f, \"active image %s (%u)\\n\",\n\t    active_regions->global == QLA27XX_DEFAULT_IMAGE ?\n\t\t\"default (boot/fw)\" :\n\t    active_regions->global == QLA27XX_PRIMARY_IMAGE ?\n\t\t\"primary\" :\n\t    active_regions->global == QLA27XX_SECONDARY_IMAGE ?\n\t\t\"secondary\" : \"invalid\",\n\t    active_regions->global);\n}\n\nbool qla24xx_risc_firmware_invalid(uint32_t *dword)\n{\n\treturn\n\t    !(dword[4] | dword[5] | dword[6] | dword[7]) ||\n\t    !(~dword[4] | ~dword[5] | ~dword[6] | ~dword[7]);\n}\n\nstatic int\nqla24xx_load_risc_flash(scsi_qla_host_t *vha, uint32_t *srisc_addr,\n    uint32_t faddr)\n{\n\tint rval;\n\tuint templates, segments, fragment;\n\tulong i;\n\tuint j;\n\tulong dlen;\n\tuint32_t *dcode;\n\tuint32_t risc_addr, risc_size, risc_attr = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\tstruct fwdt *fwdt = ha->fwdt;\n\n\tql_dbg(ql_dbg_init, vha, 0x008b,\n\t    \"FW: Loading firmware from flash (%x).\\n\", faddr);\n\n\tdcode = (uint32_t *)req->ring;\n\tqla24xx_read_flash_data(vha, dcode, faddr, 8);\n\tif (qla24xx_risc_firmware_invalid(dcode)) {\n\t\tql_log(ql_log_fatal, vha, 0x008c,\n\t\t    \"Unable to verify the integrity of flash firmware \"\n\t\t    \"image.\\n\");\n\t\tql_log(ql_log_fatal, vha, 0x008d,\n\t\t    \"Firmware data: %08x %08x %08x %08x.\\n\",\n\t\t    dcode[0], dcode[1], dcode[2], dcode[3]);\n\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tdcode = (uint32_t *)req->ring;\n\t*srisc_addr = 0;\n\tsegments = FA_RISC_CODE_SEGMENTS;\n\tfor (j = 0; j < segments; j++) {\n\t\tql_dbg(ql_dbg_init, vha, 0x008d,\n\t\t    \"-> Loading segment %u...\\n\", j);\n\t\tqla24xx_read_flash_data(vha, dcode, faddr, 10);\n\t\trisc_addr = be32_to_cpu((__force __be32)dcode[2]);\n\t\trisc_size = be32_to_cpu((__force __be32)dcode[3]);\n\t\tif (!*srisc_addr) {\n\t\t\t*srisc_addr = risc_addr;\n\t\t\trisc_attr = be32_to_cpu((__force __be32)dcode[9]);\n\t\t}\n\n\t\tdlen = ha->fw_transfer_size >> 2;\n\t\tfor (fragment = 0; risc_size; fragment++) {\n\t\t\tif (dlen > risc_size)\n\t\t\t\tdlen = risc_size;\n\n\t\t\tql_dbg(ql_dbg_init, vha, 0x008e,\n\t\t\t    \"-> Loading fragment %u: %#x <- %#x (%#lx dwords)...\\n\",\n\t\t\t    fragment, risc_addr, faddr, dlen);\n\t\t\tqla24xx_read_flash_data(vha, dcode, faddr, dlen);\n\t\t\tfor (i = 0; i < dlen; i++)\n\t\t\t\tdcode[i] = swab32(dcode[i]);\n\n\t\t\trval = qla2x00_load_ram(vha, req->dma, risc_addr, dlen);\n\t\t\tif (rval) {\n\t\t\t\tql_log(ql_log_fatal, vha, 0x008f,\n\t\t\t\t    \"-> Failed load firmware fragment %u.\\n\",\n\t\t\t\t    fragment);\n\t\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t\t}\n\n\t\t\tfaddr += dlen;\n\t\t\trisc_addr += dlen;\n\t\t\trisc_size -= dlen;\n\t\t}\n\t}\n\n\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn QLA_SUCCESS;\n\n\ttemplates = (risc_attr & BIT_9) ? 2 : 1;\n\tql_dbg(ql_dbg_init, vha, 0x0160, \"-> templates = %u\\n\", templates);\n\tfor (j = 0; j < templates; j++, fwdt++) {\n\t\tif (fwdt->template)\n\t\t\tvfree(fwdt->template);\n\t\tfwdt->template = NULL;\n\t\tfwdt->length = 0;\n\n\t\tdcode = (uint32_t *)req->ring;\n\t\tqla24xx_read_flash_data(vha, dcode, faddr, 7);\n\t\trisc_size = be32_to_cpu((__force __be32)dcode[2]);\n\t\tql_dbg(ql_dbg_init, vha, 0x0161,\n\t\t    \"-> fwdt%u template array at %#x (%#x dwords)\\n\",\n\t\t    j, faddr, risc_size);\n\t\tif (!risc_size || !~risc_size) {\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0162,\n\t\t\t    \"-> fwdt%u failed to read array\\n\", j);\n\t\t\tgoto failed;\n\t\t}\n\n\t\t/* skip header and ignore checksum */\n\t\tfaddr += 7;\n\t\trisc_size -= 8;\n\n\t\tql_dbg(ql_dbg_init, vha, 0x0163,\n\t\t    \"-> fwdt%u template allocate template %#x words...\\n\",\n\t\t    j, risc_size);\n\t\tfwdt->template = vmalloc(risc_size * sizeof(*dcode));\n\t\tif (!fwdt->template) {\n\t\t\tql_log(ql_log_warn, vha, 0x0164,\n\t\t\t    \"-> fwdt%u failed allocate template.\\n\", j);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdcode = fwdt->template;\n\t\tqla24xx_read_flash_data(vha, dcode, faddr, risc_size);\n\n\t\tif (!qla27xx_fwdt_template_valid(dcode)) {\n\t\t\tql_log(ql_log_warn, vha, 0x0165,\n\t\t\t    \"-> fwdt%u failed template validate\\n\", j);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdlen = qla27xx_fwdt_template_size(dcode);\n\t\tql_dbg(ql_dbg_init, vha, 0x0166,\n\t\t    \"-> fwdt%u template size %#lx bytes (%#lx words)\\n\",\n\t\t    j, dlen, dlen / sizeof(*dcode));\n\t\tif (dlen > risc_size * sizeof(*dcode)) {\n\t\t\tql_log(ql_log_warn, vha, 0x0167,\n\t\t\t    \"-> fwdt%u template exceeds array (%-lu bytes)\\n\",\n\t\t\t    j, dlen - risc_size * sizeof(*dcode));\n\t\t\tgoto failed;\n\t\t}\n\n\t\tfwdt->length = dlen;\n\t\tql_dbg(ql_dbg_init, vha, 0x0168,\n\t\t    \"-> fwdt%u loaded template ok\\n\", j);\n\n\t\tfaddr += risc_size + 1;\n\t}\n\n\treturn QLA_SUCCESS;\n\nfailed:\n\tif (fwdt->template)\n\t\tvfree(fwdt->template);\n\tfwdt->template = NULL;\n\tfwdt->length = 0;\n\n\treturn QLA_SUCCESS;\n}\n\n#define QLA_FW_URL \"http://ldriver.qlogic.com/firmware/\"\n\nint\nqla2x00_load_risc(scsi_qla_host_t *vha, uint32_t *srisc_addr)\n{\n\tint\trval;\n\tint\ti, fragment;\n\tuint16_t *wcode;\n\t__be16\t *fwcode;\n\tuint32_t risc_addr, risc_size, fwclen, wlen, *seg;\n\tstruct fw_blob *blob;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\n\t/* Load firmware blob. */\n\tblob = qla2x00_request_firmware(vha);\n\tif (!blob) {\n\t\tql_log(ql_log_info, vha, 0x0083,\n\t\t    \"Firmware image unavailable.\\n\");\n\t\tql_log(ql_log_info, vha, 0x0084,\n\t\t    \"Firmware images can be retrieved from: \"QLA_FW_URL \".\\n\");\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\trval = QLA_SUCCESS;\n\n\twcode = (uint16_t *)req->ring;\n\t*srisc_addr = 0;\n\tfwcode = (__force __be16 *)blob->fw->data;\n\tfwclen = 0;\n\n\t/* Validate firmware image by checking version. */\n\tif (blob->fw->size < 8 * sizeof(uint16_t)) {\n\t\tql_log(ql_log_fatal, vha, 0x0085,\n\t\t    \"Unable to verify integrity of firmware image (%zd).\\n\",\n\t\t    blob->fw->size);\n\t\tgoto fail_fw_integrity;\n\t}\n\tfor (i = 0; i < 4; i++)\n\t\twcode[i] = be16_to_cpu(fwcode[i + 4]);\n\tif ((wcode[0] == 0xffff && wcode[1] == 0xffff && wcode[2] == 0xffff &&\n\t    wcode[3] == 0xffff) || (wcode[0] == 0 && wcode[1] == 0 &&\n\t\twcode[2] == 0 && wcode[3] == 0)) {\n\t\tql_log(ql_log_fatal, vha, 0x0086,\n\t\t    \"Unable to verify integrity of firmware image.\\n\");\n\t\tql_log(ql_log_fatal, vha, 0x0087,\n\t\t    \"Firmware data: %04x %04x %04x %04x.\\n\",\n\t\t    wcode[0], wcode[1], wcode[2], wcode[3]);\n\t\tgoto fail_fw_integrity;\n\t}\n\n\tseg = blob->segs;\n\twhile (*seg && rval == QLA_SUCCESS) {\n\t\trisc_addr = *seg;\n\t\t*srisc_addr = *srisc_addr == 0 ? *seg : *srisc_addr;\n\t\trisc_size = be16_to_cpu(fwcode[3]);\n\n\t\t/* Validate firmware image size. */\n\t\tfwclen += risc_size * sizeof(uint16_t);\n\t\tif (blob->fw->size < fwclen) {\n\t\t\tql_log(ql_log_fatal, vha, 0x0088,\n\t\t\t    \"Unable to verify integrity of firmware image \"\n\t\t\t    \"(%zd).\\n\", blob->fw->size);\n\t\t\tgoto fail_fw_integrity;\n\t\t}\n\n\t\tfragment = 0;\n\t\twhile (risc_size > 0 && rval == QLA_SUCCESS) {\n\t\t\twlen = (uint16_t)(ha->fw_transfer_size >> 1);\n\t\t\tif (wlen > risc_size)\n\t\t\t\twlen = risc_size;\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0089,\n\t\t\t    \"Loading risc segment@ risc addr %x number of \"\n\t\t\t    \"words 0x%x.\\n\", risc_addr, wlen);\n\n\t\t\tfor (i = 0; i < wlen; i++)\n\t\t\t\twcode[i] = swab16((__force u32)fwcode[i]);\n\n\t\t\trval = qla2x00_load_ram(vha, req->dma, risc_addr,\n\t\t\t    wlen);\n\t\t\tif (rval) {\n\t\t\t\tql_log(ql_log_fatal, vha, 0x008a,\n\t\t\t\t    \"Failed to load segment %d of firmware.\\n\",\n\t\t\t\t    fragment);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfwcode += wlen;\n\t\t\trisc_addr += wlen;\n\t\t\trisc_size -= wlen;\n\t\t\tfragment++;\n\t\t}\n\n\t\t/* Next segment. */\n\t\tseg++;\n\t}\n\treturn rval;\n\nfail_fw_integrity:\n\treturn QLA_FUNCTION_FAILED;\n}\n\nstatic int\nqla24xx_load_risc_blob(scsi_qla_host_t *vha, uint32_t *srisc_addr)\n{\n\tint\trval;\n\tuint templates, segments, fragment;\n\tuint32_t *dcode;\n\tulong dlen;\n\tuint32_t risc_addr, risc_size, risc_attr = 0;\n\tulong i;\n\tuint j;\n\tstruct fw_blob *blob;\n\t__be32 *fwcode;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\tstruct fwdt *fwdt = ha->fwdt;\n\n\tql_dbg(ql_dbg_init, vha, 0x0090,\n\t    \"-> FW: Loading via request-firmware.\\n\");\n\n\tblob = qla2x00_request_firmware(vha);\n\tif (!blob) {\n\t\tql_log(ql_log_warn, vha, 0x0092,\n\t\t    \"-> Firmware file not found.\\n\");\n\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tfwcode = (__force __be32 *)blob->fw->data;\n\tdcode = (__force uint32_t *)fwcode;\n\tif (qla24xx_risc_firmware_invalid(dcode)) {\n\t\tql_log(ql_log_fatal, vha, 0x0093,\n\t\t    \"Unable to verify integrity of firmware image (%zd).\\n\",\n\t\t    blob->fw->size);\n\t\tql_log(ql_log_fatal, vha, 0x0095,\n\t\t    \"Firmware data: %08x %08x %08x %08x.\\n\",\n\t\t    dcode[0], dcode[1], dcode[2], dcode[3]);\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tdcode = (uint32_t *)req->ring;\n\t*srisc_addr = 0;\n\tsegments = FA_RISC_CODE_SEGMENTS;\n\tfor (j = 0; j < segments; j++) {\n\t\tql_dbg(ql_dbg_init, vha, 0x0096,\n\t\t    \"-> Loading segment %u...\\n\", j);\n\t\trisc_addr = be32_to_cpu(fwcode[2]);\n\t\trisc_size = be32_to_cpu(fwcode[3]);\n\n\t\tif (!*srisc_addr) {\n\t\t\t*srisc_addr = risc_addr;\n\t\t\trisc_attr = be32_to_cpu(fwcode[9]);\n\t\t}\n\n\t\tdlen = ha->fw_transfer_size >> 2;\n\t\tfor (fragment = 0; risc_size; fragment++) {\n\t\t\tif (dlen > risc_size)\n\t\t\t\tdlen = risc_size;\n\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0097,\n\t\t\t    \"-> Loading fragment %u: %#x <- %#x (%#lx words)...\\n\",\n\t\t\t    fragment, risc_addr,\n\t\t\t    (uint32_t)(fwcode - (typeof(fwcode))blob->fw->data),\n\t\t\t    dlen);\n\n\t\t\tfor (i = 0; i < dlen; i++)\n\t\t\t\tdcode[i] = swab32((__force u32)fwcode[i]);\n\n\t\t\trval = qla2x00_load_ram(vha, req->dma, risc_addr, dlen);\n\t\t\tif (rval) {\n\t\t\t\tql_log(ql_log_fatal, vha, 0x0098,\n\t\t\t\t    \"-> Failed load firmware fragment %u.\\n\",\n\t\t\t\t    fragment);\n\t\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t\t}\n\n\t\t\tfwcode += dlen;\n\t\t\trisc_addr += dlen;\n\t\t\trisc_size -= dlen;\n\t\t}\n\t}\n\n\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn QLA_SUCCESS;\n\n\ttemplates = (risc_attr & BIT_9) ? 2 : 1;\n\tql_dbg(ql_dbg_init, vha, 0x0170, \"-> templates = %u\\n\", templates);\n\tfor (j = 0; j < templates; j++, fwdt++) {\n\t\tif (fwdt->template)\n\t\t\tvfree(fwdt->template);\n\t\tfwdt->template = NULL;\n\t\tfwdt->length = 0;\n\n\t\trisc_size = be32_to_cpu(fwcode[2]);\n\t\tql_dbg(ql_dbg_init, vha, 0x0171,\n\t\t    \"-> fwdt%u template array at %#x (%#x dwords)\\n\",\n\t\t    j, (uint32_t)((void *)fwcode - (void *)blob->fw->data),\n\t\t    risc_size);\n\t\tif (!risc_size || !~risc_size) {\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0172,\n\t\t\t    \"-> fwdt%u failed to read array\\n\", j);\n\t\t\tgoto failed;\n\t\t}\n\n\t\t/* skip header and ignore checksum */\n\t\tfwcode += 7;\n\t\trisc_size -= 8;\n\n\t\tql_dbg(ql_dbg_init, vha, 0x0173,\n\t\t    \"-> fwdt%u template allocate template %#x words...\\n\",\n\t\t    j, risc_size);\n\t\tfwdt->template = vmalloc(risc_size * sizeof(*dcode));\n\t\tif (!fwdt->template) {\n\t\t\tql_log(ql_log_warn, vha, 0x0174,\n\t\t\t    \"-> fwdt%u failed allocate template.\\n\", j);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdcode = fwdt->template;\n\t\tfor (i = 0; i < risc_size; i++)\n\t\t\tdcode[i] = (__force u32)fwcode[i];\n\n\t\tif (!qla27xx_fwdt_template_valid(dcode)) {\n\t\t\tql_log(ql_log_warn, vha, 0x0175,\n\t\t\t    \"-> fwdt%u failed template validate\\n\", j);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdlen = qla27xx_fwdt_template_size(dcode);\n\t\tql_dbg(ql_dbg_init, vha, 0x0176,\n\t\t    \"-> fwdt%u template size %#lx bytes (%#lx words)\\n\",\n\t\t    j, dlen, dlen / sizeof(*dcode));\n\t\tif (dlen > risc_size * sizeof(*dcode)) {\n\t\t\tql_log(ql_log_warn, vha, 0x0177,\n\t\t\t    \"-> fwdt%u template exceeds array (%-lu bytes)\\n\",\n\t\t\t    j, dlen - risc_size * sizeof(*dcode));\n\t\t\tgoto failed;\n\t\t}\n\n\t\tfwdt->length = dlen;\n\t\tql_dbg(ql_dbg_init, vha, 0x0178,\n\t\t    \"-> fwdt%u loaded template ok\\n\", j);\n\n\t\tfwcode += risc_size + 1;\n\t}\n\n\treturn QLA_SUCCESS;\n\nfailed:\n\tif (fwdt->template)\n\t\tvfree(fwdt->template);\n\tfwdt->template = NULL;\n\tfwdt->length = 0;\n\n\treturn QLA_SUCCESS;\n}\n\nint\nqla24xx_load_risc(scsi_qla_host_t *vha, uint32_t *srisc_addr)\n{\n\tint rval;\n\n\tif (ql2xfwloadbin == 1)\n\t\treturn qla81xx_load_risc(vha, srisc_addr);\n\n\t/*\n\t * FW Load priority:\n\t * 1) Firmware via request-firmware interface (.bin file).\n\t * 2) Firmware residing in flash.\n\t */\n\trval = qla24xx_load_risc_blob(vha, srisc_addr);\n\tif (rval == QLA_SUCCESS)\n\t\treturn rval;\n\n\treturn qla24xx_load_risc_flash(vha, srisc_addr,\n\t    vha->hw->flt_region_fw);\n}\n\nint\nqla81xx_load_risc(scsi_qla_host_t *vha, uint32_t *srisc_addr)\n{\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct active_regions active_regions = { };\n\n\tif (ql2xfwloadbin == 2)\n\t\tgoto try_blob_fw;\n\n\t/* FW Load priority:\n\t * 1) Firmware residing in flash.\n\t * 2) Firmware via request-firmware interface (.bin file).\n\t * 3) Golden-Firmware residing in flash -- (limited operation).\n\t */\n\n\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\tgoto try_primary_fw;\n\n\tqla27xx_get_active_image(vha, &active_regions);\n\n\tif (active_regions.global != QLA27XX_SECONDARY_IMAGE)\n\t\tgoto try_primary_fw;\n\n\tql_dbg(ql_dbg_init, vha, 0x008b,\n\t    \"Loading secondary firmware image.\\n\");\n\trval = qla24xx_load_risc_flash(vha, srisc_addr, ha->flt_region_fw_sec);\n\tif (!rval)\n\t\treturn rval;\n\ntry_primary_fw:\n\tql_dbg(ql_dbg_init, vha, 0x008b,\n\t    \"Loading primary firmware image.\\n\");\n\trval = qla24xx_load_risc_flash(vha, srisc_addr, ha->flt_region_fw);\n\tif (!rval)\n\t\treturn rval;\n\ntry_blob_fw:\n\trval = qla24xx_load_risc_blob(vha, srisc_addr);\n\tif (!rval || !ha->flt_region_gold_fw)\n\t\treturn rval;\n\n\tql_log(ql_log_info, vha, 0x0099,\n\t    \"Attempting to fallback to golden firmware.\\n\");\n\trval = qla24xx_load_risc_flash(vha, srisc_addr, ha->flt_region_gold_fw);\n\tif (rval)\n\t\treturn rval;\n\n\tql_log(ql_log_info, vha, 0x009a, \"Need firmware flash update.\\n\");\n\tha->flags.running_gold_fw = 1;\n\treturn rval;\n}\n\nvoid\nqla2x00_try_to_stop_firmware(scsi_qla_host_t *vha)\n{\n\tint ret, retries;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (ha->flags.pci_channel_io_perm_failure)\n\t\treturn;\n\tif (!IS_FWI2_CAPABLE(ha))\n\t\treturn;\n\tif (!ha->fw_major_version)\n\t\treturn;\n\tif (!ha->flags.fw_started)\n\t\treturn;\n\n\tret = qla2x00_stop_firmware(vha);\n\tfor (retries = 5; ret != QLA_SUCCESS && ret != QLA_FUNCTION_TIMEOUT &&\n\t    ret != QLA_INVALID_COMMAND && retries ; retries--) {\n\t\tha->isp_ops->reset_chip(vha);\n\t\tif (ha->isp_ops->chip_diag(vha) != QLA_SUCCESS)\n\t\t\tcontinue;\n\t\tif (qla2x00_setup_chip(vha) != QLA_SUCCESS)\n\t\t\tcontinue;\n\t\tql_log(ql_log_info, vha, 0x8015,\n\t\t    \"Attempting retry of stop-firmware command.\\n\");\n\t\tret = qla2x00_stop_firmware(vha);\n\t}\n\n\tQLA_FW_STOPPED(ha);\n\tha->flags.fw_init_done = 0;\n}\n\nint\nqla24xx_configure_vhba(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tint rval2;\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\n\tif (!vha->vp_idx)\n\t\treturn -EINVAL;\n\n\trval = qla2x00_fw_ready(base_vha);\n\n\tif (rval == QLA_SUCCESS) {\n\t\tclear_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\n\t\tqla2x00_marker(vha, ha->base_qpair, 0, 0, MK_SYNC_ALL);\n\t}\n\n\tvha->flags.management_server_logged_in = 0;\n\n\t/* Login to SNS first */\n\trval2 = ha->isp_ops->fabric_login(vha, NPH_SNS, 0xff, 0xff, 0xfc, mb,\n\t    BIT_1);\n\tif (rval2 != QLA_SUCCESS || mb[0] != MBS_COMMAND_COMPLETE) {\n\t\tif (rval2 == QLA_MEMORY_ALLOC_FAILED)\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0120,\n\t\t\t    \"Failed SNS login: loop_id=%x, rval2=%d\\n\",\n\t\t\t    NPH_SNS, rval2);\n\t\telse\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0103,\n\t\t\t    \"Failed SNS login: loop_id=%x mb[0]=%x mb[1]=%x \"\n\t\t\t    \"mb[2]=%x mb[6]=%x mb[7]=%x.\\n\",\n\t\t\t    NPH_SNS, mb[0], mb[1], mb[2], mb[6], mb[7]);\n\t\treturn (QLA_FUNCTION_FAILED);\n\t}\n\n\tatomic_set(&vha->loop_down_timer, 0);\n\tatomic_set(&vha->loop_state, LOOP_UP);\n\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\trval = qla2x00_loop_resync(base_vha);\n\n\treturn rval;\n}\n\n/* 84XX Support **************************************************************/\n\nstatic LIST_HEAD(qla_cs84xx_list);\nstatic DEFINE_MUTEX(qla_cs84xx_mutex);\n\nstatic struct qla_chip_state_84xx *\nqla84xx_get_chip(struct scsi_qla_host *vha)\n{\n\tstruct qla_chip_state_84xx *cs84xx;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tmutex_lock(&qla_cs84xx_mutex);\n\n\t/* Find any shared 84xx chip. */\n\tlist_for_each_entry(cs84xx, &qla_cs84xx_list, list) {\n\t\tif (cs84xx->bus == ha->pdev->bus) {\n\t\t\tkref_get(&cs84xx->kref);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tcs84xx = kzalloc(sizeof(*cs84xx), GFP_KERNEL);\n\tif (!cs84xx)\n\t\tgoto done;\n\n\tkref_init(&cs84xx->kref);\n\tspin_lock_init(&cs84xx->access_lock);\n\tmutex_init(&cs84xx->fw_update_mutex);\n\tcs84xx->bus = ha->pdev->bus;\n\n\tlist_add_tail(&cs84xx->list, &qla_cs84xx_list);\ndone:\n\tmutex_unlock(&qla_cs84xx_mutex);\n\treturn cs84xx;\n}\n\nstatic void\n__qla84xx_chip_release(struct kref *kref)\n{\n\tstruct qla_chip_state_84xx *cs84xx =\n\t    container_of(kref, struct qla_chip_state_84xx, kref);\n\n\tmutex_lock(&qla_cs84xx_mutex);\n\tlist_del(&cs84xx->list);\n\tmutex_unlock(&qla_cs84xx_mutex);\n\tkfree(cs84xx);\n}\n\nvoid\nqla84xx_put_chip(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (ha->cs84xx)\n\t\tkref_put(&ha->cs84xx->kref, __qla84xx_chip_release);\n}\n\nstatic int\nqla84xx_init_chip(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tuint16_t status[2];\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tmutex_lock(&ha->cs84xx->fw_update_mutex);\n\n\trval = qla84xx_verify_chip(vha, status);\n\n\tmutex_unlock(&ha->cs84xx->fw_update_mutex);\n\n\treturn rval != QLA_SUCCESS || status[0] ? QLA_FUNCTION_FAILED :\n\t    QLA_SUCCESS;\n}\n\n/* 81XX Support **************************************************************/\n\nint\nqla81xx_nvram_config(scsi_qla_host_t *vha)\n{\n\tint   rval;\n\tstruct init_cb_81xx *icb;\n\tstruct nvram_81xx *nv;\n\t__le32 *dptr;\n\tuint8_t  *dptr1, *dptr2;\n\tuint32_t chksum;\n\tuint16_t cnt;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t faddr;\n\tstruct active_regions active_regions = { };\n\n\trval = QLA_SUCCESS;\n\ticb = (struct init_cb_81xx *)ha->init_cb;\n\tnv = ha->nvram;\n\n\t/* Determine NVRAM starting address. */\n\tha->nvram_size = sizeof(*nv);\n\tha->vpd_size = FA_NVRAM_VPD_SIZE;\n\tif (IS_P3P_TYPE(ha) || IS_QLA8031(ha))\n\t\tha->vpd_size = FA_VPD_SIZE_82XX;\n\n\tif (IS_QLA28XX(ha) || IS_QLA27XX(ha))\n\t\tqla28xx_get_aux_images(vha, &active_regions);\n\n\t/* Get VPD data into cache */\n\tha->vpd = ha->nvram + VPD_OFFSET;\n\n\tfaddr = ha->flt_region_vpd;\n\tif (IS_QLA28XX(ha)) {\n\t\tif (active_regions.aux.vpd_nvram == QLA27XX_SECONDARY_IMAGE)\n\t\t\tfaddr = ha->flt_region_vpd_sec;\n\t\tql_dbg(ql_dbg_init, vha, 0x0110,\n\t\t    \"Loading %s nvram image.\\n\",\n\t\t    active_regions.aux.vpd_nvram == QLA27XX_PRIMARY_IMAGE ?\n\t\t    \"primary\" : \"secondary\");\n\t}\n\tha->isp_ops->read_optrom(vha, ha->vpd, faddr << 2, ha->vpd_size);\n\n\t/* Get NVRAM data into cache and calculate checksum. */\n\tfaddr = ha->flt_region_nvram;\n\tif (IS_QLA28XX(ha)) {\n\t\tif (active_regions.aux.vpd_nvram == QLA27XX_SECONDARY_IMAGE)\n\t\t\tfaddr = ha->flt_region_nvram_sec;\n\t}\n\tql_dbg(ql_dbg_init, vha, 0x0110,\n\t    \"Loading %s nvram image.\\n\",\n\t    active_regions.aux.vpd_nvram == QLA27XX_PRIMARY_IMAGE ?\n\t    \"primary\" : \"secondary\");\n\tha->isp_ops->read_optrom(vha, ha->nvram, faddr << 2, ha->nvram_size);\n\n\tdptr = (__force __le32 *)nv;\n\tfor (cnt = 0, chksum = 0; cnt < ha->nvram_size >> 2; cnt++, dptr++)\n\t\tchksum += le32_to_cpu(*dptr);\n\n\tql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x0111,\n\t    \"Contents of NVRAM:\\n\");\n\tql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0112,\n\t    nv, ha->nvram_size);\n\n\t/* Bad NVRAM data, set defaults parameters. */\n\tif (chksum || memcmp(\"ISP \", nv->id, sizeof(nv->id)) ||\n\t    le16_to_cpu(nv->nvram_version) < ICB_VERSION) {\n\t\t/* Reset NVRAM data. */\n\t\tql_log(ql_log_info, vha, 0x0073,\n\t\t    \"Inconsistent NVRAM checksum=%#x id=%.4s version=%#x.\\n\",\n\t\t    chksum, nv->id, le16_to_cpu(nv->nvram_version));\n\t\tql_dump_buffer(ql_dbg_init, vha, 0x0073, nv, sizeof(*nv));\n\t\tql_log(ql_log_info, vha, 0x0074,\n\t\t    \"Falling back to functioning (yet invalid -- WWPN) \"\n\t\t    \"defaults.\\n\");\n\n\t\t/*\n\t\t * Set default initialization control block.\n\t\t */\n\t\tmemset(nv, 0, ha->nvram_size);\n\t\tnv->nvram_version = cpu_to_le16(ICB_VERSION);\n\t\tnv->version = cpu_to_le16(ICB_VERSION);\n\t\tnv->frame_payload_size = cpu_to_le16(2048);\n\t\tnv->execution_throttle = cpu_to_le16(0xFFFF);\n\t\tnv->exchange_count = cpu_to_le16(0);\n\t\tnv->port_name[0] = 0x21;\n\t\tnv->port_name[1] = 0x00 + ha->port_no + 1;\n\t\tnv->port_name[2] = 0x00;\n\t\tnv->port_name[3] = 0xe0;\n\t\tnv->port_name[4] = 0x8b;\n\t\tnv->port_name[5] = 0x1c;\n\t\tnv->port_name[6] = 0x55;\n\t\tnv->port_name[7] = 0x86;\n\t\tnv->node_name[0] = 0x20;\n\t\tnv->node_name[1] = 0x00;\n\t\tnv->node_name[2] = 0x00;\n\t\tnv->node_name[3] = 0xe0;\n\t\tnv->node_name[4] = 0x8b;\n\t\tnv->node_name[5] = 0x1c;\n\t\tnv->node_name[6] = 0x55;\n\t\tnv->node_name[7] = 0x86;\n\t\tnv->login_retry_count = cpu_to_le16(8);\n\t\tnv->interrupt_delay_timer = cpu_to_le16(0);\n\t\tnv->login_timeout = cpu_to_le16(0);\n\t\tnv->firmware_options_1 =\n\t\t    cpu_to_le32(BIT_14|BIT_13|BIT_2|BIT_1);\n\t\tnv->firmware_options_2 = cpu_to_le32(2 << 4);\n\t\tnv->firmware_options_2 |= cpu_to_le32(BIT_12);\n\t\tnv->firmware_options_3 = cpu_to_le32(2 << 13);\n\t\tnv->host_p = cpu_to_le32(BIT_11|BIT_10);\n\t\tnv->efi_parameters = cpu_to_le32(0);\n\t\tnv->reset_delay = 5;\n\t\tnv->max_luns_per_target = cpu_to_le16(128);\n\t\tnv->port_down_retry_count = cpu_to_le16(30);\n\t\tnv->link_down_timeout = cpu_to_le16(180);\n\t\tnv->enode_mac[0] = 0x00;\n\t\tnv->enode_mac[1] = 0xC0;\n\t\tnv->enode_mac[2] = 0xDD;\n\t\tnv->enode_mac[3] = 0x04;\n\t\tnv->enode_mac[4] = 0x05;\n\t\tnv->enode_mac[5] = 0x06 + ha->port_no + 1;\n\n\t\trval = 1;\n\t}\n\n\tif (IS_T10_PI_CAPABLE(ha))\n\t\tnv->frame_payload_size &= cpu_to_le16(~7);\n\n\tqlt_81xx_config_nvram_stage1(vha, nv);\n\n\t/* Reset Initialization control block */\n\tmemset(icb, 0, ha->init_cb_size);\n\n\t/* Copy 1st segment. */\n\tdptr1 = (uint8_t *)icb;\n\tdptr2 = (uint8_t *)&nv->version;\n\tcnt = (uint8_t *)&icb->response_q_inpointer - (uint8_t *)&icb->version;\n\twhile (cnt--)\n\t\t*dptr1++ = *dptr2++;\n\n\ticb->login_retry_count = nv->login_retry_count;\n\n\t/* Copy 2nd segment. */\n\tdptr1 = (uint8_t *)&icb->interrupt_delay_timer;\n\tdptr2 = (uint8_t *)&nv->interrupt_delay_timer;\n\tcnt = (uint8_t *)&icb->reserved_5 -\n\t    (uint8_t *)&icb->interrupt_delay_timer;\n\twhile (cnt--)\n\t\t*dptr1++ = *dptr2++;\n\n\tmemcpy(icb->enode_mac, nv->enode_mac, sizeof(icb->enode_mac));\n\t/* Some boards (with valid NVRAMs) still have NULL enode_mac!! */\n\tif (!memcmp(icb->enode_mac, \"\\0\\0\\0\\0\\0\\0\", sizeof(icb->enode_mac))) {\n\t\ticb->enode_mac[0] = 0x00;\n\t\ticb->enode_mac[1] = 0xC0;\n\t\ticb->enode_mac[2] = 0xDD;\n\t\ticb->enode_mac[3] = 0x04;\n\t\ticb->enode_mac[4] = 0x05;\n\t\ticb->enode_mac[5] = 0x06 + ha->port_no + 1;\n\t}\n\n\t/* Use extended-initialization control block. */\n\tmemcpy(ha->ex_init_cb, &nv->ex_version, sizeof(*ha->ex_init_cb));\n\tha->frame_payload_size = le16_to_cpu(icb->frame_payload_size);\n\t/*\n\t * Setup driver NVRAM options.\n\t */\n\tqla2x00_set_model_info(vha, nv->model_name, sizeof(nv->model_name),\n\t    \"QLE8XXX\");\n\n\tqlt_81xx_config_nvram_stage2(vha, icb);\n\n\t/* Use alternate WWN? */\n\tif (nv->host_p & cpu_to_le32(BIT_15)) {\n\t\tmemcpy(icb->node_name, nv->alternate_node_name, WWN_SIZE);\n\t\tmemcpy(icb->port_name, nv->alternate_port_name, WWN_SIZE);\n\t}\n\n\t/* Prepare nodename */\n\tif ((icb->firmware_options_1 & cpu_to_le32(BIT_14)) == 0) {\n\t\t/*\n\t\t * Firmware will apply the following mask if the nodename was\n\t\t * not provided.\n\t\t */\n\t\tmemcpy(icb->node_name, icb->port_name, WWN_SIZE);\n\t\ticb->node_name[0] &= 0xF0;\n\t}\n\n\tif (IS_QLA28XX(ha) || IS_QLA27XX(ha)) {\n\t\tif ((nv->enhanced_features & BIT_7) == 0)\n\t\t\tha->flags.scm_supported_a = 1;\n\t}\n\n\t/* Set host adapter parameters. */\n\tha->flags.disable_risc_code_load = 0;\n\tha->flags.enable_lip_reset = 0;\n\tha->flags.enable_lip_full_login =\n\t    le32_to_cpu(nv->host_p) & BIT_10 ? 1 : 0;\n\tha->flags.enable_target_reset =\n\t    le32_to_cpu(nv->host_p) & BIT_11 ? 1 : 0;\n\tha->flags.enable_led_scheme = 0;\n\tha->flags.disable_serdes = le32_to_cpu(nv->host_p) & BIT_5 ? 1 : 0;\n\n\tha->operating_mode = (le32_to_cpu(icb->firmware_options_2) &\n\t    (BIT_6 | BIT_5 | BIT_4)) >> 4;\n\n\t/* save HBA serial number */\n\tha->serial0 = icb->port_name[5];\n\tha->serial1 = icb->port_name[6];\n\tha->serial2 = icb->port_name[7];\n\tmemcpy(vha->node_name, icb->node_name, WWN_SIZE);\n\tmemcpy(vha->port_name, icb->port_name, WWN_SIZE);\n\n\ticb->execution_throttle = cpu_to_le16(0xFFFF);\n\n\tha->retry_count = le16_to_cpu(nv->login_retry_count);\n\n\t/* Set minimum login_timeout to 4 seconds. */\n\tif (le16_to_cpu(nv->login_timeout) < ql2xlogintimeout)\n\t\tnv->login_timeout = cpu_to_le16(ql2xlogintimeout);\n\tif (le16_to_cpu(nv->login_timeout) < 4)\n\t\tnv->login_timeout = cpu_to_le16(4);\n\tha->login_timeout = le16_to_cpu(nv->login_timeout);\n\n\t/* Set minimum RATOV to 100 tenths of a second. */\n\tha->r_a_tov = 100;\n\n\tha->loop_reset_delay = nv->reset_delay;\n\n\t/* Link Down Timeout = 0:\n\t *\n\t *\tWhen Port Down timer expires we will start returning\n\t *\tI/O's to OS with \"DID_NO_CONNECT\".\n\t *\n\t * Link Down Timeout != 0:\n\t *\n\t *\t The driver waits for the link to come up after link down\n\t *\t before returning I/Os to OS with \"DID_NO_CONNECT\".\n\t */\n\tif (le16_to_cpu(nv->link_down_timeout) == 0) {\n\t\tha->loop_down_abort_time =\n\t\t    (LOOP_DOWN_TIME - LOOP_DOWN_TIMEOUT);\n\t} else {\n\t\tha->link_down_timeout =\tle16_to_cpu(nv->link_down_timeout);\n\t\tha->loop_down_abort_time =\n\t\t    (LOOP_DOWN_TIME - ha->link_down_timeout);\n\t}\n\n\t/* Need enough time to try and get the port back. */\n\tha->port_down_retry_count = le16_to_cpu(nv->port_down_retry_count);\n\tif (qlport_down_retry)\n\t\tha->port_down_retry_count = qlport_down_retry;\n\n\t/* Set login_retry_count */\n\tha->login_retry_count  = le16_to_cpu(nv->login_retry_count);\n\tif (ha->port_down_retry_count ==\n\t    le16_to_cpu(nv->port_down_retry_count) &&\n\t    ha->port_down_retry_count > 3)\n\t\tha->login_retry_count = ha->port_down_retry_count;\n\telse if (ha->port_down_retry_count > (int)ha->login_retry_count)\n\t\tha->login_retry_count = ha->port_down_retry_count;\n\tif (ql2xloginretrycount)\n\t\tha->login_retry_count = ql2xloginretrycount;\n\n\t/* if not running MSI-X we need handshaking on interrupts */\n\tif (!vha->hw->flags.msix_enabled &&\n\t    (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)))\n\t\ticb->firmware_options_2 |= cpu_to_le32(BIT_22);\n\n\t/* Enable ZIO. */\n\tif (!vha->flags.init_done) {\n\t\tha->zio_mode = le32_to_cpu(icb->firmware_options_2) &\n\t\t    (BIT_3 | BIT_2 | BIT_1 | BIT_0);\n\t\tha->zio_timer = le16_to_cpu(icb->interrupt_delay_timer) ?\n\t\t    le16_to_cpu(icb->interrupt_delay_timer) : 2;\n\t}\n\ticb->firmware_options_2 &= cpu_to_le32(\n\t    ~(BIT_3 | BIT_2 | BIT_1 | BIT_0));\n\tvha->flags.process_response_queue = 0;\n\tif (ha->zio_mode != QLA_ZIO_DISABLED) {\n\t\tha->zio_mode = QLA_ZIO_MODE_6;\n\n\t\tql_log(ql_log_info, vha, 0x0075,\n\t\t    \"ZIO mode %d enabled; timer delay (%d us).\\n\",\n\t\t    ha->zio_mode,\n\t\t    ha->zio_timer * 100);\n\n\t\ticb->firmware_options_2 |= cpu_to_le32(\n\t\t    (uint32_t)ha->zio_mode);\n\t\ticb->interrupt_delay_timer = cpu_to_le16(ha->zio_timer);\n\t\tvha->flags.process_response_queue = 1;\n\t}\n\n\t /* enable RIDA Format2 */\n\ticb->firmware_options_3 |= cpu_to_le32(BIT_0);\n\n\t/* N2N: driver will initiate Login instead of FW */\n\ticb->firmware_options_3 |= cpu_to_le32(BIT_8);\n\n\t/* Determine NVMe/FCP priority for target ports */\n\tha->fc4_type_priority = qla2xxx_get_fc4_priority(vha);\n\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x0076,\n\t\t    \"NVRAM configuration failed.\\n\");\n\t}\n\treturn (rval);\n}\n\nint\nqla82xx_restart_isp(scsi_qla_host_t *vha)\n{\n\tint status, rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *vp;\n\tunsigned long flags;\n\n\tstatus = qla2x00_init_rings(vha);\n\tif (!status) {\n\t\tclear_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\n\t\tha->flags.chip_reset_done = 1;\n\n\t\tstatus = qla2x00_fw_ready(vha);\n\t\tif (!status) {\n\t\t\t/* Issue a marker after FW becomes ready. */\n\t\t\tqla2x00_marker(vha, ha->base_qpair, 0, 0, MK_SYNC_ALL);\n\t\t\tvha->flags.online = 1;\n\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t}\n\n\t\t/* if no cable then assume it's good */\n\t\tif ((vha->device_flags & DFLG_NO_CABLE))\n\t\t\tstatus = 0;\n\t}\n\n\tif (!status) {\n\t\tclear_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\n\n\t\tif (!atomic_read(&vha->loop_down_timer)) {\n\t\t\t/*\n\t\t\t * Issue marker command only when we are going\n\t\t\t * to start the I/O .\n\t\t\t */\n\t\t\tvha->marker_needed = 1;\n\t\t}\n\n\t\tha->isp_ops->enable_intrs(ha);\n\n\t\tha->isp_abort_cnt = 0;\n\t\tclear_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\n\n\t\t/* Update the firmware version */\n\t\tstatus = qla82xx_check_md_needed(vha);\n\n\t\tif (ha->fce) {\n\t\t\tha->flags.fce_enabled = 1;\n\t\t\tmemset(ha->fce, 0,\n\t\t\t    fce_calc_size(ha->fce_bufs));\n\t\t\trval = qla2x00_enable_fce_trace(vha,\n\t\t\t    ha->fce_dma, ha->fce_bufs, ha->fce_mb,\n\t\t\t    &ha->fce_bufs);\n\t\t\tif (rval) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x8001,\n\t\t\t\t    \"Unable to reinitialize FCE (%d).\\n\",\n\t\t\t\t    rval);\n\t\t\t\tha->flags.fce_enabled = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (ha->eft) {\n\t\t\tmemset(ha->eft, 0, EFT_SIZE);\n\t\t\trval = qla2x00_enable_eft_trace(vha,\n\t\t\t    ha->eft_dma, EFT_NUM_BUFFERS);\n\t\t\tif (rval) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x8010,\n\t\t\t\t    \"Unable to reinitialize EFT (%d).\\n\",\n\t\t\t\t    rval);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!status) {\n\t\tql_dbg(ql_dbg_taskm, vha, 0x8011,\n\t\t    \"qla82xx_restart_isp succeeded.\\n\");\n\n\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\tlist_for_each_entry(vp, &ha->vp_list, list) {\n\t\t\tif (vp->vp_idx) {\n\t\t\t\tatomic_inc(&vp->vref_count);\n\t\t\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\t\t\t\tqla2x00_vp_abort_isp(vp);\n\n\t\t\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\t\t\tatomic_dec(&vp->vref_count);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\t} else {\n\t\tql_log(ql_log_warn, vha, 0x8016,\n\t\t    \"qla82xx_restart_isp **** FAILED ****.\\n\");\n\t}\n\n\treturn status;\n}\n\n/*\n * qla24xx_get_fcp_prio\n *\tGets the fcp cmd priority value for the logged in port.\n *\tLooks for a match of the port descriptors within\n *\teach of the fcp prio config entries. If a match is found,\n *\tthe tag (priority) value is returned.\n *\n * Input:\n *\tvha = scsi host structure pointer.\n *\tfcport = port structure pointer.\n *\n * Return:\n *\tnon-zero (if found)\n *\t-1 (if not found)\n *\n * Context:\n * \tKernel context\n */\nstatic int\nqla24xx_get_fcp_prio(scsi_qla_host_t *vha, fc_port_t *fcport)\n{\n\tint i, entries;\n\tuint8_t pid_match, wwn_match;\n\tint priority;\n\tuint32_t pid1, pid2;\n\tuint64_t wwn1, wwn2;\n\tstruct qla_fcp_prio_entry *pri_entry;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!ha->fcp_prio_cfg || !ha->flags.fcp_prio_enabled)\n\t\treturn -1;\n\n\tpriority = -1;\n\tentries = ha->fcp_prio_cfg->num_entries;\n\tpri_entry = &ha->fcp_prio_cfg->entry[0];\n\n\tfor (i = 0; i < entries; i++) {\n\t\tpid_match = wwn_match = 0;\n\n\t\tif (!(pri_entry->flags & FCP_PRIO_ENTRY_VALID)) {\n\t\t\tpri_entry++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* check source pid for a match */\n\t\tif (pri_entry->flags & FCP_PRIO_ENTRY_SPID_VALID) {\n\t\t\tpid1 = pri_entry->src_pid & INVALID_PORT_ID;\n\t\t\tpid2 = vha->d_id.b24 & INVALID_PORT_ID;\n\t\t\tif (pid1 == INVALID_PORT_ID)\n\t\t\t\tpid_match++;\n\t\t\telse if (pid1 == pid2)\n\t\t\t\tpid_match++;\n\t\t}\n\n\t\t/* check destination pid for a match */\n\t\tif (pri_entry->flags & FCP_PRIO_ENTRY_DPID_VALID) {\n\t\t\tpid1 = pri_entry->dst_pid & INVALID_PORT_ID;\n\t\t\tpid2 = fcport->d_id.b24 & INVALID_PORT_ID;\n\t\t\tif (pid1 == INVALID_PORT_ID)\n\t\t\t\tpid_match++;\n\t\t\telse if (pid1 == pid2)\n\t\t\t\tpid_match++;\n\t\t}\n\n\t\t/* check source WWN for a match */\n\t\tif (pri_entry->flags & FCP_PRIO_ENTRY_SWWN_VALID) {\n\t\t\twwn1 = wwn_to_u64(vha->port_name);\n\t\t\twwn2 = wwn_to_u64(pri_entry->src_wwpn);\n\t\t\tif (wwn2 == (uint64_t)-1)\n\t\t\t\twwn_match++;\n\t\t\telse if (wwn1 == wwn2)\n\t\t\t\twwn_match++;\n\t\t}\n\n\t\t/* check destination WWN for a match */\n\t\tif (pri_entry->flags & FCP_PRIO_ENTRY_DWWN_VALID) {\n\t\t\twwn1 = wwn_to_u64(fcport->port_name);\n\t\t\twwn2 = wwn_to_u64(pri_entry->dst_wwpn);\n\t\t\tif (wwn2 == (uint64_t)-1)\n\t\t\t\twwn_match++;\n\t\t\telse if (wwn1 == wwn2)\n\t\t\t\twwn_match++;\n\t\t}\n\n\t\tif (pid_match == 2 || wwn_match == 2) {\n\t\t\t/* Found a matching entry */\n\t\t\tif (pri_entry->flags & FCP_PRIO_ENTRY_TAG_VALID)\n\t\t\t\tpriority = pri_entry->tag;\n\t\t\tbreak;\n\t\t}\n\n\t\tpri_entry++;\n\t}\n\n\treturn priority;\n}\n\n/*\n * qla24xx_update_fcport_fcp_prio\n *\tActivates fcp priority for the logged in fc port\n *\n * Input:\n *\tvha = scsi host structure pointer.\n *\tfcp = port structure pointer.\n *\n * Return:\n *\tQLA_SUCCESS or QLA_FUNCTION_FAILED\n *\n * Context:\n *\tKernel context.\n */\nint\nqla24xx_update_fcport_fcp_prio(scsi_qla_host_t *vha, fc_port_t *fcport)\n{\n\tint ret;\n\tint priority;\n\tuint16_t mb[5];\n\n\tif (fcport->port_type != FCT_TARGET ||\n\t    fcport->loop_id == FC_NO_LOOP_ID)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tpriority = qla24xx_get_fcp_prio(vha, fcport);\n\tif (priority < 0)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tif (IS_P3P_TYPE(vha->hw)) {\n\t\tfcport->fcp_prio = priority & 0xf;\n\t\treturn QLA_SUCCESS;\n\t}\n\n\tret = qla24xx_set_fcp_prio(vha, fcport->loop_id, priority, mb);\n\tif (ret == QLA_SUCCESS) {\n\t\tif (fcport->fcp_prio != priority)\n\t\t\tql_dbg(ql_dbg_user, vha, 0x709e,\n\t\t\t    \"Updated FCP_CMND priority - value=%d loop_id=%d \"\n\t\t\t    \"port_id=%02x%02x%02x.\\n\", priority,\n\t\t\t    fcport->loop_id, fcport->d_id.b.domain,\n\t\t\t    fcport->d_id.b.area, fcport->d_id.b.al_pa);\n\t\tfcport->fcp_prio = priority & 0xf;\n\t} else\n\t\tql_dbg(ql_dbg_user, vha, 0x704f,\n\t\t    \"Unable to update FCP_CMND priority - ret=0x%x for \"\n\t\t    \"loop_id=%d port_id=%02x%02x%02x.\\n\", ret, fcport->loop_id,\n\t\t    fcport->d_id.b.domain, fcport->d_id.b.area,\n\t\t    fcport->d_id.b.al_pa);\n\treturn  ret;\n}\n\n/*\n * qla24xx_update_all_fcp_prio\n *\tActivates fcp priority for all the logged in ports\n *\n * Input:\n *\tha = adapter block pointer.\n *\n * Return:\n *\tQLA_SUCCESS or QLA_FUNCTION_FAILED\n *\n * Context:\n *\tKernel context.\n */\nint\nqla24xx_update_all_fcp_prio(scsi_qla_host_t *vha)\n{\n\tint ret;\n\tfc_port_t *fcport;\n\n\tret = QLA_FUNCTION_FAILED;\n\t/* We need to set priority for all logged in ports */\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list)\n\t\tret = qla24xx_update_fcport_fcp_prio(vha, fcport);\n\n\treturn ret;\n}\n\nstruct qla_qpair *qla2xxx_create_qpair(struct scsi_qla_host *vha, int qos,\n\tint vp_idx, bool startqp)\n{\n\tint rsp_id = 0;\n\tint  req_id = 0;\n\tint i;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint16_t qpair_id = 0;\n\tstruct qla_qpair *qpair = NULL;\n\tstruct qla_msix_entry *msix;\n\n\tif (!(ha->fw_attributes & BIT_6) || !ha->flags.msix_enabled) {\n\t\tql_log(ql_log_warn, vha, 0x00181,\n\t\t    \"FW/Driver is not multi-queue capable.\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (ql2xmqsupport || ql2xnvmeenable) {\n\t\tqpair = kzalloc(sizeof(struct qla_qpair), GFP_KERNEL);\n\t\tif (qpair == NULL) {\n\t\t\tql_log(ql_log_warn, vha, 0x0182,\n\t\t\t    \"Failed to allocate memory for queue pair.\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tqpair->hw = vha->hw;\n\t\tqpair->vha = vha;\n\t\tqpair->qp_lock_ptr = &qpair->qp_lock;\n\t\tspin_lock_init(&qpair->qp_lock);\n\t\tqpair->use_shadow_reg = IS_SHADOW_REG_CAPABLE(ha) ? 1 : 0;\n\n\t\t/* Assign available que pair id */\n\t\tmutex_lock(&ha->mq_lock);\n\t\tqpair_id = find_first_zero_bit(ha->qpair_qid_map, ha->max_qpairs);\n\t\tif (ha->num_qpairs >= ha->max_qpairs) {\n\t\t\tmutex_unlock(&ha->mq_lock);\n\t\t\tql_log(ql_log_warn, vha, 0x0183,\n\t\t\t    \"No resources to create additional q pair.\\n\");\n\t\t\tgoto fail_qid_map;\n\t\t}\n\t\tha->num_qpairs++;\n\t\tset_bit(qpair_id, ha->qpair_qid_map);\n\t\tha->queue_pair_map[qpair_id] = qpair;\n\t\tqpair->id = qpair_id;\n\t\tqpair->vp_idx = vp_idx;\n\t\tqpair->fw_started = ha->flags.fw_started;\n\t\tINIT_LIST_HEAD(&qpair->hints_list);\n\t\tqpair->chip_reset = ha->base_qpair->chip_reset;\n\t\tqpair->enable_class_2 = ha->base_qpair->enable_class_2;\n\t\tqpair->enable_explicit_conf =\n\t\t    ha->base_qpair->enable_explicit_conf;\n\n\t\tfor (i = 0; i < ha->msix_count; i++) {\n\t\t\tmsix = &ha->msix_entries[i];\n\t\t\tif (msix->in_use)\n\t\t\t\tcontinue;\n\t\t\tqpair->msix = msix;\n\t\t\tql_dbg(ql_dbg_multiq, vha, 0xc00f,\n\t\t\t    \"Vector %x selected for qpair\\n\", msix->vector);\n\t\t\tbreak;\n\t\t}\n\t\tif (!qpair->msix) {\n\t\t\tql_log(ql_log_warn, vha, 0x0184,\n\t\t\t    \"Out of MSI-X vectors!.\\n\");\n\t\t\tgoto fail_msix;\n\t\t}\n\n\t\tqpair->msix->in_use = 1;\n\t\tlist_add_tail(&qpair->qp_list_elem, &vha->qp_list);\n\t\tqpair->pdev = ha->pdev;\n\t\tif (IS_QLA27XX(ha) || IS_QLA83XX(ha) || IS_QLA28XX(ha))\n\t\t\tqpair->reqq_start_iocbs = qla_83xx_start_iocbs;\n\n\t\tmutex_unlock(&ha->mq_lock);\n\n\t\t/* Create response queue first */\n\t\trsp_id = qla25xx_create_rsp_que(ha, 0, 0, 0, qpair, startqp);\n\t\tif (!rsp_id) {\n\t\t\tql_log(ql_log_warn, vha, 0x0185,\n\t\t\t    \"Failed to create response queue.\\n\");\n\t\t\tgoto fail_rsp;\n\t\t}\n\n\t\tqpair->rsp = ha->rsp_q_map[rsp_id];\n\n\t\t/* Create request queue */\n\t\treq_id = qla25xx_create_req_que(ha, 0, vp_idx, 0, rsp_id, qos,\n\t\t    startqp);\n\t\tif (!req_id) {\n\t\t\tql_log(ql_log_warn, vha, 0x0186,\n\t\t\t    \"Failed to create request queue.\\n\");\n\t\t\tgoto fail_req;\n\t\t}\n\n\t\tqpair->req = ha->req_q_map[req_id];\n\t\tqpair->rsp->req = qpair->req;\n\t\tqpair->rsp->qpair = qpair;\n\t\t/* init qpair to this cpu. Will adjust at run time. */\n\t\tqla_cpu_update(qpair, smp_processor_id());\n\n\t\tif (IS_T10_PI_CAPABLE(ha) && ql2xenabledif) {\n\t\t\tif (ha->fw_attributes & BIT_4)\n\t\t\t\tqpair->difdix_supported = 1;\n\t\t}\n\n\t\tqpair->srb_mempool = mempool_create_slab_pool(SRB_MIN_REQ, srb_cachep);\n\t\tif (!qpair->srb_mempool) {\n\t\t\tql_log(ql_log_warn, vha, 0xd036,\n\t\t\t    \"Failed to create srb mempool for qpair %d\\n\",\n\t\t\t    qpair->id);\n\t\t\tgoto fail_mempool;\n\t\t}\n\n\t\t/* Mark as online */\n\t\tqpair->online = 1;\n\n\t\tif (!vha->flags.qpairs_available)\n\t\t\tvha->flags.qpairs_available = 1;\n\n\t\tql_dbg(ql_dbg_multiq, vha, 0xc00d,\n\t\t    \"Request/Response queue pair created, id %d\\n\",\n\t\t    qpair->id);\n\t\tql_dbg(ql_dbg_init, vha, 0x0187,\n\t\t    \"Request/Response queue pair created, id %d\\n\",\n\t\t    qpair->id);\n\t}\n\treturn qpair;\n\nfail_mempool:\nfail_req:\n\tqla25xx_delete_rsp_que(vha, qpair->rsp);\nfail_rsp:\n\tmutex_lock(&ha->mq_lock);\n\tqpair->msix->in_use = 0;\n\tlist_del(&qpair->qp_list_elem);\n\tif (list_empty(&vha->qp_list))\n\t\tvha->flags.qpairs_available = 0;\nfail_msix:\n\tha->queue_pair_map[qpair_id] = NULL;\n\tclear_bit(qpair_id, ha->qpair_qid_map);\n\tha->num_qpairs--;\n\tmutex_unlock(&ha->mq_lock);\nfail_qid_map:\n\tkfree(qpair);\n\treturn NULL;\n}\n\nint qla2xxx_delete_qpair(struct scsi_qla_host *vha, struct qla_qpair *qpair)\n{\n\tint ret = QLA_FUNCTION_FAILED;\n\tstruct qla_hw_data *ha = qpair->hw;\n\n\tqpair->delete_in_progress = 1;\n\n\tret = qla25xx_delete_req_que(vha, qpair->req);\n\tif (ret != QLA_SUCCESS)\n\t\tgoto fail;\n\n\tret = qla25xx_delete_rsp_que(vha, qpair->rsp);\n\tif (ret != QLA_SUCCESS)\n\t\tgoto fail;\n\n\tmutex_lock(&ha->mq_lock);\n\tha->queue_pair_map[qpair->id] = NULL;\n\tclear_bit(qpair->id, ha->qpair_qid_map);\n\tha->num_qpairs--;\n\tlist_del(&qpair->qp_list_elem);\n\tif (list_empty(&vha->qp_list)) {\n\t\tvha->flags.qpairs_available = 0;\n\t\tvha->flags.qpairs_req_created = 0;\n\t\tvha->flags.qpairs_rsp_created = 0;\n\t}\n\tmempool_destroy(qpair->srb_mempool);\n\tkfree(qpair);\n\tmutex_unlock(&ha->mq_lock);\n\n\treturn QLA_SUCCESS;\nfail:\n\treturn ret;\n}\n"}}, "reports": [{"events": [{"location": {"col": 2, "file": 0, "line": 5373}, "message": "ERROR: invalid reference to the index variable of the iterator on line 5333"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/qla2xxx/qla_init.c", "reportHash": "ca3bf49759e78fea973be47f0ea73cdb", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 36, "file": 0, "line": 6025}, "message": "ERROR: invalid reference to the index variable of the iterator on line 5961"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/qla2xxx/qla_init.c", "reportHash": "4887d44bdf30d3e61641fe4799646506", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
