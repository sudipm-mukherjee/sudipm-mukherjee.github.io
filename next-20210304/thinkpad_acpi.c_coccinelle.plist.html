<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  thinkpad_acpi.c - ThinkPad ACPI Extras\n *\n *  Copyright (C) 2004-2005 Borislav Deianov <borislav@users.sf.net>\n *  Copyright (C) 2006-2009 Henrique de Moraes Holschuh <hmh@hmh.eng.br>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define TPACPI_VERSION \"0.26\"\n#define TPACPI_SYSFS_VERSION 0x030000\n\n/*\n *  Changelog:\n *  2007-10-20\t\tchangelog trimmed down\n *\n *  2007-03-27  0.14\trenamed to thinkpad_acpi and moved to\n *  \t\t\tdrivers/misc.\n *\n *  2006-11-22\t0.13\tnew maintainer\n *  \t\t\tchangelog now lives in git commit history, and will\n *  \t\t\tnot be updated further in-file.\n *\n *  2005-03-17\t0.11\tsupport for 600e, 770x\n *\t\t\t    thanks to Jamie Lentin <lentinj@dial.pipex.com>\n *\n *  2005-01-16\t0.9\tuse MODULE_VERSION\n *\t\t\t    thanks to Henrik Brix Andersen <brix@gentoo.org>\n *\t\t\tfix parameter passing on module loading\n *\t\t\t    thanks to Rusty Russell <rusty@rustcorp.com.au>\n *\t\t\t    thanks to Jim Radford <radford@blackbean.org>\n *  2004-11-08\t0.8\tfix init error case, don't return from a macro\n *\t\t\t    thanks to Chris Wright <chrisw@osdl.org>\n */\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/sched.h>\n#include <linux/sched/signal.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/nvram.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sysfs.h>\n#include <linux/backlight.h>\n#include <linux/bitops.h>\n#include <linux/fb.h>\n#include <linux/platform_device.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/input.h>\n#include <linux/leds.h>\n#include <linux/rfkill.h>\n#include <linux/dmi.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/acpi.h>\n#include <linux/pci.h>\n#include <linux/power_supply.h>\n#include <linux/platform_profile.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/initval.h>\n#include <linux/uaccess.h>\n#include <acpi/battery.h>\n#include <acpi/video.h>\n\n/* ThinkPad CMOS commands */\n#define TP_CMOS_VOLUME_DOWN\t0\n#define TP_CMOS_VOLUME_UP\t1\n#define TP_CMOS_VOLUME_MUTE\t2\n#define TP_CMOS_BRIGHTNESS_UP\t4\n#define TP_CMOS_BRIGHTNESS_DOWN\t5\n#define TP_CMOS_THINKLIGHT_ON\t12\n#define TP_CMOS_THINKLIGHT_OFF\t13\n\n/* NVRAM Addresses */\nenum tp_nvram_addr {\n\tTP_NVRAM_ADDR_HK2\t\t= 0x57,\n\tTP_NVRAM_ADDR_THINKLIGHT\t= 0x58,\n\tTP_NVRAM_ADDR_VIDEO\t\t= 0x59,\n\tTP_NVRAM_ADDR_BRIGHTNESS\t= 0x5e,\n\tTP_NVRAM_ADDR_MIXER\t\t= 0x60,\n};\n\n/* NVRAM bit masks */\nenum {\n\tTP_NVRAM_MASK_HKT_THINKPAD\t= 0x08,\n\tTP_NVRAM_MASK_HKT_ZOOM\t\t= 0x20,\n\tTP_NVRAM_MASK_HKT_DISPLAY\t= 0x40,\n\tTP_NVRAM_MASK_HKT_HIBERNATE\t= 0x80,\n\tTP_NVRAM_MASK_THINKLIGHT\t= 0x10,\n\tTP_NVRAM_MASK_HKT_DISPEXPND\t= 0x30,\n\tTP_NVRAM_MASK_HKT_BRIGHTNESS\t= 0x20,\n\tTP_NVRAM_MASK_LEVEL_BRIGHTNESS\t= 0x0f,\n\tTP_NVRAM_POS_LEVEL_BRIGHTNESS\t= 0,\n\tTP_NVRAM_MASK_MUTE\t\t= 0x40,\n\tTP_NVRAM_MASK_HKT_VOLUME\t= 0x80,\n\tTP_NVRAM_MASK_LEVEL_VOLUME\t= 0x0f,\n\tTP_NVRAM_POS_LEVEL_VOLUME\t= 0,\n};\n\n/* Misc NVRAM-related */\nenum {\n\tTP_NVRAM_LEVEL_VOLUME_MAX = 14,\n};\n\n/* ACPI HIDs */\n#define TPACPI_ACPI_IBM_HKEY_HID\t\"IBM0068\"\n#define TPACPI_ACPI_LENOVO_HKEY_HID\t\"LEN0068\"\n#define TPACPI_ACPI_LENOVO_HKEY_V2_HID\t\"LEN0268\"\n#define TPACPI_ACPI_EC_HID\t\t\"PNP0C09\"\n\n/* Input IDs */\n#define TPACPI_HKEY_INPUT_PRODUCT\t0x5054 /* \"TP\" */\n#define TPACPI_HKEY_INPUT_VERSION\t0x4101\n\n/* ACPI \\WGSV commands */\nenum {\n\tTP_ACPI_WGSV_GET_STATE\t\t= 0x01, /* Get state information */\n\tTP_ACPI_WGSV_PWR_ON_ON_RESUME\t= 0x02, /* Resume WWAN powered on */\n\tTP_ACPI_WGSV_PWR_OFF_ON_RESUME\t= 0x03,\t/* Resume WWAN powered off */\n\tTP_ACPI_WGSV_SAVE_STATE\t\t= 0x04, /* Save state for S4/S5 */\n};\n\n/* TP_ACPI_WGSV_GET_STATE bits */\nenum {\n\tTP_ACPI_WGSV_STATE_WWANEXIST\t= 0x0001, /* WWAN hw available */\n\tTP_ACPI_WGSV_STATE_WWANPWR\t= 0x0002, /* WWAN radio enabled */\n\tTP_ACPI_WGSV_STATE_WWANPWRRES\t= 0x0004, /* WWAN state at resume */\n\tTP_ACPI_WGSV_STATE_WWANBIOSOFF\t= 0x0008, /* WWAN disabled in BIOS */\n\tTP_ACPI_WGSV_STATE_BLTHEXIST\t= 0x0001, /* BLTH hw available */\n\tTP_ACPI_WGSV_STATE_BLTHPWR\t= 0x0002, /* BLTH radio enabled */\n\tTP_ACPI_WGSV_STATE_BLTHPWRRES\t= 0x0004, /* BLTH state at resume */\n\tTP_ACPI_WGSV_STATE_BLTHBIOSOFF\t= 0x0008, /* BLTH disabled in BIOS */\n\tTP_ACPI_WGSV_STATE_UWBEXIST\t= 0x0010, /* UWB hw available */\n\tTP_ACPI_WGSV_STATE_UWBPWR\t= 0x0020, /* UWB radio enabled */\n};\n\n/* HKEY events */\nenum tpacpi_hkey_event_t {\n\t/* Hotkey-related */\n\tTP_HKEY_EV_HOTKEY_BASE\t\t= 0x1001, /* first hotkey (FN+F1) */\n\tTP_HKEY_EV_BRGHT_UP\t\t= 0x1010, /* Brightness up */\n\tTP_HKEY_EV_BRGHT_DOWN\t\t= 0x1011, /* Brightness down */\n\tTP_HKEY_EV_KBD_LIGHT\t\t= 0x1012, /* Thinklight/kbd backlight */\n\tTP_HKEY_EV_VOL_UP\t\t= 0x1015, /* Volume up or unmute */\n\tTP_HKEY_EV_VOL_DOWN\t\t= 0x1016, /* Volume down or unmute */\n\tTP_HKEY_EV_VOL_MUTE\t\t= 0x1017, /* Mixer output mute */\n\n\t/* Reasons for waking up from S3/S4 */\n\tTP_HKEY_EV_WKUP_S3_UNDOCK\t= 0x2304, /* undock requested, S3 */\n\tTP_HKEY_EV_WKUP_S4_UNDOCK\t= 0x2404, /* undock requested, S4 */\n\tTP_HKEY_EV_WKUP_S3_BAYEJ\t= 0x2305, /* bay ejection req, S3 */\n\tTP_HKEY_EV_WKUP_S4_BAYEJ\t= 0x2405, /* bay ejection req, S4 */\n\tTP_HKEY_EV_WKUP_S3_BATLOW\t= 0x2313, /* battery empty, S3 */\n\tTP_HKEY_EV_WKUP_S4_BATLOW\t= 0x2413, /* battery empty, S4 */\n\n\t/* Auto-sleep after eject request */\n\tTP_HKEY_EV_BAYEJ_ACK\t\t= 0x3003, /* bay ejection complete */\n\tTP_HKEY_EV_UNDOCK_ACK\t\t= 0x4003, /* undock complete */\n\n\t/* Misc bay events */\n\tTP_HKEY_EV_OPTDRV_EJ\t\t= 0x3006, /* opt. drive tray ejected */\n\tTP_HKEY_EV_HOTPLUG_DOCK\t\t= 0x4010, /* docked into hotplug dock\n\t\t\t\t\t\t     or port replicator */\n\tTP_HKEY_EV_HOTPLUG_UNDOCK\t= 0x4011, /* undocked from hotplug\n\t\t\t\t\t\t     dock or port replicator */\n\n\t/* User-interface events */\n\tTP_HKEY_EV_LID_CLOSE\t\t= 0x5001, /* laptop lid closed */\n\tTP_HKEY_EV_LID_OPEN\t\t= 0x5002, /* laptop lid opened */\n\tTP_HKEY_EV_TABLET_TABLET\t= 0x5009, /* tablet swivel up */\n\tTP_HKEY_EV_TABLET_NOTEBOOK\t= 0x500a, /* tablet swivel down */\n\tTP_HKEY_EV_TABLET_CHANGED\t= 0x60c0, /* X1 Yoga (2016):\n\t\t\t\t\t\t   * enter/leave tablet mode\n\t\t\t\t\t\t   */\n\tTP_HKEY_EV_PEN_INSERTED\t\t= 0x500b, /* tablet pen inserted */\n\tTP_HKEY_EV_PEN_REMOVED\t\t= 0x500c, /* tablet pen removed */\n\tTP_HKEY_EV_BRGHT_CHANGED\t= 0x5010, /* backlight control event */\n\n\t/* Key-related user-interface events */\n\tTP_HKEY_EV_KEY_NUMLOCK\t\t= 0x6000, /* NumLock key pressed */\n\tTP_HKEY_EV_KEY_FN\t\t= 0x6005, /* Fn key pressed? E420 */\n\tTP_HKEY_EV_KEY_FN_ESC           = 0x6060, /* Fn+Esc key pressed X240 */\n\n\t/* Thermal events */\n\tTP_HKEY_EV_ALARM_BAT_HOT\t= 0x6011, /* battery too hot */\n\tTP_HKEY_EV_ALARM_BAT_XHOT\t= 0x6012, /* battery critically hot */\n\tTP_HKEY_EV_ALARM_SENSOR_HOT\t= 0x6021, /* sensor too hot */\n\tTP_HKEY_EV_ALARM_SENSOR_XHOT\t= 0x6022, /* sensor critically hot */\n\tTP_HKEY_EV_THM_TABLE_CHANGED\t= 0x6030, /* windows; thermal table changed */\n\tTP_HKEY_EV_THM_CSM_COMPLETED    = 0x6032, /* windows; thermal control set\n\t\t\t\t\t\t   * command completed. Related to\n\t\t\t\t\t\t   * AML DYTC */\n\tTP_HKEY_EV_THM_TRANSFM_CHANGED  = 0x60F0, /* windows; thermal transformation\n\t\t\t\t\t\t   * changed. Related to AML GMTS */\n\n\t/* AC-related events */\n\tTP_HKEY_EV_AC_CHANGED\t\t= 0x6040, /* AC status changed */\n\n\t/* Further user-interface events */\n\tTP_HKEY_EV_PALM_DETECTED\t= 0x60b0, /* palm hoveres keyboard */\n\tTP_HKEY_EV_PALM_UNDETECTED\t= 0x60b1, /* palm removed */\n\n\t/* Misc */\n\tTP_HKEY_EV_RFKILL_CHANGED\t= 0x7000, /* rfkill switch changed */\n};\n\n/****************************************************************************\n * Main driver\n */\n\n#define TPACPI_NAME \"thinkpad\"\n#define TPACPI_DESC \"ThinkPad ACPI Extras\"\n#define TPACPI_FILE TPACPI_NAME \"_acpi\"\n#define TPACPI_URL \"http://ibm-acpi.sf.net/\"\n#define TPACPI_MAIL \"ibm-acpi-devel@lists.sourceforge.net\"\n\n#define TPACPI_PROC_DIR \"ibm\"\n#define TPACPI_ACPI_EVENT_PREFIX \"ibm\"\n#define TPACPI_DRVR_NAME TPACPI_FILE\n#define TPACPI_DRVR_SHORTNAME \"tpacpi\"\n#define TPACPI_HWMON_DRVR_NAME TPACPI_NAME \"_hwmon\"\n\n#define TPACPI_NVRAM_KTHREAD_NAME \"ktpacpi_nvramd\"\n#define TPACPI_WORKQUEUE_NAME \"ktpacpid\"\n\n#define TPACPI_MAX_ACPI_ARGS 3\n\n/* Debugging printk groups */\n#define TPACPI_DBG_ALL\t\t0xffff\n#define TPACPI_DBG_DISCLOSETASK\t0x8000\n#define TPACPI_DBG_INIT\t\t0x0001\n#define TPACPI_DBG_EXIT\t\t0x0002\n#define TPACPI_DBG_RFKILL\t0x0004\n#define TPACPI_DBG_HKEY\t\t0x0008\n#define TPACPI_DBG_FAN\t\t0x0010\n#define TPACPI_DBG_BRGHT\t0x0020\n#define TPACPI_DBG_MIXER\t0x0040\n\n#define onoff(status, bit) ((status) & (1 << (bit)) ? \"on\" : \"off\")\n#define enabled(status, bit) ((status) & (1 << (bit)) ? \"enabled\" : \"disabled\")\n#define strlencmp(a, b) (strncmp((a), (b), strlen(b)))\n\n\n/****************************************************************************\n * Driver-wide structs and misc. variables\n */\n\nstruct ibm_struct;\n\nstruct tp_acpi_drv_struct {\n\tconst struct acpi_device_id *hid;\n\tstruct acpi_driver *driver;\n\n\tvoid (*notify) (struct ibm_struct *, u32);\n\tacpi_handle *handle;\n\tu32 type;\n\tstruct acpi_device *device;\n};\n\nstruct ibm_struct {\n\tchar *name;\n\n\tint (*read) (struct seq_file *);\n\tint (*write) (char *);\n\tvoid (*exit) (void);\n\tvoid (*resume) (void);\n\tvoid (*suspend) (void);\n\tvoid (*shutdown) (void);\n\n\tstruct list_head all_drivers;\n\n\tstruct tp_acpi_drv_struct *acpi;\n\n\tstruct {\n\t\tu8 acpi_driver_registered:1;\n\t\tu8 acpi_notify_installed:1;\n\t\tu8 proc_created:1;\n\t\tu8 init_called:1;\n\t\tu8 experimental:1;\n\t} flags;\n};\n\nstruct ibm_init_struct {\n\tchar param[32];\n\n\tint (*init) (struct ibm_init_struct *);\n\tumode_t base_procfs_mode;\n\tstruct ibm_struct *data;\n};\n\nstatic struct {\n\tu32 bluetooth:1;\n\tu32 hotkey:1;\n\tu32 hotkey_mask:1;\n\tu32 hotkey_wlsw:1;\n\tenum {\n\t\tTP_HOTKEY_TABLET_NONE = 0,\n\t\tTP_HOTKEY_TABLET_USES_MHKG,\n\t\tTP_HOTKEY_TABLET_USES_GMMS,\n\t} hotkey_tablet;\n\tu32 kbdlight:1;\n\tu32 light:1;\n\tu32 light_status:1;\n\tu32 bright_acpimode:1;\n\tu32 bright_unkfw:1;\n\tu32 wan:1;\n\tu32 uwb:1;\n\tu32 fan_ctrl_status_undef:1;\n\tu32 second_fan:1;\n\tu32 second_fan_ctl:1;\n\tu32 beep_needs_two_args:1;\n\tu32 mixer_no_level_control:1;\n\tu32 battery_force_primary:1;\n\tu32 input_device_registered:1;\n\tu32 platform_drv_registered:1;\n\tu32 platform_drv_attrs_registered:1;\n\tu32 sensors_pdrv_registered:1;\n\tu32 sensors_pdrv_attrs_registered:1;\n\tu32 sensors_pdev_attrs_registered:1;\n\tu32 hotkey_poll_active:1;\n\tu32 has_adaptive_kbd:1;\n} tp_features;\n\nstatic struct {\n\tu16 hotkey_mask_ff:1;\n\tu16 volume_ctrl_forbidden:1;\n} tp_warned;\n\nstruct thinkpad_id_data {\n\tunsigned int vendor;\t/* ThinkPad vendor:\n\t\t\t\t * PCI_VENDOR_ID_IBM/PCI_VENDOR_ID_LENOVO */\n\n\tchar *bios_version_str;\t/* Something like 1ZET51WW (1.03z) */\n\tchar *ec_version_str;\t/* Something like 1ZHT51WW-1.04a */\n\n\tu32 bios_model;\t\t/* 1Y = 0x3159, 0 = unknown */\n\tu32 ec_model;\n\tu16 bios_release;\t/* 1ZETK1WW = 0x4b31, 0 = unknown */\n\tu16 ec_release;\n\n\tchar *model_str;\t/* ThinkPad T43 */\n\tchar *nummodel_str;\t/* 9384A9C for a 9384-A9C model */\n};\nstatic struct thinkpad_id_data thinkpad_id;\n\nstatic enum {\n\tTPACPI_LIFE_INIT = 0,\n\tTPACPI_LIFE_RUNNING,\n\tTPACPI_LIFE_EXITING,\n} tpacpi_lifecycle;\n\nstatic int experimental;\nstatic u32 dbg_level;\n\nstatic struct workqueue_struct *tpacpi_wq;\n\nenum led_status_t {\n\tTPACPI_LED_OFF = 0,\n\tTPACPI_LED_ON,\n\tTPACPI_LED_BLINK,\n};\n\n/* tpacpi LED class */\nstruct tpacpi_led_classdev {\n\tstruct led_classdev led_classdev;\n\tint led;\n};\n\n/* brightness level capabilities */\nstatic unsigned int bright_maxlvl;\t/* 0 = unknown */\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\nstatic int dbg_wlswemul;\nstatic bool tpacpi_wlsw_emulstate;\nstatic int dbg_bluetoothemul;\nstatic bool tpacpi_bluetooth_emulstate;\nstatic int dbg_wwanemul;\nstatic bool tpacpi_wwan_emulstate;\nstatic int dbg_uwbemul;\nstatic bool tpacpi_uwb_emulstate;\n#endif\n\n\n/*************************************************************************\n *  Debugging helpers\n */\n\n#define dbg_printk(a_dbg_level, format, arg...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (dbg_level & (a_dbg_level))\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: \" format),\t\t\\\n\t\t       __func__, ##arg);\t\t\t\t\\\n} while (0)\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUG\n#define vdbg_printk dbg_printk\nstatic const char *str_supported(int is_supported);\n#else\nstatic inline const char *str_supported(int is_supported) { return \"\"; }\n#define vdbg_printk(a_dbg_level, format, arg...)\t\\\n\tdo { if (0) no_printk(format, ##arg); } while (0)\n#endif\n\nstatic void tpacpi_log_usertask(const char * const what)\n{\n\tprintk(KERN_DEBUG pr_fmt(\"%s: access by process with PID %d\\n\"),\n\t       what, task_tgid_vnr(current));\n}\n\n#define tpacpi_disclose_usertask(what, format, arg...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely((dbg_level & TPACPI_DBG_DISCLOSETASK) &&\t\t\\\n\t\t     (tpacpi_lifecycle == TPACPI_LIFE_RUNNING))) {\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(\"%s: PID %d: \" format),\t\\\n\t\t       what, task_tgid_vnr(current), ## arg);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n/*\n * Quirk handling helpers\n *\n * ThinkPad IDs and versions seen in the field so far are\n * two or three characters from the set [0-9A-Z], i.e. base 36.\n *\n * We use values well outside that range as specials.\n */\n\n#define TPACPI_MATCH_ANY\t\t0xffffffffU\n#define TPACPI_MATCH_ANY_VERSION\t0xffffU\n#define TPACPI_MATCH_UNKNOWN\t\t0U\n\n/* TPID('1', 'Y') == 0x3159 */\n#define TPID(__c1, __c2)\t(((__c1) << 8) | (__c2))\n#define TPID3(__c1, __c2, __c3)\t(((__c1) << 16) | ((__c2) << 8) | (__c3))\n#define TPVER TPID\n\n#define TPACPI_Q_IBM(__id1, __id2, __quirk)\t\\\n\t{ .vendor = PCI_VENDOR_ID_IBM,\t\t\\\n\t  .bios = TPID(__id1, __id2),\t\t\\\n\t  .ec = TPACPI_MATCH_ANY,\t\t\\\n\t  .quirks = (__quirk) }\n\n#define TPACPI_Q_LNV(__id1, __id2, __quirk)\t\\\n\t{ .vendor = PCI_VENDOR_ID_LENOVO,\t\\\n\t  .bios = TPID(__id1, __id2),\t\t\\\n\t  .ec = TPACPI_MATCH_ANY,\t\t\\\n\t  .quirks = (__quirk) }\n\n#define TPACPI_Q_LNV3(__id1, __id2, __id3, __quirk) \\\n\t{ .vendor = PCI_VENDOR_ID_LENOVO,\t\\\n\t  .bios = TPID3(__id1, __id2, __id3),\t\\\n\t  .ec = TPACPI_MATCH_ANY,\t\t\\\n\t  .quirks = (__quirk) }\n\n#define TPACPI_QEC_IBM(__id1, __id2, __quirk)\t\\\n\t{ .vendor = PCI_VENDOR_ID_IBM,\t\t\\\n\t  .bios = TPACPI_MATCH_ANY,\t\t\\\n\t  .ec = TPID(__id1, __id2),\t\t\\\n\t  .quirks = (__quirk) }\n\n#define TPACPI_QEC_LNV(__id1, __id2, __quirk)\t\\\n\t{ .vendor = PCI_VENDOR_ID_LENOVO,\t\\\n\t  .bios = TPACPI_MATCH_ANY,\t\t\\\n\t  .ec = TPID(__id1, __id2),\t\t\\\n\t  .quirks = (__quirk) }\n\nstruct tpacpi_quirk {\n\tunsigned int vendor;\n\tu32 bios;\n\tu32 ec;\n\tunsigned long quirks;\n};\n\n/**\n * tpacpi_check_quirks() - search BIOS/EC version on a list\n * @qlist:\t\tarray of &struct tpacpi_quirk\n * @qlist_size:\t\tnumber of elements in @qlist\n *\n * Iterates over a quirks list until one is found that matches the\n * ThinkPad's vendor, BIOS and EC model.\n *\n * Returns 0 if nothing matches, otherwise returns the quirks field of\n * the matching &struct tpacpi_quirk entry.\n *\n * The match criteria is: vendor, ec and bios much match.\n */\nstatic unsigned long __init tpacpi_check_quirks(\n\t\t\tconst struct tpacpi_quirk *qlist,\n\t\t\tunsigned int qlist_size)\n{\n\twhile (qlist_size) {\n\t\tif ((qlist->vendor == thinkpad_id.vendor ||\n\t\t\t\tqlist->vendor == TPACPI_MATCH_ANY) &&\n\t\t    (qlist->bios == thinkpad_id.bios_model ||\n\t\t\t\tqlist->bios == TPACPI_MATCH_ANY) &&\n\t\t    (qlist->ec == thinkpad_id.ec_model ||\n\t\t\t\tqlist->ec == TPACPI_MATCH_ANY))\n\t\t\treturn qlist->quirks;\n\n\t\tqlist_size--;\n\t\tqlist++;\n\t}\n\treturn 0;\n}\n\nstatic inline bool __pure __init tpacpi_is_lenovo(void)\n{\n\treturn thinkpad_id.vendor == PCI_VENDOR_ID_LENOVO;\n}\n\nstatic inline bool __pure __init tpacpi_is_ibm(void)\n{\n\treturn thinkpad_id.vendor == PCI_VENDOR_ID_IBM;\n}\n\n/****************************************************************************\n ****************************************************************************\n *\n * ACPI Helpers and device model\n *\n ****************************************************************************\n ****************************************************************************/\n\n/*************************************************************************\n * ACPI basic handles\n */\n\nstatic acpi_handle root_handle;\nstatic acpi_handle ec_handle;\n\n#define TPACPI_HANDLE(object, parent, paths...)\t\t\t\\\n\tstatic acpi_handle  object##_handle;\t\t\t\\\n\tstatic const acpi_handle * const object##_parent __initconst =\t\\\n\t\t\t\t\t\t&parent##_handle; \\\n\tstatic char *object##_paths[] __initdata = { paths }\n\nTPACPI_HANDLE(ecrd, ec, \"ECRD\");\t/* 570 */\nTPACPI_HANDLE(ecwr, ec, \"ECWR\");\t/* 570 */\n\nTPACPI_HANDLE(cmos, root, \"\\\\UCMS\",\t/* R50, R50e, R50p, R51, */\n\t\t\t\t\t/* T4x, X31, X40 */\n\t   \"\\\\CMOS\",\t\t/* A3x, G4x, R32, T23, T30, X22-24, X30 */\n\t   \"\\\\CMS\",\t\t/* R40, R40e */\n\t   );\t\t\t/* all others */\n\nTPACPI_HANDLE(hkey, ec, \"\\\\_SB.HKEY\",\t/* 600e/x, 770e, 770x */\n\t   \"^HKEY\",\t\t/* R30, R31 */\n\t   \"HKEY\",\t\t/* all others */\n\t   );\t\t\t/* 570 */\n\n/*************************************************************************\n * ACPI helpers\n */\n\nstatic int acpi_evalf(acpi_handle handle,\n\t\t      int *res, char *method, char *fmt, ...)\n{\n\tchar *fmt0 = fmt;\n\tstruct acpi_object_list params;\n\tunion acpi_object in_objs[TPACPI_MAX_ACPI_ARGS];\n\tstruct acpi_buffer result, *resultp;\n\tunion acpi_object out_obj;\n\tacpi_status status;\n\tva_list ap;\n\tchar res_type;\n\tint success;\n\tint quiet;\n\n\tif (!*fmt) {\n\t\tpr_err(\"acpi_evalf() called with empty format\\n\");\n\t\treturn 0;\n\t}\n\n\tif (*fmt == 'q') {\n\t\tquiet = 1;\n\t\tfmt++;\n\t} else\n\t\tquiet = 0;\n\n\tres_type = *(fmt++);\n\n\tparams.count = 0;\n\tparams.pointer = &in_objs[0];\n\n\tva_start(ap, fmt);\n\twhile (*fmt) {\n\t\tchar c = *(fmt++);\n\t\tswitch (c) {\n\t\tcase 'd':\t/* int */\n\t\t\tin_objs[params.count].integer.value = va_arg(ap, int);\n\t\t\tin_objs[params.count++].type = ACPI_TYPE_INTEGER;\n\t\t\tbreak;\n\t\t\t/* add more types as needed */\n\t\tdefault:\n\t\t\tpr_err(\"acpi_evalf() called with invalid format character '%c'\\n\",\n\t\t\t       c);\n\t\t\tva_end(ap);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tva_end(ap);\n\n\tif (res_type != 'v') {\n\t\tresult.length = sizeof(out_obj);\n\t\tresult.pointer = &out_obj;\n\t\tresultp = &result;\n\t} else\n\t\tresultp = NULL;\n\n\tstatus = acpi_evaluate_object(handle, method, &params, resultp);\n\n\tswitch (res_type) {\n\tcase 'd':\t\t/* int */\n\t\tsuccess = (status == AE_OK &&\n\t\t\t   out_obj.type == ACPI_TYPE_INTEGER);\n\t\tif (success && res)\n\t\t\t*res = out_obj.integer.value;\n\t\tbreak;\n\tcase 'v':\t\t/* void */\n\t\tsuccess = status == AE_OK;\n\t\tbreak;\n\t\t/* add more types as needed */\n\tdefault:\n\t\tpr_err(\"acpi_evalf() called with invalid format character '%c'\\n\",\n\t\t       res_type);\n\t\treturn 0;\n\t}\n\n\tif (!success && !quiet)\n\t\tpr_err(\"acpi_evalf(%s, %s, ...) failed: %s\\n\",\n\t\t       method, fmt0, acpi_format_exception(status));\n\n\treturn success;\n}\n\nstatic int acpi_ec_read(int i, u8 *p)\n{\n\tint v;\n\n\tif (ecrd_handle) {\n\t\tif (!acpi_evalf(ecrd_handle, &v, NULL, \"dd\", i))\n\t\t\treturn 0;\n\t\t*p = v;\n\t} else {\n\t\tif (ec_read(i, p) < 0)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int acpi_ec_write(int i, u8 v)\n{\n\tif (ecwr_handle) {\n\t\tif (!acpi_evalf(ecwr_handle, NULL, NULL, \"vdd\", i, v))\n\t\t\treturn 0;\n\t} else {\n\t\tif (ec_write(i, v) < 0)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int issue_thinkpad_cmos_command(int cmos_cmd)\n{\n\tif (!cmos_handle)\n\t\treturn -ENXIO;\n\n\tif (!acpi_evalf(cmos_handle, NULL, NULL, \"vd\", cmos_cmd))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n/*************************************************************************\n * ACPI device model\n */\n\n#define TPACPI_ACPIHANDLE_INIT(object) \\\n\tdrv_acpi_handle_init(#object, &object##_handle, *object##_parent, \\\n\t\tobject##_paths, ARRAY_SIZE(object##_paths))\n\nstatic void __init drv_acpi_handle_init(const char *name,\n\t\t\t   acpi_handle *handle, const acpi_handle parent,\n\t\t\t   char **paths, const int num_paths)\n{\n\tint i;\n\tacpi_status status;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"trying to locate ACPI handle for %s\\n\",\n\t\tname);\n\n\tfor (i = 0; i < num_paths; i++) {\n\t\tstatus = acpi_get_handle(parent, paths[i], handle);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tdbg_printk(TPACPI_DBG_INIT,\n\t\t\t\t   \"Found ACPI handle %s for %s\\n\",\n\t\t\t\t   paths[i], name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"ACPI handle for %s not found\\n\",\n\t\t    name);\n\t*handle = NULL;\n}\n\nstatic acpi_status __init tpacpi_acpi_handle_locate_callback(acpi_handle handle,\n\t\t\tu32 level, void *context, void **return_value)\n{\n\tstruct acpi_device *dev;\n\tif (!strcmp(context, \"video\")) {\n\t\tif (acpi_bus_get_device(handle, &dev))\n\t\t\treturn AE_OK;\n\t\tif (strcmp(ACPI_VIDEO_HID, acpi_device_hid(dev)))\n\t\t\treturn AE_OK;\n\t}\n\n\t*(acpi_handle *)return_value = handle;\n\n\treturn AE_CTRL_TERMINATE;\n}\n\nstatic void __init tpacpi_acpi_handle_locate(const char *name,\n\t\tconst char *hid,\n\t\tacpi_handle *handle)\n{\n\tacpi_status status;\n\tacpi_handle device_found;\n\n\tBUG_ON(!name || !handle);\n\tvdbg_printk(TPACPI_DBG_INIT,\n\t\t\t\"trying to locate ACPI handle for %s, using HID %s\\n\",\n\t\t\tname, hid ? hid : \"NULL\");\n\n\tmemset(&device_found, 0, sizeof(device_found));\n\tstatus = acpi_get_devices(hid, tpacpi_acpi_handle_locate_callback,\n\t\t\t\t  (void *)name, &device_found);\n\n\t*handle = NULL;\n\n\tif (ACPI_SUCCESS(status)) {\n\t\t*handle = device_found;\n\t\tdbg_printk(TPACPI_DBG_INIT,\n\t\t\t   \"Found ACPI handle for %s\\n\", name);\n\t} else {\n\t\tvdbg_printk(TPACPI_DBG_INIT,\n\t\t\t    \"Could not locate an ACPI handle for %s: %s\\n\",\n\t\t\t    name, acpi_format_exception(status));\n\t}\n}\n\nstatic void dispatch_acpi_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstruct ibm_struct *ibm = data;\n\n\tif (tpacpi_lifecycle != TPACPI_LIFE_RUNNING)\n\t\treturn;\n\n\tif (!ibm || !ibm->acpi || !ibm->acpi->notify)\n\t\treturn;\n\n\tibm->acpi->notify(ibm, event);\n}\n\nstatic int __init setup_acpi_notify(struct ibm_struct *ibm)\n{\n\tacpi_status status;\n\tint rc;\n\n\tBUG_ON(!ibm->acpi);\n\n\tif (!*ibm->acpi->handle)\n\t\treturn 0;\n\n\tvdbg_printk(TPACPI_DBG_INIT,\n\t\t\"setting up ACPI notify for %s\\n\", ibm->name);\n\n\trc = acpi_bus_get_device(*ibm->acpi->handle, &ibm->acpi->device);\n\tif (rc < 0) {\n\t\tpr_err(\"acpi_bus_get_device(%s) failed: %d\\n\", ibm->name, rc);\n\t\treturn -ENODEV;\n\t}\n\n\tibm->acpi->device->driver_data = ibm;\n\tsprintf(acpi_device_class(ibm->acpi->device), \"%s/%s\",\n\t\tTPACPI_ACPI_EVENT_PREFIX,\n\t\tibm->name);\n\n\tstatus = acpi_install_notify_handler(*ibm->acpi->handle,\n\t\t\tibm->acpi->type, dispatch_acpi_notify, ibm);\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status == AE_ALREADY_EXISTS) {\n\t\t\tpr_notice(\"another device driver is already handling %s events\\n\",\n\t\t\t\t  ibm->name);\n\t\t} else {\n\t\t\tpr_err(\"acpi_install_notify_handler(%s) failed: %s\\n\",\n\t\t\t       ibm->name, acpi_format_exception(status));\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\tibm->flags.acpi_notify_installed = 1;\n\treturn 0;\n}\n\nstatic int __init tpacpi_device_add(struct acpi_device *device)\n{\n\treturn 0;\n}\n\nstatic int __init register_tpacpi_subdriver(struct ibm_struct *ibm)\n{\n\tint rc;\n\n\tdbg_printk(TPACPI_DBG_INIT,\n\t\t\"registering %s as an ACPI driver\\n\", ibm->name);\n\n\tBUG_ON(!ibm->acpi);\n\n\tibm->acpi->driver = kzalloc(sizeof(struct acpi_driver), GFP_KERNEL);\n\tif (!ibm->acpi->driver) {\n\t\tpr_err(\"failed to allocate memory for ibm->acpi->driver\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsprintf(ibm->acpi->driver->name, \"%s_%s\", TPACPI_NAME, ibm->name);\n\tibm->acpi->driver->ids = ibm->acpi->hid;\n\n\tibm->acpi->driver->ops.add = &tpacpi_device_add;\n\n\trc = acpi_bus_register_driver(ibm->acpi->driver);\n\tif (rc < 0) {\n\t\tpr_err(\"acpi_bus_register_driver(%s) failed: %d\\n\",\n\t\t       ibm->name, rc);\n\t\tkfree(ibm->acpi->driver);\n\t\tibm->acpi->driver = NULL;\n\t} else if (!rc)\n\t\tibm->flags.acpi_driver_registered = 1;\n\n\treturn rc;\n}\n\n\n/****************************************************************************\n ****************************************************************************\n *\n * Procfs Helpers\n *\n ****************************************************************************\n ****************************************************************************/\n\nstatic int dispatch_proc_show(struct seq_file *m, void *v)\n{\n\tstruct ibm_struct *ibm = m->private;\n\n\tif (!ibm || !ibm->read)\n\t\treturn -EINVAL;\n\treturn ibm->read(m);\n}\n\nstatic int dispatch_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, dispatch_proc_show, PDE_DATA(inode));\n}\n\nstatic ssize_t dispatch_proc_write(struct file *file,\n\t\t\tconst char __user *userbuf,\n\t\t\tsize_t count, loff_t *pos)\n{\n\tstruct ibm_struct *ibm = PDE_DATA(file_inode(file));\n\tchar *kernbuf;\n\tint ret;\n\n\tif (!ibm || !ibm->write)\n\t\treturn -EINVAL;\n\tif (count > PAGE_SIZE - 1)\n\t\treturn -EINVAL;\n\n\tkernbuf = kmalloc(count + 1, GFP_KERNEL);\n\tif (!kernbuf)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(kernbuf, userbuf, count)) {\n\t\tkfree(kernbuf);\n\t\treturn -EFAULT;\n\t}\n\n\tkernbuf[count] = 0;\n\tret = ibm->write(kernbuf);\n\tif (ret == 0)\n\t\tret = count;\n\n\tkfree(kernbuf);\n\n\treturn ret;\n}\n\nstatic const struct proc_ops dispatch_proc_ops = {\n\t.proc_open\t= dispatch_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= dispatch_proc_write,\n};\n\n/****************************************************************************\n ****************************************************************************\n *\n * Device model: input, hwmon and platform\n *\n ****************************************************************************\n ****************************************************************************/\n\nstatic struct platform_device *tpacpi_pdev;\nstatic struct platform_device *tpacpi_sensors_pdev;\nstatic struct device *tpacpi_hwmon;\nstatic struct input_dev *tpacpi_inputdev;\nstatic struct mutex tpacpi_inputdev_send_mutex;\nstatic LIST_HEAD(tpacpi_all_drivers);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tpacpi_suspend_handler(struct device *dev)\n{\n\tstruct ibm_struct *ibm, *itmp;\n\n\tlist_for_each_entry_safe(ibm, itmp,\n\t\t\t\t &tpacpi_all_drivers,\n\t\t\t\t all_drivers) {\n\t\tif (ibm->suspend)\n\t\t\t(ibm->suspend)();\n\t}\n\n\treturn 0;\n}\n\nstatic int tpacpi_resume_handler(struct device *dev)\n{\n\tstruct ibm_struct *ibm, *itmp;\n\n\tlist_for_each_entry_safe(ibm, itmp,\n\t\t\t\t &tpacpi_all_drivers,\n\t\t\t\t all_drivers) {\n\t\tif (ibm->resume)\n\t\t\t(ibm->resume)();\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(tpacpi_pm,\n\t\t\t tpacpi_suspend_handler, tpacpi_resume_handler);\n\nstatic void tpacpi_shutdown_handler(struct platform_device *pdev)\n{\n\tstruct ibm_struct *ibm, *itmp;\n\n\tlist_for_each_entry_safe(ibm, itmp,\n\t\t\t\t &tpacpi_all_drivers,\n\t\t\t\t all_drivers) {\n\t\tif (ibm->shutdown)\n\t\t\t(ibm->shutdown)();\n\t}\n}\n\nstatic struct platform_driver tpacpi_pdriver = {\n\t.driver = {\n\t\t.name = TPACPI_DRVR_NAME,\n\t\t.pm = &tpacpi_pm,\n\t},\n\t.shutdown = tpacpi_shutdown_handler,\n};\n\nstatic struct platform_driver tpacpi_hwmon_pdriver = {\n\t.driver = {\n\t\t.name = TPACPI_HWMON_DRVR_NAME,\n\t},\n};\n\n/*************************************************************************\n * sysfs support helpers\n */\n\nstruct attribute_set {\n\tunsigned int members, max_members;\n\tstruct attribute_group group;\n};\n\nstruct attribute_set_obj {\n\tstruct attribute_set s;\n\tstruct attribute *a;\n} __attribute__((packed));\n\nstatic struct attribute_set *create_attr_set(unsigned int max_members,\n\t\t\t\t\t\tconst char *name)\n{\n\tstruct attribute_set_obj *sobj;\n\n\tif (max_members == 0)\n\t\treturn NULL;\n\n\t/* Allocates space for implicit NULL at the end too */\n\tsobj = kzalloc(sizeof(struct attribute_set_obj) +\n\t\t    max_members * sizeof(struct attribute *),\n\t\t    GFP_KERNEL);\n\tif (!sobj)\n\t\treturn NULL;\n\tsobj->s.max_members = max_members;\n\tsobj->s.group.attrs = &sobj->a;\n\tsobj->s.group.name = name;\n\n\treturn &sobj->s;\n}\n\n#define destroy_attr_set(_set) \\\n\tkfree(_set)\n\n/* not multi-threaded safe, use it in a single thread per set */\nstatic int add_to_attr_set(struct attribute_set *s, struct attribute *attr)\n{\n\tif (!s || !attr)\n\t\treturn -EINVAL;\n\n\tif (s->members >= s->max_members)\n\t\treturn -ENOMEM;\n\n\ts->group.attrs[s->members] = attr;\n\ts->members++;\n\n\treturn 0;\n}\n\nstatic int add_many_to_attr_set(struct attribute_set *s,\n\t\t\tstruct attribute **attr,\n\t\t\tunsigned int count)\n{\n\tint i, res;\n\n\tfor (i = 0; i < count; i++) {\n\t\tres = add_to_attr_set(s, attr[i]);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic void delete_attr_set(struct attribute_set *s, struct kobject *kobj)\n{\n\tsysfs_remove_group(kobj, &s->group);\n\tdestroy_attr_set(s);\n}\n\n#define register_attr_set_with_sysfs(_attr_set, _kobj) \\\n\tsysfs_create_group(_kobj, &_attr_set->group)\n\nstatic int parse_strtoul(const char *buf,\n\t\tunsigned long max, unsigned long *value)\n{\n\tchar *endp;\n\n\t*value = simple_strtoul(skip_spaces(buf), &endp, 0);\n\tendp = skip_spaces(endp);\n\tif (*endp || *value > max)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void tpacpi_disable_brightness_delay(void)\n{\n\tif (acpi_evalf(hkey_handle, NULL, \"PWMS\", \"qvd\", 0))\n\t\tpr_notice(\"ACPI backlight control delay disabled\\n\");\n}\n\nstatic void printk_deprecated_attribute(const char * const what,\n\t\t\t\t\tconst char * const details)\n{\n\ttpacpi_log_usertask(\"deprecated sysfs attribute\");\n\tpr_warn(\"WARNING: sysfs attribute %s is deprecated and will be removed. %s\\n\",\n\t\twhat, details);\n}\n\n/*************************************************************************\n * rfkill and radio control support helpers\n */\n\n/*\n * ThinkPad-ACPI firmware handling model:\n *\n * WLSW (master wireless switch) is event-driven, and is common to all\n * firmware-controlled radios.  It cannot be controlled, just monitored,\n * as expected.  It overrides all radio state in firmware\n *\n * The kernel, a masked-off hotkey, and WLSW can change the radio state\n * (TODO: verify how WLSW interacts with the returned radio state).\n *\n * The only time there are shadow radio state changes, is when\n * masked-off hotkeys are used.\n */\n\n/*\n * Internal driver API for radio state:\n *\n * int: < 0 = error, otherwise enum tpacpi_rfkill_state\n * bool: true means radio blocked (off)\n */\nenum tpacpi_rfkill_state {\n\tTPACPI_RFK_RADIO_OFF = 0,\n\tTPACPI_RFK_RADIO_ON\n};\n\n/* rfkill switches */\nenum tpacpi_rfk_id {\n\tTPACPI_RFK_BLUETOOTH_SW_ID = 0,\n\tTPACPI_RFK_WWAN_SW_ID,\n\tTPACPI_RFK_UWB_SW_ID,\n\tTPACPI_RFK_SW_MAX\n};\n\nstatic const char *tpacpi_rfkill_names[] = {\n\t[TPACPI_RFK_BLUETOOTH_SW_ID] = \"bluetooth\",\n\t[TPACPI_RFK_WWAN_SW_ID] = \"wwan\",\n\t[TPACPI_RFK_UWB_SW_ID] = \"uwb\",\n\t[TPACPI_RFK_SW_MAX] = NULL\n};\n\n/* ThinkPad-ACPI rfkill subdriver */\nstruct tpacpi_rfk {\n\tstruct rfkill *rfkill;\n\tenum tpacpi_rfk_id id;\n\tconst struct tpacpi_rfk_ops *ops;\n};\n\nstruct tpacpi_rfk_ops {\n\t/* firmware interface */\n\tint (*get_status)(void);\n\tint (*set_status)(const enum tpacpi_rfkill_state);\n};\n\nstatic struct tpacpi_rfk *tpacpi_rfkill_switches[TPACPI_RFK_SW_MAX];\n\n/* Query FW and update rfkill sw state for a given rfkill switch */\nstatic int tpacpi_rfk_update_swstate(const struct tpacpi_rfk *tp_rfk)\n{\n\tint status;\n\n\tif (!tp_rfk)\n\t\treturn -ENODEV;\n\n\tstatus = (tp_rfk->ops->get_status)();\n\tif (status < 0)\n\t\treturn status;\n\n\trfkill_set_sw_state(tp_rfk->rfkill,\n\t\t\t    (status == TPACPI_RFK_RADIO_OFF));\n\n\treturn status;\n}\n\n/* Query FW and update rfkill sw state for all rfkill switches */\nstatic void tpacpi_rfk_update_swstate_all(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < TPACPI_RFK_SW_MAX; i++)\n\t\ttpacpi_rfk_update_swstate(tpacpi_rfkill_switches[i]);\n}\n\n/*\n * Sync the HW-blocking state of all rfkill switches,\n * do notice it causes the rfkill core to schedule uevents\n */\nstatic void tpacpi_rfk_update_hwblock_state(bool blocked)\n{\n\tunsigned int i;\n\tstruct tpacpi_rfk *tp_rfk;\n\n\tfor (i = 0; i < TPACPI_RFK_SW_MAX; i++) {\n\t\ttp_rfk = tpacpi_rfkill_switches[i];\n\t\tif (tp_rfk) {\n\t\t\tif (rfkill_set_hw_state(tp_rfk->rfkill,\n\t\t\t\t\t\tblocked)) {\n\t\t\t\t/* ignore -- we track sw block */\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Call to get the WLSW state from the firmware */\nstatic int hotkey_get_wlsw(void);\n\n/* Call to query WLSW state and update all rfkill switches */\nstatic bool tpacpi_rfk_check_hwblock_state(void)\n{\n\tint res = hotkey_get_wlsw();\n\tint hw_blocked;\n\n\t/* When unknown or unsupported, we have to assume it is unblocked */\n\tif (res < 0)\n\t\treturn false;\n\n\thw_blocked = (res == TPACPI_RFK_RADIO_OFF);\n\ttpacpi_rfk_update_hwblock_state(hw_blocked);\n\n\treturn hw_blocked;\n}\n\nstatic int tpacpi_rfk_hook_set_block(void *data, bool blocked)\n{\n\tstruct tpacpi_rfk *tp_rfk = data;\n\tint res;\n\n\tdbg_printk(TPACPI_DBG_RFKILL,\n\t\t   \"request to change radio state to %s\\n\",\n\t\t   blocked ? \"blocked\" : \"unblocked\");\n\n\t/* try to set radio state */\n\tres = (tp_rfk->ops->set_status)(blocked ?\n\t\t\t\tTPACPI_RFK_RADIO_OFF : TPACPI_RFK_RADIO_ON);\n\n\t/* and update the rfkill core with whatever the FW really did */\n\ttpacpi_rfk_update_swstate(tp_rfk);\n\n\treturn (res < 0) ? res : 0;\n}\n\nstatic const struct rfkill_ops tpacpi_rfk_rfkill_ops = {\n\t.set_block = tpacpi_rfk_hook_set_block,\n};\n\nstatic int __init tpacpi_new_rfkill(const enum tpacpi_rfk_id id,\n\t\t\tconst struct tpacpi_rfk_ops *tp_rfkops,\n\t\t\tconst enum rfkill_type rfktype,\n\t\t\tconst char *name,\n\t\t\tconst bool set_default)\n{\n\tstruct tpacpi_rfk *atp_rfk;\n\tint res;\n\tbool sw_state = false;\n\tbool hw_state;\n\tint sw_status;\n\n\tBUG_ON(id >= TPACPI_RFK_SW_MAX || tpacpi_rfkill_switches[id]);\n\n\tatp_rfk = kzalloc(sizeof(struct tpacpi_rfk), GFP_KERNEL);\n\tif (atp_rfk)\n\t\tatp_rfk->rfkill = rfkill_alloc(name,\n\t\t\t\t\t\t&tpacpi_pdev->dev,\n\t\t\t\t\t\trfktype,\n\t\t\t\t\t\t&tpacpi_rfk_rfkill_ops,\n\t\t\t\t\t\tatp_rfk);\n\tif (!atp_rfk || !atp_rfk->rfkill) {\n\t\tpr_err(\"failed to allocate memory for rfkill class\\n\");\n\t\tkfree(atp_rfk);\n\t\treturn -ENOMEM;\n\t}\n\n\tatp_rfk->id = id;\n\tatp_rfk->ops = tp_rfkops;\n\n\tsw_status = (tp_rfkops->get_status)();\n\tif (sw_status < 0) {\n\t\tpr_err(\"failed to read initial state for %s, error %d\\n\",\n\t\t       name, sw_status);\n\t} else {\n\t\tsw_state = (sw_status == TPACPI_RFK_RADIO_OFF);\n\t\tif (set_default) {\n\t\t\t/* try to keep the initial state, since we ask the\n\t\t\t * firmware to preserve it across S5 in NVRAM */\n\t\t\trfkill_init_sw_state(atp_rfk->rfkill, sw_state);\n\t\t}\n\t}\n\thw_state = tpacpi_rfk_check_hwblock_state();\n\trfkill_set_hw_state(atp_rfk->rfkill, hw_state);\n\n\tres = rfkill_register(atp_rfk->rfkill);\n\tif (res < 0) {\n\t\tpr_err(\"failed to register %s rfkill switch: %d\\n\", name, res);\n\t\trfkill_destroy(atp_rfk->rfkill);\n\t\tkfree(atp_rfk);\n\t\treturn res;\n\t}\n\n\ttpacpi_rfkill_switches[id] = atp_rfk;\n\n\tpr_info(\"rfkill switch %s: radio is %sblocked\\n\",\n\t\tname, (sw_state || hw_state) ? \"\" : \"un\");\n\treturn 0;\n}\n\nstatic void tpacpi_destroy_rfkill(const enum tpacpi_rfk_id id)\n{\n\tstruct tpacpi_rfk *tp_rfk;\n\n\tBUG_ON(id >= TPACPI_RFK_SW_MAX);\n\n\ttp_rfk = tpacpi_rfkill_switches[id];\n\tif (tp_rfk) {\n\t\trfkill_unregister(tp_rfk->rfkill);\n\t\trfkill_destroy(tp_rfk->rfkill);\n\t\ttpacpi_rfkill_switches[id] = NULL;\n\t\tkfree(tp_rfk);\n\t}\n}\n\nstatic void printk_deprecated_rfkill_attribute(const char * const what)\n{\n\tprintk_deprecated_attribute(what,\n\t\t\t\"Please switch to generic rfkill before year 2010\");\n}\n\n/* sysfs <radio> enable ------------------------------------------------ */\nstatic ssize_t tpacpi_rfk_sysfs_enable_show(const enum tpacpi_rfk_id id,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tint status;\n\n\tprintk_deprecated_rfkill_attribute(attr->attr.name);\n\n\t/* This is in the ABI... */\n\tif (tpacpi_rfk_check_hwblock_state()) {\n\t\tstatus = TPACPI_RFK_RADIO_OFF;\n\t} else {\n\t\tstatus = tpacpi_rfk_update_swstate(tpacpi_rfkill_switches[id]);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t(status == TPACPI_RFK_RADIO_ON) ? 1 : 0);\n}\n\nstatic ssize_t tpacpi_rfk_sysfs_enable_store(const enum tpacpi_rfk_id id,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned long t;\n\tint res;\n\n\tprintk_deprecated_rfkill_attribute(attr->attr.name);\n\n\tif (parse_strtoul(buf, 1, &t))\n\t\treturn -EINVAL;\n\n\ttpacpi_disclose_usertask(attr->attr.name, \"set to %ld\\n\", t);\n\n\t/* This is in the ABI... */\n\tif (tpacpi_rfk_check_hwblock_state() && !!t)\n\t\treturn -EPERM;\n\n\tres = tpacpi_rfkill_switches[id]->ops->set_status((!!t) ?\n\t\t\t\tTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF);\n\ttpacpi_rfk_update_swstate(tpacpi_rfkill_switches[id]);\n\n\treturn (res < 0) ? res : count;\n}\n\n/* procfs -------------------------------------------------------------- */\nstatic int tpacpi_rfk_procfs_read(const enum tpacpi_rfk_id id, struct seq_file *m)\n{\n\tif (id >= TPACPI_RFK_SW_MAX)\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\telse {\n\t\tint status;\n\n\t\t/* This is in the ABI... */\n\t\tif (tpacpi_rfk_check_hwblock_state()) {\n\t\t\tstatus = TPACPI_RFK_RADIO_OFF;\n\t\t} else {\n\t\t\tstatus = tpacpi_rfk_update_swstate(\n\t\t\t\t\t\ttpacpi_rfkill_switches[id]);\n\t\t\tif (status < 0)\n\t\t\t\treturn status;\n\t\t}\n\n\t\tseq_printf(m, \"status:\\t\\t%s\\n\",\n\t\t\t\t(status == TPACPI_RFK_RADIO_ON) ?\n\t\t\t\t\t\"enabled\" : \"disabled\");\n\t\tseq_printf(m, \"commands:\\tenable, disable\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int tpacpi_rfk_procfs_write(const enum tpacpi_rfk_id id, char *buf)\n{\n\tchar *cmd;\n\tint status = -1;\n\tint res = 0;\n\n\tif (id >= TPACPI_RFK_SW_MAX)\n\t\treturn -ENODEV;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (strlencmp(cmd, \"enable\") == 0)\n\t\t\tstatus = TPACPI_RFK_RADIO_ON;\n\t\telse if (strlencmp(cmd, \"disable\") == 0)\n\t\t\tstatus = TPACPI_RFK_RADIO_OFF;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (status != -1) {\n\t\ttpacpi_disclose_usertask(\"procfs\", \"attempt to %s %s\\n\",\n\t\t\t\t(status == TPACPI_RFK_RADIO_ON) ?\n\t\t\t\t\t\t\"enable\" : \"disable\",\n\t\t\t\ttpacpi_rfkill_names[id]);\n\t\tres = (tpacpi_rfkill_switches[id]->ops->set_status)(status);\n\t\ttpacpi_rfk_update_swstate(tpacpi_rfkill_switches[id]);\n\t}\n\n\treturn res;\n}\n\n/*************************************************************************\n * thinkpad-acpi driver attributes\n */\n\n/* interface_version --------------------------------------------------- */\nstatic ssize_t interface_version_show(struct device_driver *drv, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"0x%08x\\n\", TPACPI_SYSFS_VERSION);\n}\nstatic DRIVER_ATTR_RO(interface_version);\n\n/* debug_level --------------------------------------------------------- */\nstatic ssize_t debug_level_show(struct device_driver *drv, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"0x%04x\\n\", dbg_level);\n}\n\nstatic ssize_t debug_level_store(struct device_driver *drv, const char *buf,\n\t\t\t\t size_t count)\n{\n\tunsigned long t;\n\n\tif (parse_strtoul(buf, 0xffff, &t))\n\t\treturn -EINVAL;\n\n\tdbg_level = t;\n\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(debug_level);\n\n/* version ------------------------------------------------------------- */\nstatic ssize_t version_show(struct device_driver *drv, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%s v%s\\n\",\n\t\t\tTPACPI_DESC, TPACPI_VERSION);\n}\nstatic DRIVER_ATTR_RO(version);\n\n/* --------------------------------------------------------------------- */\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\n/* wlsw_emulstate ------------------------------------------------------ */\nstatic ssize_t wlsw_emulstate_show(struct device_driver *drv, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", !!tpacpi_wlsw_emulstate);\n}\n\nstatic ssize_t wlsw_emulstate_store(struct device_driver *drv, const char *buf,\n\t\t\t\t    size_t count)\n{\n\tunsigned long t;\n\n\tif (parse_strtoul(buf, 1, &t))\n\t\treturn -EINVAL;\n\n\tif (tpacpi_wlsw_emulstate != !!t) {\n\t\ttpacpi_wlsw_emulstate = !!t;\n\t\ttpacpi_rfk_update_hwblock_state(!t);\t/* negative logic */\n\t}\n\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(wlsw_emulstate);\n\n/* bluetooth_emulstate ------------------------------------------------- */\nstatic ssize_t bluetooth_emulstate_show(struct device_driver *drv, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", !!tpacpi_bluetooth_emulstate);\n}\n\nstatic ssize_t bluetooth_emulstate_store(struct device_driver *drv,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tunsigned long t;\n\n\tif (parse_strtoul(buf, 1, &t))\n\t\treturn -EINVAL;\n\n\ttpacpi_bluetooth_emulstate = !!t;\n\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(bluetooth_emulstate);\n\n/* wwan_emulstate ------------------------------------------------- */\nstatic ssize_t wwan_emulstate_show(struct device_driver *drv, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", !!tpacpi_wwan_emulstate);\n}\n\nstatic ssize_t wwan_emulstate_store(struct device_driver *drv, const char *buf,\n\t\t\t\t    size_t count)\n{\n\tunsigned long t;\n\n\tif (parse_strtoul(buf, 1, &t))\n\t\treturn -EINVAL;\n\n\ttpacpi_wwan_emulstate = !!t;\n\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(wwan_emulstate);\n\n/* uwb_emulstate ------------------------------------------------- */\nstatic ssize_t uwb_emulstate_show(struct device_driver *drv, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", !!tpacpi_uwb_emulstate);\n}\n\nstatic ssize_t uwb_emulstate_store(struct device_driver *drv, const char *buf,\n\t\t\t\t   size_t count)\n{\n\tunsigned long t;\n\n\tif (parse_strtoul(buf, 1, &t))\n\t\treturn -EINVAL;\n\n\ttpacpi_uwb_emulstate = !!t;\n\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(uwb_emulstate);\n#endif\n\n/* --------------------------------------------------------------------- */\n\nstatic struct driver_attribute *tpacpi_driver_attributes[] = {\n\t&driver_attr_debug_level, &driver_attr_version,\n\t&driver_attr_interface_version,\n};\n\nstatic int __init tpacpi_create_driver_attributes(struct device_driver *drv)\n{\n\tint i, res;\n\n\ti = 0;\n\tres = 0;\n\twhile (!res && i < ARRAY_SIZE(tpacpi_driver_attributes)) {\n\t\tres = driver_create_file(drv, tpacpi_driver_attributes[i]);\n\t\ti++;\n\t}\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (!res && dbg_wlswemul)\n\t\tres = driver_create_file(drv, &driver_attr_wlsw_emulstate);\n\tif (!res && dbg_bluetoothemul)\n\t\tres = driver_create_file(drv, &driver_attr_bluetooth_emulstate);\n\tif (!res && dbg_wwanemul)\n\t\tres = driver_create_file(drv, &driver_attr_wwan_emulstate);\n\tif (!res && dbg_uwbemul)\n\t\tres = driver_create_file(drv, &driver_attr_uwb_emulstate);\n#endif\n\n\treturn res;\n}\n\nstatic void tpacpi_remove_driver_attributes(struct device_driver *drv)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tpacpi_driver_attributes); i++)\n\t\tdriver_remove_file(drv, tpacpi_driver_attributes[i]);\n\n#ifdef THINKPAD_ACPI_DEBUGFACILITIES\n\tdriver_remove_file(drv, &driver_attr_wlsw_emulstate);\n\tdriver_remove_file(drv, &driver_attr_bluetooth_emulstate);\n\tdriver_remove_file(drv, &driver_attr_wwan_emulstate);\n\tdriver_remove_file(drv, &driver_attr_uwb_emulstate);\n#endif\n}\n\n/*************************************************************************\n * Firmware Data\n */\n\n/*\n * Table of recommended minimum BIOS versions\n *\n * Reasons for listing:\n *    1. Stable BIOS, listed because the unknown amount of\n *       bugs and bad ACPI behaviour on older versions\n *\n *    2. BIOS or EC fw with known bugs that trigger on Linux\n *\n *    3. BIOS with known reduced functionality in older versions\n *\n *  We recommend the latest BIOS and EC version.\n *  We only support the latest BIOS and EC fw version as a rule.\n *\n *  Sources: IBM ThinkPad Public Web Documents (update changelogs),\n *  Information from users in ThinkWiki\n *\n *  WARNING: we use this table also to detect that the machine is\n *  a ThinkPad in some cases, so don't remove entries lightly.\n */\n\n#define TPV_Q(__v, __id1, __id2, __bv1, __bv2)\t\t\\\n\t{ .vendor\t= (__v),\t\t\t\\\n\t  .bios\t\t= TPID(__id1, __id2),\t\t\\\n\t  .ec\t\t= TPACPI_MATCH_ANY,\t\t\\\n\t  .quirks\t= TPACPI_MATCH_ANY_VERSION << 16 \\\n\t\t\t  | TPVER(__bv1, __bv2) }\n\n#define TPV_Q_X(__v, __bid1, __bid2, __bv1, __bv2,\t\\\n\t\t__eid, __ev1, __ev2)\t\t\t\\\n\t{ .vendor\t= (__v),\t\t\t\\\n\t  .bios\t\t= TPID(__bid1, __bid2),\t\t\\\n\t  .ec\t\t= __eid,\t\t\t\\\n\t  .quirks\t= TPVER(__ev1, __ev2) << 16\t\\\n\t\t\t  | TPVER(__bv1, __bv2) }\n\n#define TPV_QI0(__id1, __id2, __bv1, __bv2) \\\n\tTPV_Q(PCI_VENDOR_ID_IBM, __id1, __id2, __bv1, __bv2)\n\n/* Outdated IBM BIOSes often lack the EC id string */\n#define TPV_QI1(__id1, __id2, __bv1, __bv2, __ev1, __ev2) \\\n\tTPV_Q_X(PCI_VENDOR_ID_IBM, __id1, __id2, \t\\\n\t\t__bv1, __bv2, TPID(__id1, __id2),\t\\\n\t\t__ev1, __ev2),\t\t\t\t\\\n\tTPV_Q_X(PCI_VENDOR_ID_IBM, __id1, __id2, \t\\\n\t\t__bv1, __bv2, TPACPI_MATCH_UNKNOWN,\t\\\n\t\t__ev1, __ev2)\n\n/* Outdated IBM BIOSes often lack the EC id string */\n#define TPV_QI2(__bid1, __bid2, __bv1, __bv2,\t\t\\\n\t\t__eid1, __eid2, __ev1, __ev2) \t\t\\\n\tTPV_Q_X(PCI_VENDOR_ID_IBM, __bid1, __bid2, \t\\\n\t\t__bv1, __bv2, TPID(__eid1, __eid2),\t\\\n\t\t__ev1, __ev2),\t\t\t\t\\\n\tTPV_Q_X(PCI_VENDOR_ID_IBM, __bid1, __bid2, \t\\\n\t\t__bv1, __bv2, TPACPI_MATCH_UNKNOWN,\t\\\n\t\t__ev1, __ev2)\n\n#define TPV_QL0(__id1, __id2, __bv1, __bv2) \\\n\tTPV_Q(PCI_VENDOR_ID_LENOVO, __id1, __id2, __bv1, __bv2)\n\n#define TPV_QL1(__id1, __id2, __bv1, __bv2, __ev1, __ev2) \\\n\tTPV_Q_X(PCI_VENDOR_ID_LENOVO, __id1, __id2, \t\\\n\t\t__bv1, __bv2, TPID(__id1, __id2),\t\\\n\t\t__ev1, __ev2)\n\n#define TPV_QL2(__bid1, __bid2, __bv1, __bv2,\t\t\\\n\t\t__eid1, __eid2, __ev1, __ev2) \t\t\\\n\tTPV_Q_X(PCI_VENDOR_ID_LENOVO, __bid1, __bid2, \t\\\n\t\t__bv1, __bv2, TPID(__eid1, __eid2),\t\\\n\t\t__ev1, __ev2)\n\nstatic const struct tpacpi_quirk tpacpi_bios_version_qtable[] __initconst = {\n\t/*  Numeric models ------------------ */\n\t/*      FW MODEL   BIOS VERS\t      */\n\tTPV_QI0('I', 'M',  '6', '5'),\t\t /* 570 */\n\tTPV_QI0('I', 'U',  '2', '6'),\t\t /* 570E */\n\tTPV_QI0('I', 'B',  '5', '4'),\t\t /* 600 */\n\tTPV_QI0('I', 'H',  '4', '7'),\t\t /* 600E */\n\tTPV_QI0('I', 'N',  '3', '6'),\t\t /* 600E */\n\tTPV_QI0('I', 'T',  '5', '5'),\t\t /* 600X */\n\tTPV_QI0('I', 'D',  '4', '8'),\t\t /* 770, 770E, 770ED */\n\tTPV_QI0('I', 'I',  '4', '2'),\t\t /* 770X */\n\tTPV_QI0('I', 'O',  '2', '3'),\t\t /* 770Z */\n\n\t/* A-series ------------------------- */\n\t/*      FW MODEL   BIOS VERS  EC VERS */\n\tTPV_QI0('I', 'W',  '5', '9'),\t\t /* A20m */\n\tTPV_QI0('I', 'V',  '6', '9'),\t\t /* A20p */\n\tTPV_QI0('1', '0',  '2', '6'),\t\t /* A21e, A22e */\n\tTPV_QI0('K', 'U',  '3', '6'),\t\t /* A21e */\n\tTPV_QI0('K', 'X',  '3', '6'),\t\t /* A21m, A22m */\n\tTPV_QI0('K', 'Y',  '3', '8'),\t\t /* A21p, A22p */\n\tTPV_QI0('1', 'B',  '1', '7'),\t\t /* A22e */\n\tTPV_QI0('1', '3',  '2', '0'),\t\t /* A22m */\n\tTPV_QI0('1', 'E',  '7', '3'),\t\t /* A30/p (0) */\n\tTPV_QI1('1', 'G',  '4', '1',  '1', '7'), /* A31/p (0) */\n\tTPV_QI1('1', 'N',  '1', '6',  '0', '7'), /* A31/p (0) */\n\n\t/* G-series ------------------------- */\n\t/*      FW MODEL   BIOS VERS\t      */\n\tTPV_QI0('1', 'T',  'A', '6'),\t\t /* G40 */\n\tTPV_QI0('1', 'X',  '5', '7'),\t\t /* G41 */\n\n\t/* R-series, T-series --------------- */\n\t/*      FW MODEL   BIOS VERS  EC VERS */\n\tTPV_QI0('1', 'C',  'F', '0'),\t\t /* R30 */\n\tTPV_QI0('1', 'F',  'F', '1'),\t\t /* R31 */\n\tTPV_QI0('1', 'M',  '9', '7'),\t\t /* R32 */\n\tTPV_QI0('1', 'O',  '6', '1'),\t\t /* R40 */\n\tTPV_QI0('1', 'P',  '6', '5'),\t\t /* R40 */\n\tTPV_QI0('1', 'S',  '7', '0'),\t\t /* R40e */\n\tTPV_QI1('1', 'R',  'D', 'R',  '7', '1'), /* R50/p, R51,\n\t\t\t\t\t\t    T40/p, T41/p, T42/p (1) */\n\tTPV_QI1('1', 'V',  '7', '1',  '2', '8'), /* R50e, R51 (1) */\n\tTPV_QI1('7', '8',  '7', '1',  '0', '6'), /* R51e (1) */\n\tTPV_QI1('7', '6',  '6', '9',  '1', '6'), /* R52 (1) */\n\tTPV_QI1('7', '0',  '6', '9',  '2', '8'), /* R52, T43 (1) */\n\n\tTPV_QI0('I', 'Y',  '6', '1'),\t\t /* T20 */\n\tTPV_QI0('K', 'Z',  '3', '4'),\t\t /* T21 */\n\tTPV_QI0('1', '6',  '3', '2'),\t\t /* T22 */\n\tTPV_QI1('1', 'A',  '6', '4',  '2', '3'), /* T23 (0) */\n\tTPV_QI1('1', 'I',  '7', '1',  '2', '0'), /* T30 (0) */\n\tTPV_QI1('1', 'Y',  '6', '5',  '2', '9'), /* T43/p (1) */\n\n\tTPV_QL1('7', '9',  'E', '3',  '5', '0'), /* T60/p */\n\tTPV_QL1('7', 'C',  'D', '2',  '2', '2'), /* R60, R60i */\n\tTPV_QL1('7', 'E',  'D', '0',  '1', '5'), /* R60e, R60i */\n\n\t/*      BIOS FW    BIOS VERS  EC FW     EC VERS */\n\tTPV_QI2('1', 'W',  '9', '0',  '1', 'V', '2', '8'), /* R50e (1) */\n\tTPV_QL2('7', 'I',  '3', '4',  '7', '9', '5', '0'), /* T60/p wide */\n\n\t/* X-series ------------------------- */\n\t/*      FW MODEL   BIOS VERS  EC VERS */\n\tTPV_QI0('I', 'Z',  '9', 'D'),\t\t /* X20, X21 */\n\tTPV_QI0('1', 'D',  '7', '0'),\t\t /* X22, X23, X24 */\n\tTPV_QI1('1', 'K',  '4', '8',  '1', '8'), /* X30 (0) */\n\tTPV_QI1('1', 'Q',  '9', '7',  '2', '3'), /* X31, X32 (0) */\n\tTPV_QI1('1', 'U',  'D', '3',  'B', '2'), /* X40 (0) */\n\tTPV_QI1('7', '4',  '6', '4',  '2', '7'), /* X41 (0) */\n\tTPV_QI1('7', '5',  '6', '0',  '2', '0'), /* X41t (0) */\n\n\tTPV_QL1('7', 'B',  'D', '7',  '4', '0'), /* X60/s */\n\tTPV_QL1('7', 'J',  '3', '0',  '1', '3'), /* X60t */\n\n\t/* (0) - older versions lack DMI EC fw string and functionality */\n\t/* (1) - older versions known to lack functionality */\n};\n\n#undef TPV_QL1\n#undef TPV_QL0\n#undef TPV_QI2\n#undef TPV_QI1\n#undef TPV_QI0\n#undef TPV_Q_X\n#undef TPV_Q\n\nstatic void __init tpacpi_check_outdated_fw(void)\n{\n\tunsigned long fwvers;\n\tu16 ec_version, bios_version;\n\n\tfwvers = tpacpi_check_quirks(tpacpi_bios_version_qtable,\n\t\t\t\tARRAY_SIZE(tpacpi_bios_version_qtable));\n\n\tif (!fwvers)\n\t\treturn;\n\n\tbios_version = fwvers & 0xffffU;\n\tec_version = (fwvers >> 16) & 0xffffU;\n\n\t/* note that unknown versions are set to 0x0000 and we use that */\n\tif ((bios_version > thinkpad_id.bios_release) ||\n\t    (ec_version > thinkpad_id.ec_release &&\n\t\t\t\tec_version != TPACPI_MATCH_ANY_VERSION)) {\n\t\t/*\n\t\t * The changelogs would let us track down the exact\n\t\t * reason, but it is just too much of a pain to track\n\t\t * it.  We only list BIOSes that are either really\n\t\t * broken, or really stable to begin with, so it is\n\t\t * best if the user upgrades the firmware anyway.\n\t\t */\n\t\tpr_warn(\"WARNING: Outdated ThinkPad BIOS/EC firmware\\n\");\n\t\tpr_warn(\"WARNING: This firmware may be missing critical bug fixes and/or important features\\n\");\n\t}\n}\n\nstatic bool __init tpacpi_is_fw_known(void)\n{\n\treturn tpacpi_check_quirks(tpacpi_bios_version_qtable,\n\t\t\tARRAY_SIZE(tpacpi_bios_version_qtable)) != 0;\n}\n\n/****************************************************************************\n ****************************************************************************\n *\n * Subdrivers\n *\n ****************************************************************************\n ****************************************************************************/\n\n/*************************************************************************\n * thinkpad-acpi metadata subdriver\n */\n\nstatic int thinkpad_acpi_driver_read(struct seq_file *m)\n{\n\tseq_printf(m, \"driver:\\t\\t%s\\n\", TPACPI_DESC);\n\tseq_printf(m, \"version:\\t%s\\n\", TPACPI_VERSION);\n\treturn 0;\n}\n\nstatic struct ibm_struct thinkpad_acpi_driver_data = {\n\t.name = \"driver\",\n\t.read = thinkpad_acpi_driver_read,\n};\n\n/*************************************************************************\n * Hotkey subdriver\n */\n\n/*\n * ThinkPad firmware event model\n *\n * The ThinkPad firmware has two main event interfaces: normal ACPI\n * notifications (which follow the ACPI standard), and a private event\n * interface.\n *\n * The private event interface also issues events for the hotkeys.  As\n * the driver gained features, the event handling code ended up being\n * built around the hotkey subdriver.  This will need to be refactored\n * to a more formal event API eventually.\n *\n * Some \"hotkeys\" are actually supposed to be used as event reports,\n * such as \"brightness has changed\", \"volume has changed\", depending on\n * the ThinkPad model and how the firmware is operating.\n *\n * Unlike other classes, hotkey-class events have mask/unmask control on\n * non-ancient firmware.  However, how it behaves changes a lot with the\n * firmware model and version.\n */\n\nenum {\t/* hot key scan codes (derived from ACPI DSDT) */\n\tTP_ACPI_HOTKEYSCAN_FNF1\t\t= 0,\n\tTP_ACPI_HOTKEYSCAN_FNF2,\n\tTP_ACPI_HOTKEYSCAN_FNF3,\n\tTP_ACPI_HOTKEYSCAN_FNF4,\n\tTP_ACPI_HOTKEYSCAN_FNF5,\n\tTP_ACPI_HOTKEYSCAN_FNF6,\n\tTP_ACPI_HOTKEYSCAN_FNF7,\n\tTP_ACPI_HOTKEYSCAN_FNF8,\n\tTP_ACPI_HOTKEYSCAN_FNF9,\n\tTP_ACPI_HOTKEYSCAN_FNF10,\n\tTP_ACPI_HOTKEYSCAN_FNF11,\n\tTP_ACPI_HOTKEYSCAN_FNF12,\n\tTP_ACPI_HOTKEYSCAN_FNBACKSPACE,\n\tTP_ACPI_HOTKEYSCAN_FNINSERT,\n\tTP_ACPI_HOTKEYSCAN_FNDELETE,\n\tTP_ACPI_HOTKEYSCAN_FNHOME,\n\tTP_ACPI_HOTKEYSCAN_FNEND,\n\tTP_ACPI_HOTKEYSCAN_FNPAGEUP,\n\tTP_ACPI_HOTKEYSCAN_FNPAGEDOWN,\n\tTP_ACPI_HOTKEYSCAN_FNSPACE,\n\tTP_ACPI_HOTKEYSCAN_VOLUMEUP,\n\tTP_ACPI_HOTKEYSCAN_VOLUMEDOWN,\n\tTP_ACPI_HOTKEYSCAN_MUTE,\n\tTP_ACPI_HOTKEYSCAN_THINKPAD,\n\tTP_ACPI_HOTKEYSCAN_UNK1,\n\tTP_ACPI_HOTKEYSCAN_UNK2,\n\tTP_ACPI_HOTKEYSCAN_UNK3,\n\tTP_ACPI_HOTKEYSCAN_UNK4,\n\tTP_ACPI_HOTKEYSCAN_UNK5,\n\tTP_ACPI_HOTKEYSCAN_UNK6,\n\tTP_ACPI_HOTKEYSCAN_UNK7,\n\tTP_ACPI_HOTKEYSCAN_UNK8,\n\n\t/* Adaptive keyboard keycodes */\n\tTP_ACPI_HOTKEYSCAN_ADAPTIVE_START,\n\tTP_ACPI_HOTKEYSCAN_MUTE2        = TP_ACPI_HOTKEYSCAN_ADAPTIVE_START,\n\tTP_ACPI_HOTKEYSCAN_BRIGHTNESS_ZERO,\n\tTP_ACPI_HOTKEYSCAN_CLIPPING_TOOL,\n\tTP_ACPI_HOTKEYSCAN_CLOUD,\n\tTP_ACPI_HOTKEYSCAN_UNK9,\n\tTP_ACPI_HOTKEYSCAN_VOICE,\n\tTP_ACPI_HOTKEYSCAN_UNK10,\n\tTP_ACPI_HOTKEYSCAN_GESTURES,\n\tTP_ACPI_HOTKEYSCAN_UNK11,\n\tTP_ACPI_HOTKEYSCAN_UNK12,\n\tTP_ACPI_HOTKEYSCAN_UNK13,\n\tTP_ACPI_HOTKEYSCAN_CONFIG,\n\tTP_ACPI_HOTKEYSCAN_NEW_TAB,\n\tTP_ACPI_HOTKEYSCAN_RELOAD,\n\tTP_ACPI_HOTKEYSCAN_BACK,\n\tTP_ACPI_HOTKEYSCAN_MIC_DOWN,\n\tTP_ACPI_HOTKEYSCAN_MIC_UP,\n\tTP_ACPI_HOTKEYSCAN_MIC_CANCELLATION,\n\tTP_ACPI_HOTKEYSCAN_CAMERA_MODE,\n\tTP_ACPI_HOTKEYSCAN_ROTATE_DISPLAY,\n\n\t/* Lenovo extended keymap, starting at 0x1300 */\n\tTP_ACPI_HOTKEYSCAN_EXTENDED_START,\n\t/* first new observed key (star, favorites) is 0x1311 */\n\tTP_ACPI_HOTKEYSCAN_STAR = 69,\n\tTP_ACPI_HOTKEYSCAN_CLIPPING_TOOL2,\n\tTP_ACPI_HOTKEYSCAN_CALCULATOR,\n\tTP_ACPI_HOTKEYSCAN_BLUETOOTH,\n\tTP_ACPI_HOTKEYSCAN_KEYBOARD,\n\tTP_ACPI_HOTKEYSCAN_FN_RIGHT_SHIFT, /* Used by \"Lenovo Quick Clean\" */\n\tTP_ACPI_HOTKEYSCAN_NOTIFICATION_CENTER,\n\tTP_ACPI_HOTKEYSCAN_PICKUP_PHONE,\n\tTP_ACPI_HOTKEYSCAN_HANGUP_PHONE,\n\n\t/* Hotkey keymap size */\n\tTPACPI_HOTKEY_MAP_LEN\n};\n\nenum {\t/* Keys/events available through NVRAM polling */\n\tTPACPI_HKEY_NVRAM_KNOWN_MASK = 0x00fb88c0U,\n\tTPACPI_HKEY_NVRAM_GOOD_MASK  = 0x00fb8000U,\n};\n\nenum {\t/* Positions of some of the keys in hotkey masks */\n\tTP_ACPI_HKEY_DISPSWTCH_MASK\t= 1 << TP_ACPI_HOTKEYSCAN_FNF7,\n\tTP_ACPI_HKEY_DISPXPAND_MASK\t= 1 << TP_ACPI_HOTKEYSCAN_FNF8,\n\tTP_ACPI_HKEY_HIBERNATE_MASK\t= 1 << TP_ACPI_HOTKEYSCAN_FNF12,\n\tTP_ACPI_HKEY_BRGHTUP_MASK\t= 1 << TP_ACPI_HOTKEYSCAN_FNHOME,\n\tTP_ACPI_HKEY_BRGHTDWN_MASK\t= 1 << TP_ACPI_HOTKEYSCAN_FNEND,\n\tTP_ACPI_HKEY_KBD_LIGHT_MASK\t= 1 << TP_ACPI_HOTKEYSCAN_FNPAGEUP,\n\tTP_ACPI_HKEY_ZOOM_MASK\t\t= 1 << TP_ACPI_HOTKEYSCAN_FNSPACE,\n\tTP_ACPI_HKEY_VOLUP_MASK\t\t= 1 << TP_ACPI_HOTKEYSCAN_VOLUMEUP,\n\tTP_ACPI_HKEY_VOLDWN_MASK\t= 1 << TP_ACPI_HOTKEYSCAN_VOLUMEDOWN,\n\tTP_ACPI_HKEY_MUTE_MASK\t\t= 1 << TP_ACPI_HOTKEYSCAN_MUTE,\n\tTP_ACPI_HKEY_THINKPAD_MASK\t= 1 << TP_ACPI_HOTKEYSCAN_THINKPAD,\n};\n\nenum {\t/* NVRAM to ACPI HKEY group map */\n\tTP_NVRAM_HKEY_GROUP_HK2\t\t= TP_ACPI_HKEY_THINKPAD_MASK |\n\t\t\t\t\t  TP_ACPI_HKEY_ZOOM_MASK |\n\t\t\t\t\t  TP_ACPI_HKEY_DISPSWTCH_MASK |\n\t\t\t\t\t  TP_ACPI_HKEY_HIBERNATE_MASK,\n\tTP_NVRAM_HKEY_GROUP_BRIGHTNESS\t= TP_ACPI_HKEY_BRGHTUP_MASK |\n\t\t\t\t\t  TP_ACPI_HKEY_BRGHTDWN_MASK,\n\tTP_NVRAM_HKEY_GROUP_VOLUME\t= TP_ACPI_HKEY_VOLUP_MASK |\n\t\t\t\t\t  TP_ACPI_HKEY_VOLDWN_MASK |\n\t\t\t\t\t  TP_ACPI_HKEY_MUTE_MASK,\n};\n\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\nstruct tp_nvram_state {\n       u16 thinkpad_toggle:1;\n       u16 zoom_toggle:1;\n       u16 display_toggle:1;\n       u16 thinklight_toggle:1;\n       u16 hibernate_toggle:1;\n       u16 displayexp_toggle:1;\n       u16 display_state:1;\n       u16 brightness_toggle:1;\n       u16 volume_toggle:1;\n       u16 mute:1;\n\n       u8 brightness_level;\n       u8 volume_level;\n};\n\n/* kthread for the hotkey poller */\nstatic struct task_struct *tpacpi_hotkey_task;\n\n/*\n * Acquire mutex to write poller control variables as an\n * atomic block.\n *\n * Increment hotkey_config_change when changing them if you\n * want the kthread to forget old state.\n *\n * See HOTKEY_CONFIG_CRITICAL_START/HOTKEY_CONFIG_CRITICAL_END\n */\nstatic struct mutex hotkey_thread_data_mutex;\nstatic unsigned int hotkey_config_change;\n\n/*\n * hotkey poller control variables\n *\n * Must be atomic or readers will also need to acquire mutex\n *\n * HOTKEY_CONFIG_CRITICAL_START/HOTKEY_CONFIG_CRITICAL_END\n * should be used only when the changes need to be taken as\n * a block, OR when one needs to force the kthread to forget\n * old state.\n */\nstatic u32 hotkey_source_mask;\t\t/* bit mask 0=ACPI,1=NVRAM */\nstatic unsigned int hotkey_poll_freq = 10; /* Hz */\n\n#define HOTKEY_CONFIG_CRITICAL_START \\\n\tdo { \\\n\t\tmutex_lock(&hotkey_thread_data_mutex); \\\n\t\thotkey_config_change++; \\\n\t} while (0);\n#define HOTKEY_CONFIG_CRITICAL_END \\\n\tmutex_unlock(&hotkey_thread_data_mutex);\n\n#else /* CONFIG_THINKPAD_ACPI_HOTKEY_POLL */\n\n#define hotkey_source_mask 0U\n#define HOTKEY_CONFIG_CRITICAL_START\n#define HOTKEY_CONFIG_CRITICAL_END\n\n#endif /* CONFIG_THINKPAD_ACPI_HOTKEY_POLL */\n\nstatic struct mutex hotkey_mutex;\n\nstatic enum {\t/* Reasons for waking up */\n\tTP_ACPI_WAKEUP_NONE = 0,\t/* None or unknown */\n\tTP_ACPI_WAKEUP_BAYEJ,\t\t/* Bay ejection request */\n\tTP_ACPI_WAKEUP_UNDOCK,\t\t/* Undock request */\n} hotkey_wakeup_reason;\n\nstatic int hotkey_autosleep_ack;\n\nstatic u32 hotkey_orig_mask;\t\t/* events the BIOS had enabled */\nstatic u32 hotkey_all_mask;\t\t/* all events supported in fw */\nstatic u32 hotkey_adaptive_all_mask;\t/* all adaptive events supported in fw */\nstatic u32 hotkey_reserved_mask;\t/* events better left disabled */\nstatic u32 hotkey_driver_mask;\t\t/* events needed by the driver */\nstatic u32 hotkey_user_mask;\t\t/* events visible to userspace */\nstatic u32 hotkey_acpi_mask;\t\t/* events enabled in firmware */\n\nstatic u16 *hotkey_keycode_map;\n\nstatic struct attribute_set *hotkey_dev_attributes;\n\nstatic void tpacpi_driver_event(const unsigned int hkey_event);\nstatic void hotkey_driver_event(const unsigned int scancode);\nstatic void hotkey_poll_setup(const bool may_warn);\n\n/* HKEY.MHKG() return bits */\n#define TP_HOTKEY_TABLET_MASK (1 << 3)\nenum {\n\tTP_ACPI_MULTI_MODE_INVALID\t= 0,\n\tTP_ACPI_MULTI_MODE_UNKNOWN\t= 1 << 0,\n\tTP_ACPI_MULTI_MODE_LAPTOP\t= 1 << 1,\n\tTP_ACPI_MULTI_MODE_TABLET\t= 1 << 2,\n\tTP_ACPI_MULTI_MODE_FLAT\t\t= 1 << 3,\n\tTP_ACPI_MULTI_MODE_STAND\t= 1 << 4,\n\tTP_ACPI_MULTI_MODE_TENT\t\t= 1 << 5,\n\tTP_ACPI_MULTI_MODE_STAND_TENT\t= 1 << 6,\n};\n\nenum {\n\t/* The following modes are considered tablet mode for the purpose of\n\t * reporting the status to userspace. i.e. in all these modes it makes\n\t * sense to disable the laptop input devices such as touchpad and\n\t * keyboard.\n\t */\n\tTP_ACPI_MULTI_MODE_TABLET_LIKE\t= TP_ACPI_MULTI_MODE_TABLET |\n\t\t\t\t\t  TP_ACPI_MULTI_MODE_STAND |\n\t\t\t\t\t  TP_ACPI_MULTI_MODE_TENT |\n\t\t\t\t\t  TP_ACPI_MULTI_MODE_STAND_TENT,\n};\n\nstatic int hotkey_get_wlsw(void)\n{\n\tint status;\n\n\tif (!tp_features.hotkey_wlsw)\n\t\treturn -ENODEV;\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_wlswemul)\n\t\treturn (tpacpi_wlsw_emulstate) ?\n\t\t\t\tTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\n#endif\n\n\tif (!acpi_evalf(hkey_handle, &status, \"WLSW\", \"d\"))\n\t\treturn -EIO;\n\n\treturn (status) ? TPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\n}\n\nstatic int hotkey_gmms_get_tablet_mode(int s, int *has_tablet_mode)\n{\n\tint type = (s >> 16) & 0xffff;\n\tint value = s & 0xffff;\n\tint mode = TP_ACPI_MULTI_MODE_INVALID;\n\tint valid_modes = 0;\n\n\tif (has_tablet_mode)\n\t\t*has_tablet_mode = 0;\n\n\tswitch (type) {\n\tcase 1:\n\t\tvalid_modes = TP_ACPI_MULTI_MODE_LAPTOP |\n\t\t\t      TP_ACPI_MULTI_MODE_TABLET |\n\t\t\t      TP_ACPI_MULTI_MODE_STAND_TENT;\n\t\tbreak;\n\tcase 2:\n\t\tvalid_modes = TP_ACPI_MULTI_MODE_LAPTOP |\n\t\t\t      TP_ACPI_MULTI_MODE_FLAT |\n\t\t\t      TP_ACPI_MULTI_MODE_TABLET |\n\t\t\t      TP_ACPI_MULTI_MODE_STAND |\n\t\t\t      TP_ACPI_MULTI_MODE_TENT;\n\t\tbreak;\n\tcase 3:\n\t\tvalid_modes = TP_ACPI_MULTI_MODE_LAPTOP |\n\t\t\t      TP_ACPI_MULTI_MODE_FLAT;\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\t/* In mode 4, FLAT is not specified as a valid mode. However,\n\t\t * it can be seen at least on the X1 Yoga 2nd Generation.\n\t\t */\n\t\tvalid_modes = TP_ACPI_MULTI_MODE_LAPTOP |\n\t\t\t      TP_ACPI_MULTI_MODE_FLAT |\n\t\t\t      TP_ACPI_MULTI_MODE_TABLET |\n\t\t\t      TP_ACPI_MULTI_MODE_STAND |\n\t\t\t      TP_ACPI_MULTI_MODE_TENT;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown multi mode status type %d with value 0x%04X, please report this to %s\\n\",\n\t\t       type, value, TPACPI_MAIL);\n\t\treturn 0;\n\t}\n\n\tif (has_tablet_mode && (valid_modes & TP_ACPI_MULTI_MODE_TABLET_LIKE))\n\t\t*has_tablet_mode = 1;\n\n\tswitch (value) {\n\tcase 1:\n\t\tmode = TP_ACPI_MULTI_MODE_LAPTOP;\n\t\tbreak;\n\tcase 2:\n\t\tmode = TP_ACPI_MULTI_MODE_FLAT;\n\t\tbreak;\n\tcase 3:\n\t\tmode = TP_ACPI_MULTI_MODE_TABLET;\n\t\tbreak;\n\tcase 4:\n\t\tif (type == 1)\n\t\t\tmode = TP_ACPI_MULTI_MODE_STAND_TENT;\n\t\telse\n\t\t\tmode = TP_ACPI_MULTI_MODE_STAND;\n\t\tbreak;\n\tcase 5:\n\t\tmode = TP_ACPI_MULTI_MODE_TENT;\n\t\tbreak;\n\tdefault:\n\t\tif (type == 5 && value == 0xffff) {\n\t\t\tpr_warn(\"Multi mode status is undetected, assuming laptop\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!(mode & valid_modes)) {\n\t\tpr_err(\"Unknown/reserved multi mode value 0x%04X for type %d, please report this to %s\\n\",\n\t\t       value, type, TPACPI_MAIL);\n\t\treturn 0;\n\t}\n\n\treturn !!(mode & TP_ACPI_MULTI_MODE_TABLET_LIKE);\n}\n\nstatic int hotkey_get_tablet_mode(int *status)\n{\n\tint s;\n\n\tswitch (tp_features.hotkey_tablet) {\n\tcase TP_HOTKEY_TABLET_USES_MHKG:\n\t\tif (!acpi_evalf(hkey_handle, &s, \"MHKG\", \"d\"))\n\t\t\treturn -EIO;\n\n\t\t*status = ((s & TP_HOTKEY_TABLET_MASK) != 0);\n\t\tbreak;\n\tcase TP_HOTKEY_TABLET_USES_GMMS:\n\t\tif (!acpi_evalf(hkey_handle, &s, \"GMMS\", \"dd\", 0))\n\t\t\treturn -EIO;\n\n\t\t*status = hotkey_gmms_get_tablet_mode(s, NULL);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Reads current event mask from firmware, and updates\n * hotkey_acpi_mask accordingly.  Also resets any bits\n * from hotkey_user_mask that are unavailable to be\n * delivered (shadow requirement of the userspace ABI).\n *\n * Call with hotkey_mutex held\n */\nstatic int hotkey_mask_get(void)\n{\n\tif (tp_features.hotkey_mask) {\n\t\tu32 m = 0;\n\n\t\tif (!acpi_evalf(hkey_handle, &m, \"DHKN\", \"d\"))\n\t\t\treturn -EIO;\n\n\t\thotkey_acpi_mask = m;\n\t} else {\n\t\t/* no mask support doesn't mean no event support... */\n\t\thotkey_acpi_mask = hotkey_all_mask;\n\t}\n\n\t/* sync userspace-visible mask */\n\thotkey_user_mask &= (hotkey_acpi_mask | hotkey_source_mask);\n\n\treturn 0;\n}\n\nstatic void hotkey_mask_warn_incomplete_mask(void)\n{\n\t/* log only what the user can fix... */\n\tconst u32 wantedmask = hotkey_driver_mask &\n\t\t~(hotkey_acpi_mask | hotkey_source_mask) &\n\t\t(hotkey_all_mask | TPACPI_HKEY_NVRAM_KNOWN_MASK);\n\n\tif (wantedmask)\n\t\tpr_notice(\"required events 0x%08x not enabled!\\n\", wantedmask);\n}\n\n/*\n * Set the firmware mask when supported\n *\n * Also calls hotkey_mask_get to update hotkey_acpi_mask.\n *\n * NOTE: does not set bits in hotkey_user_mask, but may reset them.\n *\n * Call with hotkey_mutex held\n */\nstatic int hotkey_mask_set(u32 mask)\n{\n\tint i;\n\tint rc = 0;\n\n\tconst u32 fwmask = mask & ~hotkey_source_mask;\n\n\tif (tp_features.hotkey_mask) {\n\t\tfor (i = 0; i < 32; i++) {\n\t\t\tif (!acpi_evalf(hkey_handle,\n\t\t\t\t\tNULL, \"MHKM\", \"vdd\", i + 1,\n\t\t\t\t\t!!(mask & (1 << i)))) {\n\t\t\t\trc = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We *must* make an inconditional call to hotkey_mask_get to\n\t * refresh hotkey_acpi_mask and update hotkey_user_mask\n\t *\n\t * Take the opportunity to also log when we cannot _enable_\n\t * a given event.\n\t */\n\tif (!hotkey_mask_get() && !rc && (fwmask & ~hotkey_acpi_mask)) {\n\t\tpr_notice(\"asked for hotkey mask 0x%08x, but firmware forced it to 0x%08x\\n\",\n\t\t\t  fwmask, hotkey_acpi_mask);\n\t}\n\n\tif (tpacpi_lifecycle != TPACPI_LIFE_EXITING)\n\t\thotkey_mask_warn_incomplete_mask();\n\n\treturn rc;\n}\n\n/*\n * Sets hotkey_user_mask and tries to set the firmware mask\n *\n * Call with hotkey_mutex held\n */\nstatic int hotkey_user_mask_set(const u32 mask)\n{\n\tint rc;\n\n\t/* Give people a chance to notice they are doing something that\n\t * is bound to go boom on their users sooner or later */\n\tif (!tp_warned.hotkey_mask_ff &&\n\t    (mask == 0xffff || mask == 0xffffff ||\n\t     mask == 0xffffffff)) {\n\t\ttp_warned.hotkey_mask_ff = 1;\n\t\tpr_notice(\"setting the hotkey mask to 0x%08x is likely not the best way to go about it\\n\",\n\t\t\t  mask);\n\t\tpr_notice(\"please consider using the driver defaults, and refer to up-to-date thinkpad-acpi documentation\\n\");\n\t}\n\n\t/* Try to enable what the user asked for, plus whatever we need.\n\t * this syncs everything but won't enable bits in hotkey_user_mask */\n\trc = hotkey_mask_set((mask | hotkey_driver_mask) & ~hotkey_source_mask);\n\n\t/* Enable the available bits in hotkey_user_mask */\n\thotkey_user_mask = mask & (hotkey_acpi_mask | hotkey_source_mask);\n\n\treturn rc;\n}\n\n/*\n * Sets the driver hotkey mask.\n *\n * Can be called even if the hotkey subdriver is inactive\n */\nstatic int tpacpi_hotkey_driver_mask_set(const u32 mask)\n{\n\tint rc;\n\n\t/* Do the right thing if hotkey_init has not been called yet */\n\tif (!tp_features.hotkey) {\n\t\thotkey_driver_mask = mask;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&hotkey_mutex);\n\n\tHOTKEY_CONFIG_CRITICAL_START\n\thotkey_driver_mask = mask;\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\n\thotkey_source_mask |= (mask & ~hotkey_all_mask);\n#endif\n\tHOTKEY_CONFIG_CRITICAL_END\n\n\trc = hotkey_mask_set((hotkey_acpi_mask | hotkey_driver_mask) &\n\t\t\t\t\t\t\t~hotkey_source_mask);\n\thotkey_poll_setup(true);\n\n\tmutex_unlock(&hotkey_mutex);\n\n\treturn rc;\n}\n\nstatic int hotkey_status_get(int *status)\n{\n\tif (!acpi_evalf(hkey_handle, status, \"DHKC\", \"d\"))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int hotkey_status_set(bool enable)\n{\n\tif (!acpi_evalf(hkey_handle, NULL, \"MHKC\", \"vd\", enable ? 1 : 0))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void tpacpi_input_send_tabletsw(void)\n{\n\tint state;\n\n\tif (tp_features.hotkey_tablet &&\n\t    !hotkey_get_tablet_mode(&state)) {\n\t\tmutex_lock(&tpacpi_inputdev_send_mutex);\n\n\t\tinput_report_switch(tpacpi_inputdev,\n\t\t\t\t    SW_TABLET_MODE, !!state);\n\t\tinput_sync(tpacpi_inputdev);\n\n\t\tmutex_unlock(&tpacpi_inputdev_send_mutex);\n\t}\n}\n\n/* Do NOT call without validating scancode first */\nstatic void tpacpi_input_send_key(const unsigned int scancode)\n{\n\tconst unsigned int keycode = hotkey_keycode_map[scancode];\n\n\tif (keycode != KEY_RESERVED) {\n\t\tmutex_lock(&tpacpi_inputdev_send_mutex);\n\n\t\tinput_event(tpacpi_inputdev, EV_MSC, MSC_SCAN, scancode);\n\t\tinput_report_key(tpacpi_inputdev, keycode, 1);\n\t\tinput_sync(tpacpi_inputdev);\n\n\t\tinput_event(tpacpi_inputdev, EV_MSC, MSC_SCAN, scancode);\n\t\tinput_report_key(tpacpi_inputdev, keycode, 0);\n\t\tinput_sync(tpacpi_inputdev);\n\n\t\tmutex_unlock(&tpacpi_inputdev_send_mutex);\n\t}\n}\n\n/* Do NOT call without validating scancode first */\nstatic void tpacpi_input_send_key_masked(const unsigned int scancode)\n{\n\thotkey_driver_event(scancode);\n\tif (hotkey_user_mask & (1 << scancode))\n\t\ttpacpi_input_send_key(scancode);\n}\n\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\nstatic struct tp_acpi_drv_struct ibm_hotkey_acpidriver;\n\n/* Do NOT call without validating scancode first */\nstatic void tpacpi_hotkey_send_key(unsigned int scancode)\n{\n\ttpacpi_input_send_key_masked(scancode);\n}\n\nstatic void hotkey_read_nvram(struct tp_nvram_state *n, const u32 m)\n{\n\tu8 d;\n\n\tif (m & TP_NVRAM_HKEY_GROUP_HK2) {\n\t\td = nvram_read_byte(TP_NVRAM_ADDR_HK2);\n\t\tn->thinkpad_toggle = !!(d & TP_NVRAM_MASK_HKT_THINKPAD);\n\t\tn->zoom_toggle = !!(d & TP_NVRAM_MASK_HKT_ZOOM);\n\t\tn->display_toggle = !!(d & TP_NVRAM_MASK_HKT_DISPLAY);\n\t\tn->hibernate_toggle = !!(d & TP_NVRAM_MASK_HKT_HIBERNATE);\n\t}\n\tif (m & TP_ACPI_HKEY_KBD_LIGHT_MASK) {\n\t\td = nvram_read_byte(TP_NVRAM_ADDR_THINKLIGHT);\n\t\tn->thinklight_toggle = !!(d & TP_NVRAM_MASK_THINKLIGHT);\n\t}\n\tif (m & TP_ACPI_HKEY_DISPXPAND_MASK) {\n\t\td = nvram_read_byte(TP_NVRAM_ADDR_VIDEO);\n\t\tn->displayexp_toggle =\n\t\t\t\t!!(d & TP_NVRAM_MASK_HKT_DISPEXPND);\n\t}\n\tif (m & TP_NVRAM_HKEY_GROUP_BRIGHTNESS) {\n\t\td = nvram_read_byte(TP_NVRAM_ADDR_BRIGHTNESS);\n\t\tn->brightness_level = (d & TP_NVRAM_MASK_LEVEL_BRIGHTNESS)\n\t\t\t\t>> TP_NVRAM_POS_LEVEL_BRIGHTNESS;\n\t\tn->brightness_toggle =\n\t\t\t\t!!(d & TP_NVRAM_MASK_HKT_BRIGHTNESS);\n\t}\n\tif (m & TP_NVRAM_HKEY_GROUP_VOLUME) {\n\t\td = nvram_read_byte(TP_NVRAM_ADDR_MIXER);\n\t\tn->volume_level = (d & TP_NVRAM_MASK_LEVEL_VOLUME)\n\t\t\t\t>> TP_NVRAM_POS_LEVEL_VOLUME;\n\t\tn->mute = !!(d & TP_NVRAM_MASK_MUTE);\n\t\tn->volume_toggle = !!(d & TP_NVRAM_MASK_HKT_VOLUME);\n\t}\n}\n\n#define TPACPI_COMPARE_KEY(__scancode, __member) \\\ndo { \\\n\tif ((event_mask & (1 << __scancode)) && \\\n\t    oldn->__member != newn->__member) \\\n\t\ttpacpi_hotkey_send_key(__scancode); \\\n} while (0)\n\n#define TPACPI_MAY_SEND_KEY(__scancode) \\\ndo { \\\n\tif (event_mask & (1 << __scancode)) \\\n\t\ttpacpi_hotkey_send_key(__scancode); \\\n} while (0)\n\nstatic void issue_volchange(const unsigned int oldvol,\n\t\t\t    const unsigned int newvol,\n\t\t\t    const u32 event_mask)\n{\n\tunsigned int i = oldvol;\n\n\twhile (i > newvol) {\n\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_VOLUMEDOWN);\n\t\ti--;\n\t}\n\twhile (i < newvol) {\n\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_VOLUMEUP);\n\t\ti++;\n\t}\n}\n\nstatic void issue_brightnesschange(const unsigned int oldbrt,\n\t\t\t\t   const unsigned int newbrt,\n\t\t\t\t   const u32 event_mask)\n{\n\tunsigned int i = oldbrt;\n\n\twhile (i > newbrt) {\n\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_FNEND);\n\t\ti--;\n\t}\n\twhile (i < newbrt) {\n\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_FNHOME);\n\t\ti++;\n\t}\n}\n\nstatic void hotkey_compare_and_issue_event(struct tp_nvram_state *oldn,\n\t\t\t\t\t   struct tp_nvram_state *newn,\n\t\t\t\t\t   const u32 event_mask)\n{\n\n\tTPACPI_COMPARE_KEY(TP_ACPI_HOTKEYSCAN_THINKPAD, thinkpad_toggle);\n\tTPACPI_COMPARE_KEY(TP_ACPI_HOTKEYSCAN_FNSPACE, zoom_toggle);\n\tTPACPI_COMPARE_KEY(TP_ACPI_HOTKEYSCAN_FNF7, display_toggle);\n\tTPACPI_COMPARE_KEY(TP_ACPI_HOTKEYSCAN_FNF12, hibernate_toggle);\n\n\tTPACPI_COMPARE_KEY(TP_ACPI_HOTKEYSCAN_FNPAGEUP, thinklight_toggle);\n\n\tTPACPI_COMPARE_KEY(TP_ACPI_HOTKEYSCAN_FNF8, displayexp_toggle);\n\n\t/*\n\t * Handle volume\n\t *\n\t * This code is supposed to duplicate the IBM firmware behaviour:\n\t * - Pressing MUTE issues mute hotkey message, even when already mute\n\t * - Pressing Volume up/down issues volume up/down hotkey messages,\n\t *   even when already at maximum or minimum volume\n\t * - The act of unmuting issues volume up/down notification,\n\t *   depending which key was used to unmute\n\t *\n\t * We are constrained to what the NVRAM can tell us, which is not much\n\t * and certainly not enough if more than one volume hotkey was pressed\n\t * since the last poll cycle.\n\t *\n\t * Just to make our life interesting, some newer Lenovo ThinkPads have\n\t * bugs in the BIOS and may fail to update volume_toggle properly.\n\t */\n\tif (newn->mute) {\n\t\t/* muted */\n\t\tif (!oldn->mute ||\n\t\t    oldn->volume_toggle != newn->volume_toggle ||\n\t\t    oldn->volume_level != newn->volume_level) {\n\t\t\t/* recently muted, or repeated mute keypress, or\n\t\t\t * multiple presses ending in mute */\n\t\t\tissue_volchange(oldn->volume_level, newn->volume_level,\n\t\t\t\tevent_mask);\n\t\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_MUTE);\n\t\t}\n\t} else {\n\t\t/* unmute */\n\t\tif (oldn->mute) {\n\t\t\t/* recently unmuted, issue 'unmute' keypress */\n\t\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_VOLUMEUP);\n\t\t}\n\t\tif (oldn->volume_level != newn->volume_level) {\n\t\t\tissue_volchange(oldn->volume_level, newn->volume_level,\n\t\t\t\tevent_mask);\n\t\t} else if (oldn->volume_toggle != newn->volume_toggle) {\n\t\t\t/* repeated vol up/down keypress at end of scale ? */\n\t\t\tif (newn->volume_level == 0)\n\t\t\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_VOLUMEDOWN);\n\t\t\telse if (newn->volume_level >= TP_NVRAM_LEVEL_VOLUME_MAX)\n\t\t\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_VOLUMEUP);\n\t\t}\n\t}\n\n\t/* handle brightness */\n\tif (oldn->brightness_level != newn->brightness_level) {\n\t\tissue_brightnesschange(oldn->brightness_level,\n\t\t\t\t       newn->brightness_level, event_mask);\n\t} else if (oldn->brightness_toggle != newn->brightness_toggle) {\n\t\t/* repeated key presses that didn't change state */\n\t\tif (newn->brightness_level == 0)\n\t\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_FNEND);\n\t\telse if (newn->brightness_level >= bright_maxlvl\n\t\t\t\t&& !tp_features.bright_unkfw)\n\t\t\tTPACPI_MAY_SEND_KEY(TP_ACPI_HOTKEYSCAN_FNHOME);\n\t}\n\n#undef TPACPI_COMPARE_KEY\n#undef TPACPI_MAY_SEND_KEY\n}\n\n/*\n * Polling driver\n *\n * We track all events in hotkey_source_mask all the time, since\n * most of them are edge-based.  We only issue those requested by\n * hotkey_user_mask or hotkey_driver_mask, though.\n */\nstatic int hotkey_kthread(void *data)\n{\n\tstruct tp_nvram_state s[2] = { 0 };\n\tu32 poll_mask, event_mask;\n\tunsigned int si, so;\n\tunsigned long t;\n\tunsigned int change_detector;\n\tunsigned int poll_freq;\n\tbool was_frozen;\n\n\tif (tpacpi_lifecycle == TPACPI_LIFE_EXITING)\n\t\tgoto exit;\n\n\tset_freezable();\n\n\tso = 0;\n\tsi = 1;\n\tt = 0;\n\n\t/* Initial state for compares */\n\tmutex_lock(&hotkey_thread_data_mutex);\n\tchange_detector = hotkey_config_change;\n\tpoll_mask = hotkey_source_mask;\n\tevent_mask = hotkey_source_mask &\n\t\t\t(hotkey_driver_mask | hotkey_user_mask);\n\tpoll_freq = hotkey_poll_freq;\n\tmutex_unlock(&hotkey_thread_data_mutex);\n\thotkey_read_nvram(&s[so], poll_mask);\n\n\twhile (!kthread_should_stop()) {\n\t\tif (t == 0) {\n\t\t\tif (likely(poll_freq))\n\t\t\t\tt = 1000/poll_freq;\n\t\t\telse\n\t\t\t\tt = 100;\t/* should never happen... */\n\t\t}\n\t\tt = msleep_interruptible(t);\n\t\tif (unlikely(kthread_freezable_should_stop(&was_frozen)))\n\t\t\tbreak;\n\n\t\tif (t > 0 && !was_frozen)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&hotkey_thread_data_mutex);\n\t\tif (was_frozen || hotkey_config_change != change_detector) {\n\t\t\t/* forget old state on thaw or config change */\n\t\t\tsi = so;\n\t\t\tt = 0;\n\t\t\tchange_detector = hotkey_config_change;\n\t\t}\n\t\tpoll_mask = hotkey_source_mask;\n\t\tevent_mask = hotkey_source_mask &\n\t\t\t\t(hotkey_driver_mask | hotkey_user_mask);\n\t\tpoll_freq = hotkey_poll_freq;\n\t\tmutex_unlock(&hotkey_thread_data_mutex);\n\n\t\tif (likely(poll_mask)) {\n\t\t\thotkey_read_nvram(&s[si], poll_mask);\n\t\t\tif (likely(si != so)) {\n\t\t\t\thotkey_compare_and_issue_event(&s[so], &s[si],\n\t\t\t\t\t\t\t\tevent_mask);\n\t\t\t}\n\t\t}\n\n\t\tso = si;\n\t\tsi ^= 1;\n\t}\n\nexit:\n\treturn 0;\n}\n\n/* call with hotkey_mutex held */\nstatic void hotkey_poll_stop_sync(void)\n{\n\tif (tpacpi_hotkey_task) {\n\t\tkthread_stop(tpacpi_hotkey_task);\n\t\ttpacpi_hotkey_task = NULL;\n\t}\n}\n\n/* call with hotkey_mutex held */\nstatic void hotkey_poll_setup(const bool may_warn)\n{\n\tconst u32 poll_driver_mask = hotkey_driver_mask & hotkey_source_mask;\n\tconst u32 poll_user_mask = hotkey_user_mask & hotkey_source_mask;\n\n\tif (hotkey_poll_freq > 0 &&\n\t    (poll_driver_mask ||\n\t     (poll_user_mask && tpacpi_inputdev->users > 0))) {\n\t\tif (!tpacpi_hotkey_task) {\n\t\t\ttpacpi_hotkey_task = kthread_run(hotkey_kthread,\n\t\t\t\t\tNULL, TPACPI_NVRAM_KTHREAD_NAME);\n\t\t\tif (IS_ERR(tpacpi_hotkey_task)) {\n\t\t\t\ttpacpi_hotkey_task = NULL;\n\t\t\t\tpr_err(\"could not create kernel thread for hotkey polling\\n\");\n\t\t\t}\n\t\t}\n\t} else {\n\t\thotkey_poll_stop_sync();\n\t\tif (may_warn && (poll_driver_mask || poll_user_mask) &&\n\t\t    hotkey_poll_freq == 0) {\n\t\t\tpr_notice(\"hot keys 0x%08x and/or events 0x%08x require polling, which is currently disabled\\n\",\n\t\t\t\t  poll_user_mask, poll_driver_mask);\n\t\t}\n\t}\n}\n\nstatic void hotkey_poll_setup_safe(const bool may_warn)\n{\n\tmutex_lock(&hotkey_mutex);\n\thotkey_poll_setup(may_warn);\n\tmutex_unlock(&hotkey_mutex);\n}\n\n/* call with hotkey_mutex held */\nstatic void hotkey_poll_set_freq(unsigned int freq)\n{\n\tif (!freq)\n\t\thotkey_poll_stop_sync();\n\n\thotkey_poll_freq = freq;\n}\n\n#else /* CONFIG_THINKPAD_ACPI_HOTKEY_POLL */\n\nstatic void hotkey_poll_setup(const bool __unused)\n{\n}\n\nstatic void hotkey_poll_setup_safe(const bool __unused)\n{\n}\n\n#endif /* CONFIG_THINKPAD_ACPI_HOTKEY_POLL */\n\nstatic int hotkey_inputdev_open(struct input_dev *dev)\n{\n\tswitch (tpacpi_lifecycle) {\n\tcase TPACPI_LIFE_INIT:\n\tcase TPACPI_LIFE_RUNNING:\n\t\thotkey_poll_setup_safe(false);\n\t\treturn 0;\n\tcase TPACPI_LIFE_EXITING:\n\t\treturn -EBUSY;\n\t}\n\n\t/* Should only happen if tpacpi_lifecycle is corrupt */\n\tBUG();\n\treturn -EBUSY;\n}\n\nstatic void hotkey_inputdev_close(struct input_dev *dev)\n{\n\t/* disable hotkey polling when possible */\n\tif (tpacpi_lifecycle != TPACPI_LIFE_EXITING &&\n\t    !(hotkey_source_mask & hotkey_driver_mask))\n\t\thotkey_poll_setup_safe(false);\n}\n\n/* sysfs hotkey enable ------------------------------------------------- */\nstatic ssize_t hotkey_enable_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint res, status;\n\n\tprintk_deprecated_attribute(\"hotkey_enable\",\n\t\t\t\"Hotkey reporting is always enabled\");\n\n\tres = hotkey_status_get(&status);\n\tif (res)\n\t\treturn res;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", status);\n}\n\nstatic ssize_t hotkey_enable_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned long t;\n\n\tprintk_deprecated_attribute(\"hotkey_enable\",\n\t\t\t\"Hotkeys can be disabled through hotkey_mask\");\n\n\tif (parse_strtoul(buf, 1, &t))\n\t\treturn -EINVAL;\n\n\tif (t == 0)\n\t\treturn -EPERM;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(hotkey_enable);\n\n/* sysfs hotkey mask --------------------------------------------------- */\nstatic ssize_t hotkey_mask_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"0x%08x\\n\", hotkey_user_mask);\n}\n\nstatic ssize_t hotkey_mask_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned long t;\n\tint res;\n\n\tif (parse_strtoul(buf, 0xffffffffUL, &t))\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_killable(&hotkey_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tres = hotkey_user_mask_set(t);\n\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\n\thotkey_poll_setup(true);\n#endif\n\n\tmutex_unlock(&hotkey_mutex);\n\n\ttpacpi_disclose_usertask(\"hotkey_mask\", \"set to 0x%08lx\\n\", t);\n\n\treturn (res) ? res : count;\n}\n\nstatic DEVICE_ATTR_RW(hotkey_mask);\n\n/* sysfs hotkey bios_enabled ------------------------------------------- */\nstatic ssize_t hotkey_bios_enabled_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic DEVICE_ATTR_RO(hotkey_bios_enabled);\n\n/* sysfs hotkey bios_mask ---------------------------------------------- */\nstatic ssize_t hotkey_bios_mask_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tprintk_deprecated_attribute(\"hotkey_bios_mask\",\n\t\t\t\"This attribute is useless.\");\n\treturn snprintf(buf, PAGE_SIZE, \"0x%08x\\n\", hotkey_orig_mask);\n}\n\nstatic DEVICE_ATTR_RO(hotkey_bios_mask);\n\n/* sysfs hotkey all_mask ----------------------------------------------- */\nstatic ssize_t hotkey_all_mask_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"0x%08x\\n\",\n\t\t\t\thotkey_all_mask | hotkey_source_mask);\n}\n\nstatic DEVICE_ATTR_RO(hotkey_all_mask);\n\n/* sysfs hotkey all_mask ----------------------------------------------- */\nstatic ssize_t hotkey_adaptive_all_mask_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"0x%08x\\n\",\n\t\t\thotkey_adaptive_all_mask | hotkey_source_mask);\n}\n\nstatic DEVICE_ATTR_RO(hotkey_adaptive_all_mask);\n\n/* sysfs hotkey recommended_mask --------------------------------------- */\nstatic ssize_t hotkey_recommended_mask_show(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"0x%08x\\n\",\n\t\t\t(hotkey_all_mask | hotkey_source_mask)\n\t\t\t& ~hotkey_reserved_mask);\n}\n\nstatic DEVICE_ATTR_RO(hotkey_recommended_mask);\n\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\n\n/* sysfs hotkey hotkey_source_mask ------------------------------------- */\nstatic ssize_t hotkey_source_mask_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"0x%08x\\n\", hotkey_source_mask);\n}\n\nstatic ssize_t hotkey_source_mask_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned long t;\n\tu32 r_ev;\n\tint rc;\n\n\tif (parse_strtoul(buf, 0xffffffffUL, &t) ||\n\t\t((t & ~TPACPI_HKEY_NVRAM_KNOWN_MASK) != 0))\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_killable(&hotkey_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tHOTKEY_CONFIG_CRITICAL_START\n\thotkey_source_mask = t;\n\tHOTKEY_CONFIG_CRITICAL_END\n\n\trc = hotkey_mask_set((hotkey_user_mask | hotkey_driver_mask) &\n\t\t\t~hotkey_source_mask);\n\thotkey_poll_setup(true);\n\n\t/* check if events needed by the driver got disabled */\n\tr_ev = hotkey_driver_mask & ~(hotkey_acpi_mask & hotkey_all_mask)\n\t\t& ~hotkey_source_mask & TPACPI_HKEY_NVRAM_KNOWN_MASK;\n\n\tmutex_unlock(&hotkey_mutex);\n\n\tif (rc < 0)\n\t\tpr_err(\"hotkey_source_mask: failed to update the firmware event mask!\\n\");\n\n\tif (r_ev)\n\t\tpr_notice(\"hotkey_source_mask: some important events were disabled: 0x%04x\\n\",\n\t\t\t  r_ev);\n\n\ttpacpi_disclose_usertask(\"hotkey_source_mask\", \"set to 0x%08lx\\n\", t);\n\n\treturn (rc < 0) ? rc : count;\n}\n\nstatic DEVICE_ATTR_RW(hotkey_source_mask);\n\n/* sysfs hotkey hotkey_poll_freq --------------------------------------- */\nstatic ssize_t hotkey_poll_freq_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", hotkey_poll_freq);\n}\n\nstatic ssize_t hotkey_poll_freq_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned long t;\n\n\tif (parse_strtoul(buf, 25, &t))\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_killable(&hotkey_mutex))\n\t\treturn -ERESTARTSYS;\n\n\thotkey_poll_set_freq(t);\n\thotkey_poll_setup(true);\n\n\tmutex_unlock(&hotkey_mutex);\n\n\ttpacpi_disclose_usertask(\"hotkey_poll_freq\", \"set to %lu\\n\", t);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(hotkey_poll_freq);\n\n#endif /* CONFIG_THINKPAD_ACPI_HOTKEY_POLL */\n\n/* sysfs hotkey radio_sw (pollable) ------------------------------------ */\nstatic ssize_t hotkey_radio_sw_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint res;\n\tres = hotkey_get_wlsw();\n\tif (res < 0)\n\t\treturn res;\n\n\t/* Opportunistic update */\n\ttpacpi_rfk_update_hwblock_state((res == TPACPI_RFK_RADIO_OFF));\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t(res == TPACPI_RFK_RADIO_OFF) ? 0 : 1);\n}\n\nstatic DEVICE_ATTR_RO(hotkey_radio_sw);\n\nstatic void hotkey_radio_sw_notify_change(void)\n{\n\tif (tp_features.hotkey_wlsw)\n\t\tsysfs_notify(&tpacpi_pdev->dev.kobj, NULL,\n\t\t\t     \"hotkey_radio_sw\");\n}\n\n/* sysfs hotkey tablet mode (pollable) --------------------------------- */\nstatic ssize_t hotkey_tablet_mode_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint res, s;\n\tres = hotkey_get_tablet_mode(&s);\n\tif (res < 0)\n\t\treturn res;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", !!s);\n}\n\nstatic DEVICE_ATTR_RO(hotkey_tablet_mode);\n\nstatic void hotkey_tablet_mode_notify_change(void)\n{\n\tif (tp_features.hotkey_tablet)\n\t\tsysfs_notify(&tpacpi_pdev->dev.kobj, NULL,\n\t\t\t     \"hotkey_tablet_mode\");\n}\n\n/* sysfs wakeup reason (pollable) -------------------------------------- */\nstatic ssize_t hotkey_wakeup_reason_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", hotkey_wakeup_reason);\n}\n\nstatic DEVICE_ATTR(wakeup_reason, S_IRUGO, hotkey_wakeup_reason_show, NULL);\n\nstatic void hotkey_wakeup_reason_notify_change(void)\n{\n\tsysfs_notify(&tpacpi_pdev->dev.kobj, NULL,\n\t\t     \"wakeup_reason\");\n}\n\n/* sysfs wakeup hotunplug_complete (pollable) -------------------------- */\nstatic ssize_t hotkey_wakeup_hotunplug_complete_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", hotkey_autosleep_ack);\n}\n\nstatic DEVICE_ATTR(wakeup_hotunplug_complete, S_IRUGO,\n\t\t   hotkey_wakeup_hotunplug_complete_show, NULL);\n\nstatic void hotkey_wakeup_hotunplug_complete_notify_change(void)\n{\n\tsysfs_notify(&tpacpi_pdev->dev.kobj, NULL,\n\t\t     \"wakeup_hotunplug_complete\");\n}\n\n/* sysfs adaptive kbd mode --------------------------------------------- */\n\nstatic int adaptive_keyboard_get_mode(void);\nstatic int adaptive_keyboard_set_mode(int new_mode);\n\nenum ADAPTIVE_KEY_MODE {\n\tHOME_MODE,\n\tWEB_BROWSER_MODE,\n\tWEB_CONFERENCE_MODE,\n\tFUNCTION_MODE,\n\tLAYFLAT_MODE\n};\n\nstatic ssize_t adaptive_kbd_mode_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint current_mode;\n\n\tcurrent_mode = adaptive_keyboard_get_mode();\n\tif (current_mode < 0)\n\t\treturn current_mode;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_mode);\n}\n\nstatic ssize_t adaptive_kbd_mode_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned long t;\n\tint res;\n\n\tif (parse_strtoul(buf, LAYFLAT_MODE, &t))\n\t\treturn -EINVAL;\n\n\tres = adaptive_keyboard_set_mode(t);\n\treturn (res < 0) ? res : count;\n}\n\nstatic DEVICE_ATTR_RW(adaptive_kbd_mode);\n\nstatic struct attribute *adaptive_kbd_attributes[] = {\n\t&dev_attr_adaptive_kbd_mode.attr,\n\tNULL\n};\n\nstatic const struct attribute_group adaptive_kbd_attr_group = {\n\t.attrs = adaptive_kbd_attributes,\n};\n\n/* --------------------------------------------------------------------- */\n\nstatic struct attribute *hotkey_attributes[] __initdata = {\n\t&dev_attr_hotkey_enable.attr,\n\t&dev_attr_hotkey_bios_enabled.attr,\n\t&dev_attr_hotkey_bios_mask.attr,\n\t&dev_attr_wakeup_reason.attr,\n\t&dev_attr_wakeup_hotunplug_complete.attr,\n\t&dev_attr_hotkey_mask.attr,\n\t&dev_attr_hotkey_all_mask.attr,\n\t&dev_attr_hotkey_adaptive_all_mask.attr,\n\t&dev_attr_hotkey_recommended_mask.attr,\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\n\t&dev_attr_hotkey_source_mask.attr,\n\t&dev_attr_hotkey_poll_freq.attr,\n#endif\n};\n\n/*\n * Sync both the hw and sw blocking state of all switches\n */\nstatic void tpacpi_send_radiosw_update(void)\n{\n\tint wlsw;\n\n\t/*\n\t * We must sync all rfkill controllers *before* issuing any\n\t * rfkill input events, or we will race the rfkill core input\n\t * handler.\n\t *\n\t * tpacpi_inputdev_send_mutex works as a synchronization point\n\t * for the above.\n\t *\n\t * We optimize to avoid numerous calls to hotkey_get_wlsw.\n\t */\n\n\twlsw = hotkey_get_wlsw();\n\n\t/* Sync hw blocking state first if it is hw-blocked */\n\tif (wlsw == TPACPI_RFK_RADIO_OFF)\n\t\ttpacpi_rfk_update_hwblock_state(true);\n\n\t/* Sync sw blocking state */\n\ttpacpi_rfk_update_swstate_all();\n\n\t/* Sync hw blocking state last if it is hw-unblocked */\n\tif (wlsw == TPACPI_RFK_RADIO_ON)\n\t\ttpacpi_rfk_update_hwblock_state(false);\n\n\t/* Issue rfkill input event for WLSW switch */\n\tif (!(wlsw < 0)) {\n\t\tmutex_lock(&tpacpi_inputdev_send_mutex);\n\n\t\tinput_report_switch(tpacpi_inputdev,\n\t\t\t\t    SW_RFKILL_ALL, (wlsw > 0));\n\t\tinput_sync(tpacpi_inputdev);\n\n\t\tmutex_unlock(&tpacpi_inputdev_send_mutex);\n\t}\n\n\t/*\n\t * this can be unconditional, as we will poll state again\n\t * if userspace uses the notify to read data\n\t */\n\thotkey_radio_sw_notify_change();\n}\n\nstatic void hotkey_exit(void)\n{\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\n\tmutex_lock(&hotkey_mutex);\n\thotkey_poll_stop_sync();\n\tmutex_unlock(&hotkey_mutex);\n#endif\n\n\tif (hotkey_dev_attributes)\n\t\tdelete_attr_set(hotkey_dev_attributes, &tpacpi_pdev->dev.kobj);\n\n\tdbg_printk(TPACPI_DBG_EXIT | TPACPI_DBG_HKEY,\n\t\t   \"restoring original HKEY status and mask\\n\");\n\t/* yes, there is a bitwise or below, we want the\n\t * functions to be called even if one of them fail */\n\tif (((tp_features.hotkey_mask &&\n\t      hotkey_mask_set(hotkey_orig_mask)) |\n\t     hotkey_status_set(false)) != 0)\n\t\tpr_err(\"failed to restore hot key mask to BIOS defaults\\n\");\n}\n\nstatic void __init hotkey_unmap(const unsigned int scancode)\n{\n\tif (hotkey_keycode_map[scancode] != KEY_RESERVED) {\n\t\tclear_bit(hotkey_keycode_map[scancode],\n\t\t\t  tpacpi_inputdev->keybit);\n\t\thotkey_keycode_map[scancode] = KEY_RESERVED;\n\t}\n}\n\n/*\n * HKEY quirks:\n *   TPACPI_HK_Q_INIMASK:\tSupports FN+F3,FN+F4,FN+F12\n */\n\n#define\tTPACPI_HK_Q_INIMASK\t0x0001\n\nstatic const struct tpacpi_quirk tpacpi_hotkey_qtable[] __initconst = {\n\tTPACPI_Q_IBM('I', 'H', TPACPI_HK_Q_INIMASK), /* 600E */\n\tTPACPI_Q_IBM('I', 'N', TPACPI_HK_Q_INIMASK), /* 600E */\n\tTPACPI_Q_IBM('I', 'D', TPACPI_HK_Q_INIMASK), /* 770, 770E, 770ED */\n\tTPACPI_Q_IBM('I', 'W', TPACPI_HK_Q_INIMASK), /* A20m */\n\tTPACPI_Q_IBM('I', 'V', TPACPI_HK_Q_INIMASK), /* A20p */\n\tTPACPI_Q_IBM('1', '0', TPACPI_HK_Q_INIMASK), /* A21e, A22e */\n\tTPACPI_Q_IBM('K', 'U', TPACPI_HK_Q_INIMASK), /* A21e */\n\tTPACPI_Q_IBM('K', 'X', TPACPI_HK_Q_INIMASK), /* A21m, A22m */\n\tTPACPI_Q_IBM('K', 'Y', TPACPI_HK_Q_INIMASK), /* A21p, A22p */\n\tTPACPI_Q_IBM('1', 'B', TPACPI_HK_Q_INIMASK), /* A22e */\n\tTPACPI_Q_IBM('1', '3', TPACPI_HK_Q_INIMASK), /* A22m */\n\tTPACPI_Q_IBM('1', 'E', TPACPI_HK_Q_INIMASK), /* A30/p (0) */\n\tTPACPI_Q_IBM('1', 'C', TPACPI_HK_Q_INIMASK), /* R30 */\n\tTPACPI_Q_IBM('1', 'F', TPACPI_HK_Q_INIMASK), /* R31 */\n\tTPACPI_Q_IBM('I', 'Y', TPACPI_HK_Q_INIMASK), /* T20 */\n\tTPACPI_Q_IBM('K', 'Z', TPACPI_HK_Q_INIMASK), /* T21 */\n\tTPACPI_Q_IBM('1', '6', TPACPI_HK_Q_INIMASK), /* T22 */\n\tTPACPI_Q_IBM('I', 'Z', TPACPI_HK_Q_INIMASK), /* X20, X21 */\n\tTPACPI_Q_IBM('1', 'D', TPACPI_HK_Q_INIMASK), /* X22, X23, X24 */\n};\n\ntypedef u16 tpacpi_keymap_entry_t;\ntypedef tpacpi_keymap_entry_t tpacpi_keymap_t[TPACPI_HOTKEY_MAP_LEN];\n\nstatic int hotkey_init_tablet_mode(void)\n{\n\tint in_tablet_mode = 0, res;\n\tchar *type = NULL;\n\n\tif (acpi_evalf(hkey_handle, &res, \"GMMS\", \"qdd\", 0)) {\n\t\tint has_tablet_mode;\n\n\t\tin_tablet_mode = hotkey_gmms_get_tablet_mode(res,\n\t\t\t\t\t\t\t     &has_tablet_mode);\n\t\t/*\n\t\t * The Yoga 11e series has 2 accelerometers described by a\n\t\t * BOSC0200 ACPI node. This setup relies on a Windows service\n\t\t * which calls special ACPI methods on this node to report\n\t\t * the laptop/tent/tablet mode to the EC. The bmc150 iio driver\n\t\t * does not support this, so skip the hotkey on these models.\n\t\t */\n\t\tif (has_tablet_mode && !acpi_dev_present(\"BOSC0200\", \"1\", -1))\n\t\t\ttp_features.hotkey_tablet = TP_HOTKEY_TABLET_USES_GMMS;\n\t\ttype = \"GMMS\";\n\t} else if (acpi_evalf(hkey_handle, &res, \"MHKG\", \"qd\")) {\n\t\t/* For X41t, X60t, X61t Tablets... */\n\t\ttp_features.hotkey_tablet = TP_HOTKEY_TABLET_USES_MHKG;\n\t\tin_tablet_mode = !!(res & TP_HOTKEY_TABLET_MASK);\n\t\ttype = \"MHKG\";\n\t}\n\n\tif (!tp_features.hotkey_tablet)\n\t\treturn 0;\n\n\tpr_info(\"Tablet mode switch found (type: %s), currently in %s mode\\n\",\n\t\ttype, in_tablet_mode ? \"tablet\" : \"laptop\");\n\n\tres = add_to_attr_set(hotkey_dev_attributes,\n\t\t\t      &dev_attr_hotkey_tablet_mode.attr);\n\tif (res)\n\t\treturn -1;\n\n\treturn in_tablet_mode;\n}\n\nstatic int __init hotkey_init(struct ibm_init_struct *iibm)\n{\n\t/* Requirements for changing the default keymaps:\n\t *\n\t * 1. Many of the keys are mapped to KEY_RESERVED for very\n\t *    good reasons.  Do not change them unless you have deep\n\t *    knowledge on the IBM and Lenovo ThinkPad firmware for\n\t *    the various ThinkPad models.  The driver behaves\n\t *    differently for KEY_RESERVED: such keys have their\n\t *    hot key mask *unset* in mask_recommended, and also\n\t *    in the initial hot key mask programmed into the\n\t *    firmware at driver load time, which means the firm-\n\t *    ware may react very differently if you change them to\n\t *    something else;\n\t *\n\t * 2. You must be subscribed to the linux-thinkpad and\n\t *    ibm-acpi-devel mailing lists, and you should read the\n\t *    list archives since 2007 if you want to change the\n\t *    keymaps.  This requirement exists so that you will\n\t *    know the past history of problems with the thinkpad-\n\t *    acpi driver keymaps, and also that you will be\n\t *    listening to any bug reports;\n\t *\n\t * 3. Do not send thinkpad-acpi specific patches directly to\n\t *    for merging, *ever*.  Send them to the linux-acpi\n\t *    mailinglist for comments.  Merging is to be done only\n\t *    through acpi-test and the ACPI maintainer.\n\t *\n\t * If the above is too much to ask, don't change the keymap.\n\t * Ask the thinkpad-acpi maintainer to do it, instead.\n\t */\n\n\tenum keymap_index {\n\t\tTPACPI_KEYMAP_IBM_GENERIC = 0,\n\t\tTPACPI_KEYMAP_LENOVO_GENERIC,\n\t};\n\n\tstatic const tpacpi_keymap_t tpacpi_keymaps[] __initconst = {\n\t/* Generic keymap for IBM ThinkPads */\n\t[TPACPI_KEYMAP_IBM_GENERIC] = {\n\t\t/* Scan Codes 0x00 to 0x0B: ACPI HKEY FN+F1..F12 */\n\t\tKEY_FN_F1,\tKEY_BATTERY,\tKEY_COFFEE,\tKEY_SLEEP,\n\t\tKEY_WLAN,\tKEY_FN_F6, KEY_SWITCHVIDEOMODE, KEY_FN_F8,\n\t\tKEY_FN_F9,\tKEY_FN_F10,\tKEY_FN_F11,\tKEY_SUSPEND,\n\n\t\t/* Scan codes 0x0C to 0x1F: Other ACPI HKEY hot keys */\n\t\tKEY_UNKNOWN,\t/* 0x0C: FN+BACKSPACE */\n\t\tKEY_UNKNOWN,\t/* 0x0D: FN+INSERT */\n\t\tKEY_UNKNOWN,\t/* 0x0E: FN+DELETE */\n\n\t\t/* brightness: firmware always reacts to them */\n\t\tKEY_RESERVED,\t/* 0x0F: FN+HOME (brightness up) */\n\t\tKEY_RESERVED,\t/* 0x10: FN+END (brightness down) */\n\n\t\t/* Thinklight: firmware always react to it */\n\t\tKEY_RESERVED,\t/* 0x11: FN+PGUP (thinklight toggle) */\n\n\t\tKEY_UNKNOWN,\t/* 0x12: FN+PGDOWN */\n\t\tKEY_ZOOM,\t/* 0x13: FN+SPACE (zoom) */\n\n\t\t/* Volume: firmware always react to it and reprograms\n\t\t * the built-in *extra* mixer.  Never map it to control\n\t\t * another mixer by default. */\n\t\tKEY_RESERVED,\t/* 0x14: VOLUME UP */\n\t\tKEY_RESERVED,\t/* 0x15: VOLUME DOWN */\n\t\tKEY_RESERVED,\t/* 0x16: MUTE */\n\n\t\tKEY_VENDOR,\t/* 0x17: Thinkpad/AccessIBM/Lenovo */\n\n\t\t/* (assignments unknown, please report if found) */\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\n\t\t/* No assignments, only used for Adaptive keyboards. */\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\n\t\t/* No assignment, used for newer Lenovo models */\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN\n\n\t\t},\n\n\t/* Generic keymap for Lenovo ThinkPads */\n\t[TPACPI_KEYMAP_LENOVO_GENERIC] = {\n\t\t/* Scan Codes 0x00 to 0x0B: ACPI HKEY FN+F1..F12 */\n\t\tKEY_FN_F1,\tKEY_COFFEE,\tKEY_BATTERY,\tKEY_SLEEP,\n\t\tKEY_WLAN,\tKEY_CAMERA, KEY_SWITCHVIDEOMODE, KEY_FN_F8,\n\t\tKEY_FN_F9,\tKEY_FN_F10,\tKEY_FN_F11,\tKEY_SUSPEND,\n\n\t\t/* Scan codes 0x0C to 0x1F: Other ACPI HKEY hot keys */\n\t\tKEY_UNKNOWN,\t/* 0x0C: FN+BACKSPACE */\n\t\tKEY_UNKNOWN,\t/* 0x0D: FN+INSERT */\n\t\tKEY_UNKNOWN,\t/* 0x0E: FN+DELETE */\n\n\t\t/* These should be enabled --only-- when ACPI video\n\t\t * is disabled (i.e. in \"vendor\" mode), and are handled\n\t\t * in a special way by the init code */\n\t\tKEY_BRIGHTNESSUP,\t/* 0x0F: FN+HOME (brightness up) */\n\t\tKEY_BRIGHTNESSDOWN,\t/* 0x10: FN+END (brightness down) */\n\n\t\tKEY_RESERVED,\t/* 0x11: FN+PGUP (thinklight toggle) */\n\n\t\tKEY_UNKNOWN,\t/* 0x12: FN+PGDOWN */\n\t\tKEY_ZOOM,\t/* 0x13: FN+SPACE (zoom) */\n\n\t\t/* Volume: z60/z61, T60 (BIOS version?): firmware always\n\t\t * react to it and reprograms the built-in *extra* mixer.\n\t\t * Never map it to control another mixer by default.\n\t\t *\n\t\t * T60?, T61, R60?, R61: firmware and EC tries to send\n\t\t * these over the regular keyboard, so these are no-ops,\n\t\t * but there are still weird bugs re. MUTE, so do not\n\t\t * change unless you get test reports from all Lenovo\n\t\t * models.  May cause the BIOS to interfere with the\n\t\t * HDA mixer.\n\t\t */\n\t\tKEY_RESERVED,\t/* 0x14: VOLUME UP */\n\t\tKEY_RESERVED,\t/* 0x15: VOLUME DOWN */\n\t\tKEY_RESERVED,\t/* 0x16: MUTE */\n\n\t\tKEY_VENDOR,\t/* 0x17: Thinkpad/AccessIBM/Lenovo */\n\n\t\t/* (assignments unknown, please report if found) */\n\t\tKEY_UNKNOWN, KEY_UNKNOWN,\n\n\t\t/*\n\t\t * The mic mute button only sends 0x1a.  It does not\n\t\t * automatically mute the mic or change the mute light.\n\t\t */\n\t\tKEY_MICMUTE,\t/* 0x1a: Mic mute (since ?400 or so) */\n\n\t\t/* (assignments unknown, please report if found) */\n\t\tKEY_UNKNOWN,\n\n\t\t/* Extra keys in use since the X240 / T440 / T540 */\n\t\tKEY_CONFIG, KEY_SEARCH, KEY_SCALE, KEY_FILE,\n\n\t\t/*\n\t\t * These are the adaptive keyboard keycodes for Carbon X1 2014.\n\t\t * The first item in this list is the Mute button which is\n\t\t * emitted with 0x103 through\n\t\t * adaptive_keyboard_hotkey_notify_hotkey() when the sound\n\t\t * symbol is held.\n\t\t * We'll need to offset those by 0x20.\n\t\t */\n\t\tKEY_RESERVED,        /* Mute held, 0x103 */\n\t\tKEY_BRIGHTNESS_MIN,  /* Backlight off */\n\t\tKEY_RESERVED,        /* Clipping tool */\n\t\tKEY_RESERVED,        /* Cloud */\n\t\tKEY_RESERVED,\n\t\tKEY_VOICECOMMAND,    /* Voice */\n\t\tKEY_RESERVED,\n\t\tKEY_RESERVED,        /* Gestures */\n\t\tKEY_RESERVED,\n\t\tKEY_RESERVED,\n\t\tKEY_RESERVED,\n\t\tKEY_CONFIG,          /* Settings */\n\t\tKEY_RESERVED,        /* New tab */\n\t\tKEY_REFRESH,         /* Reload */\n\t\tKEY_BACK,            /* Back */\n\t\tKEY_RESERVED,        /* Microphone down */\n\t\tKEY_RESERVED,        /* Microphone up */\n\t\tKEY_RESERVED,        /* Microphone cancellation */\n\t\tKEY_RESERVED,        /* Camera mode */\n\t\tKEY_RESERVED,        /* Rotate display, 0x116 */\n\n\t\t/*\n\t\t * These are found in 2017 models (e.g. T470s, X270).\n\t\t * The lowest known value is 0x311, which according to\n\t\t * the manual should launch a user defined favorite\n\t\t * application.\n\t\t *\n\t\t * The offset for these is TP_ACPI_HOTKEYSCAN_EXTENDED_START,\n\t\t * corresponding to 0x34.\n\t\t */\n\n\t\t/* (assignments unknown, please report if found) */\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,\n\t\tKEY_UNKNOWN,\n\n\t\tKEY_BOOKMARKS,\t\t\t/* Favorite app, 0x311 */\n\t\tKEY_SELECTIVE_SCREENSHOT,\t/* Clipping tool */\n\t\tKEY_CALC,\t\t\t/* Calculator (above numpad, P52) */\n\t\tKEY_BLUETOOTH,\t\t\t/* Bluetooth */\n\t\tKEY_KEYBOARD,\t\t\t/* Keyboard, 0x315 */\n\t\tKEY_FN_RIGHT_SHIFT,\t\t/* Fn + right Shift */\n\t\tKEY_NOTIFICATION_CENTER,\t/* Notification Center */\n\t\tKEY_PICKUP_PHONE,\t\t/* Answer incoming call */\n\t\tKEY_HANGUP_PHONE,\t\t/* Decline incoming call */\n\t\t},\n\t};\n\n\tstatic const struct tpacpi_quirk tpacpi_keymap_qtable[] __initconst = {\n\t\t/* Generic maps (fallback) */\n\t\t{\n\t\t  .vendor = PCI_VENDOR_ID_IBM,\n\t\t  .bios = TPACPI_MATCH_ANY, .ec = TPACPI_MATCH_ANY,\n\t\t  .quirks = TPACPI_KEYMAP_IBM_GENERIC,\n\t\t},\n\t\t{\n\t\t  .vendor = PCI_VENDOR_ID_LENOVO,\n\t\t  .bios = TPACPI_MATCH_ANY, .ec = TPACPI_MATCH_ANY,\n\t\t  .quirks = TPACPI_KEYMAP_LENOVO_GENERIC,\n\t\t},\n\t};\n\n#define TPACPI_HOTKEY_MAP_SIZE\t\tsizeof(tpacpi_keymap_t)\n#define TPACPI_HOTKEY_MAP_TYPESIZE\tsizeof(tpacpi_keymap_entry_t)\n\n\tint res, i;\n\tint status;\n\tint hkeyv;\n\tbool radiosw_state  = false;\n\tbool tabletsw_state = false;\n\n\tunsigned long quirks;\n\tunsigned long keymap_id;\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\n\t\t\t\"initializing hotkey subdriver\\n\");\n\n\tBUG_ON(!tpacpi_inputdev);\n\tBUG_ON(tpacpi_inputdev->open != NULL ||\n\t       tpacpi_inputdev->close != NULL);\n\n\tTPACPI_ACPIHANDLE_INIT(hkey);\n\tmutex_init(&hotkey_mutex);\n\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\n\tmutex_init(&hotkey_thread_data_mutex);\n#endif\n\n\t/* hotkey not supported on 570 */\n\ttp_features.hotkey = hkey_handle != NULL;\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\n\t\t\"hotkeys are %s\\n\",\n\t\tstr_supported(tp_features.hotkey));\n\n\tif (!tp_features.hotkey)\n\t\treturn 1;\n\n\tquirks = tpacpi_check_quirks(tpacpi_hotkey_qtable,\n\t\t\t\t     ARRAY_SIZE(tpacpi_hotkey_qtable));\n\n\ttpacpi_disable_brightness_delay();\n\n\t/* MUST have enough space for all attributes to be added to\n\t * hotkey_dev_attributes */\n\thotkey_dev_attributes = create_attr_set(\n\t\t\t\t\tARRAY_SIZE(hotkey_attributes) + 2,\n\t\t\t\t\tNULL);\n\tif (!hotkey_dev_attributes)\n\t\treturn -ENOMEM;\n\tres = add_many_to_attr_set(hotkey_dev_attributes,\n\t\t\thotkey_attributes,\n\t\t\tARRAY_SIZE(hotkey_attributes));\n\tif (res)\n\t\tgoto err_exit;\n\n\t/* mask not supported on 600e/x, 770e, 770x, A21e, A2xm/p,\n\t   A30, R30, R31, T20-22, X20-21, X22-24.  Detected by checking\n\t   for HKEY interface version 0x100 */\n\tif (acpi_evalf(hkey_handle, &hkeyv, \"MHKV\", \"qd\")) {\n\t\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\n\t\t\t    \"firmware HKEY interface version: 0x%x\\n\",\n\t\t\t    hkeyv);\n\n\t\tswitch (hkeyv >> 8) {\n\t\tcase 1:\n\t\t\t/*\n\t\t\t * MHKV 0x100 in A31, R40, R40e,\n\t\t\t * T4x, X31, and later\n\t\t\t */\n\n\t\t\t/* Paranoia check AND init hotkey_all_mask */\n\t\t\tif (!acpi_evalf(hkey_handle, &hotkey_all_mask,\n\t\t\t\t\t\"MHKA\", \"qd\")) {\n\t\t\t\tpr_err(\"missing MHKA handler, please report this to %s\\n\",\n\t\t\t\t       TPACPI_MAIL);\n\t\t\t\t/* Fallback: pre-init for FN+F3,F4,F12 */\n\t\t\t\thotkey_all_mask = 0x080cU;\n\t\t\t} else {\n\t\t\t\ttp_features.hotkey_mask = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t/*\n\t\t\t * MHKV 0x200 in X1, T460s, X260, T560, X1 Tablet (2016)\n\t\t\t */\n\n\t\t\t/* Paranoia check AND init hotkey_all_mask */\n\t\t\tif (!acpi_evalf(hkey_handle, &hotkey_all_mask,\n\t\t\t\t\t\"MHKA\", \"dd\", 1)) {\n\t\t\t\tpr_err(\"missing MHKA handler, please report this to %s\\n\",\n\t\t\t\t       TPACPI_MAIL);\n\t\t\t\t/* Fallback: pre-init for FN+F3,F4,F12 */\n\t\t\t\thotkey_all_mask = 0x080cU;\n\t\t\t} else {\n\t\t\t\ttp_features.hotkey_mask = 1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check if we have an adaptive keyboard, like on the\n\t\t\t * Lenovo Carbon X1 2014 (2nd Gen).\n\t\t\t */\n\t\t\tif (acpi_evalf(hkey_handle, &hotkey_adaptive_all_mask,\n\t\t\t\t       \"MHKA\", \"dd\", 2)) {\n\t\t\t\tif (hotkey_adaptive_all_mask != 0) {\n\t\t\t\t\ttp_features.has_adaptive_kbd = true;\n\t\t\t\t\tres = sysfs_create_group(\n\t\t\t\t\t\t&tpacpi_pdev->dev.kobj,\n\t\t\t\t\t\t&adaptive_kbd_attr_group);\n\t\t\t\t\tif (res)\n\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttp_features.has_adaptive_kbd = false;\n\t\t\t\thotkey_adaptive_all_mask = 0x0U;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"unknown version of the HKEY interface: 0x%x\\n\",\n\t\t\t       hkeyv);\n\t\t\tpr_err(\"please report this to %s\\n\", TPACPI_MAIL);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\n\t\t\"hotkey masks are %s\\n\",\n\t\tstr_supported(tp_features.hotkey_mask));\n\n\t/* Init hotkey_all_mask if not initialized yet */\n\tif (!tp_features.hotkey_mask && !hotkey_all_mask &&\n\t    (quirks & TPACPI_HK_Q_INIMASK))\n\t\thotkey_all_mask = 0x080cU;  /* FN+F12, FN+F4, FN+F3 */\n\n\t/* Init hotkey_acpi_mask and hotkey_orig_mask */\n\tif (tp_features.hotkey_mask) {\n\t\t/* hotkey_source_mask *must* be zero for\n\t\t * the first hotkey_mask_get to return hotkey_orig_mask */\n\t\tres = hotkey_mask_get();\n\t\tif (res)\n\t\t\tgoto err_exit;\n\n\t\thotkey_orig_mask = hotkey_acpi_mask;\n\t} else {\n\t\thotkey_orig_mask = hotkey_all_mask;\n\t\thotkey_acpi_mask = hotkey_all_mask;\n\t}\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_wlswemul) {\n\t\ttp_features.hotkey_wlsw = 1;\n\t\tradiosw_state = !!tpacpi_wlsw_emulstate;\n\t\tpr_info(\"radio switch emulation enabled\\n\");\n\t} else\n#endif\n\t/* Not all thinkpads have a hardware radio switch */\n\tif (acpi_evalf(hkey_handle, &status, \"WLSW\", \"qd\")) {\n\t\ttp_features.hotkey_wlsw = 1;\n\t\tradiosw_state = !!status;\n\t\tpr_info(\"radio switch found; radios are %s\\n\",\n\t\t\tenabled(status, 0));\n\t}\n\tif (tp_features.hotkey_wlsw)\n\t\tres = add_to_attr_set(hotkey_dev_attributes,\n\t\t\t\t&dev_attr_hotkey_radio_sw.attr);\n\n\tres = hotkey_init_tablet_mode();\n\tif (res < 0)\n\t\tgoto err_exit;\n\n\ttabletsw_state = res;\n\n\tres = register_attr_set_with_sysfs(hotkey_dev_attributes,\n\t\t\t\t\t   &tpacpi_pdev->dev.kobj);\n\tif (res)\n\t\tgoto err_exit;\n\n\t/* Set up key map */\n\tkeymap_id = tpacpi_check_quirks(tpacpi_keymap_qtable,\n\t\t\t\t\tARRAY_SIZE(tpacpi_keymap_qtable));\n\tBUG_ON(keymap_id >= ARRAY_SIZE(tpacpi_keymaps));\n\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\n\t\t   \"using keymap number %lu\\n\", keymap_id);\n\n\thotkey_keycode_map = kmemdup(&tpacpi_keymaps[keymap_id],\n\t\t\tTPACPI_HOTKEY_MAP_SIZE,\tGFP_KERNEL);\n\tif (!hotkey_keycode_map) {\n\t\tpr_err(\"failed to allocate memory for key map\\n\");\n\t\tres = -ENOMEM;\n\t\tgoto err_exit;\n\t}\n\n\tinput_set_capability(tpacpi_inputdev, EV_MSC, MSC_SCAN);\n\ttpacpi_inputdev->keycodesize = TPACPI_HOTKEY_MAP_TYPESIZE;\n\ttpacpi_inputdev->keycodemax = TPACPI_HOTKEY_MAP_LEN;\n\ttpacpi_inputdev->keycode = hotkey_keycode_map;\n\tfor (i = 0; i < TPACPI_HOTKEY_MAP_LEN; i++) {\n\t\tif (hotkey_keycode_map[i] != KEY_RESERVED) {\n\t\t\tinput_set_capability(tpacpi_inputdev, EV_KEY,\n\t\t\t\t\t\thotkey_keycode_map[i]);\n\t\t} else {\n\t\t\tif (i < sizeof(hotkey_reserved_mask)*8)\n\t\t\t\thotkey_reserved_mask |= 1 << i;\n\t\t}\n\t}\n\n\tif (tp_features.hotkey_wlsw) {\n\t\tinput_set_capability(tpacpi_inputdev, EV_SW, SW_RFKILL_ALL);\n\t\tinput_report_switch(tpacpi_inputdev,\n\t\t\t\t    SW_RFKILL_ALL, radiosw_state);\n\t}\n\tif (tp_features.hotkey_tablet) {\n\t\tinput_set_capability(tpacpi_inputdev, EV_SW, SW_TABLET_MODE);\n\t\tinput_report_switch(tpacpi_inputdev,\n\t\t\t\t    SW_TABLET_MODE, tabletsw_state);\n\t}\n\n\t/* Do not issue duplicate brightness change events to\n\t * userspace. tpacpi_detect_brightness_capabilities() must have\n\t * been called before this point  */\n\tif (acpi_video_get_backlight_type() != acpi_backlight_vendor) {\n\t\tpr_info(\"This ThinkPad has standard ACPI backlight brightness control, supported by the ACPI video driver\\n\");\n\t\tpr_notice(\"Disabling thinkpad-acpi brightness events by default...\\n\");\n\n\t\t/* Disable brightness up/down on Lenovo thinkpads when\n\t\t * ACPI is handling them, otherwise it is plain impossible\n\t\t * for userspace to do something even remotely sane */\n\t\thotkey_reserved_mask |=\n\t\t\t(1 << TP_ACPI_HOTKEYSCAN_FNHOME)\n\t\t\t| (1 << TP_ACPI_HOTKEYSCAN_FNEND);\n\t\thotkey_unmap(TP_ACPI_HOTKEYSCAN_FNHOME);\n\t\thotkey_unmap(TP_ACPI_HOTKEYSCAN_FNEND);\n\t}\n\n#ifdef CONFIG_THINKPAD_ACPI_HOTKEY_POLL\n\thotkey_source_mask = TPACPI_HKEY_NVRAM_GOOD_MASK\n\t\t\t\t& ~hotkey_all_mask\n\t\t\t\t& ~hotkey_reserved_mask;\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\n\t\t    \"hotkey source mask 0x%08x, polling freq %u\\n\",\n\t\t    hotkey_source_mask, hotkey_poll_freq);\n#endif\n\n\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\n\t\t\t\"enabling firmware HKEY event interface...\\n\");\n\tres = hotkey_status_set(true);\n\tif (res) {\n\t\thotkey_exit();\n\t\treturn res;\n\t}\n\tres = hotkey_mask_set(((hotkey_all_mask & ~hotkey_reserved_mask)\n\t\t\t       | hotkey_driver_mask)\n\t\t\t      & ~hotkey_source_mask);\n\tif (res < 0 && res != -ENXIO) {\n\t\thotkey_exit();\n\t\treturn res;\n\t}\n\thotkey_user_mask = (hotkey_acpi_mask | hotkey_source_mask)\n\t\t\t\t& ~hotkey_reserved_mask;\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_HKEY,\n\t\t\"initial masks: user=0x%08x, fw=0x%08x, poll=0x%08x\\n\",\n\t\thotkey_user_mask, hotkey_acpi_mask, hotkey_source_mask);\n\n\ttpacpi_inputdev->open = &hotkey_inputdev_open;\n\ttpacpi_inputdev->close = &hotkey_inputdev_close;\n\n\thotkey_poll_setup_safe(true);\n\n\treturn 0;\n\nerr_exit:\n\tdelete_attr_set(hotkey_dev_attributes, &tpacpi_pdev->dev.kobj);\n\tsysfs_remove_group(&tpacpi_pdev->dev.kobj,\n\t\t\t&adaptive_kbd_attr_group);\n\n\thotkey_dev_attributes = NULL;\n\n\treturn (res < 0) ? res : 1;\n}\n\n/* Thinkpad X1 Carbon support 5 modes including Home mode, Web browser\n * mode, Web conference mode, Function mode and Lay-flat mode.\n * We support Home mode and Function mode currently.\n *\n * Will consider support rest of modes in future.\n *\n */\nstatic const int adaptive_keyboard_modes[] = {\n\tHOME_MODE,\n/*\tWEB_BROWSER_MODE = 2,\n\tWEB_CONFERENCE_MODE = 3, */\n\tFUNCTION_MODE\n};\n\n#define DFR_CHANGE_ROW\t\t\t0x101\n#define DFR_SHOW_QUICKVIEW_ROW\t\t0x102\n#define FIRST_ADAPTIVE_KEY\t\t0x103\n\n/* press Fn key a while second, it will switch to Function Mode. Then\n * release Fn key, previous mode be restored.\n */\nstatic bool adaptive_keyboard_mode_is_saved;\nstatic int adaptive_keyboard_prev_mode;\n\nstatic int adaptive_keyboard_get_mode(void)\n{\n\tint mode = 0;\n\n\tif (!acpi_evalf(hkey_handle, &mode, \"GTRW\", \"dd\", 0)) {\n\t\tpr_err(\"Cannot read adaptive keyboard mode\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn mode;\n}\n\nstatic int adaptive_keyboard_set_mode(int new_mode)\n{\n\tif (new_mode < 0 ||\n\t\tnew_mode > LAYFLAT_MODE)\n\t\treturn -EINVAL;\n\n\tif (!acpi_evalf(hkey_handle, NULL, \"STRW\", \"vd\", new_mode)) {\n\t\tpr_err(\"Cannot set adaptive keyboard mode\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int adaptive_keyboard_get_next_mode(int mode)\n{\n\tsize_t i;\n\tsize_t max_mode = ARRAY_SIZE(adaptive_keyboard_modes) - 1;\n\n\tfor (i = 0; i <= max_mode; i++) {\n\t\tif (adaptive_keyboard_modes[i] == mode)\n\t\t\tbreak;\n\t}\n\n\tif (i >= max_mode)\n\t\ti = 0;\n\telse\n\t\ti++;\n\n\treturn adaptive_keyboard_modes[i];\n}\n\nstatic bool adaptive_keyboard_hotkey_notify_hotkey(unsigned int scancode)\n{\n\tint current_mode = 0;\n\tint new_mode = 0;\n\tint keycode;\n\n\tswitch (scancode) {\n\tcase DFR_CHANGE_ROW:\n\t\tif (adaptive_keyboard_mode_is_saved) {\n\t\t\tnew_mode = adaptive_keyboard_prev_mode;\n\t\t\tadaptive_keyboard_mode_is_saved = false;\n\t\t} else {\n\t\t\tcurrent_mode = adaptive_keyboard_get_mode();\n\t\t\tif (current_mode < 0)\n\t\t\t\treturn false;\n\t\t\tnew_mode = adaptive_keyboard_get_next_mode(\n\t\t\t\t\tcurrent_mode);\n\t\t}\n\n\t\tif (adaptive_keyboard_set_mode(new_mode) < 0)\n\t\t\treturn false;\n\n\t\treturn true;\n\n\tcase DFR_SHOW_QUICKVIEW_ROW:\n\t\tcurrent_mode = adaptive_keyboard_get_mode();\n\t\tif (current_mode < 0)\n\t\t\treturn false;\n\n\t\tadaptive_keyboard_prev_mode = current_mode;\n\t\tadaptive_keyboard_mode_is_saved = true;\n\n\t\tif (adaptive_keyboard_set_mode (FUNCTION_MODE) < 0)\n\t\t\treturn false;\n\t\treturn true;\n\n\tdefault:\n\t\tif (scancode < FIRST_ADAPTIVE_KEY ||\n\t\t    scancode >= FIRST_ADAPTIVE_KEY +\n\t\t    TP_ACPI_HOTKEYSCAN_EXTENDED_START -\n\t\t    TP_ACPI_HOTKEYSCAN_ADAPTIVE_START) {\n\t\t\tpr_info(\"Unhandled adaptive keyboard key: 0x%x\\n\",\n\t\t\t\tscancode);\n\t\t\treturn false;\n\t\t}\n\t\tkeycode = hotkey_keycode_map[scancode - FIRST_ADAPTIVE_KEY +\n\t\t\t\t\t     TP_ACPI_HOTKEYSCAN_ADAPTIVE_START];\n\t\tif (keycode != KEY_RESERVED) {\n\t\t\tmutex_lock(&tpacpi_inputdev_send_mutex);\n\n\t\t\tinput_report_key(tpacpi_inputdev, keycode, 1);\n\t\t\tinput_sync(tpacpi_inputdev);\n\n\t\t\tinput_report_key(tpacpi_inputdev, keycode, 0);\n\t\t\tinput_sync(tpacpi_inputdev);\n\n\t\t\tmutex_unlock(&tpacpi_inputdev_send_mutex);\n\t\t}\n\t\treturn true;\n\t}\n}\n\nstatic bool hotkey_notify_hotkey(const u32 hkey,\n\t\t\t\t bool *send_acpi_ev,\n\t\t\t\t bool *ignore_acpi_ev)\n{\n\t/* 0x1000-0x1FFF: key presses */\n\tunsigned int scancode = hkey & 0xfff;\n\t*send_acpi_ev = true;\n\t*ignore_acpi_ev = false;\n\n\t/*\n\t * Original events are in the 0x10XX range, the adaptive keyboard\n\t * found in 2014 X1 Carbon emits events are of 0x11XX. In 2017\n\t * models, additional keys are emitted through 0x13XX.\n\t */\n\tswitch ((hkey >> 8) & 0xf) {\n\tcase 0:\n\t\tif (scancode > 0 &&\n\t\t    scancode <= TP_ACPI_HOTKEYSCAN_ADAPTIVE_START) {\n\t\t\t/* HKEY event 0x1001 is scancode 0x00 */\n\t\t\tscancode--;\n\t\t\tif (!(hotkey_source_mask & (1 << scancode))) {\n\t\t\t\ttpacpi_input_send_key_masked(scancode);\n\t\t\t\t*send_acpi_ev = false;\n\t\t\t} else {\n\t\t\t\t*ignore_acpi_ev = true;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\n\tcase 1:\n\t\treturn adaptive_keyboard_hotkey_notify_hotkey(scancode);\n\n\tcase 3:\n\t\t/* Extended keycodes start at 0x300 and our offset into the map\n\t\t * TP_ACPI_HOTKEYSCAN_EXTENDED_START. The calculated scancode\n\t\t * will be positive, but might not be in the correct range.\n\t\t */\n\t\tscancode -= (0x300 - TP_ACPI_HOTKEYSCAN_EXTENDED_START);\n\t\tif (scancode >= TP_ACPI_HOTKEYSCAN_EXTENDED_START &&\n\t\t    scancode < TPACPI_HOTKEY_MAP_LEN) {\n\t\t\ttpacpi_input_send_key(scancode);\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic bool hotkey_notify_wakeup(const u32 hkey,\n\t\t\t\t bool *send_acpi_ev,\n\t\t\t\t bool *ignore_acpi_ev)\n{\n\t/* 0x2000-0x2FFF: Wakeup reason */\n\t*send_acpi_ev = true;\n\t*ignore_acpi_ev = false;\n\n\tswitch (hkey) {\n\tcase TP_HKEY_EV_WKUP_S3_UNDOCK: /* suspend, undock */\n\tcase TP_HKEY_EV_WKUP_S4_UNDOCK: /* hibernation, undock */\n\t\thotkey_wakeup_reason = TP_ACPI_WAKEUP_UNDOCK;\n\t\t*ignore_acpi_ev = true;\n\t\tbreak;\n\n\tcase TP_HKEY_EV_WKUP_S3_BAYEJ: /* suspend, bay eject */\n\tcase TP_HKEY_EV_WKUP_S4_BAYEJ: /* hibernation, bay eject */\n\t\thotkey_wakeup_reason = TP_ACPI_WAKEUP_BAYEJ;\n\t\t*ignore_acpi_ev = true;\n\t\tbreak;\n\n\tcase TP_HKEY_EV_WKUP_S3_BATLOW: /* Battery on critical low level/S3 */\n\tcase TP_HKEY_EV_WKUP_S4_BATLOW: /* Battery on critical low level/S4 */\n\t\tpr_alert(\"EMERGENCY WAKEUP: battery almost empty\\n\");\n\t\t/* how to auto-heal: */\n\t\t/* 2313: woke up from S3, go to S4/S5 */\n\t\t/* 2413: woke up from S4, go to S5 */\n\t\tbreak;\n\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (hotkey_wakeup_reason != TP_ACPI_WAKEUP_NONE) {\n\t\tpr_info(\"woke up due to a hot-unplug request...\\n\");\n\t\thotkey_wakeup_reason_notify_change();\n\t}\n\treturn true;\n}\n\nstatic bool hotkey_notify_dockevent(const u32 hkey,\n\t\t\t\t bool *send_acpi_ev,\n\t\t\t\t bool *ignore_acpi_ev)\n{\n\t/* 0x4000-0x4FFF: dock-related events */\n\t*send_acpi_ev = true;\n\t*ignore_acpi_ev = false;\n\n\tswitch (hkey) {\n\tcase TP_HKEY_EV_UNDOCK_ACK:\n\t\t/* ACPI undock operation completed after wakeup */\n\t\thotkey_autosleep_ack = 1;\n\t\tpr_info(\"undocked\\n\");\n\t\thotkey_wakeup_hotunplug_complete_notify_change();\n\t\treturn true;\n\n\tcase TP_HKEY_EV_HOTPLUG_DOCK: /* docked to port replicator */\n\t\tpr_info(\"docked into hotplug port replicator\\n\");\n\t\treturn true;\n\tcase TP_HKEY_EV_HOTPLUG_UNDOCK: /* undocked from port replicator */\n\t\tpr_info(\"undocked from hotplug port replicator\\n\");\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool hotkey_notify_usrevent(const u32 hkey,\n\t\t\t\t bool *send_acpi_ev,\n\t\t\t\t bool *ignore_acpi_ev)\n{\n\t/* 0x5000-0x5FFF: human interface helpers */\n\t*send_acpi_ev = true;\n\t*ignore_acpi_ev = false;\n\n\tswitch (hkey) {\n\tcase TP_HKEY_EV_PEN_INSERTED:  /* X61t: tablet pen inserted into bay */\n\tcase TP_HKEY_EV_PEN_REMOVED:   /* X61t: tablet pen removed from bay */\n\t\treturn true;\n\n\tcase TP_HKEY_EV_TABLET_TABLET:   /* X41t-X61t: tablet mode */\n\tcase TP_HKEY_EV_TABLET_NOTEBOOK: /* X41t-X61t: normal mode */\n\t\ttpacpi_input_send_tabletsw();\n\t\thotkey_tablet_mode_notify_change();\n\t\t*send_acpi_ev = false;\n\t\treturn true;\n\n\tcase TP_HKEY_EV_LID_CLOSE:\t/* Lid closed */\n\tcase TP_HKEY_EV_LID_OPEN:\t/* Lid opened */\n\tcase TP_HKEY_EV_BRGHT_CHANGED:\t/* brightness changed */\n\t\t/* do not propagate these events */\n\t\t*ignore_acpi_ev = true;\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void thermal_dump_all_sensors(void);\nstatic void palmsensor_refresh(void);\n\nstatic bool hotkey_notify_6xxx(const u32 hkey,\n\t\t\t\t bool *send_acpi_ev,\n\t\t\t\t bool *ignore_acpi_ev)\n{\n\t/* 0x6000-0x6FFF: thermal alarms/notices and keyboard events */\n\t*send_acpi_ev = true;\n\t*ignore_acpi_ev = false;\n\n\tswitch (hkey) {\n\tcase TP_HKEY_EV_THM_TABLE_CHANGED:\n\t\tpr_debug(\"EC reports: Thermal Table has changed\\n\");\n\t\t/* recommended action: do nothing, we don't have\n\t\t * Lenovo ATM information */\n\t\treturn true;\n\tcase TP_HKEY_EV_THM_CSM_COMPLETED:\n\t\tpr_debug(\"EC reports: Thermal Control Command set completed (DYTC)\\n\");\n\t\t/* Thermal event - pass on to event handler */\n\t\ttpacpi_driver_event(hkey);\n\t\treturn true;\n\tcase TP_HKEY_EV_THM_TRANSFM_CHANGED:\n\t\tpr_debug(\"EC reports: Thermal Transformation changed (GMTS)\\n\");\n\t\t/* recommended action: do nothing, we don't have\n\t\t * Lenovo ATM information */\n\t\treturn true;\n\tcase TP_HKEY_EV_ALARM_BAT_HOT:\n\t\tpr_crit(\"THERMAL ALARM: battery is too hot!\\n\");\n\t\t/* recommended action: warn user through gui */\n\t\tbreak;\n\tcase TP_HKEY_EV_ALARM_BAT_XHOT:\n\t\tpr_alert(\"THERMAL EMERGENCY: battery is extremely hot!\\n\");\n\t\t/* recommended action: immediate sleep/hibernate */\n\t\tbreak;\n\tcase TP_HKEY_EV_ALARM_SENSOR_HOT:\n\t\tpr_crit(\"THERMAL ALARM: a sensor reports something is too hot!\\n\");\n\t\t/* recommended action: warn user through gui, that */\n\t\t/* some internal component is too hot */\n\t\tbreak;\n\tcase TP_HKEY_EV_ALARM_SENSOR_XHOT:\n\t\tpr_alert(\"THERMAL EMERGENCY: a sensor reports something is extremely hot!\\n\");\n\t\t/* recommended action: immediate sleep/hibernate */\n\t\tbreak;\n\tcase TP_HKEY_EV_AC_CHANGED:\n\t\t/* X120e, X121e, X220, X220i, X220t, X230, T420, T420s, W520:\n\t\t * AC status changed; can be triggered by plugging or\n\t\t * unplugging AC adapter, docking or undocking. */\n\n\t\tfallthrough;\n\n\tcase TP_HKEY_EV_KEY_NUMLOCK:\n\tcase TP_HKEY_EV_KEY_FN:\n\tcase TP_HKEY_EV_KEY_FN_ESC:\n\t\t/* key press events, we just ignore them as long as the EC\n\t\t * is still reporting them in the normal keyboard stream */\n\t\t*send_acpi_ev = false;\n\t\t*ignore_acpi_ev = true;\n\t\treturn true;\n\n\tcase TP_HKEY_EV_TABLET_CHANGED:\n\t\ttpacpi_input_send_tabletsw();\n\t\thotkey_tablet_mode_notify_change();\n\t\t*send_acpi_ev = false;\n\t\treturn true;\n\n\tcase TP_HKEY_EV_PALM_DETECTED:\n\tcase TP_HKEY_EV_PALM_UNDETECTED:\n\t\t/* palm detected  - pass on to event handler */\n\t\tpalmsensor_refresh();\n\t\treturn true;\n\n\tdefault:\n\t\t/* report simply as unknown, no sensor dump */\n\t\treturn false;\n\t}\n\n\tthermal_dump_all_sensors();\n\treturn true;\n}\n\nstatic void hotkey_notify(struct ibm_struct *ibm, u32 event)\n{\n\tu32 hkey;\n\tbool send_acpi_ev;\n\tbool ignore_acpi_ev;\n\tbool known_ev;\n\n\tif (event != 0x80) {\n\t\tpr_err(\"unknown HKEY notification event %d\\n\", event);\n\t\t/* forward it to userspace, maybe it knows how to handle it */\n\t\tacpi_bus_generate_netlink_event(\n\t\t\t\t\tibm->acpi->device->pnp.device_class,\n\t\t\t\t\tdev_name(&ibm->acpi->device->dev),\n\t\t\t\t\tevent, 0);\n\t\treturn;\n\t}\n\n\twhile (1) {\n\t\tif (!acpi_evalf(hkey_handle, &hkey, \"MHKP\", \"d\")) {\n\t\t\tpr_err(\"failed to retrieve HKEY event\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (hkey == 0) {\n\t\t\t/* queue empty */\n\t\t\treturn;\n\t\t}\n\n\t\tsend_acpi_ev = true;\n\t\tignore_acpi_ev = false;\n\n\t\tswitch (hkey >> 12) {\n\t\tcase 1:\n\t\t\t/* 0x1000-0x1FFF: key presses */\n\t\t\tknown_ev = hotkey_notify_hotkey(hkey, &send_acpi_ev,\n\t\t\t\t\t\t &ignore_acpi_ev);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/* 0x2000-0x2FFF: Wakeup reason */\n\t\t\tknown_ev = hotkey_notify_wakeup(hkey, &send_acpi_ev,\n\t\t\t\t\t\t &ignore_acpi_ev);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t/* 0x3000-0x3FFF: bay-related wakeups */\n\t\t\tswitch (hkey) {\n\t\t\tcase TP_HKEY_EV_BAYEJ_ACK:\n\t\t\t\thotkey_autosleep_ack = 1;\n\t\t\t\tpr_info(\"bay ejected\\n\");\n\t\t\t\thotkey_wakeup_hotunplug_complete_notify_change();\n\t\t\t\tknown_ev = true;\n\t\t\t\tbreak;\n\t\t\tcase TP_HKEY_EV_OPTDRV_EJ:\n\t\t\t\t/* FIXME: kick libata if SATA link offline */\n\t\t\t\tknown_ev = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tknown_ev = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t/* 0x4000-0x4FFF: dock-related events */\n\t\t\tknown_ev = hotkey_notify_dockevent(hkey, &send_acpi_ev,\n\t\t\t\t\t\t&ignore_acpi_ev);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\t/* 0x5000-0x5FFF: human interface helpers */\n\t\t\tknown_ev = hotkey_notify_usrevent(hkey, &send_acpi_ev,\n\t\t\t\t\t\t &ignore_acpi_ev);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t/* 0x6000-0x6FFF: thermal alarms/notices and\n\t\t\t *                keyboard events */\n\t\t\tknown_ev = hotkey_notify_6xxx(hkey, &send_acpi_ev,\n\t\t\t\t\t\t &ignore_acpi_ev);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\t/* 0x7000-0x7FFF: misc */\n\t\t\tif (tp_features.hotkey_wlsw &&\n\t\t\t\t\thkey == TP_HKEY_EV_RFKILL_CHANGED) {\n\t\t\t\ttpacpi_send_radiosw_update();\n\t\t\t\tsend_acpi_ev = 0;\n\t\t\t\tknown_ev = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\t/* to default */\n\t\tdefault:\n\t\t\tknown_ev = false;\n\t\t}\n\t\tif (!known_ev) {\n\t\t\tpr_notice(\"unhandled HKEY event 0x%04x\\n\", hkey);\n\t\t\tpr_notice(\"please report the conditions when this event happened to %s\\n\",\n\t\t\t\t  TPACPI_MAIL);\n\t\t}\n\n\t\t/* netlink events */\n\t\tif (!ignore_acpi_ev && send_acpi_ev) {\n\t\t\tacpi_bus_generate_netlink_event(\n\t\t\t\t\tibm->acpi->device->pnp.device_class,\n\t\t\t\t\tdev_name(&ibm->acpi->device->dev),\n\t\t\t\t\tevent, hkey);\n\t\t}\n\t}\n}\n\nstatic void hotkey_suspend(void)\n{\n\t/* Do these on suspend, we get the events on early resume! */\n\thotkey_wakeup_reason = TP_ACPI_WAKEUP_NONE;\n\thotkey_autosleep_ack = 0;\n\n\t/* save previous mode of adaptive keyboard of X1 Carbon */\n\tif (tp_features.has_adaptive_kbd) {\n\t\tif (!acpi_evalf(hkey_handle, &adaptive_keyboard_prev_mode,\n\t\t\t\t\t\"GTRW\", \"dd\", 0)) {\n\t\t\tpr_err(\"Cannot read adaptive keyboard mode.\\n\");\n\t\t}\n\t}\n}\n\nstatic void hotkey_resume(void)\n{\n\ttpacpi_disable_brightness_delay();\n\n\tif (hotkey_status_set(true) < 0 ||\n\t    hotkey_mask_set(hotkey_acpi_mask) < 0)\n\t\tpr_err(\"error while attempting to reset the event firmware interface\\n\");\n\n\ttpacpi_send_radiosw_update();\n\ttpacpi_input_send_tabletsw();\n\thotkey_tablet_mode_notify_change();\n\thotkey_wakeup_reason_notify_change();\n\thotkey_wakeup_hotunplug_complete_notify_change();\n\thotkey_poll_setup_safe(false);\n\n\t/* restore previous mode of adapive keyboard of X1 Carbon */\n\tif (tp_features.has_adaptive_kbd) {\n\t\tif (!acpi_evalf(hkey_handle, NULL, \"STRW\", \"vd\",\n\t\t\t\t\tadaptive_keyboard_prev_mode)) {\n\t\t\tpr_err(\"Cannot set adaptive keyboard mode.\\n\");\n\t\t}\n\t}\n}\n\n/* procfs -------------------------------------------------------------- */\nstatic int hotkey_read(struct seq_file *m)\n{\n\tint res, status;\n\n\tif (!tp_features.hotkey) {\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\t\treturn 0;\n\t}\n\n\tif (mutex_lock_killable(&hotkey_mutex))\n\t\treturn -ERESTARTSYS;\n\tres = hotkey_status_get(&status);\n\tif (!res)\n\t\tres = hotkey_mask_get();\n\tmutex_unlock(&hotkey_mutex);\n\tif (res)\n\t\treturn res;\n\n\tseq_printf(m, \"status:\\t\\t%s\\n\", enabled(status, 0));\n\tif (hotkey_all_mask) {\n\t\tseq_printf(m, \"mask:\\t\\t0x%08x\\n\", hotkey_user_mask);\n\t\tseq_printf(m, \"commands:\\tenable, disable, reset, <mask>\\n\");\n\t} else {\n\t\tseq_printf(m, \"mask:\\t\\tnot supported\\n\");\n\t\tseq_printf(m, \"commands:\\tenable, disable, reset\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void hotkey_enabledisable_warn(bool enable)\n{\n\ttpacpi_log_usertask(\"procfs hotkey enable/disable\");\n\tif (!WARN((tpacpi_lifecycle == TPACPI_LIFE_RUNNING || !enable),\n\t\t  pr_fmt(\"hotkey enable/disable functionality has been removed from the driver.  Hotkeys are always enabled.\\n\")))\n\t\tpr_err(\"Please remove the hotkey=enable module parameter, it is deprecated.  Hotkeys are always enabled.\\n\");\n}\n\nstatic int hotkey_write(char *buf)\n{\n\tint res;\n\tu32 mask;\n\tchar *cmd;\n\n\tif (!tp_features.hotkey)\n\t\treturn -ENODEV;\n\n\tif (mutex_lock_killable(&hotkey_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tmask = hotkey_user_mask;\n\n\tres = 0;\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (strlencmp(cmd, \"enable\") == 0) {\n\t\t\thotkey_enabledisable_warn(1);\n\t\t} else if (strlencmp(cmd, \"disable\") == 0) {\n\t\t\thotkey_enabledisable_warn(0);\n\t\t\tres = -EPERM;\n\t\t} else if (strlencmp(cmd, \"reset\") == 0) {\n\t\t\tmask = (hotkey_all_mask | hotkey_source_mask)\n\t\t\t\t& ~hotkey_reserved_mask;\n\t\t} else if (sscanf(cmd, \"0x%x\", &mask) == 1) {\n\t\t\t/* mask set */\n\t\t} else if (sscanf(cmd, \"%x\", &mask) == 1) {\n\t\t\t/* mask set */\n\t\t} else {\n\t\t\tres = -EINVAL;\n\t\t\tgoto errexit;\n\t\t}\n\t}\n\n\tif (!res) {\n\t\ttpacpi_disclose_usertask(\"procfs hotkey\",\n\t\t\t\"set mask to 0x%08x\\n\", mask);\n\t\tres = hotkey_user_mask_set(mask);\n\t}\n\nerrexit:\n\tmutex_unlock(&hotkey_mutex);\n\treturn res;\n}\n\nstatic const struct acpi_device_id ibm_htk_device_ids[] = {\n\t{TPACPI_ACPI_IBM_HKEY_HID, 0},\n\t{TPACPI_ACPI_LENOVO_HKEY_HID, 0},\n\t{TPACPI_ACPI_LENOVO_HKEY_V2_HID, 0},\n\t{\"\", 0},\n};\n\nstatic struct tp_acpi_drv_struct ibm_hotkey_acpidriver = {\n\t.hid = ibm_htk_device_ids,\n\t.notify = hotkey_notify,\n\t.handle = &hkey_handle,\n\t.type = ACPI_DEVICE_NOTIFY,\n};\n\nstatic struct ibm_struct hotkey_driver_data = {\n\t.name = \"hotkey\",\n\t.read = hotkey_read,\n\t.write = hotkey_write,\n\t.exit = hotkey_exit,\n\t.resume = hotkey_resume,\n\t.suspend = hotkey_suspend,\n\t.acpi = &ibm_hotkey_acpidriver,\n};\n\n/*************************************************************************\n * Bluetooth subdriver\n */\n\nenum {\n\t/* ACPI GBDC/SBDC bits */\n\tTP_ACPI_BLUETOOTH_HWPRESENT\t= 0x01,\t/* Bluetooth hw available */\n\tTP_ACPI_BLUETOOTH_RADIOSSW\t= 0x02,\t/* Bluetooth radio enabled */\n\tTP_ACPI_BLUETOOTH_RESUMECTRL\t= 0x04,\t/* Bluetooth state at resume:\n\t\t\t\t\t\t   0 = disable, 1 = enable */\n};\n\nenum {\n\t/* ACPI \\BLTH commands */\n\tTP_ACPI_BLTH_GET_ULTRAPORT_ID\t= 0x00, /* Get Ultraport BT ID */\n\tTP_ACPI_BLTH_GET_PWR_ON_RESUME\t= 0x01, /* Get power-on-resume state */\n\tTP_ACPI_BLTH_PWR_ON_ON_RESUME\t= 0x02, /* Resume powered on */\n\tTP_ACPI_BLTH_PWR_OFF_ON_RESUME\t= 0x03,\t/* Resume powered off */\n\tTP_ACPI_BLTH_SAVE_STATE\t\t= 0x05, /* Save state for S4/S5 */\n};\n\n#define TPACPI_RFK_BLUETOOTH_SW_NAME\t\"tpacpi_bluetooth_sw\"\n\nstatic int bluetooth_get_status(void)\n{\n\tint status;\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_bluetoothemul)\n\t\treturn (tpacpi_bluetooth_emulstate) ?\n\t\t       TPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\n#endif\n\n\tif (!acpi_evalf(hkey_handle, &status, \"GBDC\", \"d\"))\n\t\treturn -EIO;\n\n\treturn ((status & TP_ACPI_BLUETOOTH_RADIOSSW) != 0) ?\n\t\t\tTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\n}\n\nstatic int bluetooth_set_status(enum tpacpi_rfkill_state state)\n{\n\tint status;\n\n\tvdbg_printk(TPACPI_DBG_RFKILL,\n\t\t\"will attempt to %s bluetooth\\n\",\n\t\t(state == TPACPI_RFK_RADIO_ON) ? \"enable\" : \"disable\");\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_bluetoothemul) {\n\t\ttpacpi_bluetooth_emulstate = (state == TPACPI_RFK_RADIO_ON);\n\t\treturn 0;\n\t}\n#endif\n\n\tif (state == TPACPI_RFK_RADIO_ON)\n\t\tstatus = TP_ACPI_BLUETOOTH_RADIOSSW\n\t\t\t  | TP_ACPI_BLUETOOTH_RESUMECTRL;\n\telse\n\t\tstatus = 0;\n\n\tif (!acpi_evalf(hkey_handle, NULL, \"SBDC\", \"vd\", status))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n/* sysfs bluetooth enable ---------------------------------------------- */\nstatic ssize_t bluetooth_enable_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn tpacpi_rfk_sysfs_enable_show(TPACPI_RFK_BLUETOOTH_SW_ID,\n\t\t\tattr, buf);\n}\n\nstatic ssize_t bluetooth_enable_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\treturn tpacpi_rfk_sysfs_enable_store(TPACPI_RFK_BLUETOOTH_SW_ID,\n\t\t\t\tattr, buf, count);\n}\n\nstatic DEVICE_ATTR_RW(bluetooth_enable);\n\n/* --------------------------------------------------------------------- */\n\nstatic struct attribute *bluetooth_attributes[] = {\n\t&dev_attr_bluetooth_enable.attr,\n\tNULL\n};\n\nstatic const struct attribute_group bluetooth_attr_group = {\n\t.attrs = bluetooth_attributes,\n};\n\nstatic const struct tpacpi_rfk_ops bluetooth_tprfk_ops = {\n\t.get_status = bluetooth_get_status,\n\t.set_status = bluetooth_set_status,\n};\n\nstatic void bluetooth_shutdown(void)\n{\n\t/* Order firmware to save current state to NVRAM */\n\tif (!acpi_evalf(NULL, NULL, \"\\\\BLTH\", \"vd\",\n\t\t\tTP_ACPI_BLTH_SAVE_STATE))\n\t\tpr_notice(\"failed to save bluetooth state to NVRAM\\n\");\n\telse\n\t\tvdbg_printk(TPACPI_DBG_RFKILL,\n\t\t\t\"bluetooth state saved to NVRAM\\n\");\n}\n\nstatic void bluetooth_exit(void)\n{\n\tsysfs_remove_group(&tpacpi_pdev->dev.kobj,\n\t\t\t&bluetooth_attr_group);\n\n\ttpacpi_destroy_rfkill(TPACPI_RFK_BLUETOOTH_SW_ID);\n\n\tbluetooth_shutdown();\n}\n\nstatic const struct dmi_system_id bt_fwbug_list[] __initconst = {\n\t{\n\t\t.ident = \"ThinkPad E485\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"20KU\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"ThinkPad E585\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"20KV\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"ThinkPad A285 - 20MW\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"20MW\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"ThinkPad A285 - 20MX\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"20MX\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"ThinkPad A485 - 20MU\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"20MU\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"ThinkPad A485 - 20MV\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"20MV\"),\n\t\t},\n\t},\n\t{}\n};\n\nstatic const struct pci_device_id fwbug_cards_ids[] __initconst = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x24F3) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x24FD) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x2526) },\n\t{}\n};\n\n\nstatic int __init have_bt_fwbug(void)\n{\n\t/*\n\t * Some AMD based ThinkPads have a firmware bug that calling\n\t * \"GBDC\" will cause bluetooth on Intel wireless cards blocked\n\t */\n\tif (dmi_check_system(bt_fwbug_list) && pci_dev_present(fwbug_cards_ids)) {\n\t\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\tFW_BUG \"disable bluetooth subdriver for Intel cards\\n\");\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}\n\nstatic int __init bluetooth_init(struct ibm_init_struct *iibm)\n{\n\tint res;\n\tint status = 0;\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\t\"initializing bluetooth subdriver\\n\");\n\n\tTPACPI_ACPIHANDLE_INIT(hkey);\n\n\t/* bluetooth not supported on 570, 600e/x, 770e, 770x, A21e, A2xm/p,\n\t   G4x, R30, R31, R40e, R50e, T20-22, X20-21 */\n\ttp_features.bluetooth = !have_bt_fwbug() && hkey_handle &&\n\t    acpi_evalf(hkey_handle, &status, \"GBDC\", \"qd\");\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\"bluetooth is %s, status 0x%02x\\n\",\n\t\tstr_supported(tp_features.bluetooth),\n\t\tstatus);\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_bluetoothemul) {\n\t\ttp_features.bluetooth = 1;\n\t\tpr_info(\"bluetooth switch emulation enabled\\n\");\n\t} else\n#endif\n\tif (tp_features.bluetooth &&\n\t    !(status & TP_ACPI_BLUETOOTH_HWPRESENT)) {\n\t\t/* no bluetooth hardware present in system */\n\t\ttp_features.bluetooth = 0;\n\t\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\t   \"bluetooth hardware not installed\\n\");\n\t}\n\n\tif (!tp_features.bluetooth)\n\t\treturn 1;\n\n\tres = tpacpi_new_rfkill(TPACPI_RFK_BLUETOOTH_SW_ID,\n\t\t\t\t&bluetooth_tprfk_ops,\n\t\t\t\tRFKILL_TYPE_BLUETOOTH,\n\t\t\t\tTPACPI_RFK_BLUETOOTH_SW_NAME,\n\t\t\t\ttrue);\n\tif (res)\n\t\treturn res;\n\n\tres = sysfs_create_group(&tpacpi_pdev->dev.kobj,\n\t\t\t\t&bluetooth_attr_group);\n\tif (res) {\n\t\ttpacpi_destroy_rfkill(TPACPI_RFK_BLUETOOTH_SW_ID);\n\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\n/* procfs -------------------------------------------------------------- */\nstatic int bluetooth_read(struct seq_file *m)\n{\n\treturn tpacpi_rfk_procfs_read(TPACPI_RFK_BLUETOOTH_SW_ID, m);\n}\n\nstatic int bluetooth_write(char *buf)\n{\n\treturn tpacpi_rfk_procfs_write(TPACPI_RFK_BLUETOOTH_SW_ID, buf);\n}\n\nstatic struct ibm_struct bluetooth_driver_data = {\n\t.name = \"bluetooth\",\n\t.read = bluetooth_read,\n\t.write = bluetooth_write,\n\t.exit = bluetooth_exit,\n\t.shutdown = bluetooth_shutdown,\n};\n\n/*************************************************************************\n * Wan subdriver\n */\n\nenum {\n\t/* ACPI GWAN/SWAN bits */\n\tTP_ACPI_WANCARD_HWPRESENT\t= 0x01,\t/* Wan hw available */\n\tTP_ACPI_WANCARD_RADIOSSW\t= 0x02,\t/* Wan radio enabled */\n\tTP_ACPI_WANCARD_RESUMECTRL\t= 0x04,\t/* Wan state at resume:\n\t\t\t\t\t\t   0 = disable, 1 = enable */\n};\n\n#define TPACPI_RFK_WWAN_SW_NAME\t\t\"tpacpi_wwan_sw\"\n\nstatic int wan_get_status(void)\n{\n\tint status;\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_wwanemul)\n\t\treturn (tpacpi_wwan_emulstate) ?\n\t\t       TPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\n#endif\n\n\tif (!acpi_evalf(hkey_handle, &status, \"GWAN\", \"d\"))\n\t\treturn -EIO;\n\n\treturn ((status & TP_ACPI_WANCARD_RADIOSSW) != 0) ?\n\t\t\tTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\n}\n\nstatic int wan_set_status(enum tpacpi_rfkill_state state)\n{\n\tint status;\n\n\tvdbg_printk(TPACPI_DBG_RFKILL,\n\t\t\"will attempt to %s wwan\\n\",\n\t\t(state == TPACPI_RFK_RADIO_ON) ? \"enable\" : \"disable\");\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_wwanemul) {\n\t\ttpacpi_wwan_emulstate = (state == TPACPI_RFK_RADIO_ON);\n\t\treturn 0;\n\t}\n#endif\n\n\tif (state == TPACPI_RFK_RADIO_ON)\n\t\tstatus = TP_ACPI_WANCARD_RADIOSSW\n\t\t\t | TP_ACPI_WANCARD_RESUMECTRL;\n\telse\n\t\tstatus = 0;\n\n\tif (!acpi_evalf(hkey_handle, NULL, \"SWAN\", \"vd\", status))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n/* sysfs wan enable ---------------------------------------------------- */\nstatic ssize_t wan_enable_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn tpacpi_rfk_sysfs_enable_show(TPACPI_RFK_WWAN_SW_ID,\n\t\t\tattr, buf);\n}\n\nstatic ssize_t wan_enable_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\treturn tpacpi_rfk_sysfs_enable_store(TPACPI_RFK_WWAN_SW_ID,\n\t\t\tattr, buf, count);\n}\n\nstatic DEVICE_ATTR(wwan_enable, S_IWUSR | S_IRUGO,\n\t\t   wan_enable_show, wan_enable_store);\n\n/* --------------------------------------------------------------------- */\n\nstatic struct attribute *wan_attributes[] = {\n\t&dev_attr_wwan_enable.attr,\n\tNULL\n};\n\nstatic const struct attribute_group wan_attr_group = {\n\t.attrs = wan_attributes,\n};\n\nstatic const struct tpacpi_rfk_ops wan_tprfk_ops = {\n\t.get_status = wan_get_status,\n\t.set_status = wan_set_status,\n};\n\nstatic void wan_shutdown(void)\n{\n\t/* Order firmware to save current state to NVRAM */\n\tif (!acpi_evalf(NULL, NULL, \"\\\\WGSV\", \"vd\",\n\t\t\tTP_ACPI_WGSV_SAVE_STATE))\n\t\tpr_notice(\"failed to save WWAN state to NVRAM\\n\");\n\telse\n\t\tvdbg_printk(TPACPI_DBG_RFKILL,\n\t\t\t\"WWAN state saved to NVRAM\\n\");\n}\n\nstatic void wan_exit(void)\n{\n\tsysfs_remove_group(&tpacpi_pdev->dev.kobj,\n\t\t&wan_attr_group);\n\n\ttpacpi_destroy_rfkill(TPACPI_RFK_WWAN_SW_ID);\n\n\twan_shutdown();\n}\n\nstatic int __init wan_init(struct ibm_init_struct *iibm)\n{\n\tint res;\n\tint status = 0;\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\t\"initializing wan subdriver\\n\");\n\n\tTPACPI_ACPIHANDLE_INIT(hkey);\n\n\ttp_features.wan = hkey_handle &&\n\t    acpi_evalf(hkey_handle, &status, \"GWAN\", \"qd\");\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\"wan is %s, status 0x%02x\\n\",\n\t\tstr_supported(tp_features.wan),\n\t\tstatus);\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_wwanemul) {\n\t\ttp_features.wan = 1;\n\t\tpr_info(\"wwan switch emulation enabled\\n\");\n\t} else\n#endif\n\tif (tp_features.wan &&\n\t    !(status & TP_ACPI_WANCARD_HWPRESENT)) {\n\t\t/* no wan hardware present in system */\n\t\ttp_features.wan = 0;\n\t\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\t   \"wan hardware not installed\\n\");\n\t}\n\n\tif (!tp_features.wan)\n\t\treturn 1;\n\n\tres = tpacpi_new_rfkill(TPACPI_RFK_WWAN_SW_ID,\n\t\t\t\t&wan_tprfk_ops,\n\t\t\t\tRFKILL_TYPE_WWAN,\n\t\t\t\tTPACPI_RFK_WWAN_SW_NAME,\n\t\t\t\ttrue);\n\tif (res)\n\t\treturn res;\n\n\tres = sysfs_create_group(&tpacpi_pdev->dev.kobj,\n\t\t\t\t&wan_attr_group);\n\n\tif (res) {\n\t\ttpacpi_destroy_rfkill(TPACPI_RFK_WWAN_SW_ID);\n\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\n/* procfs -------------------------------------------------------------- */\nstatic int wan_read(struct seq_file *m)\n{\n\treturn tpacpi_rfk_procfs_read(TPACPI_RFK_WWAN_SW_ID, m);\n}\n\nstatic int wan_write(char *buf)\n{\n\treturn tpacpi_rfk_procfs_write(TPACPI_RFK_WWAN_SW_ID, buf);\n}\n\nstatic struct ibm_struct wan_driver_data = {\n\t.name = \"wan\",\n\t.read = wan_read,\n\t.write = wan_write,\n\t.exit = wan_exit,\n\t.shutdown = wan_shutdown,\n};\n\n/*************************************************************************\n * UWB subdriver\n */\n\nenum {\n\t/* ACPI GUWB/SUWB bits */\n\tTP_ACPI_UWB_HWPRESENT\t= 0x01,\t/* UWB hw available */\n\tTP_ACPI_UWB_RADIOSSW\t= 0x02,\t/* UWB radio enabled */\n};\n\n#define TPACPI_RFK_UWB_SW_NAME\t\"tpacpi_uwb_sw\"\n\nstatic int uwb_get_status(void)\n{\n\tint status;\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_uwbemul)\n\t\treturn (tpacpi_uwb_emulstate) ?\n\t\t       TPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\n#endif\n\n\tif (!acpi_evalf(hkey_handle, &status, \"GUWB\", \"d\"))\n\t\treturn -EIO;\n\n\treturn ((status & TP_ACPI_UWB_RADIOSSW) != 0) ?\n\t\t\tTPACPI_RFK_RADIO_ON : TPACPI_RFK_RADIO_OFF;\n}\n\nstatic int uwb_set_status(enum tpacpi_rfkill_state state)\n{\n\tint status;\n\n\tvdbg_printk(TPACPI_DBG_RFKILL,\n\t\t\"will attempt to %s UWB\\n\",\n\t\t(state == TPACPI_RFK_RADIO_ON) ? \"enable\" : \"disable\");\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_uwbemul) {\n\t\ttpacpi_uwb_emulstate = (state == TPACPI_RFK_RADIO_ON);\n\t\treturn 0;\n\t}\n#endif\n\n\tif (state == TPACPI_RFK_RADIO_ON)\n\t\tstatus = TP_ACPI_UWB_RADIOSSW;\n\telse\n\t\tstatus = 0;\n\n\tif (!acpi_evalf(hkey_handle, NULL, \"SUWB\", \"vd\", status))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n/* --------------------------------------------------------------------- */\n\nstatic const struct tpacpi_rfk_ops uwb_tprfk_ops = {\n\t.get_status = uwb_get_status,\n\t.set_status = uwb_set_status,\n};\n\nstatic void uwb_exit(void)\n{\n\ttpacpi_destroy_rfkill(TPACPI_RFK_UWB_SW_ID);\n}\n\nstatic int __init uwb_init(struct ibm_init_struct *iibm)\n{\n\tint res;\n\tint status = 0;\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\t\"initializing uwb subdriver\\n\");\n\n\tTPACPI_ACPIHANDLE_INIT(hkey);\n\n\ttp_features.uwb = hkey_handle &&\n\t    acpi_evalf(hkey_handle, &status, \"GUWB\", \"qd\");\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_RFKILL,\n\t\t\"uwb is %s, status 0x%02x\\n\",\n\t\tstr_supported(tp_features.uwb),\n\t\tstatus);\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\n\tif (dbg_uwbemul) {\n\t\ttp_features.uwb = 1;\n\t\tpr_info(\"uwb switch emulation enabled\\n\");\n\t} else\n#endif\n\tif (tp_features.uwb &&\n\t    !(status & TP_ACPI_UWB_HWPRESENT)) {\n\t\t/* no uwb hardware present in system */\n\t\ttp_features.uwb = 0;\n\t\tdbg_printk(TPACPI_DBG_INIT,\n\t\t\t   \"uwb hardware not installed\\n\");\n\t}\n\n\tif (!tp_features.uwb)\n\t\treturn 1;\n\n\tres = tpacpi_new_rfkill(TPACPI_RFK_UWB_SW_ID,\n\t\t\t\t&uwb_tprfk_ops,\n\t\t\t\tRFKILL_TYPE_UWB,\n\t\t\t\tTPACPI_RFK_UWB_SW_NAME,\n\t\t\t\tfalse);\n\treturn res;\n}\n\nstatic struct ibm_struct uwb_driver_data = {\n\t.name = \"uwb\",\n\t.exit = uwb_exit,\n\t.flags.experimental = 1,\n};\n\n/*************************************************************************\n * Video subdriver\n */\n\n#ifdef CONFIG_THINKPAD_ACPI_VIDEO\n\nenum video_access_mode {\n\tTPACPI_VIDEO_NONE = 0,\n\tTPACPI_VIDEO_570,\t/* 570 */\n\tTPACPI_VIDEO_770,\t/* 600e/x, 770e, 770x */\n\tTPACPI_VIDEO_NEW,\t/* all others */\n};\n\nenum {\t/* video status flags, based on VIDEO_570 */\n\tTP_ACPI_VIDEO_S_LCD = 0x01,\t/* LCD output enabled */\n\tTP_ACPI_VIDEO_S_CRT = 0x02,\t/* CRT output enabled */\n\tTP_ACPI_VIDEO_S_DVI = 0x08,\t/* DVI output enabled */\n};\n\nenum {  /* TPACPI_VIDEO_570 constants */\n\tTP_ACPI_VIDEO_570_PHSCMD = 0x87,\t/* unknown magic constant :( */\n\tTP_ACPI_VIDEO_570_PHSMASK = 0x03,\t/* PHS bits that map to\n\t\t\t\t\t\t * video_status_flags */\n\tTP_ACPI_VIDEO_570_PHS2CMD = 0x8b,\t/* unknown magic constant :( */\n\tTP_ACPI_VIDEO_570_PHS2SET = 0x80,\t/* unknown magic constant :( */\n};\n\nstatic enum video_access_mode video_supported;\nstatic int video_orig_autosw;\n\nstatic int video_autosw_get(void);\nstatic int video_autosw_set(int enable);\n\nTPACPI_HANDLE(vid, root,\n\t      \"\\\\_SB.PCI.AGP.VGA\",\t/* 570 */\n\t      \"\\\\_SB.PCI0.AGP0.VID0\",\t/* 600e/x, 770x */\n\t      \"\\\\_SB.PCI0.VID0\",\t/* 770e */\n\t      \"\\\\_SB.PCI0.VID\",\t\t/* A21e, G4x, R50e, X30, X40 */\n\t      \"\\\\_SB.PCI0.AGP.VGA\",\t/* X100e and a few others */\n\t      \"\\\\_SB.PCI0.AGP.VID\",\t/* all others */\n\t);\t\t\t\t/* R30, R31 */\n\nTPACPI_HANDLE(vid2, root, \"\\\\_SB.PCI0.AGPB.VID\");\t/* G41 */\n\nstatic int __init video_init(struct ibm_init_struct *iibm)\n{\n\tint ivga;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"initializing video subdriver\\n\");\n\n\tTPACPI_ACPIHANDLE_INIT(vid);\n\tif (tpacpi_is_ibm())\n\t\tTPACPI_ACPIHANDLE_INIT(vid2);\n\n\tif (vid2_handle && acpi_evalf(NULL, &ivga, \"\\\\IVGA\", \"d\") && ivga)\n\t\t/* G41, assume IVGA doesn't change */\n\t\tvid_handle = vid2_handle;\n\n\tif (!vid_handle)\n\t\t/* video switching not supported on R30, R31 */\n\t\tvideo_supported = TPACPI_VIDEO_NONE;\n\telse if (tpacpi_is_ibm() &&\n\t\t acpi_evalf(vid_handle, &video_orig_autosw, \"SWIT\", \"qd\"))\n\t\t/* 570 */\n\t\tvideo_supported = TPACPI_VIDEO_570;\n\telse if (tpacpi_is_ibm() &&\n\t\t acpi_evalf(vid_handle, &video_orig_autosw, \"^VADL\", \"qd\"))\n\t\t/* 600e/x, 770e, 770x */\n\t\tvideo_supported = TPACPI_VIDEO_770;\n\telse\n\t\t/* all others */\n\t\tvideo_supported = TPACPI_VIDEO_NEW;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"video is %s, mode %d\\n\",\n\t\tstr_supported(video_supported != TPACPI_VIDEO_NONE),\n\t\tvideo_supported);\n\n\treturn (video_supported != TPACPI_VIDEO_NONE) ? 0 : 1;\n}\n\nstatic void video_exit(void)\n{\n\tdbg_printk(TPACPI_DBG_EXIT,\n\t\t   \"restoring original video autoswitch mode\\n\");\n\tif (video_autosw_set(video_orig_autosw))\n\t\tpr_err(\"error while trying to restore original video autoswitch mode\\n\");\n}\n\nstatic int video_outputsw_get(void)\n{\n\tint status = 0;\n\tint i;\n\n\tswitch (video_supported) {\n\tcase TPACPI_VIDEO_570:\n\t\tif (!acpi_evalf(NULL, &i, \"\\\\_SB.PHS\", \"dd\",\n\t\t\t\t TP_ACPI_VIDEO_570_PHSCMD))\n\t\t\treturn -EIO;\n\t\tstatus = i & TP_ACPI_VIDEO_570_PHSMASK;\n\t\tbreak;\n\tcase TPACPI_VIDEO_770:\n\t\tif (!acpi_evalf(NULL, &i, \"\\\\VCDL\", \"d\"))\n\t\t\treturn -EIO;\n\t\tif (i)\n\t\t\tstatus |= TP_ACPI_VIDEO_S_LCD;\n\t\tif (!acpi_evalf(NULL, &i, \"\\\\VCDC\", \"d\"))\n\t\t\treturn -EIO;\n\t\tif (i)\n\t\t\tstatus |= TP_ACPI_VIDEO_S_CRT;\n\t\tbreak;\n\tcase TPACPI_VIDEO_NEW:\n\t\tif (!acpi_evalf(NULL, NULL, \"\\\\VUPS\", \"vd\", 1) ||\n\t\t    !acpi_evalf(NULL, &i, \"\\\\VCDC\", \"d\"))\n\t\t\treturn -EIO;\n\t\tif (i)\n\t\t\tstatus |= TP_ACPI_VIDEO_S_CRT;\n\n\t\tif (!acpi_evalf(NULL, NULL, \"\\\\VUPS\", \"vd\", 0) ||\n\t\t    !acpi_evalf(NULL, &i, \"\\\\VCDL\", \"d\"))\n\t\t\treturn -EIO;\n\t\tif (i)\n\t\t\tstatus |= TP_ACPI_VIDEO_S_LCD;\n\t\tif (!acpi_evalf(NULL, &i, \"\\\\VCDD\", \"d\"))\n\t\t\treturn -EIO;\n\t\tif (i)\n\t\t\tstatus |= TP_ACPI_VIDEO_S_DVI;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn status;\n}\n\nstatic int video_outputsw_set(int status)\n{\n\tint autosw;\n\tint res = 0;\n\n\tswitch (video_supported) {\n\tcase TPACPI_VIDEO_570:\n\t\tres = acpi_evalf(NULL, NULL,\n\t\t\t\t \"\\\\_SB.PHS2\", \"vdd\",\n\t\t\t\t TP_ACPI_VIDEO_570_PHS2CMD,\n\t\t\t\t status | TP_ACPI_VIDEO_570_PHS2SET);\n\t\tbreak;\n\tcase TPACPI_VIDEO_770:\n\t\tautosw = video_autosw_get();\n\t\tif (autosw < 0)\n\t\t\treturn autosw;\n\n\t\tres = video_autosw_set(1);\n\t\tif (res)\n\t\t\treturn res;\n\t\tres = acpi_evalf(vid_handle, NULL,\n\t\t\t\t \"ASWT\", \"vdd\", status * 0x100, 0);\n\t\tif (!autosw && video_autosw_set(autosw)) {\n\t\t\tpr_err(\"video auto-switch left enabled due to error\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\tcase TPACPI_VIDEO_NEW:\n\t\tres = acpi_evalf(NULL, NULL, \"\\\\VUPS\", \"vd\", 0x80) &&\n\t\t      acpi_evalf(NULL, NULL, \"\\\\VSDS\", \"vdd\", status, 1);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn (res) ? 0 : -EIO;\n}\n\nstatic int video_autosw_get(void)\n{\n\tint autosw = 0;\n\n\tswitch (video_supported) {\n\tcase TPACPI_VIDEO_570:\n\t\tif (!acpi_evalf(vid_handle, &autosw, \"SWIT\", \"d\"))\n\t\t\treturn -EIO;\n\t\tbreak;\n\tcase TPACPI_VIDEO_770:\n\tcase TPACPI_VIDEO_NEW:\n\t\tif (!acpi_evalf(vid_handle, &autosw, \"^VDEE\", \"d\"))\n\t\t\treturn -EIO;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn autosw & 1;\n}\n\nstatic int video_autosw_set(int enable)\n{\n\tif (!acpi_evalf(vid_handle, NULL, \"_DOS\", \"vd\", (enable) ? 1 : 0))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int video_outputsw_cycle(void)\n{\n\tint autosw = video_autosw_get();\n\tint res;\n\n\tif (autosw < 0)\n\t\treturn autosw;\n\n\tswitch (video_supported) {\n\tcase TPACPI_VIDEO_570:\n\t\tres = video_autosw_set(1);\n\t\tif (res)\n\t\t\treturn res;\n\t\tres = acpi_evalf(ec_handle, NULL, \"_Q16\", \"v\");\n\t\tbreak;\n\tcase TPACPI_VIDEO_770:\n\tcase TPACPI_VIDEO_NEW:\n\t\tres = video_autosw_set(1);\n\t\tif (res)\n\t\t\treturn res;\n\t\tres = acpi_evalf(vid_handle, NULL, \"VSWT\", \"v\");\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\tif (!autosw && video_autosw_set(autosw)) {\n\t\tpr_err(\"video auto-switch left enabled due to error\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn (res) ? 0 : -EIO;\n}\n\nstatic int video_expand_toggle(void)\n{\n\tswitch (video_supported) {\n\tcase TPACPI_VIDEO_570:\n\t\treturn acpi_evalf(ec_handle, NULL, \"_Q17\", \"v\") ?\n\t\t\t0 : -EIO;\n\tcase TPACPI_VIDEO_770:\n\t\treturn acpi_evalf(vid_handle, NULL, \"VEXP\", \"v\") ?\n\t\t\t0 : -EIO;\n\tcase TPACPI_VIDEO_NEW:\n\t\treturn acpi_evalf(NULL, NULL, \"\\\\VEXP\", \"v\") ?\n\t\t\t0 : -EIO;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\t/* not reached */\n}\n\nstatic int video_read(struct seq_file *m)\n{\n\tint status, autosw;\n\n\tif (video_supported == TPACPI_VIDEO_NONE) {\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\t\treturn 0;\n\t}\n\n\t/* Even reads can crash X.org, so... */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tstatus = video_outputsw_get();\n\tif (status < 0)\n\t\treturn status;\n\n\tautosw = video_autosw_get();\n\tif (autosw < 0)\n\t\treturn autosw;\n\n\tseq_printf(m, \"status:\\t\\tsupported\\n\");\n\tseq_printf(m, \"lcd:\\t\\t%s\\n\", enabled(status, 0));\n\tseq_printf(m, \"crt:\\t\\t%s\\n\", enabled(status, 1));\n\tif (video_supported == TPACPI_VIDEO_NEW)\n\t\tseq_printf(m, \"dvi:\\t\\t%s\\n\", enabled(status, 3));\n\tseq_printf(m, \"auto:\\t\\t%s\\n\", enabled(autosw, 0));\n\tseq_printf(m, \"commands:\\tlcd_enable, lcd_disable\\n\");\n\tseq_printf(m, \"commands:\\tcrt_enable, crt_disable\\n\");\n\tif (video_supported == TPACPI_VIDEO_NEW)\n\t\tseq_printf(m, \"commands:\\tdvi_enable, dvi_disable\\n\");\n\tseq_printf(m, \"commands:\\tauto_enable, auto_disable\\n\");\n\tseq_printf(m, \"commands:\\tvideo_switch, expand_toggle\\n\");\n\n\treturn 0;\n}\n\nstatic int video_write(char *buf)\n{\n\tchar *cmd;\n\tint enable, disable, status;\n\tint res;\n\n\tif (video_supported == TPACPI_VIDEO_NONE)\n\t\treturn -ENODEV;\n\n\t/* Even reads can crash X.org, let alone writes... */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tenable = 0;\n\tdisable = 0;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (strlencmp(cmd, \"lcd_enable\") == 0) {\n\t\t\tenable |= TP_ACPI_VIDEO_S_LCD;\n\t\t} else if (strlencmp(cmd, \"lcd_disable\") == 0) {\n\t\t\tdisable |= TP_ACPI_VIDEO_S_LCD;\n\t\t} else if (strlencmp(cmd, \"crt_enable\") == 0) {\n\t\t\tenable |= TP_ACPI_VIDEO_S_CRT;\n\t\t} else if (strlencmp(cmd, \"crt_disable\") == 0) {\n\t\t\tdisable |= TP_ACPI_VIDEO_S_CRT;\n\t\t} else if (video_supported == TPACPI_VIDEO_NEW &&\n\t\t\t   strlencmp(cmd, \"dvi_enable\") == 0) {\n\t\t\tenable |= TP_ACPI_VIDEO_S_DVI;\n\t\t} else if (video_supported == TPACPI_VIDEO_NEW &&\n\t\t\t   strlencmp(cmd, \"dvi_disable\") == 0) {\n\t\t\tdisable |= TP_ACPI_VIDEO_S_DVI;\n\t\t} else if (strlencmp(cmd, \"auto_enable\") == 0) {\n\t\t\tres = video_autosw_set(1);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t} else if (strlencmp(cmd, \"auto_disable\") == 0) {\n\t\t\tres = video_autosw_set(0);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t} else if (strlencmp(cmd, \"video_switch\") == 0) {\n\t\t\tres = video_outputsw_cycle();\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t} else if (strlencmp(cmd, \"expand_toggle\") == 0) {\n\t\t\tres = video_expand_toggle();\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (enable || disable) {\n\t\tstatus = video_outputsw_get();\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tres = video_outputsw_set((status & ~disable) | enable);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ibm_struct video_driver_data = {\n\t.name = \"video\",\n\t.read = video_read,\n\t.write = video_write,\n\t.exit = video_exit,\n};\n\n#endif /* CONFIG_THINKPAD_ACPI_VIDEO */\n\n/*************************************************************************\n * Keyboard backlight subdriver\n */\n\nstatic enum led_brightness kbdlight_brightness;\nstatic DEFINE_MUTEX(kbdlight_mutex);\n\nstatic int kbdlight_set_level(int level)\n{\n\tint ret = 0;\n\n\tif (!hkey_handle)\n\t\treturn -ENXIO;\n\n\tmutex_lock(&kbdlight_mutex);\n\n\tif (!acpi_evalf(hkey_handle, NULL, \"MLCS\", \"dd\", level))\n\t\tret = -EIO;\n\telse\n\t\tkbdlight_brightness = level;\n\n\tmutex_unlock(&kbdlight_mutex);\n\n\treturn ret;\n}\n\nstatic int kbdlight_get_level(void)\n{\n\tint status = 0;\n\n\tif (!hkey_handle)\n\t\treturn -ENXIO;\n\n\tif (!acpi_evalf(hkey_handle, &status, \"MLCG\", \"dd\", 0))\n\t\treturn -EIO;\n\n\tif (status < 0)\n\t\treturn status;\n\n\treturn status & 0x3;\n}\n\nstatic bool kbdlight_is_supported(void)\n{\n\tint status = 0;\n\n\tif (!hkey_handle)\n\t\treturn false;\n\n\tif (!acpi_has_method(hkey_handle, \"MLCG\")) {\n\t\tvdbg_printk(TPACPI_DBG_INIT, \"kbdlight MLCG is unavailable\\n\");\n\t\treturn false;\n\t}\n\n\tif (!acpi_evalf(hkey_handle, &status, \"MLCG\", \"qdd\", 0)) {\n\t\tvdbg_printk(TPACPI_DBG_INIT, \"kbdlight MLCG failed\\n\");\n\t\treturn false;\n\t}\n\n\tif (status < 0) {\n\t\tvdbg_printk(TPACPI_DBG_INIT, \"kbdlight MLCG err: %d\\n\", status);\n\t\treturn false;\n\t}\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"kbdlight MLCG returned 0x%x\\n\", status);\n\t/*\n\t * Guessed test for keyboard backlight:\n\t *\n\t * Machines with backlight keyboard return:\n\t *   b010100000010000000XX - ThinkPad X1 Carbon 3rd\n\t *   b110100010010000000XX - ThinkPad x230\n\t *   b010100000010000000XX - ThinkPad x240\n\t *   b010100000010000000XX - ThinkPad W541\n\t * (XX is current backlight level)\n\t *\n\t * Machines without backlight keyboard return:\n\t *   b10100001000000000000 - ThinkPad x230\n\t *   b10110001000000000000 - ThinkPad E430\n\t *   b00000000000000000000 - ThinkPad E450\n\t *\n\t * Candidate BITs for detection test (XOR):\n\t *   b01000000001000000000\n\t *              ^\n\t */\n\treturn status & BIT(9);\n}\n\nstatic int kbdlight_sysfs_set(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness brightness)\n{\n\treturn kbdlight_set_level(brightness);\n}\n\nstatic enum led_brightness kbdlight_sysfs_get(struct led_classdev *led_cdev)\n{\n\tint level;\n\n\tlevel = kbdlight_get_level();\n\tif (level < 0)\n\t\treturn 0;\n\n\treturn level;\n}\n\nstatic struct tpacpi_led_classdev tpacpi_led_kbdlight = {\n\t.led_classdev = {\n\t\t.name\t\t= \"tpacpi::kbd_backlight\",\n\t\t.max_brightness\t= 2,\n\t\t.flags\t\t= LED_BRIGHT_HW_CHANGED,\n\t\t.brightness_set_blocking = &kbdlight_sysfs_set,\n\t\t.brightness_get\t= &kbdlight_sysfs_get,\n\t}\n};\n\nstatic int __init kbdlight_init(struct ibm_init_struct *iibm)\n{\n\tint rc;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"initializing kbdlight subdriver\\n\");\n\n\tTPACPI_ACPIHANDLE_INIT(hkey);\n\n\tif (!kbdlight_is_supported()) {\n\t\ttp_features.kbdlight = 0;\n\t\tvdbg_printk(TPACPI_DBG_INIT, \"kbdlight is unsupported\\n\");\n\t\treturn 1;\n\t}\n\n\tkbdlight_brightness = kbdlight_sysfs_get(NULL);\n\ttp_features.kbdlight = 1;\n\n\trc = led_classdev_register(&tpacpi_pdev->dev,\n\t\t\t\t   &tpacpi_led_kbdlight.led_classdev);\n\tif (rc < 0) {\n\t\ttp_features.kbdlight = 0;\n\t\treturn rc;\n\t}\n\n\ttpacpi_hotkey_driver_mask_set(hotkey_driver_mask |\n\t\t\t\t      TP_ACPI_HKEY_KBD_LIGHT_MASK);\n\treturn 0;\n}\n\nstatic void kbdlight_exit(void)\n{\n\tled_classdev_unregister(&tpacpi_led_kbdlight.led_classdev);\n}\n\nstatic int kbdlight_set_level_and_update(int level)\n{\n\tint ret;\n\tstruct led_classdev *led_cdev;\n\n\tret = kbdlight_set_level(level);\n\tled_cdev = &tpacpi_led_kbdlight.led_classdev;\n\n\tif (ret == 0 && !(led_cdev->flags & LED_SUSPENDED))\n\t\tled_cdev->brightness = level;\n\n\treturn ret;\n}\n\nstatic int kbdlight_read(struct seq_file *m)\n{\n\tint level;\n\n\tif (!tp_features.kbdlight) {\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\t} else {\n\t\tlevel = kbdlight_get_level();\n\t\tif (level < 0)\n\t\t\tseq_printf(m, \"status:\\t\\terror %d\\n\", level);\n\t\telse\n\t\t\tseq_printf(m, \"status:\\t\\t%d\\n\", level);\n\t\tseq_printf(m, \"commands:\\t0, 1, 2\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int kbdlight_write(char *buf)\n{\n\tchar *cmd;\n\tint res, level = -EINVAL;\n\n\tif (!tp_features.kbdlight)\n\t\treturn -ENODEV;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tres = kstrtoint(cmd, 10, &level);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t}\n\n\tif (level >= 3 || level < 0)\n\t\treturn -EINVAL;\n\n\treturn kbdlight_set_level_and_update(level);\n}\n\nstatic void kbdlight_suspend(void)\n{\n\tstruct led_classdev *led_cdev;\n\n\tif (!tp_features.kbdlight)\n\t\treturn;\n\n\tled_cdev = &tpacpi_led_kbdlight.led_classdev;\n\tled_update_brightness(led_cdev);\n\tled_classdev_suspend(led_cdev);\n}\n\nstatic void kbdlight_resume(void)\n{\n\tif (!tp_features.kbdlight)\n\t\treturn;\n\n\tled_classdev_resume(&tpacpi_led_kbdlight.led_classdev);\n}\n\nstatic struct ibm_struct kbdlight_driver_data = {\n\t.name = \"kbdlight\",\n\t.read = kbdlight_read,\n\t.write = kbdlight_write,\n\t.suspend = kbdlight_suspend,\n\t.resume = kbdlight_resume,\n\t.exit = kbdlight_exit,\n};\n\n/*************************************************************************\n * Light (thinklight) subdriver\n */\n\nTPACPI_HANDLE(lght, root, \"\\\\LGHT\");\t/* A21e, A2xm/p, T20-22, X20-21 */\nTPACPI_HANDLE(ledb, ec, \"LEDB\");\t\t/* G4x */\n\nstatic int light_get_status(void)\n{\n\tint status = 0;\n\n\tif (tp_features.light_status) {\n\t\tif (!acpi_evalf(ec_handle, &status, \"KBLT\", \"d\"))\n\t\t\treturn -EIO;\n\t\treturn (!!status);\n\t}\n\n\treturn -ENXIO;\n}\n\nstatic int light_set_status(int status)\n{\n\tint rc;\n\n\tif (tp_features.light) {\n\t\tif (cmos_handle) {\n\t\t\trc = acpi_evalf(cmos_handle, NULL, NULL, \"vd\",\n\t\t\t\t\t(status) ?\n\t\t\t\t\t\tTP_CMOS_THINKLIGHT_ON :\n\t\t\t\t\t\tTP_CMOS_THINKLIGHT_OFF);\n\t\t} else {\n\t\t\trc = acpi_evalf(lght_handle, NULL, NULL, \"vd\",\n\t\t\t\t\t(status) ? 1 : 0);\n\t\t}\n\t\treturn (rc) ? 0 : -EIO;\n\t}\n\n\treturn -ENXIO;\n}\n\nstatic int light_sysfs_set(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness brightness)\n{\n\treturn light_set_status((brightness != LED_OFF) ?\n\t\t\t\tTPACPI_LED_ON : TPACPI_LED_OFF);\n}\n\nstatic enum led_brightness light_sysfs_get(struct led_classdev *led_cdev)\n{\n\treturn (light_get_status() == 1) ? LED_FULL : LED_OFF;\n}\n\nstatic struct tpacpi_led_classdev tpacpi_led_thinklight = {\n\t.led_classdev = {\n\t\t.name\t\t= \"tpacpi::thinklight\",\n\t\t.brightness_set_blocking = &light_sysfs_set,\n\t\t.brightness_get\t= &light_sysfs_get,\n\t}\n};\n\nstatic int __init light_init(struct ibm_init_struct *iibm)\n{\n\tint rc;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"initializing light subdriver\\n\");\n\n\tif (tpacpi_is_ibm()) {\n\t\tTPACPI_ACPIHANDLE_INIT(ledb);\n\t\tTPACPI_ACPIHANDLE_INIT(lght);\n\t}\n\tTPACPI_ACPIHANDLE_INIT(cmos);\n\n\t/* light not supported on 570, 600e/x, 770e, 770x, G4x, R30, R31 */\n\ttp_features.light = (cmos_handle || lght_handle) && !ledb_handle;\n\n\tif (tp_features.light)\n\t\t/* light status not supported on\n\t\t   570, 600e/x, 770e, 770x, G4x, R30, R31, R32, X20 */\n\t\ttp_features.light_status =\n\t\t\tacpi_evalf(ec_handle, NULL, \"KBLT\", \"qv\");\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"light is %s, light status is %s\\n\",\n\t\tstr_supported(tp_features.light),\n\t\tstr_supported(tp_features.light_status));\n\n\tif (!tp_features.light)\n\t\treturn 1;\n\n\trc = led_classdev_register(&tpacpi_pdev->dev,\n\t\t\t\t   &tpacpi_led_thinklight.led_classdev);\n\n\tif (rc < 0) {\n\t\ttp_features.light = 0;\n\t\ttp_features.light_status = 0;\n\t} else  {\n\t\trc = 0;\n\t}\n\n\treturn rc;\n}\n\nstatic void light_exit(void)\n{\n\tled_classdev_unregister(&tpacpi_led_thinklight.led_classdev);\n}\n\nstatic int light_read(struct seq_file *m)\n{\n\tint status;\n\n\tif (!tp_features.light) {\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\t} else if (!tp_features.light_status) {\n\t\tseq_printf(m, \"status:\\t\\tunknown\\n\");\n\t\tseq_printf(m, \"commands:\\ton, off\\n\");\n\t} else {\n\t\tstatus = light_get_status();\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tseq_printf(m, \"status:\\t\\t%s\\n\", onoff(status, 0));\n\t\tseq_printf(m, \"commands:\\ton, off\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int light_write(char *buf)\n{\n\tchar *cmd;\n\tint newstatus = 0;\n\n\tif (!tp_features.light)\n\t\treturn -ENODEV;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (strlencmp(cmd, \"on\") == 0) {\n\t\t\tnewstatus = 1;\n\t\t} else if (strlencmp(cmd, \"off\") == 0) {\n\t\t\tnewstatus = 0;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn light_set_status(newstatus);\n}\n\nstatic struct ibm_struct light_driver_data = {\n\t.name = \"light\",\n\t.read = light_read,\n\t.write = light_write,\n\t.exit = light_exit,\n};\n\n/*************************************************************************\n * CMOS subdriver\n */\n\n/* sysfs cmos_command -------------------------------------------------- */\nstatic ssize_t cmos_command_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned long cmos_cmd;\n\tint res;\n\n\tif (parse_strtoul(buf, 21, &cmos_cmd))\n\t\treturn -EINVAL;\n\n\tres = issue_thinkpad_cmos_command(cmos_cmd);\n\treturn (res) ? res : count;\n}\n\nstatic DEVICE_ATTR_WO(cmos_command);\n\n/* --------------------------------------------------------------------- */\n\nstatic int __init cmos_init(struct ibm_init_struct *iibm)\n{\n\tint res;\n\n\tvdbg_printk(TPACPI_DBG_INIT,\n\t\t\"initializing cmos commands subdriver\\n\");\n\n\tTPACPI_ACPIHANDLE_INIT(cmos);\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"cmos commands are %s\\n\",\n\t\tstr_supported(cmos_handle != NULL));\n\n\tres = device_create_file(&tpacpi_pdev->dev, &dev_attr_cmos_command);\n\tif (res)\n\t\treturn res;\n\n\treturn (cmos_handle) ? 0 : 1;\n}\n\nstatic void cmos_exit(void)\n{\n\tdevice_remove_file(&tpacpi_pdev->dev, &dev_attr_cmos_command);\n}\n\nstatic int cmos_read(struct seq_file *m)\n{\n\t/* cmos not supported on 570, 600e/x, 770e, 770x, A21e, A2xm/p,\n\t   R30, R31, T20-22, X20-21 */\n\tif (!cmos_handle)\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\telse {\n\t\tseq_printf(m, \"status:\\t\\tsupported\\n\");\n\t\tseq_printf(m, \"commands:\\t<cmd> (<cmd> is 0-21)\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int cmos_write(char *buf)\n{\n\tchar *cmd;\n\tint cmos_cmd, res;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (sscanf(cmd, \"%u\", &cmos_cmd) == 1 &&\n\t\t    cmos_cmd >= 0 && cmos_cmd <= 21) {\n\t\t\t/* cmos_cmd set */\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tres = issue_thinkpad_cmos_command(cmos_cmd);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ibm_struct cmos_driver_data = {\n\t.name = \"cmos\",\n\t.read = cmos_read,\n\t.write = cmos_write,\n\t.exit = cmos_exit,\n};\n\n/*************************************************************************\n * LED subdriver\n */\n\nenum led_access_mode {\n\tTPACPI_LED_NONE = 0,\n\tTPACPI_LED_570,\t/* 570 */\n\tTPACPI_LED_OLD,\t/* 600e/x, 770e, 770x, A21e, A2xm/p, T20-22, X20-21 */\n\tTPACPI_LED_NEW,\t/* all others */\n};\n\nenum {\t/* For TPACPI_LED_OLD */\n\tTPACPI_LED_EC_HLCL = 0x0c,\t/* EC reg to get led to power on */\n\tTPACPI_LED_EC_HLBL = 0x0d,\t/* EC reg to blink a lit led */\n\tTPACPI_LED_EC_HLMS = 0x0e,\t/* EC reg to select led to command */\n};\n\nstatic enum led_access_mode led_supported;\n\nstatic acpi_handle led_handle;\n\n#define TPACPI_LED_NUMLEDS 16\nstatic struct tpacpi_led_classdev *tpacpi_leds;\nstatic enum led_status_t tpacpi_led_state_cache[TPACPI_LED_NUMLEDS];\nstatic const char * const tpacpi_led_names[TPACPI_LED_NUMLEDS] = {\n\t/* there's a limit of 19 chars + NULL before 2.6.26 */\n\t\"tpacpi::power\",\n\t\"tpacpi:orange:batt\",\n\t\"tpacpi:green:batt\",\n\t\"tpacpi::dock_active\",\n\t\"tpacpi::bay_active\",\n\t\"tpacpi::dock_batt\",\n\t\"tpacpi::unknown_led\",\n\t\"tpacpi::standby\",\n\t\"tpacpi::dock_status1\",\n\t\"tpacpi::dock_status2\",\n\t\"tpacpi::unknown_led2\",\n\t\"tpacpi::unknown_led3\",\n\t\"tpacpi::thinkvantage\",\n};\n#define TPACPI_SAFE_LEDS\t0x1081U\n\nstatic inline bool tpacpi_is_led_restricted(const unsigned int led)\n{\n#ifdef CONFIG_THINKPAD_ACPI_UNSAFE_LEDS\n\treturn false;\n#else\n\treturn (1U & (TPACPI_SAFE_LEDS >> led)) == 0;\n#endif\n}\n\nstatic int led_get_status(const unsigned int led)\n{\n\tint status;\n\tenum led_status_t led_s;\n\n\tswitch (led_supported) {\n\tcase TPACPI_LED_570:\n\t\tif (!acpi_evalf(ec_handle,\n\t\t\t\t&status, \"GLED\", \"dd\", 1 << led))\n\t\t\treturn -EIO;\n\t\tled_s = (status == 0) ?\n\t\t\t\tTPACPI_LED_OFF :\n\t\t\t\t((status == 1) ?\n\t\t\t\t\tTPACPI_LED_ON :\n\t\t\t\t\tTPACPI_LED_BLINK);\n\t\ttpacpi_led_state_cache[led] = led_s;\n\t\treturn led_s;\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\t/* not reached */\n}\n\nstatic int led_set_status(const unsigned int led,\n\t\t\t  const enum led_status_t ledstatus)\n{\n\t/* off, on, blink. Index is led_status_t */\n\tstatic const unsigned int led_sled_arg1[] = { 0, 1, 3 };\n\tstatic const unsigned int led_led_arg1[] = { 0, 0x80, 0xc0 };\n\n\tint rc = 0;\n\n\tswitch (led_supported) {\n\tcase TPACPI_LED_570:\n\t\t/* 570 */\n\t\tif (unlikely(led > 7))\n\t\t\treturn -EINVAL;\n\t\tif (unlikely(tpacpi_is_led_restricted(led)))\n\t\t\treturn -EPERM;\n\t\tif (!acpi_evalf(led_handle, NULL, NULL, \"vdd\",\n\t\t\t\t(1 << led), led_sled_arg1[ledstatus]))\n\t\t\treturn -EIO;\n\t\tbreak;\n\tcase TPACPI_LED_OLD:\n\t\t/* 600e/x, 770e, 770x, A21e, A2xm/p, T20-22, X20 */\n\t\tif (unlikely(led > 7))\n\t\t\treturn -EINVAL;\n\t\tif (unlikely(tpacpi_is_led_restricted(led)))\n\t\t\treturn -EPERM;\n\t\trc = ec_write(TPACPI_LED_EC_HLMS, (1 << led));\n\t\tif (rc >= 0)\n\t\t\trc = ec_write(TPACPI_LED_EC_HLBL,\n\t\t\t\t      (ledstatus == TPACPI_LED_BLINK) << led);\n\t\tif (rc >= 0)\n\t\t\trc = ec_write(TPACPI_LED_EC_HLCL,\n\t\t\t\t      (ledstatus != TPACPI_LED_OFF) << led);\n\t\tbreak;\n\tcase TPACPI_LED_NEW:\n\t\t/* all others */\n\t\tif (unlikely(led >= TPACPI_LED_NUMLEDS))\n\t\t\treturn -EINVAL;\n\t\tif (unlikely(tpacpi_is_led_restricted(led)))\n\t\t\treturn -EPERM;\n\t\tif (!acpi_evalf(led_handle, NULL, NULL, \"vdd\",\n\t\t\t\tled, led_led_arg1[ledstatus]))\n\t\t\treturn -EIO;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\tif (!rc)\n\t\ttpacpi_led_state_cache[led] = ledstatus;\n\n\treturn rc;\n}\n\nstatic int led_sysfs_set(struct led_classdev *led_cdev,\n\t\t\tenum led_brightness brightness)\n{\n\tstruct tpacpi_led_classdev *data = container_of(led_cdev,\n\t\t\t     struct tpacpi_led_classdev, led_classdev);\n\tenum led_status_t new_state;\n\n\tif (brightness == LED_OFF)\n\t\tnew_state = TPACPI_LED_OFF;\n\telse if (tpacpi_led_state_cache[data->led] != TPACPI_LED_BLINK)\n\t\tnew_state = TPACPI_LED_ON;\n\telse\n\t\tnew_state = TPACPI_LED_BLINK;\n\n\treturn led_set_status(data->led, new_state);\n}\n\nstatic int led_sysfs_blink_set(struct led_classdev *led_cdev,\n\t\t\tunsigned long *delay_on, unsigned long *delay_off)\n{\n\tstruct tpacpi_led_classdev *data = container_of(led_cdev,\n\t\t\t     struct tpacpi_led_classdev, led_classdev);\n\n\t/* Can we choose the flash rate? */\n\tif (*delay_on == 0 && *delay_off == 0) {\n\t\t/* yes. set them to the hardware blink rate (1 Hz) */\n\t\t*delay_on = 500; /* ms */\n\t\t*delay_off = 500; /* ms */\n\t} else if ((*delay_on != 500) || (*delay_off != 500))\n\t\treturn -EINVAL;\n\n\treturn led_set_status(data->led, TPACPI_LED_BLINK);\n}\n\nstatic enum led_brightness led_sysfs_get(struct led_classdev *led_cdev)\n{\n\tint rc;\n\n\tstruct tpacpi_led_classdev *data = container_of(led_cdev,\n\t\t\t     struct tpacpi_led_classdev, led_classdev);\n\n\trc = led_get_status(data->led);\n\n\tif (rc == TPACPI_LED_OFF || rc < 0)\n\t\trc = LED_OFF;\t/* no error handling in led class :( */\n\telse\n\t\trc = LED_FULL;\n\n\treturn rc;\n}\n\nstatic void led_exit(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < TPACPI_LED_NUMLEDS; i++)\n\t\tled_classdev_unregister(&tpacpi_leds[i].led_classdev);\n\n\tkfree(tpacpi_leds);\n}\n\nstatic int __init tpacpi_init_led(unsigned int led)\n{\n\t/* LEDs with no name don't get registered */\n\tif (!tpacpi_led_names[led])\n\t\treturn 0;\n\n\ttpacpi_leds[led].led_classdev.brightness_set_blocking = &led_sysfs_set;\n\ttpacpi_leds[led].led_classdev.blink_set = &led_sysfs_blink_set;\n\tif (led_supported == TPACPI_LED_570)\n\t\ttpacpi_leds[led].led_classdev.brightness_get = &led_sysfs_get;\n\n\ttpacpi_leds[led].led_classdev.name = tpacpi_led_names[led];\n\ttpacpi_leds[led].led = led;\n\n\treturn led_classdev_register(&tpacpi_pdev->dev, &tpacpi_leds[led].led_classdev);\n}\n\nstatic const struct tpacpi_quirk led_useful_qtable[] __initconst = {\n\tTPACPI_Q_IBM('1', 'E', 0x009f), /* A30 */\n\tTPACPI_Q_IBM('1', 'N', 0x009f), /* A31 */\n\tTPACPI_Q_IBM('1', 'G', 0x009f), /* A31 */\n\n\tTPACPI_Q_IBM('1', 'I', 0x0097), /* T30 */\n\tTPACPI_Q_IBM('1', 'R', 0x0097), /* T40, T41, T42, R50, R51 */\n\tTPACPI_Q_IBM('7', '0', 0x0097), /* T43, R52 */\n\tTPACPI_Q_IBM('1', 'Y', 0x0097), /* T43 */\n\tTPACPI_Q_IBM('1', 'W', 0x0097), /* R50e */\n\tTPACPI_Q_IBM('1', 'V', 0x0097), /* R51 */\n\tTPACPI_Q_IBM('7', '8', 0x0097), /* R51e */\n\tTPACPI_Q_IBM('7', '6', 0x0097), /* R52 */\n\n\tTPACPI_Q_IBM('1', 'K', 0x00bf), /* X30 */\n\tTPACPI_Q_IBM('1', 'Q', 0x00bf), /* X31, X32 */\n\tTPACPI_Q_IBM('1', 'U', 0x00bf), /* X40 */\n\tTPACPI_Q_IBM('7', '4', 0x00bf), /* X41 */\n\tTPACPI_Q_IBM('7', '5', 0x00bf), /* X41t */\n\n\tTPACPI_Q_IBM('7', '9', 0x1f97), /* T60 (1) */\n\tTPACPI_Q_IBM('7', '7', 0x1f97), /* Z60* (1) */\n\tTPACPI_Q_IBM('7', 'F', 0x1f97), /* Z61* (1) */\n\tTPACPI_Q_IBM('7', 'B', 0x1fb7), /* X60 (1) */\n\n\t/* (1) - may have excess leds enabled on MSB */\n\n\t/* Defaults (order matters, keep last, don't reorder!) */\n\t{ /* Lenovo */\n\t  .vendor = PCI_VENDOR_ID_LENOVO,\n\t  .bios = TPACPI_MATCH_ANY, .ec = TPACPI_MATCH_ANY,\n\t  .quirks = 0x1fffU,\n\t},\n\t{ /* IBM ThinkPads with no EC version string */\n\t  .vendor = PCI_VENDOR_ID_IBM,\n\t  .bios = TPACPI_MATCH_ANY, .ec = TPACPI_MATCH_UNKNOWN,\n\t  .quirks = 0x00ffU,\n\t},\n\t{ /* IBM ThinkPads with EC version string */\n\t  .vendor = PCI_VENDOR_ID_IBM,\n\t  .bios = TPACPI_MATCH_ANY, .ec = TPACPI_MATCH_ANY,\n\t  .quirks = 0x00bfU,\n\t},\n};\n\nstatic enum led_access_mode __init led_init_detect_mode(void)\n{\n\tacpi_status status;\n\n\tif (tpacpi_is_ibm()) {\n\t\t/* 570 */\n\t\tstatus = acpi_get_handle(ec_handle, \"SLED\", &led_handle);\n\t\tif (ACPI_SUCCESS(status))\n\t\t\treturn TPACPI_LED_570;\n\n\t\t/* 600e/x, 770e, 770x, A21e, A2xm/p, T20-22, X20-21 */\n\t\tstatus = acpi_get_handle(ec_handle, \"SYSL\", &led_handle);\n\t\tif (ACPI_SUCCESS(status))\n\t\t\treturn TPACPI_LED_OLD;\n\t}\n\n\t/* most others */\n\tstatus = acpi_get_handle(ec_handle, \"LED\", &led_handle);\n\tif (ACPI_SUCCESS(status))\n\t\treturn TPACPI_LED_NEW;\n\n\t/* R30, R31, and unknown firmwares */\n\tled_handle = NULL;\n\treturn TPACPI_LED_NONE;\n}\n\nstatic int __init led_init(struct ibm_init_struct *iibm)\n{\n\tunsigned int i;\n\tint rc;\n\tunsigned long useful_leds;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"initializing LED subdriver\\n\");\n\n\tled_supported = led_init_detect_mode();\n\n\tif (led_supported != TPACPI_LED_NONE) {\n\t\tuseful_leds = tpacpi_check_quirks(led_useful_qtable,\n\t\t\t\tARRAY_SIZE(led_useful_qtable));\n\n\t\tif (!useful_leds) {\n\t\t\tled_handle = NULL;\n\t\t\tled_supported = TPACPI_LED_NONE;\n\t\t}\n\t}\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"LED commands are %s, mode %d\\n\",\n\t\tstr_supported(led_supported), led_supported);\n\n\tif (led_supported == TPACPI_LED_NONE)\n\t\treturn 1;\n\n\ttpacpi_leds = kcalloc(TPACPI_LED_NUMLEDS, sizeof(*tpacpi_leds),\n\t\t\t      GFP_KERNEL);\n\tif (!tpacpi_leds) {\n\t\tpr_err(\"Out of memory for LED data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < TPACPI_LED_NUMLEDS; i++) {\n\t\ttpacpi_leds[i].led = -1;\n\n\t\tif (!tpacpi_is_led_restricted(i) && test_bit(i, &useful_leds)) {\n\t\t\trc = tpacpi_init_led(i);\n\t\t\tif (rc < 0) {\n\t\t\t\tled_exit();\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef CONFIG_THINKPAD_ACPI_UNSAFE_LEDS\n\tpr_notice(\"warning: userspace override of important firmware LEDs is enabled\\n\");\n#endif\n\treturn 0;\n}\n\n#define str_led_status(s) \\\n\t((s) == TPACPI_LED_OFF ? \"off\" : \\\n\t\t((s) == TPACPI_LED_ON ? \"on\" : \"blinking\"))\n\nstatic int led_read(struct seq_file *m)\n{\n\tif (!led_supported) {\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\t\treturn 0;\n\t}\n\tseq_printf(m, \"status:\\t\\tsupported\\n\");\n\n\tif (led_supported == TPACPI_LED_570) {\n\t\t/* 570 */\n\t\tint i, status;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tstatus = led_get_status(i);\n\t\t\tif (status < 0)\n\t\t\t\treturn -EIO;\n\t\t\tseq_printf(m, \"%d:\\t\\t%s\\n\",\n\t\t\t\t       i, str_led_status(status));\n\t\t}\n\t}\n\n\tseq_printf(m, \"commands:\\t<led> on, <led> off, <led> blink (<led> is 0-15)\\n\");\n\n\treturn 0;\n}\n\nstatic int led_write(char *buf)\n{\n\tchar *cmd;\n\tint led, rc;\n\tenum led_status_t s;\n\n\tif (!led_supported)\n\t\treturn -ENODEV;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (sscanf(cmd, \"%d\", &led) != 1)\n\t\t\treturn -EINVAL;\n\n\t\tif (led < 0 || led > (TPACPI_LED_NUMLEDS - 1))\n\t\t\treturn -ENODEV;\n\n\t\tif (tpacpi_leds[led].led < 0)\n\t\t\treturn -ENODEV;\n\n\t\tif (strstr(cmd, \"off\")) {\n\t\t\ts = TPACPI_LED_OFF;\n\t\t} else if (strstr(cmd, \"on\")) {\n\t\t\ts = TPACPI_LED_ON;\n\t\t} else if (strstr(cmd, \"blink\")) {\n\t\t\ts = TPACPI_LED_BLINK;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trc = led_set_status(led, s);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ibm_struct led_driver_data = {\n\t.name = \"led\",\n\t.read = led_read,\n\t.write = led_write,\n\t.exit = led_exit,\n};\n\n/*************************************************************************\n * Beep subdriver\n */\n\nTPACPI_HANDLE(beep, ec, \"BEEP\");\t/* all except R30, R31 */\n\n#define TPACPI_BEEP_Q1 0x0001\n\nstatic const struct tpacpi_quirk beep_quirk_table[] __initconst = {\n\tTPACPI_Q_IBM('I', 'M', TPACPI_BEEP_Q1), /* 570 */\n\tTPACPI_Q_IBM('I', 'U', TPACPI_BEEP_Q1), /* 570E - unverified */\n};\n\nstatic int __init beep_init(struct ibm_init_struct *iibm)\n{\n\tunsigned long quirks;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"initializing beep subdriver\\n\");\n\n\tTPACPI_ACPIHANDLE_INIT(beep);\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"beep is %s\\n\",\n\t\tstr_supported(beep_handle != NULL));\n\n\tquirks = tpacpi_check_quirks(beep_quirk_table,\n\t\t\t\t     ARRAY_SIZE(beep_quirk_table));\n\n\ttp_features.beep_needs_two_args = !!(quirks & TPACPI_BEEP_Q1);\n\n\treturn (beep_handle) ? 0 : 1;\n}\n\nstatic int beep_read(struct seq_file *m)\n{\n\tif (!beep_handle)\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\telse {\n\t\tseq_printf(m, \"status:\\t\\tsupported\\n\");\n\t\tseq_printf(m, \"commands:\\t<cmd> (<cmd> is 0-17)\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int beep_write(char *buf)\n{\n\tchar *cmd;\n\tint beep_cmd;\n\n\tif (!beep_handle)\n\t\treturn -ENODEV;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (sscanf(cmd, \"%u\", &beep_cmd) == 1 &&\n\t\t    beep_cmd >= 0 && beep_cmd <= 17) {\n\t\t\t/* beep_cmd set */\n\t\t} else\n\t\t\treturn -EINVAL;\n\t\tif (tp_features.beep_needs_two_args) {\n\t\t\tif (!acpi_evalf(beep_handle, NULL, NULL, \"vdd\",\n\t\t\t\t\tbeep_cmd, 0))\n\t\t\t\treturn -EIO;\n\t\t} else {\n\t\t\tif (!acpi_evalf(beep_handle, NULL, NULL, \"vd\",\n\t\t\t\t\tbeep_cmd))\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct ibm_struct beep_driver_data = {\n\t.name = \"beep\",\n\t.read = beep_read,\n\t.write = beep_write,\n};\n\n/*************************************************************************\n * Thermal subdriver\n */\n\nenum thermal_access_mode {\n\tTPACPI_THERMAL_NONE = 0,\t/* No thermal support */\n\tTPACPI_THERMAL_ACPI_TMP07,\t/* Use ACPI TMP0-7 */\n\tTPACPI_THERMAL_ACPI_UPDT,\t/* Use ACPI TMP0-7 with UPDT */\n\tTPACPI_THERMAL_TPEC_8,\t\t/* Use ACPI EC regs, 8 sensors */\n\tTPACPI_THERMAL_TPEC_16,\t\t/* Use ACPI EC regs, 16 sensors */\n};\n\nenum { /* TPACPI_THERMAL_TPEC_* */\n\tTP_EC_THERMAL_TMP0 = 0x78,\t/* ACPI EC regs TMP 0..7 */\n\tTP_EC_THERMAL_TMP8 = 0xC0,\t/* ACPI EC regs TMP 8..15 */\n\tTP_EC_THERMAL_TMP_NA = -128,\t/* ACPI EC sensor not available */\n\n\tTPACPI_THERMAL_SENSOR_NA = -128000, /* Sensor not available */\n};\n\n\n#define TPACPI_MAX_THERMAL_SENSORS 16\t/* Max thermal sensors supported */\nstruct ibm_thermal_sensors_struct {\n\ts32 temp[TPACPI_MAX_THERMAL_SENSORS];\n};\n\nstatic enum thermal_access_mode thermal_read_mode;\n\n/* idx is zero-based */\nstatic int thermal_get_sensor(int idx, s32 *value)\n{\n\tint t;\n\ts8 tmp;\n\tchar tmpi[5];\n\n\tt = TP_EC_THERMAL_TMP0;\n\n\tswitch (thermal_read_mode) {\n#if TPACPI_MAX_THERMAL_SENSORS >= 16\n\tcase TPACPI_THERMAL_TPEC_16:\n\t\tif (idx >= 8 && idx <= 15) {\n\t\t\tt = TP_EC_THERMAL_TMP8;\n\t\t\tidx -= 8;\n\t\t}\n#endif\n\t\tfallthrough;\n\tcase TPACPI_THERMAL_TPEC_8:\n\t\tif (idx <= 7) {\n\t\t\tif (!acpi_ec_read(t + idx, &tmp))\n\t\t\t\treturn -EIO;\n\t\t\t*value = tmp * 1000;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase TPACPI_THERMAL_ACPI_UPDT:\n\t\tif (idx <= 7) {\n\t\t\tsnprintf(tmpi, sizeof(tmpi), \"TMP%c\", '0' + idx);\n\t\t\tif (!acpi_evalf(ec_handle, NULL, \"UPDT\", \"v\"))\n\t\t\t\treturn -EIO;\n\t\t\tif (!acpi_evalf(ec_handle, &t, tmpi, \"d\"))\n\t\t\t\treturn -EIO;\n\t\t\t*value = (t - 2732) * 100;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase TPACPI_THERMAL_ACPI_TMP07:\n\t\tif (idx <= 7) {\n\t\t\tsnprintf(tmpi, sizeof(tmpi), \"TMP%c\", '0' + idx);\n\t\t\tif (!acpi_evalf(ec_handle, &t, tmpi, \"d\"))\n\t\t\t\treturn -EIO;\n\t\t\tif (t > 127 || t < -127)\n\t\t\t\tt = TP_EC_THERMAL_TMP_NA;\n\t\t\t*value = t * 1000;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase TPACPI_THERMAL_NONE:\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int thermal_get_sensors(struct ibm_thermal_sensors_struct *s)\n{\n\tint res, i;\n\tint n;\n\n\tn = 8;\n\ti = 0;\n\n\tif (!s)\n\t\treturn -EINVAL;\n\n\tif (thermal_read_mode == TPACPI_THERMAL_TPEC_16)\n\t\tn = 16;\n\n\tfor (i = 0 ; i < n; i++) {\n\t\tres = thermal_get_sensor(i, &s->temp[i]);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\treturn n;\n}\n\nstatic void thermal_dump_all_sensors(void)\n{\n\tint n, i;\n\tstruct ibm_thermal_sensors_struct t;\n\n\tn = thermal_get_sensors(&t);\n\tif (n <= 0)\n\t\treturn;\n\n\tpr_notice(\"temperatures (Celsius):\");\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (t.temp[i] != TPACPI_THERMAL_SENSOR_NA)\n\t\t\tpr_cont(\" %d\", (int)(t.temp[i] / 1000));\n\t\telse\n\t\t\tpr_cont(\" N/A\");\n\t}\n\n\tpr_cont(\"\\n\");\n}\n\n/* sysfs temp##_input -------------------------------------------------- */\n\nstatic ssize_t thermal_temp_input_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct sensor_device_attribute *sensor_attr =\n\t\t\t\t\tto_sensor_dev_attr(attr);\n\tint idx = sensor_attr->index;\n\ts32 value;\n\tint res;\n\n\tres = thermal_get_sensor(idx, &value);\n\tif (res)\n\t\treturn res;\n\tif (value == TPACPI_THERMAL_SENSOR_NA)\n\t\treturn -ENXIO;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", value);\n}\n\n#define THERMAL_SENSOR_ATTR_TEMP(_idxA, _idxB) \\\n\t SENSOR_ATTR(temp##_idxA##_input, S_IRUGO, \\\n\t\t     thermal_temp_input_show, NULL, _idxB)\n\nstatic struct sensor_device_attribute sensor_dev_attr_thermal_temp_input[] = {\n\tTHERMAL_SENSOR_ATTR_TEMP(1, 0),\n\tTHERMAL_SENSOR_ATTR_TEMP(2, 1),\n\tTHERMAL_SENSOR_ATTR_TEMP(3, 2),\n\tTHERMAL_SENSOR_ATTR_TEMP(4, 3),\n\tTHERMAL_SENSOR_ATTR_TEMP(5, 4),\n\tTHERMAL_SENSOR_ATTR_TEMP(6, 5),\n\tTHERMAL_SENSOR_ATTR_TEMP(7, 6),\n\tTHERMAL_SENSOR_ATTR_TEMP(8, 7),\n\tTHERMAL_SENSOR_ATTR_TEMP(9, 8),\n\tTHERMAL_SENSOR_ATTR_TEMP(10, 9),\n\tTHERMAL_SENSOR_ATTR_TEMP(11, 10),\n\tTHERMAL_SENSOR_ATTR_TEMP(12, 11),\n\tTHERMAL_SENSOR_ATTR_TEMP(13, 12),\n\tTHERMAL_SENSOR_ATTR_TEMP(14, 13),\n\tTHERMAL_SENSOR_ATTR_TEMP(15, 14),\n\tTHERMAL_SENSOR_ATTR_TEMP(16, 15),\n};\n\n#define THERMAL_ATTRS(X) \\\n\t&sensor_dev_attr_thermal_temp_input[X].dev_attr.attr\n\nstatic struct attribute *thermal_temp_input_attr[] = {\n\tTHERMAL_ATTRS(8),\n\tTHERMAL_ATTRS(9),\n\tTHERMAL_ATTRS(10),\n\tTHERMAL_ATTRS(11),\n\tTHERMAL_ATTRS(12),\n\tTHERMAL_ATTRS(13),\n\tTHERMAL_ATTRS(14),\n\tTHERMAL_ATTRS(15),\n\tTHERMAL_ATTRS(0),\n\tTHERMAL_ATTRS(1),\n\tTHERMAL_ATTRS(2),\n\tTHERMAL_ATTRS(3),\n\tTHERMAL_ATTRS(4),\n\tTHERMAL_ATTRS(5),\n\tTHERMAL_ATTRS(6),\n\tTHERMAL_ATTRS(7),\n\tNULL\n};\n\nstatic const struct attribute_group thermal_temp_input16_group = {\n\t.attrs = thermal_temp_input_attr\n};\n\nstatic const struct attribute_group thermal_temp_input8_group = {\n\t.attrs = &thermal_temp_input_attr[8]\n};\n\n#undef THERMAL_SENSOR_ATTR_TEMP\n#undef THERMAL_ATTRS\n\n/* --------------------------------------------------------------------- */\n\nstatic int __init thermal_init(struct ibm_init_struct *iibm)\n{\n\tu8 t, ta1, ta2;\n\tint i;\n\tint acpi_tmp7;\n\tint res;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"initializing thermal subdriver\\n\");\n\n\tacpi_tmp7 = acpi_evalf(ec_handle, NULL, \"TMP7\", \"qv\");\n\n\tif (thinkpad_id.ec_model) {\n\t\t/*\n\t\t * Direct EC access mode: sensors at registers\n\t\t * 0x78-0x7F, 0xC0-0xC7.  Registers return 0x00 for\n\t\t * non-implemented, thermal sensors return 0x80 when\n\t\t * not available\n\t\t */\n\n\t\tta1 = ta2 = 0;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (acpi_ec_read(TP_EC_THERMAL_TMP0 + i, &t)) {\n\t\t\t\tta1 |= t;\n\t\t\t} else {\n\t\t\t\tta1 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (acpi_ec_read(TP_EC_THERMAL_TMP8 + i, &t)) {\n\t\t\t\tta2 |= t;\n\t\t\t} else {\n\t\t\t\tta1 = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ta1 == 0) {\n\t\t\t/* This is sheer paranoia, but we handle it anyway */\n\t\t\tif (acpi_tmp7) {\n\t\t\t\tpr_err(\"ThinkPad ACPI EC access misbehaving, falling back to ACPI TMPx access mode\\n\");\n\t\t\t\tthermal_read_mode = TPACPI_THERMAL_ACPI_TMP07;\n\t\t\t} else {\n\t\t\t\tpr_err(\"ThinkPad ACPI EC access misbehaving, disabling thermal sensors access\\n\");\n\t\t\t\tthermal_read_mode = TPACPI_THERMAL_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\tthermal_read_mode =\n\t\t\t    (ta2 != 0) ?\n\t\t\t    TPACPI_THERMAL_TPEC_16 : TPACPI_THERMAL_TPEC_8;\n\t\t}\n\t} else if (acpi_tmp7) {\n\t\tif (tpacpi_is_ibm() &&\n\t\t    acpi_evalf(ec_handle, NULL, \"UPDT\", \"qv\")) {\n\t\t\t/* 600e/x, 770e, 770x */\n\t\t\tthermal_read_mode = TPACPI_THERMAL_ACPI_UPDT;\n\t\t} else {\n\t\t\t/* IBM/LENOVO DSDT EC.TMPx access, max 8 sensors */\n\t\t\tthermal_read_mode = TPACPI_THERMAL_ACPI_TMP07;\n\t\t}\n\t} else {\n\t\t/* temperatures not supported on 570, G4x, R30, R31, R32 */\n\t\tthermal_read_mode = TPACPI_THERMAL_NONE;\n\t}\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"thermal is %s, mode %d\\n\",\n\t\tstr_supported(thermal_read_mode != TPACPI_THERMAL_NONE),\n\t\tthermal_read_mode);\n\n\tswitch (thermal_read_mode) {\n\tcase TPACPI_THERMAL_TPEC_16:\n\t\tres = sysfs_create_group(&tpacpi_hwmon->kobj,\n\t\t\t\t&thermal_temp_input16_group);\n\t\tif (res)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TPACPI_THERMAL_TPEC_8:\n\tcase TPACPI_THERMAL_ACPI_TMP07:\n\tcase TPACPI_THERMAL_ACPI_UPDT:\n\t\tres = sysfs_create_group(&tpacpi_hwmon->kobj,\n\t\t\t\t&thermal_temp_input8_group);\n\t\tif (res)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TPACPI_THERMAL_NONE:\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void thermal_exit(void)\n{\n\tswitch (thermal_read_mode) {\n\tcase TPACPI_THERMAL_TPEC_16:\n\t\tsysfs_remove_group(&tpacpi_hwmon->kobj,\n\t\t\t\t   &thermal_temp_input16_group);\n\t\tbreak;\n\tcase TPACPI_THERMAL_TPEC_8:\n\tcase TPACPI_THERMAL_ACPI_TMP07:\n\tcase TPACPI_THERMAL_ACPI_UPDT:\n\t\tsysfs_remove_group(&tpacpi_hwmon->kobj,\n\t\t\t\t   &thermal_temp_input8_group);\n\t\tbreak;\n\tcase TPACPI_THERMAL_NONE:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int thermal_read(struct seq_file *m)\n{\n\tint n, i;\n\tstruct ibm_thermal_sensors_struct t;\n\n\tn = thermal_get_sensors(&t);\n\tif (unlikely(n < 0))\n\t\treturn n;\n\n\tseq_printf(m, \"temperatures:\\t\");\n\n\tif (n > 0) {\n\t\tfor (i = 0; i < (n - 1); i++)\n\t\t\tseq_printf(m, \"%d \", t.temp[i] / 1000);\n\t\tseq_printf(m, \"%d\\n\", t.temp[i] / 1000);\n\t} else\n\t\tseq_printf(m, \"not supported\\n\");\n\n\treturn 0;\n}\n\nstatic struct ibm_struct thermal_driver_data = {\n\t.name = \"thermal\",\n\t.read = thermal_read,\n\t.exit = thermal_exit,\n};\n\n/*************************************************************************\n * Backlight/brightness subdriver\n */\n\n#define TPACPI_BACKLIGHT_DEV_NAME \"thinkpad_screen\"\n\n/*\n * ThinkPads can read brightness from two places: EC HBRV (0x31), or\n * CMOS NVRAM byte 0x5E, bits 0-3.\n *\n * EC HBRV (0x31) has the following layout\n *   Bit 7: unknown function\n *   Bit 6: unknown function\n *   Bit 5: Z: honour scale changes, NZ: ignore scale changes\n *   Bit 4: must be set to zero to avoid problems\n *   Bit 3-0: backlight brightness level\n *\n * brightness_get_raw returns status data in the HBRV layout\n *\n * WARNING: The X61 has been verified to use HBRV for something else, so\n * this should be used _only_ on IBM ThinkPads, and maybe with some careful\n * testing on the very early *60 Lenovo models...\n */\n\nenum {\n\tTP_EC_BACKLIGHT = 0x31,\n\n\t/* TP_EC_BACKLIGHT bitmasks */\n\tTP_EC_BACKLIGHT_LVLMSK = 0x1F,\n\tTP_EC_BACKLIGHT_CMDMSK = 0xE0,\n\tTP_EC_BACKLIGHT_MAPSW = 0x20,\n};\n\nenum tpacpi_brightness_access_mode {\n\tTPACPI_BRGHT_MODE_AUTO = 0,\t/* Not implemented yet */\n\tTPACPI_BRGHT_MODE_EC,\t\t/* EC control */\n\tTPACPI_BRGHT_MODE_UCMS_STEP,\t/* UCMS step-based control */\n\tTPACPI_BRGHT_MODE_ECNVRAM,\t/* EC control w/ NVRAM store */\n\tTPACPI_BRGHT_MODE_MAX\n};\n\nstatic struct backlight_device *ibm_backlight_device;\n\nstatic enum tpacpi_brightness_access_mode brightness_mode =\n\t\tTPACPI_BRGHT_MODE_MAX;\n\nstatic unsigned int brightness_enable = 2; /* 2 = auto, 0 = no, 1 = yes */\n\nstatic struct mutex brightness_mutex;\n\n/* NVRAM brightness access,\n * call with brightness_mutex held! */\nstatic unsigned int tpacpi_brightness_nvram_get(void)\n{\n\tu8 lnvram;\n\n\tlnvram = (nvram_read_byte(TP_NVRAM_ADDR_BRIGHTNESS)\n\t\t  & TP_NVRAM_MASK_LEVEL_BRIGHTNESS)\n\t\t  >> TP_NVRAM_POS_LEVEL_BRIGHTNESS;\n\tlnvram &= bright_maxlvl;\n\n\treturn lnvram;\n}\n\nstatic void tpacpi_brightness_checkpoint_nvram(void)\n{\n\tu8 lec = 0;\n\tu8 b_nvram;\n\n\tif (brightness_mode != TPACPI_BRGHT_MODE_ECNVRAM)\n\t\treturn;\n\n\tvdbg_printk(TPACPI_DBG_BRGHT,\n\t\t\"trying to checkpoint backlight level to NVRAM...\\n\");\n\n\tif (mutex_lock_killable(&brightness_mutex) < 0)\n\t\treturn;\n\n\tif (unlikely(!acpi_ec_read(TP_EC_BACKLIGHT, &lec)))\n\t\tgoto unlock;\n\tlec &= TP_EC_BACKLIGHT_LVLMSK;\n\tb_nvram = nvram_read_byte(TP_NVRAM_ADDR_BRIGHTNESS);\n\n\tif (lec != ((b_nvram & TP_NVRAM_MASK_LEVEL_BRIGHTNESS)\n\t\t\t     >> TP_NVRAM_POS_LEVEL_BRIGHTNESS)) {\n\t\t/* NVRAM needs update */\n\t\tb_nvram &= ~(TP_NVRAM_MASK_LEVEL_BRIGHTNESS <<\n\t\t\t\tTP_NVRAM_POS_LEVEL_BRIGHTNESS);\n\t\tb_nvram |= lec;\n\t\tnvram_write_byte(b_nvram, TP_NVRAM_ADDR_BRIGHTNESS);\n\t\tdbg_printk(TPACPI_DBG_BRGHT,\n\t\t\t   \"updated NVRAM backlight level to %u (0x%02x)\\n\",\n\t\t\t   (unsigned int) lec, (unsigned int) b_nvram);\n\t} else\n\t\tvdbg_printk(TPACPI_DBG_BRGHT,\n\t\t\t   \"NVRAM backlight level already is %u (0x%02x)\\n\",\n\t\t\t   (unsigned int) lec, (unsigned int) b_nvram);\n\nunlock:\n\tmutex_unlock(&brightness_mutex);\n}\n\n\n/* call with brightness_mutex held! */\nstatic int tpacpi_brightness_get_raw(int *status)\n{\n\tu8 lec = 0;\n\n\tswitch (brightness_mode) {\n\tcase TPACPI_BRGHT_MODE_UCMS_STEP:\n\t\t*status = tpacpi_brightness_nvram_get();\n\t\treturn 0;\n\tcase TPACPI_BRGHT_MODE_EC:\n\tcase TPACPI_BRGHT_MODE_ECNVRAM:\n\t\tif (unlikely(!acpi_ec_read(TP_EC_BACKLIGHT, &lec)))\n\t\t\treturn -EIO;\n\t\t*status = lec;\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n}\n\n/* call with brightness_mutex held! */\n/* do NOT call with illegal backlight level value */\nstatic int tpacpi_brightness_set_ec(unsigned int value)\n{\n\tu8 lec = 0;\n\n\tif (unlikely(!acpi_ec_read(TP_EC_BACKLIGHT, &lec)))\n\t\treturn -EIO;\n\n\tif (unlikely(!acpi_ec_write(TP_EC_BACKLIGHT,\n\t\t\t\t(lec & TP_EC_BACKLIGHT_CMDMSK) |\n\t\t\t\t(value & TP_EC_BACKLIGHT_LVLMSK))))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n/* call with brightness_mutex held! */\nstatic int tpacpi_brightness_set_ucmsstep(unsigned int value)\n{\n\tint cmos_cmd, inc;\n\tunsigned int current_value, i;\n\n\tcurrent_value = tpacpi_brightness_nvram_get();\n\n\tif (value == current_value)\n\t\treturn 0;\n\n\tcmos_cmd = (value > current_value) ?\n\t\t\tTP_CMOS_BRIGHTNESS_UP :\n\t\t\tTP_CMOS_BRIGHTNESS_DOWN;\n\tinc = (value > current_value) ? 1 : -1;\n\n\tfor (i = current_value; i != value; i += inc)\n\t\tif (issue_thinkpad_cmos_command(cmos_cmd))\n\t\t\treturn -EIO;\n\n\treturn 0;\n}\n\n/* May return EINTR which can always be mapped to ERESTARTSYS */\nstatic int brightness_set(unsigned int value)\n{\n\tint res;\n\n\tif (value > bright_maxlvl)\n\t\treturn -EINVAL;\n\n\tvdbg_printk(TPACPI_DBG_BRGHT,\n\t\t\t\"set backlight level to %d\\n\", value);\n\n\tres = mutex_lock_killable(&brightness_mutex);\n\tif (res < 0)\n\t\treturn res;\n\n\tswitch (brightness_mode) {\n\tcase TPACPI_BRGHT_MODE_EC:\n\tcase TPACPI_BRGHT_MODE_ECNVRAM:\n\t\tres = tpacpi_brightness_set_ec(value);\n\t\tbreak;\n\tcase TPACPI_BRGHT_MODE_UCMS_STEP:\n\t\tres = tpacpi_brightness_set_ucmsstep(value);\n\t\tbreak;\n\tdefault:\n\t\tres = -ENXIO;\n\t}\n\n\tmutex_unlock(&brightness_mutex);\n\treturn res;\n}\n\n/* sysfs backlight class ----------------------------------------------- */\n\nstatic int brightness_update_status(struct backlight_device *bd)\n{\n\tunsigned int level =\n\t\t(bd->props.fb_blank == FB_BLANK_UNBLANK &&\n\t\t bd->props.power == FB_BLANK_UNBLANK) ?\n\t\t\t\tbd->props.brightness : 0;\n\n\tdbg_printk(TPACPI_DBG_BRGHT,\n\t\t\t\"backlight: attempt to set level to %d\\n\",\n\t\t\tlevel);\n\n\t/* it is the backlight class's job (caller) to handle\n\t * EINTR and other errors properly */\n\treturn brightness_set(level);\n}\n\nstatic int brightness_get(struct backlight_device *bd)\n{\n\tint status, res;\n\n\tres = mutex_lock_killable(&brightness_mutex);\n\tif (res < 0)\n\t\treturn 0;\n\n\tres = tpacpi_brightness_get_raw(&status);\n\n\tmutex_unlock(&brightness_mutex);\n\n\tif (res < 0)\n\t\treturn 0;\n\n\treturn status & TP_EC_BACKLIGHT_LVLMSK;\n}\n\nstatic void tpacpi_brightness_notify_change(void)\n{\n\tbacklight_force_update(ibm_backlight_device,\n\t\t\t       BACKLIGHT_UPDATE_HOTKEY);\n}\n\nstatic const struct backlight_ops ibm_backlight_data = {\n\t.get_brightness = brightness_get,\n\t.update_status  = brightness_update_status,\n};\n\n/* --------------------------------------------------------------------- */\n\n/*\n * Call _BCL method of video device.  On some ThinkPads this will\n * switch the firmware to the ACPI brightness control mode.\n */\n\nstatic int __init tpacpi_query_bcl_levels(acpi_handle handle)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tstruct acpi_device *device, *child;\n\tint rc;\n\n\tif (acpi_bus_get_device(handle, &device))\n\t\treturn 0;\n\n\trc = 0;\n\tlist_for_each_entry(child, &device->children, node) {\n\t\tacpi_status status = acpi_evaluate_object(child->handle, \"_BCL\",\n\t\t\t\t\t\t\t  NULL, &buffer);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tbuffer.length = ACPI_ALLOCATE_BUFFER;\n\t\t\tcontinue;\n\t\t}\n\n\t\tobj = (union acpi_object *)buffer.pointer;\n\t\tif (!obj || (obj->type != ACPI_TYPE_PACKAGE)) {\n\t\t\tpr_err(\"Unknown _BCL data, please report this to %s\\n\",\n\t\t\t\tTPACPI_MAIL);\n\t\t\trc = 0;\n\t\t} else {\n\t\t\trc = obj->package.count;\n\t\t}\n\t\tbreak;\n\t}\n\n\tkfree(buffer.pointer);\n\treturn rc;\n}\n\n\n/*\n * Returns 0 (no ACPI _BCL or _BCL invalid), or size of brightness map\n */\nstatic unsigned int __init tpacpi_check_std_acpi_brightness_support(void)\n{\n\tacpi_handle video_device;\n\tint bcl_levels = 0;\n\n\ttpacpi_acpi_handle_locate(\"video\", NULL, &video_device);\n\tif (video_device)\n\t\tbcl_levels = tpacpi_query_bcl_levels(video_device);\n\n\ttp_features.bright_acpimode = (bcl_levels > 0);\n\n\treturn (bcl_levels > 2) ? (bcl_levels - 2) : 0;\n}\n\n/*\n * These are only useful for models that have only one possibility\n * of GPU.  If the BIOS model handles both ATI and Intel, don't use\n * these quirks.\n */\n#define TPACPI_BRGHT_Q_NOEC\t0x0001\t/* Must NOT use EC HBRV */\n#define TPACPI_BRGHT_Q_EC\t0x0002  /* Should or must use EC HBRV */\n#define TPACPI_BRGHT_Q_ASK\t0x8000\t/* Ask for user report */\n\nstatic const struct tpacpi_quirk brightness_quirk_table[] __initconst = {\n\t/* Models with ATI GPUs known to require ECNVRAM mode */\n\tTPACPI_Q_IBM('1', 'Y', TPACPI_BRGHT_Q_EC),\t/* T43/p ATI */\n\n\t/* Models with ATI GPUs that can use ECNVRAM */\n\tTPACPI_Q_IBM('1', 'R', TPACPI_BRGHT_Q_EC),\t/* R50,51 T40-42 */\n\tTPACPI_Q_IBM('1', 'Q', TPACPI_BRGHT_Q_ASK|TPACPI_BRGHT_Q_EC),\n\tTPACPI_Q_IBM('7', '6', TPACPI_BRGHT_Q_EC),\t/* R52 */\n\tTPACPI_Q_IBM('7', '8', TPACPI_BRGHT_Q_ASK|TPACPI_BRGHT_Q_EC),\n\n\t/* Models with Intel Extreme Graphics 2 */\n\tTPACPI_Q_IBM('1', 'U', TPACPI_BRGHT_Q_NOEC),\t/* X40 */\n\tTPACPI_Q_IBM('1', 'V', TPACPI_BRGHT_Q_ASK|TPACPI_BRGHT_Q_EC),\n\tTPACPI_Q_IBM('1', 'W', TPACPI_BRGHT_Q_ASK|TPACPI_BRGHT_Q_EC),\n\n\t/* Models with Intel GMA900 */\n\tTPACPI_Q_IBM('7', '0', TPACPI_BRGHT_Q_NOEC),\t/* T43, R52 */\n\tTPACPI_Q_IBM('7', '4', TPACPI_BRGHT_Q_NOEC),\t/* X41 */\n\tTPACPI_Q_IBM('7', '5', TPACPI_BRGHT_Q_NOEC),\t/* X41 Tablet */\n};\n\n/*\n * Returns < 0 for error, otherwise sets tp_features.bright_*\n * and bright_maxlvl.\n */\nstatic void __init tpacpi_detect_brightness_capabilities(void)\n{\n\tunsigned int b;\n\n\tvdbg_printk(TPACPI_DBG_INIT,\n\t\t    \"detecting firmware brightness interface capabilities\\n\");\n\n\t/* we could run a quirks check here (same table used by\n\t * brightness_init) if needed */\n\n\t/*\n\t * We always attempt to detect acpi support, so as to switch\n\t * Lenovo Vista BIOS to ACPI brightness mode even if we are not\n\t * going to publish a backlight interface\n\t */\n\tb = tpacpi_check_std_acpi_brightness_support();\n\tswitch (b) {\n\tcase 16:\n\t\tbright_maxlvl = 15;\n\t\tbreak;\n\tcase 8:\n\tcase 0:\n\t\tbright_maxlvl = 7;\n\t\tbreak;\n\tdefault:\n\t\ttp_features.bright_unkfw = 1;\n\t\tbright_maxlvl = b - 1;\n\t}\n\tpr_debug(\"detected %u brightness levels\\n\", bright_maxlvl + 1);\n}\n\nstatic int __init brightness_init(struct ibm_init_struct *iibm)\n{\n\tstruct backlight_properties props;\n\tint b;\n\tunsigned long quirks;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"initializing brightness subdriver\\n\");\n\n\tmutex_init(&brightness_mutex);\n\n\tquirks = tpacpi_check_quirks(brightness_quirk_table,\n\t\t\t\tARRAY_SIZE(brightness_quirk_table));\n\n\t/* tpacpi_detect_brightness_capabilities() must have run already */\n\n\t/* if it is unknown, we don't handle it: it wouldn't be safe */\n\tif (tp_features.bright_unkfw)\n\t\treturn 1;\n\n\tif (!brightness_enable) {\n\t\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_BRGHT,\n\t\t\t   \"brightness support disabled by module parameter\\n\");\n\t\treturn 1;\n\t}\n\n\tif (acpi_video_get_backlight_type() != acpi_backlight_vendor) {\n\t\tif (brightness_enable > 1) {\n\t\t\tpr_info(\"Standard ACPI backlight interface available, not loading native one\\n\");\n\t\t\treturn 1;\n\t\t} else if (brightness_enable == 1) {\n\t\t\tpr_warn(\"Cannot enable backlight brightness support, ACPI is already handling it.  Refer to the acpi_backlight kernel parameter.\\n\");\n\t\t\treturn 1;\n\t\t}\n\t} else if (!tp_features.bright_acpimode) {\n\t\tpr_notice(\"ACPI backlight interface not available\\n\");\n\t\treturn 1;\n\t}\n\n\tpr_notice(\"ACPI native brightness control enabled\\n\");\n\n\t/*\n\t * Check for module parameter bogosity, note that we\n\t * init brightness_mode to TPACPI_BRGHT_MODE_MAX in order to be\n\t * able to detect \"unspecified\"\n\t */\n\tif (brightness_mode > TPACPI_BRGHT_MODE_MAX)\n\t\treturn -EINVAL;\n\n\t/* TPACPI_BRGHT_MODE_AUTO not implemented yet, just use default */\n\tif (brightness_mode == TPACPI_BRGHT_MODE_AUTO ||\n\t    brightness_mode == TPACPI_BRGHT_MODE_MAX) {\n\t\tif (quirks & TPACPI_BRGHT_Q_EC)\n\t\t\tbrightness_mode = TPACPI_BRGHT_MODE_ECNVRAM;\n\t\telse\n\t\t\tbrightness_mode = TPACPI_BRGHT_MODE_UCMS_STEP;\n\n\t\tdbg_printk(TPACPI_DBG_BRGHT,\n\t\t\t   \"driver auto-selected brightness_mode=%d\\n\",\n\t\t\t   brightness_mode);\n\t}\n\n\t/* Safety */\n\tif (!tpacpi_is_ibm() &&\n\t    (brightness_mode == TPACPI_BRGHT_MODE_ECNVRAM ||\n\t     brightness_mode == TPACPI_BRGHT_MODE_EC))\n\t\treturn -EINVAL;\n\n\tif (tpacpi_brightness_get_raw(&b) < 0)\n\t\treturn 1;\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_PLATFORM;\n\tprops.max_brightness = bright_maxlvl;\n\tprops.brightness = b & TP_EC_BACKLIGHT_LVLMSK;\n\tibm_backlight_device = backlight_device_register(TPACPI_BACKLIGHT_DEV_NAME,\n\t\t\t\t\t\t\t NULL, NULL,\n\t\t\t\t\t\t\t &ibm_backlight_data,\n\t\t\t\t\t\t\t &props);\n\tif (IS_ERR(ibm_backlight_device)) {\n\t\tint rc = PTR_ERR(ibm_backlight_device);\n\t\tibm_backlight_device = NULL;\n\t\tpr_err(\"Could not register backlight device\\n\");\n\t\treturn rc;\n\t}\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_BRGHT,\n\t\t\t\"brightness is supported\\n\");\n\n\tif (quirks & TPACPI_BRGHT_Q_ASK) {\n\t\tpr_notice(\"brightness: will use unverified default: brightness_mode=%d\\n\",\n\t\t\t  brightness_mode);\n\t\tpr_notice(\"brightness: please report to %s whether it works well or not on your ThinkPad\\n\",\n\t\t\t  TPACPI_MAIL);\n\t}\n\n\t/* Added by mistake in early 2007.  Probably useless, but it could\n\t * be working around some unknown firmware problem where the value\n\t * read at startup doesn't match the real hardware state... so leave\n\t * it in place just in case */\n\tbacklight_update_status(ibm_backlight_device);\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_BRGHT,\n\t\t    \"brightness: registering brightness hotkeys as change notification\\n\");\n\ttpacpi_hotkey_driver_mask_set(hotkey_driver_mask\n\t\t\t\t| TP_ACPI_HKEY_BRGHTUP_MASK\n\t\t\t\t| TP_ACPI_HKEY_BRGHTDWN_MASK);\n\treturn 0;\n}\n\nstatic void brightness_suspend(void)\n{\n\ttpacpi_brightness_checkpoint_nvram();\n}\n\nstatic void brightness_shutdown(void)\n{\n\ttpacpi_brightness_checkpoint_nvram();\n}\n\nstatic void brightness_exit(void)\n{\n\tif (ibm_backlight_device) {\n\t\tvdbg_printk(TPACPI_DBG_EXIT | TPACPI_DBG_BRGHT,\n\t\t\t    \"calling backlight_device_unregister()\\n\");\n\t\tbacklight_device_unregister(ibm_backlight_device);\n\t}\n\n\ttpacpi_brightness_checkpoint_nvram();\n}\n\nstatic int brightness_read(struct seq_file *m)\n{\n\tint level;\n\n\tlevel = brightness_get(NULL);\n\tif (level < 0) {\n\t\tseq_printf(m, \"level:\\t\\tunreadable\\n\");\n\t} else {\n\t\tseq_printf(m, \"level:\\t\\t%d\\n\", level);\n\t\tseq_printf(m, \"commands:\\tup, down\\n\");\n\t\tseq_printf(m, \"commands:\\tlevel <level> (<level> is 0-%d)\\n\",\n\t\t\t       bright_maxlvl);\n\t}\n\n\treturn 0;\n}\n\nstatic int brightness_write(char *buf)\n{\n\tint level;\n\tint rc;\n\tchar *cmd;\n\n\tlevel = brightness_get(NULL);\n\tif (level < 0)\n\t\treturn level;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (strlencmp(cmd, \"up\") == 0) {\n\t\t\tif (level < bright_maxlvl)\n\t\t\t\tlevel++;\n\t\t} else if (strlencmp(cmd, \"down\") == 0) {\n\t\t\tif (level > 0)\n\t\t\t\tlevel--;\n\t\t} else if (sscanf(cmd, \"level %d\", &level) == 1 &&\n\t\t\t   level >= 0 && level <= bright_maxlvl) {\n\t\t\t/* new level set */\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\n\ttpacpi_disclose_usertask(\"procfs brightness\",\n\t\t\t\"set level to %d\\n\", level);\n\n\t/*\n\t * Now we know what the final level should be, so we try to set it.\n\t * Doing it this way makes the syscall restartable in case of EINTR\n\t */\n\trc = brightness_set(level);\n\tif (!rc && ibm_backlight_device)\n\t\tbacklight_force_update(ibm_backlight_device,\n\t\t\t\t\tBACKLIGHT_UPDATE_SYSFS);\n\treturn (rc == -EINTR) ? -ERESTARTSYS : rc;\n}\n\nstatic struct ibm_struct brightness_driver_data = {\n\t.name = \"brightness\",\n\t.read = brightness_read,\n\t.write = brightness_write,\n\t.exit = brightness_exit,\n\t.suspend = brightness_suspend,\n\t.shutdown = brightness_shutdown,\n};\n\n/*************************************************************************\n * Volume subdriver\n */\n\n/*\n * IBM ThinkPads have a simple volume controller with MUTE gating.\n * Very early Lenovo ThinkPads follow the IBM ThinkPad spec.\n *\n * Since the *61 series (and probably also the later *60 series), Lenovo\n * ThinkPads only implement the MUTE gate.\n *\n * EC register 0x30\n *   Bit 6: MUTE (1 mutes sound)\n *   Bit 3-0: Volume\n *   Other bits should be zero as far as we know.\n *\n * This is also stored in CMOS NVRAM, byte 0x60, bit 6 (MUTE), and\n * bits 3-0 (volume).  Other bits in NVRAM may have other functions,\n * such as bit 7 which is used to detect repeated presses of MUTE,\n * and we leave them unchanged.\n *\n * On newer Lenovo ThinkPads, the EC can automatically change the volume\n * in response to user input.  Unfortunately, this rarely works well.\n * The laptop changes the state of its internal MUTE gate and, on some\n * models, sends KEY_MUTE, causing any user code that responds to the\n * mute button to get confused.  The hardware MUTE gate is also\n * unnecessary, since user code can handle the mute button without\n * kernel or EC help.\n *\n * To avoid confusing userspace, we simply disable all EC-based mute\n * and volume controls when possible.\n */\n\n#ifdef CONFIG_THINKPAD_ACPI_ALSA_SUPPORT\n\n#define TPACPI_ALSA_DRVNAME  \"ThinkPad EC\"\n#define TPACPI_ALSA_SHRTNAME \"ThinkPad Console Audio Control\"\n#define TPACPI_ALSA_MIXERNAME TPACPI_ALSA_SHRTNAME\n\n#if SNDRV_CARDS <= 32\n#define DEFAULT_ALSA_IDX\t\t~((1 << (SNDRV_CARDS - 3)) - 1)\n#else\n#define DEFAULT_ALSA_IDX\t\t~((1 << (32 - 3)) - 1)\n#endif\nstatic int alsa_index = DEFAULT_ALSA_IDX; /* last three slots */\nstatic char *alsa_id = \"ThinkPadEC\";\nstatic bool alsa_enable = SNDRV_DEFAULT_ENABLE1;\n\nstruct tpacpi_alsa_data {\n\tstruct snd_card *card;\n\tstruct snd_ctl_elem_id *ctl_mute_id;\n\tstruct snd_ctl_elem_id *ctl_vol_id;\n};\n\nstatic struct snd_card *alsa_card;\n\nenum {\n\tTP_EC_AUDIO = 0x30,\n\n\t/* TP_EC_AUDIO bits */\n\tTP_EC_AUDIO_MUTESW = 6,\n\n\t/* TP_EC_AUDIO bitmasks */\n\tTP_EC_AUDIO_LVL_MSK = 0x0F,\n\tTP_EC_AUDIO_MUTESW_MSK = (1 << TP_EC_AUDIO_MUTESW),\n\n\t/* Maximum volume */\n\tTP_EC_VOLUME_MAX = 14,\n};\n\nenum tpacpi_volume_access_mode {\n\tTPACPI_VOL_MODE_AUTO = 0,\t/* Not implemented yet */\n\tTPACPI_VOL_MODE_EC,\t\t/* Pure EC control */\n\tTPACPI_VOL_MODE_UCMS_STEP,\t/* UCMS step-based control: N/A */\n\tTPACPI_VOL_MODE_ECNVRAM,\t/* EC control w/ NVRAM store */\n\tTPACPI_VOL_MODE_MAX\n};\n\nenum tpacpi_volume_capabilities {\n\tTPACPI_VOL_CAP_AUTO = 0,\t/* Use white/blacklist */\n\tTPACPI_VOL_CAP_VOLMUTE,\t\t/* Output vol and mute */\n\tTPACPI_VOL_CAP_MUTEONLY,\t/* Output mute only */\n\tTPACPI_VOL_CAP_MAX\n};\n\nenum tpacpi_mute_btn_mode {\n\tTP_EC_MUTE_BTN_LATCH  = 0,\t/* Mute mutes; up/down unmutes */\n\t/* We don't know what mode 1 is. */\n\tTP_EC_MUTE_BTN_NONE   = 2,\t/* Mute and up/down are just keys */\n\tTP_EC_MUTE_BTN_TOGGLE = 3,\t/* Mute toggles; up/down unmutes */\n};\n\nstatic enum tpacpi_volume_access_mode volume_mode =\n\tTPACPI_VOL_MODE_MAX;\n\nstatic enum tpacpi_volume_capabilities volume_capabilities;\nstatic bool volume_control_allowed;\nstatic bool software_mute_requested = true;\nstatic bool software_mute_active;\nstatic int software_mute_orig_mode;\n\n/*\n * Used to syncronize writers to TP_EC_AUDIO and\n * TP_NVRAM_ADDR_MIXER, as we need to do read-modify-write\n */\nstatic struct mutex volume_mutex;\n\nstatic void tpacpi_volume_checkpoint_nvram(void)\n{\n\tu8 lec = 0;\n\tu8 b_nvram;\n\tu8 ec_mask;\n\n\tif (volume_mode != TPACPI_VOL_MODE_ECNVRAM)\n\t\treturn;\n\tif (!volume_control_allowed)\n\t\treturn;\n\tif (software_mute_active)\n\t\treturn;\n\n\tvdbg_printk(TPACPI_DBG_MIXER,\n\t\t\"trying to checkpoint mixer state to NVRAM...\\n\");\n\n\tif (tp_features.mixer_no_level_control)\n\t\tec_mask = TP_EC_AUDIO_MUTESW_MSK;\n\telse\n\t\tec_mask = TP_EC_AUDIO_MUTESW_MSK | TP_EC_AUDIO_LVL_MSK;\n\n\tif (mutex_lock_killable(&volume_mutex) < 0)\n\t\treturn;\n\n\tif (unlikely(!acpi_ec_read(TP_EC_AUDIO, &lec)))\n\t\tgoto unlock;\n\tlec &= ec_mask;\n\tb_nvram = nvram_read_byte(TP_NVRAM_ADDR_MIXER);\n\n\tif (lec != (b_nvram & ec_mask)) {\n\t\t/* NVRAM needs update */\n\t\tb_nvram &= ~ec_mask;\n\t\tb_nvram |= lec;\n\t\tnvram_write_byte(b_nvram, TP_NVRAM_ADDR_MIXER);\n\t\tdbg_printk(TPACPI_DBG_MIXER,\n\t\t\t   \"updated NVRAM mixer status to 0x%02x (0x%02x)\\n\",\n\t\t\t   (unsigned int) lec, (unsigned int) b_nvram);\n\t} else {\n\t\tvdbg_printk(TPACPI_DBG_MIXER,\n\t\t\t   \"NVRAM mixer status already is 0x%02x (0x%02x)\\n\",\n\t\t\t   (unsigned int) lec, (unsigned int) b_nvram);\n\t}\n\nunlock:\n\tmutex_unlock(&volume_mutex);\n}\n\nstatic int volume_get_status_ec(u8 *status)\n{\n\tu8 s;\n\n\tif (!acpi_ec_read(TP_EC_AUDIO, &s))\n\t\treturn -EIO;\n\n\t*status = s;\n\n\tdbg_printk(TPACPI_DBG_MIXER, \"status 0x%02x\\n\", s);\n\n\treturn 0;\n}\n\nstatic int volume_get_status(u8 *status)\n{\n\treturn volume_get_status_ec(status);\n}\n\nstatic int volume_set_status_ec(const u8 status)\n{\n\tif (!acpi_ec_write(TP_EC_AUDIO, status))\n\t\treturn -EIO;\n\n\tdbg_printk(TPACPI_DBG_MIXER, \"set EC mixer to 0x%02x\\n\", status);\n\n\t/*\n\t * On X200s, and possibly on others, it can take a while for\n\t * reads to become correct.\n\t */\n\tmsleep(1);\n\n\treturn 0;\n}\n\nstatic int volume_set_status(const u8 status)\n{\n\treturn volume_set_status_ec(status);\n}\n\n/* returns < 0 on error, 0 on no change, 1 on change */\nstatic int __volume_set_mute_ec(const bool mute)\n{\n\tint rc;\n\tu8 s, n;\n\n\tif (mutex_lock_killable(&volume_mutex) < 0)\n\t\treturn -EINTR;\n\n\trc = volume_get_status_ec(&s);\n\tif (rc)\n\t\tgoto unlock;\n\n\tn = (mute) ? s | TP_EC_AUDIO_MUTESW_MSK :\n\t\t     s & ~TP_EC_AUDIO_MUTESW_MSK;\n\n\tif (n != s) {\n\t\trc = volume_set_status_ec(n);\n\t\tif (!rc)\n\t\t\trc = 1;\n\t}\n\nunlock:\n\tmutex_unlock(&volume_mutex);\n\treturn rc;\n}\n\nstatic int volume_alsa_set_mute(const bool mute)\n{\n\tdbg_printk(TPACPI_DBG_MIXER, \"ALSA: trying to %smute\\n\",\n\t\t   (mute) ? \"\" : \"un\");\n\treturn __volume_set_mute_ec(mute);\n}\n\nstatic int volume_set_mute(const bool mute)\n{\n\tint rc;\n\n\tdbg_printk(TPACPI_DBG_MIXER, \"trying to %smute\\n\",\n\t\t   (mute) ? \"\" : \"un\");\n\n\trc = __volume_set_mute_ec(mute);\n\treturn (rc < 0) ? rc : 0;\n}\n\n/* returns < 0 on error, 0 on no change, 1 on change */\nstatic int __volume_set_volume_ec(const u8 vol)\n{\n\tint rc;\n\tu8 s, n;\n\n\tif (vol > TP_EC_VOLUME_MAX)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_killable(&volume_mutex) < 0)\n\t\treturn -EINTR;\n\n\trc = volume_get_status_ec(&s);\n\tif (rc)\n\t\tgoto unlock;\n\n\tn = (s & ~TP_EC_AUDIO_LVL_MSK) | vol;\n\n\tif (n != s) {\n\t\trc = volume_set_status_ec(n);\n\t\tif (!rc)\n\t\t\trc = 1;\n\t}\n\nunlock:\n\tmutex_unlock(&volume_mutex);\n\treturn rc;\n}\n\nstatic int volume_set_software_mute(bool startup)\n{\n\tint result;\n\n\tif (!tpacpi_is_lenovo())\n\t\treturn -ENODEV;\n\n\tif (startup) {\n\t\tif (!acpi_evalf(ec_handle, &software_mute_orig_mode,\n\t\t\t\t\"HAUM\", \"qd\"))\n\t\t\treturn -EIO;\n\n\t\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\n\t\t\t    \"Initial HAUM setting was %d\\n\",\n\t\t\t    software_mute_orig_mode);\n\t}\n\n\tif (!acpi_evalf(ec_handle, &result, \"SAUM\", \"qdd\",\n\t\t\t(int)TP_EC_MUTE_BTN_NONE))\n\t\treturn -EIO;\n\n\tif (result != TP_EC_MUTE_BTN_NONE)\n\t\tpr_warn(\"Unexpected SAUM result %d\\n\",\n\t\t\tresult);\n\n\t/*\n\t * In software mute mode, the standard codec controls take\n\t * precendence, so we unmute the ThinkPad HW switch at\n\t * startup.  Just on case there are SAUM-capable ThinkPads\n\t * with level controls, set max HW volume as well.\n\t */\n\tif (tp_features.mixer_no_level_control)\n\t\tresult = volume_set_mute(false);\n\telse\n\t\tresult = volume_set_status(TP_EC_VOLUME_MAX);\n\n\tif (result != 0)\n\t\tpr_warn(\"Failed to unmute the HW mute switch\\n\");\n\n\treturn 0;\n}\n\nstatic void volume_exit_software_mute(void)\n{\n\tint r;\n\n\tif (!acpi_evalf(ec_handle, &r, \"SAUM\", \"qdd\", software_mute_orig_mode)\n\t    || r != software_mute_orig_mode)\n\t\tpr_warn(\"Failed to restore mute mode\\n\");\n}\n\nstatic int volume_alsa_set_volume(const u8 vol)\n{\n\tdbg_printk(TPACPI_DBG_MIXER,\n\t\t   \"ALSA: trying to set volume level to %hu\\n\", vol);\n\treturn __volume_set_volume_ec(vol);\n}\n\nstatic void volume_alsa_notify_change(void)\n{\n\tstruct tpacpi_alsa_data *d;\n\n\tif (alsa_card && alsa_card->private_data) {\n\t\td = alsa_card->private_data;\n\t\tif (d->ctl_mute_id)\n\t\t\tsnd_ctl_notify(alsa_card,\n\t\t\t\t\tSNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t\td->ctl_mute_id);\n\t\tif (d->ctl_vol_id)\n\t\t\tsnd_ctl_notify(alsa_card,\n\t\t\t\t\tSNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t\td->ctl_vol_id);\n\t}\n}\n\nstatic int volume_alsa_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = TP_EC_VOLUME_MAX;\n\treturn 0;\n}\n\nstatic int volume_alsa_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tu8 s;\n\tint rc;\n\n\trc = volume_get_status(&s);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tucontrol->value.integer.value[0] = s & TP_EC_AUDIO_LVL_MSK;\n\treturn 0;\n}\n\nstatic int volume_alsa_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\ttpacpi_disclose_usertask(\"ALSA\", \"set volume to %ld\\n\",\n\t\t\t\t ucontrol->value.integer.value[0]);\n\treturn volume_alsa_set_volume(ucontrol->value.integer.value[0]);\n}\n\n#define volume_alsa_mute_info snd_ctl_boolean_mono_info\n\nstatic int volume_alsa_mute_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tu8 s;\n\tint rc;\n\n\trc = volume_get_status(&s);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tucontrol->value.integer.value[0] =\n\t\t\t\t(s & TP_EC_AUDIO_MUTESW_MSK) ? 0 : 1;\n\treturn 0;\n}\n\nstatic int volume_alsa_mute_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\ttpacpi_disclose_usertask(\"ALSA\", \"%smute\\n\",\n\t\t\t\t ucontrol->value.integer.value[0] ?\n\t\t\t\t\t\"un\" : \"\");\n\treturn volume_alsa_set_mute(!ucontrol->value.integer.value[0]);\n}\n\nstatic struct snd_kcontrol_new volume_alsa_control_vol __initdata = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Console Playback Volume\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t.info = volume_alsa_vol_info,\n\t.get = volume_alsa_vol_get,\n};\n\nstatic struct snd_kcontrol_new volume_alsa_control_mute __initdata = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Console Playback Switch\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t.info = volume_alsa_mute_info,\n\t.get = volume_alsa_mute_get,\n};\n\nstatic void volume_suspend(void)\n{\n\ttpacpi_volume_checkpoint_nvram();\n}\n\nstatic void volume_resume(void)\n{\n\tif (software_mute_active) {\n\t\tif (volume_set_software_mute(false) < 0)\n\t\t\tpr_warn(\"Failed to restore software mute\\n\");\n\t} else {\n\t\tvolume_alsa_notify_change();\n\t}\n}\n\nstatic void volume_shutdown(void)\n{\n\ttpacpi_volume_checkpoint_nvram();\n}\n\nstatic void volume_exit(void)\n{\n\tif (alsa_card) {\n\t\tsnd_card_free(alsa_card);\n\t\talsa_card = NULL;\n\t}\n\n\ttpacpi_volume_checkpoint_nvram();\n\n\tif (software_mute_active)\n\t\tvolume_exit_software_mute();\n}\n\nstatic int __init volume_create_alsa_mixer(void)\n{\n\tstruct snd_card *card;\n\tstruct tpacpi_alsa_data *data;\n\tstruct snd_kcontrol *ctl_vol;\n\tstruct snd_kcontrol *ctl_mute;\n\tint rc;\n\n\trc = snd_card_new(&tpacpi_pdev->dev,\n\t\t\t  alsa_index, alsa_id, THIS_MODULE,\n\t\t\t  sizeof(struct tpacpi_alsa_data), &card);\n\tif (rc < 0 || !card) {\n\t\tpr_err(\"Failed to create ALSA card structures: %d\\n\", rc);\n\t\treturn 1;\n\t}\n\n\tBUG_ON(!card->private_data);\n\tdata = card->private_data;\n\tdata->card = card;\n\n\tstrlcpy(card->driver, TPACPI_ALSA_DRVNAME,\n\t\tsizeof(card->driver));\n\tstrlcpy(card->shortname, TPACPI_ALSA_SHRTNAME,\n\t\tsizeof(card->shortname));\n\tsnprintf(card->mixername, sizeof(card->mixername), \"ThinkPad EC %s\",\n\t\t (thinkpad_id.ec_version_str) ?\n\t\t\tthinkpad_id.ec_version_str : \"(unknown)\");\n\tsnprintf(card->longname, sizeof(card->longname),\n\t\t \"%s at EC reg 0x%02x, fw %s\", card->shortname, TP_EC_AUDIO,\n\t\t (thinkpad_id.ec_version_str) ?\n\t\t\tthinkpad_id.ec_version_str : \"unknown\");\n\n\tif (volume_control_allowed) {\n\t\tvolume_alsa_control_vol.put = volume_alsa_vol_put;\n\t\tvolume_alsa_control_vol.access =\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_READWRITE;\n\n\t\tvolume_alsa_control_mute.put = volume_alsa_mute_put;\n\t\tvolume_alsa_control_mute.access =\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_READWRITE;\n\t}\n\n\tif (!tp_features.mixer_no_level_control) {\n\t\tctl_vol = snd_ctl_new1(&volume_alsa_control_vol, NULL);\n\t\trc = snd_ctl_add(card, ctl_vol);\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"Failed to create ALSA volume control: %d\\n\",\n\t\t\t       rc);\n\t\t\tgoto err_exit;\n\t\t}\n\t\tdata->ctl_vol_id = &ctl_vol->id;\n\t}\n\n\tctl_mute = snd_ctl_new1(&volume_alsa_control_mute, NULL);\n\trc = snd_ctl_add(card, ctl_mute);\n\tif (rc < 0) {\n\t\tpr_err(\"Failed to create ALSA mute control: %d\\n\", rc);\n\t\tgoto err_exit;\n\t}\n\tdata->ctl_mute_id = &ctl_mute->id;\n\n\trc = snd_card_register(card);\n\tif (rc < 0) {\n\t\tpr_err(\"Failed to register ALSA card: %d\\n\", rc);\n\t\tgoto err_exit;\n\t}\n\n\talsa_card = card;\n\treturn 0;\n\nerr_exit:\n\tsnd_card_free(card);\n\treturn 1;\n}\n\n#define TPACPI_VOL_Q_MUTEONLY\t0x0001\t/* Mute-only control available */\n#define TPACPI_VOL_Q_LEVEL\t0x0002  /* Volume control available */\n\nstatic const struct tpacpi_quirk volume_quirk_table[] __initconst = {\n\t/* Whitelist volume level on all IBM by default */\n\t{ .vendor = PCI_VENDOR_ID_IBM,\n\t  .bios   = TPACPI_MATCH_ANY,\n\t  .ec     = TPACPI_MATCH_ANY,\n\t  .quirks = TPACPI_VOL_Q_LEVEL },\n\n\t/* Lenovo models with volume control (needs confirmation) */\n\tTPACPI_QEC_LNV('7', 'C', TPACPI_VOL_Q_LEVEL), /* R60/i */\n\tTPACPI_QEC_LNV('7', 'E', TPACPI_VOL_Q_LEVEL), /* R60e/i */\n\tTPACPI_QEC_LNV('7', '9', TPACPI_VOL_Q_LEVEL), /* T60/p */\n\tTPACPI_QEC_LNV('7', 'B', TPACPI_VOL_Q_LEVEL), /* X60/s */\n\tTPACPI_QEC_LNV('7', 'J', TPACPI_VOL_Q_LEVEL), /* X60t */\n\tTPACPI_QEC_LNV('7', '7', TPACPI_VOL_Q_LEVEL), /* Z60 */\n\tTPACPI_QEC_LNV('7', 'F', TPACPI_VOL_Q_LEVEL), /* Z61 */\n\n\t/* Whitelist mute-only on all Lenovo by default */\n\t{ .vendor = PCI_VENDOR_ID_LENOVO,\n\t  .bios   = TPACPI_MATCH_ANY,\n\t  .ec\t  = TPACPI_MATCH_ANY,\n\t  .quirks = TPACPI_VOL_Q_MUTEONLY }\n};\n\nstatic int __init volume_init(struct ibm_init_struct *iibm)\n{\n\tunsigned long quirks;\n\tint rc;\n\n\tvdbg_printk(TPACPI_DBG_INIT, \"initializing volume subdriver\\n\");\n\n\tmutex_init(&volume_mutex);\n\n\t/*\n\t * Check for module parameter bogosity, note that we\n\t * init volume_mode to TPACPI_VOL_MODE_MAX in order to be\n\t * able to detect \"unspecified\"\n\t */\n\tif (volume_mode > TPACPI_VOL_MODE_MAX)\n\t\treturn -EINVAL;\n\n\tif (volume_mode == TPACPI_VOL_MODE_UCMS_STEP) {\n\t\tpr_err(\"UCMS step volume mode not implemented, please contact %s\\n\",\n\t\t       TPACPI_MAIL);\n\t\treturn 1;\n\t}\n\n\tif (volume_capabilities >= TPACPI_VOL_CAP_MAX)\n\t\treturn -EINVAL;\n\n\t/*\n\t * The ALSA mixer is our primary interface.\n\t * When disabled, don't install the subdriver at all\n\t */\n\tif (!alsa_enable) {\n\t\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\n\t\t\t    \"ALSA mixer disabled by parameter, not loading volume subdriver...\\n\");\n\t\treturn 1;\n\t}\n\n\tquirks = tpacpi_check_quirks(volume_quirk_table,\n\t\t\t\t     ARRAY_SIZE(volume_quirk_table));\n\n\tswitch (volume_capabilities) {\n\tcase TPACPI_VOL_CAP_AUTO:\n\t\tif (quirks & TPACPI_VOL_Q_MUTEONLY)\n\t\t\ttp_features.mixer_no_level_control = 1;\n\t\telse if (quirks & TPACPI_VOL_Q_LEVEL)\n\t\t\ttp_features.mixer_no_level_control = 0;\n\t\telse\n\t\t\treturn 1; /* no mixer */\n\t\tbreak;\n\tcase TPACPI_VOL_CAP_VOLMUTE:\n\t\ttp_features.mixer_no_level_control = 0;\n\t\tbreak;\n\tcase TPACPI_VOL_CAP_MUTEONLY:\n\t\ttp_features.mixer_no_level_control = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\tif (volume_capabilities != TPACPI_VOL_CAP_AUTO)\n\t\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\n\t\t\t\t\"using user-supplied volume_capabilities=%d\\n\",\n\t\t\t\tvolume_capabilities);\n\n\tif (volume_mode == TPACPI_VOL_MODE_AUTO ||\n\t    volume_mode == TPACPI_VOL_MODE_MAX) {\n\t\tvolume_mode = TPACPI_VOL_MODE_ECNVRAM;\n\n\t\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\n\t\t\t\t\"driver auto-selected volume_mode=%d\\n\",\n\t\t\t\tvolume_mode);\n\t} else {\n\t\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\n\t\t\t\t\"using user-supplied volume_mode=%d\\n\",\n\t\t\t\tvolume_mode);\n\t}\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\n\t\t\t\"mute is supported, volume control is %s\\n\",\n\t\t\tstr_supported(!tp_features.mixer_no_level_control));\n\n\tif (software_mute_requested && volume_set_software_mute(true) == 0) {\n\t\tsoftware_mute_active = true;\n\t} else {\n\t\trc = volume_create_alsa_mixer();\n\t\tif (rc) {\n\t\t\tpr_err(\"Could not create the ALSA mixer interface\\n\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tpr_info(\"Console audio control enabled, mode: %s\\n\",\n\t\t\t(volume_control_allowed) ?\n\t\t\t\t\"override (read/write)\" :\n\t\t\t\t\"monitor (read only)\");\n\t}\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_MIXER,\n\t\t\"registering volume hotkeys as change notification\\n\");\n\ttpacpi_hotkey_driver_mask_set(hotkey_driver_mask\n\t\t\t| TP_ACPI_HKEY_VOLUP_MASK\n\t\t\t| TP_ACPI_HKEY_VOLDWN_MASK\n\t\t\t| TP_ACPI_HKEY_MUTE_MASK);\n\n\treturn 0;\n}\n\nstatic int volume_read(struct seq_file *m)\n{\n\tu8 status;\n\n\tif (volume_get_status(&status) < 0) {\n\t\tseq_printf(m, \"level:\\t\\tunreadable\\n\");\n\t} else {\n\t\tif (tp_features.mixer_no_level_control)\n\t\t\tseq_printf(m, \"level:\\t\\tunsupported\\n\");\n\t\telse\n\t\t\tseq_printf(m, \"level:\\t\\t%d\\n\",\n\t\t\t\t\tstatus & TP_EC_AUDIO_LVL_MSK);\n\n\t\tseq_printf(m, \"mute:\\t\\t%s\\n\",\n\t\t\t\tonoff(status, TP_EC_AUDIO_MUTESW));\n\n\t\tif (volume_control_allowed) {\n\t\t\tseq_printf(m, \"commands:\\tunmute, mute\\n\");\n\t\t\tif (!tp_features.mixer_no_level_control) {\n\t\t\t\tseq_printf(m, \"commands:\\tup, down\\n\");\n\t\t\t\tseq_printf(m, \"commands:\\tlevel <level> (<level> is 0-%d)\\n\",\n\t\t\t\t\t      TP_EC_VOLUME_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int volume_write(char *buf)\n{\n\tu8 s;\n\tu8 new_level, new_mute;\n\tint l;\n\tchar *cmd;\n\tint rc;\n\n\t/*\n\t * We do allow volume control at driver startup, so that the\n\t * user can set initial state through the volume=... parameter hack.\n\t */\n\tif (!volume_control_allowed && tpacpi_lifecycle != TPACPI_LIFE_INIT) {\n\t\tif (unlikely(!tp_warned.volume_ctrl_forbidden)) {\n\t\t\ttp_warned.volume_ctrl_forbidden = 1;\n\t\t\tpr_notice(\"Console audio control in monitor mode, changes are not allowed\\n\");\n\t\t\tpr_notice(\"Use the volume_control=1 module parameter to enable volume control\\n\");\n\t\t}\n\t\treturn -EPERM;\n\t}\n\n\trc = volume_get_status(&s);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tnew_level = s & TP_EC_AUDIO_LVL_MSK;\n\tnew_mute  = s & TP_EC_AUDIO_MUTESW_MSK;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tif (!tp_features.mixer_no_level_control) {\n\t\t\tif (strlencmp(cmd, \"up\") == 0) {\n\t\t\t\tif (new_mute)\n\t\t\t\t\tnew_mute = 0;\n\t\t\t\telse if (new_level < TP_EC_VOLUME_MAX)\n\t\t\t\t\tnew_level++;\n\t\t\t\tcontinue;\n\t\t\t} else if (strlencmp(cmd, \"down\") == 0) {\n\t\t\t\tif (new_mute)\n\t\t\t\t\tnew_mute = 0;\n\t\t\t\telse if (new_level > 0)\n\t\t\t\t\tnew_level--;\n\t\t\t\tcontinue;\n\t\t\t} else if (sscanf(cmd, \"level %u\", &l) == 1 &&\n\t\t\t\t   l >= 0 && l <= TP_EC_VOLUME_MAX) {\n\t\t\t\t\tnew_level = l;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (strlencmp(cmd, \"mute\") == 0)\n\t\t\tnew_mute = TP_EC_AUDIO_MUTESW_MSK;\n\t\telse if (strlencmp(cmd, \"unmute\") == 0)\n\t\t\tnew_mute = 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tp_features.mixer_no_level_control) {\n\t\ttpacpi_disclose_usertask(\"procfs volume\", \"%smute\\n\",\n\t\t\t\t\tnew_mute ? \"\" : \"un\");\n\t\trc = volume_set_mute(!!new_mute);\n\t} else {\n\t\ttpacpi_disclose_usertask(\"procfs volume\",\n\t\t\t\t\t\"%smute and set level to %d\\n\",\n\t\t\t\t\tnew_mute ? \"\" : \"un\", new_level);\n\t\trc = volume_set_status(new_mute | new_level);\n\t}\n\tvolume_alsa_notify_change();\n\n\treturn (rc == -EINTR) ? -ERESTARTSYS : rc;\n}\n\nstatic struct ibm_struct volume_driver_data = {\n\t.name = \"volume\",\n\t.read = volume_read,\n\t.write = volume_write,\n\t.exit = volume_exit,\n\t.suspend = volume_suspend,\n\t.resume = volume_resume,\n\t.shutdown = volume_shutdown,\n};\n\n#else /* !CONFIG_THINKPAD_ACPI_ALSA_SUPPORT */\n\n#define alsa_card NULL\n\nstatic inline void volume_alsa_notify_change(void)\n{\n}\n\nstatic int __init volume_init(struct ibm_init_struct *iibm)\n{\n\tpr_info(\"volume: disabled as there is no ALSA support in this kernel\\n\");\n\n\treturn 1;\n}\n\nstatic struct ibm_struct volume_driver_data = {\n\t.name = \"volume\",\n};\n\n#endif /* CONFIG_THINKPAD_ACPI_ALSA_SUPPORT */\n\n/*************************************************************************\n * Fan subdriver\n */\n\n/*\n * FAN ACCESS MODES\n *\n * TPACPI_FAN_RD_ACPI_GFAN:\n * \tACPI GFAN method: returns fan level\n *\n * \tsee TPACPI_FAN_WR_ACPI_SFAN\n * \tEC 0x2f (HFSP) not available if GFAN exists\n *\n * TPACPI_FAN_WR_ACPI_SFAN:\n * \tACPI SFAN method: sets fan level, 0 (stop) to 7 (max)\n *\n * \tEC 0x2f (HFSP) might be available *for reading*, but do not use\n * \tit for writing.\n *\n * TPACPI_FAN_WR_TPEC:\n * \tThinkPad EC register 0x2f (HFSP): fan control loop mode\n * \tSupported on almost all ThinkPads\n *\n * \tFan speed changes of any sort (including those caused by the\n * \tdisengaged mode) are usually done slowly by the firmware as the\n * \tmaximum amount of fan duty cycle change per second seems to be\n * \tlimited.\n *\n * \tReading is not available if GFAN exists.\n * \tWriting is not available if SFAN exists.\n *\n * \tBits\n *\t 7\tautomatic mode engaged;\n *  \t\t(default operation mode of the ThinkPad)\n * \t\tfan level is ignored in this mode.\n *\t 6\tfull speed mode (takes precedence over bit 7);\n *\t\tnot available on all thinkpads.  May disable\n *\t\tthe tachometer while the fan controller ramps up\n *\t\tthe speed (which can take up to a few *minutes*).\n *\t\tSpeeds up fan to 100% duty-cycle, which is far above\n *\t\tthe standard RPM levels.  It is not impossible that\n *\t\tit could cause hardware damage.\n *\t5-3\tunused in some models.  Extra bits for fan level\n *\t\tin others, but still useless as all values above\n *\t\t7 map to the same speed as level 7 in these models.\n *\t2-0\tfan level (0..7 usually)\n *\t\t\t0x00 = stop\n * \t\t\t0x07 = max (set when temperatures critical)\n * \t\tSome ThinkPads may have other levels, see\n * \t\tTPACPI_FAN_WR_ACPI_FANS (X31/X40/X41)\n *\n *\tFIRMWARE BUG: on some models, EC 0x2f might not be initialized at\n *\tboot. Apparently the EC does not initialize it, so unless ACPI DSDT\n *\tdoes so, its initial value is meaningless (0x07).\n *\n *\tFor firmware bugs, refer to:\n *\thttps://thinkwiki.org/wiki/Embedded_Controller_Firmware#Firmware_Issues\n *\n * \t----\n *\n *\tThinkPad EC register 0x84 (LSB), 0x85 (MSB):\n *\tMain fan tachometer reading (in RPM)\n *\n *\tThis register is present on all ThinkPads with a new-style EC, and\n *\tit is known not to be present on the A21m/e, and T22, as there is\n *\tsomething else in offset 0x84 according to the ACPI DSDT.  Other\n *\tThinkPads from this same time period (and earlier) probably lack the\n *\ttachometer as well.\n *\n *\tUnfortunately a lot of ThinkPads with new-style ECs but whose firmware\n *\twas never fixed by IBM to report the EC firmware version string\n *\tprobably support the tachometer (like the early X models), so\n *\tdetecting it is quite hard.  We need more data to know for sure.\n *\n *\tFIRMWARE BUG: always read 0x84 first, otherwise incorrect readings\n *\tmight result.\n *\n *\tFIRMWARE BUG: may go stale while the EC is switching to full speed\n *\tmode.\n *\n *\tFor firmware bugs, refer to:\n *\thttps://thinkwiki.org/wiki/Embedded_Controller_Firmware#Firmware_Issues\n *\n *\t----\n *\n *\tThinkPad EC register 0x31 bit 0 (only on select models)\n *\n *\tWhen bit 0 of EC register 0x31 is zero, the tachometer registers\n *\tshow the speed of the main fan.  When bit 0 of EC register 0x31\n *\tis one, the tachometer registers show the speed of the auxiliary\n *\tfan.\n *\n *\tFan control seems to affect both fans, regardless of the state\n *\tof this bit.\n *\n *\tSo far, only the firmware for the X60/X61 non-tablet versions\n *\tseem to support this (firmware TP-7M).\n *\n * TPACPI_FAN_WR_ACPI_FANS:\n *\tThinkPad X31, X40, X41.  Not available in the X60.\n *\n *\tFANS ACPI handle: takes three arguments: low speed, medium speed,\n *\thigh speed.  ACPI DSDT seems to map these three speeds to levels\n *\tas follows: STOP LOW LOW MED MED HIGH HIGH HIGH HIGH\n *\t(this map is stored on FAN0..FAN8 as \"0,1,1,2,2,3,3,3,3\")\n *\n * \tThe speeds are stored on handles\n * \t(FANA:FAN9), (FANC:FANB), (FANE:FAND).\n *\n * \tThere are three default speed sets, accessible as handles:\n * \tFS1L,FS1M,FS1H; FS2L,FS2M,FS2H; FS3L,FS3M,FS3H\n *\n * \tACPI DSDT switches which set is in use depending on various\n * \tfactors.\n *\n * \tTPACPI_FAN_WR_TPEC is also available and should be used to\n * \tcommand the fan.  The X31/X40/X41 seems to have 8 fan levels,\n * \tbut the ACPI tables just mention level 7.\n */\n\nenum {\t\t\t\t\t/* Fan control constants */\n\tfan_status_offset = 0x2f,\t/* EC register 0x2f */\n\tfan_rpm_offset = 0x84,\t\t/* EC register 0x84: LSB, 0x85 MSB (RPM)\n\t\t\t\t\t * 0x84 must be read before 0x85 */\n\tfan_select_offset = 0x31,\t/* EC register 0x31 (Firmware 7M)\n\t\t\t\t\t   bit 0 selects which fan is active */\n\n\tTP_EC_FAN_FULLSPEED = 0x40,\t/* EC fan mode: full speed */\n\tTP_EC_FAN_AUTO\t    = 0x80,\t/* EC fan mode: auto fan control */\n\n\tTPACPI_FAN_LAST_LEVEL = 0x100,\t/* Use cached last-seen fan level */\n};\n\nenum fan_status_access_mode {\n\tTPACPI_FAN_NONE = 0,\t\t/* No fan status or control */\n\tTPACPI_FAN_RD_ACPI_GFAN,\t/* Use ACPI GFAN */\n\tTPACPI_FAN_RD_TPEC,\t\t/* Use ACPI EC regs 0x2f, 0x84-0x85 */\n};\n\nenum fan_control_access_mode {\n\tTPACPI_FAN_WR_NONE = 0,\t\t/* No fan control */\n\tTPACPI_FAN_WR_ACPI_SFAN,\t/* Use ACPI SFAN */\n\tTPACPI_FAN_WR_TPEC,\t\t/* Use ACPI EC reg 0x2f */\n\tTPACPI_FAN_WR_ACPI_FANS,\t/* Use ACPI FANS and EC reg 0x2f */\n};\n\nenum fan_control_commands {\n\tTPACPI_FAN_CMD_SPEED \t= 0x0001,\t/* speed command */\n\tTPACPI_FAN_CMD_LEVEL \t= 0x0002,\t/* level command  */\n\tTPACPI_FAN_CMD_ENABLE\t= 0x0004,\t/* enable/disable cmd,\n\t\t\t\t\t\t * and also watchdog cmd */\n};\n\nstatic bool fan_control_allowed;\n\nstatic enum fan_status_access_mode fan_status_access_mode;\nstatic enum fan_control_access_mode fan_control_access_mode;\nstatic enum fan_control_commands fan_control_commands;\n\nstatic u8 fan_control_initial_status;\nstatic u8 fan_control_desired_level;\nstatic u8 fan_control_resume_level;\nstatic int fan_watchdog_maxinterval;\n\nstatic struct mutex fan_mutex;\n\nstatic void fan_watchdog_fire(struct work_struct *ignored);\nstatic DECLARE_DELAYED_WORK(fan_watchdog_task, fan_watchdog_fire);\n\nTPACPI_HANDLE(fans, ec, \"FANS\");\t/* X31, X40, X41 */\nTPACPI_HANDLE(gfan, ec, \"GFAN\",\t/* 570 */\n\t   \"\\\\FSPD\",\t\t/* 600e/x, 770e, 770x */\n\t   );\t\t\t/* all others */\nTPACPI_HANDLE(sfan, ec, \"SFAN\",\t/* 570 */\n\t   \"JFNS\",\t\t/* 770x-JL */\n\t   );\t\t\t/* all others */\n\n/*\n * Unitialized HFSP quirk: ACPI DSDT and EC fail to initialize the\n * HFSP register at boot, so it contains 0x07 but the Thinkpad could\n * be in auto mode (0x80).\n *\n * This is corrected by any write to HFSP either by the driver, or\n * by the firmware.\n *\n * We assume 0x07 really means auto mode while this quirk is active,\n * as this is far more likely than the ThinkPad being in level 7,\n * which is only used by the firmware during thermal emergencies.\n *\n * Enable for TP-1Y (T43), TP-78 (R51e), TP-76 (R52),\n * TP-70 (T43, R52), which are known to be buggy.\n */\n\nstatic void fan_quirk1_setup(void)\n{\n\tif (fan_control_initial_status == 0x07) {\n\t\tpr_notice(\"fan_init: initial fan status is unknown, assuming it is in auto mode\\n\");\n\t\ttp_features.fan_ctrl_status_undef = 1;\n\t}\n}\n\nstatic void fan_quirk1_handle(u8 *fan_status)\n{\n\tif (unlikely(tp_features.fan_ctrl_status_undef)) {\n\t\tif (*fan_status != fan_control_initial_status) {\n\t\t\t/* something changed the HFSP regisnter since\n\t\t\t * driver init time, so it is not undefined\n\t\t\t * anymore */\n\t\t\ttp_features.fan_ctrl_status_undef = 0;\n\t\t} else {\n\t\t\t/* Return most likely status. In fact, it\n\t\t\t * might be the only possible status */\n\t\t\t*fan_status = TP_EC_FAN_AUTO;\n\t\t}\n\t}\n}\n\n/* Select main fan on X60/X61, NOOP on others */\nstatic bool fan_select_fan1(void)\n{\n\tif (tp_features.second_fan) {\n\t\tu8 val;\n\n\t\tif (ec_read(fan_select_offset, &val) < 0)\n\t\t\treturn false;\n\t\tval &= 0xFEU;\n\t\tif (ec_write(fan_select_offset, val) < 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n/* Select secondary fan on X60/X61 */\nstatic bool fan_select_fan2(void)\n{\n\tu8 val;\n\n\tif (!tp_features.second_fan)\n\t\treturn false;\n\n\tif (ec_read(fan_select_offset, &val) < 0)\n\t\treturn false;\n\tval |= 0x01U;\n\tif (ec_write(fan_select_offset, val) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\n/*\n * Call with fan_mutex held\n */\nstatic void fan_update_desired_level(u8 status)\n{\n\tif ((status &\n\t     (TP_EC_FAN_AUTO | TP_EC_FAN_FULLSPEED)) == 0) {\n\t\tif (status > 7)\n\t\t\tfan_control_desired_level = 7;\n\t\telse\n\t\t\tfan_control_desired_level = status;\n\t}\n}\n\nstatic int fan_get_status(u8 *status)\n{\n\tu8 s;\n\n\t/* TODO:\n\t * Add TPACPI_FAN_RD_ACPI_FANS ? */\n\n\tswitch (fan_status_access_mode) {\n\tcase TPACPI_FAN_RD_ACPI_GFAN: {\n\t\t/* 570, 600e/x, 770e, 770x */\n\t\tint res;\n\n\t\tif (unlikely(!acpi_evalf(gfan_handle, &res, NULL, \"d\")))\n\t\t\treturn -EIO;\n\n\t\tif (likely(status))\n\t\t\t*status = res & 0x07;\n\n\t\tbreak;\n\t}\n\tcase TPACPI_FAN_RD_TPEC:\n\t\t/* all except 570, 600e/x, 770e, 770x */\n\t\tif (unlikely(!acpi_ec_read(fan_status_offset, &s)))\n\t\t\treturn -EIO;\n\n\t\tif (likely(status)) {\n\t\t\t*status = s;\n\t\t\tfan_quirk1_handle(status);\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int fan_get_status_safe(u8 *status)\n{\n\tint rc;\n\tu8 s;\n\n\tif (mutex_lock_killable(&fan_mutex))\n\t\treturn -ERESTARTSYS;\n\trc = fan_get_status(&s);\n\tif (!rc)\n\t\tfan_update_desired_level(s);\n\tmutex_unlock(&fan_mutex);\n\n\tif (rc)\n\t\treturn rc;\n\tif (status)\n\t\t*status = s;\n\n\treturn 0;\n}\n\nstatic int fan_get_speed(unsigned int *speed)\n{\n\tu8 hi, lo;\n\n\tswitch (fan_status_access_mode) {\n\tcase TPACPI_FAN_RD_TPEC:\n\t\t/* all except 570, 600e/x, 770e, 770x */\n\t\tif (unlikely(!fan_select_fan1()))\n\t\t\treturn -EIO;\n\t\tif (unlikely(!acpi_ec_read(fan_rpm_offset, &lo) ||\n\t\t\t     !acpi_ec_read(fan_rpm_offset + 1, &hi)))\n\t\t\treturn -EIO;\n\n\t\tif (likely(speed))\n\t\t\t*speed = (hi << 8) | lo;\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int fan2_get_speed(unsigned int *speed)\n{\n\tu8 hi, lo;\n\tbool rc;\n\n\tswitch (fan_status_access_mode) {\n\tcase TPACPI_FAN_RD_TPEC:\n\t\t/* all except 570, 600e/x, 770e, 770x */\n\t\tif (unlikely(!fan_select_fan2()))\n\t\t\treturn -EIO;\n\t\trc = !acpi_ec_read(fan_rpm_offset, &lo) ||\n\t\t\t     !acpi_ec_read(fan_rpm_offset + 1, &hi);\n\t\tfan_select_fan1(); /* play it safe */\n\t\tif (rc)\n\t\t\treturn -EIO;\n\n\t\tif (likely(speed))\n\t\t\t*speed = (hi << 8) | lo;\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int fan_set_level(int level)\n{\n\tif (!fan_control_allowed)\n\t\treturn -EPERM;\n\n\tswitch (fan_control_access_mode) {\n\tcase TPACPI_FAN_WR_ACPI_SFAN:\n\t\tif ((level < 0) || (level > 7))\n\t\t\treturn -EINVAL;\n\n\t\tif (tp_features.second_fan_ctl) {\n\t\t\tif (!fan_select_fan2() ||\n\t\t\t    !acpi_evalf(sfan_handle, NULL, NULL, \"vd\", level)) {\n\t\t\t\tpr_warn(\"Couldn't set 2nd fan level, disabling support\\n\");\n\t\t\t\ttp_features.second_fan_ctl = 0;\n\t\t\t}\n\t\t\tfan_select_fan1();\n\t\t}\n\t\tif (!acpi_evalf(sfan_handle, NULL, NULL, \"vd\", level))\n\t\t\treturn -EIO;\n\t\tbreak;\n\n\tcase TPACPI_FAN_WR_ACPI_FANS:\n\tcase TPACPI_FAN_WR_TPEC:\n\t\tif (!(level & TP_EC_FAN_AUTO) &&\n\t\t    !(level & TP_EC_FAN_FULLSPEED) &&\n\t\t    ((level < 0) || (level > 7)))\n\t\t\treturn -EINVAL;\n\n\t\t/* safety net should the EC not support AUTO\n\t\t * or FULLSPEED mode bits and just ignore them */\n\t\tif (level & TP_EC_FAN_FULLSPEED)\n\t\t\tlevel |= 7;\t/* safety min speed 7 */\n\t\telse if (level & TP_EC_FAN_AUTO)\n\t\t\tlevel |= 4;\t/* safety min speed 4 */\n\n\t\tif (tp_features.second_fan_ctl) {\n\t\t\tif (!fan_select_fan2() ||\n\t\t\t    !acpi_ec_write(fan_status_offset, level)) {\n\t\t\t\tpr_warn(\"Couldn't set 2nd fan level, disabling support\\n\");\n\t\t\t\ttp_features.second_fan_ctl = 0;\n\t\t\t}\n\t\t\tfan_select_fan1();\n\n\t\t}\n\t\tif (!acpi_ec_write(fan_status_offset, level))\n\t\t\treturn -EIO;\n\t\telse\n\t\t\ttp_features.fan_ctrl_status_undef = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\tvdbg_printk(TPACPI_DBG_FAN,\n\t\t\"fan control: set fan control register to 0x%02x\\n\", level);\n\treturn 0;\n}\n\nstatic int fan_set_level_safe(int level)\n{\n\tint rc;\n\n\tif (!fan_control_allowed)\n\t\treturn -EPERM;\n\n\tif (mutex_lock_killable(&fan_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (level == TPACPI_FAN_LAST_LEVEL)\n\t\tlevel = fan_control_desired_level;\n\n\trc = fan_set_level(level);\n\tif (!rc)\n\t\tfan_update_desired_level(level);\n\n\tmutex_unlock(&fan_mutex);\n\treturn rc;\n}\n\nstatic int fan_set_enable(void)\n{\n\tu8 s;\n\tint rc;\n\n\tif (!fan_control_allowed)\n\t\treturn -EPERM;\n\n\tif (mutex_lock_killable(&fan_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (fan_control_access_mode) {\n\tcase TPACPI_FAN_WR_ACPI_FANS:\n\tcase TPACPI_FAN_WR_TPEC:\n\t\trc = fan_get_status(&s);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\t/* Don't go out of emergency fan mode */\n\t\tif (s != 7) {\n\t\t\ts &= 0x07;\n\t\t\ts |= TP_EC_FAN_AUTO | 4; /* min fan speed 4 */\n\t\t}\n\n\t\tif (!acpi_ec_write(fan_status_offset, s))\n\t\t\trc = -EIO;\n\t\telse {\n\t\t\ttp_features.fan_ctrl_status_undef = 0;\n\t\t\trc = 0;\n\t\t}\n\t\tbreak;\n\n\tcase TPACPI_FAN_WR_ACPI_SFAN:\n\t\trc = fan_get_status(&s);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\ts &= 0x07;\n\n\t\t/* Set fan to at least level 4 */\n\t\ts |= 4;\n\n\t\tif (!acpi_evalf(sfan_handle, NULL, NULL, \"vd\", s))\n\t\t\trc = -EIO;\n\t\telse\n\t\t\trc = 0;\n\t\tbreak;\n\n\tdefault:\n\t\trc = -ENXIO;\n\t}\n\n\tmutex_unlock(&fan_mutex);\n\n\tif (!rc)\n\t\tvdbg_printk(TPACPI_DBG_FAN,\n\t\t\t\"fan control: set fan control register to 0x%02x\\n\",\n\t\t\ts);\n\treturn rc;\n}\n\nstatic int fan_set_disable(void)\n{\n\tint rc;\n\n\tif (!fan_control_allowed)\n\t\treturn -EPERM;\n\n\tif (mutex_lock_killable(&fan_mutex))\n\t\treturn -ERESTARTSYS;\n\n\trc = 0;\n\tswitch (fan_control_access_mode) {\n\tcase TPACPI_FAN_WR_ACPI_FANS:\n\tcase TPACPI_FAN_WR_TPEC:\n\t\tif (!acpi_ec_write(fan_status_offset, 0x00))\n\t\t\trc = -EIO;\n\t\telse {\n\t\t\tfan_control_desired_level = 0;\n\t\t\ttp_features.fan_ctrl_status_undef = 0;\n\t\t}\n\t\tbreak;\n\n\tcase TPACPI_FAN_WR_ACPI_SFAN:\n\t\tif (!acpi_evalf(sfan_handle, NULL, NULL, \"vd\", 0x00))\n\t\t\trc = -EIO;\n\t\telse\n\t\t\tfan_control_desired_level = 0;\n\t\tbreak;\n\n\tdefault:\n\t\trc = -ENXIO;\n\t}\n\n\tif (!rc)\n\t\tvdbg_printk(TPACPI_DBG_FAN,\n\t\t\t\"fan control: set fan control register to 0\\n\");\n\n\tmutex_unlock(&fan_mutex);\n\treturn rc;\n}\n\nstatic int fan_set_speed(int speed)\n{\n\tint rc;\n\n\tif (!fan_control_allowed)\n\t\treturn -EPERM;\n\n\tif (mutex_lock_killable(&fan_mutex))\n\t\treturn -ERESTARTSYS;\n\n\trc = 0;\n\tswitch (fan_control_access_mode) {\n\tcase TPACPI_FAN_WR_ACPI_FANS:\n\t\tif (speed >= 0 && speed <= 65535) {\n\t\t\tif (!acpi_evalf(fans_handle, NULL, NULL, \"vddd\",\n\t\t\t\t\tspeed, speed, speed))\n\t\t\t\trc = -EIO;\n\t\t} else\n\t\t\trc = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\trc = -ENXIO;\n\t}\n\n\tmutex_unlock(&fan_mutex);\n\treturn rc;\n}\n\nstatic void fan_watchdog_reset(void)\n{\n\tif (fan_control_access_mode == TPACPI_FAN_WR_NONE)\n\t\treturn;\n\n\tif (fan_watchdog_maxinterval > 0 &&\n\t    tpacpi_lifecycle != TPACPI_LIFE_EXITING)\n\t\tmod_delayed_work(tpacpi_wq, &fan_watchdog_task,\n\t\t\tmsecs_to_jiffies(fan_watchdog_maxinterval * 1000));\n\telse\n\t\tcancel_delayed_work(&fan_watchdog_task);\n}\n\nstatic void fan_watchdog_fire(struct work_struct *ignored)\n{\n\tint rc;\n\n\tif (tpacpi_lifecycle != TPACPI_LIFE_RUNNING)\n\t\treturn;\n\n\tpr_notice(\"fan watchdog: enabling fan\\n\");\n\trc = fan_set_enable();\n\tif (rc < 0) {\n\t\tpr_err(\"fan watchdog: error %d while enabling fan, will try again later...\\n\",\n\t\t       rc);\n\t\t/* reschedule for later */\n\t\tfan_watchdog_reset();\n\t}\n}\n\n/*\n * SYSFS fan layout: hwmon compatible (device)\n *\n * pwm*_enable:\n * \t0: \"disengaged\" mode\n * \t1: manual mode\n * \t2: native EC \"auto\" mode (recommended, hardware default)\n *\n * pwm*: set speed in manual mode, ignored otherwise.\n * \t0 is level 0; 255 is level 7. Intermediate points done with linear\n * \tinterpolation.\n *\n * fan*_input: tachometer reading, RPM\n *\n *\n * SYSFS fan layout: extensions\n *\n * fan_watchdog (driver):\n * \tfan watchdog interval in seconds, 0 disables (default), max 120\n */\n\n/* sysfs fan pwm1_enable ----------------------------------------------- */\nstatic ssize_t fan_pwm1_enable_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tint res, mode;\n\tu8 status;\n\n\tres = fan_get_status_safe(&status);\n\tif (res)\n\t\treturn res;\n\n\tif (status & TP_EC_FAN_FULLSPEED) {\n\t\tmode = 0;\n\t} else if (status & TP_EC_FAN_AUTO) {\n\t\tmode = 2;\n\t} else\n\t\tmode = 1;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", mode);\n}\n\nstatic ssize_t fan_pwm1_enable_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tunsigned long t;\n\tint res, level;\n\n\tif (parse_strtoul(buf, 2, &t))\n\t\treturn -EINVAL;\n\n\ttpacpi_disclose_usertask(\"hwmon pwm1_enable\",\n\t\t\t\"set fan mode to %lu\\n\", t);\n\n\tswitch (t) {\n\tcase 0:\n\t\tlevel = TP_EC_FAN_FULLSPEED;\n\t\tbreak;\n\tcase 1:\n\t\tlevel = TPACPI_FAN_LAST_LEVEL;\n\t\tbreak;\n\tcase 2:\n\t\tlevel = TP_EC_FAN_AUTO;\n\t\tbreak;\n\tcase 3:\n\t\t/* reserved for software-controlled auto mode */\n\t\treturn -ENOSYS;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tres = fan_set_level_safe(level);\n\tif (res == -ENXIO)\n\t\treturn -EINVAL;\n\telse if (res < 0)\n\t\treturn res;\n\n\tfan_watchdog_reset();\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(pwm1_enable, S_IWUSR | S_IRUGO,\n\t\t   fan_pwm1_enable_show, fan_pwm1_enable_store);\n\n/* sysfs fan pwm1 ------------------------------------------------------ */\nstatic ssize_t fan_pwm1_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tint res;\n\tu8 status;\n\n\tres = fan_get_status_safe(&status);\n\tif (res)\n\t\treturn res;\n\n\tif ((status &\n\t     (TP_EC_FAN_AUTO | TP_EC_FAN_FULLSPEED)) != 0)\n\t\tstatus = fan_control_desired_level;\n\n\tif (status > 7)\n\t\tstatus = 7;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", (status * 255) / 7);\n}\n\nstatic ssize_t fan_pwm1_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tunsigned long s;\n\tint rc;\n\tu8 status, newlevel;\n\n\tif (parse_strtoul(buf, 255, &s))\n\t\treturn -EINVAL;\n\n\ttpacpi_disclose_usertask(\"hwmon pwm1\",\n\t\t\t\"set fan speed to %lu\\n\", s);\n\n\t/* scale down from 0-255 to 0-7 */\n\tnewlevel = (s >> 5) & 0x07;\n\n\tif (mutex_lock_killable(&fan_mutex))\n\t\treturn -ERESTARTSYS;\n\n\trc = fan_get_status(&status);\n\tif (!rc && (status &\n\t\t    (TP_EC_FAN_AUTO | TP_EC_FAN_FULLSPEED)) == 0) {\n\t\trc = fan_set_level(newlevel);\n\t\tif (rc == -ENXIO)\n\t\t\trc = -EINVAL;\n\t\telse if (!rc) {\n\t\t\tfan_update_desired_level(newlevel);\n\t\t\tfan_watchdog_reset();\n\t\t}\n\t}\n\n\tmutex_unlock(&fan_mutex);\n\treturn (rc) ? rc : count;\n}\n\nstatic DEVICE_ATTR(pwm1, S_IWUSR | S_IRUGO, fan_pwm1_show, fan_pwm1_store);\n\n/* sysfs fan fan1_input ------------------------------------------------ */\nstatic ssize_t fan_fan1_input_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint res;\n\tunsigned int speed;\n\n\tres = fan_get_speed(&speed);\n\tif (res < 0)\n\t\treturn res;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", speed);\n}\n\nstatic DEVICE_ATTR(fan1_input, S_IRUGO, fan_fan1_input_show, NULL);\n\n/* sysfs fan fan2_input ------------------------------------------------ */\nstatic ssize_t fan_fan2_input_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint res;\n\tunsigned int speed;\n\n\tres = fan2_get_speed(&speed);\n\tif (res < 0)\n\t\treturn res;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", speed);\n}\n\nstatic DEVICE_ATTR(fan2_input, S_IRUGO, fan_fan2_input_show, NULL);\n\n/* sysfs fan fan_watchdog (hwmon driver) ------------------------------- */\nstatic ssize_t fan_watchdog_show(struct device_driver *drv, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", fan_watchdog_maxinterval);\n}\n\nstatic ssize_t fan_watchdog_store(struct device_driver *drv, const char *buf,\n\t\t\t\t  size_t count)\n{\n\tunsigned long t;\n\n\tif (parse_strtoul(buf, 120, &t))\n\t\treturn -EINVAL;\n\n\tif (!fan_control_allowed)\n\t\treturn -EPERM;\n\n\tfan_watchdog_maxinterval = t;\n\tfan_watchdog_reset();\n\n\ttpacpi_disclose_usertask(\"fan_watchdog\", \"set to %lu\\n\", t);\n\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(fan_watchdog);\n\n/* --------------------------------------------------------------------- */\nstatic struct attribute *fan_attributes[] = {\n\t&dev_attr_pwm1_enable.attr, &dev_attr_pwm1.attr,\n\t&dev_attr_fan1_input.attr,\n\tNULL, /* for fan2_input */\n\tNULL\n};\n\nstatic const struct attribute_group fan_attr_group = {\n\t.attrs = fan_attributes,\n};\n\n#define TPACPI_FAN_Q1\t0x0001\t\t/* Unitialized HFSP */\n#define TPACPI_FAN_2FAN\t0x0002\t\t/* EC 0x31 bit 0 selects fan2 */\n#define TPACPI_FAN_2CTL\t0x0004\t\t/* selects fan2 control */\n\nstatic const struct tpacpi_quirk fan_quirk_table[] __initconst = {\n\tTPACPI_QEC_IBM('1', 'Y', TPACPI_FAN_Q1),\n\tTPACPI_QEC_IBM('7', '8', TPACPI_FAN_Q1),\n\tTPACPI_QEC_IBM('7', '6', TPACPI_FAN_Q1),\n\tTPACPI_QEC_IBM('7', '0', TPACPI_FAN_Q1),\n\tTPACPI_QEC_LNV('7', 'M', TPACPI_FAN_2FAN),\n\tTPACPI_Q_LNV('N', '1', TPACPI_FAN_2FAN),\n\tTPACPI_Q_LNV3('N', '1', 'D', TPACPI_FAN_2CTL),\t/* P70 */\n\tTPACPI_Q_LNV3('N', '1', 'E', TPACPI_FAN_2CTL),\t/* P50 */\n\tTPACPI_Q_LNV3('N', '1', 'T', TPACPI_FAN_2CTL),\t/* P71 */\n\tTPACPI_Q_LNV3('N', '1', 'U', TPACPI_FAN_2CTL),\t/* P51 */\n\tTPACPI_Q_LNV3('N', '2', 'C', TPACPI_FAN_2CTL),\t/* P52 / P72 */\n\tTPACPI_Q_LNV3('N', '2', 'N', TPACPI_FAN_2CTL),\t/* P53 / P73 */\n\tTPACPI_Q_LNV3('N', '2', 'E', TPACPI_FAN_2CTL),\t/* P1 / X1 Extreme (1st gen) */\n\tTPACPI_Q_LNV3('N', '2', 'O', TPACPI_FAN_2CTL),\t/* P1 / X1 Extreme (2nd gen) */\n\tTPACPI_Q_LNV3('N', '2', 'V', TPACPI_FAN_2CTL),\t/* P1 / X1 Extreme (3nd gen) */\n\tTPACPI_Q_LNV3('N', '3', '0', TPACPI_FAN_2CTL),\t/* P15 (1st gen) / P15v (1st gen) */\n};\n\nstatic int __init fan_init(struct ibm_init_struct *iibm)\n{\n\tint rc;\n\tunsigned long quirks;\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_FAN,\n\t\t\t\"initializing fan subdriver\\n\");\n\n\tmutex_init(&fan_mutex);\n\tfan_status_access_mode = TPACPI_FAN_NONE;\n\tfan_control_access_mode = TPACPI_FAN_WR_NONE;\n\tfan_control_commands = 0;\n\tfan_watchdog_maxinterval = 0;\n\ttp_features.fan_ctrl_status_undef = 0;\n\ttp_features.second_fan = 0;\n\ttp_features.second_fan_ctl = 0;\n\tfan_control_desired_level = 7;\n\n\tif (tpacpi_is_ibm()) {\n\t\tTPACPI_ACPIHANDLE_INIT(fans);\n\t\tTPACPI_ACPIHANDLE_INIT(gfan);\n\t\tTPACPI_ACPIHANDLE_INIT(sfan);\n\t}\n\n\tquirks = tpacpi_check_quirks(fan_quirk_table,\n\t\t\t\t     ARRAY_SIZE(fan_quirk_table));\n\n\tif (gfan_handle) {\n\t\t/* 570, 600e/x, 770e, 770x */\n\t\tfan_status_access_mode = TPACPI_FAN_RD_ACPI_GFAN;\n\t} else {\n\t\t/* all other ThinkPads: note that even old-style\n\t\t * ThinkPad ECs supports the fan control register */\n\t\tif (likely(acpi_ec_read(fan_status_offset,\n\t\t\t\t\t&fan_control_initial_status))) {\n\t\t\tfan_status_access_mode = TPACPI_FAN_RD_TPEC;\n\t\t\tif (quirks & TPACPI_FAN_Q1)\n\t\t\t\tfan_quirk1_setup();\n\t\t\tif (quirks & TPACPI_FAN_2FAN) {\n\t\t\t\ttp_features.second_fan = 1;\n\t\t\t\tpr_info(\"secondary fan support enabled\\n\");\n\t\t\t}\n\t\t\tif (quirks & TPACPI_FAN_2CTL) {\n\t\t\t\ttp_features.second_fan = 1;\n\t\t\t\ttp_features.second_fan_ctl = 1;\n\t\t\t\tpr_info(\"secondary fan control enabled\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tpr_err(\"ThinkPad ACPI EC access misbehaving, fan status and control unavailable\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (sfan_handle) {\n\t\t/* 570, 770x-JL */\n\t\tfan_control_access_mode = TPACPI_FAN_WR_ACPI_SFAN;\n\t\tfan_control_commands |=\n\t\t    TPACPI_FAN_CMD_LEVEL | TPACPI_FAN_CMD_ENABLE;\n\t} else {\n\t\tif (!gfan_handle) {\n\t\t\t/* gfan without sfan means no fan control */\n\t\t\t/* all other models implement TP EC 0x2f control */\n\n\t\t\tif (fans_handle) {\n\t\t\t\t/* X31, X40, X41 */\n\t\t\t\tfan_control_access_mode =\n\t\t\t\t    TPACPI_FAN_WR_ACPI_FANS;\n\t\t\t\tfan_control_commands |=\n\t\t\t\t    TPACPI_FAN_CMD_SPEED |\n\t\t\t\t    TPACPI_FAN_CMD_LEVEL |\n\t\t\t\t    TPACPI_FAN_CMD_ENABLE;\n\t\t\t} else {\n\t\t\t\tfan_control_access_mode = TPACPI_FAN_WR_TPEC;\n\t\t\t\tfan_control_commands |=\n\t\t\t\t    TPACPI_FAN_CMD_LEVEL |\n\t\t\t\t    TPACPI_FAN_CMD_ENABLE;\n\t\t\t}\n\t\t}\n\t}\n\n\tvdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_FAN,\n\t\t\"fan is %s, modes %d, %d\\n\",\n\t\tstr_supported(fan_status_access_mode != TPACPI_FAN_NONE ||\n\t\t  fan_control_access_mode != TPACPI_FAN_WR_NONE),\n\t\tfan_status_access_mode, fan_control_access_mode);\n\n\t/* fan control master switch */\n\tif (!fan_control_allowed) {\n\t\tfan_control_access_mode = TPACPI_FAN_WR_NONE;\n\t\tfan_control_commands = 0;\n\t\tdbg_printk(TPACPI_DBG_INIT | TPACPI_DBG_FAN,\n\t\t\t   \"fan control features disabled by parameter\\n\");\n\t}\n\n\t/* update fan_control_desired_level */\n\tif (fan_status_access_mode != TPACPI_FAN_NONE)\n\t\tfan_get_status_safe(NULL);\n\n\tif (fan_status_access_mode != TPACPI_FAN_NONE ||\n\t    fan_control_access_mode != TPACPI_FAN_WR_NONE) {\n\t\tif (tp_features.second_fan) {\n\t\t\t/* attach second fan tachometer */\n\t\t\tfan_attributes[ARRAY_SIZE(fan_attributes)-2] =\n\t\t\t\t\t&dev_attr_fan2_input.attr;\n\t\t}\n\t\trc = sysfs_create_group(&tpacpi_hwmon->kobj,\n\t\t\t\t\t &fan_attr_group);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = driver_create_file(&tpacpi_hwmon_pdriver.driver,\n\t\t\t\t\t&driver_attr_fan_watchdog);\n\t\tif (rc < 0) {\n\t\t\tsysfs_remove_group(&tpacpi_hwmon->kobj,\n\t\t\t\t\t&fan_attr_group);\n\t\t\treturn rc;\n\t\t}\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n}\n\nstatic void fan_exit(void)\n{\n\tvdbg_printk(TPACPI_DBG_EXIT | TPACPI_DBG_FAN,\n\t\t    \"cancelling any pending fan watchdog tasks\\n\");\n\n\t/* FIXME: can we really do this unconditionally? */\n\tsysfs_remove_group(&tpacpi_hwmon->kobj, &fan_attr_group);\n\tdriver_remove_file(&tpacpi_hwmon_pdriver.driver,\n\t\t\t   &driver_attr_fan_watchdog);\n\n\tcancel_delayed_work(&fan_watchdog_task);\n\tflush_workqueue(tpacpi_wq);\n}\n\nstatic void fan_suspend(void)\n{\n\tint rc;\n\n\tif (!fan_control_allowed)\n\t\treturn;\n\n\t/* Store fan status in cache */\n\tfan_control_resume_level = 0;\n\trc = fan_get_status_safe(&fan_control_resume_level);\n\tif (rc < 0)\n\t\tpr_notice(\"failed to read fan level for later restore during resume: %d\\n\",\n\t\t\t  rc);\n\n\t/* if it is undefined, don't attempt to restore it.\n\t * KEEP THIS LAST */\n\tif (tp_features.fan_ctrl_status_undef)\n\t\tfan_control_resume_level = 0;\n}\n\nstatic void fan_resume(void)\n{\n\tu8 current_level = 7;\n\tbool do_set = false;\n\tint rc;\n\n\t/* DSDT *always* updates status on resume */\n\ttp_features.fan_ctrl_status_undef = 0;\n\n\tif (!fan_control_allowed ||\n\t    !fan_control_resume_level ||\n\t    (fan_get_status_safe(&current_level) < 0))\n\t\treturn;\n\n\tswitch (fan_control_access_mode) {\n\tcase TPACPI_FAN_WR_ACPI_SFAN:\n\t\t/* never decrease fan level */\n\t\tdo_set = (fan_control_resume_level > current_level);\n\t\tbreak;\n\tcase TPACPI_FAN_WR_ACPI_FANS:\n\tcase TPACPI_FAN_WR_TPEC:\n\t\t/* never decrease fan level, scale is:\n\t\t * TP_EC_FAN_FULLSPEED > 7 >= TP_EC_FAN_AUTO\n\t\t *\n\t\t * We expect the firmware to set either 7 or AUTO, but we\n\t\t * handle FULLSPEED out of paranoia.\n\t\t *\n\t\t * So, we can safely only restore FULLSPEED or 7, anything\n\t\t * else could slow the fan.  Restoring AUTO is useless, at\n\t\t * best that's exactly what the DSDT already set (it is the\n\t\t * slower it uses).\n\t\t *\n\t\t * Always keep in mind that the DSDT *will* have set the\n\t\t * fans to what the vendor supposes is the best level.  We\n\t\t * muck with it only to speed the fan up.\n\t\t */\n\t\tif (fan_control_resume_level != 7 &&\n\t\t    !(fan_control_resume_level & TP_EC_FAN_FULLSPEED))\n\t\t\treturn;\n\t\telse\n\t\t\tdo_set = !(current_level & TP_EC_FAN_FULLSPEED) &&\n\t\t\t\t (current_level != fan_control_resume_level);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tif (do_set) {\n\t\tpr_notice(\"restoring fan level to 0x%02x\\n\",\n\t\t\t  fan_control_resume_level);\n\t\trc = fan_set_level_safe(fan_control_resume_level);\n\t\tif (rc < 0)\n\t\t\tpr_notice(\"failed to restore fan level: %d\\n\", rc);\n\t}\n}\n\nstatic int fan_read(struct seq_file *m)\n{\n\tint rc;\n\tu8 status;\n\tunsigned int speed = 0;\n\n\tswitch (fan_status_access_mode) {\n\tcase TPACPI_FAN_RD_ACPI_GFAN:\n\t\t/* 570, 600e/x, 770e, 770x */\n\t\trc = fan_get_status_safe(&status);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tseq_printf(m, \"status:\\t\\t%s\\n\"\n\t\t\t       \"level:\\t\\t%d\\n\",\n\t\t\t       (status != 0) ? \"enabled\" : \"disabled\", status);\n\t\tbreak;\n\n\tcase TPACPI_FAN_RD_TPEC:\n\t\t/* all except 570, 600e/x, 770e, 770x */\n\t\trc = fan_get_status_safe(&status);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tseq_printf(m, \"status:\\t\\t%s\\n\",\n\t\t\t       (status != 0) ? \"enabled\" : \"disabled\");\n\n\t\trc = fan_get_speed(&speed);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tseq_printf(m, \"speed:\\t\\t%d\\n\", speed);\n\n\t\tif (status & TP_EC_FAN_FULLSPEED)\n\t\t\t/* Disengaged mode takes precedence */\n\t\t\tseq_printf(m, \"level:\\t\\tdisengaged\\n\");\n\t\telse if (status & TP_EC_FAN_AUTO)\n\t\t\tseq_printf(m, \"level:\\t\\tauto\\n\");\n\t\telse\n\t\t\tseq_printf(m, \"level:\\t\\t%d\\n\", status);\n\t\tbreak;\n\n\tcase TPACPI_FAN_NONE:\n\tdefault:\n\t\tseq_printf(m, \"status:\\t\\tnot supported\\n\");\n\t}\n\n\tif (fan_control_commands & TPACPI_FAN_CMD_LEVEL) {\n\t\tseq_printf(m, \"commands:\\tlevel <level>\");\n\n\t\tswitch (fan_control_access_mode) {\n\t\tcase TPACPI_FAN_WR_ACPI_SFAN:\n\t\t\tseq_printf(m, \" (<level> is 0-7)\\n\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tseq_printf(m, \" (<level> is 0-7, auto, disengaged, full-speed)\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fan_control_commands & TPACPI_FAN_CMD_ENABLE)\n\t\tseq_printf(m, \"commands:\\tenable, disable\\n\"\n\t\t\t       \"commands:\\twatchdog <timeout> (<timeout> is 0 (off), 1-120 (seconds))\\n\");\n\n\tif (fan_control_commands & TPACPI_FAN_CMD_SPEED)\n\t\tseq_printf(m, \"commands:\\tspeed <speed> (<speed> is 0-65535)\\n\");\n\n\treturn 0;\n}\n\nstatic int fan_write_cmd_level(const char *cmd, int *rc)\n{\n\tint level;\n\n\tif (strlencmp(cmd, \"level auto\") == 0)\n\t\tlevel = TP_EC_FAN_AUTO;\n\telse if ((strlencmp(cmd, \"level disengaged\") == 0) |\n\t\t\t(strlencmp(cmd, \"level full-speed\") == 0))\n\t\tlevel = TP_EC_FAN_FULLSPEED;\n\telse if (sscanf(cmd, \"level %d\", &level) != 1)\n\t\treturn 0;\n\n\t*rc = fan_set_level_safe(level);\n\tif (*rc == -ENXIO)\n\t\tpr_err(\"level command accepted for unsupported access mode %d\\n\",\n\t\t       fan_control_access_mode);\n\telse if (!*rc)\n\t\ttpacpi_disclose_usertask(\"procfs fan\",\n\t\t\t\"set level to %d\\n\", level);\n\n\treturn 1;\n}\n\nstatic int fan_write_cmd_enable(const char *cmd, int *rc)\n{\n\tif (strlencmp(cmd, \"enable\") != 0)\n\t\treturn 0;\n\n\t*rc = fan_set_enable();\n\tif (*rc == -ENXIO)\n\t\tpr_err(\"enable command accepted for unsupported access mode %d\\n\",\n\t\t       fan_control_access_mode);\n\telse if (!*rc)\n\t\ttpacpi_disclose_usertask(\"procfs fan\", \"enable\\n\");\n\n\treturn 1;\n}\n\nstatic int fan_write_cmd_disable(const char *cmd, int *rc)\n{\n\tif (strlencmp(cmd, \"disable\") != 0)\n\t\treturn 0;\n\n\t*rc = fan_set_disable();\n\tif (*rc == -ENXIO)\n\t\tpr_err(\"disable command accepted for unsupported access mode %d\\n\",\n\t\t       fan_control_access_mode);\n\telse if (!*rc)\n\t\ttpacpi_disclose_usertask(\"procfs fan\", \"disable\\n\");\n\n\treturn 1;\n}\n\nstatic int fan_write_cmd_speed(const char *cmd, int *rc)\n{\n\tint speed;\n\n\t/* TODO:\n\t * Support speed <low> <medium> <high> ? */\n\n\tif (sscanf(cmd, \"speed %d\", &speed) != 1)\n\t\treturn 0;\n\n\t*rc = fan_set_speed(speed);\n\tif (*rc == -ENXIO)\n\t\tpr_err(\"speed command accepted for unsupported access mode %d\\n\",\n\t\t       fan_control_access_mode);\n\telse if (!*rc)\n\t\ttpacpi_disclose_usertask(\"procfs fan\",\n\t\t\t\"set speed to %d\\n\", speed);\n\n\treturn 1;\n}\n\nstatic int fan_write_cmd_watchdog(const char *cmd, int *rc)\n{\n\tint interval;\n\n\tif (sscanf(cmd, \"watchdog %d\", &interval) != 1)\n\t\treturn 0;\n\n\tif (interval < 0 || interval > 120)\n\t\t*rc = -EINVAL;\n\telse {\n\t\tfan_watchdog_maxinterval = interval;\n\t\ttpacpi_disclose_usertask(\"procfs fan\",\n\t\t\t\"set watchdog timer to %d\\n\",\n\t\t\tinterval);\n\t}\n\n\treturn 1;\n}\n\nstatic int fan_write(char *buf)\n{\n\tchar *cmd;\n\tint rc = 0;\n\n\twhile (!rc && (cmd = strsep(&buf, \",\"))) {\n\t\tif (!((fan_control_commands & TPACPI_FAN_CMD_LEVEL) &&\n\t\t      fan_write_cmd_level(cmd, &rc)) &&\n\t\t    !((fan_control_commands & TPACPI_FAN_CMD_ENABLE) &&\n\t\t      (fan_write_cmd_enable(cmd, &rc) ||\n\t\t       fan_write_cmd_disable(cmd, &rc) ||\n\t\t       fan_write_cmd_watchdog(cmd, &rc))) &&\n\t\t    !((fan_control_commands & TPACPI_FAN_CMD_SPEED) &&\n\t\t      fan_write_cmd_speed(cmd, &rc))\n\t\t    )\n\t\t\trc = -EINVAL;\n\t\telse if (!rc)\n\t\t\tfan_watchdog_reset();\n\t}\n\n\treturn rc;\n}\n\nstatic struct ibm_struct fan_driver_data = {\n\t.name = \"fan\",\n\t.read = fan_read,\n\t.write = fan_write,\n\t.exit = fan_exit,\n\t.suspend = fan_suspend,\n\t.resume = fan_resume,\n};\n\n/*************************************************************************\n * Mute LED subdriver\n */\n\n#define TPACPI_LED_MAX\t\t2\n\nstruct tp_led_table {\n\tacpi_string name;\n\tint on_value;\n\tint off_value;\n\tint state;\n};\n\nstatic struct tp_led_table led_tables[TPACPI_LED_MAX] = {\n\t[LED_AUDIO_MUTE] = {\n\t\t.name = \"SSMS\",\n\t\t.on_value = 1,\n\t\t.off_value = 0,\n\t},\n\t[LED_AUDIO_MICMUTE] = {\n\t\t.name = \"MMTS\",\n\t\t.on_value = 2,\n\t\t.off_value = 0,\n\t},\n};\n\nstatic int mute_led_on_off(struct tp_led_table *t, bool state)\n{\n\tacpi_handle temp;\n\tint output;\n\n\tif (ACPI_FAILURE(acpi_get_handle(hkey_handle, t->name, &temp))) {\n\t\tpr_warn(\"Thinkpad ACPI has no %s interface.\\n\", t->name);\n\t\treturn -EIO;\n\t}\n\n\tif (!acpi_evalf(hkey_handle, &output, t->name, \"dd\",\n\t\t\tstate ? t->on_value : t->off_value))\n\t\treturn -EIO;\n\n\tt->state = state;\n\treturn state;\n}\n\nstatic int tpacpi_led_set(int whichled, bool on)\n{\n\tstruct tp_led_table *t;\n\n\tt = &led_tables[whichled];\n\tif (t->state < 0 || t->state == on)\n\t\treturn t->state;\n\treturn mute_led_on_off(t, on);\n}\n\nstatic int tpacpi_led_mute_set(struct led_classdev *led_cdev,\n\t\t\t       enum led_brightness brightness)\n{\n\treturn tpacpi_led_set(LED_AUDIO_MUTE, brightness != LED_OFF);\n}\n\nstatic int tpacpi_led_micmute_set(struct led_classdev *led_cdev,\n\t\t\t\t  enum led_brightness brightness)\n{\n\treturn tpacpi_led_set(LED_AUDIO_MICMUTE, brightness != LED_OFF);\n}\n\nstatic struct led_classdev mute_led_cdev[TPACPI_LED_MAX] = {\n\t[LED_AUDIO_MUTE] = {\n\t\t.name\t\t= \"platform::mute\",\n\t\t.max_brightness = 1,\n\t\t.brightness_set_blocking = tpacpi_led_mute_set,\n\t\t.default_trigger = \"audio-mute\",\n\t},\n\t[LED_AUDIO_MICMUTE] = {\n\t\t.name\t\t= \"platform::micmute\",\n\t\t.max_brightness = 1,\n\t\t.brightness_set_blocking = tpacpi_led_micmute_set,\n\t\t.default_trigger = \"audio-micmute\",\n\t},\n};\n\nstatic int mute_led_init(struct ibm_init_struct *iibm)\n{\n\tacpi_handle temp;\n\tint i, err;\n\n\tfor (i = 0; i < TPACPI_LED_MAX; i++) {\n\t\tstruct tp_led_table *t = &led_tables[i];\n\t\tif (ACPI_FAILURE(acpi_get_handle(hkey_handle, t->name, &temp))) {\n\t\t\tt->state = -ENODEV;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmute_led_cdev[i].brightness = ledtrig_audio_get(i);\n\t\terr = led_classdev_register(&tpacpi_pdev->dev, &mute_led_cdev[i]);\n\t\tif (err < 0) {\n\t\t\twhile (i--)\n\t\t\t\tled_classdev_unregister(&mute_led_cdev[i]);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void mute_led_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; i < TPACPI_LED_MAX; i++) {\n\t\tled_classdev_unregister(&mute_led_cdev[i]);\n\t\ttpacpi_led_set(i, false);\n\t}\n}\n\nstatic void mute_led_resume(void)\n{\n\tint i;\n\n\tfor (i = 0; i < TPACPI_LED_MAX; i++) {\n\t\tstruct tp_led_table *t = &led_tables[i];\n\t\tif (t->state >= 0)\n\t\t\tmute_led_on_off(t, t->state);\n\t}\n}\n\nstatic struct ibm_struct mute_led_driver_data = {\n\t.name = \"mute_led\",\n\t.exit = mute_led_exit,\n\t.resume = mute_led_resume,\n};\n\n/*\n * Battery Wear Control Driver\n * Contact: Ognjen Galic <smclt30p@gmail.com>\n */\n\n/* Metadata */\n\n#define GET_START\t\"BCTG\"\n#define SET_START\t\"BCCS\"\n#define GET_STOP\t\"BCSG\"\n#define SET_STOP\t\"BCSS\"\n\nenum {\n\tBAT_ANY = 0,\n\tBAT_PRIMARY = 1,\n\tBAT_SECONDARY = 2\n};\n\nenum {\n\t/* Error condition bit */\n\tMETHOD_ERR = BIT(31),\n};\n\nenum {\n\t/* This is used in the get/set helpers */\n\tTHRESHOLD_START,\n\tTHRESHOLD_STOP,\n};\n\nstruct tpacpi_battery_data {\n\tint charge_start;\n\tint start_support;\n\tint charge_stop;\n\tint stop_support;\n};\n\nstruct tpacpi_battery_driver_data {\n\tstruct tpacpi_battery_data batteries[3];\n\tint individual_addressing;\n};\n\nstatic struct tpacpi_battery_driver_data battery_info;\n\n/* ACPI helpers/functions/probes */\n\n/**\n * This evaluates a ACPI method call specific to the battery\n * ACPI extension. The specifics are that an error is marked\n * in the 32rd bit of the response, so we just check that here.\n */\nstatic acpi_status tpacpi_battery_acpi_eval(char *method, int *ret, int param)\n{\n\tint response;\n\n\tif (!acpi_evalf(hkey_handle, &response, method, \"dd\", param)) {\n\t\tacpi_handle_err(hkey_handle, \"%s: evaluate failed\", method);\n\t\treturn AE_ERROR;\n\t}\n\tif (response & METHOD_ERR) {\n\t\tacpi_handle_err(hkey_handle,\n\t\t\t\t\"%s evaluated but flagged as error\", method);\n\t\treturn AE_ERROR;\n\t}\n\t*ret = response;\n\treturn AE_OK;\n}\n\nstatic int tpacpi_battery_get(int what, int battery, int *ret)\n{\n\tswitch (what) {\n\tcase THRESHOLD_START:\n\t\tif ACPI_FAILURE(tpacpi_battery_acpi_eval(GET_START, ret, battery))\n\t\t\treturn -ENODEV;\n\n\t\t/* The value is in the low 8 bits of the response */\n\t\t*ret = *ret & 0xFF;\n\t\treturn 0;\n\tcase THRESHOLD_STOP:\n\t\tif ACPI_FAILURE(tpacpi_battery_acpi_eval(GET_STOP, ret, battery))\n\t\t\treturn -ENODEV;\n\t\t/* Value is in lower 8 bits */\n\t\t*ret = *ret & 0xFF;\n\t\t/*\n\t\t * On the stop value, if we return 0 that\n\t\t * does not make any sense. 0 means Default, which\n\t\t * means that charging stops at 100%, so we return\n\t\t * that.\n\t\t */\n\t\tif (*ret == 0)\n\t\t\t*ret = 100;\n\t\treturn 0;\n\tdefault:\n\t\tpr_crit(\"wrong parameter: %d\", what);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tpacpi_battery_set(int what, int battery, int value)\n{\n\tint param, ret;\n\t/* The first 8 bits are the value of the threshold */\n\tparam = value;\n\t/* The battery ID is in bits 8-9, 2 bits */\n\tparam |= battery << 8;\n\n\tswitch (what) {\n\tcase THRESHOLD_START:\n\t\tif ACPI_FAILURE(tpacpi_battery_acpi_eval(SET_START, &ret, param)) {\n\t\t\tpr_err(\"failed to set charge threshold on battery %d\",\n\t\t\t\t\tbattery);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\treturn 0;\n\tcase THRESHOLD_STOP:\n\t\tif ACPI_FAILURE(tpacpi_battery_acpi_eval(SET_STOP, &ret, param)) {\n\t\t\tpr_err(\"failed to set stop threshold: %d\", battery);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\tpr_crit(\"wrong parameter: %d\", what);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tpacpi_battery_probe(int battery)\n{\n\tint ret = 0;\n\n\tmemset(&battery_info.batteries[battery], 0,\n\t\tsizeof(battery_info.batteries[battery]));\n\n\t/*\n\t * 1) Get the current start threshold\n\t * 2) Check for support\n\t * 3) Get the current stop threshold\n\t * 4) Check for support\n\t */\n\tif (acpi_has_method(hkey_handle, GET_START)) {\n\t\tif ACPI_FAILURE(tpacpi_battery_acpi_eval(GET_START, &ret, battery)) {\n\t\t\tpr_err(\"Error probing battery %d\\n\", battery);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\t/* Individual addressing is in bit 9 */\n\t\tif (ret & BIT(9))\n\t\t\tbattery_info.individual_addressing = true;\n\t\t/* Support is marked in bit 8 */\n\t\tif (ret & BIT(8))\n\t\t\tbattery_info.batteries[battery].start_support = 1;\n\t\telse\n\t\t\treturn -ENODEV;\n\t\tif (tpacpi_battery_get(THRESHOLD_START, battery,\n\t\t\t&battery_info.batteries[battery].charge_start)) {\n\t\t\tpr_err(\"Error probing battery %d\\n\", battery);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tif (acpi_has_method(hkey_handle, GET_STOP)) {\n\t\tif ACPI_FAILURE(tpacpi_battery_acpi_eval(GET_STOP, &ret, battery)) {\n\t\t\tpr_err(\"Error probing battery stop; %d\\n\", battery);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\t/* Support is marked in bit 8 */\n\t\tif (ret & BIT(8))\n\t\t\tbattery_info.batteries[battery].stop_support = 1;\n\t\telse\n\t\t\treturn -ENODEV;\n\t\tif (tpacpi_battery_get(THRESHOLD_STOP, battery,\n\t\t\t&battery_info.batteries[battery].charge_stop)) {\n\t\t\tpr_err(\"Error probing battery stop: %d\\n\", battery);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tpr_info(\"battery %d registered (start %d, stop %d)\",\n\t\t\tbattery,\n\t\t\tbattery_info.batteries[battery].charge_start,\n\t\t\tbattery_info.batteries[battery].charge_stop);\n\n\treturn 0;\n}\n\n/* General helper functions */\n\nstatic int tpacpi_battery_get_id(const char *battery_name)\n{\n\n\tif (strcmp(battery_name, \"BAT0\") == 0 ||\n\t    tp_features.battery_force_primary)\n\t\treturn BAT_PRIMARY;\n\tif (strcmp(battery_name, \"BAT1\") == 0)\n\t\treturn BAT_SECONDARY;\n\t/*\n\t * If for some reason the battery is not BAT0 nor is it\n\t * BAT1, we will assume it's the default, first battery,\n\t * AKA primary.\n\t */\n\tpr_warn(\"unknown battery %s, assuming primary\", battery_name);\n\treturn BAT_PRIMARY;\n}\n\n/* sysfs interface */\n\nstatic ssize_t tpacpi_battery_store(int what,\n\t\t\t\t    struct device *dev,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct power_supply *supply = to_power_supply(dev);\n\tunsigned long value;\n\tint battery, rval;\n\t/*\n\t * Some systems have support for more than\n\t * one battery. If that is the case,\n\t * tpacpi_battery_probe marked that addressing\n\t * them individually is supported, so we do that\n\t * based on the device struct.\n\t *\n\t * On systems that are not supported, we assume\n\t * the primary as most of the ACPI calls fail\n\t * with \"Any Battery\" as the parameter.\n\t */\n\tif (battery_info.individual_addressing)\n\t\t/* BAT_PRIMARY or BAT_SECONDARY */\n\t\tbattery = tpacpi_battery_get_id(supply->desc->name);\n\telse\n\t\tbattery = BAT_PRIMARY;\n\n\trval = kstrtoul(buf, 10, &value);\n\tif (rval)\n\t\treturn rval;\n\n\tswitch (what) {\n\tcase THRESHOLD_START:\n\t\tif (!battery_info.batteries[battery].start_support)\n\t\t\treturn -ENODEV;\n\t\t/* valid values are [0, 99] */\n\t\tif (value > 99)\n\t\t\treturn -EINVAL;\n\t\tif (value > battery_info.batteries[battery].charge_stop)\n\t\t\treturn -EINVAL;\n\t\tif (tpacpi_battery_set(THRESHOLD_START, battery, value))\n\t\t\treturn -ENODEV;\n\t\tbattery_info.batteries[battery].charge_start = value;\n\t\treturn count;\n\n\tcase THRESHOLD_STOP:\n\t\tif (!battery_info.batteries[battery].stop_support)\n\t\t\treturn -ENODEV;\n\t\t/* valid values are [1, 100] */\n\t\tif (value < 1 || value > 100)\n\t\t\treturn -EINVAL;\n\t\tif (value < battery_info.batteries[battery].charge_start)\n\t\t\treturn -EINVAL;\n\t\tbattery_info.batteries[battery].charge_stop = value;\n\t\t/*\n\t\t * When 100 is passed to stop, we need to flip\n\t\t * it to 0 as that the EC understands that as\n\t\t * \"Default\", which will charge to 100%\n\t\t */\n\t\tif (value == 100)\n\t\t\tvalue = 0;\n\t\tif (tpacpi_battery_set(THRESHOLD_STOP, battery, value))\n\t\t\treturn -EINVAL;\n\t\treturn count;\n\tdefault:\n\t\tpr_crit(\"Wrong parameter: %d\", what);\n\t\treturn -EINVAL;\n\t}\n\treturn count;\n}\n\nstatic ssize_t tpacpi_battery_show(int what,\n\t\t\t\t   struct device *dev,\n\t\t\t\t   char *buf)\n{\n\tstruct power_supply *supply = to_power_supply(dev);\n\tint ret, battery;\n\t/*\n\t * Some systems have support for more than\n\t * one battery. If that is the case,\n\t * tpacpi_battery_probe marked that addressing\n\t * them individually is supported, so we;\n\t * based on the device struct.\n\t *\n\t * On systems that are not supported, we assume\n\t * the primary as most of the ACPI calls fail\n\t * with \"Any Battery\" as the parameter.\n\t */\n\tif (battery_info.individual_addressing)\n\t\t/* BAT_PRIMARY or BAT_SECONDARY */\n\t\tbattery = tpacpi_battery_get_id(supply->desc->name);\n\telse\n\t\tbattery = BAT_PRIMARY;\n\tif (tpacpi_battery_get(what, battery, &ret))\n\t\treturn -ENODEV;\n\treturn sprintf(buf, \"%d\\n\", ret);\n}\n\nstatic ssize_t charge_control_start_threshold_show(struct device *device,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn tpacpi_battery_show(THRESHOLD_START, device, buf);\n}\n\nstatic ssize_t charge_control_end_threshold_show(struct device *device,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn tpacpi_battery_show(THRESHOLD_STOP, device, buf);\n}\n\nstatic ssize_t charge_control_start_threshold_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\treturn tpacpi_battery_store(THRESHOLD_START, dev, buf, count);\n}\n\nstatic ssize_t charge_control_end_threshold_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\treturn tpacpi_battery_store(THRESHOLD_STOP, dev, buf, count);\n}\n\nstatic DEVICE_ATTR_RW(charge_control_start_threshold);\nstatic DEVICE_ATTR_RW(charge_control_end_threshold);\nstatic struct device_attribute dev_attr_charge_start_threshold = __ATTR(\n\tcharge_start_threshold,\n\t0644,\n\tcharge_control_start_threshold_show,\n\tcharge_control_start_threshold_store\n);\nstatic struct device_attribute dev_attr_charge_stop_threshold = __ATTR(\n\tcharge_stop_threshold,\n\t0644,\n\tcharge_control_end_threshold_show,\n\tcharge_control_end_threshold_store\n);\n\nstatic struct attribute *tpacpi_battery_attrs[] = {\n\t&dev_attr_charge_control_start_threshold.attr,\n\t&dev_attr_charge_control_end_threshold.attr,\n\t&dev_attr_charge_start_threshold.attr,\n\t&dev_attr_charge_stop_threshold.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(tpacpi_battery);\n\n/* ACPI battery hooking */\n\nstatic int tpacpi_battery_add(struct power_supply *battery)\n{\n\tint batteryid = tpacpi_battery_get_id(battery->desc->name);\n\n\tif (tpacpi_battery_probe(batteryid))\n\t\treturn -ENODEV;\n\tif (device_add_groups(&battery->dev, tpacpi_battery_groups))\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int tpacpi_battery_remove(struct power_supply *battery)\n{\n\tdevice_remove_groups(&battery->dev, tpacpi_battery_groups);\n\treturn 0;\n}\n\nstatic struct acpi_battery_hook battery_hook = {\n\t.add_battery = tpacpi_battery_add,\n\t.remove_battery = tpacpi_battery_remove,\n\t.name = \"ThinkPad Battery Extension\",\n};\n\n/* Subdriver init/exit */\n\nstatic const struct tpacpi_quirk battery_quirk_table[] __initconst = {\n\t/*\n\t * Individual addressing is broken on models that expose the\n\t * primary battery as BAT1.\n\t */\n\tTPACPI_Q_LNV('J', '7', true),       /* B5400 */\n\tTPACPI_Q_LNV('J', 'I', true),       /* Thinkpad 11e */\n\tTPACPI_Q_LNV3('R', '0', 'B', true), /* Thinkpad 11e gen 3 */\n\tTPACPI_Q_LNV3('R', '0', 'C', true), /* Thinkpad 13 */\n\tTPACPI_Q_LNV3('R', '0', 'J', true), /* Thinkpad 13 gen 2 */\n\tTPACPI_Q_LNV3('R', '0', 'K', true), /* Thinkpad 11e gen 4 celeron BIOS */\n};\n\nstatic int __init tpacpi_battery_init(struct ibm_init_struct *ibm)\n{\n\tmemset(&battery_info, 0, sizeof(battery_info));\n\n\ttp_features.battery_force_primary = tpacpi_check_quirks(\n\t\t\t\t\tbattery_quirk_table,\n\t\t\t\t\tARRAY_SIZE(battery_quirk_table));\n\n\tbattery_hook_register(&battery_hook);\n\treturn 0;\n}\n\nstatic void tpacpi_battery_exit(void)\n{\n\tbattery_hook_unregister(&battery_hook);\n}\n\nstatic struct ibm_struct battery_driver_data = {\n\t.name = \"battery\",\n\t.exit = tpacpi_battery_exit,\n};\n\n/*************************************************************************\n * LCD Shadow subdriver, for the Lenovo PrivacyGuard feature\n */\n\nstatic int lcdshadow_state;\n\nstatic int lcdshadow_on_off(bool state)\n{\n\tacpi_handle set_shadow_handle;\n\tint output;\n\n\tif (ACPI_FAILURE(acpi_get_handle(hkey_handle, \"SSSS\", &set_shadow_handle))) {\n\t\tpr_warn(\"Thinkpad ACPI has no %s interface.\\n\", \"SSSS\");\n\t\treturn -EIO;\n\t}\n\n\tif (!acpi_evalf(set_shadow_handle, &output, NULL, \"dd\", (int)state))\n\t\treturn -EIO;\n\n\tlcdshadow_state = state;\n\treturn 0;\n}\n\nstatic int lcdshadow_set(bool on)\n{\n\tif (lcdshadow_state < 0)\n\t\treturn lcdshadow_state;\n\tif (lcdshadow_state == on)\n\t\treturn 0;\n\treturn lcdshadow_on_off(on);\n}\n\nstatic int tpacpi_lcdshadow_init(struct ibm_init_struct *iibm)\n{\n\tacpi_handle get_shadow_handle;\n\tint output;\n\n\tif (ACPI_FAILURE(acpi_get_handle(hkey_handle, \"GSSS\", &get_shadow_handle))) {\n\t\tlcdshadow_state = -ENODEV;\n\t\treturn 0;\n\t}\n\n\tif (!acpi_evalf(get_shadow_handle, &output, NULL, \"dd\", 0)) {\n\t\tlcdshadow_state = -EIO;\n\t\treturn -EIO;\n\t}\n\tif (!(output & 0x10000)) {\n\t\tlcdshadow_state = -ENODEV;\n\t\treturn 0;\n\t}\n\tlcdshadow_state = output & 0x1;\n\n\treturn 0;\n}\n\nstatic void lcdshadow_resume(void)\n{\n\tif (lcdshadow_state >= 0)\n\t\tlcdshadow_on_off(lcdshadow_state);\n}\n\nstatic int lcdshadow_read(struct seq_file *m)\n{\n\tif (lcdshadow_state < 0) {\n\t\tseq_puts(m, \"status:\\t\\tnot supported\\n\");\n\t} else {\n\t\tseq_printf(m, \"status:\\t\\t%d\\n\", lcdshadow_state);\n\t\tseq_puts(m, \"commands:\\t0, 1\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int lcdshadow_write(char *buf)\n{\n\tchar *cmd;\n\tint res, state = -EINVAL;\n\n\tif (lcdshadow_state < 0)\n\t\treturn -ENODEV;\n\n\twhile ((cmd = strsep(&buf, \",\"))) {\n\t\tres = kstrtoint(cmd, 10, &state);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t}\n\n\tif (state >= 2 || state < 0)\n\t\treturn -EINVAL;\n\n\treturn lcdshadow_set(state);\n}\n\nstatic struct ibm_struct lcdshadow_driver_data = {\n\t.name = \"lcdshadow\",\n\t.resume = lcdshadow_resume,\n\t.read = lcdshadow_read,\n\t.write = lcdshadow_write,\n};\n\n/*************************************************************************\n * Thinkpad sensor interfaces\n */\n\n#define DYTC_CMD_GET          2 /* To get current IC function and mode */\n#define DYTC_GET_LAPMODE_BIT 17 /* Set when in lapmode */\n\n#define PALMSENSOR_PRESENT_BIT 0 /* Determine if psensor present */\n#define PALMSENSOR_ON_BIT      1 /* psensor status */\n\nstatic bool has_palmsensor;\nstatic bool has_lapsensor;\nstatic bool palm_state;\nstatic bool lap_state;\n\nstatic int dytc_command(int command, int *output)\n{\n\tacpi_handle dytc_handle;\n\n\tif (ACPI_FAILURE(acpi_get_handle(hkey_handle, \"DYTC\", &dytc_handle))) {\n\t\t/* Platform doesn't support DYTC */\n\t\treturn -ENODEV;\n\t}\n\tif (!acpi_evalf(dytc_handle, output, NULL, \"dd\", command))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int lapsensor_get(bool *present, bool *state)\n{\n\tint output, err;\n\n\t*present = false;\n\terr = dytc_command(DYTC_CMD_GET, &output);\n\tif (err)\n\t\treturn err;\n\n\t*present = true; /*If we get his far, we have lapmode support*/\n\t*state = output & BIT(DYTC_GET_LAPMODE_BIT) ? true : false;\n\treturn 0;\n}\n\nstatic int palmsensor_get(bool *present, bool *state)\n{\n\tacpi_handle psensor_handle;\n\tint output;\n\n\t*present = false;\n\tif (ACPI_FAILURE(acpi_get_handle(hkey_handle, \"GPSS\", &psensor_handle)))\n\t\treturn -ENODEV;\n\tif (!acpi_evalf(psensor_handle, &output, NULL, \"d\"))\n\t\treturn -EIO;\n\n\t*present = output & BIT(PALMSENSOR_PRESENT_BIT) ? true : false;\n\t*state = output & BIT(PALMSENSOR_ON_BIT) ? true : false;\n\treturn 0;\n}\n\nstatic void lapsensor_refresh(void)\n{\n\tbool state;\n\tint err;\n\n\tif (has_lapsensor) {\n\t\terr = lapsensor_get(&has_lapsensor, &state);\n\t\tif (err)\n\t\t\treturn;\n\t\tif (lap_state != state) {\n\t\t\tlap_state = state;\n\t\t\tsysfs_notify(&tpacpi_pdev->dev.kobj, NULL, \"dytc_lapmode\");\n\t\t}\n\t}\n}\n\nstatic void palmsensor_refresh(void)\n{\n\tbool state;\n\tint err;\n\n\tif (has_palmsensor) {\n\t\terr = palmsensor_get(&has_palmsensor, &state);\n\t\tif (err)\n\t\t\treturn;\n\t\tif (palm_state != state) {\n\t\t\tpalm_state = state;\n\t\t\tsysfs_notify(&tpacpi_pdev->dev.kobj, NULL, \"palmsensor\");\n\t\t}\n\t}\n}\n\nstatic ssize_t dytc_lapmode_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tif (has_lapsensor)\n\t\treturn sysfs_emit(buf, \"%d\\n\", lap_state);\n\treturn sysfs_emit(buf, \"\\n\");\n}\nstatic DEVICE_ATTR_RO(dytc_lapmode);\n\nstatic ssize_t palmsensor_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tif (has_palmsensor)\n\t\treturn sysfs_emit(buf, \"%d\\n\", palm_state);\n\treturn sysfs_emit(buf, \"\\n\");\n}\nstatic DEVICE_ATTR_RO(palmsensor);\n\nstatic int tpacpi_proxsensor_init(struct ibm_init_struct *iibm)\n{\n\tint palm_err, lap_err, err;\n\n\tpalm_err = palmsensor_get(&has_palmsensor, &palm_state);\n\tlap_err = lapsensor_get(&has_lapsensor, &lap_state);\n\t/*\n\t * If support isn't available (ENODEV) for both devices then quit, but\n\t * don't return an error.\n\t */\n\tif ((palm_err == -ENODEV) && (lap_err == -ENODEV))\n\t\treturn 0;\n\t/* Otherwise, if there was an error return it */\n\tif (palm_err && (palm_err != -ENODEV))\n\t\treturn palm_err;\n\tif (lap_err && (lap_err != -ENODEV))\n\t\treturn lap_err;\n\n\tif (has_palmsensor) {\n\t\terr = sysfs_create_file(&tpacpi_pdev->dev.kobj, &dev_attr_palmsensor.attr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (has_lapsensor) {\n\t\terr = sysfs_create_file(&tpacpi_pdev->dev.kobj, &dev_attr_dytc_lapmode.attr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void proxsensor_exit(void)\n{\n\tif (has_lapsensor)\n\t\tsysfs_remove_file(&tpacpi_pdev->dev.kobj, &dev_attr_dytc_lapmode.attr);\n\tif (has_palmsensor)\n\t\tsysfs_remove_file(&tpacpi_pdev->dev.kobj, &dev_attr_palmsensor.attr);\n}\n\nstatic struct ibm_struct proxsensor_driver_data = {\n\t.name = \"proximity-sensor\",\n\t.exit = proxsensor_exit,\n};\n\n/*************************************************************************\n * DYTC Platform Profile interface\n */\n\n#define DYTC_CMD_QUERY        0 /* To get DYTC status - enable/revision */\n#define DYTC_CMD_SET          1 /* To enable/disable IC function mode */\n#define DYTC_CMD_RESET    0x1ff /* To reset back to default */\n\n#define DYTC_QUERY_ENABLE_BIT 8  /* Bit        8 - 0 = disabled, 1 = enabled */\n#define DYTC_QUERY_SUBREV_BIT 16 /* Bits 16 - 27 - sub revision */\n#define DYTC_QUERY_REV_BIT    28 /* Bits 28 - 31 - revision */\n\n#define DYTC_GET_FUNCTION_BIT 8  /* Bits  8-11 - function setting */\n#define DYTC_GET_MODE_BIT     12 /* Bits 12-15 - mode setting */\n\n#define DYTC_SET_FUNCTION_BIT 12 /* Bits 12-15 - function setting */\n#define DYTC_SET_MODE_BIT     16 /* Bits 16-19 - mode setting */\n#define DYTC_SET_VALID_BIT    20 /* Bit     20 - 1 = on, 0 = off */\n\n#define DYTC_FUNCTION_STD     0  /* Function = 0, standard mode */\n#define DYTC_FUNCTION_CQL     1  /* Function = 1, lap mode */\n#define DYTC_FUNCTION_MMC     11 /* Function = 11, desk mode */\n\n#define DYTC_MODE_PERFORM     2  /* High power mode aka performance */\n#define DYTC_MODE_LOWPOWER    3  /* Low power mode */\n#define DYTC_MODE_BALANCE   0xF  /* Default mode aka balanced */\n\n#define DYTC_SET_COMMAND(function, mode, on) \\\n\t(DYTC_CMD_SET | (function) << DYTC_SET_FUNCTION_BIT | \\\n\t (mode) << DYTC_SET_MODE_BIT | \\\n\t (on) << DYTC_SET_VALID_BIT)\n\n#define DYTC_DISABLE_CQL DYTC_SET_COMMAND(DYTC_FUNCTION_CQL, DYTC_MODE_BALANCE, 0)\n\n#define DYTC_ENABLE_CQL DYTC_SET_COMMAND(DYTC_FUNCTION_CQL, DYTC_MODE_BALANCE, 1)\n\nstatic bool dytc_profile_available;\nstatic enum platform_profile_option dytc_current_profile;\nstatic atomic_t dytc_ignore_event = ATOMIC_INIT(0);\nstatic DEFINE_MUTEX(dytc_mutex);\n\nstatic int convert_dytc_to_profile(int dytcmode, enum platform_profile_option *profile)\n{\n\tswitch (dytcmode) {\n\tcase DYTC_MODE_LOWPOWER:\n\t\t*profile = PLATFORM_PROFILE_LOW_POWER;\n\t\tbreak;\n\tcase DYTC_MODE_BALANCE:\n\t\t*profile =  PLATFORM_PROFILE_BALANCED;\n\t\tbreak;\n\tcase DYTC_MODE_PERFORM:\n\t\t*profile =  PLATFORM_PROFILE_PERFORMANCE;\n\t\tbreak;\n\tdefault: /* Unknown mode */\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int convert_profile_to_dytc(enum platform_profile_option profile, int *perfmode)\n{\n\tswitch (profile) {\n\tcase PLATFORM_PROFILE_LOW_POWER:\n\t\t*perfmode = DYTC_MODE_LOWPOWER;\n\t\tbreak;\n\tcase PLATFORM_PROFILE_BALANCED:\n\t\t*perfmode = DYTC_MODE_BALANCE;\n\t\tbreak;\n\tcase PLATFORM_PROFILE_PERFORMANCE:\n\t\t*perfmode = DYTC_MODE_PERFORM;\n\t\tbreak;\n\tdefault: /* Unknown profile */\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n/*\n * dytc_profile_get: Function to register with platform_profile\n * handler. Returns current platform profile.\n */\nstatic int dytc_profile_get(struct platform_profile_handler *pprof,\n\t\t\t    enum platform_profile_option *profile)\n{\n\t*profile = dytc_current_profile;\n\treturn 0;\n}\n\n/*\n * Helper function - check if we are in CQL mode and if we are\n *  -  disable CQL,\n *  - run the command\n *  - enable CQL\n *  If not in CQL mode, just run the command\n */\nstatic int dytc_cql_command(int command, int *output)\n{\n\tint err, cmd_err, dummy;\n\tint cur_funcmode;\n\n\t/* Determine if we are in CQL mode. This alters the commands we do */\n\terr = dytc_command(DYTC_CMD_GET, output);\n\tif (err)\n\t\treturn err;\n\n\tcur_funcmode = (*output >> DYTC_GET_FUNCTION_BIT) & 0xF;\n\t/* Check if we're OK to return immediately */\n\tif ((command == DYTC_CMD_GET) && (cur_funcmode != DYTC_FUNCTION_CQL))\n\t\treturn 0;\n\n\tif (cur_funcmode == DYTC_FUNCTION_CQL) {\n\t\tatomic_inc(&dytc_ignore_event);\n\t\terr = dytc_command(DYTC_DISABLE_CQL, &dummy);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tcmd_err = dytc_command(command,\toutput);\n\t/* Check return condition after we've restored CQL state */\n\n\tif (cur_funcmode == DYTC_FUNCTION_CQL) {\n\t\terr = dytc_command(DYTC_ENABLE_CQL, &dummy);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn cmd_err;\n}\n\n/*\n * dytc_profile_set: Function to register with platform_profile\n * handler. Sets current platform profile.\n */\nstatic int dytc_profile_set(struct platform_profile_handler *pprof,\n\t\t\t    enum platform_profile_option profile)\n{\n\tint output;\n\tint err;\n\n\tif (!dytc_profile_available)\n\t\treturn -ENODEV;\n\n\terr = mutex_lock_interruptible(&dytc_mutex);\n\tif (err)\n\t\treturn err;\n\n\tif (profile == PLATFORM_PROFILE_BALANCED) {\n\t\t/* To get back to balanced mode we just issue a reset command */\n\t\terr = dytc_command(DYTC_CMD_RESET, &output);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t} else {\n\t\tint perfmode;\n\n\t\terr = convert_profile_to_dytc(profile, &perfmode);\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\t/* Determine if we are in CQL mode. This alters the commands we do */\n\t\terr = dytc_cql_command(DYTC_SET_COMMAND(DYTC_FUNCTION_MMC, perfmode, 1), &output);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\t/* Success - update current profile */\n\tdytc_current_profile = profile;\nunlock:\n\tmutex_unlock(&dytc_mutex);\n\treturn err;\n}\n\nstatic void dytc_profile_refresh(void)\n{\n\tenum platform_profile_option profile;\n\tint output, err;\n\tint perfmode;\n\n\tmutex_lock(&dytc_mutex);\n\terr = dytc_cql_command(DYTC_CMD_GET, &output);\n\tmutex_unlock(&dytc_mutex);\n\tif (err)\n\t\treturn;\n\n\tperfmode = (output >> DYTC_GET_MODE_BIT) & 0xF;\n\tconvert_dytc_to_profile(perfmode, &profile);\n\tif (profile != dytc_current_profile) {\n\t\tdytc_current_profile = profile;\n\t\tplatform_profile_notify();\n\t}\n}\n\nstatic struct platform_profile_handler dytc_profile = {\n\t.profile_get = dytc_profile_get,\n\t.profile_set = dytc_profile_set,\n};\n\nstatic int tpacpi_dytc_profile_init(struct ibm_init_struct *iibm)\n{\n\tint err, output;\n\n\t/* Setup supported modes */\n\tset_bit(PLATFORM_PROFILE_LOW_POWER, dytc_profile.choices);\n\tset_bit(PLATFORM_PROFILE_BALANCED, dytc_profile.choices);\n\tset_bit(PLATFORM_PROFILE_PERFORMANCE, dytc_profile.choices);\n\n\tdytc_profile_available = false;\n\terr = dytc_command(DYTC_CMD_QUERY, &output);\n\t/*\n\t * If support isn't available (ENODEV) then don't return an error\n\t * and don't create the sysfs group\n\t */\n\tif (err == -ENODEV)\n\t\treturn 0;\n\t/* For all other errors we can flag the failure */\n\tif (err)\n\t\treturn err;\n\n\t/* Check DYTC is enabled and supports mode setting */\n\tif (output & BIT(DYTC_QUERY_ENABLE_BIT)) {\n\t\t/* Only DYTC v5.0 and later has this feature. */\n\t\tint dytc_version;\n\n\t\tdytc_version = (output >> DYTC_QUERY_REV_BIT) & 0xF;\n\t\tif (dytc_version >= 5) {\n\t\t\tdbg_printk(TPACPI_DBG_INIT,\n\t\t\t\t   \"DYTC version %d: thermal mode available\\n\", dytc_version);\n\t\t\t/* Create platform_profile structure and register */\n\t\t\terr = platform_profile_register(&dytc_profile);\n\t\t\t/*\n\t\t\t * If for some reason platform_profiles aren't enabled\n\t\t\t * don't quit terminally.\n\t\t\t */\n\t\t\tif (err)\n\t\t\t\treturn 0;\n\n\t\t\tdytc_profile_available = true;\n\t\t\t/* Ensure initial values are correct */\n\t\t\tdytc_profile_refresh();\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void dytc_profile_exit(void)\n{\n\tif (dytc_profile_available) {\n\t\tdytc_profile_available = false;\n\t\tplatform_profile_remove();\n\t}\n}\n\nstatic struct ibm_struct  dytc_profile_driver_data = {\n\t.name = \"dytc-profile\",\n\t.exit = dytc_profile_exit,\n};\n\n/*************************************************************************\n * Keyboard language interface\n */\n\nstruct keyboard_lang_data {\n\tconst char *lang_str;\n\tint lang_code;\n};\n\nstatic const struct keyboard_lang_data keyboard_lang_data[] = {\n\t{\"be\", 0x080c},\n\t{\"cz\", 0x0405},\n\t{\"da\", 0x0406},\n\t{\"de\", 0x0c07},\n\t{\"en\", 0x0000},\n\t{\"es\", 0x2c0a},\n\t{\"et\", 0x0425},\n\t{\"fr\", 0x040c},\n\t{\"fr-ch\", 0x100c},\n\t{\"hu\", 0x040e},\n\t{\"it\", 0x0410},\n\t{\"jp\", 0x0411},\n\t{\"nl\", 0x0413},\n\t{\"nn\", 0x0414},\n\t{\"pl\", 0x0415},\n\t{\"pt\", 0x0816},\n\t{\"sl\", 0x041b},\n\t{\"sv\", 0x081d},\n\t{\"tr\", 0x041f},\n};\n\nstatic int set_keyboard_lang_command(int command)\n{\n\tacpi_handle sskl_handle;\n\tint output;\n\n\tif (ACPI_FAILURE(acpi_get_handle(hkey_handle, \"SSKL\", &sskl_handle))) {\n\t\t/* Platform doesn't support SSKL */\n\t\treturn -ENODEV;\n\t}\n\n\tif (!acpi_evalf(sskl_handle, &output, NULL, \"dd\", command))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int get_keyboard_lang(int *output)\n{\n\tacpi_handle gskl_handle;\n\tint kbd_lang;\n\n\tif (ACPI_FAILURE(acpi_get_handle(hkey_handle, \"GSKL\", &gskl_handle))) {\n\t\t/* Platform doesn't support GSKL */\n\t\treturn -ENODEV;\n\t}\n\n\tif (!acpi_evalf(gskl_handle, &kbd_lang, NULL, \"dd\", 0x02000000))\n\t\treturn -EIO;\n\n\t/*\n\t * METHOD_ERR gets returned on devices where there are no special (e.g. '=',\n\t * '(' and ')') keys which use layout dependent key-press emulation.\n\t */\n\tif (kbd_lang & METHOD_ERR)\n\t\treturn -ENODEV;\n\n\t*output = kbd_lang;\n\n\treturn 0;\n}\n\n/* sysfs keyboard language entry */\nstatic ssize_t keyboard_lang_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tint output, err, i, len = 0;\n\n\terr = get_keyboard_lang(&output);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(keyboard_lang_data); i++) {\n\t\tif (i)\n\t\t\tlen += sysfs_emit_at(buf, len, \"%s\", \" \");\n\n\t\tif (output == keyboard_lang_data[i].lang_code) {\n\t\t\tlen += sysfs_emit_at(buf, len, \"[%s]\", keyboard_lang_data[i].lang_str);\n\t\t} else {\n\t\t\tlen += sysfs_emit_at(buf, len, \"%s\", keyboard_lang_data[i].lang_str);\n\t\t}\n\t}\n\tlen += sysfs_emit_at(buf, len, \"\\n\");\n\n\treturn len;\n}\n\nstatic ssize_t keyboard_lang_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tint err, i;\n\tbool lang_found = false;\n\tint lang_code = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(keyboard_lang_data); i++) {\n\t\tif (sysfs_streq(buf, keyboard_lang_data[i].lang_str)) {\n\t\t\tlang_code = keyboard_lang_data[i].lang_code;\n\t\t\tlang_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (lang_found) {\n\t\tlang_code = lang_code | 1 << 24;\n\n\t\t/* Set language code */\n\t\terr = set_keyboard_lang_command(lang_code);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tdev_err(&tpacpi_pdev->dev, \"Unknown Keyboard language. Ignoring\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttpacpi_disclose_usertask(attr->attr.name,\n\t\t\t\"keyboard language is set to  %s\\n\", buf);\n\n\tsysfs_notify(&tpacpi_pdev->dev.kobj, NULL, \"keyboard_lang\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(keyboard_lang);\n\nstatic struct attribute *kbdlang_attributes[] = {\n\t&dev_attr_keyboard_lang.attr,\n\tNULL\n};\n\nstatic const struct attribute_group kbdlang_attr_group = {\n\t.attrs = kbdlang_attributes,\n};\n\nstatic int tpacpi_kbdlang_init(struct ibm_init_struct *iibm)\n{\n\tint err, output;\n\n\terr = get_keyboard_lang(&output);\n\t/*\n\t * If support isn't available (ENODEV) then don't return an error\n\t * just don't create the sysfs group.\n\t */\n\tif (err == -ENODEV)\n\t\treturn 0;\n\n\tif (err)\n\t\treturn err;\n\n\t/* Platform supports this feature - create the sysfs file */\n\treturn sysfs_create_group(&tpacpi_pdev->dev.kobj, &kbdlang_attr_group);\n}\n\nstatic void kbdlang_exit(void)\n{\n\tsysfs_remove_group(&tpacpi_pdev->dev.kobj, &kbdlang_attr_group);\n}\n\nstatic struct ibm_struct kbdlang_driver_data = {\n\t.name = \"kbdlang\",\n\t.exit = kbdlang_exit,\n};\n\n/****************************************************************************\n ****************************************************************************\n *\n * Infrastructure\n *\n ****************************************************************************\n ****************************************************************************/\n\n/*\n * HKEY event callout for other subdrivers go here\n * (yes, it is ugly, but it is quick, safe, and gets the job done\n */\nstatic void tpacpi_driver_event(const unsigned int hkey_event)\n{\n\tif (ibm_backlight_device) {\n\t\tswitch (hkey_event) {\n\t\tcase TP_HKEY_EV_BRGHT_UP:\n\t\tcase TP_HKEY_EV_BRGHT_DOWN:\n\t\t\ttpacpi_brightness_notify_change();\n\t\t}\n\t}\n\tif (alsa_card) {\n\t\tswitch (hkey_event) {\n\t\tcase TP_HKEY_EV_VOL_UP:\n\t\tcase TP_HKEY_EV_VOL_DOWN:\n\t\tcase TP_HKEY_EV_VOL_MUTE:\n\t\t\tvolume_alsa_notify_change();\n\t\t}\n\t}\n\tif (tp_features.kbdlight && hkey_event == TP_HKEY_EV_KBD_LIGHT) {\n\t\tenum led_brightness brightness;\n\n\t\tmutex_lock(&kbdlight_mutex);\n\n\t\t/*\n\t\t * Check the brightness actually changed, setting the brightness\n\t\t * through kbdlight_set_level() also triggers this event.\n\t\t */\n\t\tbrightness = kbdlight_sysfs_get(NULL);\n\t\tif (kbdlight_brightness != brightness) {\n\t\t\tkbdlight_brightness = brightness;\n\t\t\tled_classdev_notify_brightness_hw_changed(\n\t\t\t\t&tpacpi_led_kbdlight.led_classdev, brightness);\n\t\t}\n\n\t\tmutex_unlock(&kbdlight_mutex);\n\t}\n\n\tif (hkey_event == TP_HKEY_EV_THM_CSM_COMPLETED) {\n\t\tlapsensor_refresh();\n\t\t/* If we are already accessing DYTC then skip dytc update */\n\t\tif (!atomic_add_unless(&dytc_ignore_event, -1, 0))\n\t\t\tdytc_profile_refresh();\n\t}\n}\n\nstatic void hotkey_driver_event(const unsigned int scancode)\n{\n\ttpacpi_driver_event(TP_HKEY_EV_HOTKEY_BASE + scancode);\n}\n\n/* --------------------------------------------------------------------- */\n\n/* /proc support */\nstatic struct proc_dir_entry *proc_dir;\n\n/*\n * Module and infrastructure proble, init and exit handling\n */\n\nstatic bool force_load;\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUG\nstatic const char * __init str_supported(int is_supported)\n{\n\tstatic char text_unsupported[] __initdata = \"not supported\";\n\n\treturn (is_supported) ? &text_unsupported[4] : &text_unsupported[0];\n}\n#endif /* CONFIG_THINKPAD_ACPI_DEBUG */\n\nstatic void ibm_exit(struct ibm_struct *ibm)\n{\n\tdbg_printk(TPACPI_DBG_EXIT, \"removing %s\\n\", ibm->name);\n\n\tlist_del_init(&ibm->all_drivers);\n\n\tif (ibm->flags.acpi_notify_installed) {\n\t\tdbg_printk(TPACPI_DBG_EXIT,\n\t\t\t\"%s: acpi_remove_notify_handler\\n\", ibm->name);\n\t\tBUG_ON(!ibm->acpi);\n\t\tacpi_remove_notify_handler(*ibm->acpi->handle,\n\t\t\t\t\t   ibm->acpi->type,\n\t\t\t\t\t   dispatch_acpi_notify);\n\t\tibm->flags.acpi_notify_installed = 0;\n\t}\n\n\tif (ibm->flags.proc_created) {\n\t\tdbg_printk(TPACPI_DBG_EXIT,\n\t\t\t\"%s: remove_proc_entry\\n\", ibm->name);\n\t\tremove_proc_entry(ibm->name, proc_dir);\n\t\tibm->flags.proc_created = 0;\n\t}\n\n\tif (ibm->flags.acpi_driver_registered) {\n\t\tdbg_printk(TPACPI_DBG_EXIT,\n\t\t\t\"%s: acpi_bus_unregister_driver\\n\", ibm->name);\n\t\tBUG_ON(!ibm->acpi);\n\t\tacpi_bus_unregister_driver(ibm->acpi->driver);\n\t\tkfree(ibm->acpi->driver);\n\t\tibm->acpi->driver = NULL;\n\t\tibm->flags.acpi_driver_registered = 0;\n\t}\n\n\tif (ibm->flags.init_called && ibm->exit) {\n\t\tibm->exit();\n\t\tibm->flags.init_called = 0;\n\t}\n\n\tdbg_printk(TPACPI_DBG_INIT, \"finished removing %s\\n\", ibm->name);\n}\n\nstatic int __init ibm_init(struct ibm_init_struct *iibm)\n{\n\tint ret;\n\tstruct ibm_struct *ibm = iibm->data;\n\tstruct proc_dir_entry *entry;\n\n\tBUG_ON(ibm == NULL);\n\n\tINIT_LIST_HEAD(&ibm->all_drivers);\n\n\tif (ibm->flags.experimental && !experimental)\n\t\treturn 0;\n\n\tdbg_printk(TPACPI_DBG_INIT,\n\t\t\"probing for %s\\n\", ibm->name);\n\n\tif (iibm->init) {\n\t\tret = iibm->init(iibm);\n\t\tif (ret > 0)\n\t\t\treturn 0;\t/* probe failed */\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tibm->flags.init_called = 1;\n\t}\n\n\tif (ibm->acpi) {\n\t\tif (ibm->acpi->hid) {\n\t\t\tret = register_tpacpi_subdriver(ibm);\n\t\t\tif (ret)\n\t\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (ibm->acpi->notify) {\n\t\t\tret = setup_acpi_notify(ibm);\n\t\t\tif (ret == -ENODEV) {\n\t\t\t\tpr_notice(\"disabling subdriver %s\\n\",\n\t\t\t\t\t  ibm->name);\n\t\t\t\tret = 0;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tdbg_printk(TPACPI_DBG_INIT,\n\t\t\"%s installed\\n\", ibm->name);\n\n\tif (ibm->read) {\n\t\tumode_t mode = iibm->base_procfs_mode;\n\n\t\tif (!mode)\n\t\t\tmode = S_IRUGO;\n\t\tif (ibm->write)\n\t\t\tmode |= S_IWUSR;\n\t\tentry = proc_create_data(ibm->name, mode, proc_dir,\n\t\t\t\t\t &dispatch_proc_ops, ibm);\n\t\tif (!entry) {\n\t\t\tpr_err(\"unable to create proc entry %s\\n\", ibm->name);\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_out;\n\t\t}\n\t\tibm->flags.proc_created = 1;\n\t}\n\n\tlist_add_tail(&ibm->all_drivers, &tpacpi_all_drivers);\n\n\treturn 0;\n\nerr_out:\n\tdbg_printk(TPACPI_DBG_INIT,\n\t\t\"%s: at error exit path with result %d\\n\",\n\t\tibm->name, ret);\n\n\tibm_exit(ibm);\n\treturn (ret < 0) ? ret : 0;\n}\n\n/* Probing */\n\nstatic char __init tpacpi_parse_fw_id(const char * const s,\n\t\t\t\t      u32 *model, u16 *release)\n{\n\tint i;\n\n\tif (!s || strlen(s) < 8)\n\t\tgoto invalid;\n\n\tfor (i = 0; i < 8; i++)\n\t\tif (!((s[i] >= '0' && s[i] <= '9') ||\n\t\t      (s[i] >= 'A' && s[i] <= 'Z')))\n\t\t\tgoto invalid;\n\n\t/*\n\t * Most models: xxyTkkWW (#.##c)\n\t * Ancient 570/600 and -SL lacks (#.##c)\n\t */\n\tif (s[3] == 'T' || s[3] == 'N') {\n\t\t*model = TPID(s[0], s[1]);\n\t\t*release = TPVER(s[4], s[5]);\n\t\treturn s[2];\n\n\t/* New models: xxxyTkkW (#.##c); T550 and some others */\n\t} else if (s[4] == 'T' || s[4] == 'N') {\n\t\t*model = TPID3(s[0], s[1], s[2]);\n\t\t*release = TPVER(s[5], s[6]);\n\t\treturn s[3];\n\t}\n\ninvalid:\n\treturn '\\0';\n}\n\nstatic void find_new_ec_fwstr(const struct dmi_header *dm, void *private)\n{\n\tchar *ec_fw_string = (char *) private;\n\tconst char *dmi_data = (const char *)dm;\n\t/*\n\t * ThinkPad Embedded Controller Program Table on newer models\n\t *\n\t * Offset |  Name                | Width  | Description\n\t * ----------------------------------------------------\n\t *  0x00  | Type                 | BYTE   | 0x8C\n\t *  0x01  | Length               | BYTE   |\n\t *  0x02  | Handle               | WORD   | Varies\n\t *  0x04  | Signature            | BYTEx6 | ASCII for \"LENOVO\"\n\t *  0x0A  | OEM struct offset    | BYTE   | 0x0B\n\t *  0x0B  | OEM struct number    | BYTE   | 0x07, for this structure\n\t *  0x0C  | OEM struct revision  | BYTE   | 0x01, for this format\n\t *  0x0D  | ECP version ID       | STR ID |\n\t *  0x0E  | ECP release date     | STR ID |\n\t */\n\n\t/* Return if data structure not match */\n\tif (dm->type != 140 || dm->length < 0x0F ||\n\tmemcmp(dmi_data + 4, \"LENOVO\", 6) != 0 ||\n\tdmi_data[0x0A] != 0x0B || dmi_data[0x0B] != 0x07 ||\n\tdmi_data[0x0C] != 0x01)\n\t\treturn;\n\n\t/* fwstr is the first 8byte string  */\n\tstrncpy(ec_fw_string, dmi_data + 0x0F, 8);\n}\n\n/* returns 0 - probe ok, or < 0 - probe error.\n * Probe ok doesn't mean thinkpad found.\n * On error, kfree() cleanup on tp->* is not performed, caller must do it */\nstatic int __must_check __init get_thinkpad_model_data(\n\t\t\t\t\t\tstruct thinkpad_id_data *tp)\n{\n\tconst struct dmi_device *dev = NULL;\n\tchar ec_fw_string[18] = {0};\n\tchar const *s;\n\tchar t;\n\n\tif (!tp)\n\t\treturn -EINVAL;\n\n\tmemset(tp, 0, sizeof(*tp));\n\n\tif (dmi_name_in_vendors(\"IBM\"))\n\t\ttp->vendor = PCI_VENDOR_ID_IBM;\n\telse if (dmi_name_in_vendors(\"LENOVO\"))\n\t\ttp->vendor = PCI_VENDOR_ID_LENOVO;\n\telse\n\t\treturn 0;\n\n\ts = dmi_get_system_info(DMI_BIOS_VERSION);\n\ttp->bios_version_str = kstrdup(s, GFP_KERNEL);\n\tif (s && !tp->bios_version_str)\n\t\treturn -ENOMEM;\n\n\t/* Really ancient ThinkPad 240X will fail this, which is fine */\n\tt = tpacpi_parse_fw_id(tp->bios_version_str,\n\t\t\t       &tp->bios_model, &tp->bios_release);\n\tif (t != 'E' && t != 'C')\n\t\treturn 0;\n\n\t/*\n\t * ThinkPad T23 or newer, A31 or newer, R50e or newer,\n\t * X32 or newer, all Z series;  Some models must have an\n\t * up-to-date BIOS or they will not be detected.\n\t *\n\t * See https://thinkwiki.org/wiki/List_of_DMI_IDs\n\t */\n\twhile ((dev = dmi_find_device(DMI_DEV_TYPE_OEM_STRING, NULL, dev))) {\n\t\tif (sscanf(dev->name,\n\t\t\t   \"IBM ThinkPad Embedded Controller -[%17c\",\n\t\t\t   ec_fw_string) == 1) {\n\t\t\tec_fw_string[sizeof(ec_fw_string) - 1] = 0;\n\t\t\tec_fw_string[strcspn(ec_fw_string, \" ]\")] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Newer ThinkPads have different EC program info table */\n\tif (!ec_fw_string[0])\n\t\tdmi_walk(find_new_ec_fwstr, &ec_fw_string);\n\n\tif (ec_fw_string[0]) {\n\t\ttp->ec_version_str = kstrdup(ec_fw_string, GFP_KERNEL);\n\t\tif (!tp->ec_version_str)\n\t\t\treturn -ENOMEM;\n\n\t\tt = tpacpi_parse_fw_id(ec_fw_string,\n\t\t\t &tp->ec_model, &tp->ec_release);\n\t\tif (t != 'H') {\n\t\t\tpr_notice(\"ThinkPad firmware release %s doesn't match the known patterns\\n\",\n\t\t\t\t  ec_fw_string);\n\t\t\tpr_notice(\"please report this to %s\\n\", TPACPI_MAIL);\n\t\t}\n\t}\n\n\ts = dmi_get_system_info(DMI_PRODUCT_VERSION);\n\tif (s && !(strncasecmp(s, \"ThinkPad\", 8) && strncasecmp(s, \"Lenovo\", 6))) {\n\t\ttp->model_str = kstrdup(s, GFP_KERNEL);\n\t\tif (!tp->model_str)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\ts = dmi_get_system_info(DMI_BIOS_VENDOR);\n\t\tif (s && !(strncasecmp(s, \"Lenovo\", 6))) {\n\t\t\ttp->model_str = kstrdup(s, GFP_KERNEL);\n\t\t\tif (!tp->model_str)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\ts = dmi_get_system_info(DMI_PRODUCT_NAME);\n\ttp->nummodel_str = kstrdup(s, GFP_KERNEL);\n\tif (s && !tp->nummodel_str)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int __init probe_for_thinkpad(void)\n{\n\tint is_thinkpad;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\t/* It would be dangerous to run the driver in this case */\n\tif (!tpacpi_is_ibm() && !tpacpi_is_lenovo())\n\t\treturn -ENODEV;\n\n\t/*\n\t * Non-ancient models have better DMI tagging, but very old models\n\t * don't.  tpacpi_is_fw_known() is a cheat to help in that case.\n\t */\n\tis_thinkpad = (thinkpad_id.model_str != NULL) ||\n\t\t      (thinkpad_id.ec_model != 0) ||\n\t\t      tpacpi_is_fw_known();\n\n\t/* The EC handler is required */\n\ttpacpi_acpi_handle_locate(\"ec\", TPACPI_ACPI_EC_HID, &ec_handle);\n\tif (!ec_handle) {\n\t\tif (is_thinkpad)\n\t\t\tpr_err(\"Not yet supported ThinkPad detected!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!is_thinkpad && !force_load)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void __init thinkpad_acpi_init_banner(void)\n{\n\tpr_info(\"%s v%s\\n\", TPACPI_DESC, TPACPI_VERSION);\n\tpr_info(\"%s\\n\", TPACPI_URL);\n\n\tpr_info(\"ThinkPad BIOS %s, EC %s\\n\",\n\t\t(thinkpad_id.bios_version_str) ?\n\t\t\tthinkpad_id.bios_version_str : \"unknown\",\n\t\t(thinkpad_id.ec_version_str) ?\n\t\t\tthinkpad_id.ec_version_str : \"unknown\");\n\n\tBUG_ON(!thinkpad_id.vendor);\n\n\tif (thinkpad_id.model_str)\n\t\tpr_info(\"%s %s, model %s\\n\",\n\t\t\t(thinkpad_id.vendor == PCI_VENDOR_ID_IBM) ?\n\t\t\t\t\"IBM\" : ((thinkpad_id.vendor ==\n\t\t\t\t\t\tPCI_VENDOR_ID_LENOVO) ?\n\t\t\t\t\t\"Lenovo\" : \"Unknown vendor\"),\n\t\t\tthinkpad_id.model_str,\n\t\t\t(thinkpad_id.nummodel_str) ?\n\t\t\t\tthinkpad_id.nummodel_str : \"unknown\");\n}\n\n/* Module init, exit, parameters */\n\nstatic struct ibm_init_struct ibms_init[] __initdata = {\n\t{\n\t\t.data = &thinkpad_acpi_driver_data,\n\t},\n\t{\n\t\t.init = hotkey_init,\n\t\t.data = &hotkey_driver_data,\n\t},\n\t{\n\t\t.init = bluetooth_init,\n\t\t.data = &bluetooth_driver_data,\n\t},\n\t{\n\t\t.init = wan_init,\n\t\t.data = &wan_driver_data,\n\t},\n\t{\n\t\t.init = uwb_init,\n\t\t.data = &uwb_driver_data,\n\t},\n#ifdef CONFIG_THINKPAD_ACPI_VIDEO\n\t{\n\t\t.init = video_init,\n\t\t.base_procfs_mode = S_IRUSR,\n\t\t.data = &video_driver_data,\n\t},\n#endif\n\t{\n\t\t.init = kbdlight_init,\n\t\t.data = &kbdlight_driver_data,\n\t},\n\t{\n\t\t.init = light_init,\n\t\t.data = &light_driver_data,\n\t},\n\t{\n\t\t.init = cmos_init,\n\t\t.data = &cmos_driver_data,\n\t},\n\t{\n\t\t.init = led_init,\n\t\t.data = &led_driver_data,\n\t},\n\t{\n\t\t.init = beep_init,\n\t\t.data = &beep_driver_data,\n\t},\n\t{\n\t\t.init = thermal_init,\n\t\t.data = &thermal_driver_data,\n\t},\n\t{\n\t\t.init = brightness_init,\n\t\t.data = &brightness_driver_data,\n\t},\n\t{\n\t\t.init = volume_init,\n\t\t.data = &volume_driver_data,\n\t},\n\t{\n\t\t.init = fan_init,\n\t\t.data = &fan_driver_data,\n\t},\n\t{\n\t\t.init = mute_led_init,\n\t\t.data = &mute_led_driver_data,\n\t},\n\t{\n\t\t.init = tpacpi_battery_init,\n\t\t.data = &battery_driver_data,\n\t},\n\t{\n\t\t.init = tpacpi_lcdshadow_init,\n\t\t.data = &lcdshadow_driver_data,\n\t},\n\t{\n\t\t.init = tpacpi_proxsensor_init,\n\t\t.data = &proxsensor_driver_data,\n\t},\n\t{\n\t\t.init = tpacpi_dytc_profile_init,\n\t\t.data = &dytc_profile_driver_data,\n\t},\n\t{\n\t\t.init = tpacpi_kbdlang_init,\n\t\t.data = &kbdlang_driver_data,\n\t},\n};\n\nstatic int __init set_ibm_param(const char *val, const struct kernel_param *kp)\n{\n\tunsigned int i;\n\tstruct ibm_struct *ibm;\n\n\tif (!kp || !kp->name || !val)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(ibms_init); i++) {\n\t\tibm = ibms_init[i].data;\n\t\tWARN_ON(ibm == NULL);\n\n\t\tif (!ibm || !ibm->name)\n\t\t\tcontinue;\n\n\t\tif (strcmp(ibm->name, kp->name) == 0 && ibm->write) {\n\t\t\tif (strlen(val) > sizeof(ibms_init[i].param) - 1)\n\t\t\t\treturn -ENOSPC;\n\t\t\tstrcpy(ibms_init[i].param, val);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nmodule_param(experimental, int, 0444);\nMODULE_PARM_DESC(experimental,\n\t\t \"Enables experimental features when non-zero\");\n\nmodule_param_named(debug, dbg_level, uint, 0);\nMODULE_PARM_DESC(debug, \"Sets debug level bit-mask\");\n\nmodule_param(force_load, bool, 0444);\nMODULE_PARM_DESC(force_load,\n\t\t \"Attempts to load the driver even on a mis-identified ThinkPad when true\");\n\nmodule_param_named(fan_control, fan_control_allowed, bool, 0444);\nMODULE_PARM_DESC(fan_control,\n\t\t \"Enables setting fan parameters features when true\");\n\nmodule_param_named(brightness_mode, brightness_mode, uint, 0444);\nMODULE_PARM_DESC(brightness_mode,\n\t\t \"Selects brightness control strategy: 0=auto, 1=EC, 2=UCMS, 3=EC+NVRAM\");\n\nmodule_param(brightness_enable, uint, 0444);\nMODULE_PARM_DESC(brightness_enable,\n\t\t \"Enables backlight control when 1, disables when 0\");\n\n#ifdef CONFIG_THINKPAD_ACPI_ALSA_SUPPORT\nmodule_param_named(volume_mode, volume_mode, uint, 0444);\nMODULE_PARM_DESC(volume_mode,\n\t\t \"Selects volume control strategy: 0=auto, 1=EC, 2=N/A, 3=EC+NVRAM\");\n\nmodule_param_named(volume_capabilities, volume_capabilities, uint, 0444);\nMODULE_PARM_DESC(volume_capabilities,\n\t\t \"Selects the mixer capabilities: 0=auto, 1=volume and mute, 2=mute only\");\n\nmodule_param_named(volume_control, volume_control_allowed, bool, 0444);\nMODULE_PARM_DESC(volume_control,\n\t\t \"Enables software override for the console audio control when true\");\n\nmodule_param_named(software_mute, software_mute_requested, bool, 0444);\nMODULE_PARM_DESC(software_mute,\n\t\t \"Request full software mute control\");\n\n/* ALSA module API parameters */\nmodule_param_named(index, alsa_index, int, 0444);\nMODULE_PARM_DESC(index, \"ALSA index for the ACPI EC Mixer\");\nmodule_param_named(id, alsa_id, charp, 0444);\nMODULE_PARM_DESC(id, \"ALSA id for the ACPI EC Mixer\");\nmodule_param_named(enable, alsa_enable, bool, 0444);\nMODULE_PARM_DESC(enable, \"Enable the ALSA interface for the ACPI EC Mixer\");\n#endif /* CONFIG_THINKPAD_ACPI_ALSA_SUPPORT */\n\n/* The module parameter can't be read back, that's why 0 is used here */\n#define TPACPI_PARAM(feature) \\\n\tmodule_param_call(feature, set_ibm_param, NULL, NULL, 0); \\\n\tMODULE_PARM_DESC(feature, \"Simulates thinkpad-acpi procfs command at module load, see documentation\")\n\nTPACPI_PARAM(hotkey);\nTPACPI_PARAM(bluetooth);\nTPACPI_PARAM(video);\nTPACPI_PARAM(light);\nTPACPI_PARAM(cmos);\nTPACPI_PARAM(led);\nTPACPI_PARAM(beep);\nTPACPI_PARAM(brightness);\nTPACPI_PARAM(volume);\nTPACPI_PARAM(fan);\n\n#ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES\nmodule_param(dbg_wlswemul, uint, 0444);\nMODULE_PARM_DESC(dbg_wlswemul, \"Enables WLSW emulation\");\nmodule_param_named(wlsw_state, tpacpi_wlsw_emulstate, bool, 0);\nMODULE_PARM_DESC(wlsw_state,\n\t\t \"Initial state of the emulated WLSW switch\");\n\nmodule_param(dbg_bluetoothemul, uint, 0444);\nMODULE_PARM_DESC(dbg_bluetoothemul, \"Enables bluetooth switch emulation\");\nmodule_param_named(bluetooth_state, tpacpi_bluetooth_emulstate, bool, 0);\nMODULE_PARM_DESC(bluetooth_state,\n\t\t \"Initial state of the emulated bluetooth switch\");\n\nmodule_param(dbg_wwanemul, uint, 0444);\nMODULE_PARM_DESC(dbg_wwanemul, \"Enables WWAN switch emulation\");\nmodule_param_named(wwan_state, tpacpi_wwan_emulstate, bool, 0);\nMODULE_PARM_DESC(wwan_state,\n\t\t \"Initial state of the emulated WWAN switch\");\n\nmodule_param(dbg_uwbemul, uint, 0444);\nMODULE_PARM_DESC(dbg_uwbemul, \"Enables UWB switch emulation\");\nmodule_param_named(uwb_state, tpacpi_uwb_emulstate, bool, 0);\nMODULE_PARM_DESC(uwb_state,\n\t\t \"Initial state of the emulated UWB switch\");\n#endif\n\nstatic void thinkpad_acpi_module_exit(void)\n{\n\tstruct ibm_struct *ibm, *itmp;\n\n\ttpacpi_lifecycle = TPACPI_LIFE_EXITING;\n\n\tlist_for_each_entry_safe_reverse(ibm, itmp,\n\t\t\t\t\t &tpacpi_all_drivers,\n\t\t\t\t\t all_drivers) {\n\t\tibm_exit(ibm);\n\t}\n\n\tdbg_printk(TPACPI_DBG_INIT, \"finished subdriver exit path...\\n\");\n\n\tif (tpacpi_inputdev) {\n\t\tif (tp_features.input_device_registered)\n\t\t\tinput_unregister_device(tpacpi_inputdev);\n\t\telse\n\t\t\tinput_free_device(tpacpi_inputdev);\n\t\tkfree(hotkey_keycode_map);\n\t}\n\n\tif (tpacpi_hwmon)\n\t\thwmon_device_unregister(tpacpi_hwmon);\n\n\tif (tpacpi_sensors_pdev)\n\t\tplatform_device_unregister(tpacpi_sensors_pdev);\n\tif (tpacpi_pdev)\n\t\tplatform_device_unregister(tpacpi_pdev);\n\n\tif (tp_features.sensors_pdrv_attrs_registered)\n\t\ttpacpi_remove_driver_attributes(&tpacpi_hwmon_pdriver.driver);\n\tif (tp_features.platform_drv_attrs_registered)\n\t\ttpacpi_remove_driver_attributes(&tpacpi_pdriver.driver);\n\n\tif (tp_features.sensors_pdrv_registered)\n\t\tplatform_driver_unregister(&tpacpi_hwmon_pdriver);\n\n\tif (tp_features.platform_drv_registered)\n\t\tplatform_driver_unregister(&tpacpi_pdriver);\n\n\tif (proc_dir)\n\t\tremove_proc_entry(TPACPI_PROC_DIR, acpi_root_dir);\n\n\tif (tpacpi_wq)\n\t\tdestroy_workqueue(tpacpi_wq);\n\n\tkfree(thinkpad_id.bios_version_str);\n\tkfree(thinkpad_id.ec_version_str);\n\tkfree(thinkpad_id.model_str);\n\tkfree(thinkpad_id.nummodel_str);\n}\n\n\nstatic int __init thinkpad_acpi_module_init(void)\n{\n\tint ret, i;\n\n\ttpacpi_lifecycle = TPACPI_LIFE_INIT;\n\n\t/* Driver-level probe */\n\n\tret = get_thinkpad_model_data(&thinkpad_id);\n\tif (ret) {\n\t\tpr_err(\"unable to get DMI data: %d\\n\", ret);\n\t\tthinkpad_acpi_module_exit();\n\t\treturn ret;\n\t}\n\tret = probe_for_thinkpad();\n\tif (ret) {\n\t\tthinkpad_acpi_module_exit();\n\t\treturn ret;\n\t}\n\n\t/* Driver initialization */\n\n\tthinkpad_acpi_init_banner();\n\ttpacpi_check_outdated_fw();\n\n\tTPACPI_ACPIHANDLE_INIT(ecrd);\n\tTPACPI_ACPIHANDLE_INIT(ecwr);\n\n\ttpacpi_wq = create_singlethread_workqueue(TPACPI_WORKQUEUE_NAME);\n\tif (!tpacpi_wq) {\n\t\tthinkpad_acpi_module_exit();\n\t\treturn -ENOMEM;\n\t}\n\n\tproc_dir = proc_mkdir(TPACPI_PROC_DIR, acpi_root_dir);\n\tif (!proc_dir) {\n\t\tpr_err(\"unable to create proc dir \" TPACPI_PROC_DIR \"\\n\");\n\t\tthinkpad_acpi_module_exit();\n\t\treturn -ENODEV;\n\t}\n\n\tret = platform_driver_register(&tpacpi_pdriver);\n\tif (ret) {\n\t\tpr_err(\"unable to register main platform driver\\n\");\n\t\tthinkpad_acpi_module_exit();\n\t\treturn ret;\n\t}\n\ttp_features.platform_drv_registered = 1;\n\n\tret = platform_driver_register(&tpacpi_hwmon_pdriver);\n\tif (ret) {\n\t\tpr_err(\"unable to register hwmon platform driver\\n\");\n\t\tthinkpad_acpi_module_exit();\n\t\treturn ret;\n\t}\n\ttp_features.sensors_pdrv_registered = 1;\n\n\tret = tpacpi_create_driver_attributes(&tpacpi_pdriver.driver);\n\tif (!ret) {\n\t\ttp_features.platform_drv_attrs_registered = 1;\n\t\tret = tpacpi_create_driver_attributes(\n\t\t\t\t\t&tpacpi_hwmon_pdriver.driver);\n\t}\n\tif (ret) {\n\t\tpr_err(\"unable to create sysfs driver attributes\\n\");\n\t\tthinkpad_acpi_module_exit();\n\t\treturn ret;\n\t}\n\ttp_features.sensors_pdrv_attrs_registered = 1;\n\n\n\t/* Device initialization */\n\ttpacpi_pdev = platform_device_register_simple(TPACPI_DRVR_NAME, -1,\n\t\t\t\t\t\t\tNULL, 0);\n\tif (IS_ERR(tpacpi_pdev)) {\n\t\tret = PTR_ERR(tpacpi_pdev);\n\t\ttpacpi_pdev = NULL;\n\t\tpr_err(\"unable to register platform device\\n\");\n\t\tthinkpad_acpi_module_exit();\n\t\treturn ret;\n\t}\n\ttpacpi_sensors_pdev = platform_device_register_simple(\n\t\t\t\t\t\tTPACPI_HWMON_DRVR_NAME,\n\t\t\t\t\t\t-1, NULL, 0);\n\tif (IS_ERR(tpacpi_sensors_pdev)) {\n\t\tret = PTR_ERR(tpacpi_sensors_pdev);\n\t\ttpacpi_sensors_pdev = NULL;\n\t\tpr_err(\"unable to register hwmon platform device\\n\");\n\t\tthinkpad_acpi_module_exit();\n\t\treturn ret;\n\t}\n\ttp_features.sensors_pdev_attrs_registered = 1;\n\ttpacpi_hwmon = hwmon_device_register_with_groups(\n\t\t&tpacpi_sensors_pdev->dev, TPACPI_NAME, NULL, NULL);\n\n\tif (IS_ERR(tpacpi_hwmon)) {\n\t\tret = PTR_ERR(tpacpi_hwmon);\n\t\ttpacpi_hwmon = NULL;\n\t\tpr_err(\"unable to register hwmon device\\n\");\n\t\tthinkpad_acpi_module_exit();\n\t\treturn ret;\n\t}\n\tmutex_init(&tpacpi_inputdev_send_mutex);\n\ttpacpi_inputdev = input_allocate_device();\n\tif (!tpacpi_inputdev) {\n\t\tthinkpad_acpi_module_exit();\n\t\treturn -ENOMEM;\n\t} else {\n\t\t/* Prepare input device, but don't register */\n\t\ttpacpi_inputdev->name = \"ThinkPad Extra Buttons\";\n\t\ttpacpi_inputdev->phys = TPACPI_DRVR_NAME \"/input0\";\n\t\ttpacpi_inputdev->id.bustype = BUS_HOST;\n\t\ttpacpi_inputdev->id.vendor = thinkpad_id.vendor;\n\t\ttpacpi_inputdev->id.product = TPACPI_HKEY_INPUT_PRODUCT;\n\t\ttpacpi_inputdev->id.version = TPACPI_HKEY_INPUT_VERSION;\n\t\ttpacpi_inputdev->dev.parent = &tpacpi_pdev->dev;\n\t}\n\n\t/* Init subdriver dependencies */\n\ttpacpi_detect_brightness_capabilities();\n\n\t/* Init subdrivers */\n\tfor (i = 0; i < ARRAY_SIZE(ibms_init); i++) {\n\t\tret = ibm_init(&ibms_init[i]);\n\t\tif (ret >= 0 && *ibms_init[i].param)\n\t\t\tret = ibms_init[i].data->write(ibms_init[i].param);\n\t\tif (ret < 0) {\n\t\t\tthinkpad_acpi_module_exit();\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ttpacpi_lifecycle = TPACPI_LIFE_RUNNING;\n\n\tret = input_register_device(tpacpi_inputdev);\n\tif (ret < 0) {\n\t\tpr_err(\"unable to register input device\\n\");\n\t\tthinkpad_acpi_module_exit();\n\t\treturn ret;\n\t} else {\n\t\ttp_features.input_device_registered = 1;\n\t}\n\n\treturn 0;\n}\n\nMODULE_ALIAS(TPACPI_DRVR_SHORTNAME);\n\n/*\n * This will autoload the driver in almost every ThinkPad\n * in widespread use.\n *\n * Only _VERY_ old models, like the 240, 240x and 570 lack\n * the HKEY event interface.\n */\nMODULE_DEVICE_TABLE(acpi, ibm_htk_device_ids);\n\n/*\n * DMI matching for module autoloading\n *\n * See https://thinkwiki.org/wiki/List_of_DMI_IDs\n * See https://thinkwiki.org/wiki/BIOS_Upgrade_Downloads\n *\n * Only models listed in thinkwiki will be supported, so add yours\n * if it is not there yet.\n */\n#define IBM_BIOS_MODULE_ALIAS(__type) \\\n\tMODULE_ALIAS(\"dmi:bvnIBM:bvr\" __type \"ET??WW*\")\n\n/* Ancient thinkpad BIOSes have to be identified by\n * BIOS type or model number, and there are far less\n * BIOS types than model numbers... */\nIBM_BIOS_MODULE_ALIAS(\"I[MU]\");\t\t/* 570, 570e */\n\nMODULE_AUTHOR(\"Borislav Deianov <borislav@users.sf.net>\");\nMODULE_AUTHOR(\"Henrique de Moraes Holschuh <hmh@hmh.eng.br>\");\nMODULE_DESCRIPTION(TPACPI_DESC);\nMODULE_VERSION(TPACPI_VERSION);\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(thinkpad_acpi_module_init);\nmodule_exit(thinkpad_acpi_module_exit);\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 0, "line": 3055}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "4555982f0a64c8379b1b39bb878fcc50", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 8711}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "fe91afbb5e7e2fa653744105aefe04d0", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 8728}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "fe91afbb5e7e2fa653744105aefe04d0", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 8592}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "53a13476776e0af992512590f126b4fa", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 8658}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "d8fe2d789218db4154252fb86655b4eb", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 2846}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "5ddda8da4ea709c9a53cda7b3b796e92", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 2835}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "5ddda8da4ea709c9a53cda7b3b796e92", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 2825}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "a316136ba6b8a9c8c2712e3b91dceacf", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 2749}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "d0f974e41263d71c36023feff87759a7", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 2777}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "2bf90237841e0153a1ab1ffde9c7b853", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 2922}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "3a7605867ef509a40a5fd0ba63ebb4e7", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 2964}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "7f4db08236b3c1e67989d665a13bf723", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 2857}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "5ddda8da4ea709c9a53cda7b3b796e92", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 2871}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "113f897b91890a6e2bf5f4adfa47e5c6", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 2987}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "51b28126b855e35c2116b0b3800ca729", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 3020}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "b13a7ce83d0e14f8f9752bc285601084", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 3004}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "5881954627970a78c6399b323d064ea2", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 6391}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/platform/x86/thinkpad_acpi.c", "reportHash": "baeb5f2b61e6ba6dda879fb90f52e6f0", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
