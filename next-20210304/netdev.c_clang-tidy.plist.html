<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/net/ethernet/intel/e1000e/netdev.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/* Copyright(c) 1999 - 2018 Intel Corporation. */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/interrupt.h>\n#include <linux/tcp.h>\n#include <linux/ipv6.h>\n#include <linux/slab.h>\n#include <net/checksum.h>\n#include <net/ip6_checksum.h>\n#include <linux/ethtool.h>\n#include <linux/if_vlan.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/pm_qos.h>\n#include <linux/pm_runtime.h>\n#include <linux/aer.h>\n#include <linux/prefetch.h>\n\n#include \"e1000.h\"\n\nchar e1000e_driver_name[] = \"e1000e\";\n\n#define DEFAULT_MSG_ENABLE (NETIF_MSG_DRV|NETIF_MSG_PROBE|NETIF_MSG_LINK)\nstatic int debug = -1;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0=none,...,16=all)\");\n\nstatic const struct e1000_info *e1000_info_tbl[] = {\n\t[board_82571]\t\t= &e1000_82571_info,\n\t[board_82572]\t\t= &e1000_82572_info,\n\t[board_82573]\t\t= &e1000_82573_info,\n\t[board_82574]\t\t= &e1000_82574_info,\n\t[board_82583]\t\t= &e1000_82583_info,\n\t[board_80003es2lan]\t= &e1000_es2_info,\n\t[board_ich8lan]\t\t= &e1000_ich8_info,\n\t[board_ich9lan]\t\t= &e1000_ich9_info,\n\t[board_ich10lan]\t= &e1000_ich10_info,\n\t[board_pchlan]\t\t= &e1000_pch_info,\n\t[board_pch2lan]\t\t= &e1000_pch2_info,\n\t[board_pch_lpt]\t\t= &e1000_pch_lpt_info,\n\t[board_pch_spt]\t\t= &e1000_pch_spt_info,\n\t[board_pch_cnp]\t\t= &e1000_pch_cnp_info,\n};\n\nstruct e1000_reg_info {\n\tu32 ofs;\n\tchar *name;\n};\n\nstatic const struct e1000_reg_info e1000_reg_info_tbl[] = {\n\t/* General Registers */\n\t{E1000_CTRL, \"CTRL\"},\n\t{E1000_STATUS, \"STATUS\"},\n\t{E1000_CTRL_EXT, \"CTRL_EXT\"},\n\n\t/* Interrupt Registers */\n\t{E1000_ICR, \"ICR\"},\n\n\t/* Rx Registers */\n\t{E1000_RCTL, \"RCTL\"},\n\t{E1000_RDLEN(0), \"RDLEN\"},\n\t{E1000_RDH(0), \"RDH\"},\n\t{E1000_RDT(0), \"RDT\"},\n\t{E1000_RDTR, \"RDTR\"},\n\t{E1000_RXDCTL(0), \"RXDCTL\"},\n\t{E1000_ERT, \"ERT\"},\n\t{E1000_RDBAL(0), \"RDBAL\"},\n\t{E1000_RDBAH(0), \"RDBAH\"},\n\t{E1000_RDFH, \"RDFH\"},\n\t{E1000_RDFT, \"RDFT\"},\n\t{E1000_RDFHS, \"RDFHS\"},\n\t{E1000_RDFTS, \"RDFTS\"},\n\t{E1000_RDFPC, \"RDFPC\"},\n\n\t/* Tx Registers */\n\t{E1000_TCTL, \"TCTL\"},\n\t{E1000_TDBAL(0), \"TDBAL\"},\n\t{E1000_TDBAH(0), \"TDBAH\"},\n\t{E1000_TDLEN(0), \"TDLEN\"},\n\t{E1000_TDH(0), \"TDH\"},\n\t{E1000_TDT(0), \"TDT\"},\n\t{E1000_TIDV, \"TIDV\"},\n\t{E1000_TXDCTL(0), \"TXDCTL\"},\n\t{E1000_TADV, \"TADV\"},\n\t{E1000_TARC(0), \"TARC\"},\n\t{E1000_TDFH, \"TDFH\"},\n\t{E1000_TDFT, \"TDFT\"},\n\t{E1000_TDFHS, \"TDFHS\"},\n\t{E1000_TDFTS, \"TDFTS\"},\n\t{E1000_TDFPC, \"TDFPC\"},\n\n\t/* List Terminator */\n\t{0, NULL}\n};\n\n/**\n * __ew32_prepare - prepare to write to MAC CSR register on certain parts\n * @hw: pointer to the HW structure\n *\n * When updating the MAC CSR registers, the Manageability Engine (ME) could\n * be accessing the registers at the same time.  Normally, this is handled in\n * h/w by an arbiter but on some parts there is a bug that acknowledges Host\n * accesses later than it should which could result in the register to have\n * an incorrect value.  Workaround this by checking the FWSM register which\n * has bit 24 set while ME is accessing MAC CSR registers, wait if it is set\n * and try again a number of times.\n **/\nstatic void __ew32_prepare(struct e1000_hw *hw)\n{\n\ts32 i = E1000_ICH_FWSM_PCIM2PCI_COUNT;\n\n\twhile ((er32(FWSM) & E1000_ICH_FWSM_PCIM2PCI) && --i)\n\t\tudelay(50);\n}\n\nvoid __ew32(struct e1000_hw *hw, unsigned long reg, u32 val)\n{\n\tif (hw->adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\n\t\t__ew32_prepare(hw);\n\n\twritel(val, hw->hw_addr + reg);\n}\n\n/**\n * e1000_regdump - register printout routine\n * @hw: pointer to the HW structure\n * @reginfo: pointer to the register info table\n **/\nstatic void e1000_regdump(struct e1000_hw *hw, struct e1000_reg_info *reginfo)\n{\n\tint n = 0;\n\tchar rname[16];\n\tu32 regs[8];\n\n\tswitch (reginfo->ofs) {\n\tcase E1000_RXDCTL(0):\n\t\tfor (n = 0; n < 2; n++)\n\t\t\tregs[n] = __er32(hw, E1000_RXDCTL(n));\n\t\tbreak;\n\tcase E1000_TXDCTL(0):\n\t\tfor (n = 0; n < 2; n++)\n\t\t\tregs[n] = __er32(hw, E1000_TXDCTL(n));\n\t\tbreak;\n\tcase E1000_TARC(0):\n\t\tfor (n = 0; n < 2; n++)\n\t\t\tregs[n] = __er32(hw, E1000_TARC(n));\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"%-15s %08x\\n\",\n\t\t\treginfo->name, __er32(hw, reginfo->ofs));\n\t\treturn;\n\t}\n\n\tsnprintf(rname, 16, \"%s%s\", reginfo->name, \"[0-1]\");\n\tpr_info(\"%-15s %08x %08x\\n\", rname, regs[0], regs[1]);\n}\n\nstatic void e1000e_dump_ps_pages(struct e1000_adapter *adapter,\n\t\t\t\t struct e1000_buffer *bi)\n{\n\tint i;\n\tstruct e1000_ps_page *ps_page;\n\n\tfor (i = 0; i < adapter->rx_ps_pages; i++) {\n\t\tps_page = &bi->ps_pages[i];\n\n\t\tif (ps_page->page) {\n\t\t\tpr_info(\"packet dump for ps_page %d:\\n\", i);\n\t\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_ADDRESS,\n\t\t\t\t       16, 1, page_address(ps_page->page),\n\t\t\t\t       PAGE_SIZE, true);\n\t\t}\n\t}\n}\n\n/**\n * e1000e_dump - Print registers, Tx-ring and Rx-ring\n * @adapter: board private structure\n **/\nstatic void e1000e_dump(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_reg_info *reginfo;\n\tstruct e1000_ring *tx_ring = adapter->tx_ring;\n\tstruct e1000_tx_desc *tx_desc;\n\tstruct my_u0 {\n\t\t__le64 a;\n\t\t__le64 b;\n\t} *u0;\n\tstruct e1000_buffer *buffer_info;\n\tstruct e1000_ring *rx_ring = adapter->rx_ring;\n\tunion e1000_rx_desc_packet_split *rx_desc_ps;\n\tunion e1000_rx_desc_extended *rx_desc;\n\tstruct my_u1 {\n\t\t__le64 a;\n\t\t__le64 b;\n\t\t__le64 c;\n\t\t__le64 d;\n\t} *u1;\n\tu32 staterr;\n\tint i = 0;\n\n\tif (!netif_msg_hw(adapter))\n\t\treturn;\n\n\t/* Print netdevice Info */\n\tif (netdev) {\n\t\tdev_info(&adapter->pdev->dev, \"Net device Info\\n\");\n\t\tpr_info(\"Device Name     state            trans_start\\n\");\n\t\tpr_info(\"%-15s %016lX %016lX\\n\", netdev->name,\n\t\t\tnetdev->state, dev_trans_start(netdev));\n\t}\n\n\t/* Print Registers */\n\tdev_info(&adapter->pdev->dev, \"Register Dump\\n\");\n\tpr_info(\" Register Name   Value\\n\");\n\tfor (reginfo = (struct e1000_reg_info *)e1000_reg_info_tbl;\n\t     reginfo->name; reginfo++) {\n\t\te1000_regdump(hw, reginfo);\n\t}\n\n\t/* Print Tx Ring Summary */\n\tif (!netdev || !netif_running(netdev))\n\t\treturn;\n\n\tdev_info(&adapter->pdev->dev, \"Tx Ring Summary\\n\");\n\tpr_info(\"Queue [NTU] [NTC] [bi(ntc)->dma  ] leng ntw timestamp\\n\");\n\tbuffer_info = &tx_ring->buffer_info[tx_ring->next_to_clean];\n\tpr_info(\" %5d %5X %5X %016llX %04X %3X %016llX\\n\",\n\t\t0, tx_ring->next_to_use, tx_ring->next_to_clean,\n\t\t(unsigned long long)buffer_info->dma,\n\t\tbuffer_info->length,\n\t\tbuffer_info->next_to_watch,\n\t\t(unsigned long long)buffer_info->time_stamp);\n\n\t/* Print Tx Ring */\n\tif (!netif_msg_tx_done(adapter))\n\t\tgoto rx_ring_summary;\n\n\tdev_info(&adapter->pdev->dev, \"Tx Ring Dump\\n\");\n\n\t/* Transmit Descriptor Formats - DEXT[29] is 0 (Legacy) or 1 (Extended)\n\t *\n\t * Legacy Transmit Descriptor\n\t *   +--------------------------------------------------------------+\n\t * 0 |         Buffer Address [63:0] (Reserved on Write Back)       |\n\t *   +--------------------------------------------------------------+\n\t * 8 | Special  |    CSS     | Status |  CMD    |  CSO   |  Length  |\n\t *   +--------------------------------------------------------------+\n\t *   63       48 47        36 35    32 31     24 23    16 15        0\n\t *\n\t * Extended Context Descriptor (DTYP=0x0) for TSO or checksum offload\n\t *   63      48 47    40 39       32 31             16 15    8 7      0\n\t *   +----------------------------------------------------------------+\n\t * 0 |  TUCSE  | TUCS0  |   TUCSS   |     IPCSE       | IPCS0 | IPCSS |\n\t *   +----------------------------------------------------------------+\n\t * 8 |   MSS   | HDRLEN | RSV | STA | TUCMD | DTYP |      PAYLEN      |\n\t *   +----------------------------------------------------------------+\n\t *   63      48 47    40 39 36 35 32 31   24 23  20 19                0\n\t *\n\t * Extended Data Descriptor (DTYP=0x1)\n\t *   +----------------------------------------------------------------+\n\t * 0 |                     Buffer Address [63:0]                      |\n\t *   +----------------------------------------------------------------+\n\t * 8 | VLAN tag |  POPTS  | Rsvd | Status | Command | DTYP |  DTALEN  |\n\t *   +----------------------------------------------------------------+\n\t *   63       48 47     40 39  36 35    32 31     24 23  20 19        0\n\t */\n\tpr_info(\"Tl[desc]     [address 63:0  ] [SpeCssSCmCsLen] [bi->dma       ] leng  ntw timestamp        bi->skb <-- Legacy format\\n\");\n\tpr_info(\"Tc[desc]     [Ce CoCsIpceCoS] [MssHlRSCm0Plen] [bi->dma       ] leng  ntw timestamp        bi->skb <-- Ext Context format\\n\");\n\tpr_info(\"Td[desc]     [address 63:0  ] [VlaPoRSCm1Dlen] [bi->dma       ] leng  ntw timestamp        bi->skb <-- Ext Data format\\n\");\n\tfor (i = 0; tx_ring->desc && (i < tx_ring->count); i++) {\n\t\tconst char *next_desc;\n\t\ttx_desc = E1000_TX_DESC(*tx_ring, i);\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\tu0 = (struct my_u0 *)tx_desc;\n\t\tif (i == tx_ring->next_to_use && i == tx_ring->next_to_clean)\n\t\t\tnext_desc = \" NTC/U\";\n\t\telse if (i == tx_ring->next_to_use)\n\t\t\tnext_desc = \" NTU\";\n\t\telse if (i == tx_ring->next_to_clean)\n\t\t\tnext_desc = \" NTC\";\n\t\telse\n\t\t\tnext_desc = \"\";\n\t\tpr_info(\"T%c[0x%03X]    %016llX %016llX %016llX %04X  %3X %016llX %p%s\\n\",\n\t\t\t(!(le64_to_cpu(u0->b) & BIT(29)) ? 'l' :\n\t\t\t ((le64_to_cpu(u0->b) & BIT(20)) ? 'd' : 'c')),\n\t\t\ti,\n\t\t\t(unsigned long long)le64_to_cpu(u0->a),\n\t\t\t(unsigned long long)le64_to_cpu(u0->b),\n\t\t\t(unsigned long long)buffer_info->dma,\n\t\t\tbuffer_info->length, buffer_info->next_to_watch,\n\t\t\t(unsigned long long)buffer_info->time_stamp,\n\t\t\tbuffer_info->skb, next_desc);\n\n\t\tif (netif_msg_pktdata(adapter) && buffer_info->skb)\n\t\t\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_ADDRESS,\n\t\t\t\t       16, 1, buffer_info->skb->data,\n\t\t\t\t       buffer_info->skb->len, true);\n\t}\n\n\t/* Print Rx Ring Summary */\nrx_ring_summary:\n\tdev_info(&adapter->pdev->dev, \"Rx Ring Summary\\n\");\n\tpr_info(\"Queue [NTU] [NTC]\\n\");\n\tpr_info(\" %5d %5X %5X\\n\",\n\t\t0, rx_ring->next_to_use, rx_ring->next_to_clean);\n\n\t/* Print Rx Ring */\n\tif (!netif_msg_rx_status(adapter))\n\t\treturn;\n\n\tdev_info(&adapter->pdev->dev, \"Rx Ring Dump\\n\");\n\tswitch (adapter->rx_ps_pages) {\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\t\t/* [Extended] Packet Split Receive Descriptor Format\n\t\t *\n\t\t *    +-----------------------------------------------------+\n\t\t *  0 |                Buffer Address 0 [63:0]              |\n\t\t *    +-----------------------------------------------------+\n\t\t *  8 |                Buffer Address 1 [63:0]              |\n\t\t *    +-----------------------------------------------------+\n\t\t * 16 |                Buffer Address 2 [63:0]              |\n\t\t *    +-----------------------------------------------------+\n\t\t * 24 |                Buffer Address 3 [63:0]              |\n\t\t *    +-----------------------------------------------------+\n\t\t */\n\t\tpr_info(\"R  [desc]      [buffer 0 63:0 ] [buffer 1 63:0 ] [buffer 2 63:0 ] [buffer 3 63:0 ] [bi->dma       ] [bi->skb] <-- Ext Pkt Split format\\n\");\n\t\t/* [Extended] Receive Descriptor (Write-Back) Format\n\t\t *\n\t\t *   63       48 47    32 31     13 12    8 7    4 3        0\n\t\t *   +------------------------------------------------------+\n\t\t * 0 | Packet   | IP     |  Rsvd   | MRQ   | Rsvd | MRQ RSS |\n\t\t *   | Checksum | Ident  |         | Queue |      |  Type   |\n\t\t *   +------------------------------------------------------+\n\t\t * 8 | VLAN Tag | Length | Extended Error | Extended Status |\n\t\t *   +------------------------------------------------------+\n\t\t *   63       48 47    32 31            20 19               0\n\t\t */\n\t\tpr_info(\"RWB[desc]      [ck ipid mrqhsh] [vl   l0 ee  es] [ l3  l2  l1 hs] [reserved      ] ---------------- [bi->skb] <-- Ext Rx Write-Back format\\n\");\n\t\tfor (i = 0; i < rx_ring->count; i++) {\n\t\t\tconst char *next_desc;\n\t\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t\t\trx_desc_ps = E1000_RX_DESC_PS(*rx_ring, i);\n\t\t\tu1 = (struct my_u1 *)rx_desc_ps;\n\t\t\tstaterr =\n\t\t\t    le32_to_cpu(rx_desc_ps->wb.middle.status_error);\n\n\t\t\tif (i == rx_ring->next_to_use)\n\t\t\t\tnext_desc = \" NTU\";\n\t\t\telse if (i == rx_ring->next_to_clean)\n\t\t\t\tnext_desc = \" NTC\";\n\t\t\telse\n\t\t\t\tnext_desc = \"\";\n\n\t\t\tif (staterr & E1000_RXD_STAT_DD) {\n\t\t\t\t/* Descriptor Done */\n\t\t\t\tpr_info(\"%s[0x%03X]     %016llX %016llX %016llX %016llX ---------------- %p%s\\n\",\n\t\t\t\t\t\"RWB\", i,\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->a),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->b),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->c),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->d),\n\t\t\t\t\tbuffer_info->skb, next_desc);\n\t\t\t} else {\n\t\t\t\tpr_info(\"%s[0x%03X]     %016llX %016llX %016llX %016llX %016llX %p%s\\n\",\n\t\t\t\t\t\"R  \", i,\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->a),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->b),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->c),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->d),\n\t\t\t\t\t(unsigned long long)buffer_info->dma,\n\t\t\t\t\tbuffer_info->skb, next_desc);\n\n\t\t\t\tif (netif_msg_pktdata(adapter))\n\t\t\t\t\te1000e_dump_ps_pages(adapter,\n\t\t\t\t\t\t\t     buffer_info);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\tcase 0:\n\t\t/* Extended Receive Descriptor (Read) Format\n\t\t *\n\t\t *   +-----------------------------------------------------+\n\t\t * 0 |                Buffer Address [63:0]                |\n\t\t *   +-----------------------------------------------------+\n\t\t * 8 |                      Reserved                       |\n\t\t *   +-----------------------------------------------------+\n\t\t */\n\t\tpr_info(\"R  [desc]      [buf addr 63:0 ] [reserved 63:0 ] [bi->dma       ] [bi->skb] <-- Ext (Read) format\\n\");\n\t\t/* Extended Receive Descriptor (Write-Back) Format\n\t\t *\n\t\t *   63       48 47    32 31    24 23            4 3        0\n\t\t *   +------------------------------------------------------+\n\t\t *   |     RSS Hash      |        |               |         |\n\t\t * 0 +-------------------+  Rsvd  |   Reserved    | MRQ RSS |\n\t\t *   | Packet   | IP     |        |               |  Type   |\n\t\t *   | Checksum | Ident  |        |               |         |\n\t\t *   +------------------------------------------------------+\n\t\t * 8 | VLAN Tag | Length | Extended Error | Extended Status |\n\t\t *   +------------------------------------------------------+\n\t\t *   63       48 47    32 31            20 19               0\n\t\t */\n\t\tpr_info(\"RWB[desc]      [cs ipid    mrq] [vt   ln xe  xs] [bi->skb] <-- Ext (Write-Back) format\\n\");\n\n\t\tfor (i = 0; i < rx_ring->count; i++) {\n\t\t\tconst char *next_desc;\n\n\t\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t\t\trx_desc = E1000_RX_DESC_EXT(*rx_ring, i);\n\t\t\tu1 = (struct my_u1 *)rx_desc;\n\t\t\tstaterr = le32_to_cpu(rx_desc->wb.upper.status_error);\n\n\t\t\tif (i == rx_ring->next_to_use)\n\t\t\t\tnext_desc = \" NTU\";\n\t\t\telse if (i == rx_ring->next_to_clean)\n\t\t\t\tnext_desc = \" NTC\";\n\t\t\telse\n\t\t\t\tnext_desc = \"\";\n\n\t\t\tif (staterr & E1000_RXD_STAT_DD) {\n\t\t\t\t/* Descriptor Done */\n\t\t\t\tpr_info(\"%s[0x%03X]     %016llX %016llX ---------------- %p%s\\n\",\n\t\t\t\t\t\"RWB\", i,\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->a),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->b),\n\t\t\t\t\tbuffer_info->skb, next_desc);\n\t\t\t} else {\n\t\t\t\tpr_info(\"%s[0x%03X]     %016llX %016llX %016llX %p%s\\n\",\n\t\t\t\t\t\"R  \", i,\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->a),\n\t\t\t\t\t(unsigned long long)le64_to_cpu(u1->b),\n\t\t\t\t\t(unsigned long long)buffer_info->dma,\n\t\t\t\t\tbuffer_info->skb, next_desc);\n\n\t\t\t\tif (netif_msg_pktdata(adapter) &&\n\t\t\t\t    buffer_info->skb)\n\t\t\t\t\tprint_hex_dump(KERN_INFO, \"\",\n\t\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t\t       1,\n\t\t\t\t\t\t       buffer_info->skb->data,\n\t\t\t\t\t\t       adapter->rx_buffer_len,\n\t\t\t\t\t\t       true);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * e1000_desc_unused - calculate if we have unused descriptors\n * @ring: pointer to ring struct to perform calculation on\n **/\nstatic int e1000_desc_unused(struct e1000_ring *ring)\n{\n\tif (ring->next_to_clean > ring->next_to_use)\n\t\treturn ring->next_to_clean - ring->next_to_use - 1;\n\n\treturn ring->count + ring->next_to_clean - ring->next_to_use - 1;\n}\n\n/**\n * e1000e_systim_to_hwtstamp - convert system time value to hw time stamp\n * @adapter: board private structure\n * @hwtstamps: time stamp structure to update\n * @systim: unsigned 64bit system time value.\n *\n * Convert the system time value stored in the RX/TXSTMP registers into a\n * hwtstamp which can be used by the upper level time stamping functions.\n *\n * The 'systim_lock' spinlock is used to protect the consistency of the\n * system time value. This is needed because reading the 64 bit time\n * value involves reading two 32 bit registers. The first read latches the\n * value.\n **/\nstatic void e1000e_systim_to_hwtstamp(struct e1000_adapter *adapter,\n\t\t\t\t      struct skb_shared_hwtstamps *hwtstamps,\n\t\t\t\t      u64 systim)\n{\n\tu64 ns;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adapter->systim_lock, flags);\n\tns = timecounter_cyc2time(&adapter->tc, systim);\n\tspin_unlock_irqrestore(&adapter->systim_lock, flags);\n\n\tmemset(hwtstamps, 0, sizeof(*hwtstamps));\n\thwtstamps->hwtstamp = ns_to_ktime(ns);\n}\n\n/**\n * e1000e_rx_hwtstamp - utility function which checks for Rx time stamp\n * @adapter: board private structure\n * @status: descriptor extended error and status field\n * @skb: particular skb to include time stamp\n *\n * If the time stamp is valid, convert it into the timecounter ns value\n * and store that result into the shhwtstamps structure which is passed\n * up the network stack.\n **/\nstatic void e1000e_rx_hwtstamp(struct e1000_adapter *adapter, u32 status,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu64 rxstmp;\n\n\tif (!(adapter->flags & FLAG_HAS_HW_TIMESTAMP) ||\n\t    !(status & E1000_RXDEXT_STATERR_TST) ||\n\t    !(er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_VALID))\n\t\treturn;\n\n\t/* The Rx time stamp registers contain the time stamp.  No other\n\t * received packet will be time stamped until the Rx time stamp\n\t * registers are read.  Because only one packet can be time stamped\n\t * at a time, the register values must belong to this packet and\n\t * therefore none of the other additional attributes need to be\n\t * compared.\n\t */\n\trxstmp = (u64)er32(RXSTMPL);\n\trxstmp |= (u64)er32(RXSTMPH) << 32;\n\te1000e_systim_to_hwtstamp(adapter, skb_hwtstamps(skb), rxstmp);\n\n\tadapter->flags2 &= ~FLAG2_CHECK_RX_HWTSTAMP;\n}\n\n/**\n * e1000_receive_skb - helper function to handle Rx indications\n * @adapter: board private structure\n * @netdev: pointer to netdev struct\n * @staterr: descriptor extended error and status field as written by hardware\n * @vlan: descriptor vlan field as written by hardware (no le/be conversion)\n * @skb: pointer to sk_buff to be indicated to stack\n **/\nstatic void e1000_receive_skb(struct e1000_adapter *adapter,\n\t\t\t      struct net_device *netdev, struct sk_buff *skb,\n\t\t\t      u32 staterr, __le16 vlan)\n{\n\tu16 tag = le16_to_cpu(vlan);\n\n\te1000e_rx_hwtstamp(adapter, staterr, skb);\n\n\tskb->protocol = eth_type_trans(skb, netdev);\n\n\tif (staterr & E1000_RXD_STAT_VP)\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), tag);\n\n\tnapi_gro_receive(&adapter->napi, skb);\n}\n\n/**\n * e1000_rx_checksum - Receive Checksum Offload\n * @adapter: board private structure\n * @status_err: receive descriptor status and error fields\n * @skb: socket buffer with received data\n **/\nstatic void e1000_rx_checksum(struct e1000_adapter *adapter, u32 status_err,\n\t\t\t      struct sk_buff *skb)\n{\n\tu16 status = (u16)status_err;\n\tu8 errors = (u8)(status_err >> 24);\n\n\tskb_checksum_none_assert(skb);\n\n\t/* Rx checksum disabled */\n\tif (!(adapter->netdev->features & NETIF_F_RXCSUM))\n\t\treturn;\n\n\t/* Ignore Checksum bit is set */\n\tif (status & E1000_RXD_STAT_IXSM)\n\t\treturn;\n\n\t/* TCP/UDP checksum error bit or IP checksum error bit is set */\n\tif (errors & (E1000_RXD_ERR_TCPE | E1000_RXD_ERR_IPE)) {\n\t\t/* let the stack verify checksum errors */\n\t\tadapter->hw_csum_err++;\n\t\treturn;\n\t}\n\n\t/* TCP/UDP Checksum has not been calculated */\n\tif (!(status & (E1000_RXD_STAT_TCPCS | E1000_RXD_STAT_UDPCS)))\n\t\treturn;\n\n\t/* It must be a TCP or UDP packet with a valid checksum */\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tadapter->hw_csum_good++;\n}\n\nstatic void e1000e_update_rdt_wa(struct e1000_ring *rx_ring, unsigned int i)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t__ew32_prepare(hw);\n\twritel(i, rx_ring->tail);\n\n\tif (unlikely(i != readl(rx_ring->tail))) {\n\t\tu32 rctl = er32(RCTL);\n\n\t\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\t\te_err(\"ME firmware caused invalid RDT - resetting\\n\");\n\t\tschedule_work(&adapter->reset_task);\n\t}\n}\n\nstatic void e1000e_update_tdt_wa(struct e1000_ring *tx_ring, unsigned int i)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t__ew32_prepare(hw);\n\twritel(i, tx_ring->tail);\n\n\tif (unlikely(i != readl(tx_ring->tail))) {\n\t\tu32 tctl = er32(TCTL);\n\n\t\tew32(TCTL, tctl & ~E1000_TCTL_EN);\n\t\te_err(\"ME firmware caused invalid TDT - resetting\\n\");\n\t\tschedule_work(&adapter->reset_task);\n\t}\n}\n\n/**\n * e1000_alloc_rx_buffers - Replace used receive buffers\n * @rx_ring: Rx descriptor ring\n * @cleaned_count: number to reallocate\n * @gfp: flags for allocation\n **/\nstatic void e1000_alloc_rx_buffers(struct e1000_ring *rx_ring,\n\t\t\t\t   int cleaned_count, gfp_t gfp)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tunion e1000_rx_desc_extended *rx_desc;\n\tstruct e1000_buffer *buffer_info;\n\tstruct sk_buff *skb;\n\tunsigned int i;\n\tunsigned int bufsz = adapter->rx_buffer_len;\n\n\ti = rx_ring->next_to_use;\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (cleaned_count--) {\n\t\tskb = buffer_info->skb;\n\t\tif (skb) {\n\t\t\tskb_trim(skb, 0);\n\t\t\tgoto map_skb;\n\t\t}\n\n\t\tskb = __netdev_alloc_skb_ip_align(netdev, bufsz, gfp);\n\t\tif (!skb) {\n\t\t\t/* Better luck next round */\n\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer_info->skb = skb;\nmap_skb:\n\t\tbuffer_info->dma = dma_map_single(&pdev->dev, skb->data,\n\t\t\t\t\t\t  adapter->rx_buffer_len,\n\t\t\t\t\t\t  DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&pdev->dev, buffer_info->dma)) {\n\t\t\tdev_err(&pdev->dev, \"Rx DMA map failed\\n\");\n\t\t\tadapter->rx_dma_failed++;\n\t\t\tbreak;\n\t\t}\n\n\t\trx_desc = E1000_RX_DESC_EXT(*rx_ring, i);\n\t\trx_desc->read.buffer_addr = cpu_to_le64(buffer_info->dma);\n\n\t\tif (unlikely(!(i & (E1000_RX_BUFFER_WRITE - 1)))) {\n\t\t\t/* Force memory writes to complete before letting h/w\n\t\t\t * know there are new descriptors to fetch.  (Only\n\t\t\t * applicable for weak-ordered memory model archs,\n\t\t\t * such as IA-64).\n\t\t\t */\n\t\t\twmb();\n\t\t\tif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\n\t\t\t\te1000e_update_rdt_wa(rx_ring, i);\n\t\t\telse\n\t\t\t\twritel(i, rx_ring->tail);\n\t\t}\n\t\ti++;\n\t\tif (i == rx_ring->count)\n\t\t\ti = 0;\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t}\n\n\trx_ring->next_to_use = i;\n}\n\n/**\n * e1000_alloc_rx_buffers_ps - Replace used receive buffers; packet split\n * @rx_ring: Rx descriptor ring\n * @cleaned_count: number to reallocate\n * @gfp: flags for allocation\n **/\nstatic void e1000_alloc_rx_buffers_ps(struct e1000_ring *rx_ring,\n\t\t\t\t      int cleaned_count, gfp_t gfp)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tunion e1000_rx_desc_packet_split *rx_desc;\n\tstruct e1000_buffer *buffer_info;\n\tstruct e1000_ps_page *ps_page;\n\tstruct sk_buff *skb;\n\tunsigned int i, j;\n\n\ti = rx_ring->next_to_use;\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (cleaned_count--) {\n\t\trx_desc = E1000_RX_DESC_PS(*rx_ring, i);\n\n\t\tfor (j = 0; j < PS_PAGE_BUFFERS; j++) {\n\t\t\tps_page = &buffer_info->ps_pages[j];\n\t\t\tif (j >= adapter->rx_ps_pages) {\n\t\t\t\t/* all unused desc entries get hw null ptr */\n\t\t\t\trx_desc->read.buffer_addr[j + 1] =\n\t\t\t\t    ~cpu_to_le64(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!ps_page->page) {\n\t\t\t\tps_page->page = alloc_page(gfp);\n\t\t\t\tif (!ps_page->page) {\n\t\t\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\t\t\tgoto no_buffers;\n\t\t\t\t}\n\t\t\t\tps_page->dma = dma_map_page(&pdev->dev,\n\t\t\t\t\t\t\t    ps_page->page,\n\t\t\t\t\t\t\t    0, PAGE_SIZE,\n\t\t\t\t\t\t\t    DMA_FROM_DEVICE);\n\t\t\t\tif (dma_mapping_error(&pdev->dev,\n\t\t\t\t\t\t      ps_page->dma)) {\n\t\t\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\t\"Rx DMA page map failed\\n\");\n\t\t\t\t\tadapter->rx_dma_failed++;\n\t\t\t\t\tgoto no_buffers;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Refresh the desc even if buffer_addrs\n\t\t\t * didn't change because each write-back\n\t\t\t * erases this info.\n\t\t\t */\n\t\t\trx_desc->read.buffer_addr[j + 1] =\n\t\t\t    cpu_to_le64(ps_page->dma);\n\t\t}\n\n\t\tskb = __netdev_alloc_skb_ip_align(netdev, adapter->rx_ps_bsize0,\n\t\t\t\t\t\t  gfp);\n\n\t\tif (!skb) {\n\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer_info->skb = skb;\n\t\tbuffer_info->dma = dma_map_single(&pdev->dev, skb->data,\n\t\t\t\t\t\t  adapter->rx_ps_bsize0,\n\t\t\t\t\t\t  DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&pdev->dev, buffer_info->dma)) {\n\t\t\tdev_err(&pdev->dev, \"Rx DMA map failed\\n\");\n\t\t\tadapter->rx_dma_failed++;\n\t\t\t/* cleanup skb */\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tbuffer_info->skb = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\trx_desc->read.buffer_addr[0] = cpu_to_le64(buffer_info->dma);\n\n\t\tif (unlikely(!(i & (E1000_RX_BUFFER_WRITE - 1)))) {\n\t\t\t/* Force memory writes to complete before letting h/w\n\t\t\t * know there are new descriptors to fetch.  (Only\n\t\t\t * applicable for weak-ordered memory model archs,\n\t\t\t * such as IA-64).\n\t\t\t */\n\t\t\twmb();\n\t\t\tif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\n\t\t\t\te1000e_update_rdt_wa(rx_ring, i << 1);\n\t\t\telse\n\t\t\t\twritel(i << 1, rx_ring->tail);\n\t\t}\n\n\t\ti++;\n\t\tif (i == rx_ring->count)\n\t\t\ti = 0;\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t}\n\nno_buffers:\n\trx_ring->next_to_use = i;\n}\n\n/**\n * e1000_alloc_jumbo_rx_buffers - Replace used jumbo receive buffers\n * @rx_ring: Rx descriptor ring\n * @cleaned_count: number of buffers to allocate this pass\n * @gfp: flags for allocation\n **/\n\nstatic void e1000_alloc_jumbo_rx_buffers(struct e1000_ring *rx_ring,\n\t\t\t\t\t int cleaned_count, gfp_t gfp)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tunion e1000_rx_desc_extended *rx_desc;\n\tstruct e1000_buffer *buffer_info;\n\tstruct sk_buff *skb;\n\tunsigned int i;\n\tunsigned int bufsz = 256 - 16;\t/* for skb_reserve */\n\n\ti = rx_ring->next_to_use;\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (cleaned_count--) {\n\t\tskb = buffer_info->skb;\n\t\tif (skb) {\n\t\t\tskb_trim(skb, 0);\n\t\t\tgoto check_page;\n\t\t}\n\n\t\tskb = __netdev_alloc_skb_ip_align(netdev, bufsz, gfp);\n\t\tif (unlikely(!skb)) {\n\t\t\t/* Better luck next round */\n\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer_info->skb = skb;\ncheck_page:\n\t\t/* allocate a new page if necessary */\n\t\tif (!buffer_info->page) {\n\t\t\tbuffer_info->page = alloc_page(gfp);\n\t\t\tif (unlikely(!buffer_info->page)) {\n\t\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!buffer_info->dma) {\n\t\t\tbuffer_info->dma = dma_map_page(&pdev->dev,\n\t\t\t\t\t\t\tbuffer_info->page, 0,\n\t\t\t\t\t\t\tPAGE_SIZE,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(&pdev->dev, buffer_info->dma)) {\n\t\t\t\tadapter->alloc_rx_buff_failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trx_desc = E1000_RX_DESC_EXT(*rx_ring, i);\n\t\trx_desc->read.buffer_addr = cpu_to_le64(buffer_info->dma);\n\n\t\tif (unlikely(++i == rx_ring->count))\n\t\t\ti = 0;\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t}\n\n\tif (likely(rx_ring->next_to_use != i)) {\n\t\trx_ring->next_to_use = i;\n\t\tif (unlikely(i-- == 0))\n\t\t\ti = (rx_ring->count - 1);\n\n\t\t/* Force memory writes to complete before letting h/w\n\t\t * know there are new descriptors to fetch.  (Only\n\t\t * applicable for weak-ordered memory model archs,\n\t\t * such as IA-64).\n\t\t */\n\t\twmb();\n\t\tif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\n\t\t\te1000e_update_rdt_wa(rx_ring, i);\n\t\telse\n\t\t\twritel(i, rx_ring->tail);\n\t}\n}\n\nstatic inline void e1000_rx_hash(struct net_device *netdev, __le32 rss,\n\t\t\t\t struct sk_buff *skb)\n{\n\tif (netdev->features & NETIF_F_RXHASH)\n\t\tskb_set_hash(skb, le32_to_cpu(rss), PKT_HASH_TYPE_L3);\n}\n\n/**\n * e1000_clean_rx_irq - Send received data up the network stack\n * @rx_ring: Rx descriptor ring\n * @work_done: output parameter for indicating completed work\n * @work_to_do: how many packets we can clean\n *\n * the return value indicates whether actual cleaning was done, there\n * is no guarantee that everything was cleaned\n **/\nstatic bool e1000_clean_rx_irq(struct e1000_ring *rx_ring, int *work_done,\n\t\t\t       int work_to_do)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunion e1000_rx_desc_extended *rx_desc, *next_rxd;\n\tstruct e1000_buffer *buffer_info, *next_buffer;\n\tu32 length, staterr;\n\tunsigned int i;\n\tint cleaned_count = 0;\n\tbool cleaned = false;\n\tunsigned int total_rx_bytes = 0, total_rx_packets = 0;\n\n\ti = rx_ring->next_to_clean;\n\trx_desc = E1000_RX_DESC_EXT(*rx_ring, i);\n\tstaterr = le32_to_cpu(rx_desc->wb.upper.status_error);\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (staterr & E1000_RXD_STAT_DD) {\n\t\tstruct sk_buff *skb;\n\n\t\tif (*work_done >= work_to_do)\n\t\t\tbreak;\n\t\t(*work_done)++;\n\t\tdma_rmb();\t/* read descriptor and rx_buffer_info after status DD */\n\n\t\tskb = buffer_info->skb;\n\t\tbuffer_info->skb = NULL;\n\n\t\tprefetch(skb->data - NET_IP_ALIGN);\n\n\t\ti++;\n\t\tif (i == rx_ring->count)\n\t\t\ti = 0;\n\t\tnext_rxd = E1000_RX_DESC_EXT(*rx_ring, i);\n\t\tprefetch(next_rxd);\n\n\t\tnext_buffer = &rx_ring->buffer_info[i];\n\n\t\tcleaned = true;\n\t\tcleaned_count++;\n\t\tdma_unmap_single(&pdev->dev, buffer_info->dma,\n\t\t\t\t adapter->rx_buffer_len, DMA_FROM_DEVICE);\n\t\tbuffer_info->dma = 0;\n\n\t\tlength = le16_to_cpu(rx_desc->wb.upper.length);\n\n\t\t/* !EOP means multiple descriptors were used to store a single\n\t\t * packet, if that's the case we need to toss it.  In fact, we\n\t\t * need to toss every packet with the EOP bit clear and the\n\t\t * next frame that _does_ have the EOP bit set, as it is by\n\t\t * definition only a frame fragment\n\t\t */\n\t\tif (unlikely(!(staterr & E1000_RXD_STAT_EOP)))\n\t\t\tadapter->flags2 |= FLAG2_IS_DISCARDING;\n\n\t\tif (adapter->flags2 & FLAG2_IS_DISCARDING) {\n\t\t\t/* All receives must fit into a single buffer */\n\t\t\te_dbg(\"Receive packet consumed multiple buffers\\n\");\n\t\t\t/* recycle */\n\t\t\tbuffer_info->skb = skb;\n\t\t\tif (staterr & E1000_RXD_STAT_EOP)\n\t\t\t\tadapter->flags2 &= ~FLAG2_IS_DISCARDING;\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\tif (unlikely((staterr & E1000_RXDEXT_ERR_FRAME_ERR_MASK) &&\n\t\t\t     !(netdev->features & NETIF_F_RXALL))) {\n\t\t\t/* recycle */\n\t\t\tbuffer_info->skb = skb;\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\t/* adjust length to remove Ethernet CRC */\n\t\tif (!(adapter->flags2 & FLAG2_CRC_STRIPPING)) {\n\t\t\t/* If configured to store CRC, don't subtract FCS,\n\t\t\t * but keep the FCS bytes out of the total_rx_bytes\n\t\t\t * counter\n\t\t\t */\n\t\t\tif (netdev->features & NETIF_F_RXFCS)\n\t\t\t\ttotal_rx_bytes -= 4;\n\t\t\telse\n\t\t\t\tlength -= 4;\n\t\t}\n\n\t\ttotal_rx_bytes += length;\n\t\ttotal_rx_packets++;\n\n\t\t/* code added for copybreak, this should improve\n\t\t * performance for small packets with large amounts\n\t\t * of reassembly being done in the stack\n\t\t */\n\t\tif (length < copybreak) {\n\t\t\tstruct sk_buff *new_skb =\n\t\t\t\tnapi_alloc_skb(&adapter->napi, length);\n\t\t\tif (new_skb) {\n\t\t\t\tskb_copy_to_linear_data_offset(new_skb,\n\t\t\t\t\t\t\t       -NET_IP_ALIGN,\n\t\t\t\t\t\t\t       (skb->data -\n\t\t\t\t\t\t\t\tNET_IP_ALIGN),\n\t\t\t\t\t\t\t       (length +\n\t\t\t\t\t\t\t\tNET_IP_ALIGN));\n\t\t\t\t/* save the skb in buffer_info as good */\n\t\t\t\tbuffer_info->skb = skb;\n\t\t\t\tskb = new_skb;\n\t\t\t}\n\t\t\t/* else just continue with the old one */\n\t\t}\n\t\t/* end copybreak code */\n\t\tskb_put(skb, length);\n\n\t\t/* Receive Checksum Offload */\n\t\te1000_rx_checksum(adapter, staterr, skb);\n\n\t\te1000_rx_hash(netdev, rx_desc->wb.lower.hi_dword.rss, skb);\n\n\t\te1000_receive_skb(adapter, netdev, skb, staterr,\n\t\t\t\t  rx_desc->wb.upper.vlan);\n\nnext_desc:\n\t\trx_desc->wb.upper.status_error &= cpu_to_le32(~0xFF);\n\n\t\t/* return some buffers to hardware, one at a time is too slow */\n\t\tif (cleaned_count >= E1000_RX_BUFFER_WRITE) {\n\t\t\tadapter->alloc_rx_buf(rx_ring, cleaned_count,\n\t\t\t\t\t      GFP_ATOMIC);\n\t\t\tcleaned_count = 0;\n\t\t}\n\n\t\t/* use prefetched values */\n\t\trx_desc = next_rxd;\n\t\tbuffer_info = next_buffer;\n\n\t\tstaterr = le32_to_cpu(rx_desc->wb.upper.status_error);\n\t}\n\trx_ring->next_to_clean = i;\n\n\tcleaned_count = e1000_desc_unused(rx_ring);\n\tif (cleaned_count)\n\t\tadapter->alloc_rx_buf(rx_ring, cleaned_count, GFP_ATOMIC);\n\n\tadapter->total_rx_bytes += total_rx_bytes;\n\tadapter->total_rx_packets += total_rx_packets;\n\treturn cleaned;\n}\n\nstatic void e1000_put_txbuf(struct e1000_ring *tx_ring,\n\t\t\t    struct e1000_buffer *buffer_info,\n\t\t\t    bool drop)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\n\tif (buffer_info->dma) {\n\t\tif (buffer_info->mapped_as_page)\n\t\t\tdma_unmap_page(&adapter->pdev->dev, buffer_info->dma,\n\t\t\t\t       buffer_info->length, DMA_TO_DEVICE);\n\t\telse\n\t\t\tdma_unmap_single(&adapter->pdev->dev, buffer_info->dma,\n\t\t\t\t\t buffer_info->length, DMA_TO_DEVICE);\n\t\tbuffer_info->dma = 0;\n\t}\n\tif (buffer_info->skb) {\n\t\tif (drop)\n\t\t\tdev_kfree_skb_any(buffer_info->skb);\n\t\telse\n\t\t\tdev_consume_skb_any(buffer_info->skb);\n\t\tbuffer_info->skb = NULL;\n\t}\n\tbuffer_info->time_stamp = 0;\n}\n\nstatic void e1000_print_hw_hang(struct work_struct *work)\n{\n\tstruct e1000_adapter *adapter = container_of(work,\n\t\t\t\t\t\t     struct e1000_adapter,\n\t\t\t\t\t\t     print_hang_task);\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_ring *tx_ring = adapter->tx_ring;\n\tunsigned int i = tx_ring->next_to_clean;\n\tunsigned int eop = tx_ring->buffer_info[i].next_to_watch;\n\tstruct e1000_tx_desc *eop_desc = E1000_TX_DESC(*tx_ring, eop);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 phy_status, phy_1000t_status, phy_ext_status;\n\tu16 pci_status;\n\n\tif (test_bit(__E1000_DOWN, &adapter->state))\n\t\treturn;\n\n\tif (!adapter->tx_hang_recheck && (adapter->flags2 & FLAG2_DMA_BURST)) {\n\t\t/* May be block on write-back, flush and detect again\n\t\t * flush pending descriptor writebacks to memory\n\t\t */\n\t\tew32(TIDV, adapter->tx_int_delay | E1000_TIDV_FPD);\n\t\t/* execute the writes immediately */\n\t\te1e_flush();\n\t\t/* Due to rare timing issues, write to TIDV again to ensure\n\t\t * the write is successful\n\t\t */\n\t\tew32(TIDV, adapter->tx_int_delay | E1000_TIDV_FPD);\n\t\t/* execute the writes immediately */\n\t\te1e_flush();\n\t\tadapter->tx_hang_recheck = true;\n\t\treturn;\n\t}\n\tadapter->tx_hang_recheck = false;\n\n\tif (er32(TDH(0)) == er32(TDT(0))) {\n\t\te_dbg(\"false hang detected, ignoring\\n\");\n\t\treturn;\n\t}\n\n\t/* Real hang detected */\n\tnetif_stop_queue(netdev);\n\n\te1e_rphy(hw, MII_BMSR, &phy_status);\n\te1e_rphy(hw, MII_STAT1000, &phy_1000t_status);\n\te1e_rphy(hw, MII_ESTATUS, &phy_ext_status);\n\n\tpci_read_config_word(adapter->pdev, PCI_STATUS, &pci_status);\n\n\t/* detected Hardware unit hang */\n\te_err(\"Detected Hardware Unit Hang:\\n\"\n\t      \"  TDH                  <%x>\\n\"\n\t      \"  TDT                  <%x>\\n\"\n\t      \"  next_to_use          <%x>\\n\"\n\t      \"  next_to_clean        <%x>\\n\"\n\t      \"buffer_info[next_to_clean]:\\n\"\n\t      \"  time_stamp           <%lx>\\n\"\n\t      \"  next_to_watch        <%x>\\n\"\n\t      \"  jiffies              <%lx>\\n\"\n\t      \"  next_to_watch.status <%x>\\n\"\n\t      \"MAC Status             <%x>\\n\"\n\t      \"PHY Status             <%x>\\n\"\n\t      \"PHY 1000BASE-T Status  <%x>\\n\"\n\t      \"PHY Extended Status    <%x>\\n\"\n\t      \"PCI Status             <%x>\\n\",\n\t      readl(tx_ring->head), readl(tx_ring->tail), tx_ring->next_to_use,\n\t      tx_ring->next_to_clean, tx_ring->buffer_info[eop].time_stamp,\n\t      eop, jiffies, eop_desc->upper.fields.status, er32(STATUS),\n\t      phy_status, phy_1000t_status, phy_ext_status, pci_status);\n\n\te1000e_dump(adapter);\n\n\t/* Suggest workaround for known h/w issue */\n\tif ((hw->mac.type == e1000_pchlan) && (er32(CTRL) & E1000_CTRL_TFCE))\n\t\te_err(\"Try turning off Tx pause (flow control) via ethtool\\n\");\n}\n\n/**\n * e1000e_tx_hwtstamp_work - check for Tx time stamp\n * @work: pointer to work struct\n *\n * This work function polls the TSYNCTXCTL valid bit to determine when a\n * timestamp has been taken for the current stored skb.  The timestamp must\n * be for this skb because only one such packet is allowed in the queue.\n */\nstatic void e1000e_tx_hwtstamp_work(struct work_struct *work)\n{\n\tstruct e1000_adapter *adapter = container_of(work, struct e1000_adapter,\n\t\t\t\t\t\t     tx_hwtstamp_work);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (er32(TSYNCTXCTL) & E1000_TSYNCTXCTL_VALID) {\n\t\tstruct sk_buff *skb = adapter->tx_hwtstamp_skb;\n\t\tstruct skb_shared_hwtstamps shhwtstamps;\n\t\tu64 txstmp;\n\n\t\ttxstmp = er32(TXSTMPL);\n\t\ttxstmp |= (u64)er32(TXSTMPH) << 32;\n\n\t\te1000e_systim_to_hwtstamp(adapter, &shhwtstamps, txstmp);\n\n\t\t/* Clear the global tx_hwtstamp_skb pointer and force writes\n\t\t * prior to notifying the stack of a Tx timestamp.\n\t\t */\n\t\tadapter->tx_hwtstamp_skb = NULL;\n\t\twmb(); /* force write prior to skb_tstamp_tx */\n\n\t\tskb_tstamp_tx(skb, &shhwtstamps);\n\t\tdev_consume_skb_any(skb);\n\t} else if (time_after(jiffies, adapter->tx_hwtstamp_start\n\t\t\t      + adapter->tx_timeout_factor * HZ)) {\n\t\tdev_kfree_skb_any(adapter->tx_hwtstamp_skb);\n\t\tadapter->tx_hwtstamp_skb = NULL;\n\t\tadapter->tx_hwtstamp_timeouts++;\n\t\te_warn(\"clearing Tx timestamp hang\\n\");\n\t} else {\n\t\t/* reschedule to check later */\n\t\tschedule_work(&adapter->tx_hwtstamp_work);\n\t}\n}\n\n/**\n * e1000_clean_tx_irq - Reclaim resources after transmit completes\n * @tx_ring: Tx descriptor ring\n *\n * the return value indicates whether actual cleaning was done, there\n * is no guarantee that everything was cleaned\n **/\nstatic bool e1000_clean_tx_irq(struct e1000_ring *tx_ring)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_tx_desc *tx_desc, *eop_desc;\n\tstruct e1000_buffer *buffer_info;\n\tunsigned int i, eop;\n\tunsigned int count = 0;\n\tunsigned int total_tx_bytes = 0, total_tx_packets = 0;\n\tunsigned int bytes_compl = 0, pkts_compl = 0;\n\n\ti = tx_ring->next_to_clean;\n\teop = tx_ring->buffer_info[i].next_to_watch;\n\teop_desc = E1000_TX_DESC(*tx_ring, eop);\n\n\twhile ((eop_desc->upper.data & cpu_to_le32(E1000_TXD_STAT_DD)) &&\n\t       (count < tx_ring->count)) {\n\t\tbool cleaned = false;\n\n\t\tdma_rmb();\t\t/* read buffer_info after eop_desc */\n\t\tfor (; !cleaned; count++) {\n\t\t\ttx_desc = E1000_TX_DESC(*tx_ring, i);\n\t\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\t\tcleaned = (i == eop);\n\n\t\t\tif (cleaned) {\n\t\t\t\ttotal_tx_packets += buffer_info->segs;\n\t\t\t\ttotal_tx_bytes += buffer_info->bytecount;\n\t\t\t\tif (buffer_info->skb) {\n\t\t\t\t\tbytes_compl += buffer_info->skb->len;\n\t\t\t\t\tpkts_compl++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te1000_put_txbuf(tx_ring, buffer_info, false);\n\t\t\ttx_desc->upper.data = 0;\n\n\t\t\ti++;\n\t\t\tif (i == tx_ring->count)\n\t\t\t\ti = 0;\n\t\t}\n\n\t\tif (i == tx_ring->next_to_use)\n\t\t\tbreak;\n\t\teop = tx_ring->buffer_info[i].next_to_watch;\n\t\teop_desc = E1000_TX_DESC(*tx_ring, eop);\n\t}\n\n\ttx_ring->next_to_clean = i;\n\n\tnetdev_completed_queue(netdev, pkts_compl, bytes_compl);\n\n#define TX_WAKE_THRESHOLD 32\n\tif (count && netif_carrier_ok(netdev) &&\n\t    e1000_desc_unused(tx_ring) >= TX_WAKE_THRESHOLD) {\n\t\t/* Make sure that anybody stopping the queue after this\n\t\t * sees the new next_to_clean.\n\t\t */\n\t\tsmp_mb();\n\n\t\tif (netif_queue_stopped(netdev) &&\n\t\t    !(test_bit(__E1000_DOWN, &adapter->state))) {\n\t\t\tnetif_wake_queue(netdev);\n\t\t\t++adapter->restart_queue;\n\t\t}\n\t}\n\n\tif (adapter->detect_tx_hung) {\n\t\t/* Detect a transmit hang in hardware, this serializes the\n\t\t * check with the clearing of time_stamp and movement of i\n\t\t */\n\t\tadapter->detect_tx_hung = false;\n\t\tif (tx_ring->buffer_info[i].time_stamp &&\n\t\t    time_after(jiffies, tx_ring->buffer_info[i].time_stamp\n\t\t\t       + (adapter->tx_timeout_factor * HZ)) &&\n\t\t    !(er32(STATUS) & E1000_STATUS_TXOFF))\n\t\t\tschedule_work(&adapter->print_hang_task);\n\t\telse\n\t\t\tadapter->tx_hang_recheck = false;\n\t}\n\tadapter->total_tx_bytes += total_tx_bytes;\n\tadapter->total_tx_packets += total_tx_packets;\n\treturn count < tx_ring->count;\n}\n\n/**\n * e1000_clean_rx_irq_ps - Send received data up the network stack; packet split\n * @rx_ring: Rx descriptor ring\n * @work_done: output parameter for indicating completed work\n * @work_to_do: how many packets we can clean\n *\n * the return value indicates whether actual cleaning was done, there\n * is no guarantee that everything was cleaned\n **/\nstatic bool e1000_clean_rx_irq_ps(struct e1000_ring *rx_ring, int *work_done,\n\t\t\t\t  int work_to_do)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunion e1000_rx_desc_packet_split *rx_desc, *next_rxd;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_buffer *buffer_info, *next_buffer;\n\tstruct e1000_ps_page *ps_page;\n\tstruct sk_buff *skb;\n\tunsigned int i, j;\n\tu32 length, staterr;\n\tint cleaned_count = 0;\n\tbool cleaned = false;\n\tunsigned int total_rx_bytes = 0, total_rx_packets = 0;\n\n\ti = rx_ring->next_to_clean;\n\trx_desc = E1000_RX_DESC_PS(*rx_ring, i);\n\tstaterr = le32_to_cpu(rx_desc->wb.middle.status_error);\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (staterr & E1000_RXD_STAT_DD) {\n\t\tif (*work_done >= work_to_do)\n\t\t\tbreak;\n\t\t(*work_done)++;\n\t\tskb = buffer_info->skb;\n\t\tdma_rmb();\t/* read descriptor and rx_buffer_info after status DD */\n\n\t\t/* in the packet split case this is header only */\n\t\tprefetch(skb->data - NET_IP_ALIGN);\n\n\t\ti++;\n\t\tif (i == rx_ring->count)\n\t\t\ti = 0;\n\t\tnext_rxd = E1000_RX_DESC_PS(*rx_ring, i);\n\t\tprefetch(next_rxd);\n\n\t\tnext_buffer = &rx_ring->buffer_info[i];\n\n\t\tcleaned = true;\n\t\tcleaned_count++;\n\t\tdma_unmap_single(&pdev->dev, buffer_info->dma,\n\t\t\t\t adapter->rx_ps_bsize0, DMA_FROM_DEVICE);\n\t\tbuffer_info->dma = 0;\n\n\t\t/* see !EOP comment in other Rx routine */\n\t\tif (!(staterr & E1000_RXD_STAT_EOP))\n\t\t\tadapter->flags2 |= FLAG2_IS_DISCARDING;\n\n\t\tif (adapter->flags2 & FLAG2_IS_DISCARDING) {\n\t\t\te_dbg(\"Packet Split buffers didn't pick up the full packet\\n\");\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\tif (staterr & E1000_RXD_STAT_EOP)\n\t\t\t\tadapter->flags2 &= ~FLAG2_IS_DISCARDING;\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\tif (unlikely((staterr & E1000_RXDEXT_ERR_FRAME_ERR_MASK) &&\n\t\t\t     !(netdev->features & NETIF_F_RXALL))) {\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\tlength = le16_to_cpu(rx_desc->wb.middle.length0);\n\n\t\tif (!length) {\n\t\t\te_dbg(\"Last part of the packet spanning multiple descriptors\\n\");\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\t/* Good Receive */\n\t\tskb_put(skb, length);\n\n\t\t{\n\t\t\t/* this looks ugly, but it seems compiler issues make\n\t\t\t * it more efficient than reusing j\n\t\t\t */\n\t\t\tint l1 = le16_to_cpu(rx_desc->wb.upper.length[0]);\n\n\t\t\t/* page alloc/put takes too long and effects small\n\t\t\t * packet throughput, so unsplit small packets and\n\t\t\t * save the alloc/put only valid in softirq (napi)\n\t\t\t * context to call kmap_*\n\t\t\t */\n\t\t\tif (l1 && (l1 <= copybreak) &&\n\t\t\t    ((length + l1) <= adapter->rx_ps_bsize0)) {\n\t\t\t\tu8 *vaddr;\n\n\t\t\t\tps_page = &buffer_info->ps_pages[0];\n\n\t\t\t\t/* there is no documentation about how to call\n\t\t\t\t * kmap_atomic, so we can't hold the mapping\n\t\t\t\t * very long\n\t\t\t\t */\n\t\t\t\tdma_sync_single_for_cpu(&pdev->dev,\n\t\t\t\t\t\t\tps_page->dma,\n\t\t\t\t\t\t\tPAGE_SIZE,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\tvaddr = kmap_atomic(ps_page->page);\n\t\t\t\tmemcpy(skb_tail_pointer(skb), vaddr, l1);\n\t\t\t\tkunmap_atomic(vaddr);\n\t\t\t\tdma_sync_single_for_device(&pdev->dev,\n\t\t\t\t\t\t\t   ps_page->dma,\n\t\t\t\t\t\t\t   PAGE_SIZE,\n\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\n\t\t\t\t/* remove the CRC */\n\t\t\t\tif (!(adapter->flags2 & FLAG2_CRC_STRIPPING)) {\n\t\t\t\t\tif (!(netdev->features & NETIF_F_RXFCS))\n\t\t\t\t\t\tl1 -= 4;\n\t\t\t\t}\n\n\t\t\t\tskb_put(skb, l1);\n\t\t\t\tgoto copydone;\n\t\t\t}\t/* if */\n\t\t}\n\n\t\tfor (j = 0; j < PS_PAGE_BUFFERS; j++) {\n\t\t\tlength = le16_to_cpu(rx_desc->wb.upper.length[j]);\n\t\t\tif (!length)\n\t\t\t\tbreak;\n\n\t\t\tps_page = &buffer_info->ps_pages[j];\n\t\t\tdma_unmap_page(&pdev->dev, ps_page->dma, PAGE_SIZE,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\tps_page->dma = 0;\n\t\t\tskb_fill_page_desc(skb, j, ps_page->page, 0, length);\n\t\t\tps_page->page = NULL;\n\t\t\tskb->len += length;\n\t\t\tskb->data_len += length;\n\t\t\tskb->truesize += PAGE_SIZE;\n\t\t}\n\n\t\t/* strip the ethernet crc, problem is we're using pages now so\n\t\t * this whole operation can get a little cpu intensive\n\t\t */\n\t\tif (!(adapter->flags2 & FLAG2_CRC_STRIPPING)) {\n\t\t\tif (!(netdev->features & NETIF_F_RXFCS))\n\t\t\t\tpskb_trim(skb, skb->len - 4);\n\t\t}\n\ncopydone:\n\t\ttotal_rx_bytes += skb->len;\n\t\ttotal_rx_packets++;\n\n\t\te1000_rx_checksum(adapter, staterr, skb);\n\n\t\te1000_rx_hash(netdev, rx_desc->wb.lower.hi_dword.rss, skb);\n\n\t\tif (rx_desc->wb.upper.header_status &\n\t\t    cpu_to_le16(E1000_RXDPS_HDRSTAT_HDRSP))\n\t\t\tadapter->rx_hdr_split++;\n\n\t\te1000_receive_skb(adapter, netdev, skb, staterr,\n\t\t\t\t  rx_desc->wb.middle.vlan);\n\nnext_desc:\n\t\trx_desc->wb.middle.status_error &= cpu_to_le32(~0xFF);\n\t\tbuffer_info->skb = NULL;\n\n\t\t/* return some buffers to hardware, one at a time is too slow */\n\t\tif (cleaned_count >= E1000_RX_BUFFER_WRITE) {\n\t\t\tadapter->alloc_rx_buf(rx_ring, cleaned_count,\n\t\t\t\t\t      GFP_ATOMIC);\n\t\t\tcleaned_count = 0;\n\t\t}\n\n\t\t/* use prefetched values */\n\t\trx_desc = next_rxd;\n\t\tbuffer_info = next_buffer;\n\n\t\tstaterr = le32_to_cpu(rx_desc->wb.middle.status_error);\n\t}\n\trx_ring->next_to_clean = i;\n\n\tcleaned_count = e1000_desc_unused(rx_ring);\n\tif (cleaned_count)\n\t\tadapter->alloc_rx_buf(rx_ring, cleaned_count, GFP_ATOMIC);\n\n\tadapter->total_rx_bytes += total_rx_bytes;\n\tadapter->total_rx_packets += total_rx_packets;\n\treturn cleaned;\n}\n\nstatic void e1000_consume_page(struct e1000_buffer *bi, struct sk_buff *skb,\n\t\t\t       u16 length)\n{\n\tbi->page = NULL;\n\tskb->len += length;\n\tskb->data_len += length;\n\tskb->truesize += PAGE_SIZE;\n}\n\n/**\n * e1000_clean_jumbo_rx_irq - Send received data up the network stack; legacy\n * @rx_ring: Rx descriptor ring\n * @work_done: output parameter for indicating completed work\n * @work_to_do: how many packets we can clean\n *\n * the return value indicates whether actual cleaning was done, there\n * is no guarantee that everything was cleaned\n **/\nstatic bool e1000_clean_jumbo_rx_irq(struct e1000_ring *rx_ring, int *work_done,\n\t\t\t\t     int work_to_do)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tunion e1000_rx_desc_extended *rx_desc, *next_rxd;\n\tstruct e1000_buffer *buffer_info, *next_buffer;\n\tu32 length, staterr;\n\tunsigned int i;\n\tint cleaned_count = 0;\n\tbool cleaned = false;\n\tunsigned int total_rx_bytes = 0, total_rx_packets = 0;\n\tstruct skb_shared_info *shinfo;\n\n\ti = rx_ring->next_to_clean;\n\trx_desc = E1000_RX_DESC_EXT(*rx_ring, i);\n\tstaterr = le32_to_cpu(rx_desc->wb.upper.status_error);\n\tbuffer_info = &rx_ring->buffer_info[i];\n\n\twhile (staterr & E1000_RXD_STAT_DD) {\n\t\tstruct sk_buff *skb;\n\n\t\tif (*work_done >= work_to_do)\n\t\t\tbreak;\n\t\t(*work_done)++;\n\t\tdma_rmb();\t/* read descriptor and rx_buffer_info after status DD */\n\n\t\tskb = buffer_info->skb;\n\t\tbuffer_info->skb = NULL;\n\n\t\t++i;\n\t\tif (i == rx_ring->count)\n\t\t\ti = 0;\n\t\tnext_rxd = E1000_RX_DESC_EXT(*rx_ring, i);\n\t\tprefetch(next_rxd);\n\n\t\tnext_buffer = &rx_ring->buffer_info[i];\n\n\t\tcleaned = true;\n\t\tcleaned_count++;\n\t\tdma_unmap_page(&pdev->dev, buffer_info->dma, PAGE_SIZE,\n\t\t\t       DMA_FROM_DEVICE);\n\t\tbuffer_info->dma = 0;\n\n\t\tlength = le16_to_cpu(rx_desc->wb.upper.length);\n\n\t\t/* errors is only valid for DD + EOP descriptors */\n\t\tif (unlikely((staterr & E1000_RXD_STAT_EOP) &&\n\t\t\t     ((staterr & E1000_RXDEXT_ERR_FRAME_ERR_MASK) &&\n\t\t\t      !(netdev->features & NETIF_F_RXALL)))) {\n\t\t\t/* recycle both page and skb */\n\t\t\tbuffer_info->skb = skb;\n\t\t\t/* an error means any chain goes out the window too */\n\t\t\tif (rx_ring->rx_skb_top)\n\t\t\t\tdev_kfree_skb_irq(rx_ring->rx_skb_top);\n\t\t\trx_ring->rx_skb_top = NULL;\n\t\t\tgoto next_desc;\n\t\t}\n#define rxtop (rx_ring->rx_skb_top)\n\t\tif (!(staterr & E1000_RXD_STAT_EOP)) {\n\t\t\t/* this descriptor is only the beginning (or middle) */\n\t\t\tif (!rxtop) {\n\t\t\t\t/* this is the beginning of a chain */\n\t\t\t\trxtop = skb;\n\t\t\t\tskb_fill_page_desc(rxtop, 0, buffer_info->page,\n\t\t\t\t\t\t   0, length);\n\t\t\t} else {\n\t\t\t\t/* this is the middle of a chain */\n\t\t\t\tshinfo = skb_shinfo(rxtop);\n\t\t\t\tskb_fill_page_desc(rxtop, shinfo->nr_frags,\n\t\t\t\t\t\t   buffer_info->page, 0,\n\t\t\t\t\t\t   length);\n\t\t\t\t/* re-use the skb, only consumed the page */\n\t\t\t\tbuffer_info->skb = skb;\n\t\t\t}\n\t\t\te1000_consume_page(buffer_info, rxtop, length);\n\t\t\tgoto next_desc;\n\t\t} else {\n\t\t\tif (rxtop) {\n\t\t\t\t/* end of the chain */\n\t\t\t\tshinfo = skb_shinfo(rxtop);\n\t\t\t\tskb_fill_page_desc(rxtop, shinfo->nr_frags,\n\t\t\t\t\t\t   buffer_info->page, 0,\n\t\t\t\t\t\t   length);\n\t\t\t\t/* re-use the current skb, we only consumed the\n\t\t\t\t * page\n\t\t\t\t */\n\t\t\t\tbuffer_info->skb = skb;\n\t\t\t\tskb = rxtop;\n\t\t\t\trxtop = NULL;\n\t\t\t\te1000_consume_page(buffer_info, skb, length);\n\t\t\t} else {\n\t\t\t\t/* no chain, got EOP, this buf is the packet\n\t\t\t\t * copybreak to save the put_page/alloc_page\n\t\t\t\t */\n\t\t\t\tif (length <= copybreak &&\n\t\t\t\t    skb_tailroom(skb) >= length) {\n\t\t\t\t\tu8 *vaddr;\n\t\t\t\t\tvaddr = kmap_atomic(buffer_info->page);\n\t\t\t\t\tmemcpy(skb_tail_pointer(skb), vaddr,\n\t\t\t\t\t       length);\n\t\t\t\t\tkunmap_atomic(vaddr);\n\t\t\t\t\t/* re-use the page, so don't erase\n\t\t\t\t\t * buffer_info->page\n\t\t\t\t\t */\n\t\t\t\t\tskb_put(skb, length);\n\t\t\t\t} else {\n\t\t\t\t\tskb_fill_page_desc(skb, 0,\n\t\t\t\t\t\t\t   buffer_info->page, 0,\n\t\t\t\t\t\t\t   length);\n\t\t\t\t\te1000_consume_page(buffer_info, skb,\n\t\t\t\t\t\t\t   length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Receive Checksum Offload */\n\t\te1000_rx_checksum(adapter, staterr, skb);\n\n\t\te1000_rx_hash(netdev, rx_desc->wb.lower.hi_dword.rss, skb);\n\n\t\t/* probably a little skewed due to removing CRC */\n\t\ttotal_rx_bytes += skb->len;\n\t\ttotal_rx_packets++;\n\n\t\t/* eth type trans needs skb->data to point to something */\n\t\tif (!pskb_may_pull(skb, ETH_HLEN)) {\n\t\t\te_err(\"pskb_may_pull failed.\\n\");\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\te1000_receive_skb(adapter, netdev, skb, staterr,\n\t\t\t\t  rx_desc->wb.upper.vlan);\n\nnext_desc:\n\t\trx_desc->wb.upper.status_error &= cpu_to_le32(~0xFF);\n\n\t\t/* return some buffers to hardware, one at a time is too slow */\n\t\tif (unlikely(cleaned_count >= E1000_RX_BUFFER_WRITE)) {\n\t\t\tadapter->alloc_rx_buf(rx_ring, cleaned_count,\n\t\t\t\t\t      GFP_ATOMIC);\n\t\t\tcleaned_count = 0;\n\t\t}\n\n\t\t/* use prefetched values */\n\t\trx_desc = next_rxd;\n\t\tbuffer_info = next_buffer;\n\n\t\tstaterr = le32_to_cpu(rx_desc->wb.upper.status_error);\n\t}\n\trx_ring->next_to_clean = i;\n\n\tcleaned_count = e1000_desc_unused(rx_ring);\n\tif (cleaned_count)\n\t\tadapter->alloc_rx_buf(rx_ring, cleaned_count, GFP_ATOMIC);\n\n\tadapter->total_rx_bytes += total_rx_bytes;\n\tadapter->total_rx_packets += total_rx_packets;\n\treturn cleaned;\n}\n\n/**\n * e1000_clean_rx_ring - Free Rx Buffers per Queue\n * @rx_ring: Rx descriptor ring\n **/\nstatic void e1000_clean_rx_ring(struct e1000_ring *rx_ring)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct e1000_buffer *buffer_info;\n\tstruct e1000_ps_page *ps_page;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tunsigned int i, j;\n\n\t/* Free all the Rx ring sk_buffs */\n\tfor (i = 0; i < rx_ring->count; i++) {\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t\tif (buffer_info->dma) {\n\t\t\tif (adapter->clean_rx == e1000_clean_rx_irq)\n\t\t\t\tdma_unmap_single(&pdev->dev, buffer_info->dma,\n\t\t\t\t\t\t adapter->rx_buffer_len,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\telse if (adapter->clean_rx == e1000_clean_jumbo_rx_irq)\n\t\t\t\tdma_unmap_page(&pdev->dev, buffer_info->dma,\n\t\t\t\t\t       PAGE_SIZE, DMA_FROM_DEVICE);\n\t\t\telse if (adapter->clean_rx == e1000_clean_rx_irq_ps)\n\t\t\t\tdma_unmap_single(&pdev->dev, buffer_info->dma,\n\t\t\t\t\t\t adapter->rx_ps_bsize0,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tbuffer_info->dma = 0;\n\t\t}\n\n\t\tif (buffer_info->page) {\n\t\t\tput_page(buffer_info->page);\n\t\t\tbuffer_info->page = NULL;\n\t\t}\n\n\t\tif (buffer_info->skb) {\n\t\t\tdev_kfree_skb(buffer_info->skb);\n\t\t\tbuffer_info->skb = NULL;\n\t\t}\n\n\t\tfor (j = 0; j < PS_PAGE_BUFFERS; j++) {\n\t\t\tps_page = &buffer_info->ps_pages[j];\n\t\t\tif (!ps_page->page)\n\t\t\t\tbreak;\n\t\t\tdma_unmap_page(&pdev->dev, ps_page->dma, PAGE_SIZE,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\tps_page->dma = 0;\n\t\t\tput_page(ps_page->page);\n\t\t\tps_page->page = NULL;\n\t\t}\n\t}\n\n\t/* there also may be some cached data from a chained receive */\n\tif (rx_ring->rx_skb_top) {\n\t\tdev_kfree_skb(rx_ring->rx_skb_top);\n\t\trx_ring->rx_skb_top = NULL;\n\t}\n\n\t/* Zero out the descriptor ring */\n\tmemset(rx_ring->desc, 0, rx_ring->size);\n\n\trx_ring->next_to_clean = 0;\n\trx_ring->next_to_use = 0;\n\tadapter->flags2 &= ~FLAG2_IS_DISCARDING;\n}\n\nstatic void e1000e_downshift_workaround(struct work_struct *work)\n{\n\tstruct e1000_adapter *adapter = container_of(work,\n\t\t\t\t\t\t     struct e1000_adapter,\n\t\t\t\t\t\t     downshift_task);\n\n\tif (test_bit(__E1000_DOWN, &adapter->state))\n\t\treturn;\n\n\te1000e_gig_downshift_workaround_ich8lan(&adapter->hw);\n}\n\n/**\n * e1000_intr_msi - Interrupt Handler\n * @irq: interrupt number\n * @data: pointer to a network interface device structure\n **/\nstatic irqreturn_t e1000_intr_msi(int __always_unused irq, void *data)\n{\n\tstruct net_device *netdev = data;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 icr = er32(ICR);\n\n\t/* read ICR disables interrupts using IAM */\n\tif (icr & E1000_ICR_LSC) {\n\t\thw->mac.get_link_status = true;\n\t\t/* ICH8 workaround-- Call gig speed drop workaround on cable\n\t\t * disconnect (LSC) before accessing any PHY registers\n\t\t */\n\t\tif ((adapter->flags & FLAG_LSC_GIG_SPEED_DROP) &&\n\t\t    (!(er32(STATUS) & E1000_STATUS_LU)))\n\t\t\tschedule_work(&adapter->downshift_task);\n\n\t\t/* 80003ES2LAN workaround-- For packet buffer work-around on\n\t\t * link down event; disable receives here in the ISR and reset\n\t\t * adapter in watchdog\n\t\t */\n\t\tif (netif_carrier_ok(netdev) &&\n\t\t    adapter->flags & FLAG_RX_NEEDS_RESTART) {\n\t\t\t/* disable receives */\n\t\t\tu32 rctl = er32(RCTL);\n\n\t\t\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\t\t\tadapter->flags |= FLAG_RESTART_NOW;\n\t\t}\n\t\t/* guard against interrupt when we're going down */\n\t\tif (!test_bit(__E1000_DOWN, &adapter->state))\n\t\t\tmod_timer(&adapter->watchdog_timer, jiffies + 1);\n\t}\n\n\t/* Reset on uncorrectable ECC error */\n\tif ((icr & E1000_ICR_ECCER) && (hw->mac.type >= e1000_pch_lpt)) {\n\t\tu32 pbeccsts = er32(PBECCSTS);\n\n\t\tadapter->corr_errors +=\n\t\t    pbeccsts & E1000_PBECCSTS_CORR_ERR_CNT_MASK;\n\t\tadapter->uncorr_errors +=\n\t\t    (pbeccsts & E1000_PBECCSTS_UNCORR_ERR_CNT_MASK) >>\n\t\t    E1000_PBECCSTS_UNCORR_ERR_CNT_SHIFT;\n\n\t\t/* Do the reset outside of interrupt context */\n\t\tschedule_work(&adapter->reset_task);\n\n\t\t/* return immediately since reset is imminent */\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (napi_schedule_prep(&adapter->napi)) {\n\t\tadapter->total_tx_bytes = 0;\n\t\tadapter->total_tx_packets = 0;\n\t\tadapter->total_rx_bytes = 0;\n\t\tadapter->total_rx_packets = 0;\n\t\t__napi_schedule(&adapter->napi);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n/**\n * e1000_intr - Interrupt Handler\n * @irq: interrupt number\n * @data: pointer to a network interface device structure\n **/\nstatic irqreturn_t e1000_intr(int __always_unused irq, void *data)\n{\n\tstruct net_device *netdev = data;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl, icr = er32(ICR);\n\n\tif (!icr || test_bit(__E1000_DOWN, &adapter->state))\n\t\treturn IRQ_NONE;\t/* Not our interrupt */\n\n\t/* IMS will not auto-mask if INT_ASSERTED is not set, and if it is\n\t * not set, then the adapter didn't send an interrupt\n\t */\n\tif (!(icr & E1000_ICR_INT_ASSERTED))\n\t\treturn IRQ_NONE;\n\n\t/* Interrupt Auto-Mask...upon reading ICR,\n\t * interrupts are masked.  No need for the\n\t * IMC write\n\t */\n\n\tif (icr & E1000_ICR_LSC) {\n\t\thw->mac.get_link_status = true;\n\t\t/* ICH8 workaround-- Call gig speed drop workaround on cable\n\t\t * disconnect (LSC) before accessing any PHY registers\n\t\t */\n\t\tif ((adapter->flags & FLAG_LSC_GIG_SPEED_DROP) &&\n\t\t    (!(er32(STATUS) & E1000_STATUS_LU)))\n\t\t\tschedule_work(&adapter->downshift_task);\n\n\t\t/* 80003ES2LAN workaround--\n\t\t * For packet buffer work-around on link down event;\n\t\t * disable receives here in the ISR and\n\t\t * reset adapter in watchdog\n\t\t */\n\t\tif (netif_carrier_ok(netdev) &&\n\t\t    (adapter->flags & FLAG_RX_NEEDS_RESTART)) {\n\t\t\t/* disable receives */\n\t\t\trctl = er32(RCTL);\n\t\t\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\t\t\tadapter->flags |= FLAG_RESTART_NOW;\n\t\t}\n\t\t/* guard against interrupt when we're going down */\n\t\tif (!test_bit(__E1000_DOWN, &adapter->state))\n\t\t\tmod_timer(&adapter->watchdog_timer, jiffies + 1);\n\t}\n\n\t/* Reset on uncorrectable ECC error */\n\tif ((icr & E1000_ICR_ECCER) && (hw->mac.type >= e1000_pch_lpt)) {\n\t\tu32 pbeccsts = er32(PBECCSTS);\n\n\t\tadapter->corr_errors +=\n\t\t    pbeccsts & E1000_PBECCSTS_CORR_ERR_CNT_MASK;\n\t\tadapter->uncorr_errors +=\n\t\t    (pbeccsts & E1000_PBECCSTS_UNCORR_ERR_CNT_MASK) >>\n\t\t    E1000_PBECCSTS_UNCORR_ERR_CNT_SHIFT;\n\n\t\t/* Do the reset outside of interrupt context */\n\t\tschedule_work(&adapter->reset_task);\n\n\t\t/* return immediately since reset is imminent */\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (napi_schedule_prep(&adapter->napi)) {\n\t\tadapter->total_tx_bytes = 0;\n\t\tadapter->total_tx_packets = 0;\n\t\tadapter->total_rx_bytes = 0;\n\t\tadapter->total_rx_packets = 0;\n\t\t__napi_schedule(&adapter->napi);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t e1000_msix_other(int __always_unused irq, void *data)\n{\n\tstruct net_device *netdev = data;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 icr = er32(ICR);\n\n\tif (icr & adapter->eiac_mask)\n\t\tew32(ICS, (icr & adapter->eiac_mask));\n\n\tif (icr & E1000_ICR_LSC) {\n\t\thw->mac.get_link_status = true;\n\t\t/* guard against interrupt when we're going down */\n\t\tif (!test_bit(__E1000_DOWN, &adapter->state))\n\t\t\tmod_timer(&adapter->watchdog_timer, jiffies + 1);\n\t}\n\n\tif (!test_bit(__E1000_DOWN, &adapter->state))\n\t\tew32(IMS, E1000_IMS_OTHER | IMS_OTHER_MASK);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t e1000_intr_msix_tx(int __always_unused irq, void *data)\n{\n\tstruct net_device *netdev = data;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_ring *tx_ring = adapter->tx_ring;\n\n\tadapter->total_tx_bytes = 0;\n\tadapter->total_tx_packets = 0;\n\n\tif (!e1000_clean_tx_irq(tx_ring))\n\t\t/* Ring was not completely cleaned, so fire another interrupt */\n\t\tew32(ICS, tx_ring->ims_val);\n\n\tif (!test_bit(__E1000_DOWN, &adapter->state))\n\t\tew32(IMS, adapter->tx_ring->ims_val);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t e1000_intr_msix_rx(int __always_unused irq, void *data)\n{\n\tstruct net_device *netdev = data;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_ring *rx_ring = adapter->rx_ring;\n\n\t/* Write the ITR value calculated at the end of the\n\t * previous interrupt.\n\t */\n\tif (rx_ring->set_itr) {\n\t\tu32 itr = rx_ring->itr_val ?\n\t\t\t  1000000000 / (rx_ring->itr_val * 256) : 0;\n\n\t\twritel(itr, rx_ring->itr_register);\n\t\trx_ring->set_itr = 0;\n\t}\n\n\tif (napi_schedule_prep(&adapter->napi)) {\n\t\tadapter->total_rx_bytes = 0;\n\t\tadapter->total_rx_packets = 0;\n\t\t__napi_schedule(&adapter->napi);\n\t}\n\treturn IRQ_HANDLED;\n}\n\n/**\n * e1000_configure_msix - Configure MSI-X hardware\n * @adapter: board private structure\n *\n * e1000_configure_msix sets up the hardware to properly\n * generate MSI-X interrupts.\n **/\nstatic void e1000_configure_msix(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_ring *rx_ring = adapter->rx_ring;\n\tstruct e1000_ring *tx_ring = adapter->tx_ring;\n\tint vector = 0;\n\tu32 ctrl_ext, ivar = 0;\n\n\tadapter->eiac_mask = 0;\n\n\t/* Workaround issue with spurious interrupts on 82574 in MSI-X mode */\n\tif (hw->mac.type == e1000_82574) {\n\t\tu32 rfctl = er32(RFCTL);\n\n\t\trfctl |= E1000_RFCTL_ACK_DIS;\n\t\tew32(RFCTL, rfctl);\n\t}\n\n\t/* Configure Rx vector */\n\trx_ring->ims_val = E1000_IMS_RXQ0;\n\tadapter->eiac_mask |= rx_ring->ims_val;\n\tif (rx_ring->itr_val)\n\t\twritel(1000000000 / (rx_ring->itr_val * 256),\n\t\t       rx_ring->itr_register);\n\telse\n\t\twritel(1, rx_ring->itr_register);\n\tivar = E1000_IVAR_INT_ALLOC_VALID | vector;\n\n\t/* Configure Tx vector */\n\ttx_ring->ims_val = E1000_IMS_TXQ0;\n\tvector++;\n\tif (tx_ring->itr_val)\n\t\twritel(1000000000 / (tx_ring->itr_val * 256),\n\t\t       tx_ring->itr_register);\n\telse\n\t\twritel(1, tx_ring->itr_register);\n\tadapter->eiac_mask |= tx_ring->ims_val;\n\tivar |= ((E1000_IVAR_INT_ALLOC_VALID | vector) << 8);\n\n\t/* set vector for Other Causes, e.g. link changes */\n\tvector++;\n\tivar |= ((E1000_IVAR_INT_ALLOC_VALID | vector) << 16);\n\tif (rx_ring->itr_val)\n\t\twritel(1000000000 / (rx_ring->itr_val * 256),\n\t\t       hw->hw_addr + E1000_EITR_82574(vector));\n\telse\n\t\twritel(1, hw->hw_addr + E1000_EITR_82574(vector));\n\n\t/* Cause Tx interrupts on every write back */\n\tivar |= BIT(31);\n\n\tew32(IVAR, ivar);\n\n\t/* enable MSI-X PBA support */\n\tctrl_ext = er32(CTRL_EXT) & ~E1000_CTRL_EXT_IAME;\n\tctrl_ext |= E1000_CTRL_EXT_PBA_CLR | E1000_CTRL_EXT_EIAME;\n\tew32(CTRL_EXT, ctrl_ext);\n\te1e_flush();\n}\n\nvoid e1000e_reset_interrupt_capability(struct e1000_adapter *adapter)\n{\n\tif (adapter->msix_entries) {\n\t\tpci_disable_msix(adapter->pdev);\n\t\tkfree(adapter->msix_entries);\n\t\tadapter->msix_entries = NULL;\n\t} else if (adapter->flags & FLAG_MSI_ENABLED) {\n\t\tpci_disable_msi(adapter->pdev);\n\t\tadapter->flags &= ~FLAG_MSI_ENABLED;\n\t}\n}\n\n/**\n * e1000e_set_interrupt_capability - set MSI or MSI-X if supported\n * @adapter: board private structure\n *\n * Attempt to configure interrupts using the best available\n * capabilities of the hardware and kernel.\n **/\nvoid e1000e_set_interrupt_capability(struct e1000_adapter *adapter)\n{\n\tint err;\n\tint i;\n\n\tswitch (adapter->int_mode) {\n\tcase E1000E_INT_MODE_MSIX:\n\t\tif (adapter->flags & FLAG_HAS_MSIX) {\n\t\t\tadapter->num_vectors = 3; /* RxQ0, TxQ0 and other */\n\t\t\tadapter->msix_entries = kcalloc(adapter->num_vectors,\n\t\t\t\t\t\t\tsizeof(struct\n\t\t\t\t\t\t\t       msix_entry),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (adapter->msix_entries) {\n\t\t\t\tstruct e1000_adapter *a = adapter;\n\n\t\t\t\tfor (i = 0; i < adapter->num_vectors; i++)\n\t\t\t\t\tadapter->msix_entries[i].entry = i;\n\n\t\t\t\terr = pci_enable_msix_range(a->pdev,\n\t\t\t\t\t\t\t    a->msix_entries,\n\t\t\t\t\t\t\t    a->num_vectors,\n\t\t\t\t\t\t\t    a->num_vectors);\n\t\t\t\tif (err > 0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* MSI-X failed, so fall through and try MSI */\n\t\t\te_err(\"Failed to initialize MSI-X interrupts.  Falling back to MSI interrupts.\\n\");\n\t\t\te1000e_reset_interrupt_capability(adapter);\n\t\t}\n\t\tadapter->int_mode = E1000E_INT_MODE_MSI;\n\t\tfallthrough;\n\tcase E1000E_INT_MODE_MSI:\n\t\tif (!pci_enable_msi(adapter->pdev)) {\n\t\t\tadapter->flags |= FLAG_MSI_ENABLED;\n\t\t} else {\n\t\t\tadapter->int_mode = E1000E_INT_MODE_LEGACY;\n\t\t\te_err(\"Failed to initialize MSI interrupts.  Falling back to legacy interrupts.\\n\");\n\t\t}\n\t\tfallthrough;\n\tcase E1000E_INT_MODE_LEGACY:\n\t\t/* Don't do anything; this is the system default */\n\t\tbreak;\n\t}\n\n\t/* store the number of vectors being used */\n\tadapter->num_vectors = 1;\n}\n\n/**\n * e1000_request_msix - Initialize MSI-X interrupts\n * @adapter: board private structure\n *\n * e1000_request_msix allocates MSI-X vectors and requests interrupts from the\n * kernel.\n **/\nstatic int e1000_request_msix(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint err = 0, vector = 0;\n\n\tif (strlen(netdev->name) < (IFNAMSIZ - 5))\n\t\tsnprintf(adapter->rx_ring->name,\n\t\t\t sizeof(adapter->rx_ring->name) - 1,\n\t\t\t \"%.14s-rx-0\", netdev->name);\n\telse\n\t\tmemcpy(adapter->rx_ring->name, netdev->name, IFNAMSIZ);\n\terr = request_irq(adapter->msix_entries[vector].vector,\n\t\t\t  e1000_intr_msix_rx, 0, adapter->rx_ring->name,\n\t\t\t  netdev);\n\tif (err)\n\t\treturn err;\n\tadapter->rx_ring->itr_register = adapter->hw.hw_addr +\n\t    E1000_EITR_82574(vector);\n\tadapter->rx_ring->itr_val = adapter->itr;\n\tvector++;\n\n\tif (strlen(netdev->name) < (IFNAMSIZ - 5))\n\t\tsnprintf(adapter->tx_ring->name,\n\t\t\t sizeof(adapter->tx_ring->name) - 1,\n\t\t\t \"%.14s-tx-0\", netdev->name);\n\telse\n\t\tmemcpy(adapter->tx_ring->name, netdev->name, IFNAMSIZ);\n\terr = request_irq(adapter->msix_entries[vector].vector,\n\t\t\t  e1000_intr_msix_tx, 0, adapter->tx_ring->name,\n\t\t\t  netdev);\n\tif (err)\n\t\treturn err;\n\tadapter->tx_ring->itr_register = adapter->hw.hw_addr +\n\t    E1000_EITR_82574(vector);\n\tadapter->tx_ring->itr_val = adapter->itr;\n\tvector++;\n\n\terr = request_irq(adapter->msix_entries[vector].vector,\n\t\t\t  e1000_msix_other, 0, netdev->name, netdev);\n\tif (err)\n\t\treturn err;\n\n\te1000_configure_msix(adapter);\n\n\treturn 0;\n}\n\n/**\n * e1000_request_irq - initialize interrupts\n * @adapter: board private structure\n *\n * Attempts to configure interrupts using the best available\n * capabilities of the hardware and kernel.\n **/\nstatic int e1000_request_irq(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint err;\n\n\tif (adapter->msix_entries) {\n\t\terr = e1000_request_msix(adapter);\n\t\tif (!err)\n\t\t\treturn err;\n\t\t/* fall back to MSI */\n\t\te1000e_reset_interrupt_capability(adapter);\n\t\tadapter->int_mode = E1000E_INT_MODE_MSI;\n\t\te1000e_set_interrupt_capability(adapter);\n\t}\n\tif (adapter->flags & FLAG_MSI_ENABLED) {\n\t\terr = request_irq(adapter->pdev->irq, e1000_intr_msi, 0,\n\t\t\t\t  netdev->name, netdev);\n\t\tif (!err)\n\t\t\treturn err;\n\n\t\t/* fall back to legacy interrupt */\n\t\te1000e_reset_interrupt_capability(adapter);\n\t\tadapter->int_mode = E1000E_INT_MODE_LEGACY;\n\t}\n\n\terr = request_irq(adapter->pdev->irq, e1000_intr, IRQF_SHARED,\n\t\t\t  netdev->name, netdev);\n\tif (err)\n\t\te_err(\"Unable to allocate interrupt, Error: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void e1000_free_irq(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tif (adapter->msix_entries) {\n\t\tint vector = 0;\n\n\t\tfree_irq(adapter->msix_entries[vector].vector, netdev);\n\t\tvector++;\n\n\t\tfree_irq(adapter->msix_entries[vector].vector, netdev);\n\t\tvector++;\n\n\t\t/* Other Causes interrupt vector */\n\t\tfree_irq(adapter->msix_entries[vector].vector, netdev);\n\t\treturn;\n\t}\n\n\tfree_irq(adapter->pdev->irq, netdev);\n}\n\n/**\n * e1000_irq_disable - Mask off interrupt generation on the NIC\n * @adapter: board private structure\n **/\nstatic void e1000_irq_disable(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tew32(IMC, ~0);\n\tif (adapter->msix_entries)\n\t\tew32(EIAC_82574, 0);\n\te1e_flush();\n\n\tif (adapter->msix_entries) {\n\t\tint i;\n\n\t\tfor (i = 0; i < adapter->num_vectors; i++)\n\t\t\tsynchronize_irq(adapter->msix_entries[i].vector);\n\t} else {\n\t\tsynchronize_irq(adapter->pdev->irq);\n\t}\n}\n\n/**\n * e1000_irq_enable - Enable default interrupt generation settings\n * @adapter: board private structure\n **/\nstatic void e1000_irq_enable(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (adapter->msix_entries) {\n\t\tew32(EIAC_82574, adapter->eiac_mask & E1000_EIAC_MASK_82574);\n\t\tew32(IMS, adapter->eiac_mask | E1000_IMS_OTHER |\n\t\t     IMS_OTHER_MASK);\n\t} else if (hw->mac.type >= e1000_pch_lpt) {\n\t\tew32(IMS, IMS_ENABLE_MASK | E1000_IMS_ECCER);\n\t} else {\n\t\tew32(IMS, IMS_ENABLE_MASK);\n\t}\n\te1e_flush();\n}\n\n/**\n * e1000e_get_hw_control - get control of the h/w from f/w\n * @adapter: address of board private structure\n *\n * e1000e_get_hw_control sets {CTRL_EXT|SWSM}:DRV_LOAD bit.\n * For ASF and Pass Through versions of f/w this means that\n * the driver is loaded. For AMT version (only with 82573)\n * of the f/w this means that the network i/f is open.\n **/\nvoid e1000e_get_hw_control(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl_ext;\n\tu32 swsm;\n\n\t/* Let firmware know the driver has taken over */\n\tif (adapter->flags & FLAG_HAS_SWSM_ON_LOAD) {\n\t\tswsm = er32(SWSM);\n\t\tew32(SWSM, swsm | E1000_SWSM_DRV_LOAD);\n\t} else if (adapter->flags & FLAG_HAS_CTRLEXT_ON_LOAD) {\n\t\tctrl_ext = er32(CTRL_EXT);\n\t\tew32(CTRL_EXT, ctrl_ext | E1000_CTRL_EXT_DRV_LOAD);\n\t}\n}\n\n/**\n * e1000e_release_hw_control - release control of the h/w to f/w\n * @adapter: address of board private structure\n *\n * e1000e_release_hw_control resets {CTRL_EXT|SWSM}:DRV_LOAD bit.\n * For ASF and Pass Through versions of f/w this means that the\n * driver is no longer loaded. For AMT version (only with 82573) i\n * of the f/w this means that the network i/f is closed.\n *\n **/\nvoid e1000e_release_hw_control(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl_ext;\n\tu32 swsm;\n\n\t/* Let firmware taken over control of h/w */\n\tif (adapter->flags & FLAG_HAS_SWSM_ON_LOAD) {\n\t\tswsm = er32(SWSM);\n\t\tew32(SWSM, swsm & ~E1000_SWSM_DRV_LOAD);\n\t} else if (adapter->flags & FLAG_HAS_CTRLEXT_ON_LOAD) {\n\t\tctrl_ext = er32(CTRL_EXT);\n\t\tew32(CTRL_EXT, ctrl_ext & ~E1000_CTRL_EXT_DRV_LOAD);\n\t}\n}\n\n/**\n * e1000_alloc_ring_dma - allocate memory for a ring structure\n * @adapter: board private structure\n * @ring: ring struct for which to allocate dma\n **/\nstatic int e1000_alloc_ring_dma(struct e1000_adapter *adapter,\n\t\t\t\tstruct e1000_ring *ring)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tring->desc = dma_alloc_coherent(&pdev->dev, ring->size, &ring->dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ring->desc)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n/**\n * e1000e_setup_tx_resources - allocate Tx resources (Descriptors)\n * @tx_ring: Tx descriptor ring\n *\n * Return 0 on success, negative on failure\n **/\nint e1000e_setup_tx_resources(struct e1000_ring *tx_ring)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\tint err = -ENOMEM, size;\n\n\tsize = sizeof(struct e1000_buffer) * tx_ring->count;\n\ttx_ring->buffer_info = vzalloc(size);\n\tif (!tx_ring->buffer_info)\n\t\tgoto err;\n\n\t/* round up to nearest 4K */\n\ttx_ring->size = tx_ring->count * sizeof(struct e1000_tx_desc);\n\ttx_ring->size = ALIGN(tx_ring->size, 4096);\n\n\terr = e1000_alloc_ring_dma(adapter, tx_ring);\n\tif (err)\n\t\tgoto err;\n\n\ttx_ring->next_to_use = 0;\n\ttx_ring->next_to_clean = 0;\n\n\treturn 0;\nerr:\n\tvfree(tx_ring->buffer_info);\n\te_err(\"Unable to allocate memory for the transmit descriptor ring\\n\");\n\treturn err;\n}\n\n/**\n * e1000e_setup_rx_resources - allocate Rx resources (Descriptors)\n * @rx_ring: Rx descriptor ring\n *\n * Returns 0 on success, negative on failure\n **/\nint e1000e_setup_rx_resources(struct e1000_ring *rx_ring)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct e1000_buffer *buffer_info;\n\tint i, size, desc_len, err = -ENOMEM;\n\n\tsize = sizeof(struct e1000_buffer) * rx_ring->count;\n\trx_ring->buffer_info = vzalloc(size);\n\tif (!rx_ring->buffer_info)\n\t\tgoto err;\n\n\tfor (i = 0; i < rx_ring->count; i++) {\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t\tbuffer_info->ps_pages = kcalloc(PS_PAGE_BUFFERS,\n\t\t\t\t\t\tsizeof(struct e1000_ps_page),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!buffer_info->ps_pages)\n\t\t\tgoto err_pages;\n\t}\n\n\tdesc_len = sizeof(union e1000_rx_desc_packet_split);\n\n\t/* Round up to nearest 4K */\n\trx_ring->size = rx_ring->count * desc_len;\n\trx_ring->size = ALIGN(rx_ring->size, 4096);\n\n\terr = e1000_alloc_ring_dma(adapter, rx_ring);\n\tif (err)\n\t\tgoto err_pages;\n\n\trx_ring->next_to_clean = 0;\n\trx_ring->next_to_use = 0;\n\trx_ring->rx_skb_top = NULL;\n\n\treturn 0;\n\nerr_pages:\n\tfor (i = 0; i < rx_ring->count; i++) {\n\t\tbuffer_info = &rx_ring->buffer_info[i];\n\t\tkfree(buffer_info->ps_pages);\n\t}\nerr:\n\tvfree(rx_ring->buffer_info);\n\te_err(\"Unable to allocate memory for the receive descriptor ring\\n\");\n\treturn err;\n}\n\n/**\n * e1000_clean_tx_ring - Free Tx Buffers\n * @tx_ring: Tx descriptor ring\n **/\nstatic void e1000_clean_tx_ring(struct e1000_ring *tx_ring)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\tstruct e1000_buffer *buffer_info;\n\tunsigned long size;\n\tunsigned int i;\n\n\tfor (i = 0; i < tx_ring->count; i++) {\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\te1000_put_txbuf(tx_ring, buffer_info, false);\n\t}\n\n\tnetdev_reset_queue(adapter->netdev);\n\tsize = sizeof(struct e1000_buffer) * tx_ring->count;\n\tmemset(tx_ring->buffer_info, 0, size);\n\n\tmemset(tx_ring->desc, 0, tx_ring->size);\n\n\ttx_ring->next_to_use = 0;\n\ttx_ring->next_to_clean = 0;\n}\n\n/**\n * e1000e_free_tx_resources - Free Tx Resources per Queue\n * @tx_ring: Tx descriptor ring\n *\n * Free all transmit software resources\n **/\nvoid e1000e_free_tx_resources(struct e1000_ring *tx_ring)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\te1000_clean_tx_ring(tx_ring);\n\n\tvfree(tx_ring->buffer_info);\n\ttx_ring->buffer_info = NULL;\n\n\tdma_free_coherent(&pdev->dev, tx_ring->size, tx_ring->desc,\n\t\t\t  tx_ring->dma);\n\ttx_ring->desc = NULL;\n}\n\n/**\n * e1000e_free_rx_resources - Free Rx Resources\n * @rx_ring: Rx descriptor ring\n *\n * Free all receive software resources\n **/\nvoid e1000e_free_rx_resources(struct e1000_ring *rx_ring)\n{\n\tstruct e1000_adapter *adapter = rx_ring->adapter;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint i;\n\n\te1000_clean_rx_ring(rx_ring);\n\n\tfor (i = 0; i < rx_ring->count; i++)\n\t\tkfree(rx_ring->buffer_info[i].ps_pages);\n\n\tvfree(rx_ring->buffer_info);\n\trx_ring->buffer_info = NULL;\n\n\tdma_free_coherent(&pdev->dev, rx_ring->size, rx_ring->desc,\n\t\t\t  rx_ring->dma);\n\trx_ring->desc = NULL;\n}\n\n/**\n * e1000_update_itr - update the dynamic ITR value based on statistics\n * @itr_setting: current adapter->itr\n * @packets: the number of packets during this measurement interval\n * @bytes: the number of bytes during this measurement interval\n *\n *      Stores a new ITR value based on packets and byte\n *      counts during the last interrupt.  The advantage of per interrupt\n *      computation is faster updates and more accurate ITR for the current\n *      traffic pattern.  Constants in this function were computed\n *      based on theoretical maximum wire speed and thresholds were set based\n *      on testing data as well as attempting to minimize response time\n *      while increasing bulk throughput.  This functionality is controlled\n *      by the InterruptThrottleRate module parameter.\n **/\nstatic unsigned int e1000_update_itr(u16 itr_setting, int packets, int bytes)\n{\n\tunsigned int retval = itr_setting;\n\n\tif (packets == 0)\n\t\treturn itr_setting;\n\n\tswitch (itr_setting) {\n\tcase lowest_latency:\n\t\t/* handle TSO and jumbo frames */\n\t\tif (bytes / packets > 8000)\n\t\t\tretval = bulk_latency;\n\t\telse if ((packets < 5) && (bytes > 512))\n\t\t\tretval = low_latency;\n\t\tbreak;\n\tcase low_latency:\t/* 50 usec aka 20000 ints/s */\n\t\tif (bytes > 10000) {\n\t\t\t/* this if handles the TSO accounting */\n\t\t\tif (bytes / packets > 8000)\n\t\t\t\tretval = bulk_latency;\n\t\t\telse if ((packets < 10) || ((bytes / packets) > 1200))\n\t\t\t\tretval = bulk_latency;\n\t\t\telse if ((packets > 35))\n\t\t\t\tretval = lowest_latency;\n\t\t} else if (bytes / packets > 2000) {\n\t\t\tretval = bulk_latency;\n\t\t} else if (packets <= 2 && bytes < 512) {\n\t\t\tretval = lowest_latency;\n\t\t}\n\t\tbreak;\n\tcase bulk_latency:\t/* 250 usec aka 4000 ints/s */\n\t\tif (bytes > 25000) {\n\t\t\tif (packets > 35)\n\t\t\t\tretval = low_latency;\n\t\t} else if (bytes < 6000) {\n\t\t\tretval = low_latency;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\nstatic void e1000_set_itr(struct e1000_adapter *adapter)\n{\n\tu16 current_itr;\n\tu32 new_itr = adapter->itr;\n\n\t/* for non-gigabit speeds, just fix the interrupt rate at 4000 */\n\tif (adapter->link_speed != SPEED_1000) {\n\t\tcurrent_itr = 0;\n\t\tnew_itr = 4000;\n\t\tgoto set_itr_now;\n\t}\n\n\tif (adapter->flags2 & FLAG2_DISABLE_AIM) {\n\t\tnew_itr = 0;\n\t\tgoto set_itr_now;\n\t}\n\n\tadapter->tx_itr = e1000_update_itr(adapter->tx_itr,\n\t\t\t\t\t   adapter->total_tx_packets,\n\t\t\t\t\t   adapter->total_tx_bytes);\n\t/* conservative mode (itr 3) eliminates the lowest_latency setting */\n\tif (adapter->itr_setting == 3 && adapter->tx_itr == lowest_latency)\n\t\tadapter->tx_itr = low_latency;\n\n\tadapter->rx_itr = e1000_update_itr(adapter->rx_itr,\n\t\t\t\t\t   adapter->total_rx_packets,\n\t\t\t\t\t   adapter->total_rx_bytes);\n\t/* conservative mode (itr 3) eliminates the lowest_latency setting */\n\tif (adapter->itr_setting == 3 && adapter->rx_itr == lowest_latency)\n\t\tadapter->rx_itr = low_latency;\n\n\tcurrent_itr = max(adapter->rx_itr, adapter->tx_itr);\n\n\t/* counts and packets in update_itr are dependent on these numbers */\n\tswitch (current_itr) {\n\tcase lowest_latency:\n\t\tnew_itr = 70000;\n\t\tbreak;\n\tcase low_latency:\n\t\tnew_itr = 20000;\t/* aka hwitr = ~200 */\n\t\tbreak;\n\tcase bulk_latency:\n\t\tnew_itr = 4000;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nset_itr_now:\n\tif (new_itr != adapter->itr) {\n\t\t/* this attempts to bias the interrupt rate towards Bulk\n\t\t * by adding intermediate steps when interrupt rate is\n\t\t * increasing\n\t\t */\n\t\tnew_itr = new_itr > adapter->itr ?\n\t\t    min(adapter->itr + (new_itr >> 2), new_itr) : new_itr;\n\t\tadapter->itr = new_itr;\n\t\tadapter->rx_ring->itr_val = new_itr;\n\t\tif (adapter->msix_entries)\n\t\t\tadapter->rx_ring->set_itr = 1;\n\t\telse\n\t\t\te1000e_write_itr(adapter, new_itr);\n\t}\n}\n\n/**\n * e1000e_write_itr - write the ITR value to the appropriate registers\n * @adapter: address of board private structure\n * @itr: new ITR value to program\n *\n * e1000e_write_itr determines if the adapter is in MSI-X mode\n * and, if so, writes the EITR registers with the ITR value.\n * Otherwise, it writes the ITR value into the ITR register.\n **/\nvoid e1000e_write_itr(struct e1000_adapter *adapter, u32 itr)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 new_itr = itr ? 1000000000 / (itr * 256) : 0;\n\n\tif (adapter->msix_entries) {\n\t\tint vector;\n\n\t\tfor (vector = 0; vector < adapter->num_vectors; vector++)\n\t\t\twritel(new_itr, hw->hw_addr + E1000_EITR_82574(vector));\n\t} else {\n\t\tew32(ITR, new_itr);\n\t}\n}\n\n/**\n * e1000_alloc_queues - Allocate memory for all rings\n * @adapter: board private structure to initialize\n **/\nstatic int e1000_alloc_queues(struct e1000_adapter *adapter)\n{\n\tint size = sizeof(struct e1000_ring);\n\n\tadapter->tx_ring = kzalloc(size, GFP_KERNEL);\n\tif (!adapter->tx_ring)\n\t\tgoto err;\n\tadapter->tx_ring->count = adapter->tx_ring_count;\n\tadapter->tx_ring->adapter = adapter;\n\n\tadapter->rx_ring = kzalloc(size, GFP_KERNEL);\n\tif (!adapter->rx_ring)\n\t\tgoto err;\n\tadapter->rx_ring->count = adapter->rx_ring_count;\n\tadapter->rx_ring->adapter = adapter;\n\n\treturn 0;\nerr:\n\te_err(\"Unable to allocate memory for queues\\n\");\n\tkfree(adapter->rx_ring);\n\tkfree(adapter->tx_ring);\n\treturn -ENOMEM;\n}\n\n/**\n * e1000e_poll - NAPI Rx polling callback\n * @napi: struct associated with this polling callback\n * @budget: number of packets driver is allowed to process this poll\n **/\nstatic int e1000e_poll(struct napi_struct *napi, int budget)\n{\n\tstruct e1000_adapter *adapter = container_of(napi, struct e1000_adapter,\n\t\t\t\t\t\t     napi);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct net_device *poll_dev = adapter->netdev;\n\tint tx_cleaned = 1, work_done = 0;\n\n\tadapter = netdev_priv(poll_dev);\n\n\tif (!adapter->msix_entries ||\n\t    (adapter->rx_ring->ims_val & adapter->tx_ring->ims_val))\n\t\ttx_cleaned = e1000_clean_tx_irq(adapter->tx_ring);\n\n\tadapter->clean_rx(adapter->rx_ring, &work_done, budget);\n\n\tif (!tx_cleaned || work_done == budget)\n\t\treturn budget;\n\n\t/* Exit the polling mode, but don't re-enable interrupts if stack might\n\t * poll us due to busy-polling\n\t */\n\tif (likely(napi_complete_done(napi, work_done))) {\n\t\tif (adapter->itr_setting & 3)\n\t\t\te1000_set_itr(adapter);\n\t\tif (!test_bit(__E1000_DOWN, &adapter->state)) {\n\t\t\tif (adapter->msix_entries)\n\t\t\t\tew32(IMS, adapter->rx_ring->ims_val);\n\t\t\telse\n\t\t\t\te1000_irq_enable(adapter);\n\t\t}\n\t}\n\n\treturn work_done;\n}\n\nstatic int e1000_vlan_rx_add_vid(struct net_device *netdev,\n\t\t\t\t __always_unused __be16 proto, u16 vid)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 vfta, index;\n\n\t/* don't update vlan cookie if already programmed */\n\tif ((adapter->hw.mng_cookie.status &\n\t     E1000_MNG_DHCP_COOKIE_STATUS_VLAN) &&\n\t    (vid == adapter->mng_vlan_id))\n\t\treturn 0;\n\n\t/* add VID to filter table */\n\tif (adapter->flags & FLAG_HAS_HW_VLAN_FILTER) {\n\t\tindex = (vid >> 5) & 0x7F;\n\t\tvfta = E1000_READ_REG_ARRAY(hw, E1000_VFTA, index);\n\t\tvfta |= BIT((vid & 0x1F));\n\t\thw->mac.ops.write_vfta(hw, index, vfta);\n\t}\n\n\tset_bit(vid, adapter->active_vlans);\n\n\treturn 0;\n}\n\nstatic int e1000_vlan_rx_kill_vid(struct net_device *netdev,\n\t\t\t\t  __always_unused __be16 proto, u16 vid)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 vfta, index;\n\n\tif ((adapter->hw.mng_cookie.status &\n\t     E1000_MNG_DHCP_COOKIE_STATUS_VLAN) &&\n\t    (vid == adapter->mng_vlan_id)) {\n\t\t/* release control to f/w */\n\t\te1000e_release_hw_control(adapter);\n\t\treturn 0;\n\t}\n\n\t/* remove VID from filter table */\n\tif (adapter->flags & FLAG_HAS_HW_VLAN_FILTER) {\n\t\tindex = (vid >> 5) & 0x7F;\n\t\tvfta = E1000_READ_REG_ARRAY(hw, E1000_VFTA, index);\n\t\tvfta &= ~BIT((vid & 0x1F));\n\t\thw->mac.ops.write_vfta(hw, index, vfta);\n\t}\n\n\tclear_bit(vid, adapter->active_vlans);\n\n\treturn 0;\n}\n\n/**\n * e1000e_vlan_filter_disable - helper to disable hw VLAN filtering\n * @adapter: board private structure to initialize\n **/\nstatic void e1000e_vlan_filter_disable(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl;\n\n\tif (adapter->flags & FLAG_HAS_HW_VLAN_FILTER) {\n\t\t/* disable VLAN receive filtering */\n\t\trctl = er32(RCTL);\n\t\trctl &= ~(E1000_RCTL_VFE | E1000_RCTL_CFIEN);\n\t\tew32(RCTL, rctl);\n\n\t\tif (adapter->mng_vlan_id != (u16)E1000_MNG_VLAN_NONE) {\n\t\t\te1000_vlan_rx_kill_vid(netdev, htons(ETH_P_8021Q),\n\t\t\t\t\t       adapter->mng_vlan_id);\n\t\t\tadapter->mng_vlan_id = E1000_MNG_VLAN_NONE;\n\t\t}\n\t}\n}\n\n/**\n * e1000e_vlan_filter_enable - helper to enable HW VLAN filtering\n * @adapter: board private structure to initialize\n **/\nstatic void e1000e_vlan_filter_enable(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl;\n\n\tif (adapter->flags & FLAG_HAS_HW_VLAN_FILTER) {\n\t\t/* enable VLAN receive filtering */\n\t\trctl = er32(RCTL);\n\t\trctl |= E1000_RCTL_VFE;\n\t\trctl &= ~E1000_RCTL_CFIEN;\n\t\tew32(RCTL, rctl);\n\t}\n}\n\n/**\n * e1000e_vlan_strip_disable - helper to disable HW VLAN stripping\n * @adapter: board private structure to initialize\n **/\nstatic void e1000e_vlan_strip_disable(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl;\n\n\t/* disable VLAN tag insert/strip */\n\tctrl = er32(CTRL);\n\tctrl &= ~E1000_CTRL_VME;\n\tew32(CTRL, ctrl);\n}\n\n/**\n * e1000e_vlan_strip_enable - helper to enable HW VLAN stripping\n * @adapter: board private structure to initialize\n **/\nstatic void e1000e_vlan_strip_enable(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl;\n\n\t/* enable VLAN tag insert/strip */\n\tctrl = er32(CTRL);\n\tctrl |= E1000_CTRL_VME;\n\tew32(CTRL, ctrl);\n}\n\nstatic void e1000_update_mng_vlan(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tu16 vid = adapter->hw.mng_cookie.vlan_id;\n\tu16 old_vid = adapter->mng_vlan_id;\n\n\tif (adapter->hw.mng_cookie.status & E1000_MNG_DHCP_COOKIE_STATUS_VLAN) {\n\t\te1000_vlan_rx_add_vid(netdev, htons(ETH_P_8021Q), vid);\n\t\tadapter->mng_vlan_id = vid;\n\t}\n\n\tif ((old_vid != (u16)E1000_MNG_VLAN_NONE) && (vid != old_vid))\n\t\te1000_vlan_rx_kill_vid(netdev, htons(ETH_P_8021Q), old_vid);\n}\n\nstatic void e1000_restore_vlan(struct e1000_adapter *adapter)\n{\n\tu16 vid;\n\n\te1000_vlan_rx_add_vid(adapter->netdev, htons(ETH_P_8021Q), 0);\n\n\tfor_each_set_bit(vid, adapter->active_vlans, VLAN_N_VID)\n\t    e1000_vlan_rx_add_vid(adapter->netdev, htons(ETH_P_8021Q), vid);\n}\n\nstatic void e1000_init_manageability_pt(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 manc, manc2h, mdef, i, j;\n\n\tif (!(adapter->flags & FLAG_MNG_PT_ENABLED))\n\t\treturn;\n\n\tmanc = er32(MANC);\n\n\t/* enable receiving management packets to the host. this will probably\n\t * generate destination unreachable messages from the host OS, but\n\t * the packets will be handled on SMBUS\n\t */\n\tmanc |= E1000_MANC_EN_MNG2HOST;\n\tmanc2h = er32(MANC2H);\n\n\tswitch (hw->mac.type) {\n\tdefault:\n\t\tmanc2h |= (E1000_MANC2H_PORT_623 | E1000_MANC2H_PORT_664);\n\t\tbreak;\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\t/* Check if IPMI pass-through decision filter already exists;\n\t\t * if so, enable it.\n\t\t */\n\t\tfor (i = 0, j = 0; i < 8; i++) {\n\t\t\tmdef = er32(MDEF(i));\n\n\t\t\t/* Ignore filters with anything other than IPMI ports */\n\t\t\tif (mdef & ~(E1000_MDEF_PORT_623 | E1000_MDEF_PORT_664))\n\t\t\t\tcontinue;\n\n\t\t\t/* Enable this decision filter in MANC2H */\n\t\t\tif (mdef)\n\t\t\t\tmanc2h |= BIT(i);\n\n\t\t\tj |= mdef;\n\t\t}\n\n\t\tif (j == (E1000_MDEF_PORT_623 | E1000_MDEF_PORT_664))\n\t\t\tbreak;\n\n\t\t/* Create new decision filter in an empty filter */\n\t\tfor (i = 0, j = 0; i < 8; i++)\n\t\t\tif (er32(MDEF(i)) == 0) {\n\t\t\t\tew32(MDEF(i), (E1000_MDEF_PORT_623 |\n\t\t\t\t\t       E1000_MDEF_PORT_664));\n\t\t\t\tmanc2h |= BIT(1);\n\t\t\t\tj++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!j)\n\t\t\te_warn(\"Unable to create IPMI pass-through filter\\n\");\n\t\tbreak;\n\t}\n\n\tew32(MANC2H, manc2h);\n\tew32(MANC, manc);\n}\n\n/**\n * e1000_configure_tx - Configure Transmit Unit after Reset\n * @adapter: board private structure\n *\n * Configure the Tx unit of the MAC after a reset.\n **/\nstatic void e1000_configure_tx(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_ring *tx_ring = adapter->tx_ring;\n\tu64 tdba;\n\tu32 tdlen, tctl, tarc;\n\n\t/* Setup the HW Tx Head and Tail descriptor pointers */\n\ttdba = tx_ring->dma;\n\ttdlen = tx_ring->count * sizeof(struct e1000_tx_desc);\n\tew32(TDBAL(0), (tdba & DMA_BIT_MASK(32)));\n\tew32(TDBAH(0), (tdba >> 32));\n\tew32(TDLEN(0), tdlen);\n\tew32(TDH(0), 0);\n\tew32(TDT(0), 0);\n\ttx_ring->head = adapter->hw.hw_addr + E1000_TDH(0);\n\ttx_ring->tail = adapter->hw.hw_addr + E1000_TDT(0);\n\n\twritel(0, tx_ring->head);\n\tif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\n\t\te1000e_update_tdt_wa(tx_ring, 0);\n\telse\n\t\twritel(0, tx_ring->tail);\n\n\t/* Set the Tx Interrupt Delay register */\n\tew32(TIDV, adapter->tx_int_delay);\n\t/* Tx irq moderation */\n\tew32(TADV, adapter->tx_abs_int_delay);\n\n\tif (adapter->flags2 & FLAG2_DMA_BURST) {\n\t\tu32 txdctl = er32(TXDCTL(0));\n\n\t\ttxdctl &= ~(E1000_TXDCTL_PTHRESH | E1000_TXDCTL_HTHRESH |\n\t\t\t    E1000_TXDCTL_WTHRESH);\n\t\t/* set up some performance related parameters to encourage the\n\t\t * hardware to use the bus more efficiently in bursts, depends\n\t\t * on the tx_int_delay to be enabled,\n\t\t * wthresh = 1 ==> burst write is disabled to avoid Tx stalls\n\t\t * hthresh = 1 ==> prefetch when one or more available\n\t\t * pthresh = 0x1f ==> prefetch if internal cache 31 or less\n\t\t * BEWARE: this seems to work but should be considered first if\n\t\t * there are Tx hangs or other Tx related bugs\n\t\t */\n\t\ttxdctl |= E1000_TXDCTL_DMA_BURST_ENABLE;\n\t\tew32(TXDCTL(0), txdctl);\n\t}\n\t/* erratum work around: set txdctl the same for both queues */\n\tew32(TXDCTL(1), er32(TXDCTL(0)));\n\n\t/* Program the Transmit Control Register */\n\ttctl = er32(TCTL);\n\ttctl &= ~E1000_TCTL_CT;\n\ttctl |= E1000_TCTL_PSP | E1000_TCTL_RTLC |\n\t\t(E1000_COLLISION_THRESHOLD << E1000_CT_SHIFT);\n\n\tif (adapter->flags & FLAG_TARC_SPEED_MODE_BIT) {\n\t\ttarc = er32(TARC(0));\n\t\t/* set the speed mode bit, we'll clear it if we're not at\n\t\t * gigabit link later\n\t\t */\n#define SPEED_MODE_BIT BIT(21)\n\t\ttarc |= SPEED_MODE_BIT;\n\t\tew32(TARC(0), tarc);\n\t}\n\n\t/* errata: program both queues to unweighted RR */\n\tif (adapter->flags & FLAG_TARC_SET_BIT_ZERO) {\n\t\ttarc = er32(TARC(0));\n\t\ttarc |= 1;\n\t\tew32(TARC(0), tarc);\n\t\ttarc = er32(TARC(1));\n\t\ttarc |= 1;\n\t\tew32(TARC(1), tarc);\n\t}\n\n\t/* Setup Transmit Descriptor Settings for eop descriptor */\n\tadapter->txd_cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_IFCS;\n\n\t/* only set IDE if we are delaying interrupts using the timers */\n\tif (adapter->tx_int_delay)\n\t\tadapter->txd_cmd |= E1000_TXD_CMD_IDE;\n\n\t/* enable Report Status bit */\n\tadapter->txd_cmd |= E1000_TXD_CMD_RS;\n\n\tew32(TCTL, tctl);\n\n\thw->mac.ops.config_collision_dist(hw);\n\n\t/* SPT and KBL Si errata workaround to avoid data corruption */\n\tif (hw->mac.type == e1000_pch_spt) {\n\t\tu32 reg_val;\n\n\t\treg_val = er32(IOSFPC);\n\t\treg_val |= E1000_RCTL_RDMTS_HEX;\n\t\tew32(IOSFPC, reg_val);\n\n\t\treg_val = er32(TARC(0));\n\t\t/* SPT and KBL Si errata workaround to avoid Tx hang.\n\t\t * Dropping the number of outstanding requests from\n\t\t * 3 to 2 in order to avoid a buffer overrun.\n\t\t */\n\t\treg_val &= ~E1000_TARC0_CB_MULTIQ_3_REQ;\n\t\treg_val |= E1000_TARC0_CB_MULTIQ_2_REQ;\n\t\tew32(TARC(0), reg_val);\n\t}\n}\n\n#define PAGE_USE_COUNT(S) (((S) >> PAGE_SHIFT) + \\\n\t\t\t   (((S) & (PAGE_SIZE - 1)) ? 1 : 0))\n\n/**\n * e1000_setup_rctl - configure the receive control registers\n * @adapter: Board private structure\n **/\nstatic void e1000_setup_rctl(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl, rfctl;\n\tu32 pages = 0;\n\n\t/* Workaround Si errata on PCHx - configure jumbo frame flow.\n\t * If jumbo frames not set, program related MAC/PHY registers\n\t * to h/w defaults\n\t */\n\tif (hw->mac.type >= e1000_pch2lan) {\n\t\ts32 ret_val;\n\n\t\tif (adapter->netdev->mtu > ETH_DATA_LEN)\n\t\t\tret_val = e1000_lv_jumbo_workaround_ich8lan(hw, true);\n\t\telse\n\t\t\tret_val = e1000_lv_jumbo_workaround_ich8lan(hw, false);\n\n\t\tif (ret_val)\n\t\t\te_dbg(\"failed to enable|disable jumbo frame workaround mode\\n\");\n\t}\n\n\t/* Program MC offset vector base */\n\trctl = er32(RCTL);\n\trctl &= ~(3 << E1000_RCTL_MO_SHIFT);\n\trctl |= E1000_RCTL_EN | E1000_RCTL_BAM |\n\t    E1000_RCTL_LBM_NO | E1000_RCTL_RDMTS_HALF |\n\t    (adapter->hw.mac.mc_filter_type << E1000_RCTL_MO_SHIFT);\n\n\t/* Do not Store bad packets */\n\trctl &= ~E1000_RCTL_SBP;\n\n\t/* Enable Long Packet receive */\n\tif (adapter->netdev->mtu <= ETH_DATA_LEN)\n\t\trctl &= ~E1000_RCTL_LPE;\n\telse\n\t\trctl |= E1000_RCTL_LPE;\n\n\t/* Some systems expect that the CRC is included in SMBUS traffic. The\n\t * hardware strips the CRC before sending to both SMBUS (BMC) and to\n\t * host memory when this is enabled\n\t */\n\tif (adapter->flags2 & FLAG2_CRC_STRIPPING)\n\t\trctl |= E1000_RCTL_SECRC;\n\n\t/* Workaround Si errata on 82577 PHY - configure IPG for jumbos */\n\tif ((hw->phy.type == e1000_phy_82577) && (rctl & E1000_RCTL_LPE)) {\n\t\tu16 phy_data;\n\n\t\te1e_rphy(hw, PHY_REG(770, 26), &phy_data);\n\t\tphy_data &= 0xfff8;\n\t\tphy_data |= BIT(2);\n\t\te1e_wphy(hw, PHY_REG(770, 26), phy_data);\n\n\t\te1e_rphy(hw, 22, &phy_data);\n\t\tphy_data &= 0x0fff;\n\t\tphy_data |= BIT(14);\n\t\te1e_wphy(hw, 0x10, 0x2823);\n\t\te1e_wphy(hw, 0x11, 0x0003);\n\t\te1e_wphy(hw, 22, phy_data);\n\t}\n\n\t/* Setup buffer sizes */\n\trctl &= ~E1000_RCTL_SZ_4096;\n\trctl |= E1000_RCTL_BSEX;\n\tswitch (adapter->rx_buffer_len) {\n\tcase 2048:\n\tdefault:\n\t\trctl |= E1000_RCTL_SZ_2048;\n\t\trctl &= ~E1000_RCTL_BSEX;\n\t\tbreak;\n\tcase 4096:\n\t\trctl |= E1000_RCTL_SZ_4096;\n\t\tbreak;\n\tcase 8192:\n\t\trctl |= E1000_RCTL_SZ_8192;\n\t\tbreak;\n\tcase 16384:\n\t\trctl |= E1000_RCTL_SZ_16384;\n\t\tbreak;\n\t}\n\n\t/* Enable Extended Status in all Receive Descriptors */\n\trfctl = er32(RFCTL);\n\trfctl |= E1000_RFCTL_EXTEN;\n\tew32(RFCTL, rfctl);\n\n\t/* 82571 and greater support packet-split where the protocol\n\t * header is placed in skb->data and the packet data is\n\t * placed in pages hanging off of skb_shinfo(skb)->nr_frags.\n\t * In the case of a non-split, skb->data is linearly filled,\n\t * followed by the page buffers.  Therefore, skb->data is\n\t * sized to hold the largest protocol header.\n\t *\n\t * allocations using alloc_page take too long for regular MTU\n\t * so only enable packet split for jumbo frames\n\t *\n\t * Using pages when the page size is greater than 16k wastes\n\t * a lot of memory, since we allocate 3 pages at all times\n\t * per packet.\n\t */\n\tpages = PAGE_USE_COUNT(adapter->netdev->mtu);\n\tif ((pages <= 3) && (PAGE_SIZE <= 16384) && (rctl & E1000_RCTL_LPE))\n\t\tadapter->rx_ps_pages = pages;\n\telse\n\t\tadapter->rx_ps_pages = 0;\n\n\tif (adapter->rx_ps_pages) {\n\t\tu32 psrctl = 0;\n\n\t\t/* Enable Packet split descriptors */\n\t\trctl |= E1000_RCTL_DTYP_PS;\n\n\t\tpsrctl |= adapter->rx_ps_bsize0 >> E1000_PSRCTL_BSIZE0_SHIFT;\n\n\t\tswitch (adapter->rx_ps_pages) {\n\t\tcase 3:\n\t\t\tpsrctl |= PAGE_SIZE << E1000_PSRCTL_BSIZE3_SHIFT;\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tpsrctl |= PAGE_SIZE << E1000_PSRCTL_BSIZE2_SHIFT;\n\t\t\tfallthrough;\n\t\tcase 1:\n\t\t\tpsrctl |= PAGE_SIZE >> E1000_PSRCTL_BSIZE1_SHIFT;\n\t\t\tbreak;\n\t\t}\n\n\t\tew32(PSRCTL, psrctl);\n\t}\n\n\t/* This is useful for sniffing bad packets. */\n\tif (adapter->netdev->features & NETIF_F_RXALL) {\n\t\t/* UPE and MPE will be handled by normal PROMISC logic\n\t\t * in e1000e_set_rx_mode\n\t\t */\n\t\trctl |= (E1000_RCTL_SBP |\t/* Receive bad packets */\n\t\t\t E1000_RCTL_BAM |\t/* RX All Bcast Pkts */\n\t\t\t E1000_RCTL_PMCF);\t/* RX All MAC Ctrl Pkts */\n\n\t\trctl &= ~(E1000_RCTL_VFE |\t/* Disable VLAN filter */\n\t\t\t  E1000_RCTL_DPF |\t/* Allow filtered pause */\n\t\t\t  E1000_RCTL_CFIEN);\t/* Dis VLAN CFIEN Filter */\n\t\t/* Do not mess with E1000_CTRL_VME, it affects transmit as well,\n\t\t * and that breaks VLANs.\n\t\t */\n\t}\n\n\tew32(RCTL, rctl);\n\t/* just started the receive unit, no need to restart */\n\tadapter->flags &= ~FLAG_RESTART_NOW;\n}\n\n/**\n * e1000_configure_rx - Configure Receive Unit after Reset\n * @adapter: board private structure\n *\n * Configure the Rx unit of the MAC after a reset.\n **/\nstatic void e1000_configure_rx(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_ring *rx_ring = adapter->rx_ring;\n\tu64 rdba;\n\tu32 rdlen, rctl, rxcsum, ctrl_ext;\n\n\tif (adapter->rx_ps_pages) {\n\t\t/* this is a 32 byte descriptor */\n\t\trdlen = rx_ring->count *\n\t\t    sizeof(union e1000_rx_desc_packet_split);\n\t\tadapter->clean_rx = e1000_clean_rx_irq_ps;\n\t\tadapter->alloc_rx_buf = e1000_alloc_rx_buffers_ps;\n\t} else if (adapter->netdev->mtu > ETH_FRAME_LEN + ETH_FCS_LEN) {\n\t\trdlen = rx_ring->count * sizeof(union e1000_rx_desc_extended);\n\t\tadapter->clean_rx = e1000_clean_jumbo_rx_irq;\n\t\tadapter->alloc_rx_buf = e1000_alloc_jumbo_rx_buffers;\n\t} else {\n\t\trdlen = rx_ring->count * sizeof(union e1000_rx_desc_extended);\n\t\tadapter->clean_rx = e1000_clean_rx_irq;\n\t\tadapter->alloc_rx_buf = e1000_alloc_rx_buffers;\n\t}\n\n\t/* disable receives while setting up the descriptors */\n\trctl = er32(RCTL);\n\tif (!(adapter->flags2 & FLAG2_NO_DISABLE_RX))\n\t\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\te1e_flush();\n\tusleep_range(10000, 11000);\n\n\tif (adapter->flags2 & FLAG2_DMA_BURST) {\n\t\t/* set the writeback threshold (only takes effect if the RDTR\n\t\t * is set). set GRAN=1 and write back up to 0x4 worth, and\n\t\t * enable prefetching of 0x20 Rx descriptors\n\t\t * granularity = 01\n\t\t * wthresh = 04,\n\t\t * hthresh = 04,\n\t\t * pthresh = 0x20\n\t\t */\n\t\tew32(RXDCTL(0), E1000_RXDCTL_DMA_BURST_ENABLE);\n\t\tew32(RXDCTL(1), E1000_RXDCTL_DMA_BURST_ENABLE);\n\t}\n\n\t/* set the Receive Delay Timer Register */\n\tew32(RDTR, adapter->rx_int_delay);\n\n\t/* irq moderation */\n\tew32(RADV, adapter->rx_abs_int_delay);\n\tif ((adapter->itr_setting != 0) && (adapter->itr != 0))\n\t\te1000e_write_itr(adapter, adapter->itr);\n\n\tctrl_ext = er32(CTRL_EXT);\n\t/* Auto-Mask interrupts upon ICR access */\n\tctrl_ext |= E1000_CTRL_EXT_IAME;\n\tew32(IAM, 0xffffffff);\n\tew32(CTRL_EXT, ctrl_ext);\n\te1e_flush();\n\n\t/* Setup the HW Rx Head and Tail Descriptor Pointers and\n\t * the Base and Length of the Rx Descriptor Ring\n\t */\n\trdba = rx_ring->dma;\n\tew32(RDBAL(0), (rdba & DMA_BIT_MASK(32)));\n\tew32(RDBAH(0), (rdba >> 32));\n\tew32(RDLEN(0), rdlen);\n\tew32(RDH(0), 0);\n\tew32(RDT(0), 0);\n\trx_ring->head = adapter->hw.hw_addr + E1000_RDH(0);\n\trx_ring->tail = adapter->hw.hw_addr + E1000_RDT(0);\n\n\twritel(0, rx_ring->head);\n\tif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\n\t\te1000e_update_rdt_wa(rx_ring, 0);\n\telse\n\t\twritel(0, rx_ring->tail);\n\n\t/* Enable Receive Checksum Offload for TCP and UDP */\n\trxcsum = er32(RXCSUM);\n\tif (adapter->netdev->features & NETIF_F_RXCSUM)\n\t\trxcsum |= E1000_RXCSUM_TUOFL;\n\telse\n\t\trxcsum &= ~E1000_RXCSUM_TUOFL;\n\tew32(RXCSUM, rxcsum);\n\n\t/* With jumbo frames, excessive C-state transition latencies result\n\t * in dropped transactions.\n\t */\n\tif (adapter->netdev->mtu > ETH_DATA_LEN) {\n\t\tu32 lat =\n\t\t    ((er32(PBA) & E1000_PBA_RXA_MASK) * 1024 -\n\t\t     adapter->max_frame_size) * 8 / 1000;\n\n\t\tif (adapter->flags & FLAG_IS_ICH) {\n\t\t\tu32 rxdctl = er32(RXDCTL(0));\n\n\t\t\tew32(RXDCTL(0), rxdctl | 0x3 | BIT(8));\n\t\t}\n\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"Some CPU C-states have been disabled in order to enable jumbo frames\\n\");\n\t\tcpu_latency_qos_update_request(&adapter->pm_qos_req, lat);\n\t} else {\n\t\tcpu_latency_qos_update_request(&adapter->pm_qos_req,\n\t\t\t\t\t       PM_QOS_DEFAULT_VALUE);\n\t}\n\n\t/* Enable Receives */\n\tew32(RCTL, rctl);\n}\n\n/**\n * e1000e_write_mc_addr_list - write multicast addresses to MTA\n * @netdev: network interface device structure\n *\n * Writes multicast address list to the MTA hash table.\n * Returns: -ENOMEM on failure\n *                0 on no addresses written\n *                X on writing X addresses to MTA\n */\nstatic int e1000e_write_mc_addr_list(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct netdev_hw_addr *ha;\n\tu8 *mta_list;\n\tint i;\n\n\tif (netdev_mc_empty(netdev)) {\n\t\t/* nothing to program, so clear mc list */\n\t\thw->mac.ops.update_mc_addr_list(hw, NULL, 0);\n\t\treturn 0;\n\t}\n\n\tmta_list = kcalloc(netdev_mc_count(netdev), ETH_ALEN, GFP_ATOMIC);\n\tif (!mta_list)\n\t\treturn -ENOMEM;\n\n\t/* update_mc_addr_list expects a packed array of only addresses. */\n\ti = 0;\n\tnetdev_for_each_mc_addr(ha, netdev)\n\t    memcpy(mta_list + (i++ * ETH_ALEN), ha->addr, ETH_ALEN);\n\n\thw->mac.ops.update_mc_addr_list(hw, mta_list, i);\n\tkfree(mta_list);\n\n\treturn netdev_mc_count(netdev);\n}\n\n/**\n * e1000e_write_uc_addr_list - write unicast addresses to RAR table\n * @netdev: network interface device structure\n *\n * Writes unicast address list to the RAR table.\n * Returns: -ENOMEM on failure/insufficient address space\n *                0 on no addresses written\n *                X on writing X addresses to the RAR table\n **/\nstatic int e1000e_write_uc_addr_list(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunsigned int rar_entries;\n\tint count = 0;\n\n\trar_entries = hw->mac.ops.rar_get_count(hw);\n\n\t/* save a rar entry for our hardware address */\n\trar_entries--;\n\n\t/* save a rar entry for the LAA workaround */\n\tif (adapter->flags & FLAG_RESET_OVERWRITES_LAA)\n\t\trar_entries--;\n\n\t/* return ENOMEM indicating insufficient memory for addresses */\n\tif (netdev_uc_count(netdev) > rar_entries)\n\t\treturn -ENOMEM;\n\n\tif (!netdev_uc_empty(netdev) && rar_entries) {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\t/* write the addresses in reverse order to avoid write\n\t\t * combining\n\t\t */\n\t\tnetdev_for_each_uc_addr(ha, netdev) {\n\t\t\tint ret_val;\n\n\t\t\tif (!rar_entries)\n\t\t\t\tbreak;\n\t\t\tret_val = hw->mac.ops.rar_set(hw, ha->addr, rar_entries--);\n\t\t\tif (ret_val < 0)\n\t\t\t\treturn -ENOMEM;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\t/* zero out the remaining RAR entries not used above */\n\tfor (; rar_entries > 0; rar_entries--) {\n\t\tew32(RAH(rar_entries), 0);\n\t\tew32(RAL(rar_entries), 0);\n\t}\n\te1e_flush();\n\n\treturn count;\n}\n\n/**\n * e1000e_set_rx_mode - secondary unicast, Multicast and Promiscuous mode set\n * @netdev: network interface device structure\n *\n * The ndo_set_rx_mode entry point is called whenever the unicast or multicast\n * address list or the network interface flags are updated.  This routine is\n * responsible for configuring the hardware for proper unicast, multicast,\n * promiscuous mode, and all-multi behavior.\n **/\nstatic void e1000e_set_rx_mode(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 rctl;\n\n\tif (pm_runtime_suspended(netdev->dev.parent))\n\t\treturn;\n\n\t/* Check for Promiscuous and All Multicast modes */\n\trctl = er32(RCTL);\n\n\t/* clear the affected bits */\n\trctl &= ~(E1000_RCTL_UPE | E1000_RCTL_MPE);\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\trctl |= (E1000_RCTL_UPE | E1000_RCTL_MPE);\n\t\t/* Do not hardware filter VLANs in promisc mode */\n\t\te1000e_vlan_filter_disable(adapter);\n\t} else {\n\t\tint count;\n\n\t\tif (netdev->flags & IFF_ALLMULTI) {\n\t\t\trctl |= E1000_RCTL_MPE;\n\t\t} else {\n\t\t\t/* Write addresses to the MTA, if the attempt fails\n\t\t\t * then we should just turn on promiscuous mode so\n\t\t\t * that we can at least receive multicast traffic\n\t\t\t */\n\t\t\tcount = e1000e_write_mc_addr_list(netdev);\n\t\t\tif (count < 0)\n\t\t\t\trctl |= E1000_RCTL_MPE;\n\t\t}\n\t\te1000e_vlan_filter_enable(adapter);\n\t\t/* Write addresses to available RAR registers, if there is not\n\t\t * sufficient space to store all the addresses then enable\n\t\t * unicast promiscuous mode\n\t\t */\n\t\tcount = e1000e_write_uc_addr_list(netdev);\n\t\tif (count < 0)\n\t\t\trctl |= E1000_RCTL_UPE;\n\t}\n\n\tew32(RCTL, rctl);\n\n\tif (netdev->features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\te1000e_vlan_strip_enable(adapter);\n\telse\n\t\te1000e_vlan_strip_disable(adapter);\n}\n\nstatic void e1000e_setup_rss_hash(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 mrqc, rxcsum;\n\tu32 rss_key[10];\n\tint i;\n\n\tnetdev_rss_key_fill(rss_key, sizeof(rss_key));\n\tfor (i = 0; i < 10; i++)\n\t\tew32(RSSRK(i), rss_key[i]);\n\n\t/* Direct all traffic to queue 0 */\n\tfor (i = 0; i < 32; i++)\n\t\tew32(RETA(i), 0);\n\n\t/* Disable raw packet checksumming so that RSS hash is placed in\n\t * descriptor on writeback.\n\t */\n\trxcsum = er32(RXCSUM);\n\trxcsum |= E1000_RXCSUM_PCSD;\n\n\tew32(RXCSUM, rxcsum);\n\n\tmrqc = (E1000_MRQC_RSS_FIELD_IPV4 |\n\t\tE1000_MRQC_RSS_FIELD_IPV4_TCP |\n\t\tE1000_MRQC_RSS_FIELD_IPV6 |\n\t\tE1000_MRQC_RSS_FIELD_IPV6_TCP |\n\t\tE1000_MRQC_RSS_FIELD_IPV6_TCP_EX);\n\n\tew32(MRQC, mrqc);\n}\n\n/**\n * e1000e_get_base_timinca - get default SYSTIM time increment attributes\n * @adapter: board private structure\n * @timinca: pointer to returned time increment attributes\n *\n * Get attributes for incrementing the System Time Register SYSTIML/H at\n * the default base frequency, and set the cyclecounter shift value.\n **/\ns32 e1000e_get_base_timinca(struct e1000_adapter *adapter, u32 *timinca)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 incvalue, incperiod, shift;\n\n\t/* Make sure clock is enabled on I217/I218/I219  before checking\n\t * the frequency\n\t */\n\tif ((hw->mac.type >= e1000_pch_lpt) &&\n\t    !(er32(TSYNCTXCTL) & E1000_TSYNCTXCTL_ENABLED) &&\n\t    !(er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_ENABLED)) {\n\t\tu32 fextnvm7 = er32(FEXTNVM7);\n\n\t\tif (!(fextnvm7 & BIT(0))) {\n\t\t\tew32(FEXTNVM7, fextnvm7 | BIT(0));\n\t\t\te1e_flush();\n\t\t}\n\t}\n\n\tswitch (hw->mac.type) {\n\tcase e1000_pch2lan:\n\t\t/* Stable 96MHz frequency */\n\t\tincperiod = INCPERIOD_96MHZ;\n\t\tincvalue = INCVALUE_96MHZ;\n\t\tshift = INCVALUE_SHIFT_96MHZ;\n\t\tadapter->cc.shift = shift + INCPERIOD_SHIFT_96MHZ;\n\t\tbreak;\n\tcase e1000_pch_lpt:\n\t\tif (er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_SYSCFI) {\n\t\t\t/* Stable 96MHz frequency */\n\t\t\tincperiod = INCPERIOD_96MHZ;\n\t\t\tincvalue = INCVALUE_96MHZ;\n\t\t\tshift = INCVALUE_SHIFT_96MHZ;\n\t\t\tadapter->cc.shift = shift + INCPERIOD_SHIFT_96MHZ;\n\t\t} else {\n\t\t\t/* Stable 25MHz frequency */\n\t\t\tincperiod = INCPERIOD_25MHZ;\n\t\t\tincvalue = INCVALUE_25MHZ;\n\t\t\tshift = INCVALUE_SHIFT_25MHZ;\n\t\t\tadapter->cc.shift = shift;\n\t\t}\n\t\tbreak;\n\tcase e1000_pch_spt:\n\t\t/* Stable 24MHz frequency */\n\t\tincperiod = INCPERIOD_24MHZ;\n\t\tincvalue = INCVALUE_24MHZ;\n\t\tshift = INCVALUE_SHIFT_24MHZ;\n\t\tadapter->cc.shift = shift;\n\t\tbreak;\n\tcase e1000_pch_cnp:\n\tcase e1000_pch_tgp:\n\tcase e1000_pch_adp:\n\tcase e1000_pch_mtp:\n\t\tif (er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_SYSCFI) {\n\t\t\t/* Stable 24MHz frequency */\n\t\t\tincperiod = INCPERIOD_24MHZ;\n\t\t\tincvalue = INCVALUE_24MHZ;\n\t\t\tshift = INCVALUE_SHIFT_24MHZ;\n\t\t\tadapter->cc.shift = shift;\n\t\t} else {\n\t\t\t/* Stable 38400KHz frequency */\n\t\t\tincperiod = INCPERIOD_38400KHZ;\n\t\t\tincvalue = INCVALUE_38400KHZ;\n\t\t\tshift = INCVALUE_SHIFT_38400KHZ;\n\t\t\tadapter->cc.shift = shift;\n\t\t}\n\t\tbreak;\n\tcase e1000_82574:\n\tcase e1000_82583:\n\t\t/* Stable 25MHz frequency */\n\t\tincperiod = INCPERIOD_25MHZ;\n\t\tincvalue = INCVALUE_25MHZ;\n\t\tshift = INCVALUE_SHIFT_25MHZ;\n\t\tadapter->cc.shift = shift;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*timinca = ((incperiod << E1000_TIMINCA_INCPERIOD_SHIFT) |\n\t\t    ((incvalue << shift) & E1000_TIMINCA_INCVALUE_MASK));\n\n\treturn 0;\n}\n\n/**\n * e1000e_config_hwtstamp - configure the hwtstamp registers and enable/disable\n * @adapter: board private structure\n * @config: timestamp configuration\n *\n * Outgoing time stamping can be enabled and disabled. Play nice and\n * disable it when requested, although it shouldn't cause any overhead\n * when no packet needs it. At most one packet in the queue may be\n * marked for time stamping, otherwise it would be impossible to tell\n * for sure to which packet the hardware time stamp belongs.\n *\n * Incoming time stamping has to be configured via the hardware filters.\n * Not all combinations are supported, in particular event type has to be\n * specified. Matching the kind of event packet is not supported, with the\n * exception of \"all V2 events regardless of level 2 or 4\".\n **/\nstatic int e1000e_config_hwtstamp(struct e1000_adapter *adapter,\n\t\t\t\t  struct hwtstamp_config *config)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 tsync_tx_ctl = E1000_TSYNCTXCTL_ENABLED;\n\tu32 tsync_rx_ctl = E1000_TSYNCRXCTL_ENABLED;\n\tu32 rxmtrl = 0;\n\tu16 rxudp = 0;\n\tbool is_l4 = false;\n\tbool is_l2 = false;\n\tu32 regval;\n\n\tif (!(adapter->flags & FLAG_HAS_HW_TIMESTAMP))\n\t\treturn -EINVAL;\n\n\t/* flags reserved for future extensions - must be zero */\n\tif (config->flags)\n\t\treturn -EINVAL;\n\n\tswitch (config->tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\ttsync_tx_ctl = 0;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (config->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\ttsync_rx_ctl = 0;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L4_V1;\n\t\trxmtrl = E1000_RXMTRL_PTP_V1_SYNC_MESSAGE;\n\t\tis_l4 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L4_V1;\n\t\trxmtrl = E1000_RXMTRL_PTP_V1_DELAY_REQ_MESSAGE;\n\t\tis_l4 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\t\t/* Also time stamps V2 L2 Path Delay Request/Response */\n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L2_V2;\n\t\trxmtrl = E1000_RXMTRL_PTP_V2_SYNC_MESSAGE;\n\t\tis_l2 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\t\t/* Also time stamps V2 L2 Path Delay Request/Response. */\n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L2_V2;\n\t\trxmtrl = E1000_RXMTRL_PTP_V2_DELAY_REQ_MESSAGE;\n\t\tis_l2 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\t\t/* Hardware cannot filter just V2 L4 Sync messages */\n\t\tfallthrough;\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\t\t/* Also time stamps V2 Path Delay Request/Response. */\n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L2_L4_V2;\n\t\trxmtrl = E1000_RXMTRL_PTP_V2_SYNC_MESSAGE;\n\t\tis_l2 = true;\n\t\tis_l4 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\t/* Hardware cannot filter just V2 L4 Delay Request messages */\n\t\tfallthrough;\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\t/* Also time stamps V2 Path Delay Request/Response. */\n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L2_L4_V2;\n\t\trxmtrl = E1000_RXMTRL_PTP_V2_DELAY_REQ_MESSAGE;\n\t\tis_l2 = true;\n\t\tis_l4 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\t\t/* Hardware cannot filter just V2 L4 or L2 Event messages */\n\t\tfallthrough;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_EVENT_V2;\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\tis_l2 = true;\n\t\tis_l4 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\t\t/* For V1, the hardware can only filter Sync messages or\n\t\t * Delay Request messages but not both so fall-through to\n\t\t * time stamp all packets.\n\t\t */\n\t\tfallthrough;\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\tcase HWTSTAMP_FILTER_ALL:\n\t\tis_l2 = true;\n\t\tis_l4 = true;\n\t\ttsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_ALL;\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_ALL;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tadapter->hwtstamp_config = *config;\n\n\t/* enable/disable Tx h/w time stamping */\n\tregval = er32(TSYNCTXCTL);\n\tregval &= ~E1000_TSYNCTXCTL_ENABLED;\n\tregval |= tsync_tx_ctl;\n\tew32(TSYNCTXCTL, regval);\n\tif ((er32(TSYNCTXCTL) & E1000_TSYNCTXCTL_ENABLED) !=\n\t    (regval & E1000_TSYNCTXCTL_ENABLED)) {\n\t\te_err(\"Timesync Tx Control register not set as expected\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\t/* enable/disable Rx h/w time stamping */\n\tregval = er32(TSYNCRXCTL);\n\tregval &= ~(E1000_TSYNCRXCTL_ENABLED | E1000_TSYNCRXCTL_TYPE_MASK);\n\tregval |= tsync_rx_ctl;\n\tew32(TSYNCRXCTL, regval);\n\tif ((er32(TSYNCRXCTL) & (E1000_TSYNCRXCTL_ENABLED |\n\t\t\t\t E1000_TSYNCRXCTL_TYPE_MASK)) !=\n\t    (regval & (E1000_TSYNCRXCTL_ENABLED |\n\t\t       E1000_TSYNCRXCTL_TYPE_MASK))) {\n\t\te_err(\"Timesync Rx Control register not set as expected\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\t/* L2: define ethertype filter for time stamped packets */\n\tif (is_l2)\n\t\trxmtrl |= ETH_P_1588;\n\n\t/* define which PTP packets get time stamped */\n\tew32(RXMTRL, rxmtrl);\n\n\t/* Filter by destination port */\n\tif (is_l4) {\n\t\trxudp = PTP_EV_PORT;\n\t\tcpu_to_be16s(&rxudp);\n\t}\n\tew32(RXUDP, rxudp);\n\n\te1e_flush();\n\n\t/* Clear TSYNCRXCTL_VALID & TSYNCTXCTL_VALID bit */\n\ter32(RXSTMPH);\n\ter32(TXSTMPH);\n\n\treturn 0;\n}\n\n/**\n * e1000_configure - configure the hardware for Rx and Tx\n * @adapter: private board structure\n **/\nstatic void e1000_configure(struct e1000_adapter *adapter)\n{\n\tstruct e1000_ring *rx_ring = adapter->rx_ring;\n\n\te1000e_set_rx_mode(adapter->netdev);\n\n\te1000_restore_vlan(adapter);\n\te1000_init_manageability_pt(adapter);\n\n\te1000_configure_tx(adapter);\n\n\tif (adapter->netdev->features & NETIF_F_RXHASH)\n\t\te1000e_setup_rss_hash(adapter);\n\te1000_setup_rctl(adapter);\n\te1000_configure_rx(adapter);\n\tadapter->alloc_rx_buf(rx_ring, e1000_desc_unused(rx_ring), GFP_KERNEL);\n}\n\n/**\n * e1000e_power_up_phy - restore link in case the phy was powered down\n * @adapter: address of board private structure\n *\n * The phy may be powered down to save power and turn off link when the\n * driver is unloaded and wake on lan is not enabled (among others)\n * *** this routine MUST be followed by a call to e1000e_reset ***\n **/\nvoid e1000e_power_up_phy(struct e1000_adapter *adapter)\n{\n\tif (adapter->hw.phy.ops.power_up)\n\t\tadapter->hw.phy.ops.power_up(&adapter->hw);\n\n\tadapter->hw.mac.ops.setup_link(&adapter->hw);\n}\n\n/**\n * e1000_power_down_phy - Power down the PHY\n * @adapter: board private structure\n *\n * Power down the PHY so no link is implied when interface is down.\n * The PHY cannot be powered down if management or WoL is active.\n */\nstatic void e1000_power_down_phy(struct e1000_adapter *adapter)\n{\n\tif (adapter->hw.phy.ops.power_down)\n\t\tadapter->hw.phy.ops.power_down(&adapter->hw);\n}\n\n/**\n * e1000_flush_tx_ring - remove all descriptors from the tx_ring\n * @adapter: board private structure\n *\n * We want to clear all pending descriptors from the TX ring.\n * zeroing happens when the HW reads the regs. We  assign the ring itself as\n * the data of the next descriptor. We don't care about the data we are about\n * to reset the HW.\n */\nstatic void e1000_flush_tx_ring(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_ring *tx_ring = adapter->tx_ring;\n\tstruct e1000_tx_desc *tx_desc = NULL;\n\tu32 tdt, tctl, txd_lower = E1000_TXD_CMD_IFCS;\n\tu16 size = 512;\n\n\ttctl = er32(TCTL);\n\tew32(TCTL, tctl | E1000_TCTL_EN);\n\ttdt = er32(TDT(0));\n\tBUG_ON(tdt != tx_ring->next_to_use);\n\ttx_desc =  E1000_TX_DESC(*tx_ring, tx_ring->next_to_use);\n\ttx_desc->buffer_addr = cpu_to_le64(tx_ring->dma);\n\n\ttx_desc->lower.data = cpu_to_le32(txd_lower | size);\n\ttx_desc->upper.data = 0;\n\t/* flush descriptors to memory before notifying the HW */\n\twmb();\n\ttx_ring->next_to_use++;\n\tif (tx_ring->next_to_use == tx_ring->count)\n\t\ttx_ring->next_to_use = 0;\n\tew32(TDT(0), tx_ring->next_to_use);\n\tusleep_range(200, 250);\n}\n\n/**\n * e1000_flush_rx_ring - remove all descriptors from the rx_ring\n * @adapter: board private structure\n *\n * Mark all descriptors in the RX ring as consumed and disable the rx ring\n */\nstatic void e1000_flush_rx_ring(struct e1000_adapter *adapter)\n{\n\tu32 rctl, rxdctl;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\trctl = er32(RCTL);\n\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\te1e_flush();\n\tusleep_range(100, 150);\n\n\trxdctl = er32(RXDCTL(0));\n\t/* zero the lower 14 bits (prefetch and host thresholds) */\n\trxdctl &= 0xffffc000;\n\n\t/* update thresholds: prefetch threshold to 31, host threshold to 1\n\t * and make sure the granularity is \"descriptors\" and not \"cache lines\"\n\t */\n\trxdctl |= (0x1F | BIT(8) | E1000_RXDCTL_THRESH_UNIT_DESC);\n\n\tew32(RXDCTL(0), rxdctl);\n\t/* momentarily enable the RX ring for the changes to take effect */\n\tew32(RCTL, rctl | E1000_RCTL_EN);\n\te1e_flush();\n\tusleep_range(100, 150);\n\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n}\n\n/**\n * e1000_flush_desc_rings - remove all descriptors from the descriptor rings\n * @adapter: board private structure\n *\n * In i219, the descriptor rings must be emptied before resetting the HW\n * or before changing the device state to D3 during runtime (runtime PM).\n *\n * Failure to do this will cause the HW to enter a unit hang state which can\n * only be released by PCI reset on the device\n *\n */\n\nstatic void e1000_flush_desc_rings(struct e1000_adapter *adapter)\n{\n\tu16 hang_state;\n\tu32 fext_nvm11, tdlen;\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t/* First, disable MULR fix in FEXTNVM11 */\n\tfext_nvm11 = er32(FEXTNVM11);\n\tfext_nvm11 |= E1000_FEXTNVM11_DISABLE_MULR_FIX;\n\tew32(FEXTNVM11, fext_nvm11);\n\t/* do nothing if we're not in faulty state, or if the queue is empty */\n\ttdlen = er32(TDLEN(0));\n\tpci_read_config_word(adapter->pdev, PCICFG_DESC_RING_STATUS,\n\t\t\t     &hang_state);\n\tif (!(hang_state & FLUSH_DESC_REQUIRED) || !tdlen)\n\t\treturn;\n\te1000_flush_tx_ring(adapter);\n\t/* recheck, maybe the fault is caused by the rx ring */\n\tpci_read_config_word(adapter->pdev, PCICFG_DESC_RING_STATUS,\n\t\t\t     &hang_state);\n\tif (hang_state & FLUSH_DESC_REQUIRED)\n\t\te1000_flush_rx_ring(adapter);\n}\n\n/**\n * e1000e_systim_reset - reset the timesync registers after a hardware reset\n * @adapter: board private structure\n *\n * When the MAC is reset, all hardware bits for timesync will be reset to the\n * default values. This function will restore the settings last in place.\n * Since the clock SYSTIME registers are reset, we will simply restore the\n * cyclecounter to the kernel real clock time.\n **/\nstatic void e1000e_systim_reset(struct e1000_adapter *adapter)\n{\n\tstruct ptp_clock_info *info = &adapter->ptp_clock_info;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunsigned long flags;\n\tu32 timinca;\n\ts32 ret_val;\n\n\tif (!(adapter->flags & FLAG_HAS_HW_TIMESTAMP))\n\t\treturn;\n\n\tif (info->adjfreq) {\n\t\t/* restore the previous ptp frequency delta */\n\t\tret_val = info->adjfreq(info, adapter->ptp_delta);\n\t} else {\n\t\t/* set the default base frequency if no adjustment possible */\n\t\tret_val = e1000e_get_base_timinca(adapter, &timinca);\n\t\tif (!ret_val)\n\t\t\tew32(TIMINCA, timinca);\n\t}\n\n\tif (ret_val) {\n\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t \"Failed to restore TIMINCA clock rate delta: %d\\n\",\n\t\t\t ret_val);\n\t\treturn;\n\t}\n\n\t/* reset the systim ns time counter */\n\tspin_lock_irqsave(&adapter->systim_lock, flags);\n\ttimecounter_init(&adapter->tc, &adapter->cc,\n\t\t\t ktime_to_ns(ktime_get_real()));\n\tspin_unlock_irqrestore(&adapter->systim_lock, flags);\n\n\t/* restore the previous hwtstamp configuration settings */\n\te1000e_config_hwtstamp(adapter, &adapter->hwtstamp_config);\n}\n\n/**\n * e1000e_reset - bring the hardware into a known good state\n * @adapter: board private structure\n *\n * This function boots the hardware and enables some settings that\n * require a configuration cycle of the hardware - those cannot be\n * set/changed during runtime. After reset the device needs to be\n * properly configured for Rx, Tx etc.\n */\nvoid e1000e_reset(struct e1000_adapter *adapter)\n{\n\tstruct e1000_mac_info *mac = &adapter->hw.mac;\n\tstruct e1000_fc_info *fc = &adapter->hw.fc;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 tx_space, min_tx_space, min_rx_space;\n\tu32 pba = adapter->pba;\n\tu16 hwm;\n\n\t/* reset Packet Buffer Allocation to default */\n\tew32(PBA, pba);\n\n\tif (adapter->max_frame_size > (VLAN_ETH_FRAME_LEN + ETH_FCS_LEN)) {\n\t\t/* To maintain wire speed transmits, the Tx FIFO should be\n\t\t * large enough to accommodate two full transmit packets,\n\t\t * rounded up to the next 1KB and expressed in KB.  Likewise,\n\t\t * the Rx FIFO should be large enough to accommodate at least\n\t\t * one full receive packet and is similarly rounded up and\n\t\t * expressed in KB.\n\t\t */\n\t\tpba = er32(PBA);\n\t\t/* upper 16 bits has Tx packet buffer allocation size in KB */\n\t\ttx_space = pba >> 16;\n\t\t/* lower 16 bits has Rx packet buffer allocation size in KB */\n\t\tpba &= 0xffff;\n\t\t/* the Tx fifo also stores 16 bytes of information about the Tx\n\t\t * but don't include ethernet FCS because hardware appends it\n\t\t */\n\t\tmin_tx_space = (adapter->max_frame_size +\n\t\t\t\tsizeof(struct e1000_tx_desc) - ETH_FCS_LEN) * 2;\n\t\tmin_tx_space = ALIGN(min_tx_space, 1024);\n\t\tmin_tx_space >>= 10;\n\t\t/* software strips receive CRC, so leave room for it */\n\t\tmin_rx_space = adapter->max_frame_size;\n\t\tmin_rx_space = ALIGN(min_rx_space, 1024);\n\t\tmin_rx_space >>= 10;\n\n\t\t/* If current Tx allocation is less than the min Tx FIFO size,\n\t\t * and the min Tx FIFO size is less than the current Rx FIFO\n\t\t * allocation, take space away from current Rx allocation\n\t\t */\n\t\tif ((tx_space < min_tx_space) &&\n\t\t    ((min_tx_space - tx_space) < pba)) {\n\t\t\tpba -= min_tx_space - tx_space;\n\n\t\t\t/* if short on Rx space, Rx wins and must trump Tx\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tif (pba < min_rx_space)\n\t\t\t\tpba = min_rx_space;\n\t\t}\n\n\t\tew32(PBA, pba);\n\t}\n\n\t/* flow control settings\n\t *\n\t * The high water mark must be low enough to fit one full frame\n\t * (or the size used for early receive) above it in the Rx FIFO.\n\t * Set it to the lower of:\n\t * - 90% of the Rx FIFO size, and\n\t * - the full Rx FIFO size minus one full frame\n\t */\n\tif (adapter->flags & FLAG_DISABLE_FC_PAUSE_TIME)\n\t\tfc->pause_time = 0xFFFF;\n\telse\n\t\tfc->pause_time = E1000_FC_PAUSE_TIME;\n\tfc->send_xon = true;\n\tfc->current_mode = fc->requested_mode;\n\n\tswitch (hw->mac.type) {\n\tcase e1000_ich9lan:\n\tcase e1000_ich10lan:\n\t\tif (adapter->netdev->mtu > ETH_DATA_LEN) {\n\t\t\tpba = 14;\n\t\t\tew32(PBA, pba);\n\t\t\tfc->high_water = 0x2800;\n\t\t\tfc->low_water = fc->high_water - 8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\thwm = min(((pba << 10) * 9 / 10),\n\t\t\t  ((pba << 10) - adapter->max_frame_size));\n\n\t\tfc->high_water = hwm & E1000_FCRTH_RTH;\t/* 8-byte granularity */\n\t\tfc->low_water = fc->high_water - 8;\n\t\tbreak;\n\tcase e1000_pchlan:\n\t\t/* Workaround PCH LOM adapter hangs with certain network\n\t\t * loads.  If hangs persist, try disabling Tx flow control.\n\t\t */\n\t\tif (adapter->netdev->mtu > ETH_DATA_LEN) {\n\t\t\tfc->high_water = 0x3500;\n\t\t\tfc->low_water = 0x1500;\n\t\t} else {\n\t\t\tfc->high_water = 0x5000;\n\t\t\tfc->low_water = 0x3000;\n\t\t}\n\t\tfc->refresh_time = 0x1000;\n\t\tbreak;\n\tcase e1000_pch2lan:\n\tcase e1000_pch_lpt:\n\tcase e1000_pch_spt:\n\tcase e1000_pch_cnp:\n\tcase e1000_pch_tgp:\n\tcase e1000_pch_adp:\n\tcase e1000_pch_mtp:\n\t\tfc->refresh_time = 0xFFFF;\n\t\tfc->pause_time = 0xFFFF;\n\n\t\tif (adapter->netdev->mtu <= ETH_DATA_LEN) {\n\t\t\tfc->high_water = 0x05C20;\n\t\t\tfc->low_water = 0x05048;\n\t\t\tbreak;\n\t\t}\n\n\t\tpba = 14;\n\t\tew32(PBA, pba);\n\t\tfc->high_water = ((pba << 10) * 9 / 10) & E1000_FCRTH_RTH;\n\t\tfc->low_water = ((pba << 10) * 8 / 10) & E1000_FCRTL_RTL;\n\t\tbreak;\n\t}\n\n\t/* Alignment of Tx data is on an arbitrary byte boundary with the\n\t * maximum size per Tx descriptor limited only to the transmit\n\t * allocation of the packet buffer minus 96 bytes with an upper\n\t * limit of 24KB due to receive synchronization limitations.\n\t */\n\tadapter->tx_fifo_limit = min_t(u32, ((er32(PBA) >> 16) << 10) - 96,\n\t\t\t\t       24 << 10);\n\n\t/* Disable Adaptive Interrupt Moderation if 2 full packets cannot\n\t * fit in receive buffer.\n\t */\n\tif (adapter->itr_setting & 0x3) {\n\t\tif ((adapter->max_frame_size * 2) > (pba << 10)) {\n\t\t\tif (!(adapter->flags2 & FLAG2_DISABLE_AIM)) {\n\t\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t\t \"Interrupt Throttle Rate off\\n\");\n\t\t\t\tadapter->flags2 |= FLAG2_DISABLE_AIM;\n\t\t\t\te1000e_write_itr(adapter, 0);\n\t\t\t}\n\t\t} else if (adapter->flags2 & FLAG2_DISABLE_AIM) {\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"Interrupt Throttle Rate on\\n\");\n\t\t\tadapter->flags2 &= ~FLAG2_DISABLE_AIM;\n\t\t\tadapter->itr = 20000;\n\t\t\te1000e_write_itr(adapter, adapter->itr);\n\t\t}\n\t}\n\n\tif (hw->mac.type >= e1000_pch_spt)\n\t\te1000_flush_desc_rings(adapter);\n\t/* Allow time for pending master requests to run */\n\tmac->ops.reset_hw(hw);\n\n\t/* For parts with AMT enabled, let the firmware know\n\t * that the network interface is in control\n\t */\n\tif (adapter->flags & FLAG_HAS_AMT)\n\t\te1000e_get_hw_control(adapter);\n\n\tew32(WUC, 0);\n\n\tif (mac->ops.init_hw(hw))\n\t\te_err(\"Hardware Error\\n\");\n\n\te1000_update_mng_vlan(adapter);\n\n\t/* Enable h/w to recognize an 802.1Q VLAN Ethernet packet */\n\tew32(VET, ETH_P_8021Q);\n\n\te1000e_reset_adaptive(hw);\n\n\t/* restore systim and hwtstamp settings */\n\te1000e_systim_reset(adapter);\n\n\t/* Set EEE advertisement as appropriate */\n\tif (adapter->flags2 & FLAG2_HAS_EEE) {\n\t\ts32 ret_val;\n\t\tu16 adv_addr;\n\n\t\tswitch (hw->phy.type) {\n\t\tcase e1000_phy_82579:\n\t\t\tadv_addr = I82579_EEE_ADVERTISEMENT;\n\t\t\tbreak;\n\t\tcase e1000_phy_i217:\n\t\t\tadv_addr = I217_EEE_ADVERTISEMENT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"Invalid PHY type setting EEE advertisement\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tret_val = hw->phy.ops.acquire(hw);\n\t\tif (ret_val) {\n\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\"EEE advertisement - unable to acquire PHY\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\te1000_write_emi_reg_locked(hw, adv_addr,\n\t\t\t\t\t   hw->dev_spec.ich8lan.eee_disable ?\n\t\t\t\t\t   0 : adapter->eee_advert);\n\n\t\thw->phy.ops.release(hw);\n\t}\n\n\tif (!netif_running(adapter->netdev) &&\n\t    !test_bit(__E1000_TESTING, &adapter->state))\n\t\te1000_power_down_phy(adapter);\n\n\te1000_get_phy_info(hw);\n\n\tif ((adapter->flags & FLAG_HAS_SMART_POWER_DOWN) &&\n\t    !(adapter->flags & FLAG_SMART_POWER_DOWN)) {\n\t\tu16 phy_data = 0;\n\t\t/* speed up time to link by disabling smart power down, ignore\n\t\t * the return value of this function because there is nothing\n\t\t * different we would do if it failed\n\t\t */\n\t\te1e_rphy(hw, IGP02E1000_PHY_POWER_MGMT, &phy_data);\n\t\tphy_data &= ~IGP02E1000_PM_SPD;\n\t\te1e_wphy(hw, IGP02E1000_PHY_POWER_MGMT, phy_data);\n\t}\n\tif (hw->mac.type >= e1000_pch_spt && adapter->int_mode == 0) {\n\t\tu32 reg;\n\n\t\t/* Fextnvm7 @ 0xe4[2] = 1 */\n\t\treg = er32(FEXTNVM7);\n\t\treg |= E1000_FEXTNVM7_SIDE_CLK_UNGATE;\n\t\tew32(FEXTNVM7, reg);\n\t\t/* Fextnvm9 @ 0x5bb4[13:12] = 11 */\n\t\treg = er32(FEXTNVM9);\n\t\treg |= E1000_FEXTNVM9_IOSFSB_CLKGATE_DIS |\n\t\t       E1000_FEXTNVM9_IOSFSB_CLKREQ_DIS;\n\t\tew32(FEXTNVM9, reg);\n\t}\n\n}\n\n/**\n * e1000e_trigger_lsc - trigger an LSC interrupt\n * @adapter: \n *\n * Fire a link status change interrupt to start the watchdog.\n **/\nstatic void e1000e_trigger_lsc(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (adapter->msix_entries)\n\t\tew32(ICS, E1000_ICS_LSC | E1000_ICS_OTHER);\n\telse\n\t\tew32(ICS, E1000_ICS_LSC);\n}\n\nvoid e1000e_up(struct e1000_adapter *adapter)\n{\n\t/* hardware has been reset, we need to reload some things */\n\te1000_configure(adapter);\n\n\tclear_bit(__E1000_DOWN, &adapter->state);\n\n\tif (adapter->msix_entries)\n\t\te1000_configure_msix(adapter);\n\te1000_irq_enable(adapter);\n\n\t/* Tx queue started by watchdog timer when link is up */\n\n\te1000e_trigger_lsc(adapter);\n}\n\nstatic void e1000e_flush_descriptors(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (!(adapter->flags2 & FLAG2_DMA_BURST))\n\t\treturn;\n\n\t/* flush pending descriptor writebacks to memory */\n\tew32(TIDV, adapter->tx_int_delay | E1000_TIDV_FPD);\n\tew32(RDTR, adapter->rx_int_delay | E1000_RDTR_FPD);\n\n\t/* execute the writes immediately */\n\te1e_flush();\n\n\t/* due to rare timing issues, write to TIDV/RDTR again to ensure the\n\t * write is successful\n\t */\n\tew32(TIDV, adapter->tx_int_delay | E1000_TIDV_FPD);\n\tew32(RDTR, adapter->rx_int_delay | E1000_RDTR_FPD);\n\n\t/* execute the writes immediately */\n\te1e_flush();\n}\n\nstatic void e1000e_update_stats(struct e1000_adapter *adapter);\n\n/**\n * e1000e_down - quiesce the device and optionally reset the hardware\n * @adapter: board private structure\n * @reset: boolean flag to reset the hardware or not\n */\nvoid e1000e_down(struct e1000_adapter *adapter, bool reset)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 tctl, rctl;\n\n\t/* signal that we're down so the interrupt handler does not\n\t * reschedule our watchdog timer\n\t */\n\tset_bit(__E1000_DOWN, &adapter->state);\n\n\tnetif_carrier_off(netdev);\n\n\t/* disable receives in the hardware */\n\trctl = er32(RCTL);\n\tif (!(adapter->flags2 & FLAG2_NO_DISABLE_RX))\n\t\tew32(RCTL, rctl & ~E1000_RCTL_EN);\n\t/* flush and sleep below */\n\n\tnetif_stop_queue(netdev);\n\n\t/* disable transmits in the hardware */\n\ttctl = er32(TCTL);\n\ttctl &= ~E1000_TCTL_EN;\n\tew32(TCTL, tctl);\n\n\t/* flush both disables and wait for them to finish */\n\te1e_flush();\n\tusleep_range(10000, 11000);\n\n\te1000_irq_disable(adapter);\n\n\tnapi_synchronize(&adapter->napi);\n\n\tdel_timer_sync(&adapter->watchdog_timer);\n\tdel_timer_sync(&adapter->phy_info_timer);\n\n\tspin_lock(&adapter->stats64_lock);\n\te1000e_update_stats(adapter);\n\tspin_unlock(&adapter->stats64_lock);\n\n\te1000e_flush_descriptors(adapter);\n\n\tadapter->link_speed = 0;\n\tadapter->link_duplex = 0;\n\n\t/* Disable Si errata workaround on PCHx for jumbo frame flow */\n\tif ((hw->mac.type >= e1000_pch2lan) &&\n\t    (adapter->netdev->mtu > ETH_DATA_LEN) &&\n\t    e1000_lv_jumbo_workaround_ich8lan(hw, false))\n\t\te_dbg(\"failed to disable jumbo frame workaround mode\\n\");\n\n\tif (!pci_channel_offline(adapter->pdev)) {\n\t\tif (reset)\n\t\t\te1000e_reset(adapter);\n\t\telse if (hw->mac.type >= e1000_pch_spt)\n\t\t\te1000_flush_desc_rings(adapter);\n\t}\n\te1000_clean_tx_ring(adapter->tx_ring);\n\te1000_clean_rx_ring(adapter->rx_ring);\n}\n\nvoid e1000e_reinit_locked(struct e1000_adapter *adapter)\n{\n\tmight_sleep();\n\twhile (test_and_set_bit(__E1000_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 1100);\n\te1000e_down(adapter, true);\n\te1000e_up(adapter);\n\tclear_bit(__E1000_RESETTING, &adapter->state);\n}\n\n/**\n * e1000e_sanitize_systim - sanitize raw cycle counter reads\n * @hw: pointer to the HW structure\n * @systim: PHC time value read, sanitized and returned\n * @sts: structure to hold system time before and after reading SYSTIML,\n * may be NULL\n *\n * Errata for 82574/82583 possible bad bits read from SYSTIMH/L:\n * check to see that the time is incrementing at a reasonable\n * rate and is a multiple of incvalue.\n **/\nstatic u64 e1000e_sanitize_systim(struct e1000_hw *hw, u64 systim,\n\t\t\t\t  struct ptp_system_timestamp *sts)\n{\n\tu64 time_delta, rem, temp;\n\tu64 systim_next;\n\tu32 incvalue;\n\tint i;\n\n\tincvalue = er32(TIMINCA) & E1000_TIMINCA_INCVALUE_MASK;\n\tfor (i = 0; i < E1000_MAX_82574_SYSTIM_REREADS; i++) {\n\t\t/* latch SYSTIMH on read of SYSTIML */\n\t\tptp_read_system_prets(sts);\n\t\tsystim_next = (u64)er32(SYSTIML);\n\t\tptp_read_system_postts(sts);\n\t\tsystim_next |= (u64)er32(SYSTIMH) << 32;\n\n\t\ttime_delta = systim_next - systim;\n\t\ttemp = time_delta;\n\t\t/* VMWare users have seen incvalue of zero, don't div / 0 */\n\t\trem = incvalue ? do_div(temp, incvalue) : (time_delta != 0);\n\n\t\tsystim = systim_next;\n\n\t\tif ((time_delta < E1000_82574_SYSTIM_EPSILON) && (rem == 0))\n\t\t\tbreak;\n\t}\n\n\treturn systim;\n}\n\n/**\n * e1000e_read_systim - read SYSTIM register\n * @adapter: board private structure\n * @sts: structure which will contain system time before and after reading\n * SYSTIML, may be NULL\n **/\nu64 e1000e_read_systim(struct e1000_adapter *adapter,\n\t\t       struct ptp_system_timestamp *sts)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 systimel, systimel_2, systimeh;\n\tu64 systim;\n\t/* SYSTIMH latching upon SYSTIML read does not work well.\n\t * This means that if SYSTIML overflows after we read it but before\n\t * we read SYSTIMH, the value of SYSTIMH has been incremented and we\n\t * will experience a huge non linear increment in the systime value\n\t * to fix that we test for overflow and if true, we re-read systime.\n\t */\n\tptp_read_system_prets(sts);\n\tsystimel = er32(SYSTIML);\n\tptp_read_system_postts(sts);\n\tsystimeh = er32(SYSTIMH);\n\t/* Is systimel is so large that overflow is possible? */\n\tif (systimel >= (u32)0xffffffff - E1000_TIMINCA_INCVALUE_MASK) {\n\t\tptp_read_system_prets(sts);\n\t\tsystimel_2 = er32(SYSTIML);\n\t\tptp_read_system_postts(sts);\n\t\tif (systimel > systimel_2) {\n\t\t\t/* There was an overflow, read again SYSTIMH, and use\n\t\t\t * systimel_2\n\t\t\t */\n\t\t\tsystimeh = er32(SYSTIMH);\n\t\t\tsystimel = systimel_2;\n\t\t}\n\t}\n\tsystim = (u64)systimel;\n\tsystim |= (u64)systimeh << 32;\n\n\tif (adapter->flags2 & FLAG2_CHECK_SYSTIM_OVERFLOW)\n\t\tsystim = e1000e_sanitize_systim(hw, systim, sts);\n\n\treturn systim;\n}\n\n/**\n * e1000e_cyclecounter_read - read raw cycle counter (used by time counter)\n * @cc: cyclecounter structure\n **/\nstatic u64 e1000e_cyclecounter_read(const struct cyclecounter *cc)\n{\n\tstruct e1000_adapter *adapter = container_of(cc, struct e1000_adapter,\n\t\t\t\t\t\t     cc);\n\n\treturn e1000e_read_systim(adapter, NULL);\n}\n\n/**\n * e1000_sw_init - Initialize general software structures (struct e1000_adapter)\n * @adapter: board private structure to initialize\n *\n * e1000_sw_init initializes the Adapter private data structure.\n * Fields are initialized based on PCI device information and\n * OS network device settings (MTU size).\n **/\nstatic int e1000_sw_init(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tadapter->rx_buffer_len = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;\n\tadapter->rx_ps_bsize0 = 128;\n\tadapter->max_frame_size = netdev->mtu + VLAN_ETH_HLEN + ETH_FCS_LEN;\n\tadapter->min_frame_size = ETH_ZLEN + ETH_FCS_LEN;\n\tadapter->tx_ring_count = E1000_DEFAULT_TXD;\n\tadapter->rx_ring_count = E1000_DEFAULT_RXD;\n\n\tspin_lock_init(&adapter->stats64_lock);\n\n\te1000e_set_interrupt_capability(adapter);\n\n\tif (e1000_alloc_queues(adapter))\n\t\treturn -ENOMEM;\n\n\t/* Setup hardware time stamping cyclecounter */\n\tif (adapter->flags & FLAG_HAS_HW_TIMESTAMP) {\n\t\tadapter->cc.read = e1000e_cyclecounter_read;\n\t\tadapter->cc.mask = CYCLECOUNTER_MASK(64);\n\t\tadapter->cc.mult = 1;\n\t\t/* cc.shift set in e1000e_get_base_tininca() */\n\n\t\tspin_lock_init(&adapter->systim_lock);\n\t\tINIT_WORK(&adapter->tx_hwtstamp_work, e1000e_tx_hwtstamp_work);\n\t}\n\n\t/* Explicitly disable IRQ since the NIC can be in any state. */\n\te1000_irq_disable(adapter);\n\n\tset_bit(__E1000_DOWN, &adapter->state);\n\treturn 0;\n}\n\n/**\n * e1000_intr_msi_test - Interrupt Handler\n * @irq: interrupt number\n * @data: pointer to a network interface device structure\n **/\nstatic irqreturn_t e1000_intr_msi_test(int __always_unused irq, void *data)\n{\n\tstruct net_device *netdev = data;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 icr = er32(ICR);\n\n\te_dbg(\"icr is %08X\\n\", icr);\n\tif (icr & E1000_ICR_RXSEQ) {\n\t\tadapter->flags &= ~FLAG_MSI_TEST_FAILED;\n\t\t/* Force memory writes to complete before acknowledging the\n\t\t * interrupt is handled.\n\t\t */\n\t\twmb();\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n/**\n * e1000_test_msi_interrupt - Returns 0 for successful test\n * @adapter: board private struct\n *\n * code flow taken from tg3.c\n **/\nstatic int e1000_test_msi_interrupt(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint err;\n\n\t/* poll_enable hasn't been called yet, so don't need disable */\n\t/* clear any pending events */\n\ter32(ICR);\n\n\t/* free the real vector and request a test handler */\n\te1000_free_irq(adapter);\n\te1000e_reset_interrupt_capability(adapter);\n\n\t/* Assume that the test fails, if it succeeds then the test\n\t * MSI irq handler will unset this flag\n\t */\n\tadapter->flags |= FLAG_MSI_TEST_FAILED;\n\n\terr = pci_enable_msi(adapter->pdev);\n\tif (err)\n\t\tgoto msi_test_failed;\n\n\terr = request_irq(adapter->pdev->irq, e1000_intr_msi_test, 0,\n\t\t\t  netdev->name, netdev);\n\tif (err) {\n\t\tpci_disable_msi(adapter->pdev);\n\t\tgoto msi_test_failed;\n\t}\n\n\t/* Force memory writes to complete before enabling and firing an\n\t * interrupt.\n\t */\n\twmb();\n\n\te1000_irq_enable(adapter);\n\n\t/* fire an unusual interrupt on the test handler */\n\tew32(ICS, E1000_ICS_RXSEQ);\n\te1e_flush();\n\tmsleep(100);\n\n\te1000_irq_disable(adapter);\n\n\trmb();\t\t\t/* read flags after interrupt has been fired */\n\n\tif (adapter->flags & FLAG_MSI_TEST_FAILED) {\n\t\tadapter->int_mode = E1000E_INT_MODE_LEGACY;\n\t\te_info(\"MSI interrupt test failed, using legacy interrupt.\\n\");\n\t} else {\n\t\te_dbg(\"MSI interrupt test succeeded!\\n\");\n\t}\n\n\tfree_irq(adapter->pdev->irq, netdev);\n\tpci_disable_msi(adapter->pdev);\n\nmsi_test_failed:\n\te1000e_set_interrupt_capability(adapter);\n\treturn e1000_request_irq(adapter);\n}\n\n/**\n * e1000_test_msi - Returns 0 if MSI test succeeds or INTx mode is restored\n * @adapter: board private struct\n *\n * code flow taken from tg3.c, called with e1000 interrupts disabled.\n **/\nstatic int e1000_test_msi(struct e1000_adapter *adapter)\n{\n\tint err;\n\tu16 pci_cmd;\n\n\tif (!(adapter->flags & FLAG_MSI_ENABLED))\n\t\treturn 0;\n\n\t/* disable SERR in case the MSI write causes a master abort */\n\tpci_read_config_word(adapter->pdev, PCI_COMMAND, &pci_cmd);\n\tif (pci_cmd & PCI_COMMAND_SERR)\n\t\tpci_write_config_word(adapter->pdev, PCI_COMMAND,\n\t\t\t\t      pci_cmd & ~PCI_COMMAND_SERR);\n\n\terr = e1000_test_msi_interrupt(adapter);\n\n\t/* re-enable SERR */\n\tif (pci_cmd & PCI_COMMAND_SERR) {\n\t\tpci_read_config_word(adapter->pdev, PCI_COMMAND, &pci_cmd);\n\t\tpci_cmd |= PCI_COMMAND_SERR;\n\t\tpci_write_config_word(adapter->pdev, PCI_COMMAND, pci_cmd);\n\t}\n\n\treturn err;\n}\n\n/**\n * e1000e_open - Called when a network interface is made active\n * @netdev: network interface device structure\n *\n * Returns 0 on success, negative value on failure\n *\n * The open entry point is called when a network interface is made\n * active by the system (IFF_UP).  At this point all resources needed\n * for transmit and receive operations are allocated, the interrupt\n * handler is registered with the OS, the watchdog timer is started,\n * and the stack is notified that the interface is ready.\n **/\nint e1000e_open(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint err;\n\n\t/* disallow open during test */\n\tif (test_bit(__E1000_TESTING, &adapter->state))\n\t\treturn -EBUSY;\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tnetif_carrier_off(netdev);\n\tnetif_stop_queue(netdev);\n\n\t/* allocate transmit descriptors */\n\terr = e1000e_setup_tx_resources(adapter->tx_ring);\n\tif (err)\n\t\tgoto err_setup_tx;\n\n\t/* allocate receive descriptors */\n\terr = e1000e_setup_rx_resources(adapter->rx_ring);\n\tif (err)\n\t\tgoto err_setup_rx;\n\n\t/* If AMT is enabled, let the firmware know that the network\n\t * interface is now open and reset the part to a known state.\n\t */\n\tif (adapter->flags & FLAG_HAS_AMT) {\n\t\te1000e_get_hw_control(adapter);\n\t\te1000e_reset(adapter);\n\t}\n\n\te1000e_power_up_phy(adapter);\n\n\tadapter->mng_vlan_id = E1000_MNG_VLAN_NONE;\n\tif ((adapter->hw.mng_cookie.status & E1000_MNG_DHCP_COOKIE_STATUS_VLAN))\n\t\te1000_update_mng_vlan(adapter);\n\n\t/* DMA latency requirement to workaround jumbo issue */\n\tcpu_latency_qos_add_request(&adapter->pm_qos_req, PM_QOS_DEFAULT_VALUE);\n\n\t/* before we allocate an interrupt, we must be ready to handle it.\n\t * Setting DEBUG_SHIRQ in the kernel makes it fire an interrupt\n\t * as soon as we call pci_request_irq, so we have to setup our\n\t * clean_rx handler before we do so.\n\t */\n\te1000_configure(adapter);\n\n\terr = e1000_request_irq(adapter);\n\tif (err)\n\t\tgoto err_req_irq;\n\n\t/* Work around PCIe errata with MSI interrupts causing some chipsets to\n\t * ignore e1000e MSI messages, which means we need to test our MSI\n\t * interrupt now\n\t */\n\tif (adapter->int_mode != E1000E_INT_MODE_LEGACY) {\n\t\terr = e1000_test_msi(adapter);\n\t\tif (err) {\n\t\t\te_err(\"Interrupt allocation failed\\n\");\n\t\t\tgoto err_req_irq;\n\t\t}\n\t}\n\n\t/* From here on the code is the same as e1000e_up() */\n\tclear_bit(__E1000_DOWN, &adapter->state);\n\n\tnapi_enable(&adapter->napi);\n\n\te1000_irq_enable(adapter);\n\n\tadapter->tx_hang_recheck = false;\n\n\thw->mac.get_link_status = true;\n\tpm_runtime_put(&pdev->dev);\n\n\te1000e_trigger_lsc(adapter);\n\n\treturn 0;\n\nerr_req_irq:\n\tcpu_latency_qos_remove_request(&adapter->pm_qos_req);\n\te1000e_release_hw_control(adapter);\n\te1000_power_down_phy(adapter);\n\te1000e_free_rx_resources(adapter->rx_ring);\nerr_setup_rx:\n\te1000e_free_tx_resources(adapter->tx_ring);\nerr_setup_tx:\n\te1000e_reset(adapter);\n\tpm_runtime_put_sync(&pdev->dev);\n\n\treturn err;\n}\n\n/**\n * e1000e_close - Disables a network interface\n * @netdev: network interface device structure\n *\n * Returns 0, this is not allowed to fail\n *\n * The close entry point is called when an interface is de-activated\n * by the OS.  The hardware is still under the drivers control, but\n * needs to be disabled.  A global MAC reset is issued to stop the\n * hardware, and all transmit and receive resources are freed.\n **/\nint e1000e_close(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint count = E1000_CHECK_RESET_COUNT;\n\n\twhile (test_bit(__E1000_RESETTING, &adapter->state) && count--)\n\t\tusleep_range(10000, 11000);\n\n\tWARN_ON(test_bit(__E1000_RESETTING, &adapter->state));\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tif (netif_device_present(netdev)) {\n\t\te1000e_down(adapter, true);\n\t\te1000_free_irq(adapter);\n\n\t\t/* Link status message must follow this format */\n\t\tnetdev_info(netdev, \"NIC Link is Down\\n\");\n\t}\n\n\tnapi_disable(&adapter->napi);\n\n\te1000e_free_tx_resources(adapter->tx_ring);\n\te1000e_free_rx_resources(adapter->rx_ring);\n\n\t/* kill manageability vlan ID if supported, but not if a vlan with\n\t * the same ID is registered on the host OS (let 8021q kill it)\n\t */\n\tif (adapter->hw.mng_cookie.status & E1000_MNG_DHCP_COOKIE_STATUS_VLAN)\n\t\te1000_vlan_rx_kill_vid(netdev, htons(ETH_P_8021Q),\n\t\t\t\t       adapter->mng_vlan_id);\n\n\t/* If AMT is enabled, let the firmware know that the network\n\t * interface is now closed\n\t */\n\tif ((adapter->flags & FLAG_HAS_AMT) &&\n\t    !test_bit(__E1000_TESTING, &adapter->state))\n\t\te1000e_release_hw_control(adapter);\n\n\tcpu_latency_qos_remove_request(&adapter->pm_qos_req);\n\n\tpm_runtime_put_sync(&pdev->dev);\n\n\treturn 0;\n}\n\n/**\n * e1000_set_mac - Change the Ethernet Address of the NIC\n * @netdev: network interface device structure\n * @p: pointer to an address structure\n *\n * Returns 0 on success, negative on failure\n **/\nstatic int e1000_set_mac(struct net_device *netdev, void *p)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tmemcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);\n\tmemcpy(adapter->hw.mac.addr, addr->sa_data, netdev->addr_len);\n\n\thw->mac.ops.rar_set(&adapter->hw, adapter->hw.mac.addr, 0);\n\n\tif (adapter->flags & FLAG_RESET_OVERWRITES_LAA) {\n\t\t/* activate the work around */\n\t\te1000e_set_laa_state_82571(&adapter->hw, 1);\n\n\t\t/* Hold a copy of the LAA in RAR[14] This is done so that\n\t\t * between the time RAR[0] gets clobbered  and the time it\n\t\t * gets fixed (in e1000_watchdog), the actual LAA is in one\n\t\t * of the RARs and no incoming packets directed to this port\n\t\t * are dropped. Eventually the LAA will be in RAR[0] and\n\t\t * RAR[14]\n\t\t */\n\t\thw->mac.ops.rar_set(&adapter->hw, adapter->hw.mac.addr,\n\t\t\t\t    adapter->hw.mac.rar_entry_count - 1);\n\t}\n\n\treturn 0;\n}\n\n/**\n * e1000e_update_phy_task - work thread to update phy\n * @work: pointer to our work struct\n *\n * this worker thread exists because we must acquire a\n * semaphore to read the phy, which we could msleep while\n * waiting for it, and we can't msleep in a timer.\n **/\nstatic void e1000e_update_phy_task(struct work_struct *work)\n{\n\tstruct e1000_adapter *adapter = container_of(work,\n\t\t\t\t\t\t     struct e1000_adapter,\n\t\t\t\t\t\t     update_phy_task);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\tif (test_bit(__E1000_DOWN, &adapter->state))\n\t\treturn;\n\n\te1000_get_phy_info(hw);\n\n\t/* Enable EEE on 82579 after link up */\n\tif (hw->phy.type >= e1000_phy_82579)\n\t\te1000_set_eee_pchlan(hw);\n}\n\n/**\n * e1000_update_phy_info - timre call-back to update PHY info\n * @t: pointer to timer_list containing private info adapter\n *\n * Need to wait a few seconds after link up to get diagnostic information from\n * the phy\n **/\nstatic void e1000_update_phy_info(struct timer_list *t)\n{\n\tstruct e1000_adapter *adapter = from_timer(adapter, t, phy_info_timer);\n\n\tif (test_bit(__E1000_DOWN, &adapter->state))\n\t\treturn;\n\n\tschedule_work(&adapter->update_phy_task);\n}\n\n/**\n * e1000e_update_phy_stats - Update the PHY statistics counters\n * @adapter: board private structure\n *\n * Read/clear the upper 16-bit PHY registers and read/accumulate lower\n **/\nstatic void e1000e_update_phy_stats(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\ts32 ret_val;\n\tu16 phy_data;\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\treturn;\n\n\t/* A page set is expensive so check if already on desired page.\n\t * If not, set to the page with the PHY status registers.\n\t */\n\thw->phy.addr = 1;\n\tret_val = e1000e_read_phy_reg_mdic(hw, IGP01E1000_PHY_PAGE_SELECT,\n\t\t\t\t\t   &phy_data);\n\tif (ret_val)\n\t\tgoto release;\n\tif (phy_data != (HV_STATS_PAGE << IGP_PAGE_SHIFT)) {\n\t\tret_val = hw->phy.ops.set_page(hw,\n\t\t\t\t\t       HV_STATS_PAGE << IGP_PAGE_SHIFT);\n\t\tif (ret_val)\n\t\t\tgoto release;\n\t}\n\n\t/* Single Collision Count */\n\thw->phy.ops.read_reg_page(hw, HV_SCC_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_SCC_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.scc += phy_data;\n\n\t/* Excessive Collision Count */\n\thw->phy.ops.read_reg_page(hw, HV_ECOL_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_ECOL_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.ecol += phy_data;\n\n\t/* Multiple Collision Count */\n\thw->phy.ops.read_reg_page(hw, HV_MCC_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_MCC_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.mcc += phy_data;\n\n\t/* Late Collision Count */\n\thw->phy.ops.read_reg_page(hw, HV_LATECOL_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_LATECOL_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.latecol += phy_data;\n\n\t/* Collision Count - also used for adaptive IFS */\n\thw->phy.ops.read_reg_page(hw, HV_COLC_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_COLC_LOWER, &phy_data);\n\tif (!ret_val)\n\t\thw->mac.collision_delta = phy_data;\n\n\t/* Defer Count */\n\thw->phy.ops.read_reg_page(hw, HV_DC_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_DC_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.dc += phy_data;\n\n\t/* Transmit with no CRS */\n\thw->phy.ops.read_reg_page(hw, HV_TNCRS_UPPER, &phy_data);\n\tret_val = hw->phy.ops.read_reg_page(hw, HV_TNCRS_LOWER, &phy_data);\n\tif (!ret_val)\n\t\tadapter->stats.tncrs += phy_data;\n\nrelease:\n\thw->phy.ops.release(hw);\n}\n\n/**\n * e1000e_update_stats - Update the board statistics counters\n * @adapter: board private structure\n **/\nstatic void e1000e_update_stats(struct e1000_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\t/* Prevent stats update while adapter is being reset, or if the pci\n\t * connection is down.\n\t */\n\tif (adapter->link_speed == 0)\n\t\treturn;\n\tif (pci_channel_offline(pdev))\n\t\treturn;\n\n\tadapter->stats.crcerrs += er32(CRCERRS);\n\tadapter->stats.gprc += er32(GPRC);\n\tadapter->stats.gorc += er32(GORCL);\n\ter32(GORCH);\t\t/* Clear gorc */\n\tadapter->stats.bprc += er32(BPRC);\n\tadapter->stats.mprc += er32(MPRC);\n\tadapter->stats.roc += er32(ROC);\n\n\tadapter->stats.mpc += er32(MPC);\n\n\t/* Half-duplex statistics */\n\tif (adapter->link_duplex == HALF_DUPLEX) {\n\t\tif (adapter->flags2 & FLAG2_HAS_PHY_STATS) {\n\t\t\te1000e_update_phy_stats(adapter);\n\t\t} else {\n\t\t\tadapter->stats.scc += er32(SCC);\n\t\t\tadapter->stats.ecol += er32(ECOL);\n\t\t\tadapter->stats.mcc += er32(MCC);\n\t\t\tadapter->stats.latecol += er32(LATECOL);\n\t\t\tadapter->stats.dc += er32(DC);\n\n\t\t\thw->mac.collision_delta = er32(COLC);\n\n\t\t\tif ((hw->mac.type != e1000_82574) &&\n\t\t\t    (hw->mac.type != e1000_82583))\n\t\t\t\tadapter->stats.tncrs += er32(TNCRS);\n\t\t}\n\t\tadapter->stats.colc += hw->mac.collision_delta;\n\t}\n\n\tadapter->stats.xonrxc += er32(XONRXC);\n\tadapter->stats.xontxc += er32(XONTXC);\n\tadapter->stats.xoffrxc += er32(XOFFRXC);\n\tadapter->stats.xofftxc += er32(XOFFTXC);\n\tadapter->stats.gptc += er32(GPTC);\n\tadapter->stats.gotc += er32(GOTCL);\n\ter32(GOTCH);\t\t/* Clear gotc */\n\tadapter->stats.rnbc += er32(RNBC);\n\tadapter->stats.ruc += er32(RUC);\n\n\tadapter->stats.mptc += er32(MPTC);\n\tadapter->stats.bptc += er32(BPTC);\n\n\t/* used for adaptive IFS */\n\n\thw->mac.tx_packet_delta = er32(TPT);\n\tadapter->stats.tpt += hw->mac.tx_packet_delta;\n\n\tadapter->stats.algnerrc += er32(ALGNERRC);\n\tadapter->stats.rxerrc += er32(RXERRC);\n\tadapter->stats.cexterr += er32(CEXTERR);\n\tadapter->stats.tsctc += er32(TSCTC);\n\tadapter->stats.tsctfc += er32(TSCTFC);\n\n\t/* Fill out the OS statistics structure */\n\tnetdev->stats.multicast = adapter->stats.mprc;\n\tnetdev->stats.collisions = adapter->stats.colc;\n\n\t/* Rx Errors */\n\n\t/* RLEC on some newer hardware can be incorrect so build\n\t * our own version based on RUC and ROC\n\t */\n\tnetdev->stats.rx_errors = adapter->stats.rxerrc +\n\t    adapter->stats.crcerrs + adapter->stats.algnerrc +\n\t    adapter->stats.ruc + adapter->stats.roc + adapter->stats.cexterr;\n\tnetdev->stats.rx_length_errors = adapter->stats.ruc +\n\t    adapter->stats.roc;\n\tnetdev->stats.rx_crc_errors = adapter->stats.crcerrs;\n\tnetdev->stats.rx_frame_errors = adapter->stats.algnerrc;\n\tnetdev->stats.rx_missed_errors = adapter->stats.mpc;\n\n\t/* Tx Errors */\n\tnetdev->stats.tx_errors = adapter->stats.ecol + adapter->stats.latecol;\n\tnetdev->stats.tx_aborted_errors = adapter->stats.ecol;\n\tnetdev->stats.tx_window_errors = adapter->stats.latecol;\n\tnetdev->stats.tx_carrier_errors = adapter->stats.tncrs;\n\n\t/* Tx Dropped needs to be maintained elsewhere */\n\n\t/* Management Stats */\n\tadapter->stats.mgptc += er32(MGTPTC);\n\tadapter->stats.mgprc += er32(MGTPRC);\n\tadapter->stats.mgpdc += er32(MGTPDC);\n\n\t/* Correctable ECC Errors */\n\tif (hw->mac.type >= e1000_pch_lpt) {\n\t\tu32 pbeccsts = er32(PBECCSTS);\n\n\t\tadapter->corr_errors +=\n\t\t    pbeccsts & E1000_PBECCSTS_CORR_ERR_CNT_MASK;\n\t\tadapter->uncorr_errors +=\n\t\t    (pbeccsts & E1000_PBECCSTS_UNCORR_ERR_CNT_MASK) >>\n\t\t    E1000_PBECCSTS_UNCORR_ERR_CNT_SHIFT;\n\t}\n}\n\n/**\n * e1000_phy_read_status - Update the PHY register status snapshot\n * @adapter: board private structure\n **/\nstatic void e1000_phy_read_status(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct e1000_phy_regs *phy = &adapter->phy_regs;\n\n\tif (!pm_runtime_suspended((&adapter->pdev->dev)->parent) &&\n\t    (er32(STATUS) & E1000_STATUS_LU) &&\n\t    (adapter->hw.phy.media_type == e1000_media_type_copper)) {\n\t\tint ret_val;\n\n\t\tret_val = e1e_rphy(hw, MII_BMCR, &phy->bmcr);\n\t\tret_val |= e1e_rphy(hw, MII_BMSR, &phy->bmsr);\n\t\tret_val |= e1e_rphy(hw, MII_ADVERTISE, &phy->advertise);\n\t\tret_val |= e1e_rphy(hw, MII_LPA, &phy->lpa);\n\t\tret_val |= e1e_rphy(hw, MII_EXPANSION, &phy->expansion);\n\t\tret_val |= e1e_rphy(hw, MII_CTRL1000, &phy->ctrl1000);\n\t\tret_val |= e1e_rphy(hw, MII_STAT1000, &phy->stat1000);\n\t\tret_val |= e1e_rphy(hw, MII_ESTATUS, &phy->estatus);\n\t\tif (ret_val)\n\t\t\te_warn(\"Error reading PHY register\\n\");\n\t} else {\n\t\t/* Do not read PHY registers if link is not up\n\t\t * Set values to typical power-on defaults\n\t\t */\n\t\tphy->bmcr = (BMCR_SPEED1000 | BMCR_ANENABLE | BMCR_FULLDPLX);\n\t\tphy->bmsr = (BMSR_100FULL | BMSR_100HALF | BMSR_10FULL |\n\t\t\t     BMSR_10HALF | BMSR_ESTATEN | BMSR_ANEGCAPABLE |\n\t\t\t     BMSR_ERCAP);\n\t\tphy->advertise = (ADVERTISE_PAUSE_ASYM | ADVERTISE_PAUSE_CAP |\n\t\t\t\t  ADVERTISE_ALL | ADVERTISE_CSMA);\n\t\tphy->lpa = 0;\n\t\tphy->expansion = EXPANSION_ENABLENPAGE;\n\t\tphy->ctrl1000 = ADVERTISE_1000FULL;\n\t\tphy->stat1000 = 0;\n\t\tphy->estatus = (ESTATUS_1000_TFULL | ESTATUS_1000_THALF);\n\t}\n}\n\nstatic void e1000_print_link_info(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl = er32(CTRL);\n\n\t/* Link status message must follow this format for user tools */\n\tnetdev_info(adapter->netdev,\n\t\t    \"NIC Link is Up %d Mbps %s Duplex, Flow Control: %s\\n\",\n\t\t    adapter->link_speed,\n\t\t    adapter->link_duplex == FULL_DUPLEX ? \"Full\" : \"Half\",\n\t\t    (ctrl & E1000_CTRL_TFCE) && (ctrl & E1000_CTRL_RFCE) ? \"Rx/Tx\" :\n\t\t    (ctrl & E1000_CTRL_RFCE) ? \"Rx\" :\n\t\t    (ctrl & E1000_CTRL_TFCE) ? \"Tx\" : \"None\");\n}\n\nstatic bool e1000e_has_link(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tbool link_active = false;\n\ts32 ret_val = 0;\n\n\t/* get_link_status is set on LSC (link status) interrupt or\n\t * Rx sequence error interrupt.  get_link_status will stay\n\t * true until the check_for_link establishes link\n\t * for copper adapters ONLY\n\t */\n\tswitch (hw->phy.media_type) {\n\tcase e1000_media_type_copper:\n\t\tif (hw->mac.get_link_status) {\n\t\t\tret_val = hw->mac.ops.check_for_link(hw);\n\t\t\tlink_active = !hw->mac.get_link_status;\n\t\t} else {\n\t\t\tlink_active = true;\n\t\t}\n\t\tbreak;\n\tcase e1000_media_type_fiber:\n\t\tret_val = hw->mac.ops.check_for_link(hw);\n\t\tlink_active = !!(er32(STATUS) & E1000_STATUS_LU);\n\t\tbreak;\n\tcase e1000_media_type_internal_serdes:\n\t\tret_val = hw->mac.ops.check_for_link(hw);\n\t\tlink_active = hw->mac.serdes_has_link;\n\t\tbreak;\n\tdefault:\n\tcase e1000_media_type_unknown:\n\t\tbreak;\n\t}\n\n\tif ((ret_val == -E1000_ERR_PHY) && (hw->phy.type == e1000_phy_igp_3) &&\n\t    (er32(CTRL) & E1000_PHY_CTRL_GBE_DISABLE)) {\n\t\t/* See e1000_kmrn_lock_loss_workaround_ich8lan() */\n\t\te_info(\"Gigabit has been disabled, downgrading speed\\n\");\n\t}\n\n\treturn link_active;\n}\n\nstatic void e1000e_enable_receives(struct e1000_adapter *adapter)\n{\n\t/* make sure the receive unit is started */\n\tif ((adapter->flags & FLAG_RX_NEEDS_RESTART) &&\n\t    (adapter->flags & FLAG_RESTART_NOW)) {\n\t\tstruct e1000_hw *hw = &adapter->hw;\n\t\tu32 rctl = er32(RCTL);\n\n\t\tew32(RCTL, rctl | E1000_RCTL_EN);\n\t\tadapter->flags &= ~FLAG_RESTART_NOW;\n\t}\n}\n\nstatic void e1000e_check_82574_phy_workaround(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t/* With 82574 controllers, PHY needs to be checked periodically\n\t * for hung state and reset, if two calls return true\n\t */\n\tif (e1000_check_phy_82574(hw))\n\t\tadapter->phy_hang_count++;\n\telse\n\t\tadapter->phy_hang_count = 0;\n\n\tif (adapter->phy_hang_count > 1) {\n\t\tadapter->phy_hang_count = 0;\n\t\te_dbg(\"PHY appears hung - resetting\\n\");\n\t\tschedule_work(&adapter->reset_task);\n\t}\n}\n\n/**\n * e1000_watchdog - Timer Call-back\n * @t: pointer to timer_list containing private info adapter\n **/\nstatic void e1000_watchdog(struct timer_list *t)\n{\n\tstruct e1000_adapter *adapter = from_timer(adapter, t, watchdog_timer);\n\n\t/* Do the rest outside of interrupt context */\n\tschedule_work(&adapter->watchdog_task);\n\n\t/* TODO: make this use queue_delayed_work() */\n}\n\nstatic void e1000_watchdog_task(struct work_struct *work)\n{\n\tstruct e1000_adapter *adapter = container_of(work,\n\t\t\t\t\t\t     struct e1000_adapter,\n\t\t\t\t\t\t     watchdog_task);\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct e1000_mac_info *mac = &adapter->hw.mac;\n\tstruct e1000_phy_info *phy = &adapter->hw.phy;\n\tstruct e1000_ring *tx_ring = adapter->tx_ring;\n\tu32 dmoff_exit_timeout = 100, tries = 0;\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 link, tctl, pcim_state;\n\n\tif (test_bit(__E1000_DOWN, &adapter->state))\n\t\treturn;\n\n\tlink = e1000e_has_link(adapter);\n\tif ((netif_carrier_ok(netdev)) && link) {\n\t\t/* Cancel scheduled suspend requests. */\n\t\tpm_runtime_resume(netdev->dev.parent);\n\n\t\te1000e_enable_receives(adapter);\n\t\tgoto link_up;\n\t}\n\n\tif ((e1000e_enable_tx_pkt_filtering(hw)) &&\n\t    (adapter->mng_vlan_id != adapter->hw.mng_cookie.vlan_id))\n\t\te1000_update_mng_vlan(adapter);\n\n\tif (link) {\n\t\tif (!netif_carrier_ok(netdev)) {\n\t\t\tbool txb2b = true;\n\n\t\t\t/* Cancel scheduled suspend requests. */\n\t\t\tpm_runtime_resume(netdev->dev.parent);\n\n\t\t\t/* Checking if MAC is in DMoff state*/\n\t\t\tpcim_state = er32(STATUS);\n\t\t\twhile (pcim_state & E1000_STATUS_PCIM_STATE) {\n\t\t\t\tif (tries++ == dmoff_exit_timeout) {\n\t\t\t\t\te_dbg(\"Error in exiting dmoff\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tusleep_range(10000, 20000);\n\t\t\t\tpcim_state = er32(STATUS);\n\n\t\t\t\t/* Checking if MAC exited DMoff state */\n\t\t\t\tif (!(pcim_state & E1000_STATUS_PCIM_STATE))\n\t\t\t\t\te1000_phy_hw_reset(&adapter->hw);\n\t\t\t}\n\n\t\t\t/* update snapshot of PHY registers on LSC */\n\t\t\te1000_phy_read_status(adapter);\n\t\t\tmac->ops.get_link_up_info(&adapter->hw,\n\t\t\t\t\t\t  &adapter->link_speed,\n\t\t\t\t\t\t  &adapter->link_duplex);\n\t\t\te1000_print_link_info(adapter);\n\n\t\t\t/* check if SmartSpeed worked */\n\t\t\te1000e_check_downshift(hw);\n\t\t\tif (phy->speed_downgraded)\n\t\t\t\tnetdev_warn(netdev,\n\t\t\t\t\t    \"Link Speed was downgraded by SmartSpeed\\n\");\n\n\t\t\t/* On supported PHYs, check for duplex mismatch only\n\t\t\t * if link has autonegotiated at 10/100 half\n\t\t\t */\n\t\t\tif ((hw->phy.type == e1000_phy_igp_3 ||\n\t\t\t     hw->phy.type == e1000_phy_bm) &&\n\t\t\t    hw->mac.autoneg &&\n\t\t\t    (adapter->link_speed == SPEED_10 ||\n\t\t\t     adapter->link_speed == SPEED_100) &&\n\t\t\t    (adapter->link_duplex == HALF_DUPLEX)) {\n\t\t\t\tu16 autoneg_exp;\n\n\t\t\t\te1e_rphy(hw, MII_EXPANSION, &autoneg_exp);\n\n\t\t\t\tif (!(autoneg_exp & EXPANSION_NWAY))\n\t\t\t\t\te_info(\"Autonegotiated half duplex but link partner cannot autoneg.  Try forcing full duplex if link gets many collisions.\\n\");\n\t\t\t}\n\n\t\t\t/* adjust timeout factor according to speed/duplex */\n\t\t\tadapter->tx_timeout_factor = 1;\n\t\t\tswitch (adapter->link_speed) {\n\t\t\tcase SPEED_10:\n\t\t\t\ttxb2b = false;\n\t\t\t\tadapter->tx_timeout_factor = 16;\n\t\t\t\tbreak;\n\t\t\tcase SPEED_100:\n\t\t\t\ttxb2b = false;\n\t\t\t\tadapter->tx_timeout_factor = 10;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* workaround: re-program speed mode bit after\n\t\t\t * link-up event\n\t\t\t */\n\t\t\tif ((adapter->flags & FLAG_TARC_SPEED_MODE_BIT) &&\n\t\t\t    !txb2b) {\n\t\t\t\tu32 tarc0;\n\n\t\t\t\ttarc0 = er32(TARC(0));\n\t\t\t\ttarc0 &= ~SPEED_MODE_BIT;\n\t\t\t\tew32(TARC(0), tarc0);\n\t\t\t}\n\n\t\t\t/* disable TSO for pcie and 10/100 speeds, to avoid\n\t\t\t * some hardware issues\n\t\t\t */\n\t\t\tif (!(adapter->flags & FLAG_TSO_FORCE)) {\n\t\t\t\tswitch (adapter->link_speed) {\n\t\t\t\tcase SPEED_10:\n\t\t\t\tcase SPEED_100:\n\t\t\t\t\te_info(\"10/100 speed: disabling TSO\\n\");\n\t\t\t\t\tnetdev->features &= ~NETIF_F_TSO;\n\t\t\t\t\tnetdev->features &= ~NETIF_F_TSO6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SPEED_1000:\n\t\t\t\t\tnetdev->features |= NETIF_F_TSO;\n\t\t\t\t\tnetdev->features |= NETIF_F_TSO6;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* oops */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (hw->mac.type == e1000_pch_spt) {\n\t\t\t\t\tnetdev->features &= ~NETIF_F_TSO;\n\t\t\t\t\tnetdev->features &= ~NETIF_F_TSO6;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* enable transmits in the hardware, need to do this\n\t\t\t * after setting TARC(0)\n\t\t\t */\n\t\t\ttctl = er32(TCTL);\n\t\t\ttctl |= E1000_TCTL_EN;\n\t\t\tew32(TCTL, tctl);\n\n\t\t\t/* Perform any post-link-up configuration before\n\t\t\t * reporting link up.\n\t\t\t */\n\t\t\tif (phy->ops.cfg_on_link_up)\n\t\t\t\tphy->ops.cfg_on_link_up(hw);\n\n\t\t\tnetif_wake_queue(netdev);\n\t\t\tnetif_carrier_on(netdev);\n\n\t\t\tif (!test_bit(__E1000_DOWN, &adapter->state))\n\t\t\t\tmod_timer(&adapter->phy_info_timer,\n\t\t\t\t\t  round_jiffies(jiffies + 2 * HZ));\n\t\t}\n\t} else {\n\t\tif (netif_carrier_ok(netdev)) {\n\t\t\tadapter->link_speed = 0;\n\t\t\tadapter->link_duplex = 0;\n\t\t\t/* Link status message must follow this format */\n\t\t\tnetdev_info(netdev, \"NIC Link is Down\\n\");\n\t\t\tnetif_carrier_off(netdev);\n\t\t\tnetif_stop_queue(netdev);\n\t\t\tif (!test_bit(__E1000_DOWN, &adapter->state))\n\t\t\t\tmod_timer(&adapter->phy_info_timer,\n\t\t\t\t\t  round_jiffies(jiffies + 2 * HZ));\n\n\t\t\t/* 8000ES2LAN requires a Rx packet buffer work-around\n\t\t\t * on link down event; reset the controller to flush\n\t\t\t * the Rx packet buffer.\n\t\t\t */\n\t\t\tif (adapter->flags & FLAG_RX_NEEDS_RESTART)\n\t\t\t\tadapter->flags |= FLAG_RESTART_NOW;\n\t\t\telse\n\t\t\t\tpm_schedule_suspend(netdev->dev.parent,\n\t\t\t\t\t\t    LINK_TIMEOUT);\n\t\t}\n\t}\n\nlink_up:\n\tspin_lock(&adapter->stats64_lock);\n\te1000e_update_stats(adapter);\n\n\tmac->tx_packet_delta = adapter->stats.tpt - adapter->tpt_old;\n\tadapter->tpt_old = adapter->stats.tpt;\n\tmac->collision_delta = adapter->stats.colc - adapter->colc_old;\n\tadapter->colc_old = adapter->stats.colc;\n\n\tadapter->gorc = adapter->stats.gorc - adapter->gorc_old;\n\tadapter->gorc_old = adapter->stats.gorc;\n\tadapter->gotc = adapter->stats.gotc - adapter->gotc_old;\n\tadapter->gotc_old = adapter->stats.gotc;\n\tspin_unlock(&adapter->stats64_lock);\n\n\t/* If the link is lost the controller stops DMA, but\n\t * if there is queued Tx work it cannot be done.  So\n\t * reset the controller to flush the Tx packet buffers.\n\t */\n\tif (!netif_carrier_ok(netdev) &&\n\t    (e1000_desc_unused(tx_ring) + 1 < tx_ring->count))\n\t\tadapter->flags |= FLAG_RESTART_NOW;\n\n\t/* If reset is necessary, do it outside of interrupt context. */\n\tif (adapter->flags & FLAG_RESTART_NOW) {\n\t\tschedule_work(&adapter->reset_task);\n\t\t/* return immediately since reset is imminent */\n\t\treturn;\n\t}\n\n\te1000e_update_adaptive(&adapter->hw);\n\n\t/* Simple mode for Interrupt Throttle Rate (ITR) */\n\tif (adapter->itr_setting == 4) {\n\t\t/* Symmetric Tx/Rx gets a reduced ITR=2000;\n\t\t * Total asymmetrical Tx or Rx gets ITR=8000;\n\t\t * everyone else is between 2000-8000.\n\t\t */\n\t\tu32 goc = (adapter->gotc + adapter->gorc) / 10000;\n\t\tu32 dif = (adapter->gotc > adapter->gorc ?\n\t\t\t   adapter->gotc - adapter->gorc :\n\t\t\t   adapter->gorc - adapter->gotc) / 10000;\n\t\tu32 itr = goc > 0 ? (dif * 6000 / goc + 2000) : 8000;\n\n\t\te1000e_write_itr(adapter, itr);\n\t}\n\n\t/* Cause software interrupt to ensure Rx ring is cleaned */\n\tif (adapter->msix_entries)\n\t\tew32(ICS, adapter->rx_ring->ims_val);\n\telse\n\t\tew32(ICS, E1000_ICS_RXDMT0);\n\n\t/* flush pending descriptors to memory before detecting Tx hang */\n\te1000e_flush_descriptors(adapter);\n\n\t/* Force detection of hung controller every watchdog period */\n\tadapter->detect_tx_hung = true;\n\n\t/* With 82571 controllers, LAA may be overwritten due to controller\n\t * reset from the other port. Set the appropriate LAA in RAR[0]\n\t */\n\tif (e1000e_get_laa_state_82571(hw))\n\t\thw->mac.ops.rar_set(hw, adapter->hw.mac.addr, 0);\n\n\tif (adapter->flags2 & FLAG2_CHECK_PHY_HANG)\n\t\te1000e_check_82574_phy_workaround(adapter);\n\n\t/* Clear valid timestamp stuck in RXSTMPL/H due to a Rx error */\n\tif (adapter->hwtstamp_config.rx_filter != HWTSTAMP_FILTER_NONE) {\n\t\tif ((adapter->flags2 & FLAG2_CHECK_RX_HWTSTAMP) &&\n\t\t    (er32(TSYNCRXCTL) & E1000_TSYNCRXCTL_VALID)) {\n\t\t\ter32(RXSTMPH);\n\t\t\tadapter->rx_hwtstamp_cleared++;\n\t\t} else {\n\t\t\tadapter->flags2 |= FLAG2_CHECK_RX_HWTSTAMP;\n\t\t}\n\t}\n\n\t/* Reset the timer */\n\tif (!test_bit(__E1000_DOWN, &adapter->state))\n\t\tmod_timer(&adapter->watchdog_timer,\n\t\t\t  round_jiffies(jiffies + 2 * HZ));\n}\n\n#define E1000_TX_FLAGS_CSUM\t\t0x00000001\n#define E1000_TX_FLAGS_VLAN\t\t0x00000002\n#define E1000_TX_FLAGS_TSO\t\t0x00000004\n#define E1000_TX_FLAGS_IPV4\t\t0x00000008\n#define E1000_TX_FLAGS_NO_FCS\t\t0x00000010\n#define E1000_TX_FLAGS_HWTSTAMP\t\t0x00000020\n#define E1000_TX_FLAGS_VLAN_MASK\t0xffff0000\n#define E1000_TX_FLAGS_VLAN_SHIFT\t16\n\nstatic int e1000_tso(struct e1000_ring *tx_ring, struct sk_buff *skb,\n\t\t     __be16 protocol)\n{\n\tstruct e1000_context_desc *context_desc;\n\tstruct e1000_buffer *buffer_info;\n\tunsigned int i;\n\tu32 cmd_length = 0;\n\tu16 ipcse = 0, mss;\n\tu8 ipcss, ipcso, tucss, tucso, hdr_len;\n\tint err;\n\n\tif (!skb_is_gso(skb))\n\t\treturn 0;\n\n\terr = skb_cow_head(skb, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\thdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (protocol == htons(ETH_P_IP)) {\n\t\tstruct iphdr *iph = ip_hdr(skb);\n\t\tiph->tot_len = 0;\n\t\tiph->check = 0;\n\t\ttcp_hdr(skb)->check = ~csum_tcpudp_magic(iph->saddr, iph->daddr,\n\t\t\t\t\t\t\t 0, IPPROTO_TCP, 0);\n\t\tcmd_length = E1000_TXD_CMD_IP;\n\t\tipcse = skb_transport_offset(skb) - 1;\n\t} else if (skb_is_gso_v6(skb)) {\n\t\ttcp_v6_gso_csum_prep(skb);\n\t\tipcse = 0;\n\t}\n\tipcss = skb_network_offset(skb);\n\tipcso = (void *)&(ip_hdr(skb)->check) - (void *)skb->data;\n\ttucss = skb_transport_offset(skb);\n\ttucso = (void *)&(tcp_hdr(skb)->check) - (void *)skb->data;\n\n\tcmd_length |= (E1000_TXD_CMD_DEXT | E1000_TXD_CMD_TSE |\n\t\t       E1000_TXD_CMD_TCP | (skb->len - (hdr_len)));\n\n\ti = tx_ring->next_to_use;\n\tcontext_desc = E1000_CONTEXT_DESC(*tx_ring, i);\n\tbuffer_info = &tx_ring->buffer_info[i];\n\n\tcontext_desc->lower_setup.ip_fields.ipcss = ipcss;\n\tcontext_desc->lower_setup.ip_fields.ipcso = ipcso;\n\tcontext_desc->lower_setup.ip_fields.ipcse = cpu_to_le16(ipcse);\n\tcontext_desc->upper_setup.tcp_fields.tucss = tucss;\n\tcontext_desc->upper_setup.tcp_fields.tucso = tucso;\n\tcontext_desc->upper_setup.tcp_fields.tucse = 0;\n\tcontext_desc->tcp_seg_setup.fields.mss = cpu_to_le16(mss);\n\tcontext_desc->tcp_seg_setup.fields.hdr_len = hdr_len;\n\tcontext_desc->cmd_and_length = cpu_to_le32(cmd_length);\n\n\tbuffer_info->time_stamp = jiffies;\n\tbuffer_info->next_to_watch = i;\n\n\ti++;\n\tif (i == tx_ring->count)\n\t\ti = 0;\n\ttx_ring->next_to_use = i;\n\n\treturn 1;\n}\n\nstatic bool e1000_tx_csum(struct e1000_ring *tx_ring, struct sk_buff *skb,\n\t\t\t  __be16 protocol)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\tstruct e1000_context_desc *context_desc;\n\tstruct e1000_buffer *buffer_info;\n\tunsigned int i;\n\tu8 css;\n\tu32 cmd_len = E1000_TXD_CMD_DEXT;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn false;\n\n\tswitch (protocol) {\n\tcase cpu_to_be16(ETH_P_IP):\n\t\tif (ip_hdr(skb)->protocol == IPPROTO_TCP)\n\t\t\tcmd_len |= E1000_TXD_CMD_TCP;\n\t\tbreak;\n\tcase cpu_to_be16(ETH_P_IPV6):\n\t\t/* XXX not handling all IPV6 headers */\n\t\tif (ipv6_hdr(skb)->nexthdr == IPPROTO_TCP)\n\t\t\tcmd_len |= E1000_TXD_CMD_TCP;\n\t\tbreak;\n\tdefault:\n\t\tif (unlikely(net_ratelimit()))\n\t\t\te_warn(\"checksum_partial proto=%x!\\n\",\n\t\t\t       be16_to_cpu(protocol));\n\t\tbreak;\n\t}\n\n\tcss = skb_checksum_start_offset(skb);\n\n\ti = tx_ring->next_to_use;\n\tbuffer_info = &tx_ring->buffer_info[i];\n\tcontext_desc = E1000_CONTEXT_DESC(*tx_ring, i);\n\n\tcontext_desc->lower_setup.ip_config = 0;\n\tcontext_desc->upper_setup.tcp_fields.tucss = css;\n\tcontext_desc->upper_setup.tcp_fields.tucso = css + skb->csum_offset;\n\tcontext_desc->upper_setup.tcp_fields.tucse = 0;\n\tcontext_desc->tcp_seg_setup.data = 0;\n\tcontext_desc->cmd_and_length = cpu_to_le32(cmd_len);\n\n\tbuffer_info->time_stamp = jiffies;\n\tbuffer_info->next_to_watch = i;\n\n\ti++;\n\tif (i == tx_ring->count)\n\t\ti = 0;\n\ttx_ring->next_to_use = i;\n\n\treturn true;\n}\n\nstatic int e1000_tx_map(struct e1000_ring *tx_ring, struct sk_buff *skb,\n\t\t\tunsigned int first, unsigned int max_per_txd,\n\t\t\tunsigned int nr_frags)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\tstruct pci_dev *pdev = adapter->pdev;\n\tstruct e1000_buffer *buffer_info;\n\tunsigned int len = skb_headlen(skb);\n\tunsigned int offset = 0, size, count = 0, i;\n\tunsigned int f, bytecount, segs;\n\n\ti = tx_ring->next_to_use;\n\n\twhile (len) {\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\tsize = min(len, max_per_txd);\n\n\t\tbuffer_info->length = size;\n\t\tbuffer_info->time_stamp = jiffies;\n\t\tbuffer_info->next_to_watch = i;\n\t\tbuffer_info->dma = dma_map_single(&pdev->dev,\n\t\t\t\t\t\t  skb->data + offset,\n\t\t\t\t\t\t  size, DMA_TO_DEVICE);\n\t\tbuffer_info->mapped_as_page = false;\n\t\tif (dma_mapping_error(&pdev->dev, buffer_info->dma))\n\t\t\tgoto dma_error;\n\n\t\tlen -= size;\n\t\toffset += size;\n\t\tcount++;\n\n\t\tif (len) {\n\t\t\ti++;\n\t\t\tif (i == tx_ring->count)\n\t\t\t\ti = 0;\n\t\t}\n\t}\n\n\tfor (f = 0; f < nr_frags; f++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[f];\n\n\t\tlen = skb_frag_size(frag);\n\t\toffset = 0;\n\n\t\twhile (len) {\n\t\t\ti++;\n\t\t\tif (i == tx_ring->count)\n\t\t\t\ti = 0;\n\n\t\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\t\tsize = min(len, max_per_txd);\n\n\t\t\tbuffer_info->length = size;\n\t\t\tbuffer_info->time_stamp = jiffies;\n\t\t\tbuffer_info->next_to_watch = i;\n\t\t\tbuffer_info->dma = skb_frag_dma_map(&pdev->dev, frag,\n\t\t\t\t\t\t\t    offset, size,\n\t\t\t\t\t\t\t    DMA_TO_DEVICE);\n\t\t\tbuffer_info->mapped_as_page = true;\n\t\t\tif (dma_mapping_error(&pdev->dev, buffer_info->dma))\n\t\t\t\tgoto dma_error;\n\n\t\t\tlen -= size;\n\t\t\toffset += size;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tsegs = skb_shinfo(skb)->gso_segs ? : 1;\n\t/* multiply data chunks by size of headers */\n\tbytecount = ((segs - 1) * skb_headlen(skb)) + skb->len;\n\n\ttx_ring->buffer_info[i].skb = skb;\n\ttx_ring->buffer_info[i].segs = segs;\n\ttx_ring->buffer_info[i].bytecount = bytecount;\n\ttx_ring->buffer_info[first].next_to_watch = i;\n\n\treturn count;\n\ndma_error:\n\tdev_err(&pdev->dev, \"Tx DMA map failed\\n\");\n\tbuffer_info->dma = 0;\n\tif (count)\n\t\tcount--;\n\n\twhile (count--) {\n\t\tif (i == 0)\n\t\t\ti += tx_ring->count;\n\t\ti--;\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\te1000_put_txbuf(tx_ring, buffer_info, true);\n\t}\n\n\treturn 0;\n}\n\nstatic void e1000_tx_queue(struct e1000_ring *tx_ring, int tx_flags, int count)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\tstruct e1000_tx_desc *tx_desc = NULL;\n\tstruct e1000_buffer *buffer_info;\n\tu32 txd_upper = 0, txd_lower = E1000_TXD_CMD_IFCS;\n\tunsigned int i;\n\n\tif (tx_flags & E1000_TX_FLAGS_TSO) {\n\t\ttxd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D |\n\t\t    E1000_TXD_CMD_TSE;\n\t\ttxd_upper |= E1000_TXD_POPTS_TXSM << 8;\n\n\t\tif (tx_flags & E1000_TX_FLAGS_IPV4)\n\t\t\ttxd_upper |= E1000_TXD_POPTS_IXSM << 8;\n\t}\n\n\tif (tx_flags & E1000_TX_FLAGS_CSUM) {\n\t\ttxd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D;\n\t\ttxd_upper |= E1000_TXD_POPTS_TXSM << 8;\n\t}\n\n\tif (tx_flags & E1000_TX_FLAGS_VLAN) {\n\t\ttxd_lower |= E1000_TXD_CMD_VLE;\n\t\ttxd_upper |= (tx_flags & E1000_TX_FLAGS_VLAN_MASK);\n\t}\n\n\tif (unlikely(tx_flags & E1000_TX_FLAGS_NO_FCS))\n\t\ttxd_lower &= ~(E1000_TXD_CMD_IFCS);\n\n\tif (unlikely(tx_flags & E1000_TX_FLAGS_HWTSTAMP)) {\n\t\ttxd_lower |= E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D;\n\t\ttxd_upper |= E1000_TXD_EXTCMD_TSTAMP;\n\t}\n\n\ti = tx_ring->next_to_use;\n\n\tdo {\n\t\tbuffer_info = &tx_ring->buffer_info[i];\n\t\ttx_desc = E1000_TX_DESC(*tx_ring, i);\n\t\ttx_desc->buffer_addr = cpu_to_le64(buffer_info->dma);\n\t\ttx_desc->lower.data = cpu_to_le32(txd_lower |\n\t\t\t\t\t\t  buffer_info->length);\n\t\ttx_desc->upper.data = cpu_to_le32(txd_upper);\n\n\t\ti++;\n\t\tif (i == tx_ring->count)\n\t\t\ti = 0;\n\t} while (--count > 0);\n\n\ttx_desc->lower.data |= cpu_to_le32(adapter->txd_cmd);\n\n\t/* txd_cmd re-enables FCS, so we'll re-disable it here as desired. */\n\tif (unlikely(tx_flags & E1000_TX_FLAGS_NO_FCS))\n\t\ttx_desc->lower.data &= ~(cpu_to_le32(E1000_TXD_CMD_IFCS));\n\n\t/* Force memory writes to complete before letting h/w\n\t * know there are new descriptors to fetch.  (Only\n\t * applicable for weak-ordered memory model archs,\n\t * such as IA-64).\n\t */\n\twmb();\n\n\ttx_ring->next_to_use = i;\n}\n\n#define MINIMUM_DHCP_PACKET_SIZE 282\nstatic int e1000_transfer_dhcp_info(struct e1000_adapter *adapter,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 length, offset;\n\n\tif (skb_vlan_tag_present(skb) &&\n\t    !((skb_vlan_tag_get(skb) == adapter->hw.mng_cookie.vlan_id) &&\n\t      (adapter->hw.mng_cookie.status &\n\t       E1000_MNG_DHCP_COOKIE_STATUS_VLAN)))\n\t\treturn 0;\n\n\tif (skb->len <= MINIMUM_DHCP_PACKET_SIZE)\n\t\treturn 0;\n\n\tif (((struct ethhdr *)skb->data)->h_proto != htons(ETH_P_IP))\n\t\treturn 0;\n\n\t{\n\t\tconst struct iphdr *ip = (struct iphdr *)((u8 *)skb->data + 14);\n\t\tstruct udphdr *udp;\n\n\t\tif (ip->protocol != IPPROTO_UDP)\n\t\t\treturn 0;\n\n\t\tudp = (struct udphdr *)((u8 *)ip + (ip->ihl << 2));\n\t\tif (ntohs(udp->dest) != 67)\n\t\t\treturn 0;\n\n\t\toffset = (u8 *)udp + 8 - skb->data;\n\t\tlength = skb->len - offset;\n\t\treturn e1000e_mng_write_dhcp_info(hw, (u8 *)udp + 8, length);\n\t}\n\n\treturn 0;\n}\n\nstatic int __e1000_maybe_stop_tx(struct e1000_ring *tx_ring, int size)\n{\n\tstruct e1000_adapter *adapter = tx_ring->adapter;\n\n\tnetif_stop_queue(adapter->netdev);\n\t/* Herbert's original patch had:\n\t *  smp_mb__after_netif_stop_queue();\n\t * but since that doesn't exist yet, just open code it.\n\t */\n\tsmp_mb();\n\n\t/* We need to check again in a case another CPU has just\n\t * made room available.\n\t */\n\tif (e1000_desc_unused(tx_ring) < size)\n\t\treturn -EBUSY;\n\n\t/* A reprieve! */\n\tnetif_start_queue(adapter->netdev);\n\t++adapter->restart_queue;\n\treturn 0;\n}\n\nstatic int e1000_maybe_stop_tx(struct e1000_ring *tx_ring, int size)\n{\n\tBUG_ON(size > tx_ring->count);\n\n\tif (e1000_desc_unused(tx_ring) >= size)\n\t\treturn 0;\n\treturn __e1000_maybe_stop_tx(tx_ring, size);\n}\n\nstatic netdev_tx_t e1000_xmit_frame(struct sk_buff *skb,\n\t\t\t\t    struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_ring *tx_ring = adapter->tx_ring;\n\tunsigned int first;\n\tunsigned int tx_flags = 0;\n\tunsigned int len = skb_headlen(skb);\n\tunsigned int nr_frags;\n\tunsigned int mss;\n\tint count = 0;\n\tint tso;\n\tunsigned int f;\n\t__be16 protocol = vlan_get_protocol(skb);\n\n\tif (test_bit(__E1000_DOWN, &adapter->state)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (skb->len <= 0) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t/* The minimum packet size with TCTL.PSP set is 17 bytes so\n\t * pad skb in order to meet this minimum size requirement\n\t */\n\tif (skb_put_padto(skb, 17))\n\t\treturn NETDEV_TX_OK;\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (mss) {\n\t\tu8 hdr_len;\n\n\t\t/* TSO Workaround for 82571/2/3 Controllers -- if skb->data\n\t\t * points to just header, pull a few bytes of payload from\n\t\t * frags into skb->data\n\t\t */\n\t\thdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb);\n\t\t/* we do this workaround for ES2LAN, but it is un-necessary,\n\t\t * avoiding it could save a lot of cycles\n\t\t */\n\t\tif (skb->data_len && (hdr_len == len)) {\n\t\t\tunsigned int pull_size;\n\n\t\t\tpull_size = min_t(unsigned int, 4, skb->data_len);\n\t\t\tif (!__pskb_pull_tail(skb, pull_size)) {\n\t\t\t\te_err(\"__pskb_pull_tail failed.\\n\");\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t}\n\t\t\tlen = skb_headlen(skb);\n\t\t}\n\t}\n\n\t/* reserve a descriptor for the offload context */\n\tif ((mss) || (skb->ip_summed == CHECKSUM_PARTIAL))\n\t\tcount++;\n\tcount++;\n\n\tcount += DIV_ROUND_UP(len, adapter->tx_fifo_limit);\n\n\tnr_frags = skb_shinfo(skb)->nr_frags;\n\tfor (f = 0; f < nr_frags; f++)\n\t\tcount += DIV_ROUND_UP(skb_frag_size(&skb_shinfo(skb)->frags[f]),\n\t\t\t\t      adapter->tx_fifo_limit);\n\n\tif (adapter->hw.mac.tx_pkt_filtering)\n\t\te1000_transfer_dhcp_info(adapter, skb);\n\n\t/* need: count + 2 desc gap to keep tail from touching\n\t * head, otherwise try next time\n\t */\n\tif (e1000_maybe_stop_tx(tx_ring, count + 2))\n\t\treturn NETDEV_TX_BUSY;\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\ttx_flags |= E1000_TX_FLAGS_VLAN;\n\t\ttx_flags |= (skb_vlan_tag_get(skb) <<\n\t\t\t     E1000_TX_FLAGS_VLAN_SHIFT);\n\t}\n\n\tfirst = tx_ring->next_to_use;\n\n\ttso = e1000_tso(tx_ring, skb, protocol);\n\tif (tso < 0) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (tso)\n\t\ttx_flags |= E1000_TX_FLAGS_TSO;\n\telse if (e1000_tx_csum(tx_ring, skb, protocol))\n\t\ttx_flags |= E1000_TX_FLAGS_CSUM;\n\n\t/* Old method was to assume IPv4 packet by default if TSO was enabled.\n\t * 82571 hardware supports TSO capabilities for IPv6 as well...\n\t * no longer assume, we must.\n\t */\n\tif (protocol == htons(ETH_P_IP))\n\t\ttx_flags |= E1000_TX_FLAGS_IPV4;\n\n\tif (unlikely(skb->no_fcs))\n\t\ttx_flags |= E1000_TX_FLAGS_NO_FCS;\n\n\t/* if count is 0 then mapping error has occurred */\n\tcount = e1000_tx_map(tx_ring, skb, first, adapter->tx_fifo_limit,\n\t\t\t     nr_frags);\n\tif (count) {\n\t\tif (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&\n\t\t    (adapter->flags & FLAG_HAS_HW_TIMESTAMP)) {\n\t\t\tif (!adapter->tx_hwtstamp_skb) {\n\t\t\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\t\t\t\ttx_flags |= E1000_TX_FLAGS_HWTSTAMP;\n\t\t\t\tadapter->tx_hwtstamp_skb = skb_get(skb);\n\t\t\t\tadapter->tx_hwtstamp_start = jiffies;\n\t\t\t\tschedule_work(&adapter->tx_hwtstamp_work);\n\t\t\t} else {\n\t\t\t\tadapter->tx_hwtstamp_skipped++;\n\t\t\t}\n\t\t}\n\n\t\tskb_tx_timestamp(skb);\n\n\t\tnetdev_sent_queue(netdev, skb->len);\n\t\te1000_tx_queue(tx_ring, tx_flags, count);\n\t\t/* Make sure there is space in the ring for the next send. */\n\t\te1000_maybe_stop_tx(tx_ring,\n\t\t\t\t    (MAX_SKB_FRAGS *\n\t\t\t\t     DIV_ROUND_UP(PAGE_SIZE,\n\t\t\t\t\t\t  adapter->tx_fifo_limit) + 2));\n\n\t\tif (!netdev_xmit_more() ||\n\t\t    netif_xmit_stopped(netdev_get_tx_queue(netdev, 0))) {\n\t\t\tif (adapter->flags2 & FLAG2_PCIM2PCI_ARBITER_WA)\n\t\t\t\te1000e_update_tdt_wa(tx_ring,\n\t\t\t\t\t\t     tx_ring->next_to_use);\n\t\t\telse\n\t\t\t\twritel(tx_ring->next_to_use, tx_ring->tail);\n\t\t}\n\t} else {\n\t\tdev_kfree_skb_any(skb);\n\t\ttx_ring->buffer_info[first].time_stamp = 0;\n\t\ttx_ring->next_to_use = first;\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n/**\n * e1000_tx_timeout - Respond to a Tx Hang\n * @netdev: network interface device structure\n * @txqueue: index of the hung queue (unused)\n **/\nstatic void e1000_tx_timeout(struct net_device *netdev, unsigned int __always_unused txqueue)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\t/* Do the reset outside of interrupt context */\n\tadapter->tx_timeout_count++;\n\tschedule_work(&adapter->reset_task);\n}\n\nstatic void e1000_reset_task(struct work_struct *work)\n{\n\tstruct e1000_adapter *adapter;\n\tadapter = container_of(work, struct e1000_adapter, reset_task);\n\n\t/* don't run the task if already down */\n\tif (test_bit(__E1000_DOWN, &adapter->state))\n\t\treturn;\n\n\tif (!(adapter->flags & FLAG_RESTART_NOW)) {\n\t\te1000e_dump(adapter);\n\t\te_err(\"Reset adapter unexpectedly\\n\");\n\t}\n\te1000e_reinit_locked(adapter);\n}\n\n/**\n * e1000_get_stats64 - Get System Network Statistics\n * @netdev: network interface device structure\n * @stats: rtnl_link_stats64 pointer\n *\n * Returns the address of the device statistics structure.\n **/\nvoid e1000e_get_stats64(struct net_device *netdev,\n\t\t\tstruct rtnl_link_stats64 *stats)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tspin_lock(&adapter->stats64_lock);\n\te1000e_update_stats(adapter);\n\t/* Fill out the OS statistics structure */\n\tstats->rx_bytes = adapter->stats.gorc;\n\tstats->rx_packets = adapter->stats.gprc;\n\tstats->tx_bytes = adapter->stats.gotc;\n\tstats->tx_packets = adapter->stats.gptc;\n\tstats->multicast = adapter->stats.mprc;\n\tstats->collisions = adapter->stats.colc;\n\n\t/* Rx Errors */\n\n\t/* RLEC on some newer hardware can be incorrect so build\n\t * our own version based on RUC and ROC\n\t */\n\tstats->rx_errors = adapter->stats.rxerrc +\n\t    adapter->stats.crcerrs + adapter->stats.algnerrc +\n\t    adapter->stats.ruc + adapter->stats.roc + adapter->stats.cexterr;\n\tstats->rx_length_errors = adapter->stats.ruc + adapter->stats.roc;\n\tstats->rx_crc_errors = adapter->stats.crcerrs;\n\tstats->rx_frame_errors = adapter->stats.algnerrc;\n\tstats->rx_missed_errors = adapter->stats.mpc;\n\n\t/* Tx Errors */\n\tstats->tx_errors = adapter->stats.ecol + adapter->stats.latecol;\n\tstats->tx_aborted_errors = adapter->stats.ecol;\n\tstats->tx_window_errors = adapter->stats.latecol;\n\tstats->tx_carrier_errors = adapter->stats.tncrs;\n\n\t/* Tx Dropped needs to be maintained elsewhere */\n\n\tspin_unlock(&adapter->stats64_lock);\n}\n\n/**\n * e1000_change_mtu - Change the Maximum Transfer Unit\n * @netdev: network interface device structure\n * @new_mtu: new value for maximum frame size\n *\n * Returns 0 on success, negative on failure\n **/\nstatic int e1000_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tint max_frame = new_mtu + VLAN_ETH_HLEN + ETH_FCS_LEN;\n\n\t/* Jumbo frame support */\n\tif ((new_mtu > ETH_DATA_LEN) &&\n\t    !(adapter->flags & FLAG_HAS_JUMBO_FRAMES)) {\n\t\te_err(\"Jumbo Frames not supported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Jumbo frame workaround on 82579 and newer requires CRC be stripped */\n\tif ((adapter->hw.mac.type >= e1000_pch2lan) &&\n\t    !(adapter->flags2 & FLAG2_CRC_STRIPPING) &&\n\t    (new_mtu > ETH_DATA_LEN)) {\n\t\te_err(\"Jumbo Frames not supported on this device when CRC stripping is disabled.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twhile (test_and_set_bit(__E1000_RESETTING, &adapter->state))\n\t\tusleep_range(1000, 1100);\n\t/* e1000e_down -> e1000e_reset dependent on max_frame_size & mtu */\n\tadapter->max_frame_size = max_frame;\n\tnetdev_dbg(netdev, \"changing MTU from %d to %d\\n\",\n\t\t   netdev->mtu, new_mtu);\n\tnetdev->mtu = new_mtu;\n\n\tpm_runtime_get_sync(netdev->dev.parent);\n\n\tif (netif_running(netdev))\n\t\te1000e_down(adapter, true);\n\n\t/* NOTE: netdev_alloc_skb reserves 16 bytes, and typically NET_IP_ALIGN\n\t * means we reserve 2 more, this pushes us to allocate from the next\n\t * larger slab size.\n\t * i.e. RXBUFFER_2048 --> size-4096 slab\n\t * However with the new *_jumbo_rx* routines, jumbo receives will use\n\t * fragmented skbs\n\t */\n\n\tif (max_frame <= 2048)\n\t\tadapter->rx_buffer_len = 2048;\n\telse\n\t\tadapter->rx_buffer_len = 4096;\n\n\t/* adjust allocation if LPE protects us, and we aren't using SBP */\n\tif (max_frame <= (VLAN_ETH_FRAME_LEN + ETH_FCS_LEN))\n\t\tadapter->rx_buffer_len = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;\n\n\tif (netif_running(netdev))\n\t\te1000e_up(adapter);\n\telse\n\t\te1000e_reset(adapter);\n\n\tpm_runtime_put_sync(netdev->dev.parent);\n\n\tclear_bit(__E1000_RESETTING, &adapter->state);\n\n\treturn 0;\n}\n\nstatic int e1000_mii_ioctl(struct net_device *netdev, struct ifreq *ifr,\n\t\t\t   int cmd)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct mii_ioctl_data *data = if_mii(ifr);\n\n\tif (adapter->hw.phy.media_type != e1000_media_type_copper)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tdata->phy_id = adapter->hw.phy.addr;\n\t\tbreak;\n\tcase SIOCGMIIREG:\n\t\te1000_phy_read_status(adapter);\n\n\t\tswitch (data->reg_num & 0x1F) {\n\t\tcase MII_BMCR:\n\t\t\tdata->val_out = adapter->phy_regs.bmcr;\n\t\t\tbreak;\n\t\tcase MII_BMSR:\n\t\t\tdata->val_out = adapter->phy_regs.bmsr;\n\t\t\tbreak;\n\t\tcase MII_PHYSID1:\n\t\t\tdata->val_out = (adapter->hw.phy.id >> 16);\n\t\t\tbreak;\n\t\tcase MII_PHYSID2:\n\t\t\tdata->val_out = (adapter->hw.phy.id & 0xFFFF);\n\t\t\tbreak;\n\t\tcase MII_ADVERTISE:\n\t\t\tdata->val_out = adapter->phy_regs.advertise;\n\t\t\tbreak;\n\t\tcase MII_LPA:\n\t\t\tdata->val_out = adapter->phy_regs.lpa;\n\t\t\tbreak;\n\t\tcase MII_EXPANSION:\n\t\t\tdata->val_out = adapter->phy_regs.expansion;\n\t\t\tbreak;\n\t\tcase MII_CTRL1000:\n\t\t\tdata->val_out = adapter->phy_regs.ctrl1000;\n\t\t\tbreak;\n\t\tcase MII_STAT1000:\n\t\t\tdata->val_out = adapter->phy_regs.stat1000;\n\t\t\tbreak;\n\t\tcase MII_ESTATUS:\n\t\t\tdata->val_out = adapter->phy_regs.estatus;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\tcase SIOCSMIIREG:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n/**\n * e1000e_hwtstamp_ioctl - control hardware time stamping\n * @netdev: network interface device structure\n * @ifr: interface request\n *\n * Outgoing time stamping can be enabled and disabled. Play nice and\n * disable it when requested, although it shouldn't cause any overhead\n * when no packet needs it. At most one packet in the queue may be\n * marked for time stamping, otherwise it would be impossible to tell\n * for sure to which packet the hardware time stamp belongs.\n *\n * Incoming time stamping has to be configured via the hardware filters.\n * Not all combinations are supported, in particular event type has to be\n * specified. Matching the kind of event packet is not supported, with the\n * exception of \"all V2 events regardless of level 2 or 4\".\n **/\nstatic int e1000e_hwtstamp_set(struct net_device *netdev, struct ifreq *ifr)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct hwtstamp_config config;\n\tint ret_val;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\tret_val = e1000e_config_hwtstamp(adapter, &config);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tswitch (config.rx_filter) {\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\t/* With V2 type filters which specify a Sync or Delay Request,\n\t\t * Path Delay Request/Response messages are also time stamped\n\t\t * by hardware so notify the caller the requested packets plus\n\t\t * some others are time stamped.\n\t\t */\n\t\tconfig.rx_filter = HWTSTAMP_FILTER_SOME;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn copy_to_user(ifr->ifr_data, &config,\n\t\t\t    sizeof(config)) ? -EFAULT : 0;\n}\n\nstatic int e1000e_hwtstamp_get(struct net_device *netdev, struct ifreq *ifr)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\treturn copy_to_user(ifr->ifr_data, &adapter->hwtstamp_config,\n\t\t\t    sizeof(adapter->hwtstamp_config)) ? -EFAULT : 0;\n}\n\nstatic int e1000_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\treturn e1000_mii_ioctl(netdev, ifr, cmd);\n\tcase SIOCSHWTSTAMP:\n\t\treturn e1000e_hwtstamp_set(netdev, ifr);\n\tcase SIOCGHWTSTAMP:\n\t\treturn e1000e_hwtstamp_get(netdev, ifr);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int e1000_init_phy_wakeup(struct e1000_adapter *adapter, u32 wufc)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 i, mac_reg, wuc;\n\tu16 phy_reg, wuc_enable;\n\tint retval;\n\n\t/* copy MAC RARs to PHY RARs */\n\te1000_copy_rx_addrs_to_phy_ich8lan(hw);\n\n\tretval = hw->phy.ops.acquire(hw);\n\tif (retval) {\n\t\te_err(\"Could not acquire PHY\\n\");\n\t\treturn retval;\n\t}\n\n\t/* Enable access to wakeup registers on and set page to BM_WUC_PAGE */\n\tretval = e1000_enable_phy_wakeup_reg_access_bm(hw, &wuc_enable);\n\tif (retval)\n\t\tgoto release;\n\n\t/* copy MAC MTA to PHY MTA - only needed for pchlan */\n\tfor (i = 0; i < adapter->hw.mac.mta_reg_count; i++) {\n\t\tmac_reg = E1000_READ_REG_ARRAY(hw, E1000_MTA, i);\n\t\thw->phy.ops.write_reg_page(hw, BM_MTA(i),\n\t\t\t\t\t   (u16)(mac_reg & 0xFFFF));\n\t\thw->phy.ops.write_reg_page(hw, BM_MTA(i) + 1,\n\t\t\t\t\t   (u16)((mac_reg >> 16) & 0xFFFF));\n\t}\n\n\t/* configure PHY Rx Control register */\n\thw->phy.ops.read_reg_page(&adapter->hw, BM_RCTL, &phy_reg);\n\tmac_reg = er32(RCTL);\n\tif (mac_reg & E1000_RCTL_UPE)\n\t\tphy_reg |= BM_RCTL_UPE;\n\tif (mac_reg & E1000_RCTL_MPE)\n\t\tphy_reg |= BM_RCTL_MPE;\n\tphy_reg &= ~(BM_RCTL_MO_MASK);\n\tif (mac_reg & E1000_RCTL_MO_3)\n\t\tphy_reg |= (((mac_reg & E1000_RCTL_MO_3) >> E1000_RCTL_MO_SHIFT)\n\t\t\t    << BM_RCTL_MO_SHIFT);\n\tif (mac_reg & E1000_RCTL_BAM)\n\t\tphy_reg |= BM_RCTL_BAM;\n\tif (mac_reg & E1000_RCTL_PMCF)\n\t\tphy_reg |= BM_RCTL_PMCF;\n\tmac_reg = er32(CTRL);\n\tif (mac_reg & E1000_CTRL_RFCE)\n\t\tphy_reg |= BM_RCTL_RFCE;\n\thw->phy.ops.write_reg_page(&adapter->hw, BM_RCTL, phy_reg);\n\n\twuc = E1000_WUC_PME_EN;\n\tif (wufc & (E1000_WUFC_MAG | E1000_WUFC_LNKC))\n\t\twuc |= E1000_WUC_APME;\n\n\t/* enable PHY wakeup in MAC register */\n\tew32(WUFC, wufc);\n\tew32(WUC, (E1000_WUC_PHY_WAKE | E1000_WUC_APMPME |\n\t\t   E1000_WUC_PME_STATUS | wuc));\n\n\t/* configure and enable PHY wakeup in PHY registers */\n\thw->phy.ops.write_reg_page(&adapter->hw, BM_WUFC, wufc);\n\thw->phy.ops.write_reg_page(&adapter->hw, BM_WUC, wuc);\n\n\t/* activate PHY wakeup */\n\twuc_enable |= BM_WUC_ENABLE_BIT | BM_WUC_HOST_WU_BIT;\n\tretval = e1000_disable_phy_wakeup_reg_access_bm(hw, &wuc_enable);\n\tif (retval)\n\t\te_err(\"Could not set PHY Host Wakeup bit\\n\");\nrelease:\n\thw->phy.ops.release(hw);\n\n\treturn retval;\n}\n\nstatic void e1000e_flush_lpic(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ret_val;\n\n\tpm_runtime_get_sync(netdev->dev.parent);\n\n\tret_val = hw->phy.ops.acquire(hw);\n\tif (ret_val)\n\t\tgoto fl_out;\n\n\tpr_info(\"EEE TX LPI TIMER: %08X\\n\",\n\t\ter32(LPIC) >> E1000_LPIC_LPIET_SHIFT);\n\n\thw->phy.ops.release(hw);\n\nfl_out:\n\tpm_runtime_put_sync(netdev->dev.parent);\n}\n\n/* S0ix implementation */\nstatic void e1000e_s0ix_entry_flow(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 mac_data;\n\tu16 phy_data;\n\n\t/* Disable the periodic inband message,\n\t * don't request PCIe clock in K1 page770_17[10:9] = 10b\n\t */\n\te1e_rphy(hw, HV_PM_CTRL, &phy_data);\n\tphy_data &= ~HV_PM_CTRL_K1_CLK_REQ;\n\tphy_data |= BIT(10);\n\te1e_wphy(hw, HV_PM_CTRL, phy_data);\n\n\t/* Make sure we don't exit K1 every time a new packet arrives\n\t * 772_29[5] = 1 CS_Mode_Stay_In_K1\n\t */\n\te1e_rphy(hw, I217_CGFREG, &phy_data);\n\tphy_data |= BIT(5);\n\te1e_wphy(hw, I217_CGFREG, phy_data);\n\n\t/* Change the MAC/PHY interface to SMBus\n\t * Force the SMBus in PHY page769_23[0] = 1\n\t * Force the SMBus in MAC CTRL_EXT[11] = 1\n\t */\n\te1e_rphy(hw, CV_SMB_CTRL, &phy_data);\n\tphy_data |= CV_SMB_CTRL_FORCE_SMBUS;\n\te1e_wphy(hw, CV_SMB_CTRL, phy_data);\n\tmac_data = er32(CTRL_EXT);\n\tmac_data |= E1000_CTRL_EXT_FORCE_SMBUS;\n\tew32(CTRL_EXT, mac_data);\n\n\t/* DFT control: PHY bit: page769_20[0] = 1\n\t * Gate PPW via EXTCNF_CTRL - set 0x0F00[7] = 1\n\t */\n\te1e_rphy(hw, I82579_DFT_CTRL, &phy_data);\n\tphy_data |= BIT(0);\n\te1e_wphy(hw, I82579_DFT_CTRL, phy_data);\n\n\tmac_data = er32(EXTCNF_CTRL);\n\tmac_data |= E1000_EXTCNF_CTRL_GATE_PHY_CFG;\n\tew32(EXTCNF_CTRL, mac_data);\n\n\t/* Check MAC Tx/Rx packet buffer pointers.\n\t * Reset MAC Tx/Rx packet buffer pointers to suppress any\n\t * pending traffic indication that would prevent power gating.\n\t */\n\tmac_data = er32(TDFH);\n\tif (mac_data)\n\t\tew32(TDFH, 0);\n\tmac_data = er32(TDFT);\n\tif (mac_data)\n\t\tew32(TDFT, 0);\n\tmac_data = er32(TDFHS);\n\tif (mac_data)\n\t\tew32(TDFHS, 0);\n\tmac_data = er32(TDFTS);\n\tif (mac_data)\n\t\tew32(TDFTS, 0);\n\tmac_data = er32(TDFPC);\n\tif (mac_data)\n\t\tew32(TDFPC, 0);\n\tmac_data = er32(RDFH);\n\tif (mac_data)\n\t\tew32(RDFH, 0);\n\tmac_data = er32(RDFT);\n\tif (mac_data)\n\t\tew32(RDFT, 0);\n\tmac_data = er32(RDFHS);\n\tif (mac_data)\n\t\tew32(RDFHS, 0);\n\tmac_data = er32(RDFTS);\n\tif (mac_data)\n\t\tew32(RDFTS, 0);\n\tmac_data = er32(RDFPC);\n\tif (mac_data)\n\t\tew32(RDFPC, 0);\n\n\t/* Enable the Dynamic Power Gating in the MAC */\n\tmac_data = er32(FEXTNVM7);\n\tmac_data |= BIT(22);\n\tew32(FEXTNVM7, mac_data);\n\n\t/* Disable the time synchronization clock */\n\tmac_data = er32(FEXTNVM7);\n\tmac_data |= BIT(31);\n\tmac_data &= ~BIT(0);\n\tew32(FEXTNVM7, mac_data);\n\n\t/* Dynamic Power Gating Enable */\n\tmac_data = er32(CTRL_EXT);\n\tmac_data |= BIT(3);\n\tew32(CTRL_EXT, mac_data);\n\n\t/* Disable disconnected cable conditioning for Power Gating */\n\tmac_data = er32(DPGFR);\n\tmac_data |= BIT(2);\n\tew32(DPGFR, mac_data);\n\n\t/* Don't wake from dynamic Power Gating with clock request */\n\tmac_data = er32(FEXTNVM12);\n\tmac_data |= BIT(12);\n\tew32(FEXTNVM12, mac_data);\n\n\t/* Ungate PGCB clock */\n\tmac_data = er32(FEXTNVM9);\n\tmac_data &= ~BIT(28);\n\tew32(FEXTNVM9, mac_data);\n\n\t/* Enable K1 off to enable mPHY Power Gating */\n\tmac_data = er32(FEXTNVM6);\n\tmac_data |= BIT(31);\n\tew32(FEXTNVM6, mac_data);\n\n\t/* Enable mPHY power gating for any link and speed */\n\tmac_data = er32(FEXTNVM8);\n\tmac_data |= BIT(9);\n\tew32(FEXTNVM8, mac_data);\n\n\t/* Enable the Dynamic Clock Gating in the DMA and MAC */\n\tmac_data = er32(CTRL_EXT);\n\tmac_data |= E1000_CTRL_EXT_DMA_DYN_CLK_EN;\n\tew32(CTRL_EXT, mac_data);\n\n\t/* No MAC DPG gating SLP_S0 in modern standby\n\t * Switch the logic of the lanphypc to use PMC counter\n\t */\n\tmac_data = er32(FEXTNVM5);\n\tmac_data |= BIT(7);\n\tew32(FEXTNVM5, mac_data);\n}\n\nstatic void e1000e_s0ix_exit_flow(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 mac_data;\n\tu16 phy_data;\n\n\t/* Disable the Dynamic Power Gating in the MAC */\n\tmac_data = er32(FEXTNVM7);\n\tmac_data &= 0xFFBFFFFF;\n\tew32(FEXTNVM7, mac_data);\n\n\t/* Enable the time synchronization clock */\n\tmac_data = er32(FEXTNVM7);\n\tmac_data |= BIT(0);\n\tew32(FEXTNVM7, mac_data);\n\n\t/* Disable mPHY power gating for any link and speed */\n\tmac_data = er32(FEXTNVM8);\n\tmac_data &= ~BIT(9);\n\tew32(FEXTNVM8, mac_data);\n\n\t/* Disable K1 off */\n\tmac_data = er32(FEXTNVM6);\n\tmac_data &= ~BIT(31);\n\tew32(FEXTNVM6, mac_data);\n\n\t/* Disable Ungate PGCB clock */\n\tmac_data = er32(FEXTNVM9);\n\tmac_data |= BIT(28);\n\tew32(FEXTNVM9, mac_data);\n\n\t/* Cancel not waking from dynamic\n\t * Power Gating with clock request\n\t */\n\tmac_data = er32(FEXTNVM12);\n\tmac_data &= ~BIT(12);\n\tew32(FEXTNVM12, mac_data);\n\n\t/* Cancel disable disconnected cable conditioning\n\t * for Power Gating\n\t */\n\tmac_data = er32(DPGFR);\n\tmac_data &= ~BIT(2);\n\tew32(DPGFR, mac_data);\n\n\t/* Disable Dynamic Power Gating */\n\tmac_data = er32(CTRL_EXT);\n\tmac_data &= 0xFFFFFFF7;\n\tew32(CTRL_EXT, mac_data);\n\n\t/* Disable the Dynamic Clock Gating in the DMA and MAC */\n\tmac_data = er32(CTRL_EXT);\n\tmac_data &= 0xFFF7FFFF;\n\tew32(CTRL_EXT, mac_data);\n\n\t/* Revert the lanphypc logic to use the internal Gbe counter\n\t * and not the PMC counter\n\t */\n\tmac_data = er32(FEXTNVM5);\n\tmac_data &= 0xFFFFFF7F;\n\tew32(FEXTNVM5, mac_data);\n\n\t/* Enable the periodic inband message,\n\t * Request PCIe clock in K1 page770_17[10:9] =01b\n\t */\n\te1e_rphy(hw, HV_PM_CTRL, &phy_data);\n\tphy_data &= 0xFBFF;\n\tphy_data |= HV_PM_CTRL_K1_CLK_REQ;\n\te1e_wphy(hw, HV_PM_CTRL, phy_data);\n\n\t/* Return back configuration\n\t * 772_29[5] = 0 CS_Mode_Stay_In_K1\n\t */\n\te1e_rphy(hw, I217_CGFREG, &phy_data);\n\tphy_data &= 0xFFDF;\n\te1e_wphy(hw, I217_CGFREG, phy_data);\n\n\t/* Change the MAC/PHY interface to Kumeran\n\t * Unforce the SMBus in PHY page769_23[0] = 0\n\t * Unforce the SMBus in MAC CTRL_EXT[11] = 0\n\t */\n\te1e_rphy(hw, CV_SMB_CTRL, &phy_data);\n\tphy_data &= ~CV_SMB_CTRL_FORCE_SMBUS;\n\te1e_wphy(hw, CV_SMB_CTRL, phy_data);\n\tmac_data = er32(CTRL_EXT);\n\tmac_data &= ~E1000_CTRL_EXT_FORCE_SMBUS;\n\tew32(CTRL_EXT, mac_data);\n}\n\nstatic int e1000e_pm_freeze(struct device *dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tbool present;\n\n\trtnl_lock();\n\n\tpresent = netif_device_present(netdev);\n\tnetif_device_detach(netdev);\n\n\tif (present && netif_running(netdev)) {\n\t\tint count = E1000_CHECK_RESET_COUNT;\n\n\t\twhile (test_bit(__E1000_RESETTING, &adapter->state) && count--)\n\t\t\tusleep_range(10000, 11000);\n\n\t\tWARN_ON(test_bit(__E1000_RESETTING, &adapter->state));\n\n\t\t/* Quiesce the device without resetting the hardware */\n\t\te1000e_down(adapter, false);\n\t\te1000_free_irq(adapter);\n\t}\n\trtnl_unlock();\n\n\te1000e_reset_interrupt_capability(adapter);\n\n\t/* Allow time for pending master requests to run */\n\te1000e_disable_pcie_master(&adapter->hw);\n\n\treturn 0;\n}\n\nstatic int __e1000_shutdown(struct pci_dev *pdev, bool runtime)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu32 ctrl, ctrl_ext, rctl, status, wufc;\n\tint retval = 0;\n\n\t/* Runtime suspend should only enable wakeup for link changes */\n\tif (runtime)\n\t\twufc = E1000_WUFC_LNKC;\n\telse if (device_may_wakeup(&pdev->dev))\n\t\twufc = adapter->wol;\n\telse\n\t\twufc = 0;\n\n\tstatus = er32(STATUS);\n\tif (status & E1000_STATUS_LU)\n\t\twufc &= ~E1000_WUFC_LNKC;\n\n\tif (wufc) {\n\t\te1000_setup_rctl(adapter);\n\t\te1000e_set_rx_mode(netdev);\n\n\t\t/* turn on all-multi mode if wake on multicast is enabled */\n\t\tif (wufc & E1000_WUFC_MC) {\n\t\t\trctl = er32(RCTL);\n\t\t\trctl |= E1000_RCTL_MPE;\n\t\t\tew32(RCTL, rctl);\n\t\t}\n\n\t\tctrl = er32(CTRL);\n\t\tctrl |= E1000_CTRL_ADVD3WUC;\n\t\tif (!(adapter->flags2 & FLAG2_HAS_PHY_WAKEUP))\n\t\t\tctrl |= E1000_CTRL_EN_PHY_PWR_MGMT;\n\t\tew32(CTRL, ctrl);\n\n\t\tif (adapter->hw.phy.media_type == e1000_media_type_fiber ||\n\t\t    adapter->hw.phy.media_type ==\n\t\t    e1000_media_type_internal_serdes) {\n\t\t\t/* keep the laser running in D3 */\n\t\t\tctrl_ext = er32(CTRL_EXT);\n\t\t\tctrl_ext |= E1000_CTRL_EXT_SDP3_DATA;\n\t\t\tew32(CTRL_EXT, ctrl_ext);\n\t\t}\n\n\t\tif (!runtime)\n\t\t\te1000e_power_up_phy(adapter);\n\n\t\tif (adapter->flags & FLAG_IS_ICH)\n\t\t\te1000_suspend_workarounds_ich8lan(&adapter->hw);\n\n\t\tif (adapter->flags2 & FLAG2_HAS_PHY_WAKEUP) {\n\t\t\t/* enable wakeup by the PHY */\n\t\t\tretval = e1000_init_phy_wakeup(adapter, wufc);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t} else {\n\t\t\t/* enable wakeup by the MAC */\n\t\t\tew32(WUFC, wufc);\n\t\t\tew32(WUC, E1000_WUC_PME_EN);\n\t\t}\n\t} else {\n\t\tew32(WUC, 0);\n\t\tew32(WUFC, 0);\n\n\t\te1000_power_down_phy(adapter);\n\t}\n\n\tif (adapter->hw.phy.type == e1000_phy_igp_3) {\n\t\te1000e_igp3_phy_powerdown_workaround_ich8lan(&adapter->hw);\n\t} else if (hw->mac.type >= e1000_pch_lpt) {\n\t\tif (wufc && !(wufc & (E1000_WUFC_EX | E1000_WUFC_MC | E1000_WUFC_BC)))\n\t\t\t/* ULP does not support wake from unicast, multicast\n\t\t\t * or broadcast.\n\t\t\t */\n\t\t\tretval = e1000_enable_ulp_lpt_lp(hw, !runtime);\n\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t/* Ensure that the appropriate bits are set in LPI_CTRL\n\t * for EEE in Sx\n\t */\n\tif ((hw->phy.type >= e1000_phy_i217) &&\n\t    adapter->eee_advert && hw->dev_spec.ich8lan.eee_lp_ability) {\n\t\tu16 lpi_ctrl = 0;\n\n\t\tretval = hw->phy.ops.acquire(hw);\n\t\tif (!retval) {\n\t\t\tretval = e1e_rphy_locked(hw, I82579_LPI_CTRL,\n\t\t\t\t\t\t &lpi_ctrl);\n\t\t\tif (!retval) {\n\t\t\t\tif (adapter->eee_advert &\n\t\t\t\t    hw->dev_spec.ich8lan.eee_lp_ability &\n\t\t\t\t    I82579_EEE_100_SUPPORTED)\n\t\t\t\t\tlpi_ctrl |= I82579_LPI_CTRL_100_ENABLE;\n\t\t\t\tif (adapter->eee_advert &\n\t\t\t\t    hw->dev_spec.ich8lan.eee_lp_ability &\n\t\t\t\t    I82579_EEE_1000_SUPPORTED)\n\t\t\t\t\tlpi_ctrl |= I82579_LPI_CTRL_1000_ENABLE;\n\n\t\t\t\tretval = e1e_wphy_locked(hw, I82579_LPI_CTRL,\n\t\t\t\t\t\t\t lpi_ctrl);\n\t\t\t}\n\t\t}\n\t\thw->phy.ops.release(hw);\n\t}\n\n\t/* Release control of h/w to f/w.  If f/w is AMT enabled, this\n\t * would have already happened in close and is redundant.\n\t */\n\te1000e_release_hw_control(adapter);\n\n\tpci_clear_master(pdev);\n\n\t/* The pci-e switch on some quad port adapters will report a\n\t * correctable error when the MAC transitions from D0 to D3.  To\n\t * prevent this we need to mask off the correctable errors on the\n\t * downstream port of the pci-e switch.\n\t *\n\t * We don't have the associated upstream bridge while assigning\n\t * the PCI device into guest. For example, the KVM on power is\n\t * one of the cases.\n\t */\n\tif (adapter->flags & FLAG_IS_QUAD_PORT) {\n\t\tstruct pci_dev *us_dev = pdev->bus->self;\n\t\tu16 devctl;\n\n\t\tif (!us_dev)\n\t\t\treturn 0;\n\n\t\tpcie_capability_read_word(us_dev, PCI_EXP_DEVCTL, &devctl);\n\t\tpcie_capability_write_word(us_dev, PCI_EXP_DEVCTL,\n\t\t\t\t\t   (devctl & ~PCI_EXP_DEVCTL_CERE));\n\n\t\tpci_save_state(pdev);\n\t\tpci_prepare_to_sleep(pdev);\n\n\t\tpcie_capability_write_word(us_dev, PCI_EXP_DEVCTL, devctl);\n\t}\n\n\treturn 0;\n}\n\n/**\n * __e1000e_disable_aspm - Disable ASPM states\n * @pdev: pointer to PCI device struct\n * @state: bit-mask of ASPM states to disable\n * @locked: indication if this context holds pci_bus_sem locked.\n *\n * Some devices *must* have certain ASPM states disabled per hardware errata.\n **/\nstatic void __e1000e_disable_aspm(struct pci_dev *pdev, u16 state, int locked)\n{\n\tstruct pci_dev *parent = pdev->bus->self;\n\tu16 aspm_dis_mask = 0;\n\tu16 pdev_aspmc, parent_aspmc;\n\n\tswitch (state) {\n\tcase PCIE_LINK_STATE_L0S:\n\tcase PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1:\n\t\taspm_dis_mask |= PCI_EXP_LNKCTL_ASPM_L0S;\n\t\tfallthrough; /* can't have L1 without L0s */\n\tcase PCIE_LINK_STATE_L1:\n\t\taspm_dis_mask |= PCI_EXP_LNKCTL_ASPM_L1;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tpcie_capability_read_word(pdev, PCI_EXP_LNKCTL, &pdev_aspmc);\n\tpdev_aspmc &= PCI_EXP_LNKCTL_ASPMC;\n\n\tif (parent) {\n\t\tpcie_capability_read_word(parent, PCI_EXP_LNKCTL,\n\t\t\t\t\t  &parent_aspmc);\n\t\tparent_aspmc &= PCI_EXP_LNKCTL_ASPMC;\n\t}\n\n\t/* Nothing to do if the ASPM states to be disabled already are */\n\tif (!(pdev_aspmc & aspm_dis_mask) &&\n\t    (!parent || !(parent_aspmc & aspm_dis_mask)))\n\t\treturn;\n\n\tdev_info(&pdev->dev, \"Disabling ASPM %s %s\\n\",\n\t\t (aspm_dis_mask & pdev_aspmc & PCI_EXP_LNKCTL_ASPM_L0S) ?\n\t\t \"L0s\" : \"\",\n\t\t (aspm_dis_mask & pdev_aspmc & PCI_EXP_LNKCTL_ASPM_L1) ?\n\t\t \"L1\" : \"\");\n\n#ifdef CONFIG_PCIEASPM\n\tif (locked)\n\t\tpci_disable_link_state_locked(pdev, state);\n\telse\n\t\tpci_disable_link_state(pdev, state);\n\n\t/* Double-check ASPM control.  If not disabled by the above, the\n\t * BIOS is preventing that from happening (or CONFIG_PCIEASPM is\n\t * not enabled); override by writing PCI config space directly.\n\t */\n\tpcie_capability_read_word(pdev, PCI_EXP_LNKCTL, &pdev_aspmc);\n\tpdev_aspmc &= PCI_EXP_LNKCTL_ASPMC;\n\n\tif (!(aspm_dis_mask & pdev_aspmc))\n\t\treturn;\n#endif\n\n\t/* Both device and parent should have the same ASPM setting.\n\t * Disable ASPM in downstream component first and then upstream.\n\t */\n\tpcie_capability_clear_word(pdev, PCI_EXP_LNKCTL, aspm_dis_mask);\n\n\tif (parent)\n\t\tpcie_capability_clear_word(parent, PCI_EXP_LNKCTL,\n\t\t\t\t\t   aspm_dis_mask);\n}\n\n/**\n * e1000e_disable_aspm - Disable ASPM states.\n * @pdev: pointer to PCI device struct\n * @state: bit-mask of ASPM states to disable\n *\n * This function acquires the pci_bus_sem!\n * Some devices *must* have certain ASPM states disabled per hardware errata.\n **/\nstatic void e1000e_disable_aspm(struct pci_dev *pdev, u16 state)\n{\n\t__e1000e_disable_aspm(pdev, state, 0);\n}\n\n/**\n * e1000e_disable_aspm_locked   Disable ASPM states.\n * @pdev: pointer to PCI device struct\n * @state: bit-mask of ASPM states to disable\n *\n * This function must be called with pci_bus_sem acquired!\n * Some devices *must* have certain ASPM states disabled per hardware errata.\n **/\nstatic void e1000e_disable_aspm_locked(struct pci_dev *pdev, u16 state)\n{\n\t__e1000e_disable_aspm(pdev, state, 1);\n}\n\nstatic int e1000e_pm_thaw(struct device *dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tint rc = 0;\n\n\te1000e_set_interrupt_capability(adapter);\n\n\trtnl_lock();\n\tif (netif_running(netdev)) {\n\t\trc = e1000_request_irq(adapter);\n\t\tif (rc)\n\t\t\tgoto err_irq;\n\n\t\te1000e_up(adapter);\n\t}\n\n\tnetif_device_attach(netdev);\nerr_irq:\n\trtnl_unlock();\n\n\treturn rc;\n}\n\nstatic int __e1000_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 aspm_disable_flag = 0;\n\n\tif (adapter->flags2 & FLAG2_DISABLE_ASPM_L0S)\n\t\taspm_disable_flag = PCIE_LINK_STATE_L0S;\n\tif (adapter->flags2 & FLAG2_DISABLE_ASPM_L1)\n\t\taspm_disable_flag |= PCIE_LINK_STATE_L1;\n\tif (aspm_disable_flag)\n\t\te1000e_disable_aspm(pdev, aspm_disable_flag);\n\n\tpci_set_master(pdev);\n\n\tif (hw->mac.type >= e1000_pch2lan)\n\t\te1000_resume_workarounds_pchlan(&adapter->hw);\n\n\te1000e_power_up_phy(adapter);\n\n\t/* report the system wakeup cause from S3/S4 */\n\tif (adapter->flags2 & FLAG2_HAS_PHY_WAKEUP) {\n\t\tu16 phy_data;\n\n\t\te1e_rphy(&adapter->hw, BM_WUS, &phy_data);\n\t\tif (phy_data) {\n\t\t\te_info(\"PHY Wakeup cause - %s\\n\",\n\t\t\t       phy_data & E1000_WUS_EX ? \"Unicast Packet\" :\n\t\t\t       phy_data & E1000_WUS_MC ? \"Multicast Packet\" :\n\t\t\t       phy_data & E1000_WUS_BC ? \"Broadcast Packet\" :\n\t\t\t       phy_data & E1000_WUS_MAG ? \"Magic Packet\" :\n\t\t\t       phy_data & E1000_WUS_LNKC ?\n\t\t\t       \"Link Status Change\" : \"other\");\n\t\t}\n\t\te1e_wphy(&adapter->hw, BM_WUS, ~0);\n\t} else {\n\t\tu32 wus = er32(WUS);\n\n\t\tif (wus) {\n\t\t\te_info(\"MAC Wakeup cause - %s\\n\",\n\t\t\t       wus & E1000_WUS_EX ? \"Unicast Packet\" :\n\t\t\t       wus & E1000_WUS_MC ? \"Multicast Packet\" :\n\t\t\t       wus & E1000_WUS_BC ? \"Broadcast Packet\" :\n\t\t\t       wus & E1000_WUS_MAG ? \"Magic Packet\" :\n\t\t\t       wus & E1000_WUS_LNKC ? \"Link Status Change\" :\n\t\t\t       \"other\");\n\t\t}\n\t\tew32(WUS, ~0);\n\t}\n\n\te1000e_reset(adapter);\n\n\te1000_init_manageability_pt(adapter);\n\n\t/* If the controller has AMT, do not set DRV_LOAD until the interface\n\t * is up.  For all other cases, let the f/w know that the h/w is now\n\t * under the control of the driver.\n\t */\n\tif (!(adapter->flags & FLAG_HAS_AMT))\n\t\te1000e_get_hw_control(adapter);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int e1000e_pm_suspend(struct device *dev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(to_pci_dev(dev));\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint rc;\n\n\te1000e_flush_lpic(pdev);\n\n\te1000e_pm_freeze(dev);\n\n\trc = __e1000_shutdown(pdev, false);\n\tif (rc) {\n\t\te1000e_pm_thaw(dev);\n\t} else {\n\t\t/* Introduce S0ix implementation */\n\t\tif (adapter->flags2 & FLAG2_ENABLE_S0IX_FLOWS)\n\t\t\te1000e_s0ix_entry_flow(adapter);\n\t}\n\n\treturn rc;\n}\n\nstatic __maybe_unused int e1000e_pm_resume(struct device *dev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(to_pci_dev(dev));\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint rc;\n\n\t/* Introduce S0ix implementation */\n\tif (adapter->flags2 & FLAG2_ENABLE_S0IX_FLOWS)\n\t\te1000e_s0ix_exit_flow(adapter);\n\n\trc = __e1000_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\treturn e1000e_pm_thaw(dev);\n}\n\nstatic __maybe_unused int e1000e_pm_runtime_idle(struct device *dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tu16 eee_lp;\n\n\teee_lp = adapter->hw.dev_spec.ich8lan.eee_lp_ability;\n\n\tif (!e1000e_has_link(adapter)) {\n\t\tadapter->hw.dev_spec.ich8lan.eee_lp_ability = eee_lp;\n\t\tpm_schedule_suspend(dev, 5 * MSEC_PER_SEC);\n\t}\n\n\treturn -EBUSY;\n}\n\nstatic __maybe_unused int e1000e_pm_runtime_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tint rc;\n\n\trc = __e1000_resume(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (netdev->flags & IFF_UP)\n\t\te1000e_up(adapter);\n\n\treturn rc;\n}\n\nstatic __maybe_unused int e1000e_pm_runtime_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tif (netdev->flags & IFF_UP) {\n\t\tint count = E1000_CHECK_RESET_COUNT;\n\n\t\twhile (test_bit(__E1000_RESETTING, &adapter->state) && count--)\n\t\t\tusleep_range(10000, 11000);\n\n\t\tWARN_ON(test_bit(__E1000_RESETTING, &adapter->state));\n\n\t\t/* Down the device without resetting the hardware */\n\t\te1000e_down(adapter, false);\n\t}\n\n\tif (__e1000_shutdown(pdev, true)) {\n\t\te1000e_pm_runtime_resume(dev);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic void e1000_shutdown(struct pci_dev *pdev)\n{\n\te1000e_flush_lpic(pdev);\n\n\te1000e_pm_freeze(&pdev->dev);\n\n\t__e1000_shutdown(pdev, false);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\nstatic irqreturn_t e1000_intr_msix(int __always_unused irq, void *data)\n{\n\tstruct net_device *netdev = data;\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tif (adapter->msix_entries) {\n\t\tint vector, msix_irq;\n\n\t\tvector = 0;\n\t\tmsix_irq = adapter->msix_entries[vector].vector;\n\t\tif (disable_hardirq(msix_irq))\n\t\t\te1000_intr_msix_rx(msix_irq, netdev);\n\t\tenable_irq(msix_irq);\n\n\t\tvector++;\n\t\tmsix_irq = adapter->msix_entries[vector].vector;\n\t\tif (disable_hardirq(msix_irq))\n\t\t\te1000_intr_msix_tx(msix_irq, netdev);\n\t\tenable_irq(msix_irq);\n\n\t\tvector++;\n\t\tmsix_irq = adapter->msix_entries[vector].vector;\n\t\tif (disable_hardirq(msix_irq))\n\t\t\te1000_msix_other(msix_irq, netdev);\n\t\tenable_irq(msix_irq);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n/**\n * e1000_netpoll\n * @netdev: network interface device structure\n *\n * Polling 'interrupt' - used by things like netconsole to send skbs\n * without having to re-enable interrupts. It's not called while\n * the interrupt routine is executing.\n */\nstatic void e1000_netpoll(struct net_device *netdev)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\tswitch (adapter->int_mode) {\n\tcase E1000E_INT_MODE_MSIX:\n\t\te1000_intr_msix(adapter->pdev->irq, netdev);\n\t\tbreak;\n\tcase E1000E_INT_MODE_MSI:\n\t\tif (disable_hardirq(adapter->pdev->irq))\n\t\t\te1000_intr_msi(adapter->pdev->irq, netdev);\n\t\tenable_irq(adapter->pdev->irq);\n\t\tbreak;\n\tdefault:\t\t/* E1000E_INT_MODE_LEGACY */\n\t\tif (disable_hardirq(adapter->pdev->irq))\n\t\t\te1000_intr(adapter->pdev->irq, netdev);\n\t\tenable_irq(adapter->pdev->irq);\n\t\tbreak;\n\t}\n}\n#endif\n\n/**\n * e1000_io_error_detected - called when PCI error is detected\n * @pdev: Pointer to PCI device\n * @state: The current pci connection state\n *\n * This function is called after a PCI bus error affecting\n * this device has been detected.\n */\nstatic pci_ers_result_t e1000_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t\tpci_channel_state_t state)\n{\n\te1000e_pm_freeze(&pdev->dev);\n\n\tif (state == pci_channel_io_perm_failure)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tpci_disable_device(pdev);\n\n\t/* Request a slot slot reset. */\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n/**\n * e1000_io_slot_reset - called after the pci bus has been reset.\n * @pdev: Pointer to PCI device\n *\n * Restart the card from scratch, as if from a cold-boot. Implementation\n * resembles the first-half of the e1000e_pm_resume routine.\n */\nstatic pci_ers_result_t e1000_io_slot_reset(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\tu16 aspm_disable_flag = 0;\n\tint err;\n\tpci_ers_result_t result;\n\n\tif (adapter->flags2 & FLAG2_DISABLE_ASPM_L0S)\n\t\taspm_disable_flag = PCIE_LINK_STATE_L0S;\n\tif (adapter->flags2 & FLAG2_DISABLE_ASPM_L1)\n\t\taspm_disable_flag |= PCIE_LINK_STATE_L1;\n\tif (aspm_disable_flag)\n\t\te1000e_disable_aspm_locked(pdev, aspm_disable_flag);\n\n\terr = pci_enable_device_mem(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot re-enable PCI device after reset.\\n\");\n\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t} else {\n\t\tpdev->state_saved = true;\n\t\tpci_restore_state(pdev);\n\t\tpci_set_master(pdev);\n\n\t\tpci_enable_wake(pdev, PCI_D3hot, 0);\n\t\tpci_enable_wake(pdev, PCI_D3cold, 0);\n\n\t\te1000e_reset(adapter);\n\t\tew32(WUS, ~0);\n\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t}\n\n\treturn result;\n}\n\n/**\n * e1000_io_resume - called when traffic can start flowing again.\n * @pdev: Pointer to PCI device\n *\n * This callback is called when the error recovery driver tells us that\n * its OK to resume normal operation. Implementation resembles the\n * second-half of the e1000e_pm_resume routine.\n */\nstatic void e1000_io_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\te1000_init_manageability_pt(adapter);\n\n\te1000e_pm_thaw(&pdev->dev);\n\n\t/* If the controller has AMT, do not set DRV_LOAD until the interface\n\t * is up.  For all other cases, let the f/w know that the h/w is now\n\t * under the control of the driver.\n\t */\n\tif (!(adapter->flags & FLAG_HAS_AMT))\n\t\te1000e_get_hw_control(adapter);\n}\n\nstatic void e1000_print_device_info(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 ret_val;\n\tu8 pba_str[E1000_PBANUM_LENGTH];\n\n\t/* print bus type/speed/width info */\n\te_info(\"(PCI Express:2.5GT/s:%s) %pM\\n\",\n\t       /* bus width */\n\t       ((hw->bus.width == e1000_bus_width_pcie_x4) ? \"Width x4\" :\n\t\t\"Width x1\"),\n\t       /* MAC address */\n\t       netdev->dev_addr);\n\te_info(\"Intel(R) PRO/%s Network Connection\\n\",\n\t       (hw->phy.type == e1000_phy_ife) ? \"10/100\" : \"1000\");\n\tret_val = e1000_read_pba_string_generic(hw, pba_str,\n\t\t\t\t\t\tE1000_PBANUM_LENGTH);\n\tif (ret_val)\n\t\tstrlcpy((char *)pba_str, \"Unknown\", sizeof(pba_str));\n\te_info(\"MAC: %d, PHY: %d, PBA No: %s\\n\",\n\t       hw->mac.type, hw->phy.type, pba_str);\n}\n\nstatic void e1000_eeprom_checks(struct e1000_adapter *adapter)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tint ret_val;\n\tu16 buf = 0;\n\n\tif (hw->mac.type != e1000_82573)\n\t\treturn;\n\n\tret_val = e1000_read_nvm(hw, NVM_INIT_CONTROL2_REG, 1, &buf);\n\tle16_to_cpus(&buf);\n\tif (!ret_val && (!(buf & BIT(0)))) {\n\t\t/* Deep Smart Power Down (DSPD) */\n\t\tdev_warn(&adapter->pdev->dev,\n\t\t\t \"Warning: detected DSPD enabled in EEPROM\\n\");\n\t}\n}\n\nstatic netdev_features_t e1000_fix_features(struct net_device *netdev,\n\t\t\t\t\t    netdev_features_t features)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tstruct e1000_hw *hw = &adapter->hw;\n\n\t/* Jumbo frame workaround on 82579 and newer requires CRC be stripped */\n\tif ((hw->mac.type >= e1000_pch2lan) && (netdev->mtu > ETH_DATA_LEN))\n\t\tfeatures &= ~NETIF_F_RXFCS;\n\n\t/* Since there is no support for separate Rx/Tx vlan accel\n\t * enable/disable make sure Tx flag is always in same state as Rx.\n\t */\n\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\n\telse\n\t\tfeatures &= ~NETIF_F_HW_VLAN_CTAG_TX;\n\n\treturn features;\n}\n\nstatic int e1000_set_features(struct net_device *netdev,\n\t\t\t      netdev_features_t features)\n{\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\tnetdev_features_t changed = features ^ netdev->features;\n\n\tif (changed & (NETIF_F_TSO | NETIF_F_TSO6))\n\t\tadapter->flags |= FLAG_TSO_FORCE;\n\n\tif (!(changed & (NETIF_F_HW_VLAN_CTAG_RX | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t NETIF_F_RXCSUM | NETIF_F_RXHASH | NETIF_F_RXFCS |\n\t\t\t NETIF_F_RXALL)))\n\t\treturn 0;\n\n\tif (changed & NETIF_F_RXFCS) {\n\t\tif (features & NETIF_F_RXFCS) {\n\t\t\tadapter->flags2 &= ~FLAG2_CRC_STRIPPING;\n\t\t} else {\n\t\t\t/* We need to take it back to defaults, which might mean\n\t\t\t * stripping is still disabled at the adapter level.\n\t\t\t */\n\t\t\tif (adapter->flags2 & FLAG2_DFLT_CRC_STRIPPING)\n\t\t\t\tadapter->flags2 |= FLAG2_CRC_STRIPPING;\n\t\t\telse\n\t\t\t\tadapter->flags2 &= ~FLAG2_CRC_STRIPPING;\n\t\t}\n\t}\n\n\tnetdev->features = features;\n\n\tif (netif_running(netdev))\n\t\te1000e_reinit_locked(adapter);\n\telse\n\t\te1000e_reset(adapter);\n\n\treturn 1;\n}\n\nstatic const struct net_device_ops e1000e_netdev_ops = {\n\t.ndo_open\t\t= e1000e_open,\n\t.ndo_stop\t\t= e1000e_close,\n\t.ndo_start_xmit\t\t= e1000_xmit_frame,\n\t.ndo_get_stats64\t= e1000e_get_stats64,\n\t.ndo_set_rx_mode\t= e1000e_set_rx_mode,\n\t.ndo_set_mac_address\t= e1000_set_mac,\n\t.ndo_change_mtu\t\t= e1000_change_mtu,\n\t.ndo_do_ioctl\t\t= e1000_ioctl,\n\t.ndo_tx_timeout\t\t= e1000_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\n\t.ndo_vlan_rx_add_vid\t= e1000_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= e1000_vlan_rx_kill_vid,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= e1000_netpoll,\n#endif\n\t.ndo_set_features = e1000_set_features,\n\t.ndo_fix_features = e1000_fix_features,\n\t.ndo_features_check\t= passthru_features_check,\n};\n\n/**\n * e1000_probe - Device Initialization Routine\n * @pdev: PCI device information struct\n * @ent: entry in e1000_pci_tbl\n *\n * Returns 0 on success, negative on failure\n *\n * e1000_probe initializes an adapter identified by a pci_dev structure.\n * The OS initialization, configuring of the adapter private structure,\n * and a hardware reset occur.\n **/\nstatic int e1000_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *netdev;\n\tstruct e1000_adapter *adapter;\n\tstruct e1000_hw *hw;\n\tconst struct e1000_info *ei = e1000_info_tbl[ent->driver_data];\n\tresource_size_t mmio_start, mmio_len;\n\tresource_size_t flash_start, flash_len;\n\tstatic int cards_found;\n\tu16 aspm_disable_flag = 0;\n\tint bars, i, err, pci_using_dac;\n\tu16 eeprom_data = 0;\n\tu16 eeprom_apme_mask = E1000_EEPROM_APME;\n\ts32 ret_val = 0;\n\n\tif (ei->flags2 & FLAG2_DISABLE_ASPM_L0S)\n\t\taspm_disable_flag = PCIE_LINK_STATE_L0S;\n\tif (ei->flags2 & FLAG2_DISABLE_ASPM_L1)\n\t\taspm_disable_flag |= PCIE_LINK_STATE_L1;\n\tif (aspm_disable_flag)\n\t\te1000e_disable_aspm(pdev, aspm_disable_flag);\n\n\terr = pci_enable_device_mem(pdev);\n\tif (err)\n\t\treturn err;\n\n\tpci_using_dac = 0;\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (!err) {\n\t\tpci_using_dac = 1;\n\t} else {\n\t\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"No usable DMA configuration, aborting\\n\");\n\t\t\tgoto err_dma;\n\t\t}\n\t}\n\n\tbars = pci_select_bars(pdev, IORESOURCE_MEM);\n\terr = pci_request_selected_regions_exclusive(pdev, bars,\n\t\t\t\t\t\t     e1000e_driver_name);\n\tif (err)\n\t\tgoto err_pci_reg;\n\n\t/* AER (Advanced Error Reporting) hooks */\n\tpci_enable_pcie_error_reporting(pdev);\n\n\tpci_set_master(pdev);\n\t/* PCI config space info */\n\terr = pci_save_state(pdev);\n\tif (err)\n\t\tgoto err_alloc_etherdev;\n\n\terr = -ENOMEM;\n\tnetdev = alloc_etherdev(sizeof(struct e1000_adapter));\n\tif (!netdev)\n\t\tgoto err_alloc_etherdev;\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\tnetdev->irq = pdev->irq;\n\n\tpci_set_drvdata(pdev, netdev);\n\tadapter = netdev_priv(netdev);\n\thw = &adapter->hw;\n\tadapter->netdev = netdev;\n\tadapter->pdev = pdev;\n\tadapter->ei = ei;\n\tadapter->pba = ei->pba;\n\tadapter->flags = ei->flags;\n\tadapter->flags2 = ei->flags2;\n\tadapter->hw.adapter = adapter;\n\tadapter->hw.mac.type = ei->mac;\n\tadapter->max_hw_frame_size = ei->max_hw_frame_size;\n\tadapter->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);\n\n\tmmio_start = pci_resource_start(pdev, 0);\n\tmmio_len = pci_resource_len(pdev, 0);\n\n\terr = -EIO;\n\tadapter->hw.hw_addr = ioremap(mmio_start, mmio_len);\n\tif (!adapter->hw.hw_addr)\n\t\tgoto err_ioremap;\n\n\tif ((adapter->flags & FLAG_HAS_FLASH) &&\n\t    (pci_resource_flags(pdev, 1) & IORESOURCE_MEM) &&\n\t    (hw->mac.type < e1000_pch_spt)) {\n\t\tflash_start = pci_resource_start(pdev, 1);\n\t\tflash_len = pci_resource_len(pdev, 1);\n\t\tadapter->hw.flash_address = ioremap(flash_start, flash_len);\n\t\tif (!adapter->hw.flash_address)\n\t\t\tgoto err_flashmap;\n\t}\n\n\t/* Set default EEE advertisement */\n\tif (adapter->flags2 & FLAG2_HAS_EEE)\n\t\tadapter->eee_advert = MDIO_EEE_100TX | MDIO_EEE_1000T;\n\n\t/* construct the net_device struct */\n\tnetdev->netdev_ops = &e1000e_netdev_ops;\n\te1000e_set_ethtool_ops(netdev);\n\tnetdev->watchdog_timeo = 5 * HZ;\n\tnetif_napi_add(netdev, &adapter->napi, e1000e_poll, 64);\n\tstrlcpy(netdev->name, pci_name(pdev), sizeof(netdev->name));\n\n\tnetdev->mem_start = mmio_start;\n\tnetdev->mem_end = mmio_start + mmio_len;\n\n\tadapter->bd_number = cards_found++;\n\n\te1000e_check_options(adapter);\n\n\t/* setup adapter struct */\n\terr = e1000_sw_init(adapter);\n\tif (err)\n\t\tgoto err_sw_init;\n\n\tmemcpy(&hw->mac.ops, ei->mac_ops, sizeof(hw->mac.ops));\n\tmemcpy(&hw->nvm.ops, ei->nvm_ops, sizeof(hw->nvm.ops));\n\tmemcpy(&hw->phy.ops, ei->phy_ops, sizeof(hw->phy.ops));\n\n\terr = ei->get_variants(adapter);\n\tif (err)\n\t\tgoto err_hw_init;\n\n\tif ((adapter->flags & FLAG_IS_ICH) &&\n\t    (adapter->flags & FLAG_READ_ONLY_NVM) &&\n\t    (hw->mac.type < e1000_pch_spt))\n\t\te1000e_write_protect_nvm_ich8lan(&adapter->hw);\n\n\thw->mac.ops.get_bus_info(&adapter->hw);\n\n\tadapter->hw.phy.autoneg_wait_to_complete = 0;\n\n\t/* Copper options */\n\tif (adapter->hw.phy.media_type == e1000_media_type_copper) {\n\t\tadapter->hw.phy.mdix = AUTO_ALL_MODES;\n\t\tadapter->hw.phy.disable_polarity_correction = 0;\n\t\tadapter->hw.phy.ms_type = e1000_ms_hw_default;\n\t}\n\n\tif (hw->phy.ops.check_reset_block && hw->phy.ops.check_reset_block(hw))\n\t\tdev_info(&pdev->dev,\n\t\t\t \"PHY reset is blocked due to SOL/IDER session.\\n\");\n\n\t/* Set initial default active device features */\n\tnetdev->features = (NETIF_F_SG |\n\t\t\t    NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t    NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t    NETIF_F_TSO |\n\t\t\t    NETIF_F_TSO6 |\n\t\t\t    NETIF_F_RXHASH |\n\t\t\t    NETIF_F_RXCSUM |\n\t\t\t    NETIF_F_HW_CSUM);\n\n\t/* Set user-changeable features (subset of all device features) */\n\tnetdev->hw_features = netdev->features;\n\tnetdev->hw_features |= NETIF_F_RXFCS;\n\tnetdev->priv_flags |= IFF_SUPP_NOFCS;\n\tnetdev->hw_features |= NETIF_F_RXALL;\n\n\tif (adapter->flags & FLAG_HAS_HW_VLAN_FILTER)\n\t\tnetdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n\n\tnetdev->vlan_features |= (NETIF_F_SG |\n\t\t\t\t  NETIF_F_TSO |\n\t\t\t\t  NETIF_F_TSO6 |\n\t\t\t\t  NETIF_F_HW_CSUM);\n\n\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\n\tif (pci_using_dac) {\n\t\tnetdev->features |= NETIF_F_HIGHDMA;\n\t\tnetdev->vlan_features |= NETIF_F_HIGHDMA;\n\t}\n\n\t/* MTU range: 68 - max_hw_frame_size */\n\tnetdev->min_mtu = ETH_MIN_MTU;\n\tnetdev->max_mtu = adapter->max_hw_frame_size -\n\t\t\t  (VLAN_ETH_HLEN + ETH_FCS_LEN);\n\n\tif (e1000e_enable_mng_pass_thru(&adapter->hw))\n\t\tadapter->flags |= FLAG_MNG_PT_ENABLED;\n\n\t/* before reading the NVM, reset the controller to\n\t * put the device in a known good starting state\n\t */\n\tadapter->hw.mac.ops.reset_hw(&adapter->hw);\n\n\t/* systems with ASPM and others may see the checksum fail on the first\n\t * attempt. Let's give it a few tries\n\t */\n\tfor (i = 0;; i++) {\n\t\tif (e1000_validate_nvm_checksum(&adapter->hw) >= 0)\n\t\t\tbreak;\n\t\tif (i == 2) {\n\t\t\tdev_err(&pdev->dev, \"The NVM Checksum Is Not Valid\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto err_eeprom;\n\t\t}\n\t}\n\n\te1000_eeprom_checks(adapter);\n\n\t/* copy the MAC address */\n\tif (e1000e_read_mac_addr(&adapter->hw))\n\t\tdev_err(&pdev->dev,\n\t\t\t\"NVM Read Error while reading MAC address\\n\");\n\n\tmemcpy(netdev->dev_addr, adapter->hw.mac.addr, netdev->addr_len);\n\n\tif (!is_valid_ether_addr(netdev->dev_addr)) {\n\t\tdev_err(&pdev->dev, \"Invalid MAC Address: %pM\\n\",\n\t\t\tnetdev->dev_addr);\n\t\terr = -EIO;\n\t\tgoto err_eeprom;\n\t}\n\n\ttimer_setup(&adapter->watchdog_timer, e1000_watchdog, 0);\n\ttimer_setup(&adapter->phy_info_timer, e1000_update_phy_info, 0);\n\n\tINIT_WORK(&adapter->reset_task, e1000_reset_task);\n\tINIT_WORK(&adapter->watchdog_task, e1000_watchdog_task);\n\tINIT_WORK(&adapter->downshift_task, e1000e_downshift_workaround);\n\tINIT_WORK(&adapter->update_phy_task, e1000e_update_phy_task);\n\tINIT_WORK(&adapter->print_hang_task, e1000_print_hw_hang);\n\n\t/* Initialize link parameters. User can change them with ethtool */\n\tadapter->hw.mac.autoneg = 1;\n\tadapter->fc_autoneg = true;\n\tadapter->hw.fc.requested_mode = e1000_fc_default;\n\tadapter->hw.fc.current_mode = e1000_fc_default;\n\tadapter->hw.phy.autoneg_advertised = 0x2f;\n\n\t/* Initial Wake on LAN setting - If APM wake is enabled in\n\t * the EEPROM, enable the ACPI Magic Packet filter\n\t */\n\tif (adapter->flags & FLAG_APME_IN_WUC) {\n\t\t/* APME bit in EEPROM is mapped to WUC.APME */\n\t\teeprom_data = er32(WUC);\n\t\teeprom_apme_mask = E1000_WUC_APME;\n\t\tif ((hw->mac.type > e1000_ich10lan) &&\n\t\t    (eeprom_data & E1000_WUC_PHY_WAKE))\n\t\t\tadapter->flags2 |= FLAG2_HAS_PHY_WAKEUP;\n\t} else if (adapter->flags & FLAG_APME_IN_CTRL3) {\n\t\tif (adapter->flags & FLAG_APME_CHECK_PORT_B &&\n\t\t    (adapter->hw.bus.func == 1))\n\t\t\tret_val = e1000_read_nvm(&adapter->hw,\n\t\t\t\t\t      NVM_INIT_CONTROL3_PORT_B,\n\t\t\t\t\t      1, &eeprom_data);\n\t\telse\n\t\t\tret_val = e1000_read_nvm(&adapter->hw,\n\t\t\t\t\t      NVM_INIT_CONTROL3_PORT_A,\n\t\t\t\t\t      1, &eeprom_data);\n\t}\n\n\t/* fetch WoL from EEPROM */\n\tif (ret_val)\n\t\te_dbg(\"NVM read error getting WoL initial values: %d\\n\", ret_val);\n\telse if (eeprom_data & eeprom_apme_mask)\n\t\tadapter->eeprom_wol |= E1000_WUFC_MAG;\n\n\t/* now that we have the eeprom settings, apply the special cases\n\t * where the eeprom may be wrong or the board simply won't support\n\t * wake on lan on a particular port\n\t */\n\tif (!(adapter->flags & FLAG_HAS_WOL))\n\t\tadapter->eeprom_wol = 0;\n\n\t/* initialize the wol settings based on the eeprom settings */\n\tadapter->wol = adapter->eeprom_wol;\n\n\t/* make sure adapter isn't asleep if manageability is enabled */\n\tif (adapter->wol || (adapter->flags & FLAG_MNG_PT_ENABLED) ||\n\t    (hw->mac.ops.check_mng_mode(hw)))\n\t\tdevice_wakeup_enable(&pdev->dev);\n\n\t/* save off EEPROM version number */\n\tret_val = e1000_read_nvm(&adapter->hw, 5, 1, &adapter->eeprom_vers);\n\n\tif (ret_val) {\n\t\te_dbg(\"NVM read error getting EEPROM version: %d\\n\", ret_val);\n\t\tadapter->eeprom_vers = 0;\n\t}\n\n\t/* init PTP hardware clock */\n\te1000e_ptp_init(adapter);\n\n\t/* reset the hardware with the new settings */\n\te1000e_reset(adapter);\n\n\t/* If the controller has AMT, do not set DRV_LOAD until the interface\n\t * is up.  For all other cases, let the f/w know that the h/w is now\n\t * under the control of the driver.\n\t */\n\tif (!(adapter->flags & FLAG_HAS_AMT))\n\t\te1000e_get_hw_control(adapter);\n\n\tif (hw->mac.type >= e1000_pch_cnp)\n\t\tadapter->flags2 |= FLAG2_ENABLE_S0IX_FLOWS;\n\n\tstrlcpy(netdev->name, \"eth%d\", sizeof(netdev->name));\n\terr = register_netdev(netdev);\n\tif (err)\n\t\tgoto err_register;\n\n\t/* carrier off reporting is important to ethtool even BEFORE open */\n\tnetif_carrier_off(netdev);\n\n\te1000_print_device_info(adapter);\n\n\tdev_pm_set_driver_flags(&pdev->dev, DPM_FLAG_NO_DIRECT_COMPLETE);\n\n\tif (pci_dev_run_wake(pdev) && hw->mac.type < e1000_pch_cnp)\n\t\tpm_runtime_put_noidle(&pdev->dev);\n\n\treturn 0;\n\nerr_register:\n\tif (!(adapter->flags & FLAG_HAS_AMT))\n\t\te1000e_release_hw_control(adapter);\nerr_eeprom:\n\tif (hw->phy.ops.check_reset_block && !hw->phy.ops.check_reset_block(hw))\n\t\te1000_phy_hw_reset(&adapter->hw);\nerr_hw_init:\n\tkfree(adapter->tx_ring);\n\tkfree(adapter->rx_ring);\nerr_sw_init:\n\tif ((adapter->hw.flash_address) && (hw->mac.type < e1000_pch_spt))\n\t\tiounmap(adapter->hw.flash_address);\n\te1000e_reset_interrupt_capability(adapter);\nerr_flashmap:\n\tiounmap(adapter->hw.hw_addr);\nerr_ioremap:\n\tfree_netdev(netdev);\nerr_alloc_etherdev:\n\tpci_release_mem_regions(pdev);\nerr_pci_reg:\nerr_dma:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\n/**\n * e1000_remove - Device Removal Routine\n * @pdev: PCI device information struct\n *\n * e1000_remove is called by the PCI subsystem to alert the driver\n * that it should release a PCI device.  The could be caused by a\n * Hot-Plug event, or because the driver is going to be removed from\n * memory.\n **/\nstatic void e1000_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct e1000_adapter *adapter = netdev_priv(netdev);\n\n\te1000e_ptp_remove(adapter);\n\n\t/* The timers may be rescheduled, so explicitly disable them\n\t * from being rescheduled.\n\t */\n\tset_bit(__E1000_DOWN, &adapter->state);\n\tdel_timer_sync(&adapter->watchdog_timer);\n\tdel_timer_sync(&adapter->phy_info_timer);\n\n\tcancel_work_sync(&adapter->reset_task);\n\tcancel_work_sync(&adapter->watchdog_task);\n\tcancel_work_sync(&adapter->downshift_task);\n\tcancel_work_sync(&adapter->update_phy_task);\n\tcancel_work_sync(&adapter->print_hang_task);\n\n\tif (adapter->flags & FLAG_HAS_HW_TIMESTAMP) {\n\t\tcancel_work_sync(&adapter->tx_hwtstamp_work);\n\t\tif (adapter->tx_hwtstamp_skb) {\n\t\t\tdev_consume_skb_any(adapter->tx_hwtstamp_skb);\n\t\t\tadapter->tx_hwtstamp_skb = NULL;\n\t\t}\n\t}\n\n\tunregister_netdev(netdev);\n\n\tif (pci_dev_run_wake(pdev))\n\t\tpm_runtime_get_noresume(&pdev->dev);\n\n\t/* Release control of h/w to f/w.  If f/w is AMT enabled, this\n\t * would have already happened in close and is redundant.\n\t */\n\te1000e_release_hw_control(adapter);\n\n\te1000e_reset_interrupt_capability(adapter);\n\tkfree(adapter->tx_ring);\n\tkfree(adapter->rx_ring);\n\n\tiounmap(adapter->hw.hw_addr);\n\tif ((adapter->hw.flash_address) &&\n\t    (adapter->hw.mac.type < e1000_pch_spt))\n\t\tiounmap(adapter->hw.flash_address);\n\tpci_release_mem_regions(pdev);\n\n\tfree_netdev(netdev);\n\n\t/* AER disable */\n\tpci_disable_pcie_error_reporting(pdev);\n\n\tpci_disable_device(pdev);\n}\n\n/* PCI Error Recovery (ERS) */\nstatic const struct pci_error_handlers e1000_err_handler = {\n\t.error_detected = e1000_io_error_detected,\n\t.slot_reset = e1000_io_slot_reset,\n\t.resume = e1000_io_resume,\n};\n\nstatic const struct pci_device_id e1000_pci_tbl[] = {\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_COPPER), board_82571 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_FIBER), board_82571 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_QUAD_COPPER), board_82571 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_QUAD_COPPER_LP),\n\t  board_82571 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_QUAD_FIBER), board_82571 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_SERDES), board_82571 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_SERDES_DUAL), board_82571 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571EB_SERDES_QUAD), board_82571 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82571PT_QUAD_COPPER), board_82571 },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82572EI), board_82572 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82572EI_COPPER), board_82572 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82572EI_FIBER), board_82572 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82572EI_SERDES), board_82572 },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82573E), board_82573 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82573E_IAMT), board_82573 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82573L), board_82573 },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82574L), board_82574 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82574LA), board_82574 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82583V), board_82583 },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_80003ES2LAN_COPPER_DPT),\n\t  board_80003es2lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_80003ES2LAN_COPPER_SPT),\n\t  board_80003es2lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_80003ES2LAN_SERDES_DPT),\n\t  board_80003es2lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_80003ES2LAN_SERDES_SPT),\n\t  board_80003es2lan },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IFE), board_ich8lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IFE_G), board_ich8lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IFE_GT), board_ich8lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IGP_AMT), board_ich8lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IGP_C), board_ich8lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IGP_M), board_ich8lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_IGP_M_AMT), board_ich8lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH8_82567V_3), board_ich8lan },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IFE), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IFE_G), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IFE_GT), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IGP_AMT), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IGP_C), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_BM), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IGP_M), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IGP_M_AMT), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH9_IGP_M_V), board_ich9lan },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_R_BM_LM), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_R_BM_LF), board_ich9lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_R_BM_V), board_ich9lan },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_D_BM_LM), board_ich10lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_D_BM_LF), board_ich10lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_ICH10_D_BM_V), board_ich10lan },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_M_HV_LM), board_pchlan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_M_HV_LC), board_pchlan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_D_HV_DM), board_pchlan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_D_HV_DC), board_pchlan },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH2_LV_LM), board_pch2lan },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH2_LV_V), board_pch2lan },\n\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_LPT_I217_LM), board_pch_lpt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_LPT_I217_V), board_pch_lpt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_LPTLP_I218_LM), board_pch_lpt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_LPTLP_I218_V), board_pch_lpt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_I218_LM2), board_pch_lpt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_I218_V2), board_pch_lpt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_I218_LM3), board_pch_lpt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_I218_V3), board_pch_lpt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_SPT_I219_LM), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_SPT_I219_V), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_SPT_I219_LM2), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_SPT_I219_V2), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_LBG_I219_LM3), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_SPT_I219_LM4), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_SPT_I219_V4), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_SPT_I219_LM5), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_SPT_I219_V5), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CNP_I219_LM6), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CNP_I219_V6), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CNP_I219_LM7), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CNP_I219_V7), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ICP_I219_LM8), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ICP_I219_V8), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ICP_I219_LM9), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ICP_I219_V9), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CMP_I219_LM10), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CMP_I219_V10), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CMP_I219_LM11), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CMP_I219_V11), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CMP_I219_LM12), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_CMP_I219_V12), board_pch_spt },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_TGP_I219_LM13), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_TGP_I219_V13), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_TGP_I219_LM14), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_TGP_I219_V14), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_TGP_I219_LM15), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_TGP_I219_V15), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ADP_I219_LM16), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ADP_I219_V16), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ADP_I219_LM17), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_ADP_I219_V17), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_MTP_I219_LM18), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_MTP_I219_V18), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_MTP_I219_LM19), board_pch_cnp },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_PCH_MTP_I219_V19), board_pch_cnp },\n\n\t{ 0, 0, 0, 0, 0, 0, 0 }\t/* terminate list */\n};\nMODULE_DEVICE_TABLE(pci, e1000_pci_tbl);\n\nstatic const struct dev_pm_ops e1000_pm_ops = {\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= e1000e_pm_suspend,\n\t.resume\t\t= e1000e_pm_resume,\n\t.freeze\t\t= e1000e_pm_freeze,\n\t.thaw\t\t= e1000e_pm_thaw,\n\t.poweroff\t= e1000e_pm_suspend,\n\t.restore\t= e1000e_pm_resume,\n#endif\n\tSET_RUNTIME_PM_OPS(e1000e_pm_runtime_suspend, e1000e_pm_runtime_resume,\n\t\t\t   e1000e_pm_runtime_idle)\n};\n\n/* PCI Device API Driver */\nstatic struct pci_driver e1000_driver = {\n\t.name     = e1000e_driver_name,\n\t.id_table = e1000_pci_tbl,\n\t.probe    = e1000_probe,\n\t.remove   = e1000_remove,\n\t.driver   = {\n\t\t.pm = &e1000_pm_ops,\n\t},\n\t.shutdown = e1000_shutdown,\n\t.err_handler = &e1000_err_handler\n};\n\n/**\n * e1000_init_module - Driver Registration Routine\n *\n * e1000_init_module is the first routine called when the driver is\n * loaded. All it does is register with the PCI subsystem.\n **/\nstatic int __init e1000_init_module(void)\n{\n\tpr_info(\"Intel(R) PRO/1000 Network Driver\\n\");\n\tpr_info(\"Copyright(c) 1999 - 2015 Intel Corporation.\\n\");\n\n\treturn pci_register_driver(&e1000_driver);\n}\nmodule_init(e1000_init_module);\n\n/**\n * e1000_exit_module - Driver Exit Cleanup Routine\n *\n * e1000_exit_module is called just before the driver is removed\n * from memory.\n **/\nstatic void __exit e1000_exit_module(void)\n{\n\tpci_unregister_driver(&e1000_driver);\n}\nmodule_exit(e1000_exit_module);\n\nMODULE_AUTHOR(\"Intel Corporation, <linux.nics@intel.com>\");\nMODULE_DESCRIPTION(\"Intel(R) PRO/1000 Network Driver\");\nMODULE_LICENSE(\"GPL v2\");\n\n/* netdev.c */\n"}, "1": {"id": 1, "path": "/src/include/linux/prefetch.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n/*\n *  Generic cache management functions. Everything is arch-specific,  \n *  but this header exists to make sure the defines/functions can be\n *  used in a generic way.\n *\n *  2000-11-13  Arjan van de Ven   <arjan@fenrus.demon.nl>\n *\n */\n\n#ifndef _LINUX_PREFETCH_H\n#define _LINUX_PREFETCH_H\n\n#include <linux/types.h>\n#include <asm/processor.h>\n#include <asm/cache.h>\n\nstruct page;\n/*\n\tprefetch(x) attempts to pre-emptively get the memory pointed to\n\tby address \"x\" into the CPU L1 cache. \n\tprefetch(x) should not cause any kind of exception, prefetch(0) is\n\tspecifically ok.\n\n\tprefetch() should be defined by the architecture, if not, the \n\t#define below provides a no-op define.\t\n\t\n\tThere are 3 prefetch() macros:\n\t\n\tprefetch(x)  \t- prefetches the cacheline at \"x\" for read\n\tprefetchw(x)\t- prefetches the cacheline at \"x\" for write\n\tspin_lock_prefetch(x) - prefetches the spinlock *x for taking\n\t\n\tthere is also PREFETCH_STRIDE which is the architecure-preferred \n\t\"lookahead\" size for prefetching streamed operations.\n\t\n*/\n\n#ifndef ARCH_HAS_PREFETCH\n#define prefetch(x) __builtin_prefetch(x)\n#endif\n\n#ifndef ARCH_HAS_PREFETCHW\n#define prefetchw(x) __builtin_prefetch(x,1)\n#endif\n\n#ifndef ARCH_HAS_SPINLOCK_PREFETCH\n#define spin_lock_prefetch(x) prefetchw(x)\n#endif\n\n#ifndef PREFETCH_STRIDE\n#define PREFETCH_STRIDE (4*L1_CACHE_BYTES)\n#endif\n\nstatic inline void prefetch_range(void *addr, size_t len)\n{\n#ifdef ARCH_HAS_PREFETCH\n\tchar *cp;\n\tchar *end = addr + len;\n\n\tfor (cp = addr; cp < end; cp += PREFETCH_STRIDE)\n\t\tprefetch(cp);\n#endif\n}\n\nstatic inline void prefetch_page_address(struct page *page)\n{\n#if defined(WANT_PAGE_VIRTUAL) || defined(HASHED_PAGE_VIRTUAL)\n\tprefetch(page);\n#endif\n}\n\n#endif\n"}, "2": {"id": 2, "path": "/src/drivers/net/ethernet/intel/e1000e/e1000.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n/* Copyright(c) 1999 - 2018 Intel Corporation. */\n\n/* Linux PRO/1000 Ethernet Driver main header file */\n\n#ifndef _E1000_H_\n#define _E1000_H_\n\n#include <linux/bitops.h>\n#include <linux/types.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#include <linux/io.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/crc32.h>\n#include <linux/if_vlan.h>\n#include <linux/timecounter.h>\n#include <linux/net_tstamp.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/ptp_classify.h>\n#include <linux/mii.h>\n#include <linux/mdio.h>\n#include <linux/pm_qos.h>\n#include \"hw.h\"\n\nstruct e1000_info;\n\n#define e_dbg(format, arg...) \\\n\tnetdev_dbg(hw->adapter->netdev, format, ## arg)\n#define e_err(format, arg...) \\\n\tnetdev_err(adapter->netdev, format, ## arg)\n#define e_info(format, arg...) \\\n\tnetdev_info(adapter->netdev, format, ## arg)\n#define e_warn(format, arg...) \\\n\tnetdev_warn(adapter->netdev, format, ## arg)\n#define e_notice(format, arg...) \\\n\tnetdev_notice(adapter->netdev, format, ## arg)\n\n/* Interrupt modes, as used by the IntMode parameter */\n#define E1000E_INT_MODE_LEGACY\t\t0\n#define E1000E_INT_MODE_MSI\t\t1\n#define E1000E_INT_MODE_MSIX\t\t2\n\n/* Tx/Rx descriptor defines */\n#define E1000_DEFAULT_TXD\t\t256\n#define E1000_MAX_TXD\t\t\t4096\n#define E1000_MIN_TXD\t\t\t64\n\n#define E1000_DEFAULT_RXD\t\t256\n#define E1000_MAX_RXD\t\t\t4096\n#define E1000_MIN_RXD\t\t\t64\n\n#define E1000_MIN_ITR_USECS\t\t10 /* 100000 irq/sec */\n#define E1000_MAX_ITR_USECS\t\t10000 /* 100    irq/sec */\n\n#define E1000_FC_PAUSE_TIME\t\t0x0680 /* 858 usec */\n\n/* How many Tx Descriptors do we need to call netif_wake_queue ? */\n/* How many Rx Buffers do we bundle into one write to the hardware ? */\n#define E1000_RX_BUFFER_WRITE\t\t16 /* Must be power of 2 */\n\n#define AUTO_ALL_MODES\t\t\t0\n#define E1000_EEPROM_APME\t\t0x0400\n\n#define E1000_MNG_VLAN_NONE\t\t(-1)\n\n#define DEFAULT_JUMBO\t\t\t9234\n\n/* Time to wait before putting the device into D3 if there's no link (in ms). */\n#define LINK_TIMEOUT\t\t100\n\n/* Count for polling __E1000_RESET condition every 10-20msec.\n * Experimentation has shown the reset can take approximately 210msec.\n */\n#define E1000_CHECK_RESET_COUNT\t\t25\n\n#define PCICFG_DESC_RING_STATUS\t\t0xe4\n#define FLUSH_DESC_REQUIRED\t\t0x100\n\n/* in the case of WTHRESH, it appears at least the 82571/2 hardware\n * writes back 4 descriptors when WTHRESH=5, and 3 descriptors when\n * WTHRESH=4, so a setting of 5 gives the most efficient bus\n * utilization but to avoid possible Tx stalls, set it to 1\n */\n#define E1000_TXDCTL_DMA_BURST_ENABLE                          \\\n\t(E1000_TXDCTL_GRAN | /* set descriptor granularity */  \\\n\t E1000_TXDCTL_COUNT_DESC |                             \\\n\t (1u << 16) | /* wthresh must be +1 more than desired */\\\n\t (1u << 8)  | /* hthresh */                             \\\n\t 0x1f)        /* pthresh */\n\n#define E1000_RXDCTL_DMA_BURST_ENABLE                          \\\n\t(0x01000000 | /* set descriptor granularity */         \\\n\t (4u << 16) | /* set writeback threshold    */         \\\n\t (4u << 8)  | /* set prefetch threshold     */         \\\n\t 0x20)        /* set hthresh                */\n\n#define E1000_TIDV_FPD BIT(31)\n#define E1000_RDTR_FPD BIT(31)\n\nenum e1000_boards {\n\tboard_82571,\n\tboard_82572,\n\tboard_82573,\n\tboard_82574,\n\tboard_82583,\n\tboard_80003es2lan,\n\tboard_ich8lan,\n\tboard_ich9lan,\n\tboard_ich10lan,\n\tboard_pchlan,\n\tboard_pch2lan,\n\tboard_pch_lpt,\n\tboard_pch_spt,\n\tboard_pch_cnp\n};\n\nstruct e1000_ps_page {\n\tstruct page *page;\n\tu64 dma; /* must be u64 - written to hw */\n};\n\n/* wrappers around a pointer to a socket buffer,\n * so a DMA handle can be stored along with the buffer\n */\nstruct e1000_buffer {\n\tdma_addr_t dma;\n\tstruct sk_buff *skb;\n\tunion {\n\t\t/* Tx */\n\t\tstruct {\n\t\t\tunsigned long time_stamp;\n\t\t\tu16 length;\n\t\t\tu16 next_to_watch;\n\t\t\tunsigned int segs;\n\t\t\tunsigned int bytecount;\n\t\t\tu16 mapped_as_page;\n\t\t};\n\t\t/* Rx */\n\t\tstruct {\n\t\t\t/* arrays of page information for packet split */\n\t\t\tstruct e1000_ps_page *ps_pages;\n\t\t\tstruct page *page;\n\t\t};\n\t};\n};\n\nstruct e1000_ring {\n\tstruct e1000_adapter *adapter;\t/* back pointer to adapter */\n\tvoid *desc;\t\t\t/* pointer to ring memory  */\n\tdma_addr_t dma;\t\t\t/* phys address of ring    */\n\tunsigned int size;\t\t/* length of ring in bytes */\n\tunsigned int count;\t\t/* number of desc. in ring */\n\n\tu16 next_to_use;\n\tu16 next_to_clean;\n\n\tvoid __iomem *head;\n\tvoid __iomem *tail;\n\n\t/* array of buffer information structs */\n\tstruct e1000_buffer *buffer_info;\n\n\tchar name[IFNAMSIZ + 5];\n\tu32 ims_val;\n\tu32 itr_val;\n\tvoid __iomem *itr_register;\n\tint set_itr;\n\n\tstruct sk_buff *rx_skb_top;\n};\n\n/* PHY register snapshot values */\nstruct e1000_phy_regs {\n\tu16 bmcr;\t\t/* basic mode control register    */\n\tu16 bmsr;\t\t/* basic mode status register     */\n\tu16 advertise;\t\t/* auto-negotiation advertisement */\n\tu16 lpa;\t\t/* link partner ability register  */\n\tu16 expansion;\t\t/* auto-negotiation expansion reg */\n\tu16 ctrl1000;\t\t/* 1000BASE-T control register    */\n\tu16 stat1000;\t\t/* 1000BASE-T status register     */\n\tu16 estatus;\t\t/* extended status register       */\n};\n\n/* board specific private data structure */\nstruct e1000_adapter {\n\tstruct timer_list watchdog_timer;\n\tstruct timer_list phy_info_timer;\n\tstruct timer_list blink_timer;\n\n\tstruct work_struct reset_task;\n\tstruct work_struct watchdog_task;\n\n\tconst struct e1000_info *ei;\n\n\tunsigned long active_vlans[BITS_TO_LONGS(VLAN_N_VID)];\n\tu32 bd_number;\n\tu32 rx_buffer_len;\n\tu16 mng_vlan_id;\n\tu16 link_speed;\n\tu16 link_duplex;\n\tu16 eeprom_vers;\n\n\t/* track device up/down/testing state */\n\tunsigned long state;\n\n\t/* Interrupt Throttle Rate */\n\tu32 itr;\n\tu32 itr_setting;\n\tu16 tx_itr;\n\tu16 rx_itr;\n\n\t/* Tx - one ring per active queue */\n\tstruct e1000_ring *tx_ring ____cacheline_aligned_in_smp;\n\tu32 tx_fifo_limit;\n\n\tstruct napi_struct napi;\n\n\tunsigned int uncorr_errors;\t/* uncorrectable ECC errors */\n\tunsigned int corr_errors;\t/* correctable ECC errors */\n\tunsigned int restart_queue;\n\tu32 txd_cmd;\n\n\tbool detect_tx_hung;\n\tbool tx_hang_recheck;\n\tu8 tx_timeout_factor;\n\n\tu32 tx_int_delay;\n\tu32 tx_abs_int_delay;\n\n\tunsigned int total_tx_bytes;\n\tunsigned int total_tx_packets;\n\tunsigned int total_rx_bytes;\n\tunsigned int total_rx_packets;\n\n\t/* Tx stats */\n\tu64 tpt_old;\n\tu64 colc_old;\n\tu32 gotc;\n\tu64 gotc_old;\n\tu32 tx_timeout_count;\n\tu32 tx_fifo_head;\n\tu32 tx_head_addr;\n\tu32 tx_fifo_size;\n\tu32 tx_dma_failed;\n\tu32 tx_hwtstamp_timeouts;\n\tu32 tx_hwtstamp_skipped;\n\n\t/* Rx */\n\tbool (*clean_rx)(struct e1000_ring *ring, int *work_done,\n\t\t\t int work_to_do) ____cacheline_aligned_in_smp;\n\tvoid (*alloc_rx_buf)(struct e1000_ring *ring, int cleaned_count,\n\t\t\t     gfp_t gfp);\n\tstruct e1000_ring *rx_ring;\n\n\tu32 rx_int_delay;\n\tu32 rx_abs_int_delay;\n\n\t/* Rx stats */\n\tu64 hw_csum_err;\n\tu64 hw_csum_good;\n\tu64 rx_hdr_split;\n\tu32 gorc;\n\tu64 gorc_old;\n\tu32 alloc_rx_buff_failed;\n\tu32 rx_dma_failed;\n\tu32 rx_hwtstamp_cleared;\n\n\tunsigned int rx_ps_pages;\n\tu16 rx_ps_bsize0;\n\tu32 max_frame_size;\n\tu32 min_frame_size;\n\n\t/* OS defined structs */\n\tstruct net_device *netdev;\n\tstruct pci_dev *pdev;\n\n\t/* structs defined in e1000_hw.h */\n\tstruct e1000_hw hw;\n\n\tspinlock_t stats64_lock;\t/* protects statistics counters */\n\tstruct e1000_hw_stats stats;\n\tstruct e1000_phy_info phy_info;\n\tstruct e1000_phy_stats phy_stats;\n\n\t/* Snapshot of PHY registers */\n\tstruct e1000_phy_regs phy_regs;\n\n\tstruct e1000_ring test_tx_ring;\n\tstruct e1000_ring test_rx_ring;\n\tu32 test_icr;\n\n\tu32 msg_enable;\n\tunsigned int num_vectors;\n\tstruct msix_entry *msix_entries;\n\tint int_mode;\n\tu32 eiac_mask;\n\n\tu32 eeprom_wol;\n\tu32 wol;\n\tu32 pba;\n\tu32 max_hw_frame_size;\n\n\tbool fc_autoneg;\n\n\tunsigned int flags;\n\tunsigned int flags2;\n\tstruct work_struct downshift_task;\n\tstruct work_struct update_phy_task;\n\tstruct work_struct print_hang_task;\n\n\tint phy_hang_count;\n\n\tu16 tx_ring_count;\n\tu16 rx_ring_count;\n\n\tstruct hwtstamp_config hwtstamp_config;\n\tstruct delayed_work systim_overflow_work;\n\tstruct sk_buff *tx_hwtstamp_skb;\n\tunsigned long tx_hwtstamp_start;\n\tstruct work_struct tx_hwtstamp_work;\n\tspinlock_t systim_lock;\t/* protects SYSTIML/H regsters */\n\tstruct cyclecounter cc;\n\tstruct timecounter tc;\n\tstruct ptp_clock *ptp_clock;\n\tstruct ptp_clock_info ptp_clock_info;\n\tstruct pm_qos_request pm_qos_req;\n\ts32 ptp_delta;\n\n\tu16 eee_advert;\n};\n\nstruct e1000_info {\n\tenum e1000_mac_type\tmac;\n\tunsigned int\t\tflags;\n\tunsigned int\t\tflags2;\n\tu32\t\t\tpba;\n\tu32\t\t\tmax_hw_frame_size;\n\ts32\t\t\t(*get_variants)(struct e1000_adapter *);\n\tconst struct e1000_mac_operations *mac_ops;\n\tconst struct e1000_phy_operations *phy_ops;\n\tconst struct e1000_nvm_operations *nvm_ops;\n};\n\ns32 e1000e_get_base_timinca(struct e1000_adapter *adapter, u32 *timinca);\n\n/* The system time is maintained by a 64-bit counter comprised of the 32-bit\n * SYSTIMH and SYSTIML registers.  How the counter increments (and therefore\n * its resolution) is based on the contents of the TIMINCA register - it\n * increments every incperiod (bits 31:24) clock ticks by incvalue (bits 23:0).\n * For the best accuracy, the incperiod should be as small as possible.  The\n * incvalue is scaled by a factor as large as possible (while still fitting\n * in bits 23:0) so that relatively small clock corrections can be made.\n *\n * As a result, a shift of INCVALUE_SHIFT_n is used to fit a value of\n * INCVALUE_n into the TIMINCA register allowing 32+8+(24-INCVALUE_SHIFT_n)\n * bits to count nanoseconds leaving the rest for fractional nonseconds.\n */\n#define INCVALUE_96MHZ\t\t125\n#define INCVALUE_SHIFT_96MHZ\t17\n#define INCPERIOD_SHIFT_96MHZ\t2\n#define INCPERIOD_96MHZ\t\t(12 >> INCPERIOD_SHIFT_96MHZ)\n\n#define INCVALUE_25MHZ\t\t40\n#define INCVALUE_SHIFT_25MHZ\t18\n#define INCPERIOD_25MHZ\t\t1\n\n#define INCVALUE_24MHZ\t\t125\n#define INCVALUE_SHIFT_24MHZ\t14\n#define INCPERIOD_24MHZ\t\t3\n\n#define INCVALUE_38400KHZ\t26\n#define INCVALUE_SHIFT_38400KHZ\t19\n#define INCPERIOD_38400KHZ\t1\n\n/* Another drawback of scaling the incvalue by a large factor is the\n * 64-bit SYSTIM register overflows more quickly.  This is dealt with\n * by simply reading the clock before it overflows.\n *\n * Clock\tns bits\tOverflows after\n * ~~~~~~\t~~~~~~~\t~~~~~~~~~~~~~~~\n * 96MHz\t47-bit\t2^(47-INCPERIOD_SHIFT_96MHz) / 10^9 / 3600 = 9.77 hrs\n * 25MHz\t46-bit\t2^46 / 10^9 / 3600 = 19.55 hours\n */\n#define E1000_SYSTIM_OVERFLOW_PERIOD\t(HZ * 60 * 60 * 4)\n#define E1000_MAX_82574_SYSTIM_REREADS\t50\n#define E1000_82574_SYSTIM_EPSILON\t(1ULL << 35ULL)\n\n/* hardware capability, feature, and workaround flags */\n#define FLAG_HAS_AMT                      BIT(0)\n#define FLAG_HAS_FLASH                    BIT(1)\n#define FLAG_HAS_HW_VLAN_FILTER           BIT(2)\n#define FLAG_HAS_WOL                      BIT(3)\n/* reserved BIT(4) */\n#define FLAG_HAS_CTRLEXT_ON_LOAD          BIT(5)\n#define FLAG_HAS_SWSM_ON_LOAD             BIT(6)\n#define FLAG_HAS_JUMBO_FRAMES             BIT(7)\n#define FLAG_READ_ONLY_NVM                BIT(8)\n#define FLAG_IS_ICH                       BIT(9)\n#define FLAG_HAS_MSIX                     BIT(10)\n#define FLAG_HAS_SMART_POWER_DOWN         BIT(11)\n#define FLAG_IS_QUAD_PORT_A               BIT(12)\n#define FLAG_IS_QUAD_PORT                 BIT(13)\n#define FLAG_HAS_HW_TIMESTAMP             BIT(14)\n#define FLAG_APME_IN_WUC                  BIT(15)\n#define FLAG_APME_IN_CTRL3                BIT(16)\n#define FLAG_APME_CHECK_PORT_B            BIT(17)\n#define FLAG_DISABLE_FC_PAUSE_TIME        BIT(18)\n#define FLAG_NO_WAKE_UCAST                BIT(19)\n#define FLAG_MNG_PT_ENABLED               BIT(20)\n#define FLAG_RESET_OVERWRITES_LAA         BIT(21)\n#define FLAG_TARC_SPEED_MODE_BIT          BIT(22)\n#define FLAG_TARC_SET_BIT_ZERO            BIT(23)\n#define FLAG_RX_NEEDS_RESTART             BIT(24)\n#define FLAG_LSC_GIG_SPEED_DROP           BIT(25)\n#define FLAG_SMART_POWER_DOWN             BIT(26)\n#define FLAG_MSI_ENABLED                  BIT(27)\n/* reserved BIT(28) */\n#define FLAG_TSO_FORCE                    BIT(29)\n#define FLAG_RESTART_NOW                  BIT(30)\n#define FLAG_MSI_TEST_FAILED              BIT(31)\n\n#define FLAG2_CRC_STRIPPING               BIT(0)\n#define FLAG2_HAS_PHY_WAKEUP              BIT(1)\n#define FLAG2_IS_DISCARDING               BIT(2)\n#define FLAG2_DISABLE_ASPM_L1             BIT(3)\n#define FLAG2_HAS_PHY_STATS               BIT(4)\n#define FLAG2_HAS_EEE                     BIT(5)\n#define FLAG2_DMA_BURST                   BIT(6)\n#define FLAG2_DISABLE_ASPM_L0S            BIT(7)\n#define FLAG2_DISABLE_AIM                 BIT(8)\n#define FLAG2_CHECK_PHY_HANG              BIT(9)\n#define FLAG2_NO_DISABLE_RX               BIT(10)\n#define FLAG2_PCIM2PCI_ARBITER_WA         BIT(11)\n#define FLAG2_DFLT_CRC_STRIPPING          BIT(12)\n#define FLAG2_CHECK_RX_HWTSTAMP           BIT(13)\n#define FLAG2_CHECK_SYSTIM_OVERFLOW       BIT(14)\n#define FLAG2_ENABLE_S0IX_FLOWS           BIT(15)\n\n#define E1000_RX_DESC_PS(R, i)\t    \\\n\t(&(((union e1000_rx_desc_packet_split *)((R).desc))[i]))\n#define E1000_RX_DESC_EXT(R, i)\t    \\\n\t(&(((union e1000_rx_desc_extended *)((R).desc))[i]))\n#define E1000_GET_DESC(R, i, type)\t(&(((struct type *)((R).desc))[i]))\n#define E1000_TX_DESC(R, i)\t\tE1000_GET_DESC(R, i, e1000_tx_desc)\n#define E1000_CONTEXT_DESC(R, i)\tE1000_GET_DESC(R, i, e1000_context_desc)\n\nenum e1000_state_t {\n\t__E1000_TESTING,\n\t__E1000_RESETTING,\n\t__E1000_ACCESS_SHARED_RESOURCE,\n\t__E1000_DOWN\n};\n\nenum latency_range {\n\tlowest_latency = 0,\n\tlow_latency = 1,\n\tbulk_latency = 2,\n\tlatency_invalid = 255\n};\n\nextern char e1000e_driver_name[];\n\nvoid e1000e_check_options(struct e1000_adapter *adapter);\nvoid e1000e_set_ethtool_ops(struct net_device *netdev);\n\nint e1000e_open(struct net_device *netdev);\nint e1000e_close(struct net_device *netdev);\nvoid e1000e_up(struct e1000_adapter *adapter);\nvoid e1000e_down(struct e1000_adapter *adapter, bool reset);\nvoid e1000e_reinit_locked(struct e1000_adapter *adapter);\nvoid e1000e_reset(struct e1000_adapter *adapter);\nvoid e1000e_power_up_phy(struct e1000_adapter *adapter);\nint e1000e_setup_rx_resources(struct e1000_ring *ring);\nint e1000e_setup_tx_resources(struct e1000_ring *ring);\nvoid e1000e_free_rx_resources(struct e1000_ring *ring);\nvoid e1000e_free_tx_resources(struct e1000_ring *ring);\nvoid e1000e_get_stats64(struct net_device *netdev,\n\t\t\tstruct rtnl_link_stats64 *stats);\nvoid e1000e_set_interrupt_capability(struct e1000_adapter *adapter);\nvoid e1000e_reset_interrupt_capability(struct e1000_adapter *adapter);\nvoid e1000e_get_hw_control(struct e1000_adapter *adapter);\nvoid e1000e_release_hw_control(struct e1000_adapter *adapter);\nvoid e1000e_write_itr(struct e1000_adapter *adapter, u32 itr);\n\nextern unsigned int copybreak;\n\nextern const struct e1000_info e1000_82571_info;\nextern const struct e1000_info e1000_82572_info;\nextern const struct e1000_info e1000_82573_info;\nextern const struct e1000_info e1000_82574_info;\nextern const struct e1000_info e1000_82583_info;\nextern const struct e1000_info e1000_ich8_info;\nextern const struct e1000_info e1000_ich9_info;\nextern const struct e1000_info e1000_ich10_info;\nextern const struct e1000_info e1000_pch_info;\nextern const struct e1000_info e1000_pch2_info;\nextern const struct e1000_info e1000_pch_lpt_info;\nextern const struct e1000_info e1000_pch_spt_info;\nextern const struct e1000_info e1000_pch_cnp_info;\nextern const struct e1000_info e1000_es2_info;\n\nvoid e1000e_ptp_init(struct e1000_adapter *adapter);\nvoid e1000e_ptp_remove(struct e1000_adapter *adapter);\n\nu64 e1000e_read_systim(struct e1000_adapter *adapter,\n\t\t       struct ptp_system_timestamp *sts);\n\nstatic inline s32 e1000_phy_hw_reset(struct e1000_hw *hw)\n{\n\treturn hw->phy.ops.reset(hw);\n}\n\nstatic inline s32 e1e_rphy(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\treturn hw->phy.ops.read_reg(hw, offset, data);\n}\n\nstatic inline s32 e1e_rphy_locked(struct e1000_hw *hw, u32 offset, u16 *data)\n{\n\treturn hw->phy.ops.read_reg_locked(hw, offset, data);\n}\n\nstatic inline s32 e1e_wphy(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\treturn hw->phy.ops.write_reg(hw, offset, data);\n}\n\nstatic inline s32 e1e_wphy_locked(struct e1000_hw *hw, u32 offset, u16 data)\n{\n\treturn hw->phy.ops.write_reg_locked(hw, offset, data);\n}\n\nvoid e1000e_reload_nvm_generic(struct e1000_hw *hw);\n\nstatic inline s32 e1000e_read_mac_addr(struct e1000_hw *hw)\n{\n\tif (hw->mac.ops.read_mac_addr)\n\t\treturn hw->mac.ops.read_mac_addr(hw);\n\n\treturn e1000_read_mac_addr_generic(hw);\n}\n\nstatic inline s32 e1000_validate_nvm_checksum(struct e1000_hw *hw)\n{\n\treturn hw->nvm.ops.validate(hw);\n}\n\nstatic inline s32 e1000e_update_nvm_checksum(struct e1000_hw *hw)\n{\n\treturn hw->nvm.ops.update(hw);\n}\n\nstatic inline s32 e1000_read_nvm(struct e1000_hw *hw, u16 offset, u16 words,\n\t\t\t\t u16 *data)\n{\n\treturn hw->nvm.ops.read(hw, offset, words, data);\n}\n\nstatic inline s32 e1000_write_nvm(struct e1000_hw *hw, u16 offset, u16 words,\n\t\t\t\t  u16 *data)\n{\n\treturn hw->nvm.ops.write(hw, offset, words, data);\n}\n\nstatic inline s32 e1000_get_phy_info(struct e1000_hw *hw)\n{\n\treturn hw->phy.ops.get_info(hw);\n}\n\nstatic inline u32 __er32(struct e1000_hw *hw, unsigned long reg)\n{\n\treturn readl(hw->hw_addr + reg);\n}\n\n#define er32(reg)\t__er32(hw, E1000_##reg)\n\nvoid __ew32(struct e1000_hw *hw, unsigned long reg, u32 val);\n\n#define ew32(reg, val)\t__ew32(hw, E1000_##reg, (val))\n\n#define e1e_flush()\ter32(STATUS)\n\n#define E1000_WRITE_REG_ARRAY(a, reg, offset, value) \\\n\t(__ew32((a), (reg + ((offset) << 2)), (value)))\n\n#define E1000_READ_REG_ARRAY(a, reg, offset) \\\n\t(readl((a)->hw_addr + reg + ((offset) << 2)))\n\n#endif /* _E1000_H_ */\n"}, "3": {"id": 3, "path": "/src/include/linux/netdevice.h", "content": "/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tDefinitions for the Interfaces handler.\n *\n * Version:\t@(#)dev.h\t1.0.10\t08/12/93\n *\n * Authors:\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\t\tCorey Minyard <wf-rch!minyard@relay.EU.net>\n *\t\tDonald J. Becker, <becker@cesdis.gsfc.nasa.gov>\n *\t\tAlan Cox, <alan@lxorguk.ukuu.org.uk>\n *\t\tBjorn Ekwall. <bj0rn@blox.se>\n *              Pekka Riikonen <priikone@poseidon.pspt.fi>\n *\n *\t\tMoved to /usr/include/linux for NET3\n */\n#ifndef _LINUX_NETDEVICE_H\n#define _LINUX_NETDEVICE_H\n\n#include <linux/timer.h>\n#include <linux/bug.h>\n#include <linux/delay.h>\n#include <linux/atomic.h>\n#include <linux/prefetch.h>\n#include <asm/cache.h>\n#include <asm/byteorder.h>\n\n#include <linux/percpu.h>\n#include <linux/rculist.h>\n#include <linux/workqueue.h>\n#include <linux/dynamic_queue_limits.h>\n\n#include <net/net_namespace.h>\n#ifdef CONFIG_DCB\n#include <net/dcbnl.h>\n#endif\n#include <net/netprio_cgroup.h>\n#include <net/xdp.h>\n\n#include <linux/netdev_features.h>\n#include <linux/neighbour.h>\n#include <uapi/linux/netdevice.h>\n#include <uapi/linux/if_bonding.h>\n#include <uapi/linux/pkt_cls.h>\n#include <linux/hashtable.h>\n\nstruct netpoll_info;\nstruct device;\nstruct ethtool_ops;\nstruct phy_device;\nstruct dsa_port;\nstruct ip_tunnel_parm;\nstruct macsec_context;\nstruct macsec_ops;\n\nstruct sfp_bus;\n/* 802.11 specific */\nstruct wireless_dev;\n/* 802.15.4 specific */\nstruct wpan_dev;\nstruct mpls_dev;\n/* UDP Tunnel offloads */\nstruct udp_tunnel_info;\nstruct udp_tunnel_nic_info;\nstruct udp_tunnel_nic;\nstruct bpf_prog;\nstruct xdp_buff;\n\nvoid synchronize_net(void);\nvoid netdev_set_default_ethtool_ops(struct net_device *dev,\n\t\t\t\t    const struct ethtool_ops *ops);\n\n/* Backlog congestion levels */\n#define NET_RX_SUCCESS\t\t0\t/* keep 'em coming, baby */\n#define NET_RX_DROP\t\t1\t/* packet dropped */\n\n#define MAX_NEST_DEV 8\n\n/*\n * Transmit return codes: transmit return codes originate from three different\n * namespaces:\n *\n * - qdisc return codes\n * - driver transmit return codes\n * - errno values\n *\n * Drivers are allowed to return any one of those in their hard_start_xmit()\n * function. Real network devices commonly used with qdiscs should only return\n * the driver transmit return codes though - when qdiscs are used, the actual\n * transmission happens asynchronously, so the value is not propagated to\n * higher layers. Virtual network devices transmit synchronously; in this case\n * the driver transmit return codes are consumed by dev_queue_xmit(), and all\n * others are propagated to higher layers.\n */\n\n/* qdisc ->enqueue() return codes. */\n#define NET_XMIT_SUCCESS\t0x00\n#define NET_XMIT_DROP\t\t0x01\t/* skb dropped\t\t\t*/\n#define NET_XMIT_CN\t\t0x02\t/* congestion notification\t*/\n#define NET_XMIT_MASK\t\t0x0f\t/* qdisc flags in net/sch_generic.h */\n\n/* NET_XMIT_CN is special. It does not guarantee that this packet is lost. It\n * indicates that the device will soon be dropping packets, or already drops\n * some packets of the same priority; prompting us to send less aggressively. */\n#define net_xmit_eval(e)\t((e) == NET_XMIT_CN ? 0 : (e))\n#define net_xmit_errno(e)\t((e) != NET_XMIT_CN ? -ENOBUFS : 0)\n\n/* Driver transmit return codes */\n#define NETDEV_TX_MASK\t\t0xf0\n\nenum netdev_tx {\n\t__NETDEV_TX_MIN\t = INT_MIN,\t/* make sure enum is signed */\n\tNETDEV_TX_OK\t = 0x00,\t/* driver took care of packet */\n\tNETDEV_TX_BUSY\t = 0x10,\t/* driver tx path was busy*/\n};\ntypedef enum netdev_tx netdev_tx_t;\n\n/*\n * Current order: NETDEV_TX_MASK > NET_XMIT_MASK >= 0 is significant;\n * hard_start_xmit() return < NET_XMIT_MASK means skb was consumed.\n */\nstatic inline bool dev_xmit_complete(int rc)\n{\n\t/*\n\t * Positive cases with an skb consumed by a driver:\n\t * - successful transmission (rc == NETDEV_TX_OK)\n\t * - error while transmitting (rc < 0)\n\t * - error while queueing to a different device (rc & NET_XMIT_MASK)\n\t */\n\tif (likely(rc < NET_XMIT_MASK))\n\t\treturn true;\n\n\treturn false;\n}\n\n/*\n *\tCompute the worst-case header length according to the protocols\n *\tused.\n */\n\n#if defined(CONFIG_HYPERV_NET)\n# define LL_MAX_HEADER 128\n#elif defined(CONFIG_WLAN) || IS_ENABLED(CONFIG_AX25)\n# if defined(CONFIG_MAC80211_MESH)\n#  define LL_MAX_HEADER 128\n# else\n#  define LL_MAX_HEADER 96\n# endif\n#else\n# define LL_MAX_HEADER 32\n#endif\n\n#if !IS_ENABLED(CONFIG_NET_IPIP) && !IS_ENABLED(CONFIG_NET_IPGRE) && \\\n    !IS_ENABLED(CONFIG_IPV6_SIT) && !IS_ENABLED(CONFIG_IPV6_TUNNEL)\n#define MAX_HEADER LL_MAX_HEADER\n#else\n#define MAX_HEADER (LL_MAX_HEADER + 48)\n#endif\n\n/*\n *\tOld network device statistics. Fields are native words\n *\t(unsigned long) so they can be read and written atomically.\n */\n\nstruct net_device_stats {\n\tunsigned long\trx_packets;\n\tunsigned long\ttx_packets;\n\tunsigned long\trx_bytes;\n\tunsigned long\ttx_bytes;\n\tunsigned long\trx_errors;\n\tunsigned long\ttx_errors;\n\tunsigned long\trx_dropped;\n\tunsigned long\ttx_dropped;\n\tunsigned long\tmulticast;\n\tunsigned long\tcollisions;\n\tunsigned long\trx_length_errors;\n\tunsigned long\trx_over_errors;\n\tunsigned long\trx_crc_errors;\n\tunsigned long\trx_frame_errors;\n\tunsigned long\trx_fifo_errors;\n\tunsigned long\trx_missed_errors;\n\tunsigned long\ttx_aborted_errors;\n\tunsigned long\ttx_carrier_errors;\n\tunsigned long\ttx_fifo_errors;\n\tunsigned long\ttx_heartbeat_errors;\n\tunsigned long\ttx_window_errors;\n\tunsigned long\trx_compressed;\n\tunsigned long\ttx_compressed;\n};\n\n\n#include <linux/cache.h>\n#include <linux/skbuff.h>\n\n#ifdef CONFIG_RPS\n#include <linux/static_key.h>\nextern struct static_key_false rps_needed;\nextern struct static_key_false rfs_needed;\n#endif\n\nstruct neighbour;\nstruct neigh_parms;\nstruct sk_buff;\n\nstruct netdev_hw_addr {\n\tstruct list_head\tlist;\n\tunsigned char\t\taddr[MAX_ADDR_LEN];\n\tunsigned char\t\ttype;\n#define NETDEV_HW_ADDR_T_LAN\t\t1\n#define NETDEV_HW_ADDR_T_SAN\t\t2\n#define NETDEV_HW_ADDR_T_UNICAST\t3\n#define NETDEV_HW_ADDR_T_MULTICAST\t4\n\tbool\t\t\tglobal_use;\n\tint\t\t\tsync_cnt;\n\tint\t\t\trefcount;\n\tint\t\t\tsynced;\n\tstruct rcu_head\t\trcu_head;\n};\n\nstruct netdev_hw_addr_list {\n\tstruct list_head\tlist;\n\tint\t\t\tcount;\n};\n\n#define netdev_hw_addr_list_count(l) ((l)->count)\n#define netdev_hw_addr_list_empty(l) (netdev_hw_addr_list_count(l) == 0)\n#define netdev_hw_addr_list_for_each(ha, l) \\\n\tlist_for_each_entry(ha, &(l)->list, list)\n\n#define netdev_uc_count(dev) netdev_hw_addr_list_count(&(dev)->uc)\n#define netdev_uc_empty(dev) netdev_hw_addr_list_empty(&(dev)->uc)\n#define netdev_for_each_uc_addr(ha, dev) \\\n\tnetdev_hw_addr_list_for_each(ha, &(dev)->uc)\n\n#define netdev_mc_count(dev) netdev_hw_addr_list_count(&(dev)->mc)\n#define netdev_mc_empty(dev) netdev_hw_addr_list_empty(&(dev)->mc)\n#define netdev_for_each_mc_addr(ha, dev) \\\n\tnetdev_hw_addr_list_for_each(ha, &(dev)->mc)\n\nstruct hh_cache {\n\tunsigned int\thh_len;\n\tseqlock_t\thh_lock;\n\n\t/* cached hardware header; allow for machine alignment needs.        */\n#define HH_DATA_MOD\t16\n#define HH_DATA_OFF(__len) \\\n\t(HH_DATA_MOD - (((__len - 1) & (HH_DATA_MOD - 1)) + 1))\n#define HH_DATA_ALIGN(__len) \\\n\t(((__len)+(HH_DATA_MOD-1))&~(HH_DATA_MOD - 1))\n\tunsigned long\thh_data[HH_DATA_ALIGN(LL_MAX_HEADER) / sizeof(long)];\n};\n\n/* Reserve HH_DATA_MOD byte-aligned hard_header_len, but at least that much.\n * Alternative is:\n *   dev->hard_header_len ? (dev->hard_header_len +\n *                           (HH_DATA_MOD - 1)) & ~(HH_DATA_MOD - 1) : 0\n *\n * We could use other alignment values, but we must maintain the\n * relationship HH alignment <= LL alignment.\n */\n#define LL_RESERVED_SPACE(dev) \\\n\t((((dev)->hard_header_len+(dev)->needed_headroom)&~(HH_DATA_MOD - 1)) + HH_DATA_MOD)\n#define LL_RESERVED_SPACE_EXTRA(dev,extra) \\\n\t((((dev)->hard_header_len+(dev)->needed_headroom+(extra))&~(HH_DATA_MOD - 1)) + HH_DATA_MOD)\n\nstruct header_ops {\n\tint\t(*create) (struct sk_buff *skb, struct net_device *dev,\n\t\t\t   unsigned short type, const void *daddr,\n\t\t\t   const void *saddr, unsigned int len);\n\tint\t(*parse)(const struct sk_buff *skb, unsigned char *haddr);\n\tint\t(*cache)(const struct neighbour *neigh, struct hh_cache *hh, __be16 type);\n\tvoid\t(*cache_update)(struct hh_cache *hh,\n\t\t\t\tconst struct net_device *dev,\n\t\t\t\tconst unsigned char *haddr);\n\tbool\t(*validate)(const char *ll_header, unsigned int len);\n\t__be16\t(*parse_protocol)(const struct sk_buff *skb);\n};\n\n/* These flag bits are private to the generic network queueing\n * layer; they may not be explicitly referenced by any other\n * code.\n */\n\nenum netdev_state_t {\n\t__LINK_STATE_START,\n\t__LINK_STATE_PRESENT,\n\t__LINK_STATE_NOCARRIER,\n\t__LINK_STATE_LINKWATCH_PENDING,\n\t__LINK_STATE_DORMANT,\n\t__LINK_STATE_TESTING,\n};\n\n\n/*\n * This structure holds boot-time configured netdevice settings. They\n * are then used in the device probing.\n */\nstruct netdev_boot_setup {\n\tchar name[IFNAMSIZ];\n\tstruct ifmap map;\n};\n#define NETDEV_BOOT_SETUP_MAX 8\n\nint __init netdev_boot_setup(char *str);\n\nstruct gro_list {\n\tstruct list_head\tlist;\n\tint\t\t\tcount;\n};\n\n/*\n * size of gro hash buckets, must less than bit number of\n * napi_struct::gro_bitmask\n */\n#define GRO_HASH_BUCKETS\t8\n\n/*\n * Structure for NAPI scheduling similar to tasklet but with weighting\n */\nstruct napi_struct {\n\t/* The poll_list must only be managed by the entity which\n\t * changes the state of the NAPI_STATE_SCHED bit.  This means\n\t * whoever atomically sets that bit can add this napi_struct\n\t * to the per-CPU poll_list, and whoever clears that bit\n\t * can remove from the list right before clearing the bit.\n\t */\n\tstruct list_head\tpoll_list;\n\n\tunsigned long\t\tstate;\n\tint\t\t\tweight;\n\tint\t\t\tdefer_hard_irqs_count;\n\tunsigned long\t\tgro_bitmask;\n\tint\t\t\t(*poll)(struct napi_struct *, int);\n#ifdef CONFIG_NETPOLL\n\tint\t\t\tpoll_owner;\n#endif\n\tstruct net_device\t*dev;\n\tstruct gro_list\t\tgro_hash[GRO_HASH_BUCKETS];\n\tstruct sk_buff\t\t*skb;\n\tstruct list_head\trx_list; /* Pending GRO_NORMAL skbs */\n\tint\t\t\trx_count; /* length of rx_list */\n\tstruct hrtimer\t\ttimer;\n\tstruct list_head\tdev_list;\n\tstruct hlist_node\tnapi_hash_node;\n\tunsigned int\t\tnapi_id;\n\tstruct task_struct\t*thread;\n};\n\nenum {\n\tNAPI_STATE_SCHED,\t\t/* Poll is scheduled */\n\tNAPI_STATE_MISSED,\t\t/* reschedule a napi */\n\tNAPI_STATE_DISABLE,\t\t/* Disable pending */\n\tNAPI_STATE_NPSVC,\t\t/* Netpoll - don't dequeue from poll_list */\n\tNAPI_STATE_LISTED,\t\t/* NAPI added to system lists */\n\tNAPI_STATE_NO_BUSY_POLL,\t/* Do not add in napi_hash, no busy polling */\n\tNAPI_STATE_IN_BUSY_POLL,\t/* sk_busy_loop() owns this NAPI */\n\tNAPI_STATE_PREFER_BUSY_POLL,\t/* prefer busy-polling over softirq processing*/\n\tNAPI_STATE_THREADED,\t\t/* The poll is performed inside its own thread*/\n};\n\nenum {\n\tNAPIF_STATE_SCHED\t\t= BIT(NAPI_STATE_SCHED),\n\tNAPIF_STATE_MISSED\t\t= BIT(NAPI_STATE_MISSED),\n\tNAPIF_STATE_DISABLE\t\t= BIT(NAPI_STATE_DISABLE),\n\tNAPIF_STATE_NPSVC\t\t= BIT(NAPI_STATE_NPSVC),\n\tNAPIF_STATE_LISTED\t\t= BIT(NAPI_STATE_LISTED),\n\tNAPIF_STATE_NO_BUSY_POLL\t= BIT(NAPI_STATE_NO_BUSY_POLL),\n\tNAPIF_STATE_IN_BUSY_POLL\t= BIT(NAPI_STATE_IN_BUSY_POLL),\n\tNAPIF_STATE_PREFER_BUSY_POLL\t= BIT(NAPI_STATE_PREFER_BUSY_POLL),\n\tNAPIF_STATE_THREADED\t\t= BIT(NAPI_STATE_THREADED),\n};\n\nenum gro_result {\n\tGRO_MERGED,\n\tGRO_MERGED_FREE,\n\tGRO_HELD,\n\tGRO_NORMAL,\n\tGRO_CONSUMED,\n};\ntypedef enum gro_result gro_result_t;\n\n/*\n * enum rx_handler_result - Possible return values for rx_handlers.\n * @RX_HANDLER_CONSUMED: skb was consumed by rx_handler, do not process it\n * further.\n * @RX_HANDLER_ANOTHER: Do another round in receive path. This is indicated in\n * case skb->dev was changed by rx_handler.\n * @RX_HANDLER_EXACT: Force exact delivery, no wildcard.\n * @RX_HANDLER_PASS: Do nothing, pass the skb as if no rx_handler was called.\n *\n * rx_handlers are functions called from inside __netif_receive_skb(), to do\n * special processing of the skb, prior to delivery to protocol handlers.\n *\n * Currently, a net_device can only have a single rx_handler registered. Trying\n * to register a second rx_handler will return -EBUSY.\n *\n * To register a rx_handler on a net_device, use netdev_rx_handler_register().\n * To unregister a rx_handler on a net_device, use\n * netdev_rx_handler_unregister().\n *\n * Upon return, rx_handler is expected to tell __netif_receive_skb() what to\n * do with the skb.\n *\n * If the rx_handler consumed the skb in some way, it should return\n * RX_HANDLER_CONSUMED. This is appropriate when the rx_handler arranged for\n * the skb to be delivered in some other way.\n *\n * If the rx_handler changed skb->dev, to divert the skb to another\n * net_device, it should return RX_HANDLER_ANOTHER. The rx_handler for the\n * new device will be called if it exists.\n *\n * If the rx_handler decides the skb should be ignored, it should return\n * RX_HANDLER_EXACT. The skb will only be delivered to protocol handlers that\n * are registered on exact device (ptype->dev == skb->dev).\n *\n * If the rx_handler didn't change skb->dev, but wants the skb to be normally\n * delivered, it should return RX_HANDLER_PASS.\n *\n * A device without a registered rx_handler will behave as if rx_handler\n * returned RX_HANDLER_PASS.\n */\n\nenum rx_handler_result {\n\tRX_HANDLER_CONSUMED,\n\tRX_HANDLER_ANOTHER,\n\tRX_HANDLER_EXACT,\n\tRX_HANDLER_PASS,\n};\ntypedef enum rx_handler_result rx_handler_result_t;\ntypedef rx_handler_result_t rx_handler_func_t(struct sk_buff **pskb);\n\nvoid __napi_schedule(struct napi_struct *n);\nvoid __napi_schedule_irqoff(struct napi_struct *n);\n\nstatic inline bool napi_disable_pending(struct napi_struct *n)\n{\n\treturn test_bit(NAPI_STATE_DISABLE, &n->state);\n}\n\nstatic inline bool napi_prefer_busy_poll(struct napi_struct *n)\n{\n\treturn test_bit(NAPI_STATE_PREFER_BUSY_POLL, &n->state);\n}\n\nbool napi_schedule_prep(struct napi_struct *n);\n\n/**\n *\tnapi_schedule - schedule NAPI poll\n *\t@n: NAPI context\n *\n * Schedule NAPI poll routine to be called if it is not already\n * running.\n */\nstatic inline void napi_schedule(struct napi_struct *n)\n{\n\tif (napi_schedule_prep(n))\n\t\t__napi_schedule(n);\n}\n\n/**\n *\tnapi_schedule_irqoff - schedule NAPI poll\n *\t@n: NAPI context\n *\n * Variant of napi_schedule(), assuming hard irqs are masked.\n */\nstatic inline void napi_schedule_irqoff(struct napi_struct *n)\n{\n\tif (napi_schedule_prep(n))\n\t\t__napi_schedule_irqoff(n);\n}\n\n/* Try to reschedule poll. Called by dev->poll() after napi_complete().  */\nstatic inline bool napi_reschedule(struct napi_struct *napi)\n{\n\tif (napi_schedule_prep(napi)) {\n\t\t__napi_schedule(napi);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool napi_complete_done(struct napi_struct *n, int work_done);\n/**\n *\tnapi_complete - NAPI processing complete\n *\t@n: NAPI context\n *\n * Mark NAPI processing as complete.\n * Consider using napi_complete_done() instead.\n * Return false if device should avoid rearming interrupts.\n */\nstatic inline bool napi_complete(struct napi_struct *n)\n{\n\treturn napi_complete_done(n, 0);\n}\n\nint dev_set_threaded(struct net_device *dev, bool threaded);\n\n/**\n *\tnapi_disable - prevent NAPI from scheduling\n *\t@n: NAPI context\n *\n * Stop NAPI from being scheduled on this context.\n * Waits till any outstanding processing completes.\n */\nvoid napi_disable(struct napi_struct *n);\n\nvoid napi_enable(struct napi_struct *n);\n\n/**\n *\tnapi_synchronize - wait until NAPI is not running\n *\t@n: NAPI context\n *\n * Wait until NAPI is done being scheduled on this context.\n * Waits till any outstanding processing completes but\n * does not disable future activations.\n */\nstatic inline void napi_synchronize(const struct napi_struct *n)\n{\n\tif (IS_ENABLED(CONFIG_SMP))\n\t\twhile (test_bit(NAPI_STATE_SCHED, &n->state))\n\t\t\tmsleep(1);\n\telse\n\t\tbarrier();\n}\n\n/**\n *\tnapi_if_scheduled_mark_missed - if napi is running, set the\n *\tNAPIF_STATE_MISSED\n *\t@n: NAPI context\n *\n * If napi is running, set the NAPIF_STATE_MISSED, and return true if\n * NAPI is scheduled.\n **/\nstatic inline bool napi_if_scheduled_mark_missed(struct napi_struct *n)\n{\n\tunsigned long val, new;\n\n\tdo {\n\t\tval = READ_ONCE(n->state);\n\t\tif (val & NAPIF_STATE_DISABLE)\n\t\t\treturn true;\n\n\t\tif (!(val & NAPIF_STATE_SCHED))\n\t\t\treturn false;\n\n\t\tnew = val | NAPIF_STATE_MISSED;\n\t} while (cmpxchg(&n->state, val, new) != val);\n\n\treturn true;\n}\n\nenum netdev_queue_state_t {\n\t__QUEUE_STATE_DRV_XOFF,\n\t__QUEUE_STATE_STACK_XOFF,\n\t__QUEUE_STATE_FROZEN,\n};\n\n#define QUEUE_STATE_DRV_XOFF\t(1 << __QUEUE_STATE_DRV_XOFF)\n#define QUEUE_STATE_STACK_XOFF\t(1 << __QUEUE_STATE_STACK_XOFF)\n#define QUEUE_STATE_FROZEN\t(1 << __QUEUE_STATE_FROZEN)\n\n#define QUEUE_STATE_ANY_XOFF\t(QUEUE_STATE_DRV_XOFF | QUEUE_STATE_STACK_XOFF)\n#define QUEUE_STATE_ANY_XOFF_OR_FROZEN (QUEUE_STATE_ANY_XOFF | \\\n\t\t\t\t\tQUEUE_STATE_FROZEN)\n#define QUEUE_STATE_DRV_XOFF_OR_FROZEN (QUEUE_STATE_DRV_XOFF | \\\n\t\t\t\t\tQUEUE_STATE_FROZEN)\n\n/*\n * __QUEUE_STATE_DRV_XOFF is used by drivers to stop the transmit queue.  The\n * netif_tx_* functions below are used to manipulate this flag.  The\n * __QUEUE_STATE_STACK_XOFF flag is used by the stack to stop the transmit\n * queue independently.  The netif_xmit_*stopped functions below are called\n * to check if the queue has been stopped by the driver or stack (either\n * of the XOFF bits are set in the state).  Drivers should not need to call\n * netif_xmit*stopped functions, they should only be using netif_tx_*.\n */\n\nstruct netdev_queue {\n/*\n * read-mostly part\n */\n\tstruct net_device\t*dev;\n\tstruct Qdisc __rcu\t*qdisc;\n\tstruct Qdisc\t\t*qdisc_sleeping;\n#ifdef CONFIG_SYSFS\n\tstruct kobject\t\tkobj;\n#endif\n#if defined(CONFIG_XPS) && defined(CONFIG_NUMA)\n\tint\t\t\tnuma_node;\n#endif\n\tunsigned long\t\ttx_maxrate;\n\t/*\n\t * Number of TX timeouts for this queue\n\t * (/sys/class/net/DEV/Q/trans_timeout)\n\t */\n\tunsigned long\t\ttrans_timeout;\n\n\t/* Subordinate device that the queue has been assigned to */\n\tstruct net_device\t*sb_dev;\n#ifdef CONFIG_XDP_SOCKETS\n\tstruct xsk_buff_pool    *pool;\n#endif\n/*\n * write-mostly part\n */\n\tspinlock_t\t\t_xmit_lock ____cacheline_aligned_in_smp;\n\tint\t\t\txmit_lock_owner;\n\t/*\n\t * Time (in jiffies) of last Tx\n\t */\n\tunsigned long\t\ttrans_start;\n\n\tunsigned long\t\tstate;\n\n#ifdef CONFIG_BQL\n\tstruct dql\t\tdql;\n#endif\n} ____cacheline_aligned_in_smp;\n\nextern int sysctl_fb_tunnels_only_for_init_net;\nextern int sysctl_devconf_inherit_init_net;\n\n/*\n * sysctl_fb_tunnels_only_for_init_net == 0 : For all netns\n *                                     == 1 : For initns only\n *                                     == 2 : For none.\n */\nstatic inline bool net_has_fallback_tunnels(const struct net *net)\n{\n\treturn !IS_ENABLED(CONFIG_SYSCTL) ||\n\t       !sysctl_fb_tunnels_only_for_init_net ||\n\t       (net == &init_net && sysctl_fb_tunnels_only_for_init_net == 1);\n}\n\nstatic inline int netdev_queue_numa_node_read(const struct netdev_queue *q)\n{\n#if defined(CONFIG_XPS) && defined(CONFIG_NUMA)\n\treturn q->numa_node;\n#else\n\treturn NUMA_NO_NODE;\n#endif\n}\n\nstatic inline void netdev_queue_numa_node_write(struct netdev_queue *q, int node)\n{\n#if defined(CONFIG_XPS) && defined(CONFIG_NUMA)\n\tq->numa_node = node;\n#endif\n}\n\n#ifdef CONFIG_RPS\n/*\n * This structure holds an RPS map which can be of variable length.  The\n * map is an array of CPUs.\n */\nstruct rps_map {\n\tunsigned int len;\n\tstruct rcu_head rcu;\n\tu16 cpus[];\n};\n#define RPS_MAP_SIZE(_num) (sizeof(struct rps_map) + ((_num) * sizeof(u16)))\n\n/*\n * The rps_dev_flow structure contains the mapping of a flow to a CPU, the\n * tail pointer for that CPU's input queue at the time of last enqueue, and\n * a hardware filter index.\n */\nstruct rps_dev_flow {\n\tu16 cpu;\n\tu16 filter;\n\tunsigned int last_qtail;\n};\n#define RPS_NO_FILTER 0xffff\n\n/*\n * The rps_dev_flow_table structure contains a table of flow mappings.\n */\nstruct rps_dev_flow_table {\n\tunsigned int mask;\n\tstruct rcu_head rcu;\n\tstruct rps_dev_flow flows[];\n};\n#define RPS_DEV_FLOW_TABLE_SIZE(_num) (sizeof(struct rps_dev_flow_table) + \\\n    ((_num) * sizeof(struct rps_dev_flow)))\n\n/*\n * The rps_sock_flow_table contains mappings of flows to the last CPU\n * on which they were processed by the application (set in recvmsg).\n * Each entry is a 32bit value. Upper part is the high-order bits\n * of flow hash, lower part is CPU number.\n * rps_cpu_mask is used to partition the space, depending on number of\n * possible CPUs : rps_cpu_mask = roundup_pow_of_two(nr_cpu_ids) - 1\n * For example, if 64 CPUs are possible, rps_cpu_mask = 0x3f,\n * meaning we use 32-6=26 bits for the hash.\n */\nstruct rps_sock_flow_table {\n\tu32\tmask;\n\n\tu32\tents[] ____cacheline_aligned_in_smp;\n};\n#define\tRPS_SOCK_FLOW_TABLE_SIZE(_num) (offsetof(struct rps_sock_flow_table, ents[_num]))\n\n#define RPS_NO_CPU 0xffff\n\nextern u32 rps_cpu_mask;\nextern struct rps_sock_flow_table __rcu *rps_sock_flow_table;\n\nstatic inline void rps_record_sock_flow(struct rps_sock_flow_table *table,\n\t\t\t\t\tu32 hash)\n{\n\tif (table && hash) {\n\t\tunsigned int index = hash & table->mask;\n\t\tu32 val = hash & ~rps_cpu_mask;\n\n\t\t/* We only give a hint, preemption can change CPU under us */\n\t\tval |= raw_smp_processor_id();\n\n\t\tif (table->ents[index] != val)\n\t\t\ttable->ents[index] = val;\n\t}\n}\n\n#ifdef CONFIG_RFS_ACCEL\nbool rps_may_expire_flow(struct net_device *dev, u16 rxq_index, u32 flow_id,\n\t\t\t u16 filter_id);\n#endif\n#endif /* CONFIG_RPS */\n\n/* This structure contains an instance of an RX queue. */\nstruct netdev_rx_queue {\n#ifdef CONFIG_RPS\n\tstruct rps_map __rcu\t\t*rps_map;\n\tstruct rps_dev_flow_table __rcu\t*rps_flow_table;\n#endif\n\tstruct kobject\t\t\tkobj;\n\tstruct net_device\t\t*dev;\n\tstruct xdp_rxq_info\t\txdp_rxq;\n#ifdef CONFIG_XDP_SOCKETS\n\tstruct xsk_buff_pool            *pool;\n#endif\n} ____cacheline_aligned_in_smp;\n\n/*\n * RX queue sysfs structures and functions.\n */\nstruct rx_queue_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct netdev_rx_queue *queue, char *buf);\n\tssize_t (*store)(struct netdev_rx_queue *queue,\n\t\t\t const char *buf, size_t len);\n};\n\n#ifdef CONFIG_XPS\n/*\n * This structure holds an XPS map which can be of variable length.  The\n * map is an array of queues.\n */\nstruct xps_map {\n\tunsigned int len;\n\tunsigned int alloc_len;\n\tstruct rcu_head rcu;\n\tu16 queues[];\n};\n#define XPS_MAP_SIZE(_num) (sizeof(struct xps_map) + ((_num) * sizeof(u16)))\n#define XPS_MIN_MAP_ALLOC ((L1_CACHE_ALIGN(offsetof(struct xps_map, queues[1])) \\\n       - sizeof(struct xps_map)) / sizeof(u16))\n\n/*\n * This structure holds all XPS maps for device.  Maps are indexed by CPU.\n */\nstruct xps_dev_maps {\n\tstruct rcu_head rcu;\n\tstruct xps_map __rcu *attr_map[]; /* Either CPUs map or RXQs map */\n};\n\n#define XPS_CPU_DEV_MAPS_SIZE(_tcs) (sizeof(struct xps_dev_maps) +\t\\\n\t(nr_cpu_ids * (_tcs) * sizeof(struct xps_map *)))\n\n#define XPS_RXQ_DEV_MAPS_SIZE(_tcs, _rxqs) (sizeof(struct xps_dev_maps) +\\\n\t(_rxqs * (_tcs) * sizeof(struct xps_map *)))\n\n#endif /* CONFIG_XPS */\n\n#define TC_MAX_QUEUE\t16\n#define TC_BITMASK\t15\n/* HW offloaded queuing disciplines txq count and offset maps */\nstruct netdev_tc_txq {\n\tu16 count;\n\tu16 offset;\n};\n\n#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)\n/*\n * This structure is to hold information about the device\n * configured to run FCoE protocol stack.\n */\nstruct netdev_fcoe_hbainfo {\n\tchar\tmanufacturer[64];\n\tchar\tserial_number[64];\n\tchar\thardware_version[64];\n\tchar\tdriver_version[64];\n\tchar\toptionrom_version[64];\n\tchar\tfirmware_version[64];\n\tchar\tmodel[256];\n\tchar\tmodel_description[256];\n};\n#endif\n\n#define MAX_PHYS_ITEM_ID_LEN 32\n\n/* This structure holds a unique identifier to identify some\n * physical item (port for example) used by a netdevice.\n */\nstruct netdev_phys_item_id {\n\tunsigned char id[MAX_PHYS_ITEM_ID_LEN];\n\tunsigned char id_len;\n};\n\nstatic inline bool netdev_phys_item_id_same(struct netdev_phys_item_id *a,\n\t\t\t\t\t    struct netdev_phys_item_id *b)\n{\n\treturn a->id_len == b->id_len &&\n\t       memcmp(a->id, b->id, a->id_len) == 0;\n}\n\ntypedef u16 (*select_queue_fallback_t)(struct net_device *dev,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       struct net_device *sb_dev);\n\nenum tc_setup_type {\n\tTC_SETUP_QDISC_MQPRIO,\n\tTC_SETUP_CLSU32,\n\tTC_SETUP_CLSFLOWER,\n\tTC_SETUP_CLSMATCHALL,\n\tTC_SETUP_CLSBPF,\n\tTC_SETUP_BLOCK,\n\tTC_SETUP_QDISC_CBS,\n\tTC_SETUP_QDISC_RED,\n\tTC_SETUP_QDISC_PRIO,\n\tTC_SETUP_QDISC_MQ,\n\tTC_SETUP_QDISC_ETF,\n\tTC_SETUP_ROOT_QDISC,\n\tTC_SETUP_QDISC_GRED,\n\tTC_SETUP_QDISC_TAPRIO,\n\tTC_SETUP_FT,\n\tTC_SETUP_QDISC_ETS,\n\tTC_SETUP_QDISC_TBF,\n\tTC_SETUP_QDISC_FIFO,\n\tTC_SETUP_QDISC_HTB,\n};\n\n/* These structures hold the attributes of bpf state that are being passed\n * to the netdevice through the bpf op.\n */\nenum bpf_netdev_command {\n\t/* Set or clear a bpf program used in the earliest stages of packet\n\t * rx. The prog will have been loaded as BPF_PROG_TYPE_XDP. The callee\n\t * is responsible for calling bpf_prog_put on any old progs that are\n\t * stored. In case of error, the callee need not release the new prog\n\t * reference, but on success it takes ownership and must bpf_prog_put\n\t * when it is no longer used.\n\t */\n\tXDP_SETUP_PROG,\n\tXDP_SETUP_PROG_HW,\n\t/* BPF program for offload callbacks, invoked at program load time. */\n\tBPF_OFFLOAD_MAP_ALLOC,\n\tBPF_OFFLOAD_MAP_FREE,\n\tXDP_SETUP_XSK_POOL,\n};\n\nstruct bpf_prog_offload_ops;\nstruct netlink_ext_ack;\nstruct xdp_umem;\nstruct xdp_dev_bulk_queue;\nstruct bpf_xdp_link;\n\nenum bpf_xdp_mode {\n\tXDP_MODE_SKB = 0,\n\tXDP_MODE_DRV = 1,\n\tXDP_MODE_HW = 2,\n\t__MAX_XDP_MODE\n};\n\nstruct bpf_xdp_entity {\n\tstruct bpf_prog *prog;\n\tstruct bpf_xdp_link *link;\n};\n\nstruct netdev_bpf {\n\tenum bpf_netdev_command command;\n\tunion {\n\t\t/* XDP_SETUP_PROG */\n\t\tstruct {\n\t\t\tu32 flags;\n\t\t\tstruct bpf_prog *prog;\n\t\t\tstruct netlink_ext_ack *extack;\n\t\t};\n\t\t/* BPF_OFFLOAD_MAP_ALLOC, BPF_OFFLOAD_MAP_FREE */\n\t\tstruct {\n\t\t\tstruct bpf_offloaded_map *offmap;\n\t\t};\n\t\t/* XDP_SETUP_XSK_POOL */\n\t\tstruct {\n\t\t\tstruct xsk_buff_pool *pool;\n\t\t\tu16 queue_id;\n\t\t} xsk;\n\t};\n};\n\n/* Flags for ndo_xsk_wakeup. */\n#define XDP_WAKEUP_RX (1 << 0)\n#define XDP_WAKEUP_TX (1 << 1)\n\n#ifdef CONFIG_XFRM_OFFLOAD\nstruct xfrmdev_ops {\n\tint\t(*xdo_dev_state_add) (struct xfrm_state *x);\n\tvoid\t(*xdo_dev_state_delete) (struct xfrm_state *x);\n\tvoid\t(*xdo_dev_state_free) (struct xfrm_state *x);\n\tbool\t(*xdo_dev_offload_ok) (struct sk_buff *skb,\n\t\t\t\t       struct xfrm_state *x);\n\tvoid\t(*xdo_dev_state_advance_esn) (struct xfrm_state *x);\n};\n#endif\n\nstruct dev_ifalias {\n\tstruct rcu_head rcuhead;\n\tchar ifalias[];\n};\n\nstruct devlink;\nstruct tlsdev_ops;\n\nstruct netdev_name_node {\n\tstruct hlist_node hlist;\n\tstruct list_head list;\n\tstruct net_device *dev;\n\tconst char *name;\n};\n\nint netdev_name_node_alt_create(struct net_device *dev, const char *name);\nint netdev_name_node_alt_destroy(struct net_device *dev, const char *name);\n\nstruct netdev_net_notifier {\n\tstruct list_head list;\n\tstruct notifier_block *nb;\n};\n\n/*\n * This structure defines the management hooks for network devices.\n * The following hooks can be defined; unless noted otherwise, they are\n * optional and can be filled with a null pointer.\n *\n * int (*ndo_init)(struct net_device *dev);\n *     This function is called once when a network device is registered.\n *     The network device can use this for any late stage initialization\n *     or semantic validation. It can fail with an error code which will\n *     be propagated back to register_netdev.\n *\n * void (*ndo_uninit)(struct net_device *dev);\n *     This function is called when device is unregistered or when registration\n *     fails. It is not called if init fails.\n *\n * int (*ndo_open)(struct net_device *dev);\n *     This function is called when a network device transitions to the up\n *     state.\n *\n * int (*ndo_stop)(struct net_device *dev);\n *     This function is called when a network device transitions to the down\n *     state.\n *\n * netdev_tx_t (*ndo_start_xmit)(struct sk_buff *skb,\n *                               struct net_device *dev);\n *\tCalled when a packet needs to be transmitted.\n *\tReturns NETDEV_TX_OK.  Can return NETDEV_TX_BUSY, but you should stop\n *\tthe queue before that can happen; it's for obsolete devices and weird\n *\tcorner cases, but the stack really does a non-trivial amount\n *\tof useless work if you return NETDEV_TX_BUSY.\n *\tRequired; cannot be NULL.\n *\n * netdev_features_t (*ndo_features_check)(struct sk_buff *skb,\n *\t\t\t\t\t   struct net_device *dev\n *\t\t\t\t\t   netdev_features_t features);\n *\tCalled by core transmit path to determine if device is capable of\n *\tperforming offload operations on a given packet. This is to give\n *\tthe device an opportunity to implement any restrictions that cannot\n *\tbe otherwise expressed by feature flags. The check is called with\n *\tthe set of features that the stack has calculated and it returns\n *\tthose the driver believes to be appropriate.\n *\n * u16 (*ndo_select_queue)(struct net_device *dev, struct sk_buff *skb,\n *                         struct net_device *sb_dev);\n *\tCalled to decide which queue to use when device supports multiple\n *\ttransmit queues.\n *\n * void (*ndo_change_rx_flags)(struct net_device *dev, int flags);\n *\tThis function is called to allow device receiver to make\n *\tchanges to configuration when multicast or promiscuous is enabled.\n *\n * void (*ndo_set_rx_mode)(struct net_device *dev);\n *\tThis function is called device changes address list filtering.\n *\tIf driver handles unicast address filtering, it should set\n *\tIFF_UNICAST_FLT in its priv_flags.\n *\n * int (*ndo_set_mac_address)(struct net_device *dev, void *addr);\n *\tThis function  is called when the Media Access Control address\n *\tneeds to be changed. If this interface is not defined, the\n *\tMAC address can not be changed.\n *\n * int (*ndo_validate_addr)(struct net_device *dev);\n *\tTest if Media Access Control address is valid for the device.\n *\n * int (*ndo_do_ioctl)(struct net_device *dev, struct ifreq *ifr, int cmd);\n *\tCalled when a user requests an ioctl which can't be handled by\n *\tthe generic interface code. If not defined ioctls return\n *\tnot supported error code.\n *\n * int (*ndo_set_config)(struct net_device *dev, struct ifmap *map);\n *\tUsed to set network devices bus interface parameters. This interface\n *\tis retained for legacy reasons; new devices should use the bus\n *\tinterface (PCI) for low level management.\n *\n * int (*ndo_change_mtu)(struct net_device *dev, int new_mtu);\n *\tCalled when a user wants to change the Maximum Transfer Unit\n *\tof a device.\n *\n * void (*ndo_tx_timeout)(struct net_device *dev, unsigned int txqueue);\n *\tCallback used when the transmitter has not made any progress\n *\tfor dev->watchdog ticks.\n *\n * void (*ndo_get_stats64)(struct net_device *dev,\n *                         struct rtnl_link_stats64 *storage);\n * struct net_device_stats* (*ndo_get_stats)(struct net_device *dev);\n *\tCalled when a user wants to get the network device usage\n *\tstatistics. Drivers must do one of the following:\n *\t1. Define @ndo_get_stats64 to fill in a zero-initialised\n *\t   rtnl_link_stats64 structure passed by the caller.\n *\t2. Define @ndo_get_stats to update a net_device_stats structure\n *\t   (which should normally be dev->stats) and return a pointer to\n *\t   it. The structure may be changed asynchronously only if each\n *\t   field is written atomically.\n *\t3. Update dev->stats asynchronously and atomically, and define\n *\t   neither operation.\n *\n * bool (*ndo_has_offload_stats)(const struct net_device *dev, int attr_id)\n *\tReturn true if this device supports offload stats of this attr_id.\n *\n * int (*ndo_get_offload_stats)(int attr_id, const struct net_device *dev,\n *\tvoid *attr_data)\n *\tGet statistics for offload operations by attr_id. Write it into the\n *\tattr_data pointer.\n *\n * int (*ndo_vlan_rx_add_vid)(struct net_device *dev, __be16 proto, u16 vid);\n *\tIf device supports VLAN filtering this function is called when a\n *\tVLAN id is registered.\n *\n * int (*ndo_vlan_rx_kill_vid)(struct net_device *dev, __be16 proto, u16 vid);\n *\tIf device supports VLAN filtering this function is called when a\n *\tVLAN id is unregistered.\n *\n * void (*ndo_poll_controller)(struct net_device *dev);\n *\n *\tSR-IOV management functions.\n * int (*ndo_set_vf_mac)(struct net_device *dev, int vf, u8* mac);\n * int (*ndo_set_vf_vlan)(struct net_device *dev, int vf, u16 vlan,\n *\t\t\t  u8 qos, __be16 proto);\n * int (*ndo_set_vf_rate)(struct net_device *dev, int vf, int min_tx_rate,\n *\t\t\t  int max_tx_rate);\n * int (*ndo_set_vf_spoofchk)(struct net_device *dev, int vf, bool setting);\n * int (*ndo_set_vf_trust)(struct net_device *dev, int vf, bool setting);\n * int (*ndo_get_vf_config)(struct net_device *dev,\n *\t\t\t    int vf, struct ifla_vf_info *ivf);\n * int (*ndo_set_vf_link_state)(struct net_device *dev, int vf, int link_state);\n * int (*ndo_set_vf_port)(struct net_device *dev, int vf,\n *\t\t\t  struct nlattr *port[]);\n *\n *      Enable or disable the VF ability to query its RSS Redirection Table and\n *      Hash Key. This is needed since on some devices VF share this information\n *      with PF and querying it may introduce a theoretical security risk.\n * int (*ndo_set_vf_rss_query_en)(struct net_device *dev, int vf, bool setting);\n * int (*ndo_get_vf_port)(struct net_device *dev, int vf, struct sk_buff *skb);\n * int (*ndo_setup_tc)(struct net_device *dev, enum tc_setup_type type,\n *\t\t       void *type_data);\n *\tCalled to setup any 'tc' scheduler, classifier or action on @dev.\n *\tThis is always called from the stack with the rtnl lock held and netif\n *\ttx queues stopped. This allows the netdevice to perform queue\n *\tmanagement safely.\n *\n *\tFiber Channel over Ethernet (FCoE) offload functions.\n * int (*ndo_fcoe_enable)(struct net_device *dev);\n *\tCalled when the FCoE protocol stack wants to start using LLD for FCoE\n *\tso the underlying device can perform whatever needed configuration or\n *\tinitialization to support acceleration of FCoE traffic.\n *\n * int (*ndo_fcoe_disable)(struct net_device *dev);\n *\tCalled when the FCoE protocol stack wants to stop using LLD for FCoE\n *\tso the underlying device can perform whatever needed clean-ups to\n *\tstop supporting acceleration of FCoE traffic.\n *\n * int (*ndo_fcoe_ddp_setup)(struct net_device *dev, u16 xid,\n *\t\t\t     struct scatterlist *sgl, unsigned int sgc);\n *\tCalled when the FCoE Initiator wants to initialize an I/O that\n *\tis a possible candidate for Direct Data Placement (DDP). The LLD can\n *\tperform necessary setup and returns 1 to indicate the device is set up\n *\tsuccessfully to perform DDP on this I/O, otherwise this returns 0.\n *\n * int (*ndo_fcoe_ddp_done)(struct net_device *dev,  u16 xid);\n *\tCalled when the FCoE Initiator/Target is done with the DDPed I/O as\n *\tindicated by the FC exchange id 'xid', so the underlying device can\n *\tclean up and reuse resources for later DDP requests.\n *\n * int (*ndo_fcoe_ddp_target)(struct net_device *dev, u16 xid,\n *\t\t\t      struct scatterlist *sgl, unsigned int sgc);\n *\tCalled when the FCoE Target wants to initialize an I/O that\n *\tis a possible candidate for Direct Data Placement (DDP). The LLD can\n *\tperform necessary setup and returns 1 to indicate the device is set up\n *\tsuccessfully to perform DDP on this I/O, otherwise this returns 0.\n *\n * int (*ndo_fcoe_get_hbainfo)(struct net_device *dev,\n *\t\t\t       struct netdev_fcoe_hbainfo *hbainfo);\n *\tCalled when the FCoE Protocol stack wants information on the underlying\n *\tdevice. This information is utilized by the FCoE protocol stack to\n *\tregister attributes with Fiber Channel management service as per the\n *\tFC-GS Fabric Device Management Information(FDMI) specification.\n *\n * int (*ndo_fcoe_get_wwn)(struct net_device *dev, u64 *wwn, int type);\n *\tCalled when the underlying device wants to override default World Wide\n *\tName (WWN) generation mechanism in FCoE protocol stack to pass its own\n *\tWorld Wide Port Name (WWPN) or World Wide Node Name (WWNN) to the FCoE\n *\tprotocol stack to use.\n *\n *\tRFS acceleration.\n * int (*ndo_rx_flow_steer)(struct net_device *dev, const struct sk_buff *skb,\n *\t\t\t    u16 rxq_index, u32 flow_id);\n *\tSet hardware filter for RFS.  rxq_index is the target queue index;\n *\tflow_id is a flow ID to be passed to rps_may_expire_flow() later.\n *\tReturn the filter ID on success, or a negative error code.\n *\n *\tSlave management functions (for bridge, bonding, etc).\n * int (*ndo_add_slave)(struct net_device *dev, struct net_device *slave_dev);\n *\tCalled to make another netdev an underling.\n *\n * int (*ndo_del_slave)(struct net_device *dev, struct net_device *slave_dev);\n *\tCalled to release previously enslaved netdev.\n *\n * struct net_device *(*ndo_get_xmit_slave)(struct net_device *dev,\n *\t\t\t\t\t    struct sk_buff *skb,\n *\t\t\t\t\t    bool all_slaves);\n *\tGet the xmit slave of master device. If all_slaves is true, function\n *\tassume all the slaves can transmit.\n *\n *      Feature/offload setting functions.\n * netdev_features_t (*ndo_fix_features)(struct net_device *dev,\n *\t\tnetdev_features_t features);\n *\tAdjusts the requested feature flags according to device-specific\n *\tconstraints, and returns the resulting flags. Must not modify\n *\tthe device state.\n *\n * int (*ndo_set_features)(struct net_device *dev, netdev_features_t features);\n *\tCalled to update device configuration to new features. Passed\n *\tfeature set might be less than what was returned by ndo_fix_features()).\n *\tMust return >0 or -errno if it changed dev->features itself.\n *\n * int (*ndo_fdb_add)(struct ndmsg *ndm, struct nlattr *tb[],\n *\t\t      struct net_device *dev,\n *\t\t      const unsigned char *addr, u16 vid, u16 flags,\n *\t\t      struct netlink_ext_ack *extack);\n *\tAdds an FDB entry to dev for addr.\n * int (*ndo_fdb_del)(struct ndmsg *ndm, struct nlattr *tb[],\n *\t\t      struct net_device *dev,\n *\t\t      const unsigned char *addr, u16 vid)\n *\tDeletes the FDB entry from dev coresponding to addr.\n * int (*ndo_fdb_dump)(struct sk_buff *skb, struct netlink_callback *cb,\n *\t\t       struct net_device *dev, struct net_device *filter_dev,\n *\t\t       int *idx)\n *\tUsed to add FDB entries to dump requests. Implementers should add\n *\tentries to skb and update idx with the number of entries.\n *\n * int (*ndo_bridge_setlink)(struct net_device *dev, struct nlmsghdr *nlh,\n *\t\t\t     u16 flags, struct netlink_ext_ack *extack)\n * int (*ndo_bridge_getlink)(struct sk_buff *skb, u32 pid, u32 seq,\n *\t\t\t     struct net_device *dev, u32 filter_mask,\n *\t\t\t     int nlflags)\n * int (*ndo_bridge_dellink)(struct net_device *dev, struct nlmsghdr *nlh,\n *\t\t\t     u16 flags);\n *\n * int (*ndo_change_carrier)(struct net_device *dev, bool new_carrier);\n *\tCalled to change device carrier. Soft-devices (like dummy, team, etc)\n *\twhich do not represent real hardware may define this to allow their\n *\tuserspace components to manage their virtual carrier state. Devices\n *\tthat determine carrier state from physical hardware properties (eg\n *\tnetwork cables) or protocol-dependent mechanisms (eg\n *\tUSB_CDC_NOTIFY_NETWORK_CONNECTION) should NOT implement this function.\n *\n * int (*ndo_get_phys_port_id)(struct net_device *dev,\n *\t\t\t       struct netdev_phys_item_id *ppid);\n *\tCalled to get ID of physical port of this device. If driver does\n *\tnot implement this, it is assumed that the hw is not able to have\n *\tmultiple net devices on single physical port.\n *\n * int (*ndo_get_port_parent_id)(struct net_device *dev,\n *\t\t\t\t struct netdev_phys_item_id *ppid)\n *\tCalled to get the parent ID of the physical port of this device.\n *\n * void* (*ndo_dfwd_add_station)(struct net_device *pdev,\n *\t\t\t\t struct net_device *dev)\n *\tCalled by upper layer devices to accelerate switching or other\n *\tstation functionality into hardware. 'pdev is the lowerdev\n *\tto use for the offload and 'dev' is the net device that will\n *\tback the offload. Returns a pointer to the private structure\n *\tthe upper layer will maintain.\n * void (*ndo_dfwd_del_station)(struct net_device *pdev, void *priv)\n *\tCalled by upper layer device to delete the station created\n *\tby 'ndo_dfwd_add_station'. 'pdev' is the net device backing\n *\tthe station and priv is the structure returned by the add\n *\toperation.\n * int (*ndo_set_tx_maxrate)(struct net_device *dev,\n *\t\t\t     int queue_index, u32 maxrate);\n *\tCalled when a user wants to set a max-rate limitation of specific\n *\tTX queue.\n * int (*ndo_get_iflink)(const struct net_device *dev);\n *\tCalled to get the iflink value of this device.\n * void (*ndo_change_proto_down)(struct net_device *dev,\n *\t\t\t\t bool proto_down);\n *\tThis function is used to pass protocol port error state information\n *\tto the switch driver. The switch driver can react to the proto_down\n *      by doing a phys down on the associated switch port.\n * int (*ndo_fill_metadata_dst)(struct net_device *dev, struct sk_buff *skb);\n *\tThis function is used to get egress tunnel information for given skb.\n *\tThis is useful for retrieving outer tunnel header parameters while\n *\tsampling packet.\n * void (*ndo_set_rx_headroom)(struct net_device *dev, int needed_headroom);\n *\tThis function is used to specify the headroom that the skb must\n *\tconsider when allocation skb during packet reception. Setting\n *\tappropriate rx headroom value allows avoiding skb head copy on\n *\tforward. Setting a negative value resets the rx headroom to the\n *\tdefault value.\n * int (*ndo_bpf)(struct net_device *dev, struct netdev_bpf *bpf);\n *\tThis function is used to set or query state related to XDP on the\n *\tnetdevice and manage BPF offload. See definition of\n *\tenum bpf_netdev_command for details.\n * int (*ndo_xdp_xmit)(struct net_device *dev, int n, struct xdp_frame **xdp,\n *\t\t\tu32 flags);\n *\tThis function is used to submit @n XDP packets for transmit on a\n *\tnetdevice. Returns number of frames successfully transmitted, frames\n *\tthat got dropped are freed/returned via xdp_return_frame().\n *\tReturns negative number, means general error invoking ndo, meaning\n *\tno frames were xmit'ed and core-caller will free all frames.\n * int (*ndo_xsk_wakeup)(struct net_device *dev, u32 queue_id, u32 flags);\n *      This function is used to wake up the softirq, ksoftirqd or kthread\n *\tresponsible for sending and/or receiving packets on a specific\n *\tqueue id bound to an AF_XDP socket. The flags field specifies if\n *\tonly RX, only Tx, or both should be woken up using the flags\n *\tXDP_WAKEUP_RX and XDP_WAKEUP_TX.\n * struct devlink_port *(*ndo_get_devlink_port)(struct net_device *dev);\n *\tGet devlink port instance associated with a given netdev.\n *\tCalled with a reference on the netdevice and devlink locks only,\n *\trtnl_lock is not held.\n * int (*ndo_tunnel_ctl)(struct net_device *dev, struct ip_tunnel_parm *p,\n *\t\t\t int cmd);\n *\tAdd, change, delete or get information on an IPv4 tunnel.\n * struct net_device *(*ndo_get_peer_dev)(struct net_device *dev);\n *\tIf a device is paired with a peer device, return the peer instance.\n *\tThe caller must be under RCU read context.\n */\nstruct net_device_ops {\n\tint\t\t\t(*ndo_init)(struct net_device *dev);\n\tvoid\t\t\t(*ndo_uninit)(struct net_device *dev);\n\tint\t\t\t(*ndo_open)(struct net_device *dev);\n\tint\t\t\t(*ndo_stop)(struct net_device *dev);\n\tnetdev_tx_t\t\t(*ndo_start_xmit)(struct sk_buff *skb,\n\t\t\t\t\t\t  struct net_device *dev);\n\tnetdev_features_t\t(*ndo_features_check)(struct sk_buff *skb,\n\t\t\t\t\t\t      struct net_device *dev,\n\t\t\t\t\t\t      netdev_features_t features);\n\tu16\t\t\t(*ndo_select_queue)(struct net_device *dev,\n\t\t\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t\t\t    struct net_device *sb_dev);\n\tvoid\t\t\t(*ndo_change_rx_flags)(struct net_device *dev,\n\t\t\t\t\t\t       int flags);\n\tvoid\t\t\t(*ndo_set_rx_mode)(struct net_device *dev);\n\tint\t\t\t(*ndo_set_mac_address)(struct net_device *dev,\n\t\t\t\t\t\t       void *addr);\n\tint\t\t\t(*ndo_validate_addr)(struct net_device *dev);\n\tint\t\t\t(*ndo_do_ioctl)(struct net_device *dev,\n\t\t\t\t\t        struct ifreq *ifr, int cmd);\n\tint\t\t\t(*ndo_set_config)(struct net_device *dev,\n\t\t\t\t\t          struct ifmap *map);\n\tint\t\t\t(*ndo_change_mtu)(struct net_device *dev,\n\t\t\t\t\t\t  int new_mtu);\n\tint\t\t\t(*ndo_neigh_setup)(struct net_device *dev,\n\t\t\t\t\t\t   struct neigh_parms *);\n\tvoid\t\t\t(*ndo_tx_timeout) (struct net_device *dev,\n\t\t\t\t\t\t   unsigned int txqueue);\n\n\tvoid\t\t\t(*ndo_get_stats64)(struct net_device *dev,\n\t\t\t\t\t\t   struct rtnl_link_stats64 *storage);\n\tbool\t\t\t(*ndo_has_offload_stats)(const struct net_device *dev, int attr_id);\n\tint\t\t\t(*ndo_get_offload_stats)(int attr_id,\n\t\t\t\t\t\t\t const struct net_device *dev,\n\t\t\t\t\t\t\t void *attr_data);\n\tstruct net_device_stats* (*ndo_get_stats)(struct net_device *dev);\n\n\tint\t\t\t(*ndo_vlan_rx_add_vid)(struct net_device *dev,\n\t\t\t\t\t\t       __be16 proto, u16 vid);\n\tint\t\t\t(*ndo_vlan_rx_kill_vid)(struct net_device *dev,\n\t\t\t\t\t\t        __be16 proto, u16 vid);\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\tvoid                    (*ndo_poll_controller)(struct net_device *dev);\n\tint\t\t\t(*ndo_netpoll_setup)(struct net_device *dev,\n\t\t\t\t\t\t     struct netpoll_info *info);\n\tvoid\t\t\t(*ndo_netpoll_cleanup)(struct net_device *dev);\n#endif\n\tint\t\t\t(*ndo_set_vf_mac)(struct net_device *dev,\n\t\t\t\t\t\t  int queue, u8 *mac);\n\tint\t\t\t(*ndo_set_vf_vlan)(struct net_device *dev,\n\t\t\t\t\t\t   int queue, u16 vlan,\n\t\t\t\t\t\t   u8 qos, __be16 proto);\n\tint\t\t\t(*ndo_set_vf_rate)(struct net_device *dev,\n\t\t\t\t\t\t   int vf, int min_tx_rate,\n\t\t\t\t\t\t   int max_tx_rate);\n\tint\t\t\t(*ndo_set_vf_spoofchk)(struct net_device *dev,\n\t\t\t\t\t\t       int vf, bool setting);\n\tint\t\t\t(*ndo_set_vf_trust)(struct net_device *dev,\n\t\t\t\t\t\t    int vf, bool setting);\n\tint\t\t\t(*ndo_get_vf_config)(struct net_device *dev,\n\t\t\t\t\t\t     int vf,\n\t\t\t\t\t\t     struct ifla_vf_info *ivf);\n\tint\t\t\t(*ndo_set_vf_link_state)(struct net_device *dev,\n\t\t\t\t\t\t\t int vf, int link_state);\n\tint\t\t\t(*ndo_get_vf_stats)(struct net_device *dev,\n\t\t\t\t\t\t    int vf,\n\t\t\t\t\t\t    struct ifla_vf_stats\n\t\t\t\t\t\t    *vf_stats);\n\tint\t\t\t(*ndo_set_vf_port)(struct net_device *dev,\n\t\t\t\t\t\t   int vf,\n\t\t\t\t\t\t   struct nlattr *port[]);\n\tint\t\t\t(*ndo_get_vf_port)(struct net_device *dev,\n\t\t\t\t\t\t   int vf, struct sk_buff *skb);\n\tint\t\t\t(*ndo_get_vf_guid)(struct net_device *dev,\n\t\t\t\t\t\t   int vf,\n\t\t\t\t\t\t   struct ifla_vf_guid *node_guid,\n\t\t\t\t\t\t   struct ifla_vf_guid *port_guid);\n\tint\t\t\t(*ndo_set_vf_guid)(struct net_device *dev,\n\t\t\t\t\t\t   int vf, u64 guid,\n\t\t\t\t\t\t   int guid_type);\n\tint\t\t\t(*ndo_set_vf_rss_query_en)(\n\t\t\t\t\t\t   struct net_device *dev,\n\t\t\t\t\t\t   int vf, bool setting);\n\tint\t\t\t(*ndo_setup_tc)(struct net_device *dev,\n\t\t\t\t\t\tenum tc_setup_type type,\n\t\t\t\t\t\tvoid *type_data);\n#if IS_ENABLED(CONFIG_FCOE)\n\tint\t\t\t(*ndo_fcoe_enable)(struct net_device *dev);\n\tint\t\t\t(*ndo_fcoe_disable)(struct net_device *dev);\n\tint\t\t\t(*ndo_fcoe_ddp_setup)(struct net_device *dev,\n\t\t\t\t\t\t      u16 xid,\n\t\t\t\t\t\t      struct scatterlist *sgl,\n\t\t\t\t\t\t      unsigned int sgc);\n\tint\t\t\t(*ndo_fcoe_ddp_done)(struct net_device *dev,\n\t\t\t\t\t\t     u16 xid);\n\tint\t\t\t(*ndo_fcoe_ddp_target)(struct net_device *dev,\n\t\t\t\t\t\t       u16 xid,\n\t\t\t\t\t\t       struct scatterlist *sgl,\n\t\t\t\t\t\t       unsigned int sgc);\n\tint\t\t\t(*ndo_fcoe_get_hbainfo)(struct net_device *dev,\n\t\t\t\t\t\t\tstruct netdev_fcoe_hbainfo *hbainfo);\n#endif\n\n#if IS_ENABLED(CONFIG_LIBFCOE)\n#define NETDEV_FCOE_WWNN 0\n#define NETDEV_FCOE_WWPN 1\n\tint\t\t\t(*ndo_fcoe_get_wwn)(struct net_device *dev,\n\t\t\t\t\t\t    u64 *wwn, int type);\n#endif\n\n#ifdef CONFIG_RFS_ACCEL\n\tint\t\t\t(*ndo_rx_flow_steer)(struct net_device *dev,\n\t\t\t\t\t\t     const struct sk_buff *skb,\n\t\t\t\t\t\t     u16 rxq_index,\n\t\t\t\t\t\t     u32 flow_id);\n#endif\n\tint\t\t\t(*ndo_add_slave)(struct net_device *dev,\n\t\t\t\t\t\t struct net_device *slave_dev,\n\t\t\t\t\t\t struct netlink_ext_ack *extack);\n\tint\t\t\t(*ndo_del_slave)(struct net_device *dev,\n\t\t\t\t\t\t struct net_device *slave_dev);\n\tstruct net_device*\t(*ndo_get_xmit_slave)(struct net_device *dev,\n\t\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t\t      bool all_slaves);\n\tstruct net_device*\t(*ndo_sk_get_lower_dev)(struct net_device *dev,\n\t\t\t\t\t\t\tstruct sock *sk);\n\tnetdev_features_t\t(*ndo_fix_features)(struct net_device *dev,\n\t\t\t\t\t\t    netdev_features_t features);\n\tint\t\t\t(*ndo_set_features)(struct net_device *dev,\n\t\t\t\t\t\t    netdev_features_t features);\n\tint\t\t\t(*ndo_neigh_construct)(struct net_device *dev,\n\t\t\t\t\t\t       struct neighbour *n);\n\tvoid\t\t\t(*ndo_neigh_destroy)(struct net_device *dev,\n\t\t\t\t\t\t     struct neighbour *n);\n\n\tint\t\t\t(*ndo_fdb_add)(struct ndmsg *ndm,\n\t\t\t\t\t       struct nlattr *tb[],\n\t\t\t\t\t       struct net_device *dev,\n\t\t\t\t\t       const unsigned char *addr,\n\t\t\t\t\t       u16 vid,\n\t\t\t\t\t       u16 flags,\n\t\t\t\t\t       struct netlink_ext_ack *extack);\n\tint\t\t\t(*ndo_fdb_del)(struct ndmsg *ndm,\n\t\t\t\t\t       struct nlattr *tb[],\n\t\t\t\t\t       struct net_device *dev,\n\t\t\t\t\t       const unsigned char *addr,\n\t\t\t\t\t       u16 vid);\n\tint\t\t\t(*ndo_fdb_dump)(struct sk_buff *skb,\n\t\t\t\t\t\tstruct netlink_callback *cb,\n\t\t\t\t\t\tstruct net_device *dev,\n\t\t\t\t\t\tstruct net_device *filter_dev,\n\t\t\t\t\t\tint *idx);\n\tint\t\t\t(*ndo_fdb_get)(struct sk_buff *skb,\n\t\t\t\t\t       struct nlattr *tb[],\n\t\t\t\t\t       struct net_device *dev,\n\t\t\t\t\t       const unsigned char *addr,\n\t\t\t\t\t       u16 vid, u32 portid, u32 seq,\n\t\t\t\t\t       struct netlink_ext_ack *extack);\n\tint\t\t\t(*ndo_bridge_setlink)(struct net_device *dev,\n\t\t\t\t\t\t      struct nlmsghdr *nlh,\n\t\t\t\t\t\t      u16 flags,\n\t\t\t\t\t\t      struct netlink_ext_ack *extack);\n\tint\t\t\t(*ndo_bridge_getlink)(struct sk_buff *skb,\n\t\t\t\t\t\t      u32 pid, u32 seq,\n\t\t\t\t\t\t      struct net_device *dev,\n\t\t\t\t\t\t      u32 filter_mask,\n\t\t\t\t\t\t      int nlflags);\n\tint\t\t\t(*ndo_bridge_dellink)(struct net_device *dev,\n\t\t\t\t\t\t      struct nlmsghdr *nlh,\n\t\t\t\t\t\t      u16 flags);\n\tint\t\t\t(*ndo_change_carrier)(struct net_device *dev,\n\t\t\t\t\t\t      bool new_carrier);\n\tint\t\t\t(*ndo_get_phys_port_id)(struct net_device *dev,\n\t\t\t\t\t\t\tstruct netdev_phys_item_id *ppid);\n\tint\t\t\t(*ndo_get_port_parent_id)(struct net_device *dev,\n\t\t\t\t\t\t\t  struct netdev_phys_item_id *ppid);\n\tint\t\t\t(*ndo_get_phys_port_name)(struct net_device *dev,\n\t\t\t\t\t\t\t  char *name, size_t len);\n\tvoid*\t\t\t(*ndo_dfwd_add_station)(struct net_device *pdev,\n\t\t\t\t\t\t\tstruct net_device *dev);\n\tvoid\t\t\t(*ndo_dfwd_del_station)(struct net_device *pdev,\n\t\t\t\t\t\t\tvoid *priv);\n\n\tint\t\t\t(*ndo_set_tx_maxrate)(struct net_device *dev,\n\t\t\t\t\t\t      int queue_index,\n\t\t\t\t\t\t      u32 maxrate);\n\tint\t\t\t(*ndo_get_iflink)(const struct net_device *dev);\n\tint\t\t\t(*ndo_change_proto_down)(struct net_device *dev,\n\t\t\t\t\t\t\t bool proto_down);\n\tint\t\t\t(*ndo_fill_metadata_dst)(struct net_device *dev,\n\t\t\t\t\t\t       struct sk_buff *skb);\n\tvoid\t\t\t(*ndo_set_rx_headroom)(struct net_device *dev,\n\t\t\t\t\t\t       int needed_headroom);\n\tint\t\t\t(*ndo_bpf)(struct net_device *dev,\n\t\t\t\t\t   struct netdev_bpf *bpf);\n\tint\t\t\t(*ndo_xdp_xmit)(struct net_device *dev, int n,\n\t\t\t\t\t\tstruct xdp_frame **xdp,\n\t\t\t\t\t\tu32 flags);\n\tint\t\t\t(*ndo_xsk_wakeup)(struct net_device *dev,\n\t\t\t\t\t\t  u32 queue_id, u32 flags);\n\tstruct devlink_port *\t(*ndo_get_devlink_port)(struct net_device *dev);\n\tint\t\t\t(*ndo_tunnel_ctl)(struct net_device *dev,\n\t\t\t\t\t\t  struct ip_tunnel_parm *p, int cmd);\n\tstruct net_device *\t(*ndo_get_peer_dev)(struct net_device *dev);\n};\n\n/**\n * enum netdev_priv_flags - &struct net_device priv_flags\n *\n * These are the &struct net_device, they are only set internally\n * by drivers and used in the kernel. These flags are invisible to\n * userspace; this means that the order of these flags can change\n * during any kernel release.\n *\n * You should have a pretty good reason to be extending these flags.\n *\n * @IFF_802_1Q_VLAN: 802.1Q VLAN device\n * @IFF_EBRIDGE: Ethernet bridging device\n * @IFF_BONDING: bonding master or slave\n * @IFF_ISATAP: ISATAP interface (RFC4214)\n * @IFF_WAN_HDLC: WAN HDLC device\n * @IFF_XMIT_DST_RELEASE: dev_hard_start_xmit() is allowed to\n *\trelease skb->dst\n * @IFF_DONT_BRIDGE: disallow bridging this ether dev\n * @IFF_DISABLE_NETPOLL: disable netpoll at run-time\n * @IFF_MACVLAN_PORT: device used as macvlan port\n * @IFF_BRIDGE_PORT: device used as bridge port\n * @IFF_OVS_DATAPATH: device used as Open vSwitch datapath port\n * @IFF_TX_SKB_SHARING: The interface supports sharing skbs on transmit\n * @IFF_UNICAST_FLT: Supports unicast filtering\n * @IFF_TEAM_PORT: device used as team port\n * @IFF_SUPP_NOFCS: device supports sending custom FCS\n * @IFF_LIVE_ADDR_CHANGE: device supports hardware address\n *\tchange when it's running\n * @IFF_MACVLAN: Macvlan device\n * @IFF_XMIT_DST_RELEASE_PERM: IFF_XMIT_DST_RELEASE not taking into account\n *\tunderlying stacked devices\n * @IFF_L3MDEV_MASTER: device is an L3 master device\n * @IFF_NO_QUEUE: device can run without qdisc attached\n * @IFF_OPENVSWITCH: device is a Open vSwitch master\n * @IFF_L3MDEV_SLAVE: device is enslaved to an L3 master device\n * @IFF_TEAM: device is a team device\n * @IFF_RXFH_CONFIGURED: device has had Rx Flow indirection table configured\n * @IFF_PHONY_HEADROOM: the headroom value is controlled by an external\n *\tentity (i.e. the master device for bridged veth)\n * @IFF_MACSEC: device is a MACsec device\n * @IFF_NO_RX_HANDLER: device doesn't support the rx_handler hook\n * @IFF_FAILOVER: device is a failover master device\n * @IFF_FAILOVER_SLAVE: device is lower dev of a failover master device\n * @IFF_L3MDEV_RX_HANDLER: only invoke the rx handler of L3 master device\n * @IFF_LIVE_RENAME_OK: rename is allowed while device is up and running\n */\nenum netdev_priv_flags {\n\tIFF_802_1Q_VLAN\t\t\t= 1<<0,\n\tIFF_EBRIDGE\t\t\t= 1<<1,\n\tIFF_BONDING\t\t\t= 1<<2,\n\tIFF_ISATAP\t\t\t= 1<<3,\n\tIFF_WAN_HDLC\t\t\t= 1<<4,\n\tIFF_XMIT_DST_RELEASE\t\t= 1<<5,\n\tIFF_DONT_BRIDGE\t\t\t= 1<<6,\n\tIFF_DISABLE_NETPOLL\t\t= 1<<7,\n\tIFF_MACVLAN_PORT\t\t= 1<<8,\n\tIFF_BRIDGE_PORT\t\t\t= 1<<9,\n\tIFF_OVS_DATAPATH\t\t= 1<<10,\n\tIFF_TX_SKB_SHARING\t\t= 1<<11,\n\tIFF_UNICAST_FLT\t\t\t= 1<<12,\n\tIFF_TEAM_PORT\t\t\t= 1<<13,\n\tIFF_SUPP_NOFCS\t\t\t= 1<<14,\n\tIFF_LIVE_ADDR_CHANGE\t\t= 1<<15,\n\tIFF_MACVLAN\t\t\t= 1<<16,\n\tIFF_XMIT_DST_RELEASE_PERM\t= 1<<17,\n\tIFF_L3MDEV_MASTER\t\t= 1<<18,\n\tIFF_NO_QUEUE\t\t\t= 1<<19,\n\tIFF_OPENVSWITCH\t\t\t= 1<<20,\n\tIFF_L3MDEV_SLAVE\t\t= 1<<21,\n\tIFF_TEAM\t\t\t= 1<<22,\n\tIFF_RXFH_CONFIGURED\t\t= 1<<23,\n\tIFF_PHONY_HEADROOM\t\t= 1<<24,\n\tIFF_MACSEC\t\t\t= 1<<25,\n\tIFF_NO_RX_HANDLER\t\t= 1<<26,\n\tIFF_FAILOVER\t\t\t= 1<<27,\n\tIFF_FAILOVER_SLAVE\t\t= 1<<28,\n\tIFF_L3MDEV_RX_HANDLER\t\t= 1<<29,\n\tIFF_LIVE_RENAME_OK\t\t= 1<<30,\n};\n\n#define IFF_802_1Q_VLAN\t\t\tIFF_802_1Q_VLAN\n#define IFF_EBRIDGE\t\t\tIFF_EBRIDGE\n#define IFF_BONDING\t\t\tIFF_BONDING\n#define IFF_ISATAP\t\t\tIFF_ISATAP\n#define IFF_WAN_HDLC\t\t\tIFF_WAN_HDLC\n#define IFF_XMIT_DST_RELEASE\t\tIFF_XMIT_DST_RELEASE\n#define IFF_DONT_BRIDGE\t\t\tIFF_DONT_BRIDGE\n#define IFF_DISABLE_NETPOLL\t\tIFF_DISABLE_NETPOLL\n#define IFF_MACVLAN_PORT\t\tIFF_MACVLAN_PORT\n#define IFF_BRIDGE_PORT\t\t\tIFF_BRIDGE_PORT\n#define IFF_OVS_DATAPATH\t\tIFF_OVS_DATAPATH\n#define IFF_TX_SKB_SHARING\t\tIFF_TX_SKB_SHARING\n#define IFF_UNICAST_FLT\t\t\tIFF_UNICAST_FLT\n#define IFF_TEAM_PORT\t\t\tIFF_TEAM_PORT\n#define IFF_SUPP_NOFCS\t\t\tIFF_SUPP_NOFCS\n#define IFF_LIVE_ADDR_CHANGE\t\tIFF_LIVE_ADDR_CHANGE\n#define IFF_MACVLAN\t\t\tIFF_MACVLAN\n#define IFF_XMIT_DST_RELEASE_PERM\tIFF_XMIT_DST_RELEASE_PERM\n#define IFF_L3MDEV_MASTER\t\tIFF_L3MDEV_MASTER\n#define IFF_NO_QUEUE\t\t\tIFF_NO_QUEUE\n#define IFF_OPENVSWITCH\t\t\tIFF_OPENVSWITCH\n#define IFF_L3MDEV_SLAVE\t\tIFF_L3MDEV_SLAVE\n#define IFF_TEAM\t\t\tIFF_TEAM\n#define IFF_RXFH_CONFIGURED\t\tIFF_RXFH_CONFIGURED\n#define IFF_MACSEC\t\t\tIFF_MACSEC\n#define IFF_NO_RX_HANDLER\t\tIFF_NO_RX_HANDLER\n#define IFF_FAILOVER\t\t\tIFF_FAILOVER\n#define IFF_FAILOVER_SLAVE\t\tIFF_FAILOVER_SLAVE\n#define IFF_L3MDEV_RX_HANDLER\t\tIFF_L3MDEV_RX_HANDLER\n#define IFF_LIVE_RENAME_OK\t\tIFF_LIVE_RENAME_OK\n\n/* Specifies the type of the struct net_device::ml_priv pointer */\nenum netdev_ml_priv_type {\n\tML_PRIV_NONE,\n\tML_PRIV_CAN,\n};\n\n/**\n *\tstruct net_device - The DEVICE structure.\n *\n *\tActually, this whole structure is a big mistake.  It mixes I/O\n *\tdata with strictly \"high-level\" data, and it has to know about\n *\talmost every data structure used in the INET module.\n *\n *\t@name:\tThis is the first field of the \"visible\" part of this structure\n *\t\t(i.e. as seen by users in the \"Space.c\" file).  It is the name\n *\t\tof the interface.\n *\n *\t@name_node:\tName hashlist node\n *\t@ifalias:\tSNMP alias\n *\t@mem_end:\tShared memory end\n *\t@mem_start:\tShared memory start\n *\t@base_addr:\tDevice I/O address\n *\t@irq:\t\tDevice IRQ number\n *\n *\t@state:\t\tGeneric network queuing layer state, see netdev_state_t\n *\t@dev_list:\tThe global list of network devices\n *\t@napi_list:\tList entry used for polling NAPI devices\n *\t@unreg_list:\tList entry  when we are unregistering the\n *\t\t\tdevice; see the function unregister_netdev\n *\t@close_list:\tList entry used when we are closing the device\n *\t@ptype_all:     Device-specific packet handlers for all protocols\n *\t@ptype_specific: Device-specific, protocol-specific packet handlers\n *\n *\t@adj_list:\tDirectly linked devices, like slaves for bonding\n *\t@features:\tCurrently active device features\n *\t@hw_features:\tUser-changeable features\n *\n *\t@wanted_features:\tUser-requested features\n *\t@vlan_features:\t\tMask of features inheritable by VLAN devices\n *\n *\t@hw_enc_features:\tMask of features inherited by encapsulating devices\n *\t\t\t\tThis field indicates what encapsulation\n *\t\t\t\toffloads the hardware is capable of doing,\n *\t\t\t\tand drivers will need to set them appropriately.\n *\n *\t@mpls_features:\tMask of features inheritable by MPLS\n *\t@gso_partial_features: value(s) from NETIF_F_GSO\\*\n *\n *\t@ifindex:\tinterface index\n *\t@group:\t\tThe group the device belongs to\n *\n *\t@stats:\t\tStatistics struct, which was left as a legacy, use\n *\t\t\trtnl_link_stats64 instead\n *\n *\t@rx_dropped:\tDropped packets by core network,\n *\t\t\tdo not use this in drivers\n *\t@tx_dropped:\tDropped packets by core network,\n *\t\t\tdo not use this in drivers\n *\t@rx_nohandler:\tnohandler dropped packets by core network on\n *\t\t\tinactive devices, do not use this in drivers\n *\t@carrier_up_count:\tNumber of times the carrier has been up\n *\t@carrier_down_count:\tNumber of times the carrier has been down\n *\n *\t@wireless_handlers:\tList of functions to handle Wireless Extensions,\n *\t\t\t\tinstead of ioctl,\n *\t\t\t\tsee <net/iw_handler.h> for details.\n *\t@wireless_data:\tInstance data managed by the core of wireless extensions\n *\n *\t@netdev_ops:\tIncludes several pointers to callbacks,\n *\t\t\tif one wants to override the ndo_*() functions\n *\t@ethtool_ops:\tManagement operations\n *\t@l3mdev_ops:\tLayer 3 master device operations\n *\t@ndisc_ops:\tIncludes callbacks for different IPv6 neighbour\n *\t\t\tdiscovery handling. Necessary for e.g. 6LoWPAN.\n *\t@xfrmdev_ops:\tTransformation offload operations\n *\t@tlsdev_ops:\tTransport Layer Security offload operations\n *\t@header_ops:\tIncludes callbacks for creating,parsing,caching,etc\n *\t\t\tof Layer 2 headers.\n *\n *\t@flags:\t\tInterface flags (a la BSD)\n *\t@priv_flags:\tLike 'flags' but invisible to userspace,\n *\t\t\tsee if.h for the definitions\n *\t@gflags:\tGlobal flags ( kept as legacy )\n *\t@padded:\tHow much padding added by alloc_netdev()\n *\t@operstate:\tRFC2863 operstate\n *\t@link_mode:\tMapping policy to operstate\n *\t@if_port:\tSelectable AUI, TP, ...\n *\t@dma:\t\tDMA channel\n *\t@mtu:\t\tInterface MTU value\n *\t@min_mtu:\tInterface Minimum MTU value\n *\t@max_mtu:\tInterface Maximum MTU value\n *\t@type:\t\tInterface hardware type\n *\t@hard_header_len: Maximum hardware header length.\n *\t@min_header_len:  Minimum hardware header length\n *\n *\t@needed_headroom: Extra headroom the hardware may need, but not in all\n *\t\t\t  cases can this be guaranteed\n *\t@needed_tailroom: Extra tailroom the hardware may need, but not in all\n *\t\t\t  cases can this be guaranteed. Some cases also use\n *\t\t\t  LL_MAX_HEADER instead to allocate the skb\n *\n *\tinterface address info:\n *\n * \t@perm_addr:\t\tPermanent hw address\n * \t@addr_assign_type:\tHw address assignment type\n * \t@addr_len:\t\tHardware address length\n *\t@upper_level:\t\tMaximum depth level of upper devices.\n *\t@lower_level:\t\tMaximum depth level of lower devices.\n *\t@neigh_priv_len:\tUsed in neigh_alloc()\n * \t@dev_id:\t\tUsed to differentiate devices that share\n * \t\t\t\tthe same link layer address\n * \t@dev_port:\t\tUsed to differentiate devices that share\n * \t\t\t\tthe same function\n *\t@addr_list_lock:\tXXX: need comments on this one\n *\t@name_assign_type:\tnetwork interface name assignment type\n *\t@uc_promisc:\t\tCounter that indicates promiscuous mode\n *\t\t\t\thas been enabled due to the need to listen to\n *\t\t\t\tadditional unicast addresses in a device that\n *\t\t\t\tdoes not implement ndo_set_rx_mode()\n *\t@uc:\t\t\tunicast mac addresses\n *\t@mc:\t\t\tmulticast mac addresses\n *\t@dev_addrs:\t\tlist of device hw addresses\n *\t@queues_kset:\t\tGroup of all Kobjects in the Tx and RX queues\n *\t@promiscuity:\t\tNumber of times the NIC is told to work in\n *\t\t\t\tpromiscuous mode; if it becomes 0 the NIC will\n *\t\t\t\texit promiscuous mode\n *\t@allmulti:\t\tCounter, enables or disables allmulticast mode\n *\n *\t@vlan_info:\tVLAN info\n *\t@dsa_ptr:\tdsa specific data\n *\t@tipc_ptr:\tTIPC specific data\n *\t@atalk_ptr:\tAppleTalk link\n *\t@ip_ptr:\tIPv4 specific data\n *\t@dn_ptr:\tDECnet specific data\n *\t@ip6_ptr:\tIPv6 specific data\n *\t@ax25_ptr:\tAX.25 specific data\n *\t@ieee80211_ptr:\tIEEE 802.11 specific data, assign before registering\n *\t@ieee802154_ptr: IEEE 802.15.4 low-rate Wireless Personal Area Network\n *\t\t\t device struct\n *\t@mpls_ptr:\tmpls_dev struct pointer\n *\n *\t@dev_addr:\tHw address (before bcast,\n *\t\t\tbecause most packets are unicast)\n *\n *\t@_rx:\t\t\tArray of RX queues\n *\t@num_rx_queues:\t\tNumber of RX queues\n *\t\t\t\tallocated at register_netdev() time\n *\t@real_num_rx_queues: \tNumber of RX queues currently active in device\n *\t@xdp_prog:\t\tXDP sockets filter program pointer\n *\t@gro_flush_timeout:\ttimeout for GRO layer in NAPI\n *\t@napi_defer_hard_irqs:\tIf not zero, provides a counter that would\n *\t\t\t\tallow to avoid NIC hard IRQ, on busy queues.\n *\n *\t@rx_handler:\t\thandler for received packets\n *\t@rx_handler_data: \tXXX: need comments on this one\n *\t@miniq_ingress:\t\tingress/clsact qdisc specific data for\n *\t\t\t\tingress processing\n *\t@ingress_queue:\t\tXXX: need comments on this one\n *\t@nf_hooks_ingress:\tnetfilter hooks executed for ingress packets\n *\t@broadcast:\t\thw bcast address\n *\n *\t@rx_cpu_rmap:\tCPU reverse-mapping for RX completion interrupts,\n *\t\t\tindexed by RX queue number. Assigned by driver.\n *\t\t\tThis must only be set if the ndo_rx_flow_steer\n *\t\t\toperation is defined\n *\t@index_hlist:\t\tDevice index hash chain\n *\n *\t@_tx:\t\t\tArray of TX queues\n *\t@num_tx_queues:\t\tNumber of TX queues allocated at alloc_netdev_mq() time\n *\t@real_num_tx_queues: \tNumber of TX queues currently active in device\n *\t@qdisc:\t\t\tRoot qdisc from userspace point of view\n *\t@tx_queue_len:\t\tMax frames per queue allowed\n *\t@tx_global_lock: \tXXX: need comments on this one\n *\t@xdp_bulkq:\t\tXDP device bulk queue\n *\t@xps_cpus_map:\t\tall CPUs map for XPS device\n *\t@xps_rxqs_map:\t\tall RXQs map for XPS device\n *\n *\t@xps_maps:\tXXX: need comments on this one\n *\t@miniq_egress:\t\tclsact qdisc specific data for\n *\t\t\t\tegress processing\n *\t@qdisc_hash:\t\tqdisc hash table\n *\t@watchdog_timeo:\tRepresents the timeout that is used by\n *\t\t\t\tthe watchdog (see dev_watchdog())\n *\t@watchdog_timer:\tList of timers\n *\n *\t@proto_down_reason:\treason a netdev interface is held down\n *\t@pcpu_refcnt:\t\tNumber of references to this device\n *\t@todo_list:\t\tDelayed register/unregister\n *\t@link_watch_list:\tXXX: need comments on this one\n *\n *\t@reg_state:\t\tRegister/unregister state machine\n *\t@dismantle:\t\tDevice is going to be freed\n *\t@rtnl_link_state:\tThis enum represents the phases of creating\n *\t\t\t\ta new link\n *\n *\t@needs_free_netdev:\tShould unregister perform free_netdev?\n *\t@priv_destructor:\tCalled from unregister\n *\t@npinfo:\t\tXXX: need comments on this one\n * \t@nd_net:\t\tNetwork namespace this network device is inside\n *\n * \t@ml_priv:\tMid-layer private\n *\t@ml_priv_type:  Mid-layer private type\n * \t@lstats:\tLoopback statistics\n * \t@tstats:\tTunnel statistics\n * \t@dstats:\tDummy statistics\n * \t@vstats:\tVirtual ethernet statistics\n *\n *\t@garp_port:\tGARP\n *\t@mrp_port:\tMRP\n *\n *\t@dev:\t\tClass/net/name entry\n *\t@sysfs_groups:\tSpace for optional device, statistics and wireless\n *\t\t\tsysfs groups\n *\n *\t@sysfs_rx_queue_group:\tSpace for optional per-rx queue attributes\n *\t@rtnl_link_ops:\tRtnl_link_ops\n *\n *\t@gso_max_size:\tMaximum size of generic segmentation offload\n *\t@gso_max_segs:\tMaximum number of segments that can be passed to the\n *\t\t\tNIC for GSO\n *\n *\t@dcbnl_ops:\tData Center Bridging netlink ops\n *\t@num_tc:\tNumber of traffic classes in the net device\n *\t@tc_to_txq:\tXXX: need comments on this one\n *\t@prio_tc_map:\tXXX: need comments on this one\n *\n *\t@fcoe_ddp_xid:\tMax exchange id for FCoE LRO by ddp\n *\n *\t@priomap:\tXXX: need comments on this one\n *\t@phydev:\tPhysical device may attach itself\n *\t\t\tfor hardware timestamping\n *\t@sfp_bus:\tattached &struct sfp_bus structure.\n *\n *\t@qdisc_tx_busylock: lockdep class annotating Qdisc->busylock spinlock\n *\t@qdisc_running_key: lockdep class annotating Qdisc->running seqcount\n *\n *\t@proto_down:\tprotocol port state information can be sent to the\n *\t\t\tswitch driver and used to set the phys state of the\n *\t\t\tswitch port.\n *\n *\t@wol_enabled:\tWake-on-LAN is enabled\n *\n *\t@threaded:\tnapi threaded mode is enabled\n *\n *\t@net_notifier_list:\tList of per-net netdev notifier block\n *\t\t\t\tthat follow this device when it is moved\n *\t\t\t\tto another network namespace.\n *\n *\t@macsec_ops:    MACsec offloading ops\n *\n *\t@udp_tunnel_nic_info:\tstatic structure describing the UDP tunnel\n *\t\t\t\toffload capabilities of the device\n *\t@udp_tunnel_nic:\tUDP tunnel offload state\n *\t@xdp_state:\t\tstores info on attached XDP BPF programs\n *\n *\t@nested_level:\tUsed as as a parameter of spin_lock_nested() of\n *\t\t\tdev->addr_list_lock.\n *\t@unlink_list:\tAs netif_addr_lock() can be called recursively,\n *\t\t\tkeep a list of interfaces to be deleted.\n *\n *\tFIXME: cleanup struct net_device such that network protocol info\n *\tmoves out.\n */\n\nstruct net_device {\n\tchar\t\t\tname[IFNAMSIZ];\n\tstruct netdev_name_node\t*name_node;\n\tstruct dev_ifalias\t__rcu *ifalias;\n\t/*\n\t *\tI/O specific fields\n\t *\tFIXME: Merge these and struct ifmap into one\n\t */\n\tunsigned long\t\tmem_end;\n\tunsigned long\t\tmem_start;\n\tunsigned long\t\tbase_addr;\n\n\t/*\n\t *\tSome hardware also needs these fields (state,dev_list,\n\t *\tnapi_list,unreg_list,close_list) but they are not\n\t *\tpart of the usual set specified in Space.c.\n\t */\n\n\tunsigned long\t\tstate;\n\n\tstruct list_head\tdev_list;\n\tstruct list_head\tnapi_list;\n\tstruct list_head\tunreg_list;\n\tstruct list_head\tclose_list;\n\tstruct list_head\tptype_all;\n\tstruct list_head\tptype_specific;\n\n\tstruct {\n\t\tstruct list_head upper;\n\t\tstruct list_head lower;\n\t} adj_list;\n\n\t/* Read-mostly cache-line for fast-path access */\n\tunsigned int\t\tflags;\n\tunsigned int\t\tpriv_flags;\n\tconst struct net_device_ops *netdev_ops;\n\tint\t\t\tifindex;\n\tunsigned short\t\tgflags;\n\tunsigned short\t\thard_header_len;\n\n\t/* Note : dev->mtu is often read without holding a lock.\n\t * Writers usually hold RTNL.\n\t * It is recommended to use READ_ONCE() to annotate the reads,\n\t * and to use WRITE_ONCE() to annotate the writes.\n\t */\n\tunsigned int\t\tmtu;\n\tunsigned short\t\tneeded_headroom;\n\tunsigned short\t\tneeded_tailroom;\n\n\tnetdev_features_t\tfeatures;\n\tnetdev_features_t\thw_features;\n\tnetdev_features_t\twanted_features;\n\tnetdev_features_t\tvlan_features;\n\tnetdev_features_t\thw_enc_features;\n\tnetdev_features_t\tmpls_features;\n\tnetdev_features_t\tgso_partial_features;\n\n\tunsigned int\t\tmin_mtu;\n\tunsigned int\t\tmax_mtu;\n\tunsigned short\t\ttype;\n\tunsigned char\t\tmin_header_len;\n\tunsigned char\t\tname_assign_type;\n\n\tint\t\t\tgroup;\n\n\tstruct net_device_stats\tstats; /* not used by modern drivers */\n\n\tatomic_long_t\t\trx_dropped;\n\tatomic_long_t\t\ttx_dropped;\n\tatomic_long_t\t\trx_nohandler;\n\n\t/* Stats to monitor link on/off, flapping */\n\tatomic_t\t\tcarrier_up_count;\n\tatomic_t\t\tcarrier_down_count;\n\n#ifdef CONFIG_WIRELESS_EXT\n\tconst struct iw_handler_def *wireless_handlers;\n\tstruct iw_public_data\t*wireless_data;\n#endif\n\tconst struct ethtool_ops *ethtool_ops;\n#ifdef CONFIG_NET_L3_MASTER_DEV\n\tconst struct l3mdev_ops\t*l3mdev_ops;\n#endif\n#if IS_ENABLED(CONFIG_IPV6)\n\tconst struct ndisc_ops *ndisc_ops;\n#endif\n\n#ifdef CONFIG_XFRM_OFFLOAD\n\tconst struct xfrmdev_ops *xfrmdev_ops;\n#endif\n\n#if IS_ENABLED(CONFIG_TLS_DEVICE)\n\tconst struct tlsdev_ops *tlsdev_ops;\n#endif\n\n\tconst struct header_ops *header_ops;\n\n\tunsigned char\t\toperstate;\n\tunsigned char\t\tlink_mode;\n\n\tunsigned char\t\tif_port;\n\tunsigned char\t\tdma;\n\n\t/* Interface address info. */\n\tunsigned char\t\tperm_addr[MAX_ADDR_LEN];\n\tunsigned char\t\taddr_assign_type;\n\tunsigned char\t\taddr_len;\n\tunsigned char\t\tupper_level;\n\tunsigned char\t\tlower_level;\n\n\tunsigned short\t\tneigh_priv_len;\n\tunsigned short          dev_id;\n\tunsigned short          dev_port;\n\tunsigned short\t\tpadded;\n\n\tspinlock_t\t\taddr_list_lock;\n\tint\t\t\tirq;\n\n\tstruct netdev_hw_addr_list\tuc;\n\tstruct netdev_hw_addr_list\tmc;\n\tstruct netdev_hw_addr_list\tdev_addrs;\n\n#ifdef CONFIG_SYSFS\n\tstruct kset\t\t*queues_kset;\n#endif\n#ifdef CONFIG_LOCKDEP\n\tstruct list_head\tunlink_list;\n#endif\n\tunsigned int\t\tpromiscuity;\n\tunsigned int\t\tallmulti;\n\tbool\t\t\tuc_promisc;\n#ifdef CONFIG_LOCKDEP\n\tunsigned char\t\tnested_level;\n#endif\n\n\n\t/* Protocol-specific pointers */\n\n#if IS_ENABLED(CONFIG_VLAN_8021Q)\n\tstruct vlan_info __rcu\t*vlan_info;\n#endif\n#if IS_ENABLED(CONFIG_NET_DSA)\n\tstruct dsa_port\t\t*dsa_ptr;\n#endif\n#if IS_ENABLED(CONFIG_TIPC)\n\tstruct tipc_bearer __rcu *tipc_ptr;\n#endif\n#if IS_ENABLED(CONFIG_IRDA) || IS_ENABLED(CONFIG_ATALK)\n\tvoid \t\t\t*atalk_ptr;\n#endif\n\tstruct in_device __rcu\t*ip_ptr;\n#if IS_ENABLED(CONFIG_DECNET)\n\tstruct dn_dev __rcu     *dn_ptr;\n#endif\n\tstruct inet6_dev __rcu\t*ip6_ptr;\n#if IS_ENABLED(CONFIG_AX25)\n\tvoid\t\t\t*ax25_ptr;\n#endif\n\tstruct wireless_dev\t*ieee80211_ptr;\n\tstruct wpan_dev\t\t*ieee802154_ptr;\n#if IS_ENABLED(CONFIG_MPLS_ROUTING)\n\tstruct mpls_dev __rcu\t*mpls_ptr;\n#endif\n\n/*\n * Cache lines mostly used on receive path (including eth_type_trans())\n */\n\t/* Interface address info used in eth_type_trans() */\n\tunsigned char\t\t*dev_addr;\n\n\tstruct netdev_rx_queue\t*_rx;\n\tunsigned int\t\tnum_rx_queues;\n\tunsigned int\t\treal_num_rx_queues;\n\n\tstruct bpf_prog __rcu\t*xdp_prog;\n\tunsigned long\t\tgro_flush_timeout;\n\tint\t\t\tnapi_defer_hard_irqs;\n\trx_handler_func_t __rcu\t*rx_handler;\n\tvoid __rcu\t\t*rx_handler_data;\n\n#ifdef CONFIG_NET_CLS_ACT\n\tstruct mini_Qdisc __rcu\t*miniq_ingress;\n#endif\n\tstruct netdev_queue __rcu *ingress_queue;\n#ifdef CONFIG_NETFILTER_INGRESS\n\tstruct nf_hook_entries __rcu *nf_hooks_ingress;\n#endif\n\n\tunsigned char\t\tbroadcast[MAX_ADDR_LEN];\n#ifdef CONFIG_RFS_ACCEL\n\tstruct cpu_rmap\t\t*rx_cpu_rmap;\n#endif\n\tstruct hlist_node\tindex_hlist;\n\n/*\n * Cache lines mostly used on transmit path\n */\n\tstruct netdev_queue\t*_tx ____cacheline_aligned_in_smp;\n\tunsigned int\t\tnum_tx_queues;\n\tunsigned int\t\treal_num_tx_queues;\n\tstruct Qdisc\t\t*qdisc;\n\tunsigned int\t\ttx_queue_len;\n\tspinlock_t\t\ttx_global_lock;\n\n\tstruct xdp_dev_bulk_queue __percpu *xdp_bulkq;\n\n#ifdef CONFIG_XPS\n\tstruct xps_dev_maps __rcu *xps_cpus_map;\n\tstruct xps_dev_maps __rcu *xps_rxqs_map;\n#endif\n#ifdef CONFIG_NET_CLS_ACT\n\tstruct mini_Qdisc __rcu\t*miniq_egress;\n#endif\n\n#ifdef CONFIG_NET_SCHED\n\tDECLARE_HASHTABLE\t(qdisc_hash, 4);\n#endif\n\t/* These may be needed for future network-power-down code. */\n\tstruct timer_list\twatchdog_timer;\n\tint\t\t\twatchdog_timeo;\n\n\tu32                     proto_down_reason;\n\n\tstruct list_head\ttodo_list;\n\tint __percpu\t\t*pcpu_refcnt;\n\n\tstruct list_head\tlink_watch_list;\n\n\tenum { NETREG_UNINITIALIZED=0,\n\t       NETREG_REGISTERED,\t/* completed register_netdevice */\n\t       NETREG_UNREGISTERING,\t/* called unregister_netdevice */\n\t       NETREG_UNREGISTERED,\t/* completed unregister todo */\n\t       NETREG_RELEASED,\t\t/* called free_netdev */\n\t       NETREG_DUMMY,\t\t/* dummy device for NAPI poll */\n\t} reg_state:8;\n\n\tbool dismantle;\n\n\tenum {\n\t\tRTNL_LINK_INITIALIZED,\n\t\tRTNL_LINK_INITIALIZING,\n\t} rtnl_link_state:16;\n\n\tbool needs_free_netdev;\n\tvoid (*priv_destructor)(struct net_device *dev);\n\n#ifdef CONFIG_NETPOLL\n\tstruct netpoll_info __rcu\t*npinfo;\n#endif\n\n\tpossible_net_t\t\t\tnd_net;\n\n\t/* mid-layer private */\n\tvoid\t\t\t\t*ml_priv;\n\tenum netdev_ml_priv_type\tml_priv_type;\n\n\tunion {\n\t\tstruct pcpu_lstats __percpu\t\t*lstats;\n\t\tstruct pcpu_sw_netstats __percpu\t*tstats;\n\t\tstruct pcpu_dstats __percpu\t\t*dstats;\n\t};\n\n#if IS_ENABLED(CONFIG_GARP)\n\tstruct garp_port __rcu\t*garp_port;\n#endif\n#if IS_ENABLED(CONFIG_MRP)\n\tstruct mrp_port __rcu\t*mrp_port;\n#endif\n\n\tstruct device\t\tdev;\n\tconst struct attribute_group *sysfs_groups[4];\n\tconst struct attribute_group *sysfs_rx_queue_group;\n\n\tconst struct rtnl_link_ops *rtnl_link_ops;\n\n\t/* for setting kernel sock attribute on TCP connection setup */\n#define GSO_MAX_SIZE\t\t65536\n\tunsigned int\t\tgso_max_size;\n#define GSO_MAX_SEGS\t\t65535\n\tu16\t\t\tgso_max_segs;\n\n#ifdef CONFIG_DCB\n\tconst struct dcbnl_rtnl_ops *dcbnl_ops;\n#endif\n\ts16\t\t\tnum_tc;\n\tstruct netdev_tc_txq\ttc_to_txq[TC_MAX_QUEUE];\n\tu8\t\t\tprio_tc_map[TC_BITMASK + 1];\n\n#if IS_ENABLED(CONFIG_FCOE)\n\tunsigned int\t\tfcoe_ddp_xid;\n#endif\n#if IS_ENABLED(CONFIG_CGROUP_NET_PRIO)\n\tstruct netprio_map __rcu *priomap;\n#endif\n\tstruct phy_device\t*phydev;\n\tstruct sfp_bus\t\t*sfp_bus;\n\tstruct lock_class_key\t*qdisc_tx_busylock;\n\tstruct lock_class_key\t*qdisc_running_key;\n\tbool\t\t\tproto_down;\n\tunsigned\t\twol_enabled:1;\n\tunsigned\t\tthreaded:1;\n\n\tstruct list_head\tnet_notifier_list;\n\n#if IS_ENABLED(CONFIG_MACSEC)\n\t/* MACsec management functions */\n\tconst struct macsec_ops *macsec_ops;\n#endif\n\tconst struct udp_tunnel_nic_info\t*udp_tunnel_nic_info;\n\tstruct udp_tunnel_nic\t*udp_tunnel_nic;\n\n\t/* protected by rtnl_lock */\n\tstruct bpf_xdp_entity\txdp_state[__MAX_XDP_MODE];\n};\n#define to_net_dev(d) container_of(d, struct net_device, dev)\n\nstatic inline bool netif_elide_gro(const struct net_device *dev)\n{\n\tif (!(dev->features & NETIF_F_GRO) || dev->xdp_prog)\n\t\treturn true;\n\treturn false;\n}\n\n#define\tNETDEV_ALIGN\t\t32\n\nstatic inline\nint netdev_get_prio_tc_map(const struct net_device *dev, u32 prio)\n{\n\treturn dev->prio_tc_map[prio & TC_BITMASK];\n}\n\nstatic inline\nint netdev_set_prio_tc_map(struct net_device *dev, u8 prio, u8 tc)\n{\n\tif (tc >= dev->num_tc)\n\t\treturn -EINVAL;\n\n\tdev->prio_tc_map[prio & TC_BITMASK] = tc & TC_BITMASK;\n\treturn 0;\n}\n\nint netdev_txq_to_tc(struct net_device *dev, unsigned int txq);\nvoid netdev_reset_tc(struct net_device *dev);\nint netdev_set_tc_queue(struct net_device *dev, u8 tc, u16 count, u16 offset);\nint netdev_set_num_tc(struct net_device *dev, u8 num_tc);\n\nstatic inline\nint netdev_get_num_tc(struct net_device *dev)\n{\n\treturn dev->num_tc;\n}\n\nstatic inline void net_prefetch(void *p)\n{\n\tprefetch(p);\n#if L1_CACHE_BYTES < 128\n\tprefetch((u8 *)p + L1_CACHE_BYTES);\n#endif\n}\n\nstatic inline void net_prefetchw(void *p)\n{\n\tprefetchw(p);\n#if L1_CACHE_BYTES < 128\n\tprefetchw((u8 *)p + L1_CACHE_BYTES);\n#endif\n}\n\nvoid netdev_unbind_sb_channel(struct net_device *dev,\n\t\t\t      struct net_device *sb_dev);\nint netdev_bind_sb_channel_queue(struct net_device *dev,\n\t\t\t\t struct net_device *sb_dev,\n\t\t\t\t u8 tc, u16 count, u16 offset);\nint netdev_set_sb_channel(struct net_device *dev, u16 channel);\nstatic inline int netdev_get_sb_channel(struct net_device *dev)\n{\n\treturn max_t(int, -dev->num_tc, 0);\n}\n\nstatic inline\nstruct netdev_queue *netdev_get_tx_queue(const struct net_device *dev,\n\t\t\t\t\t unsigned int index)\n{\n\treturn &dev->_tx[index];\n}\n\nstatic inline struct netdev_queue *skb_get_tx_queue(const struct net_device *dev,\n\t\t\t\t\t\t    const struct sk_buff *skb)\n{\n\treturn netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));\n}\n\nstatic inline void netdev_for_each_tx_queue(struct net_device *dev,\n\t\t\t\t\t    void (*f)(struct net_device *,\n\t\t\t\t\t\t      struct netdev_queue *,\n\t\t\t\t\t\t      void *),\n\t\t\t\t\t    void *arg)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < dev->num_tx_queues; i++)\n\t\tf(dev, &dev->_tx[i], arg);\n}\n\n#define netdev_lockdep_set_classes(dev)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstatic struct lock_class_key qdisc_tx_busylock_key;\t\\\n\tstatic struct lock_class_key qdisc_running_key;\t\t\\\n\tstatic struct lock_class_key qdisc_xmit_lock_key;\t\\\n\tstatic struct lock_class_key dev_addr_list_lock_key;\t\\\n\tunsigned int i;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t(dev)->qdisc_tx_busylock = &qdisc_tx_busylock_key;\t\\\n\t(dev)->qdisc_running_key = &qdisc_running_key;\t\t\\\n\tlockdep_set_class(&(dev)->addr_list_lock,\t\t\\\n\t\t\t  &dev_addr_list_lock_key);\t\t\\\n\tfor (i = 0; i < (dev)->num_tx_queues; i++)\t\t\\\n\t\tlockdep_set_class(&(dev)->_tx[i]._xmit_lock,\t\\\n\t\t\t\t  &qdisc_xmit_lock_key);\t\\\n}\n\nu16 netdev_pick_tx(struct net_device *dev, struct sk_buff *skb,\n\t\t     struct net_device *sb_dev);\nstruct netdev_queue *netdev_core_pick_tx(struct net_device *dev,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t struct net_device *sb_dev);\n\n/* returns the headroom that the master device needs to take in account\n * when forwarding to this dev\n */\nstatic inline unsigned netdev_get_fwd_headroom(struct net_device *dev)\n{\n\treturn dev->priv_flags & IFF_PHONY_HEADROOM ? 0 : dev->needed_headroom;\n}\n\nstatic inline void netdev_set_rx_headroom(struct net_device *dev, int new_hr)\n{\n\tif (dev->netdev_ops->ndo_set_rx_headroom)\n\t\tdev->netdev_ops->ndo_set_rx_headroom(dev, new_hr);\n}\n\n/* set the device rx headroom to the dev's default */\nstatic inline void netdev_reset_rx_headroom(struct net_device *dev)\n{\n\tnetdev_set_rx_headroom(dev, -1);\n}\n\nstatic inline void *netdev_get_ml_priv(struct net_device *dev,\n\t\t\t\t       enum netdev_ml_priv_type type)\n{\n\tif (dev->ml_priv_type != type)\n\t\treturn NULL;\n\n\treturn dev->ml_priv;\n}\n\nstatic inline void netdev_set_ml_priv(struct net_device *dev,\n\t\t\t\t      void *ml_priv,\n\t\t\t\t      enum netdev_ml_priv_type type)\n{\n\tWARN(dev->ml_priv_type && dev->ml_priv_type != type,\n\t     \"Overwriting already set ml_priv_type (%u) with different ml_priv_type (%u)!\\n\",\n\t     dev->ml_priv_type, type);\n\tWARN(!dev->ml_priv_type && dev->ml_priv,\n\t     \"Overwriting already set ml_priv and ml_priv_type is ML_PRIV_NONE!\\n\");\n\n\tdev->ml_priv = ml_priv;\n\tdev->ml_priv_type = type;\n}\n\n/*\n * Net namespace inlines\n */\nstatic inline\nstruct net *dev_net(const struct net_device *dev)\n{\n\treturn read_pnet(&dev->nd_net);\n}\n\nstatic inline\nvoid dev_net_set(struct net_device *dev, struct net *net)\n{\n\twrite_pnet(&dev->nd_net, net);\n}\n\n/**\n *\tnetdev_priv - access network device private data\n *\t@dev: network device\n *\n * Get network device private data\n */\nstatic inline void *netdev_priv(const struct net_device *dev)\n{\n\treturn (char *)dev + ALIGN(sizeof(struct net_device), NETDEV_ALIGN);\n}\n\n/* Set the sysfs physical device reference for the network logical device\n * if set prior to registration will cause a symlink during initialization.\n */\n#define SET_NETDEV_DEV(net, pdev)\t((net)->dev.parent = (pdev))\n\n/* Set the sysfs device type for the network logical device to allow\n * fine-grained identification of different network device types. For\n * example Ethernet, Wireless LAN, Bluetooth, WiMAX etc.\n */\n#define SET_NETDEV_DEVTYPE(net, devtype)\t((net)->dev.type = (devtype))\n\n/* Default NAPI poll() weight\n * Device drivers are strongly advised to not use bigger value\n */\n#define NAPI_POLL_WEIGHT 64\n\n/**\n *\tnetif_napi_add - initialize a NAPI context\n *\t@dev:  network device\n *\t@napi: NAPI context\n *\t@poll: polling function\n *\t@weight: default weight\n *\n * netif_napi_add() must be used to initialize a NAPI context prior to calling\n * *any* of the other NAPI-related functions.\n */\nvoid netif_napi_add(struct net_device *dev, struct napi_struct *napi,\n\t\t    int (*poll)(struct napi_struct *, int), int weight);\n\n/**\n *\tnetif_tx_napi_add - initialize a NAPI context\n *\t@dev:  network device\n *\t@napi: NAPI context\n *\t@poll: polling function\n *\t@weight: default weight\n *\n * This variant of netif_napi_add() should be used from drivers using NAPI\n * to exclusively poll a TX queue.\n * This will avoid we add it into napi_hash[], thus polluting this hash table.\n */\nstatic inline void netif_tx_napi_add(struct net_device *dev,\n\t\t\t\t     struct napi_struct *napi,\n\t\t\t\t     int (*poll)(struct napi_struct *, int),\n\t\t\t\t     int weight)\n{\n\tset_bit(NAPI_STATE_NO_BUSY_POLL, &napi->state);\n\tnetif_napi_add(dev, napi, poll, weight);\n}\n\n/**\n *  __netif_napi_del - remove a NAPI context\n *  @napi: NAPI context\n *\n * Warning: caller must observe RCU grace period before freeing memory\n * containing @napi. Drivers might want to call this helper to combine\n * all the needed RCU grace periods into a single one.\n */\nvoid __netif_napi_del(struct napi_struct *napi);\n\n/**\n *  netif_napi_del - remove a NAPI context\n *  @napi: NAPI context\n *\n *  netif_napi_del() removes a NAPI context from the network device NAPI list\n */\nstatic inline void netif_napi_del(struct napi_struct *napi)\n{\n\t__netif_napi_del(napi);\n\tsynchronize_net();\n}\n\nstruct napi_gro_cb {\n\t/* Virtual address of skb_shinfo(skb)->frags[0].page + offset. */\n\tvoid\t*frag0;\n\n\t/* Length of frag0. */\n\tunsigned int frag0_len;\n\n\t/* This indicates where we are processing relative to skb->data. */\n\tint\tdata_offset;\n\n\t/* This is non-zero if the packet cannot be merged with the new skb. */\n\tu16\tflush;\n\n\t/* Save the IP ID here and check when we get to the transport layer */\n\tu16\tflush_id;\n\n\t/* Number of segments aggregated. */\n\tu16\tcount;\n\n\t/* Start offset for remote checksum offload */\n\tu16\tgro_remcsum_start;\n\n\t/* jiffies when first packet was created/queued */\n\tunsigned long age;\n\n\t/* Used in ipv6_gro_receive() and foo-over-udp */\n\tu16\tproto;\n\n\t/* This is non-zero if the packet may be of the same flow. */\n\tu8\tsame_flow:1;\n\n\t/* Used in tunnel GRO receive */\n\tu8\tencap_mark:1;\n\n\t/* GRO checksum is valid */\n\tu8\tcsum_valid:1;\n\n\t/* Number of checksums via CHECKSUM_UNNECESSARY */\n\tu8\tcsum_cnt:3;\n\n\t/* Free the skb? */\n\tu8\tfree:2;\n#define NAPI_GRO_FREE\t\t  1\n#define NAPI_GRO_FREE_STOLEN_HEAD 2\n\n\t/* Used in foo-over-udp, set in udp[46]_gro_receive */\n\tu8\tis_ipv6:1;\n\n\t/* Used in GRE, set in fou/gue_gro_receive */\n\tu8\tis_fou:1;\n\n\t/* Used to determine if flush_id can be ignored */\n\tu8\tis_atomic:1;\n\n\t/* Number of gro_receive callbacks this packet already went through */\n\tu8 recursion_counter:4;\n\n\t/* GRO is done by frag_list pointer chaining. */\n\tu8\tis_flist:1;\n\n\t/* used to support CHECKSUM_COMPLETE for tunneling protocols */\n\t__wsum\tcsum;\n\n\t/* used in skb_gro_receive() slow path */\n\tstruct sk_buff *last;\n};\n\n#define NAPI_GRO_CB(skb) ((struct napi_gro_cb *)(skb)->cb)\n\n#define GRO_RECURSION_LIMIT 15\nstatic inline int gro_recursion_inc_test(struct sk_buff *skb)\n{\n\treturn ++NAPI_GRO_CB(skb)->recursion_counter == GRO_RECURSION_LIMIT;\n}\n\ntypedef struct sk_buff *(*gro_receive_t)(struct list_head *, struct sk_buff *);\nstatic inline struct sk_buff *call_gro_receive(gro_receive_t cb,\n\t\t\t\t\t       struct list_head *head,\n\t\t\t\t\t       struct sk_buff *skb)\n{\n\tif (unlikely(gro_recursion_inc_test(skb))) {\n\t\tNAPI_GRO_CB(skb)->flush |= 1;\n\t\treturn NULL;\n\t}\n\n\treturn cb(head, skb);\n}\n\ntypedef struct sk_buff *(*gro_receive_sk_t)(struct sock *, struct list_head *,\n\t\t\t\t\t    struct sk_buff *);\nstatic inline struct sk_buff *call_gro_receive_sk(gro_receive_sk_t cb,\n\t\t\t\t\t\t  struct sock *sk,\n\t\t\t\t\t\t  struct list_head *head,\n\t\t\t\t\t\t  struct sk_buff *skb)\n{\n\tif (unlikely(gro_recursion_inc_test(skb))) {\n\t\tNAPI_GRO_CB(skb)->flush |= 1;\n\t\treturn NULL;\n\t}\n\n\treturn cb(sk, head, skb);\n}\n\nstruct packet_type {\n\t__be16\t\t\ttype;\t/* This is really htons(ether_type). */\n\tbool\t\t\tignore_outgoing;\n\tstruct net_device\t*dev;\t/* NULL is wildcarded here\t     */\n\tint\t\t\t(*func) (struct sk_buff *,\n\t\t\t\t\t struct net_device *,\n\t\t\t\t\t struct packet_type *,\n\t\t\t\t\t struct net_device *);\n\tvoid\t\t\t(*list_func) (struct list_head *,\n\t\t\t\t\t      struct packet_type *,\n\t\t\t\t\t      struct net_device *);\n\tbool\t\t\t(*id_match)(struct packet_type *ptype,\n\t\t\t\t\t    struct sock *sk);\n\tvoid\t\t\t*af_packet_priv;\n\tstruct list_head\tlist;\n};\n\nstruct offload_callbacks {\n\tstruct sk_buff\t\t*(*gso_segment)(struct sk_buff *skb,\n\t\t\t\t\t\tnetdev_features_t features);\n\tstruct sk_buff\t\t*(*gro_receive)(struct list_head *head,\n\t\t\t\t\t\tstruct sk_buff *skb);\n\tint\t\t\t(*gro_complete)(struct sk_buff *skb, int nhoff);\n};\n\nstruct packet_offload {\n\t__be16\t\t\t type;\t/* This is really htons(ether_type). */\n\tu16\t\t\t priority;\n\tstruct offload_callbacks callbacks;\n\tstruct list_head\t list;\n};\n\n/* often modified stats are per-CPU, other are shared (netdev->stats) */\nstruct pcpu_sw_netstats {\n\tu64     rx_packets;\n\tu64     rx_bytes;\n\tu64     tx_packets;\n\tu64     tx_bytes;\n\tstruct u64_stats_sync   syncp;\n} __aligned(4 * sizeof(u64));\n\nstruct pcpu_lstats {\n\tu64_stats_t packets;\n\tu64_stats_t bytes;\n\tstruct u64_stats_sync syncp;\n} __aligned(2 * sizeof(u64));\n\nvoid dev_lstats_read(struct net_device *dev, u64 *packets, u64 *bytes);\n\nstatic inline void dev_sw_netstats_rx_add(struct net_device *dev, unsigned int len)\n{\n\tstruct pcpu_sw_netstats *tstats = this_cpu_ptr(dev->tstats);\n\n\tu64_stats_update_begin(&tstats->syncp);\n\ttstats->rx_bytes += len;\n\ttstats->rx_packets++;\n\tu64_stats_update_end(&tstats->syncp);\n}\n\nstatic inline void dev_sw_netstats_tx_add(struct net_device *dev,\n\t\t\t\t\t  unsigned int packets,\n\t\t\t\t\t  unsigned int len)\n{\n\tstruct pcpu_sw_netstats *tstats = this_cpu_ptr(dev->tstats);\n\n\tu64_stats_update_begin(&tstats->syncp);\n\ttstats->tx_bytes += len;\n\ttstats->tx_packets += packets;\n\tu64_stats_update_end(&tstats->syncp);\n}\n\nstatic inline void dev_lstats_add(struct net_device *dev, unsigned int len)\n{\n\tstruct pcpu_lstats *lstats = this_cpu_ptr(dev->lstats);\n\n\tu64_stats_update_begin(&lstats->syncp);\n\tu64_stats_add(&lstats->bytes, len);\n\tu64_stats_inc(&lstats->packets);\n\tu64_stats_update_end(&lstats->syncp);\n}\n\n#define __netdev_alloc_pcpu_stats(type, gfp)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(type) __percpu *pcpu_stats = alloc_percpu_gfp(type, gfp);\\\n\tif (pcpu_stats)\t{\t\t\t\t\t\t\\\n\t\tint __cpu;\t\t\t\t\t\t\\\n\t\tfor_each_possible_cpu(__cpu) {\t\t\t\t\\\n\t\t\ttypeof(type) *stat;\t\t\t\t\\\n\t\t\tstat = per_cpu_ptr(pcpu_stats, __cpu);\t\t\\\n\t\t\tu64_stats_init(&stat->syncp);\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tpcpu_stats;\t\t\t\t\t\t\t\\\n})\n\n#define netdev_alloc_pcpu_stats(type)\t\t\t\t\t\\\n\t__netdev_alloc_pcpu_stats(type, GFP_KERNEL)\n\n#define devm_netdev_alloc_pcpu_stats(dev, type)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(type) __percpu *pcpu_stats = devm_alloc_percpu(dev, type);\\\n\tif (pcpu_stats) {\t\t\t\t\t\t\\\n\t\tint __cpu;\t\t\t\t\t\t\\\n\t\tfor_each_possible_cpu(__cpu) {\t\t\t\t\\\n\t\t\ttypeof(type) *stat;\t\t\t\t\\\n\t\t\tstat = per_cpu_ptr(pcpu_stats, __cpu);\t\t\\\n\t\t\tu64_stats_init(&stat->syncp);\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tpcpu_stats;\t\t\t\t\t\t\t\\\n})\n\nenum netdev_lag_tx_type {\n\tNETDEV_LAG_TX_TYPE_UNKNOWN,\n\tNETDEV_LAG_TX_TYPE_RANDOM,\n\tNETDEV_LAG_TX_TYPE_BROADCAST,\n\tNETDEV_LAG_TX_TYPE_ROUNDROBIN,\n\tNETDEV_LAG_TX_TYPE_ACTIVEBACKUP,\n\tNETDEV_LAG_TX_TYPE_HASH,\n};\n\nenum netdev_lag_hash {\n\tNETDEV_LAG_HASH_NONE,\n\tNETDEV_LAG_HASH_L2,\n\tNETDEV_LAG_HASH_L34,\n\tNETDEV_LAG_HASH_L23,\n\tNETDEV_LAG_HASH_E23,\n\tNETDEV_LAG_HASH_E34,\n\tNETDEV_LAG_HASH_VLAN_SRCMAC,\n\tNETDEV_LAG_HASH_UNKNOWN,\n};\n\nstruct netdev_lag_upper_info {\n\tenum netdev_lag_tx_type tx_type;\n\tenum netdev_lag_hash hash_type;\n};\n\nstruct netdev_lag_lower_state_info {\n\tu8 link_up : 1,\n\t   tx_enabled : 1;\n};\n\n#include <linux/notifier.h>\n\n/* netdevice notifier chain. Please remember to update netdev_cmd_to_name()\n * and the rtnetlink notification exclusion list in rtnetlink_event() when\n * adding new types.\n */\nenum netdev_cmd {\n\tNETDEV_UP\t= 1,\t/* For now you can't veto a device up/down */\n\tNETDEV_DOWN,\n\tNETDEV_REBOOT,\t\t/* Tell a protocol stack a network interface\n\t\t\t\t   detected a hardware crash and restarted\n\t\t\t\t   - we can use this eg to kick tcp sessions\n\t\t\t\t   once done */\n\tNETDEV_CHANGE,\t\t/* Notify device state change */\n\tNETDEV_REGISTER,\n\tNETDEV_UNREGISTER,\n\tNETDEV_CHANGEMTU,\t/* notify after mtu change happened */\n\tNETDEV_CHANGEADDR,\t/* notify after the address change */\n\tNETDEV_PRE_CHANGEADDR,\t/* notify before the address change */\n\tNETDEV_GOING_DOWN,\n\tNETDEV_CHANGENAME,\n\tNETDEV_FEAT_CHANGE,\n\tNETDEV_BONDING_FAILOVER,\n\tNETDEV_PRE_UP,\n\tNETDEV_PRE_TYPE_CHANGE,\n\tNETDEV_POST_TYPE_CHANGE,\n\tNETDEV_POST_INIT,\n\tNETDEV_RELEASE,\n\tNETDEV_NOTIFY_PEERS,\n\tNETDEV_JOIN,\n\tNETDEV_CHANGEUPPER,\n\tNETDEV_RESEND_IGMP,\n\tNETDEV_PRECHANGEMTU,\t/* notify before mtu change happened */\n\tNETDEV_CHANGEINFODATA,\n\tNETDEV_BONDING_INFO,\n\tNETDEV_PRECHANGEUPPER,\n\tNETDEV_CHANGELOWERSTATE,\n\tNETDEV_UDP_TUNNEL_PUSH_INFO,\n\tNETDEV_UDP_TUNNEL_DROP_INFO,\n\tNETDEV_CHANGE_TX_QUEUE_LEN,\n\tNETDEV_CVLAN_FILTER_PUSH_INFO,\n\tNETDEV_CVLAN_FILTER_DROP_INFO,\n\tNETDEV_SVLAN_FILTER_PUSH_INFO,\n\tNETDEV_SVLAN_FILTER_DROP_INFO,\n};\nconst char *netdev_cmd_to_name(enum netdev_cmd cmd);\n\nint register_netdevice_notifier(struct notifier_block *nb);\nint unregister_netdevice_notifier(struct notifier_block *nb);\nint register_netdevice_notifier_net(struct net *net, struct notifier_block *nb);\nint unregister_netdevice_notifier_net(struct net *net,\n\t\t\t\t      struct notifier_block *nb);\nint register_netdevice_notifier_dev_net(struct net_device *dev,\n\t\t\t\t\tstruct notifier_block *nb,\n\t\t\t\t\tstruct netdev_net_notifier *nn);\nint unregister_netdevice_notifier_dev_net(struct net_device *dev,\n\t\t\t\t\t  struct notifier_block *nb,\n\t\t\t\t\t  struct netdev_net_notifier *nn);\n\nstruct netdev_notifier_info {\n\tstruct net_device\t*dev;\n\tstruct netlink_ext_ack\t*extack;\n};\n\nstruct netdev_notifier_info_ext {\n\tstruct netdev_notifier_info info; /* must be first */\n\tunion {\n\t\tu32 mtu;\n\t} ext;\n};\n\nstruct netdev_notifier_change_info {\n\tstruct netdev_notifier_info info; /* must be first */\n\tunsigned int flags_changed;\n};\n\nstruct netdev_notifier_changeupper_info {\n\tstruct netdev_notifier_info info; /* must be first */\n\tstruct net_device *upper_dev; /* new upper dev */\n\tbool master; /* is upper dev master */\n\tbool linking; /* is the notification for link or unlink */\n\tvoid *upper_info; /* upper dev info */\n};\n\nstruct netdev_notifier_changelowerstate_info {\n\tstruct netdev_notifier_info info; /* must be first */\n\tvoid *lower_state_info; /* is lower dev state */\n};\n\nstruct netdev_notifier_pre_changeaddr_info {\n\tstruct netdev_notifier_info info; /* must be first */\n\tconst unsigned char *dev_addr;\n};\n\nstatic inline void netdev_notifier_info_init(struct netdev_notifier_info *info,\n\t\t\t\t\t     struct net_device *dev)\n{\n\tinfo->dev = dev;\n\tinfo->extack = NULL;\n}\n\nstatic inline struct net_device *\nnetdev_notifier_info_to_dev(const struct netdev_notifier_info *info)\n{\n\treturn info->dev;\n}\n\nstatic inline struct netlink_ext_ack *\nnetdev_notifier_info_to_extack(const struct netdev_notifier_info *info)\n{\n\treturn info->extack;\n}\n\nint call_netdevice_notifiers(unsigned long val, struct net_device *dev);\n\n\nextern rwlock_t\t\t\t\tdev_base_lock;\t\t/* Device list lock */\n\n#define for_each_netdev(net, d)\t\t\\\n\t\tlist_for_each_entry(d, &(net)->dev_base_head, dev_list)\n#define for_each_netdev_reverse(net, d)\t\\\n\t\tlist_for_each_entry_reverse(d, &(net)->dev_base_head, dev_list)\n#define for_each_netdev_rcu(net, d)\t\t\\\n\t\tlist_for_each_entry_rcu(d, &(net)->dev_base_head, dev_list)\n#define for_each_netdev_safe(net, d, n)\t\\\n\t\tlist_for_each_entry_safe(d, n, &(net)->dev_base_head, dev_list)\n#define for_each_netdev_continue(net, d)\t\t\\\n\t\tlist_for_each_entry_continue(d, &(net)->dev_base_head, dev_list)\n#define for_each_netdev_continue_reverse(net, d)\t\t\\\n\t\tlist_for_each_entry_continue_reverse(d, &(net)->dev_base_head, \\\n\t\t\t\t\t\t     dev_list)\n#define for_each_netdev_continue_rcu(net, d)\t\t\\\n\tlist_for_each_entry_continue_rcu(d, &(net)->dev_base_head, dev_list)\n#define for_each_netdev_in_bond_rcu(bond, slave)\t\\\n\t\tfor_each_netdev_rcu(&init_net, slave)\t\\\n\t\t\tif (netdev_master_upper_dev_get_rcu(slave) == (bond))\n#define net_device_entry(lh)\tlist_entry(lh, struct net_device, dev_list)\n\nstatic inline struct net_device *next_net_device(struct net_device *dev)\n{\n\tstruct list_head *lh;\n\tstruct net *net;\n\n\tnet = dev_net(dev);\n\tlh = dev->dev_list.next;\n\treturn lh == &net->dev_base_head ? NULL : net_device_entry(lh);\n}\n\nstatic inline struct net_device *next_net_device_rcu(struct net_device *dev)\n{\n\tstruct list_head *lh;\n\tstruct net *net;\n\n\tnet = dev_net(dev);\n\tlh = rcu_dereference(list_next_rcu(&dev->dev_list));\n\treturn lh == &net->dev_base_head ? NULL : net_device_entry(lh);\n}\n\nstatic inline struct net_device *first_net_device(struct net *net)\n{\n\treturn list_empty(&net->dev_base_head) ? NULL :\n\t\tnet_device_entry(net->dev_base_head.next);\n}\n\nstatic inline struct net_device *first_net_device_rcu(struct net *net)\n{\n\tstruct list_head *lh = rcu_dereference(list_next_rcu(&net->dev_base_head));\n\n\treturn lh == &net->dev_base_head ? NULL : net_device_entry(lh);\n}\n\nint netdev_boot_setup_check(struct net_device *dev);\nunsigned long netdev_boot_base(const char *prefix, int unit);\nstruct net_device *dev_getbyhwaddr_rcu(struct net *net, unsigned short type,\n\t\t\t\t       const char *hwaddr);\nstruct net_device *dev_getfirstbyhwtype(struct net *net, unsigned short type);\nvoid dev_add_pack(struct packet_type *pt);\nvoid dev_remove_pack(struct packet_type *pt);\nvoid __dev_remove_pack(struct packet_type *pt);\nvoid dev_add_offload(struct packet_offload *po);\nvoid dev_remove_offload(struct packet_offload *po);\n\nint dev_get_iflink(const struct net_device *dev);\nint dev_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb);\nstruct net_device *__dev_get_by_flags(struct net *net, unsigned short flags,\n\t\t\t\t      unsigned short mask);\nstruct net_device *dev_get_by_name(struct net *net, const char *name);\nstruct net_device *dev_get_by_name_rcu(struct net *net, const char *name);\nstruct net_device *__dev_get_by_name(struct net *net, const char *name);\nint dev_alloc_name(struct net_device *dev, const char *name);\nint dev_open(struct net_device *dev, struct netlink_ext_ack *extack);\nvoid dev_close(struct net_device *dev);\nvoid dev_close_many(struct list_head *head, bool unlink);\nvoid dev_disable_lro(struct net_device *dev);\nint dev_loopback_xmit(struct net *net, struct sock *sk, struct sk_buff *newskb);\nu16 dev_pick_tx_zero(struct net_device *dev, struct sk_buff *skb,\n\t\t     struct net_device *sb_dev);\nu16 dev_pick_tx_cpu_id(struct net_device *dev, struct sk_buff *skb,\n\t\t       struct net_device *sb_dev);\n\nint dev_queue_xmit(struct sk_buff *skb);\nint dev_queue_xmit_accel(struct sk_buff *skb, struct net_device *sb_dev);\nint __dev_direct_xmit(struct sk_buff *skb, u16 queue_id);\n\nstatic inline int dev_direct_xmit(struct sk_buff *skb, u16 queue_id)\n{\n\tint ret;\n\n\tret = __dev_direct_xmit(skb, queue_id);\n\tif (!dev_xmit_complete(ret))\n\t\tkfree_skb(skb);\n\treturn ret;\n}\n\nint register_netdevice(struct net_device *dev);\nvoid unregister_netdevice_queue(struct net_device *dev, struct list_head *head);\nvoid unregister_netdevice_many(struct list_head *head);\nstatic inline void unregister_netdevice(struct net_device *dev)\n{\n\tunregister_netdevice_queue(dev, NULL);\n}\n\nint netdev_refcnt_read(const struct net_device *dev);\nvoid free_netdev(struct net_device *dev);\nvoid netdev_freemem(struct net_device *dev);\nint init_dummy_netdev(struct net_device *dev);\n\nstruct net_device *netdev_get_xmit_slave(struct net_device *dev,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t bool all_slaves);\nstruct net_device *netdev_sk_get_lowest_dev(struct net_device *dev,\n\t\t\t\t\t    struct sock *sk);\nstruct net_device *dev_get_by_index(struct net *net, int ifindex);\nstruct net_device *__dev_get_by_index(struct net *net, int ifindex);\nstruct net_device *dev_get_by_index_rcu(struct net *net, int ifindex);\nstruct net_device *dev_get_by_napi_id(unsigned int napi_id);\nint netdev_get_name(struct net *net, char *name, int ifindex);\nint dev_restart(struct net_device *dev);\nint skb_gro_receive(struct sk_buff *p, struct sk_buff *skb);\nint skb_gro_receive_list(struct sk_buff *p, struct sk_buff *skb);\n\nstatic inline unsigned int skb_gro_offset(const struct sk_buff *skb)\n{\n\treturn NAPI_GRO_CB(skb)->data_offset;\n}\n\nstatic inline unsigned int skb_gro_len(const struct sk_buff *skb)\n{\n\treturn skb->len - NAPI_GRO_CB(skb)->data_offset;\n}\n\nstatic inline void skb_gro_pull(struct sk_buff *skb, unsigned int len)\n{\n\tNAPI_GRO_CB(skb)->data_offset += len;\n}\n\nstatic inline void *skb_gro_header_fast(struct sk_buff *skb,\n\t\t\t\t\tunsigned int offset)\n{\n\treturn NAPI_GRO_CB(skb)->frag0 + offset;\n}\n\nstatic inline int skb_gro_header_hard(struct sk_buff *skb, unsigned int hlen)\n{\n\treturn NAPI_GRO_CB(skb)->frag0_len < hlen;\n}\n\nstatic inline void skb_gro_frag0_invalidate(struct sk_buff *skb)\n{\n\tNAPI_GRO_CB(skb)->frag0 = NULL;\n\tNAPI_GRO_CB(skb)->frag0_len = 0;\n}\n\nstatic inline void *skb_gro_header_slow(struct sk_buff *skb, unsigned int hlen,\n\t\t\t\t\tunsigned int offset)\n{\n\tif (!pskb_may_pull(skb, hlen))\n\t\treturn NULL;\n\n\tskb_gro_frag0_invalidate(skb);\n\treturn skb->data + offset;\n}\n\nstatic inline void *skb_gro_network_header(struct sk_buff *skb)\n{\n\treturn (NAPI_GRO_CB(skb)->frag0 ?: skb->data) +\n\t       skb_network_offset(skb);\n}\n\nstatic inline void skb_gro_postpull_rcsum(struct sk_buff *skb,\n\t\t\t\t\tconst void *start, unsigned int len)\n{\n\tif (NAPI_GRO_CB(skb)->csum_valid)\n\t\tNAPI_GRO_CB(skb)->csum = csum_sub(NAPI_GRO_CB(skb)->csum,\n\t\t\t\t\t\t  csum_partial(start, len, 0));\n}\n\n/* GRO checksum functions. These are logical equivalents of the normal\n * checksum functions (in skbuff.h) except that they operate on the GRO\n * offsets and fields in sk_buff.\n */\n\n__sum16 __skb_gro_checksum_complete(struct sk_buff *skb);\n\nstatic inline bool skb_at_gro_remcsum_start(struct sk_buff *skb)\n{\n\treturn (NAPI_GRO_CB(skb)->gro_remcsum_start == skb_gro_offset(skb));\n}\n\nstatic inline bool __skb_gro_checksum_validate_needed(struct sk_buff *skb,\n\t\t\t\t\t\t      bool zero_okay,\n\t\t\t\t\t\t      __sum16 check)\n{\n\treturn ((skb->ip_summed != CHECKSUM_PARTIAL ||\n\t\tskb_checksum_start_offset(skb) <\n\t\t skb_gro_offset(skb)) &&\n\t\t!skb_at_gro_remcsum_start(skb) &&\n\t\tNAPI_GRO_CB(skb)->csum_cnt == 0 &&\n\t\t(!zero_okay || check));\n}\n\nstatic inline __sum16 __skb_gro_checksum_validate_complete(struct sk_buff *skb,\n\t\t\t\t\t\t\t   __wsum psum)\n{\n\tif (NAPI_GRO_CB(skb)->csum_valid &&\n\t    !csum_fold(csum_add(psum, NAPI_GRO_CB(skb)->csum)))\n\t\treturn 0;\n\n\tNAPI_GRO_CB(skb)->csum = psum;\n\n\treturn __skb_gro_checksum_complete(skb);\n}\n\nstatic inline void skb_gro_incr_csum_unnecessary(struct sk_buff *skb)\n{\n\tif (NAPI_GRO_CB(skb)->csum_cnt > 0) {\n\t\t/* Consume a checksum from CHECKSUM_UNNECESSARY */\n\t\tNAPI_GRO_CB(skb)->csum_cnt--;\n\t} else {\n\t\t/* Update skb for CHECKSUM_UNNECESSARY and csum_level when we\n\t\t * verified a new top level checksum or an encapsulated one\n\t\t * during GRO. This saves work if we fallback to normal path.\n\t\t */\n\t\t__skb_incr_checksum_unnecessary(skb);\n\t}\n}\n\n#define __skb_gro_checksum_validate(skb, proto, zero_okay, check,\t\\\n\t\t\t\t    compute_pseudo)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__sum16 __ret = 0;\t\t\t\t\t\t\\\n\tif (__skb_gro_checksum_validate_needed(skb, zero_okay, check))\t\\\n\t\t__ret = __skb_gro_checksum_validate_complete(skb,\t\\\n\t\t\t\tcompute_pseudo(skb, proto));\t\t\\\n\tif (!__ret)\t\t\t\t\t\t\t\\\n\t\tskb_gro_incr_csum_unnecessary(skb);\t\t\t\\\n\t__ret;\t\t\t\t\t\t\t\t\\\n})\n\n#define skb_gro_checksum_validate(skb, proto, compute_pseudo)\t\t\\\n\t__skb_gro_checksum_validate(skb, proto, false, 0, compute_pseudo)\n\n#define skb_gro_checksum_validate_zero_check(skb, proto, check,\t\t\\\n\t\t\t\t\t     compute_pseudo)\t\t\\\n\t__skb_gro_checksum_validate(skb, proto, true, check, compute_pseudo)\n\n#define skb_gro_checksum_simple_validate(skb)\t\t\t\t\\\n\t__skb_gro_checksum_validate(skb, 0, false, 0, null_compute_pseudo)\n\nstatic inline bool __skb_gro_checksum_convert_check(struct sk_buff *skb)\n{\n\treturn (NAPI_GRO_CB(skb)->csum_cnt == 0 &&\n\t\t!NAPI_GRO_CB(skb)->csum_valid);\n}\n\nstatic inline void __skb_gro_checksum_convert(struct sk_buff *skb,\n\t\t\t\t\t      __wsum pseudo)\n{\n\tNAPI_GRO_CB(skb)->csum = ~pseudo;\n\tNAPI_GRO_CB(skb)->csum_valid = 1;\n}\n\n#define skb_gro_checksum_try_convert(skb, proto, compute_pseudo)\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (__skb_gro_checksum_convert_check(skb))\t\t\t\\\n\t\t__skb_gro_checksum_convert(skb, \t\t\t\\\n\t\t\t\t\t   compute_pseudo(skb, proto));\t\\\n} while (0)\n\nstruct gro_remcsum {\n\tint offset;\n\t__wsum delta;\n};\n\nstatic inline void skb_gro_remcsum_init(struct gro_remcsum *grc)\n{\n\tgrc->offset = 0;\n\tgrc->delta = 0;\n}\n\nstatic inline void *skb_gro_remcsum_process(struct sk_buff *skb, void *ptr,\n\t\t\t\t\t    unsigned int off, size_t hdrlen,\n\t\t\t\t\t    int start, int offset,\n\t\t\t\t\t    struct gro_remcsum *grc,\n\t\t\t\t\t    bool nopartial)\n{\n\t__wsum delta;\n\tsize_t plen = hdrlen + max_t(size_t, offset + sizeof(u16), start);\n\n\tBUG_ON(!NAPI_GRO_CB(skb)->csum_valid);\n\n\tif (!nopartial) {\n\t\tNAPI_GRO_CB(skb)->gro_remcsum_start = off + hdrlen + start;\n\t\treturn ptr;\n\t}\n\n\tptr = skb_gro_header_fast(skb, off);\n\tif (skb_gro_header_hard(skb, off + plen)) {\n\t\tptr = skb_gro_header_slow(skb, off + plen, off);\n\t\tif (!ptr)\n\t\t\treturn NULL;\n\t}\n\n\tdelta = remcsum_adjust(ptr + hdrlen, NAPI_GRO_CB(skb)->csum,\n\t\t\t       start, offset);\n\n\t/* Adjust skb->csum since we changed the packet */\n\tNAPI_GRO_CB(skb)->csum = csum_add(NAPI_GRO_CB(skb)->csum, delta);\n\n\tgrc->offset = off + hdrlen + offset;\n\tgrc->delta = delta;\n\n\treturn ptr;\n}\n\nstatic inline void skb_gro_remcsum_cleanup(struct sk_buff *skb,\n\t\t\t\t\t   struct gro_remcsum *grc)\n{\n\tvoid *ptr;\n\tsize_t plen = grc->offset + sizeof(u16);\n\n\tif (!grc->delta)\n\t\treturn;\n\n\tptr = skb_gro_header_fast(skb, grc->offset);\n\tif (skb_gro_header_hard(skb, grc->offset + sizeof(u16))) {\n\t\tptr = skb_gro_header_slow(skb, plen, grc->offset);\n\t\tif (!ptr)\n\t\t\treturn;\n\t}\n\n\tremcsum_unadjust((__sum16 *)ptr, grc->delta);\n}\n\n#ifdef CONFIG_XFRM_OFFLOAD\nstatic inline void skb_gro_flush_final(struct sk_buff *skb, struct sk_buff *pp, int flush)\n{\n\tif (PTR_ERR(pp) != -EINPROGRESS)\n\t\tNAPI_GRO_CB(skb)->flush |= flush;\n}\nstatic inline void skb_gro_flush_final_remcsum(struct sk_buff *skb,\n\t\t\t\t\t       struct sk_buff *pp,\n\t\t\t\t\t       int flush,\n\t\t\t\t\t       struct gro_remcsum *grc)\n{\n\tif (PTR_ERR(pp) != -EINPROGRESS) {\n\t\tNAPI_GRO_CB(skb)->flush |= flush;\n\t\tskb_gro_remcsum_cleanup(skb, grc);\n\t\tskb->remcsum_offload = 0;\n\t}\n}\n#else\nstatic inline void skb_gro_flush_final(struct sk_buff *skb, struct sk_buff *pp, int flush)\n{\n\tNAPI_GRO_CB(skb)->flush |= flush;\n}\nstatic inline void skb_gro_flush_final_remcsum(struct sk_buff *skb,\n\t\t\t\t\t       struct sk_buff *pp,\n\t\t\t\t\t       int flush,\n\t\t\t\t\t       struct gro_remcsum *grc)\n{\n\tNAPI_GRO_CB(skb)->flush |= flush;\n\tskb_gro_remcsum_cleanup(skb, grc);\n\tskb->remcsum_offload = 0;\n}\n#endif\n\nstatic inline int dev_hard_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t  unsigned short type,\n\t\t\t\t  const void *daddr, const void *saddr,\n\t\t\t\t  unsigned int len)\n{\n\tif (!dev->header_ops || !dev->header_ops->create)\n\t\treturn 0;\n\n\treturn dev->header_ops->create(skb, dev, type, daddr, saddr, len);\n}\n\nstatic inline int dev_parse_header(const struct sk_buff *skb,\n\t\t\t\t   unsigned char *haddr)\n{\n\tconst struct net_device *dev = skb->dev;\n\n\tif (!dev->header_ops || !dev->header_ops->parse)\n\t\treturn 0;\n\treturn dev->header_ops->parse(skb, haddr);\n}\n\nstatic inline __be16 dev_parse_header_protocol(const struct sk_buff *skb)\n{\n\tconst struct net_device *dev = skb->dev;\n\n\tif (!dev->header_ops || !dev->header_ops->parse_protocol)\n\t\treturn 0;\n\treturn dev->header_ops->parse_protocol(skb);\n}\n\n/* ll_header must have at least hard_header_len allocated */\nstatic inline bool dev_validate_header(const struct net_device *dev,\n\t\t\t\t       char *ll_header, int len)\n{\n\tif (likely(len >= dev->hard_header_len))\n\t\treturn true;\n\tif (len < dev->min_header_len)\n\t\treturn false;\n\n\tif (capable(CAP_SYS_RAWIO)) {\n\t\tmemset(ll_header + len, 0, dev->hard_header_len - len);\n\t\treturn true;\n\t}\n\n\tif (dev->header_ops && dev->header_ops->validate)\n\t\treturn dev->header_ops->validate(ll_header, len);\n\n\treturn false;\n}\n\nstatic inline bool dev_has_header(const struct net_device *dev)\n{\n\treturn dev->header_ops && dev->header_ops->create;\n}\n\ntypedef int gifconf_func_t(struct net_device * dev, char __user * bufptr,\n\t\t\t   int len, int size);\nint register_gifconf(unsigned int family, gifconf_func_t *gifconf);\nstatic inline int unregister_gifconf(unsigned int family)\n{\n\treturn register_gifconf(family, NULL);\n}\n\n#ifdef CONFIG_NET_FLOW_LIMIT\n#define FLOW_LIMIT_HISTORY\t(1 << 7)  /* must be ^2 and !overflow buckets */\nstruct sd_flow_limit {\n\tu64\t\t\tcount;\n\tunsigned int\t\tnum_buckets;\n\tunsigned int\t\thistory_head;\n\tu16\t\t\thistory[FLOW_LIMIT_HISTORY];\n\tu8\t\t\tbuckets[];\n};\n\nextern int netdev_flow_limit_table_len;\n#endif /* CONFIG_NET_FLOW_LIMIT */\n\n/*\n * Incoming packets are placed on per-CPU queues\n */\nstruct softnet_data {\n\tstruct list_head\tpoll_list;\n\tstruct sk_buff_head\tprocess_queue;\n\n\t/* stats */\n\tunsigned int\t\tprocessed;\n\tunsigned int\t\ttime_squeeze;\n\tunsigned int\t\treceived_rps;\n#ifdef CONFIG_RPS\n\tstruct softnet_data\t*rps_ipi_list;\n#endif\n#ifdef CONFIG_NET_FLOW_LIMIT\n\tstruct sd_flow_limit __rcu *flow_limit;\n#endif\n\tstruct Qdisc\t\t*output_queue;\n\tstruct Qdisc\t\t**output_queue_tailp;\n\tstruct sk_buff\t\t*completion_queue;\n#ifdef CONFIG_XFRM_OFFLOAD\n\tstruct sk_buff_head\txfrm_backlog;\n#endif\n\t/* written and read only by owning cpu: */\n\tstruct {\n\t\tu16 recursion;\n\t\tu8  more;\n\t} xmit;\n#ifdef CONFIG_RPS\n\t/* input_queue_head should be written by cpu owning this struct,\n\t * and only read by other cpus. Worth using a cache line.\n\t */\n\tunsigned int\t\tinput_queue_head ____cacheline_aligned_in_smp;\n\n\t/* Elements below can be accessed between CPUs for RPS/RFS */\n\tcall_single_data_t\tcsd ____cacheline_aligned_in_smp;\n\tstruct softnet_data\t*rps_ipi_next;\n\tunsigned int\t\tcpu;\n\tunsigned int\t\tinput_queue_tail;\n#endif\n\tunsigned int\t\tdropped;\n\tstruct sk_buff_head\tinput_pkt_queue;\n\tstruct napi_struct\tbacklog;\n\n};\n\nstatic inline void input_queue_head_incr(struct softnet_data *sd)\n{\n#ifdef CONFIG_RPS\n\tsd->input_queue_head++;\n#endif\n}\n\nstatic inline void input_queue_tail_incr_save(struct softnet_data *sd,\n\t\t\t\t\t      unsigned int *qtail)\n{\n#ifdef CONFIG_RPS\n\t*qtail = ++sd->input_queue_tail;\n#endif\n}\n\nDECLARE_PER_CPU_ALIGNED(struct softnet_data, softnet_data);\n\nstatic inline int dev_recursion_level(void)\n{\n\treturn this_cpu_read(softnet_data.xmit.recursion);\n}\n\n#define XMIT_RECURSION_LIMIT\t8\nstatic inline bool dev_xmit_recursion(void)\n{\n\treturn unlikely(__this_cpu_read(softnet_data.xmit.recursion) >\n\t\t\tXMIT_RECURSION_LIMIT);\n}\n\nstatic inline void dev_xmit_recursion_inc(void)\n{\n\t__this_cpu_inc(softnet_data.xmit.recursion);\n}\n\nstatic inline void dev_xmit_recursion_dec(void)\n{\n\t__this_cpu_dec(softnet_data.xmit.recursion);\n}\n\nvoid __netif_schedule(struct Qdisc *q);\nvoid netif_schedule_queue(struct netdev_queue *txq);\n\nstatic inline void netif_tx_schedule_all(struct net_device *dev)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < dev->num_tx_queues; i++)\n\t\tnetif_schedule_queue(netdev_get_tx_queue(dev, i));\n}\n\nstatic __always_inline void netif_tx_start_queue(struct netdev_queue *dev_queue)\n{\n\tclear_bit(__QUEUE_STATE_DRV_XOFF, &dev_queue->state);\n}\n\n/**\n *\tnetif_start_queue - allow transmit\n *\t@dev: network device\n *\n *\tAllow upper layers to call the device hard_start_xmit routine.\n */\nstatic inline void netif_start_queue(struct net_device *dev)\n{\n\tnetif_tx_start_queue(netdev_get_tx_queue(dev, 0));\n}\n\nstatic inline void netif_tx_start_all_queues(struct net_device *dev)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < dev->num_tx_queues; i++) {\n\t\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, i);\n\t\tnetif_tx_start_queue(txq);\n\t}\n}\n\nvoid netif_tx_wake_queue(struct netdev_queue *dev_queue);\n\n/**\n *\tnetif_wake_queue - restart transmit\n *\t@dev: network device\n *\n *\tAllow upper layers to call the device hard_start_xmit routine.\n *\tUsed for flow control when transmit resources are available.\n */\nstatic inline void netif_wake_queue(struct net_device *dev)\n{\n\tnetif_tx_wake_queue(netdev_get_tx_queue(dev, 0));\n}\n\nstatic inline void netif_tx_wake_all_queues(struct net_device *dev)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < dev->num_tx_queues; i++) {\n\t\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, i);\n\t\tnetif_tx_wake_queue(txq);\n\t}\n}\n\nstatic __always_inline void netif_tx_stop_queue(struct netdev_queue *dev_queue)\n{\n\tset_bit(__QUEUE_STATE_DRV_XOFF, &dev_queue->state);\n}\n\n/**\n *\tnetif_stop_queue - stop transmitted packets\n *\t@dev: network device\n *\n *\tStop upper layers calling the device hard_start_xmit routine.\n *\tUsed for flow control when transmit resources are unavailable.\n */\nstatic inline void netif_stop_queue(struct net_device *dev)\n{\n\tnetif_tx_stop_queue(netdev_get_tx_queue(dev, 0));\n}\n\nvoid netif_tx_stop_all_queues(struct net_device *dev);\n\nstatic inline bool netif_tx_queue_stopped(const struct netdev_queue *dev_queue)\n{\n\treturn test_bit(__QUEUE_STATE_DRV_XOFF, &dev_queue->state);\n}\n\n/**\n *\tnetif_queue_stopped - test if transmit queue is flowblocked\n *\t@dev: network device\n *\n *\tTest if transmit queue on device is currently unable to send.\n */\nstatic inline bool netif_queue_stopped(const struct net_device *dev)\n{\n\treturn netif_tx_queue_stopped(netdev_get_tx_queue(dev, 0));\n}\n\nstatic inline bool netif_xmit_stopped(const struct netdev_queue *dev_queue)\n{\n\treturn dev_queue->state & QUEUE_STATE_ANY_XOFF;\n}\n\nstatic inline bool\nnetif_xmit_frozen_or_stopped(const struct netdev_queue *dev_queue)\n{\n\treturn dev_queue->state & QUEUE_STATE_ANY_XOFF_OR_FROZEN;\n}\n\nstatic inline bool\nnetif_xmit_frozen_or_drv_stopped(const struct netdev_queue *dev_queue)\n{\n\treturn dev_queue->state & QUEUE_STATE_DRV_XOFF_OR_FROZEN;\n}\n\n/**\n *\tnetdev_txq_bql_enqueue_prefetchw - prefetch bql data for write\n *\t@dev_queue: pointer to transmit queue\n *\n * BQL enabled drivers might use this helper in their ndo_start_xmit(),\n * to give appropriate hint to the CPU.\n */\nstatic inline void netdev_txq_bql_enqueue_prefetchw(struct netdev_queue *dev_queue)\n{\n#ifdef CONFIG_BQL\n\tprefetchw(&dev_queue->dql.num_queued);\n#endif\n}\n\n/**\n *\tnetdev_txq_bql_complete_prefetchw - prefetch bql data for write\n *\t@dev_queue: pointer to transmit queue\n *\n * BQL enabled drivers might use this helper in their TX completion path,\n * to give appropriate hint to the CPU.\n */\nstatic inline void netdev_txq_bql_complete_prefetchw(struct netdev_queue *dev_queue)\n{\n#ifdef CONFIG_BQL\n\tprefetchw(&dev_queue->dql.limit);\n#endif\n}\n\nstatic inline void netdev_tx_sent_queue(struct netdev_queue *dev_queue,\n\t\t\t\t\tunsigned int bytes)\n{\n#ifdef CONFIG_BQL\n\tdql_queued(&dev_queue->dql, bytes);\n\n\tif (likely(dql_avail(&dev_queue->dql) >= 0))\n\t\treturn;\n\n\tset_bit(__QUEUE_STATE_STACK_XOFF, &dev_queue->state);\n\n\t/*\n\t * The XOFF flag must be set before checking the dql_avail below,\n\t * because in netdev_tx_completed_queue we update the dql_completed\n\t * before checking the XOFF flag.\n\t */\n\tsmp_mb();\n\n\t/* check again in case another CPU has just made room avail */\n\tif (unlikely(dql_avail(&dev_queue->dql) >= 0))\n\t\tclear_bit(__QUEUE_STATE_STACK_XOFF, &dev_queue->state);\n#endif\n}\n\n/* Variant of netdev_tx_sent_queue() for drivers that are aware\n * that they should not test BQL status themselves.\n * We do want to change __QUEUE_STATE_STACK_XOFF only for the last\n * skb of a batch.\n * Returns true if the doorbell must be used to kick the NIC.\n */\nstatic inline bool __netdev_tx_sent_queue(struct netdev_queue *dev_queue,\n\t\t\t\t\t  unsigned int bytes,\n\t\t\t\t\t  bool xmit_more)\n{\n\tif (xmit_more) {\n#ifdef CONFIG_BQL\n\t\tdql_queued(&dev_queue->dql, bytes);\n#endif\n\t\treturn netif_tx_queue_stopped(dev_queue);\n\t}\n\tnetdev_tx_sent_queue(dev_queue, bytes);\n\treturn true;\n}\n\n/**\n * \tnetdev_sent_queue - report the number of bytes queued to hardware\n * \t@dev: network device\n * \t@bytes: number of bytes queued to the hardware device queue\n *\n * \tReport the number of bytes queued for sending/completion to the network\n * \tdevice hardware queue. @bytes should be a good approximation and should\n * \texactly match netdev_completed_queue() @bytes\n */\nstatic inline void netdev_sent_queue(struct net_device *dev, unsigned int bytes)\n{\n\tnetdev_tx_sent_queue(netdev_get_tx_queue(dev, 0), bytes);\n}\n\nstatic inline bool __netdev_sent_queue(struct net_device *dev,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       bool xmit_more)\n{\n\treturn __netdev_tx_sent_queue(netdev_get_tx_queue(dev, 0), bytes,\n\t\t\t\t      xmit_more);\n}\n\nstatic inline void netdev_tx_completed_queue(struct netdev_queue *dev_queue,\n\t\t\t\t\t     unsigned int pkts, unsigned int bytes)\n{\n#ifdef CONFIG_BQL\n\tif (unlikely(!bytes))\n\t\treturn;\n\n\tdql_completed(&dev_queue->dql, bytes);\n\n\t/*\n\t * Without the memory barrier there is a small possiblity that\n\t * netdev_tx_sent_queue will miss the update and cause the queue to\n\t * be stopped forever\n\t */\n\tsmp_mb();\n\n\tif (unlikely(dql_avail(&dev_queue->dql) < 0))\n\t\treturn;\n\n\tif (test_and_clear_bit(__QUEUE_STATE_STACK_XOFF, &dev_queue->state))\n\t\tnetif_schedule_queue(dev_queue);\n#endif\n}\n\n/**\n * \tnetdev_completed_queue - report bytes and packets completed by device\n * \t@dev: network device\n * \t@pkts: actual number of packets sent over the medium\n * \t@bytes: actual number of bytes sent over the medium\n *\n * \tReport the number of bytes and packets transmitted by the network device\n * \thardware queue over the physical medium, @bytes must exactly match the\n * \t@bytes amount passed to netdev_sent_queue()\n */\nstatic inline void netdev_completed_queue(struct net_device *dev,\n\t\t\t\t\t  unsigned int pkts, unsigned int bytes)\n{\n\tnetdev_tx_completed_queue(netdev_get_tx_queue(dev, 0), pkts, bytes);\n}\n\nstatic inline void netdev_tx_reset_queue(struct netdev_queue *q)\n{\n#ifdef CONFIG_BQL\n\tclear_bit(__QUEUE_STATE_STACK_XOFF, &q->state);\n\tdql_reset(&q->dql);\n#endif\n}\n\n/**\n * \tnetdev_reset_queue - reset the packets and bytes count of a network device\n * \t@dev_queue: network device\n *\n * \tReset the bytes and packet count of a network device and clear the\n * \tsoftware flow control OFF bit for this network device\n */\nstatic inline void netdev_reset_queue(struct net_device *dev_queue)\n{\n\tnetdev_tx_reset_queue(netdev_get_tx_queue(dev_queue, 0));\n}\n\n/**\n * \tnetdev_cap_txqueue - check if selected tx queue exceeds device queues\n * \t@dev: network device\n * \t@queue_index: given tx queue index\n *\n * \tReturns 0 if given tx queue index >= number of device tx queues,\n * \totherwise returns the originally passed tx queue index.\n */\nstatic inline u16 netdev_cap_txqueue(struct net_device *dev, u16 queue_index)\n{\n\tif (unlikely(queue_index >= dev->real_num_tx_queues)) {\n\t\tnet_warn_ratelimited(\"%s selects TX queue %d, but real number of TX queues is %d\\n\",\n\t\t\t\t     dev->name, queue_index,\n\t\t\t\t     dev->real_num_tx_queues);\n\t\treturn 0;\n\t}\n\n\treturn queue_index;\n}\n\n/**\n *\tnetif_running - test if up\n *\t@dev: network device\n *\n *\tTest if the device has been brought up.\n */\nstatic inline bool netif_running(const struct net_device *dev)\n{\n\treturn test_bit(__LINK_STATE_START, &dev->state);\n}\n\n/*\n * Routines to manage the subqueues on a device.  We only need start,\n * stop, and a check if it's stopped.  All other device management is\n * done at the overall netdevice level.\n * Also test the device if we're multiqueue.\n */\n\n/**\n *\tnetif_start_subqueue - allow sending packets on subqueue\n *\t@dev: network device\n *\t@queue_index: sub queue index\n *\n * Start individual transmit queue of a device with multiple transmit queues.\n */\nstatic inline void netif_start_subqueue(struct net_device *dev, u16 queue_index)\n{\n\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, queue_index);\n\n\tnetif_tx_start_queue(txq);\n}\n\n/**\n *\tnetif_stop_subqueue - stop sending packets on subqueue\n *\t@dev: network device\n *\t@queue_index: sub queue index\n *\n * Stop individual transmit queue of a device with multiple transmit queues.\n */\nstatic inline void netif_stop_subqueue(struct net_device *dev, u16 queue_index)\n{\n\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, queue_index);\n\tnetif_tx_stop_queue(txq);\n}\n\n/**\n *\t__netif_subqueue_stopped - test status of subqueue\n *\t@dev: network device\n *\t@queue_index: sub queue index\n *\n * Check individual transmit queue of a device with multiple transmit queues.\n */\nstatic inline bool __netif_subqueue_stopped(const struct net_device *dev,\n\t\t\t\t\t    u16 queue_index)\n{\n\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, queue_index);\n\n\treturn netif_tx_queue_stopped(txq);\n}\n\n/**\n *\tnetif_subqueue_stopped - test status of subqueue\n *\t@dev: network device\n *\t@skb: sub queue buffer pointer\n *\n * Check individual transmit queue of a device with multiple transmit queues.\n */\nstatic inline bool netif_subqueue_stopped(const struct net_device *dev,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\treturn __netif_subqueue_stopped(dev, skb_get_queue_mapping(skb));\n}\n\n/**\n *\tnetif_wake_subqueue - allow sending packets on subqueue\n *\t@dev: network device\n *\t@queue_index: sub queue index\n *\n * Resume individual transmit queue of a device with multiple transmit queues.\n */\nstatic inline void netif_wake_subqueue(struct net_device *dev, u16 queue_index)\n{\n\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, queue_index);\n\n\tnetif_tx_wake_queue(txq);\n}\n\n#ifdef CONFIG_XPS\nint netif_set_xps_queue(struct net_device *dev, const struct cpumask *mask,\n\t\t\tu16 index);\nint __netif_set_xps_queue(struct net_device *dev, const unsigned long *mask,\n\t\t\t  u16 index, bool is_rxqs_map);\n\n/**\n *\tnetif_attr_test_mask - Test a CPU or Rx queue set in a mask\n *\t@j: CPU/Rx queue index\n *\t@mask: bitmask of all cpus/rx queues\n *\t@nr_bits: number of bits in the bitmask\n *\n * Test if a CPU or Rx queue index is set in a mask of all CPU/Rx queues.\n */\nstatic inline bool netif_attr_test_mask(unsigned long j,\n\t\t\t\t\tconst unsigned long *mask,\n\t\t\t\t\tunsigned int nr_bits)\n{\n\tcpu_max_bits_warn(j, nr_bits);\n\treturn test_bit(j, mask);\n}\n\n/**\n *\tnetif_attr_test_online - Test for online CPU/Rx queue\n *\t@j: CPU/Rx queue index\n *\t@online_mask: bitmask for CPUs/Rx queues that are online\n *\t@nr_bits: number of bits in the bitmask\n *\n * Returns true if a CPU/Rx queue is online.\n */\nstatic inline bool netif_attr_test_online(unsigned long j,\n\t\t\t\t\t  const unsigned long *online_mask,\n\t\t\t\t\t  unsigned int nr_bits)\n{\n\tcpu_max_bits_warn(j, nr_bits);\n\n\tif (online_mask)\n\t\treturn test_bit(j, online_mask);\n\n\treturn (j < nr_bits);\n}\n\n/**\n *\tnetif_attrmask_next - get the next CPU/Rx queue in a cpu/Rx queues mask\n *\t@n: CPU/Rx queue index\n *\t@srcp: the cpumask/Rx queue mask pointer\n *\t@nr_bits: number of bits in the bitmask\n *\n * Returns >= nr_bits if no further CPUs/Rx queues set.\n */\nstatic inline unsigned int netif_attrmask_next(int n, const unsigned long *srcp,\n\t\t\t\t\t       unsigned int nr_bits)\n{\n\t/* -1 is a legal arg here. */\n\tif (n != -1)\n\t\tcpu_max_bits_warn(n, nr_bits);\n\n\tif (srcp)\n\t\treturn find_next_bit(srcp, nr_bits, n + 1);\n\n\treturn n + 1;\n}\n\n/**\n *\tnetif_attrmask_next_and - get the next CPU/Rx queue in \\*src1p & \\*src2p\n *\t@n: CPU/Rx queue index\n *\t@src1p: the first CPUs/Rx queues mask pointer\n *\t@src2p: the second CPUs/Rx queues mask pointer\n *\t@nr_bits: number of bits in the bitmask\n *\n * Returns >= nr_bits if no further CPUs/Rx queues set in both.\n */\nstatic inline int netif_attrmask_next_and(int n, const unsigned long *src1p,\n\t\t\t\t\t  const unsigned long *src2p,\n\t\t\t\t\t  unsigned int nr_bits)\n{\n\t/* -1 is a legal arg here. */\n\tif (n != -1)\n\t\tcpu_max_bits_warn(n, nr_bits);\n\n\tif (src1p && src2p)\n\t\treturn find_next_and_bit(src1p, src2p, nr_bits, n + 1);\n\telse if (src1p)\n\t\treturn find_next_bit(src1p, nr_bits, n + 1);\n\telse if (src2p)\n\t\treturn find_next_bit(src2p, nr_bits, n + 1);\n\n\treturn n + 1;\n}\n#else\nstatic inline int netif_set_xps_queue(struct net_device *dev,\n\t\t\t\t      const struct cpumask *mask,\n\t\t\t\t      u16 index)\n{\n\treturn 0;\n}\n\nstatic inline int __netif_set_xps_queue(struct net_device *dev,\n\t\t\t\t\tconst unsigned long *mask,\n\t\t\t\t\tu16 index, bool is_rxqs_map)\n{\n\treturn 0;\n}\n#endif\n\n/**\n *\tnetif_is_multiqueue - test if device has multiple transmit queues\n *\t@dev: network device\n *\n * Check if device has multiple transmit queues\n */\nstatic inline bool netif_is_multiqueue(const struct net_device *dev)\n{\n\treturn dev->num_tx_queues > 1;\n}\n\nint netif_set_real_num_tx_queues(struct net_device *dev, unsigned int txq);\n\n#ifdef CONFIG_SYSFS\nint netif_set_real_num_rx_queues(struct net_device *dev, unsigned int rxq);\n#else\nstatic inline int netif_set_real_num_rx_queues(struct net_device *dev,\n\t\t\t\t\t\tunsigned int rxqs)\n{\n\tdev->real_num_rx_queues = rxqs;\n\treturn 0;\n}\n#endif\n\nstatic inline struct netdev_rx_queue *\n__netif_get_rx_queue(struct net_device *dev, unsigned int rxq)\n{\n\treturn dev->_rx + rxq;\n}\n\n#ifdef CONFIG_SYSFS\nstatic inline unsigned int get_netdev_rx_queue_index(\n\t\tstruct netdev_rx_queue *queue)\n{\n\tstruct net_device *dev = queue->dev;\n\tint index = queue - dev->_rx;\n\n\tBUG_ON(index >= dev->num_rx_queues);\n\treturn index;\n}\n#endif\n\n#define DEFAULT_MAX_NUM_RSS_QUEUES\t(8)\nint netif_get_num_default_rss_queues(void);\n\nenum skb_free_reason {\n\tSKB_REASON_CONSUMED,\n\tSKB_REASON_DROPPED,\n};\n\nvoid __dev_kfree_skb_irq(struct sk_buff *skb, enum skb_free_reason reason);\nvoid __dev_kfree_skb_any(struct sk_buff *skb, enum skb_free_reason reason);\n\n/*\n * It is not allowed to call kfree_skb() or consume_skb() from hardware\n * interrupt context or with hardware interrupts being disabled.\n * (in_irq() || irqs_disabled())\n *\n * We provide four helpers that can be used in following contexts :\n *\n * dev_kfree_skb_irq(skb) when caller drops a packet from irq context,\n *  replacing kfree_skb(skb)\n *\n * dev_consume_skb_irq(skb) when caller consumes a packet from irq context.\n *  Typically used in place of consume_skb(skb) in TX completion path\n *\n * dev_kfree_skb_any(skb) when caller doesn't know its current irq context,\n *  replacing kfree_skb(skb)\n *\n * dev_consume_skb_any(skb) when caller doesn't know its current irq context,\n *  and consumed a packet. Used in place of consume_skb(skb)\n */\nstatic inline void dev_kfree_skb_irq(struct sk_buff *skb)\n{\n\t__dev_kfree_skb_irq(skb, SKB_REASON_DROPPED);\n}\n\nstatic inline void dev_consume_skb_irq(struct sk_buff *skb)\n{\n\t__dev_kfree_skb_irq(skb, SKB_REASON_CONSUMED);\n}\n\nstatic inline void dev_kfree_skb_any(struct sk_buff *skb)\n{\n\t__dev_kfree_skb_any(skb, SKB_REASON_DROPPED);\n}\n\nstatic inline void dev_consume_skb_any(struct sk_buff *skb)\n{\n\t__dev_kfree_skb_any(skb, SKB_REASON_CONSUMED);\n}\n\nvoid generic_xdp_tx(struct sk_buff *skb, struct bpf_prog *xdp_prog);\nint do_xdp_generic(struct bpf_prog *xdp_prog, struct sk_buff *skb);\nint netif_rx(struct sk_buff *skb);\nint netif_rx_ni(struct sk_buff *skb);\nint netif_rx_any_context(struct sk_buff *skb);\nint netif_receive_skb(struct sk_buff *skb);\nint netif_receive_skb_core(struct sk_buff *skb);\nvoid netif_receive_skb_list(struct list_head *head);\ngro_result_t napi_gro_receive(struct napi_struct *napi, struct sk_buff *skb);\nvoid napi_gro_flush(struct napi_struct *napi, bool flush_old);\nstruct sk_buff *napi_get_frags(struct napi_struct *napi);\ngro_result_t napi_gro_frags(struct napi_struct *napi);\nstruct packet_offload *gro_find_receive_by_type(__be16 type);\nstruct packet_offload *gro_find_complete_by_type(__be16 type);\n\nstatic inline void napi_free_frags(struct napi_struct *napi)\n{\n\tkfree_skb(napi->skb);\n\tnapi->skb = NULL;\n}\n\nbool netdev_is_rx_handler_busy(struct net_device *dev);\nint netdev_rx_handler_register(struct net_device *dev,\n\t\t\t       rx_handler_func_t *rx_handler,\n\t\t\t       void *rx_handler_data);\nvoid netdev_rx_handler_unregister(struct net_device *dev);\n\nbool dev_valid_name(const char *name);\nint dev_ioctl(struct net *net, unsigned int cmd, struct ifreq *ifr,\n\t\tbool *need_copyout);\nint dev_ifconf(struct net *net, struct ifconf *, int);\nint dev_ethtool(struct net *net, struct ifreq *);\nunsigned int dev_get_flags(const struct net_device *);\nint __dev_change_flags(struct net_device *dev, unsigned int flags,\n\t\t       struct netlink_ext_ack *extack);\nint dev_change_flags(struct net_device *dev, unsigned int flags,\n\t\t     struct netlink_ext_ack *extack);\nvoid __dev_notify_flags(struct net_device *, unsigned int old_flags,\n\t\t\tunsigned int gchanges);\nint dev_change_name(struct net_device *, const char *);\nint dev_set_alias(struct net_device *, const char *, size_t);\nint dev_get_alias(const struct net_device *, char *, size_t);\nint dev_change_net_namespace(struct net_device *, struct net *, const char *);\nint __dev_set_mtu(struct net_device *, int);\nint dev_validate_mtu(struct net_device *dev, int mtu,\n\t\t     struct netlink_ext_ack *extack);\nint dev_set_mtu_ext(struct net_device *dev, int mtu,\n\t\t    struct netlink_ext_ack *extack);\nint dev_set_mtu(struct net_device *, int);\nint dev_change_tx_queue_len(struct net_device *, unsigned long);\nvoid dev_set_group(struct net_device *, int);\nint dev_pre_changeaddr_notify(struct net_device *dev, const char *addr,\n\t\t\t      struct netlink_ext_ack *extack);\nint dev_set_mac_address(struct net_device *dev, struct sockaddr *sa,\n\t\t\tstruct netlink_ext_ack *extack);\nint dev_set_mac_address_user(struct net_device *dev, struct sockaddr *sa,\n\t\t\t     struct netlink_ext_ack *extack);\nint dev_get_mac_address(struct sockaddr *sa, struct net *net, char *dev_name);\nint dev_change_carrier(struct net_device *, bool new_carrier);\nint dev_get_phys_port_id(struct net_device *dev,\n\t\t\t struct netdev_phys_item_id *ppid);\nint dev_get_phys_port_name(struct net_device *dev,\n\t\t\t   char *name, size_t len);\nint dev_get_port_parent_id(struct net_device *dev,\n\t\t\t   struct netdev_phys_item_id *ppid, bool recurse);\nbool netdev_port_same_parent_id(struct net_device *a, struct net_device *b);\nint dev_change_proto_down(struct net_device *dev, bool proto_down);\nint dev_change_proto_down_generic(struct net_device *dev, bool proto_down);\nvoid dev_change_proto_down_reason(struct net_device *dev, unsigned long mask,\n\t\t\t\t  u32 value);\nstruct sk_buff *validate_xmit_skb_list(struct sk_buff *skb, struct net_device *dev, bool *again);\nstruct sk_buff *dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t    struct netdev_queue *txq, int *ret);\n\ntypedef int (*bpf_op_t)(struct net_device *dev, struct netdev_bpf *bpf);\nint dev_change_xdp_fd(struct net_device *dev, struct netlink_ext_ack *extack,\n\t\t      int fd, int expected_fd, u32 flags);\nint bpf_xdp_link_attach(const union bpf_attr *attr, struct bpf_prog *prog);\nu32 dev_xdp_prog_id(struct net_device *dev, enum bpf_xdp_mode mode);\n\nint xdp_umem_query(struct net_device *dev, u16 queue_id);\n\nint __dev_forward_skb(struct net_device *dev, struct sk_buff *skb);\nint dev_forward_skb(struct net_device *dev, struct sk_buff *skb);\nint dev_forward_skb_nomtu(struct net_device *dev, struct sk_buff *skb);\nbool is_skb_forwardable(const struct net_device *dev,\n\t\t\tconst struct sk_buff *skb);\n\nstatic __always_inline bool __is_skb_forwardable(const struct net_device *dev,\n\t\t\t\t\t\t const struct sk_buff *skb,\n\t\t\t\t\t\t const bool check_mtu)\n{\n\tconst u32 vlan_hdr_len = 4; /* VLAN_HLEN */\n\tunsigned int len;\n\n\tif (!(dev->flags & IFF_UP))\n\t\treturn false;\n\n\tif (!check_mtu)\n\t\treturn true;\n\n\tlen = dev->mtu + dev->hard_header_len + vlan_hdr_len;\n\tif (skb->len <= len)\n\t\treturn true;\n\n\t/* if TSO is enabled, we don't care about the length as the packet\n\t * could be forwarded without being segmented before\n\t */\n\tif (skb_is_gso(skb))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic __always_inline int ____dev_forward_skb(struct net_device *dev,\n\t\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t\t       const bool check_mtu)\n{\n\tif (skb_orphan_frags(skb, GFP_ATOMIC) ||\n\t    unlikely(!__is_skb_forwardable(dev, skb, check_mtu))) {\n\t\tatomic_long_inc(&dev->rx_dropped);\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\tskb_scrub_packet(skb, true);\n\tskb->priority = 0;\n\treturn 0;\n}\n\nbool dev_nit_active(struct net_device *dev);\nvoid dev_queue_xmit_nit(struct sk_buff *skb, struct net_device *dev);\n\nextern int\t\tnetdev_budget;\nextern unsigned int\tnetdev_budget_usecs;\n\n/* Called by rtnetlink.c:rtnl_unlock() */\nvoid netdev_run_todo(void);\n\n/**\n *\tdev_put - release reference to device\n *\t@dev: network device\n *\n * Release reference to device to allow it to be freed.\n */\nstatic inline void dev_put(struct net_device *dev)\n{\n\tthis_cpu_dec(*dev->pcpu_refcnt);\n}\n\n/**\n *\tdev_hold - get reference to device\n *\t@dev: network device\n *\n * Hold reference to device to keep it from being freed.\n */\nstatic inline void dev_hold(struct net_device *dev)\n{\n\tthis_cpu_inc(*dev->pcpu_refcnt);\n}\n\n/* Carrier loss detection, dial on demand. The functions netif_carrier_on\n * and _off may be called from IRQ context, but it is caller\n * who is responsible for serialization of these calls.\n *\n * The name carrier is inappropriate, these functions should really be\n * called netif_lowerlayer_*() because they represent the state of any\n * kind of lower layer not just hardware media.\n */\n\nvoid linkwatch_init_dev(struct net_device *dev);\nvoid linkwatch_fire_event(struct net_device *dev);\nvoid linkwatch_forget_dev(struct net_device *dev);\n\n/**\n *\tnetif_carrier_ok - test if carrier present\n *\t@dev: network device\n *\n * Check if carrier is present on device\n */\nstatic inline bool netif_carrier_ok(const struct net_device *dev)\n{\n\treturn !test_bit(__LINK_STATE_NOCARRIER, &dev->state);\n}\n\nunsigned long dev_trans_start(struct net_device *dev);\n\nvoid __netdev_watchdog_up(struct net_device *dev);\n\nvoid netif_carrier_on(struct net_device *dev);\n\nvoid netif_carrier_off(struct net_device *dev);\n\n/**\n *\tnetif_dormant_on - mark device as dormant.\n *\t@dev: network device\n *\n * Mark device as dormant (as per RFC2863).\n *\n * The dormant state indicates that the relevant interface is not\n * actually in a condition to pass packets (i.e., it is not 'up') but is\n * in a \"pending\" state, waiting for some external event.  For \"on-\n * demand\" interfaces, this new state identifies the situation where the\n * interface is waiting for events to place it in the up state.\n */\nstatic inline void netif_dormant_on(struct net_device *dev)\n{\n\tif (!test_and_set_bit(__LINK_STATE_DORMANT, &dev->state))\n\t\tlinkwatch_fire_event(dev);\n}\n\n/**\n *\tnetif_dormant_off - set device as not dormant.\n *\t@dev: network device\n *\n * Device is not in dormant state.\n */\nstatic inline void netif_dormant_off(struct net_device *dev)\n{\n\tif (test_and_clear_bit(__LINK_STATE_DORMANT, &dev->state))\n\t\tlinkwatch_fire_event(dev);\n}\n\n/**\n *\tnetif_dormant - test if device is dormant\n *\t@dev: network device\n *\n * Check if device is dormant.\n */\nstatic inline bool netif_dormant(const struct net_device *dev)\n{\n\treturn test_bit(__LINK_STATE_DORMANT, &dev->state);\n}\n\n\n/**\n *\tnetif_testing_on - mark device as under test.\n *\t@dev: network device\n *\n * Mark device as under test (as per RFC2863).\n *\n * The testing state indicates that some test(s) must be performed on\n * the interface. After completion, of the test, the interface state\n * will change to up, dormant, or down, as appropriate.\n */\nstatic inline void netif_testing_on(struct net_device *dev)\n{\n\tif (!test_and_set_bit(__LINK_STATE_TESTING, &dev->state))\n\t\tlinkwatch_fire_event(dev);\n}\n\n/**\n *\tnetif_testing_off - set device as not under test.\n *\t@dev: network device\n *\n * Device is not in testing state.\n */\nstatic inline void netif_testing_off(struct net_device *dev)\n{\n\tif (test_and_clear_bit(__LINK_STATE_TESTING, &dev->state))\n\t\tlinkwatch_fire_event(dev);\n}\n\n/**\n *\tnetif_testing - test if device is under test\n *\t@dev: network device\n *\n * Check if device is under test\n */\nstatic inline bool netif_testing(const struct net_device *dev)\n{\n\treturn test_bit(__LINK_STATE_TESTING, &dev->state);\n}\n\n\n/**\n *\tnetif_oper_up - test if device is operational\n *\t@dev: network device\n *\n * Check if carrier is operational\n */\nstatic inline bool netif_oper_up(const struct net_device *dev)\n{\n\treturn (dev->operstate == IF_OPER_UP ||\n\t\tdev->operstate == IF_OPER_UNKNOWN /* backward compat */);\n}\n\n/**\n *\tnetif_device_present - is device available or removed\n *\t@dev: network device\n *\n * Check if device has not been removed from system.\n */\nstatic inline bool netif_device_present(struct net_device *dev)\n{\n\treturn test_bit(__LINK_STATE_PRESENT, &dev->state);\n}\n\nvoid netif_device_detach(struct net_device *dev);\n\nvoid netif_device_attach(struct net_device *dev);\n\n/*\n * Network interface message level settings\n */\n\nenum {\n\tNETIF_MSG_DRV_BIT,\n\tNETIF_MSG_PROBE_BIT,\n\tNETIF_MSG_LINK_BIT,\n\tNETIF_MSG_TIMER_BIT,\n\tNETIF_MSG_IFDOWN_BIT,\n\tNETIF_MSG_IFUP_BIT,\n\tNETIF_MSG_RX_ERR_BIT,\n\tNETIF_MSG_TX_ERR_BIT,\n\tNETIF_MSG_TX_QUEUED_BIT,\n\tNETIF_MSG_INTR_BIT,\n\tNETIF_MSG_TX_DONE_BIT,\n\tNETIF_MSG_RX_STATUS_BIT,\n\tNETIF_MSG_PKTDATA_BIT,\n\tNETIF_MSG_HW_BIT,\n\tNETIF_MSG_WOL_BIT,\n\n\t/* When you add a new bit above, update netif_msg_class_names array\n\t * in net/ethtool/common.c\n\t */\n\tNETIF_MSG_CLASS_COUNT,\n};\n/* Both ethtool_ops interface and internal driver implementation use u32 */\nstatic_assert(NETIF_MSG_CLASS_COUNT <= 32);\n\n#define __NETIF_MSG_BIT(bit)\t((u32)1 << (bit))\n#define __NETIF_MSG(name)\t__NETIF_MSG_BIT(NETIF_MSG_ ## name ## _BIT)\n\n#define NETIF_MSG_DRV\t\t__NETIF_MSG(DRV)\n#define NETIF_MSG_PROBE\t\t__NETIF_MSG(PROBE)\n#define NETIF_MSG_LINK\t\t__NETIF_MSG(LINK)\n#define NETIF_MSG_TIMER\t\t__NETIF_MSG(TIMER)\n#define NETIF_MSG_IFDOWN\t__NETIF_MSG(IFDOWN)\n#define NETIF_MSG_IFUP\t\t__NETIF_MSG(IFUP)\n#define NETIF_MSG_RX_ERR\t__NETIF_MSG(RX_ERR)\n#define NETIF_MSG_TX_ERR\t__NETIF_MSG(TX_ERR)\n#define NETIF_MSG_TX_QUEUED\t__NETIF_MSG(TX_QUEUED)\n#define NETIF_MSG_INTR\t\t__NETIF_MSG(INTR)\n#define NETIF_MSG_TX_DONE\t__NETIF_MSG(TX_DONE)\n#define NETIF_MSG_RX_STATUS\t__NETIF_MSG(RX_STATUS)\n#define NETIF_MSG_PKTDATA\t__NETIF_MSG(PKTDATA)\n#define NETIF_MSG_HW\t\t__NETIF_MSG(HW)\n#define NETIF_MSG_WOL\t\t__NETIF_MSG(WOL)\n\n#define netif_msg_drv(p)\t((p)->msg_enable & NETIF_MSG_DRV)\n#define netif_msg_probe(p)\t((p)->msg_enable & NETIF_MSG_PROBE)\n#define netif_msg_link(p)\t((p)->msg_enable & NETIF_MSG_LINK)\n#define netif_msg_timer(p)\t((p)->msg_enable & NETIF_MSG_TIMER)\n#define netif_msg_ifdown(p)\t((p)->msg_enable & NETIF_MSG_IFDOWN)\n#define netif_msg_ifup(p)\t((p)->msg_enable & NETIF_MSG_IFUP)\n#define netif_msg_rx_err(p)\t((p)->msg_enable & NETIF_MSG_RX_ERR)\n#define netif_msg_tx_err(p)\t((p)->msg_enable & NETIF_MSG_TX_ERR)\n#define netif_msg_tx_queued(p)\t((p)->msg_enable & NETIF_MSG_TX_QUEUED)\n#define netif_msg_intr(p)\t((p)->msg_enable & NETIF_MSG_INTR)\n#define netif_msg_tx_done(p)\t((p)->msg_enable & NETIF_MSG_TX_DONE)\n#define netif_msg_rx_status(p)\t((p)->msg_enable & NETIF_MSG_RX_STATUS)\n#define netif_msg_pktdata(p)\t((p)->msg_enable & NETIF_MSG_PKTDATA)\n#define netif_msg_hw(p)\t\t((p)->msg_enable & NETIF_MSG_HW)\n#define netif_msg_wol(p)\t((p)->msg_enable & NETIF_MSG_WOL)\n\nstatic inline u32 netif_msg_init(int debug_value, int default_msg_enable_bits)\n{\n\t/* use default */\n\tif (debug_value < 0 || debug_value >= (sizeof(u32) * 8))\n\t\treturn default_msg_enable_bits;\n\tif (debug_value == 0)\t/* no output */\n\t\treturn 0;\n\t/* set low N bits */\n\treturn (1U << debug_value) - 1;\n}\n\nstatic inline void __netif_tx_lock(struct netdev_queue *txq, int cpu)\n{\n\tspin_lock(&txq->_xmit_lock);\n\ttxq->xmit_lock_owner = cpu;\n}\n\nstatic inline bool __netif_tx_acquire(struct netdev_queue *txq)\n{\n\t__acquire(&txq->_xmit_lock);\n\treturn true;\n}\n\nstatic inline void __netif_tx_release(struct netdev_queue *txq)\n{\n\t__release(&txq->_xmit_lock);\n}\n\nstatic inline void __netif_tx_lock_bh(struct netdev_queue *txq)\n{\n\tspin_lock_bh(&txq->_xmit_lock);\n\ttxq->xmit_lock_owner = smp_processor_id();\n}\n\nstatic inline bool __netif_tx_trylock(struct netdev_queue *txq)\n{\n\tbool ok = spin_trylock(&txq->_xmit_lock);\n\tif (likely(ok))\n\t\ttxq->xmit_lock_owner = smp_processor_id();\n\treturn ok;\n}\n\nstatic inline void __netif_tx_unlock(struct netdev_queue *txq)\n{\n\ttxq->xmit_lock_owner = -1;\n\tspin_unlock(&txq->_xmit_lock);\n}\n\nstatic inline void __netif_tx_unlock_bh(struct netdev_queue *txq)\n{\n\ttxq->xmit_lock_owner = -1;\n\tspin_unlock_bh(&txq->_xmit_lock);\n}\n\nstatic inline void txq_trans_update(struct netdev_queue *txq)\n{\n\tif (txq->xmit_lock_owner != -1)\n\t\ttxq->trans_start = jiffies;\n}\n\n/* legacy drivers only, netdev_start_xmit() sets txq->trans_start */\nstatic inline void netif_trans_update(struct net_device *dev)\n{\n\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, 0);\n\n\tif (txq->trans_start != jiffies)\n\t\ttxq->trans_start = jiffies;\n}\n\n/**\n *\tnetif_tx_lock - grab network device transmit lock\n *\t@dev: network device\n *\n * Get network device transmit lock\n */\nstatic inline void netif_tx_lock(struct net_device *dev)\n{\n\tunsigned int i;\n\tint cpu;\n\n\tspin_lock(&dev->tx_global_lock);\n\tcpu = smp_processor_id();\n\tfor (i = 0; i < dev->num_tx_queues; i++) {\n\t\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, i);\n\n\t\t/* We are the only thread of execution doing a\n\t\t * freeze, but we have to grab the _xmit_lock in\n\t\t * order to synchronize with threads which are in\n\t\t * the ->hard_start_xmit() handler and already\n\t\t * checked the frozen bit.\n\t\t */\n\t\t__netif_tx_lock(txq, cpu);\n\t\tset_bit(__QUEUE_STATE_FROZEN, &txq->state);\n\t\t__netif_tx_unlock(txq);\n\t}\n}\n\nstatic inline void netif_tx_lock_bh(struct net_device *dev)\n{\n\tlocal_bh_disable();\n\tnetif_tx_lock(dev);\n}\n\nstatic inline void netif_tx_unlock(struct net_device *dev)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < dev->num_tx_queues; i++) {\n\t\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, i);\n\n\t\t/* No need to grab the _xmit_lock here.  If the\n\t\t * queue is not stopped for another reason, we\n\t\t * force a schedule.\n\t\t */\n\t\tclear_bit(__QUEUE_STATE_FROZEN, &txq->state);\n\t\tnetif_schedule_queue(txq);\n\t}\n\tspin_unlock(&dev->tx_global_lock);\n}\n\nstatic inline void netif_tx_unlock_bh(struct net_device *dev)\n{\n\tnetif_tx_unlock(dev);\n\tlocal_bh_enable();\n}\n\n#define HARD_TX_LOCK(dev, txq, cpu) {\t\t\t\\\n\tif ((dev->features & NETIF_F_LLTX) == 0) {\t\\\n\t\t__netif_tx_lock(txq, cpu);\t\t\\\n\t} else {\t\t\t\t\t\\\n\t\t__netif_tx_acquire(txq);\t\t\\\n\t}\t\t\t\t\t\t\\\n}\n\n#define HARD_TX_TRYLOCK(dev, txq)\t\t\t\\\n\t(((dev->features & NETIF_F_LLTX) == 0) ?\t\\\n\t\t__netif_tx_trylock(txq) :\t\t\\\n\t\t__netif_tx_acquire(txq))\n\n#define HARD_TX_UNLOCK(dev, txq) {\t\t\t\\\n\tif ((dev->features & NETIF_F_LLTX) == 0) {\t\\\n\t\t__netif_tx_unlock(txq);\t\t\t\\\n\t} else {\t\t\t\t\t\\\n\t\t__netif_tx_release(txq);\t\t\\\n\t}\t\t\t\t\t\t\\\n}\n\nstatic inline void netif_tx_disable(struct net_device *dev)\n{\n\tunsigned int i;\n\tint cpu;\n\n\tlocal_bh_disable();\n\tcpu = smp_processor_id();\n\tspin_lock(&dev->tx_global_lock);\n\tfor (i = 0; i < dev->num_tx_queues; i++) {\n\t\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, i);\n\n\t\t__netif_tx_lock(txq, cpu);\n\t\tnetif_tx_stop_queue(txq);\n\t\t__netif_tx_unlock(txq);\n\t}\n\tspin_unlock(&dev->tx_global_lock);\n\tlocal_bh_enable();\n}\n\nstatic inline void netif_addr_lock(struct net_device *dev)\n{\n\tunsigned char nest_level = 0;\n\n#ifdef CONFIG_LOCKDEP\n\tnest_level = dev->nested_level;\n#endif\n\tspin_lock_nested(&dev->addr_list_lock, nest_level);\n}\n\nstatic inline void netif_addr_lock_bh(struct net_device *dev)\n{\n\tunsigned char nest_level = 0;\n\n#ifdef CONFIG_LOCKDEP\n\tnest_level = dev->nested_level;\n#endif\n\tlocal_bh_disable();\n\tspin_lock_nested(&dev->addr_list_lock, nest_level);\n}\n\nstatic inline void netif_addr_unlock(struct net_device *dev)\n{\n\tspin_unlock(&dev->addr_list_lock);\n}\n\nstatic inline void netif_addr_unlock_bh(struct net_device *dev)\n{\n\tspin_unlock_bh(&dev->addr_list_lock);\n}\n\n/*\n * dev_addrs walker. Should be used only for read access. Call with\n * rcu_read_lock held.\n */\n#define for_each_dev_addr(dev, ha) \\\n\t\tlist_for_each_entry_rcu(ha, &dev->dev_addrs.list, list)\n\n/* These functions live elsewhere (drivers/net/net_init.c, but related) */\n\nvoid ether_setup(struct net_device *dev);\n\n/* Support for loadable net-drivers */\nstruct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,\n\t\t\t\t    unsigned char name_assign_type,\n\t\t\t\t    void (*setup)(struct net_device *),\n\t\t\t\t    unsigned int txqs, unsigned int rxqs);\n#define alloc_netdev(sizeof_priv, name, name_assign_type, setup) \\\n\talloc_netdev_mqs(sizeof_priv, name, name_assign_type, setup, 1, 1)\n\n#define alloc_netdev_mq(sizeof_priv, name, name_assign_type, setup, count) \\\n\talloc_netdev_mqs(sizeof_priv, name, name_assign_type, setup, count, \\\n\t\t\t count)\n\nint register_netdev(struct net_device *dev);\nvoid unregister_netdev(struct net_device *dev);\n\nint devm_register_netdev(struct device *dev, struct net_device *ndev);\n\n/* General hardware address lists handling functions */\nint __hw_addr_sync(struct netdev_hw_addr_list *to_list,\n\t\t   struct netdev_hw_addr_list *from_list, int addr_len);\nvoid __hw_addr_unsync(struct netdev_hw_addr_list *to_list,\n\t\t      struct netdev_hw_addr_list *from_list, int addr_len);\nint __hw_addr_sync_dev(struct netdev_hw_addr_list *list,\n\t\t       struct net_device *dev,\n\t\t       int (*sync)(struct net_device *, const unsigned char *),\n\t\t       int (*unsync)(struct net_device *,\n\t\t\t\t     const unsigned char *));\nint __hw_addr_ref_sync_dev(struct netdev_hw_addr_list *list,\n\t\t\t   struct net_device *dev,\n\t\t\t   int (*sync)(struct net_device *,\n\t\t\t\t       const unsigned char *, int),\n\t\t\t   int (*unsync)(struct net_device *,\n\t\t\t\t\t const unsigned char *, int));\nvoid __hw_addr_ref_unsync_dev(struct netdev_hw_addr_list *list,\n\t\t\t      struct net_device *dev,\n\t\t\t      int (*unsync)(struct net_device *,\n\t\t\t\t\t    const unsigned char *, int));\nvoid __hw_addr_unsync_dev(struct netdev_hw_addr_list *list,\n\t\t\t  struct net_device *dev,\n\t\t\t  int (*unsync)(struct net_device *,\n\t\t\t\t\tconst unsigned char *));\nvoid __hw_addr_init(struct netdev_hw_addr_list *list);\n\n/* Functions used for device addresses handling */\nint dev_addr_add(struct net_device *dev, const unsigned char *addr,\n\t\t unsigned char addr_type);\nint dev_addr_del(struct net_device *dev, const unsigned char *addr,\n\t\t unsigned char addr_type);\nvoid dev_addr_flush(struct net_device *dev);\nint dev_addr_init(struct net_device *dev);\n\n/* Functions used for unicast addresses handling */\nint dev_uc_add(struct net_device *dev, const unsigned char *addr);\nint dev_uc_add_excl(struct net_device *dev, const unsigned char *addr);\nint dev_uc_del(struct net_device *dev, const unsigned char *addr);\nint dev_uc_sync(struct net_device *to, struct net_device *from);\nint dev_uc_sync_multiple(struct net_device *to, struct net_device *from);\nvoid dev_uc_unsync(struct net_device *to, struct net_device *from);\nvoid dev_uc_flush(struct net_device *dev);\nvoid dev_uc_init(struct net_device *dev);\n\n/**\n *  __dev_uc_sync - Synchonize device's unicast list\n *  @dev:  device to sync\n *  @sync: function to call if address should be added\n *  @unsync: function to call if address should be removed\n *\n *  Add newly added addresses to the interface, and release\n *  addresses that have been deleted.\n */\nstatic inline int __dev_uc_sync(struct net_device *dev,\n\t\t\t\tint (*sync)(struct net_device *,\n\t\t\t\t\t    const unsigned char *),\n\t\t\t\tint (*unsync)(struct net_device *,\n\t\t\t\t\t      const unsigned char *))\n{\n\treturn __hw_addr_sync_dev(&dev->uc, dev, sync, unsync);\n}\n\n/**\n *  __dev_uc_unsync - Remove synchronized addresses from device\n *  @dev:  device to sync\n *  @unsync: function to call if address should be removed\n *\n *  Remove all addresses that were added to the device by dev_uc_sync().\n */\nstatic inline void __dev_uc_unsync(struct net_device *dev,\n\t\t\t\t   int (*unsync)(struct net_device *,\n\t\t\t\t\t\t const unsigned char *))\n{\n\t__hw_addr_unsync_dev(&dev->uc, dev, unsync);\n}\n\n/* Functions used for multicast addresses handling */\nint dev_mc_add(struct net_device *dev, const unsigned char *addr);\nint dev_mc_add_global(struct net_device *dev, const unsigned char *addr);\nint dev_mc_add_excl(struct net_device *dev, const unsigned char *addr);\nint dev_mc_del(struct net_device *dev, const unsigned char *addr);\nint dev_mc_del_global(struct net_device *dev, const unsigned char *addr);\nint dev_mc_sync(struct net_device *to, struct net_device *from);\nint dev_mc_sync_multiple(struct net_device *to, struct net_device *from);\nvoid dev_mc_unsync(struct net_device *to, struct net_device *from);\nvoid dev_mc_flush(struct net_device *dev);\nvoid dev_mc_init(struct net_device *dev);\n\n/**\n *  __dev_mc_sync - Synchonize device's multicast list\n *  @dev:  device to sync\n *  @sync: function to call if address should be added\n *  @unsync: function to call if address should be removed\n *\n *  Add newly added addresses to the interface, and release\n *  addresses that have been deleted.\n */\nstatic inline int __dev_mc_sync(struct net_device *dev,\n\t\t\t\tint (*sync)(struct net_device *,\n\t\t\t\t\t    const unsigned char *),\n\t\t\t\tint (*unsync)(struct net_device *,\n\t\t\t\t\t      const unsigned char *))\n{\n\treturn __hw_addr_sync_dev(&dev->mc, dev, sync, unsync);\n}\n\n/**\n *  __dev_mc_unsync - Remove synchronized addresses from device\n *  @dev:  device to sync\n *  @unsync: function to call if address should be removed\n *\n *  Remove all addresses that were added to the device by dev_mc_sync().\n */\nstatic inline void __dev_mc_unsync(struct net_device *dev,\n\t\t\t\t   int (*unsync)(struct net_device *,\n\t\t\t\t\t\t const unsigned char *))\n{\n\t__hw_addr_unsync_dev(&dev->mc, dev, unsync);\n}\n\n/* Functions used for secondary unicast and multicast support */\nvoid dev_set_rx_mode(struct net_device *dev);\nvoid __dev_set_rx_mode(struct net_device *dev);\nint dev_set_promiscuity(struct net_device *dev, int inc);\nint dev_set_allmulti(struct net_device *dev, int inc);\nvoid netdev_state_change(struct net_device *dev);\nvoid __netdev_notify_peers(struct net_device *dev);\nvoid netdev_notify_peers(struct net_device *dev);\nvoid netdev_features_change(struct net_device *dev);\n/* Load a device via the kmod */\nvoid dev_load(struct net *net, const char *name);\nstruct rtnl_link_stats64 *dev_get_stats(struct net_device *dev,\n\t\t\t\t\tstruct rtnl_link_stats64 *storage);\nvoid netdev_stats_to_stats64(struct rtnl_link_stats64 *stats64,\n\t\t\t     const struct net_device_stats *netdev_stats);\nvoid dev_fetch_sw_netstats(struct rtnl_link_stats64 *s,\n\t\t\t   const struct pcpu_sw_netstats __percpu *netstats);\nvoid dev_get_tstats64(struct net_device *dev, struct rtnl_link_stats64 *s);\n\nextern int\t\tnetdev_max_backlog;\nextern int\t\tnetdev_tstamp_prequeue;\nextern int\t\tweight_p;\nextern int\t\tdev_weight_rx_bias;\nextern int\t\tdev_weight_tx_bias;\nextern int\t\tdev_rx_weight;\nextern int\t\tdev_tx_weight;\nextern int\t\tgro_normal_batch;\n\nenum {\n\tNESTED_SYNC_IMM_BIT,\n\tNESTED_SYNC_TODO_BIT,\n};\n\n#define __NESTED_SYNC_BIT(bit)\t((u32)1 << (bit))\n#define __NESTED_SYNC(name)\t__NESTED_SYNC_BIT(NESTED_SYNC_ ## name ## _BIT)\n\n#define NESTED_SYNC_IMM\t\t__NESTED_SYNC(IMM)\n#define NESTED_SYNC_TODO\t__NESTED_SYNC(TODO)\n\nstruct netdev_nested_priv {\n\tunsigned char flags;\n\tvoid *data;\n};\n\nbool netdev_has_upper_dev(struct net_device *dev, struct net_device *upper_dev);\nstruct net_device *netdev_upper_get_next_dev_rcu(struct net_device *dev,\n\t\t\t\t\t\t     struct list_head **iter);\nstruct net_device *netdev_all_upper_get_next_dev_rcu(struct net_device *dev,\n\t\t\t\t\t\t     struct list_head **iter);\n\n#ifdef CONFIG_LOCKDEP\nstatic LIST_HEAD(net_unlink_list);\n\nstatic inline void net_unlink_todo(struct net_device *dev)\n{\n\tif (list_empty(&dev->unlink_list))\n\t\tlist_add_tail(&dev->unlink_list, &net_unlink_list);\n}\n#endif\n\n/* iterate through upper list, must be called under RCU read lock */\n#define netdev_for_each_upper_dev_rcu(dev, updev, iter) \\\n\tfor (iter = &(dev)->adj_list.upper, \\\n\t     updev = netdev_upper_get_next_dev_rcu(dev, &(iter)); \\\n\t     updev; \\\n\t     updev = netdev_upper_get_next_dev_rcu(dev, &(iter)))\n\nint netdev_walk_all_upper_dev_rcu(struct net_device *dev,\n\t\t\t\t  int (*fn)(struct net_device *upper_dev,\n\t\t\t\t\t    struct netdev_nested_priv *priv),\n\t\t\t\t  struct netdev_nested_priv *priv);\n\nbool netdev_has_upper_dev_all_rcu(struct net_device *dev,\n\t\t\t\t  struct net_device *upper_dev);\n\nbool netdev_has_any_upper_dev(struct net_device *dev);\n\nvoid *netdev_lower_get_next_private(struct net_device *dev,\n\t\t\t\t    struct list_head **iter);\nvoid *netdev_lower_get_next_private_rcu(struct net_device *dev,\n\t\t\t\t\tstruct list_head **iter);\n\n#define netdev_for_each_lower_private(dev, priv, iter) \\\n\tfor (iter = (dev)->adj_list.lower.next, \\\n\t     priv = netdev_lower_get_next_private(dev, &(iter)); \\\n\t     priv; \\\n\t     priv = netdev_lower_get_next_private(dev, &(iter)))\n\n#define netdev_for_each_lower_private_rcu(dev, priv, iter) \\\n\tfor (iter = &(dev)->adj_list.lower, \\\n\t     priv = netdev_lower_get_next_private_rcu(dev, &(iter)); \\\n\t     priv; \\\n\t     priv = netdev_lower_get_next_private_rcu(dev, &(iter)))\n\nvoid *netdev_lower_get_next(struct net_device *dev,\n\t\t\t\tstruct list_head **iter);\n\n#define netdev_for_each_lower_dev(dev, ldev, iter) \\\n\tfor (iter = (dev)->adj_list.lower.next, \\\n\t     ldev = netdev_lower_get_next(dev, &(iter)); \\\n\t     ldev; \\\n\t     ldev = netdev_lower_get_next(dev, &(iter)))\n\nstruct net_device *netdev_next_lower_dev_rcu(struct net_device *dev,\n\t\t\t\t\t     struct list_head **iter);\nint netdev_walk_all_lower_dev(struct net_device *dev,\n\t\t\t      int (*fn)(struct net_device *lower_dev,\n\t\t\t\t\tstruct netdev_nested_priv *priv),\n\t\t\t      struct netdev_nested_priv *priv);\nint netdev_walk_all_lower_dev_rcu(struct net_device *dev,\n\t\t\t\t  int (*fn)(struct net_device *lower_dev,\n\t\t\t\t\t    struct netdev_nested_priv *priv),\n\t\t\t\t  struct netdev_nested_priv *priv);\n\nvoid *netdev_adjacent_get_private(struct list_head *adj_list);\nvoid *netdev_lower_get_first_private_rcu(struct net_device *dev);\nstruct net_device *netdev_master_upper_dev_get(struct net_device *dev);\nstruct net_device *netdev_master_upper_dev_get_rcu(struct net_device *dev);\nint netdev_upper_dev_link(struct net_device *dev, struct net_device *upper_dev,\n\t\t\t  struct netlink_ext_ack *extack);\nint netdev_master_upper_dev_link(struct net_device *dev,\n\t\t\t\t struct net_device *upper_dev,\n\t\t\t\t void *upper_priv, void *upper_info,\n\t\t\t\t struct netlink_ext_ack *extack);\nvoid netdev_upper_dev_unlink(struct net_device *dev,\n\t\t\t     struct net_device *upper_dev);\nint netdev_adjacent_change_prepare(struct net_device *old_dev,\n\t\t\t\t   struct net_device *new_dev,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   struct netlink_ext_ack *extack);\nvoid netdev_adjacent_change_commit(struct net_device *old_dev,\n\t\t\t\t   struct net_device *new_dev,\n\t\t\t\t   struct net_device *dev);\nvoid netdev_adjacent_change_abort(struct net_device *old_dev,\n\t\t\t\t  struct net_device *new_dev,\n\t\t\t\t  struct net_device *dev);\nvoid netdev_adjacent_rename_links(struct net_device *dev, char *oldname);\nvoid *netdev_lower_dev_get_private(struct net_device *dev,\n\t\t\t\t   struct net_device *lower_dev);\nvoid netdev_lower_state_changed(struct net_device *lower_dev,\n\t\t\t\tvoid *lower_state_info);\n\n/* RSS keys are 40 or 52 bytes long */\n#define NETDEV_RSS_KEY_LEN 52\nextern u8 netdev_rss_key[NETDEV_RSS_KEY_LEN] __read_mostly;\nvoid netdev_rss_key_fill(void *buffer, size_t len);\n\nint skb_checksum_help(struct sk_buff *skb);\nint skb_crc32c_csum_help(struct sk_buff *skb);\nint skb_csum_hwoffload_help(struct sk_buff *skb,\n\t\t\t    const netdev_features_t features);\n\nstruct sk_buff *__skb_gso_segment(struct sk_buff *skb,\n\t\t\t\t  netdev_features_t features, bool tx_path);\nstruct sk_buff *skb_mac_gso_segment(struct sk_buff *skb,\n\t\t\t\t    netdev_features_t features);\n\nstruct netdev_bonding_info {\n\tifslave\tslave;\n\tifbond\tmaster;\n};\n\nstruct netdev_notifier_bonding_info {\n\tstruct netdev_notifier_info info; /* must be first */\n\tstruct netdev_bonding_info  bonding_info;\n};\n\nvoid netdev_bonding_info_change(struct net_device *dev,\n\t\t\t\tstruct netdev_bonding_info *bonding_info);\n\n#if IS_ENABLED(CONFIG_ETHTOOL_NETLINK)\nvoid ethtool_notify(struct net_device *dev, unsigned int cmd, const void *data);\n#else\nstatic inline void ethtool_notify(struct net_device *dev, unsigned int cmd,\n\t\t\t\t  const void *data)\n{\n}\n#endif\n\nstatic inline\nstruct sk_buff *skb_gso_segment(struct sk_buff *skb, netdev_features_t features)\n{\n\treturn __skb_gso_segment(skb, features, true);\n}\n__be16 skb_network_protocol(struct sk_buff *skb, int *depth);\n\nstatic inline bool can_checksum_protocol(netdev_features_t features,\n\t\t\t\t\t __be16 protocol)\n{\n\tif (protocol == htons(ETH_P_FCOE))\n\t\treturn !!(features & NETIF_F_FCOE_CRC);\n\n\t/* Assume this is an IP checksum (not SCTP CRC) */\n\n\tif (features & NETIF_F_HW_CSUM) {\n\t\t/* Can checksum everything */\n\t\treturn true;\n\t}\n\n\tswitch (protocol) {\n\tcase htons(ETH_P_IP):\n\t\treturn !!(features & NETIF_F_IP_CSUM);\n\tcase htons(ETH_P_IPV6):\n\t\treturn !!(features & NETIF_F_IPV6_CSUM);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n#ifdef CONFIG_BUG\nvoid netdev_rx_csum_fault(struct net_device *dev, struct sk_buff *skb);\n#else\nstatic inline void netdev_rx_csum_fault(struct net_device *dev,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n}\n#endif\n/* rx skb timestamps */\nvoid net_enable_timestamp(void);\nvoid net_disable_timestamp(void);\n\n#ifdef CONFIG_PROC_FS\nint __init dev_proc_init(void);\n#else\n#define dev_proc_init() 0\n#endif\n\nstatic inline netdev_tx_t __netdev_start_xmit(const struct net_device_ops *ops,\n\t\t\t\t\t      struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t\t      bool more)\n{\n\t__this_cpu_write(softnet_data.xmit.more, more);\n\treturn ops->ndo_start_xmit(skb, dev);\n}\n\nstatic inline bool netdev_xmit_more(void)\n{\n\treturn __this_cpu_read(softnet_data.xmit.more);\n}\n\nstatic inline netdev_tx_t netdev_start_xmit(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t\t    struct netdev_queue *txq, bool more)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\tnetdev_tx_t rc;\n\n\trc = __netdev_start_xmit(ops, skb, dev, more);\n\tif (rc == NETDEV_TX_OK)\n\t\ttxq_trans_update(txq);\n\n\treturn rc;\n}\n\nint netdev_class_create_file_ns(const struct class_attribute *class_attr,\n\t\t\t\tconst void *ns);\nvoid netdev_class_remove_file_ns(const struct class_attribute *class_attr,\n\t\t\t\t const void *ns);\n\nextern const struct kobj_ns_type_operations net_ns_type_operations;\n\nconst char *netdev_drivername(const struct net_device *dev);\n\nvoid linkwatch_run_queue(void);\n\nstatic inline netdev_features_t netdev_intersect_features(netdev_features_t f1,\n\t\t\t\t\t\t\t  netdev_features_t f2)\n{\n\tif ((f1 ^ f2) & NETIF_F_HW_CSUM) {\n\t\tif (f1 & NETIF_F_HW_CSUM)\n\t\t\tf1 |= (NETIF_F_IP_CSUM|NETIF_F_IPV6_CSUM);\n\t\telse\n\t\t\tf2 |= (NETIF_F_IP_CSUM|NETIF_F_IPV6_CSUM);\n\t}\n\n\treturn f1 & f2;\n}\n\nstatic inline netdev_features_t netdev_get_wanted_features(\n\tstruct net_device *dev)\n{\n\treturn (dev->features & ~dev->hw_features) | dev->wanted_features;\n}\nnetdev_features_t netdev_increment_features(netdev_features_t all,\n\tnetdev_features_t one, netdev_features_t mask);\n\n/* Allow TSO being used on stacked device :\n * Performing the GSO segmentation before last device\n * is a performance improvement.\n */\nstatic inline netdev_features_t netdev_add_tso_features(netdev_features_t features,\n\t\t\t\t\t\t\tnetdev_features_t mask)\n{\n\treturn netdev_increment_features(features, NETIF_F_ALL_TSO, mask);\n}\n\nint __netdev_update_features(struct net_device *dev);\nvoid netdev_update_features(struct net_device *dev);\nvoid netdev_change_features(struct net_device *dev);\n\nvoid netif_stacked_transfer_operstate(const struct net_device *rootdev,\n\t\t\t\t\tstruct net_device *dev);\n\nnetdev_features_t passthru_features_check(struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *dev,\n\t\t\t\t\t  netdev_features_t features);\nnetdev_features_t netif_skb_features(struct sk_buff *skb);\n\nstatic inline bool net_gso_ok(netdev_features_t features, int gso_type)\n{\n\tnetdev_features_t feature = (netdev_features_t)gso_type << NETIF_F_GSO_SHIFT;\n\n\t/* check flags correspondence */\n\tBUILD_BUG_ON(SKB_GSO_TCPV4   != (NETIF_F_TSO >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_DODGY   != (NETIF_F_GSO_ROBUST >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_TCP_ECN != (NETIF_F_TSO_ECN >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_TCP_FIXEDID != (NETIF_F_TSO_MANGLEID >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_TCPV6   != (NETIF_F_TSO6 >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_FCOE    != (NETIF_F_FSO >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_GRE     != (NETIF_F_GSO_GRE >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_GRE_CSUM != (NETIF_F_GSO_GRE_CSUM >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_IPXIP4  != (NETIF_F_GSO_IPXIP4 >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_IPXIP6  != (NETIF_F_GSO_IPXIP6 >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_UDP_TUNNEL != (NETIF_F_GSO_UDP_TUNNEL >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_UDP_TUNNEL_CSUM != (NETIF_F_GSO_UDP_TUNNEL_CSUM >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_PARTIAL != (NETIF_F_GSO_PARTIAL >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_TUNNEL_REMCSUM != (NETIF_F_GSO_TUNNEL_REMCSUM >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_SCTP    != (NETIF_F_GSO_SCTP >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_ESP != (NETIF_F_GSO_ESP >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_UDP != (NETIF_F_GSO_UDP >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_UDP_L4 != (NETIF_F_GSO_UDP_L4 >> NETIF_F_GSO_SHIFT));\n\tBUILD_BUG_ON(SKB_GSO_FRAGLIST != (NETIF_F_GSO_FRAGLIST >> NETIF_F_GSO_SHIFT));\n\n\treturn (features & feature) == feature;\n}\n\nstatic inline bool skb_gso_ok(struct sk_buff *skb, netdev_features_t features)\n{\n\treturn net_gso_ok(features, skb_shinfo(skb)->gso_type) &&\n\t       (!skb_has_frag_list(skb) || (features & NETIF_F_FRAGLIST));\n}\n\nstatic inline bool netif_needs_gso(struct sk_buff *skb,\n\t\t\t\t   netdev_features_t features)\n{\n\treturn skb_is_gso(skb) && (!skb_gso_ok(skb, features) ||\n\t\tunlikely((skb->ip_summed != CHECKSUM_PARTIAL) &&\n\t\t\t (skb->ip_summed != CHECKSUM_UNNECESSARY)));\n}\n\nstatic inline void netif_set_gso_max_size(struct net_device *dev,\n\t\t\t\t\t  unsigned int size)\n{\n\tdev->gso_max_size = size;\n}\n\nstatic inline void skb_gso_error_unwind(struct sk_buff *skb, __be16 protocol,\n\t\t\t\t\tint pulled_hlen, u16 mac_offset,\n\t\t\t\t\tint mac_len)\n{\n\tskb->protocol = protocol;\n\tskb->encapsulation = 1;\n\tskb_push(skb, pulled_hlen);\n\tskb_reset_transport_header(skb);\n\tskb->mac_header = mac_offset;\n\tskb->network_header = skb->mac_header + mac_len;\n\tskb->mac_len = mac_len;\n}\n\nstatic inline bool netif_is_macsec(const struct net_device *dev)\n{\n\treturn dev->priv_flags & IFF_MACSEC;\n}\n\nstatic inline bool netif_is_macvlan(const struct net_device *dev)\n{\n\treturn dev->priv_flags & IFF_MACVLAN;\n}\n\nstatic inline bool netif_is_macvlan_port(const struct net_device *dev)\n{\n\treturn dev->priv_flags & IFF_MACVLAN_PORT;\n}\n\nstatic inline bool netif_is_bond_master(const struct net_device *dev)\n{\n\treturn dev->flags & IFF_MASTER && dev->priv_flags & IFF_BONDING;\n}\n\nstatic inline bool netif_is_bond_slave(const struct net_device *dev)\n{\n\treturn dev->flags & IFF_SLAVE && dev->priv_flags & IFF_BONDING;\n}\n\nstatic inline bool netif_supports_nofcs(struct net_device *dev)\n{\n\treturn dev->priv_flags & IFF_SUPP_NOFCS;\n}\n\nstatic inline bool netif_has_l3_rx_handler(const struct net_device *dev)\n{\n\treturn dev->priv_flags & IFF_L3MDEV_RX_HANDLER;\n}\n\nstatic inline bool netif_is_l3_master(const struct net_device *dev)\n{\n\treturn dev->priv_flags & IFF_L3MDEV_MASTER;\n}\n\nstatic inline bool netif_is_l3_slave(const struct net_device *dev)\n{\n\treturn dev->priv_flags & IFF_L3MDEV_SLAVE;\n}\n\nstatic inline bool netif_is_bridge_master(const struct net_device *dev)\n{\n\treturn dev->priv_flags & IFF_EBRIDGE;\n}\n\nstatic inline bool netif_is_bridge_port(const struct net_device *dev)\n{\n\treturn dev->priv_flags & IFF_BRIDGE_PORT;\n}\n\nstatic inline bool netif_is_ovs_master(const struct net_device *dev)\n{\n\treturn dev->priv_flags & IFF_OPENVSWITCH;\n}\n\nstatic inline bool netif_is_ovs_port(const struct net_device *dev)\n{\n\treturn dev->priv_flags & IFF_OVS_DATAPATH;\n}\n\nstatic inline bool netif_is_any_bridge_port(const struct net_device *dev)\n{\n\treturn netif_is_bridge_port(dev) || netif_is_ovs_port(dev);\n}\n\nstatic inline bool netif_is_team_master(const struct net_device *dev)\n{\n\treturn dev->priv_flags & IFF_TEAM;\n}\n\nstatic inline bool netif_is_team_port(const struct net_device *dev)\n{\n\treturn dev->priv_flags & IFF_TEAM_PORT;\n}\n\nstatic inline bool netif_is_lag_master(const struct net_device *dev)\n{\n\treturn netif_is_bond_master(dev) || netif_is_team_master(dev);\n}\n\nstatic inline bool netif_is_lag_port(const struct net_device *dev)\n{\n\treturn netif_is_bond_slave(dev) || netif_is_team_port(dev);\n}\n\nstatic inline bool netif_is_rxfh_configured(const struct net_device *dev)\n{\n\treturn dev->priv_flags & IFF_RXFH_CONFIGURED;\n}\n\nstatic inline bool netif_is_failover(const struct net_device *dev)\n{\n\treturn dev->priv_flags & IFF_FAILOVER;\n}\n\nstatic inline bool netif_is_failover_slave(const struct net_device *dev)\n{\n\treturn dev->priv_flags & IFF_FAILOVER_SLAVE;\n}\n\n/* This device needs to keep skb dst for qdisc enqueue or ndo_start_xmit() */\nstatic inline void netif_keep_dst(struct net_device *dev)\n{\n\tdev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM);\n}\n\n/* return true if dev can't cope with mtu frames that need vlan tag insertion */\nstatic inline bool netif_reduces_vlan_mtu(struct net_device *dev)\n{\n\t/* TODO: reserve and use an additional IFF bit, if we get more users */\n\treturn dev->priv_flags & IFF_MACSEC;\n}\n\nextern struct pernet_operations __net_initdata loopback_net_ops;\n\n/* Logging, debugging and troubleshooting/diagnostic helpers. */\n\n/* netdev_printk helpers, similar to dev_printk */\n\nstatic inline const char *netdev_name(const struct net_device *dev)\n{\n\tif (!dev->name[0] || strchr(dev->name, '%'))\n\t\treturn \"(unnamed net_device)\";\n\treturn dev->name;\n}\n\nstatic inline bool netdev_unregistering(const struct net_device *dev)\n{\n\treturn dev->reg_state == NETREG_UNREGISTERING;\n}\n\nstatic inline const char *netdev_reg_state(const struct net_device *dev)\n{\n\tswitch (dev->reg_state) {\n\tcase NETREG_UNINITIALIZED: return \" (uninitialized)\";\n\tcase NETREG_REGISTERED: return \"\";\n\tcase NETREG_UNREGISTERING: return \" (unregistering)\";\n\tcase NETREG_UNREGISTERED: return \" (unregistered)\";\n\tcase NETREG_RELEASED: return \" (released)\";\n\tcase NETREG_DUMMY: return \" (dummy)\";\n\t}\n\n\tWARN_ONCE(1, \"%s: unknown reg_state %d\\n\", dev->name, dev->reg_state);\n\treturn \" (unknown)\";\n}\n\n__printf(3, 4) __cold\nvoid netdev_printk(const char *level, const struct net_device *dev,\n\t\t   const char *format, ...);\n__printf(2, 3) __cold\nvoid netdev_emerg(const struct net_device *dev, const char *format, ...);\n__printf(2, 3) __cold\nvoid netdev_alert(const struct net_device *dev, const char *format, ...);\n__printf(2, 3) __cold\nvoid netdev_crit(const struct net_device *dev, const char *format, ...);\n__printf(2, 3) __cold\nvoid netdev_err(const struct net_device *dev, const char *format, ...);\n__printf(2, 3) __cold\nvoid netdev_warn(const struct net_device *dev, const char *format, ...);\n__printf(2, 3) __cold\nvoid netdev_notice(const struct net_device *dev, const char *format, ...);\n__printf(2, 3) __cold\nvoid netdev_info(const struct net_device *dev, const char *format, ...);\n\n#define netdev_level_once(level, dev, fmt, ...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tstatic bool __print_once __read_mostly;\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (!__print_once) {\t\t\t\t\t\\\n\t\t__print_once = true;\t\t\t\t\\\n\t\tnetdev_printk(level, dev, fmt, ##__VA_ARGS__);\t\\\n\t}\t\t\t\t\t\t\t\\\n} while (0)\n\n#define netdev_emerg_once(dev, fmt, ...) \\\n\tnetdev_level_once(KERN_EMERG, dev, fmt, ##__VA_ARGS__)\n#define netdev_alert_once(dev, fmt, ...) \\\n\tnetdev_level_once(KERN_ALERT, dev, fmt, ##__VA_ARGS__)\n#define netdev_crit_once(dev, fmt, ...) \\\n\tnetdev_level_once(KERN_CRIT, dev, fmt, ##__VA_ARGS__)\n#define netdev_err_once(dev, fmt, ...) \\\n\tnetdev_level_once(KERN_ERR, dev, fmt, ##__VA_ARGS__)\n#define netdev_warn_once(dev, fmt, ...) \\\n\tnetdev_level_once(KERN_WARNING, dev, fmt, ##__VA_ARGS__)\n#define netdev_notice_once(dev, fmt, ...) \\\n\tnetdev_level_once(KERN_NOTICE, dev, fmt, ##__VA_ARGS__)\n#define netdev_info_once(dev, fmt, ...) \\\n\tnetdev_level_once(KERN_INFO, dev, fmt, ##__VA_ARGS__)\n\n#define MODULE_ALIAS_NETDEV(device) \\\n\tMODULE_ALIAS(\"netdev-\" device)\n\n#if defined(CONFIG_DYNAMIC_DEBUG) || \\\n\t(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))\n#define netdev_dbg(__dev, format, args...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tdynamic_netdev_dbg(__dev, format, ##args);\t\t\\\n} while (0)\n#elif defined(DEBUG)\n#define netdev_dbg(__dev, format, args...)\t\t\t\\\n\tnetdev_printk(KERN_DEBUG, __dev, format, ##args)\n#else\n#define netdev_dbg(__dev, format, args...)\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\\\n\t\tnetdev_printk(KERN_DEBUG, __dev, format, ##args); \\\n})\n#endif\n\n#if defined(VERBOSE_DEBUG)\n#define netdev_vdbg\tnetdev_dbg\n#else\n\n#define netdev_vdbg(dev, format, args...)\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\\\n\t\tnetdev_printk(KERN_DEBUG, dev, format, ##args);\t\\\n\t0;\t\t\t\t\t\t\t\\\n})\n#endif\n\n/*\n * netdev_WARN() acts like dev_printk(), but with the key difference\n * of using a WARN/WARN_ON to get the message out, including the\n * file/line information and a backtrace.\n */\n#define netdev_WARN(dev, format, args...)\t\t\t\\\n\tWARN(1, \"netdevice: %s%s: \" format, netdev_name(dev),\t\\\n\t     netdev_reg_state(dev), ##args)\n\n#define netdev_WARN_ONCE(dev, format, args...)\t\t\t\t\\\n\tWARN_ONCE(1, \"netdevice: %s%s: \" format, netdev_name(dev),\t\\\n\t\t  netdev_reg_state(dev), ##args)\n\n/* netif printk helpers, similar to netdev_printk */\n\n#define netif_printk(priv, type, level, dev, fmt, args...)\t\\\ndo {\t\t\t\t\t  \t\t\t\\\n\tif (netif_msg_##type(priv))\t\t\t\t\\\n\t\tnetdev_printk(level, (dev), fmt, ##args);\t\\\n} while (0)\n\n#define netif_level(level, priv, type, dev, fmt, args...)\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (netif_msg_##type(priv))\t\t\t\t\\\n\t\tnetdev_##level(dev, fmt, ##args);\t\t\\\n} while (0)\n\n#define netif_emerg(priv, type, dev, fmt, args...)\t\t\\\n\tnetif_level(emerg, priv, type, dev, fmt, ##args)\n#define netif_alert(priv, type, dev, fmt, args...)\t\t\\\n\tnetif_level(alert, priv, type, dev, fmt, ##args)\n#define netif_crit(priv, type, dev, fmt, args...)\t\t\\\n\tnetif_level(crit, priv, type, dev, fmt, ##args)\n#define netif_err(priv, type, dev, fmt, args...)\t\t\\\n\tnetif_level(err, priv, type, dev, fmt, ##args)\n#define netif_warn(priv, type, dev, fmt, args...)\t\t\\\n\tnetif_level(warn, priv, type, dev, fmt, ##args)\n#define netif_notice(priv, type, dev, fmt, args...)\t\t\\\n\tnetif_level(notice, priv, type, dev, fmt, ##args)\n#define netif_info(priv, type, dev, fmt, args...)\t\t\\\n\tnetif_level(info, priv, type, dev, fmt, ##args)\n\n#if defined(CONFIG_DYNAMIC_DEBUG) || \\\n\t(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))\n#define netif_dbg(priv, type, netdev, format, args...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (netif_msg_##type(priv))\t\t\t\t\\\n\t\tdynamic_netdev_dbg(netdev, format, ##args);\t\\\n} while (0)\n#elif defined(DEBUG)\n#define netif_dbg(priv, type, dev, format, args...)\t\t\\\n\tnetif_printk(priv, type, KERN_DEBUG, dev, format, ##args)\n#else\n#define netif_dbg(priv, type, dev, format, args...)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\t\\\n\t\tnetif_printk(priv, type, KERN_DEBUG, dev, format, ##args); \\\n\t0;\t\t\t\t\t\t\t\t\\\n})\n#endif\n\n/* if @cond then downgrade to debug, else print at @level */\n#define netif_cond_dbg(priv, type, netdev, cond, level, fmt, args...)     \\\n\tdo {                                                              \\\n\t\tif (cond)                                                 \\\n\t\t\tnetif_dbg(priv, type, netdev, fmt, ##args);       \\\n\t\telse                                                      \\\n\t\t\tnetif_ ## level(priv, type, netdev, fmt, ##args); \\\n\t} while (0)\n\n#if defined(VERBOSE_DEBUG)\n#define netif_vdbg\tnetif_dbg\n#else\n#define netif_vdbg(priv, type, dev, format, args...)\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\\\n\t\tnetif_printk(priv, type, KERN_DEBUG, dev, format, ##args); \\\n\t0;\t\t\t\t\t\t\t\\\n})\n#endif\n\n/*\n *\tThe list of packet types we will receive (as opposed to discard)\n *\tand the routines to invoke.\n *\n *\tWhy 16. Because with 16 the only overlap we get on a hash of the\n *\tlow nibble of the protocol value is RARP/SNAP/X.25.\n *\n *\t\t0800\tIP\n *\t\t0001\t802.3\n *\t\t0002\tAX.25\n *\t\t0004\t802.2\n *\t\t8035\tRARP\n *\t\t0005\tSNAP\n *\t\t0805\tX.25\n *\t\t0806\tARP\n *\t\t8137\tIPX\n *\t\t0009\tLocaltalk\n *\t\t86DD\tIPv6\n */\n#define PTYPE_HASH_SIZE\t(16)\n#define PTYPE_HASH_MASK\t(PTYPE_HASH_SIZE - 1)\n\nextern struct net_device *blackhole_netdev;\n\n#endif\t/* _LINUX_NETDEVICE_H */\n"}}, "reports": [{"events": [{"location": {"col": 19, "file": 0, "line": 915}, "message": "Value stored to 'hw' during its initialization is never read"}, {"location": {"col": 19, "file": 0, "line": 915}, "message": "Value stored to 'hw' during its initialization is never read"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/intel/e1000e/netdev.c", "reportHash": "9523809729ce0db33cda6bee8f6aa748", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 0, "line": 1309}, "message": "Value stored to 'hw' during its initialization is never read"}, {"location": {"col": 19, "file": 0, "line": 1309}, "message": "Value stored to 'hw' during its initialization is never read"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/intel/e1000e/netdev.c", "reportHash": "9523809729ce0db33cda6bee8f6aa748", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 40, "file": 1, "line": 40}, "message": "expanded from macro 'prefetch'"}, {"location": {"col": 2, "file": 0, "line": 1327}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 7, "file": 0, "line": 1328}, "message": "Assuming the condition is false"}, {"location": {"col": 3, "file": 0, "line": 1328}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1338}, "message": "Assuming 'i' is equal to field 'count'"}, {"location": {"col": 3, "file": 0, "line": 1338}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 1352}, "message": "Assuming the condition is false"}, {"location": {"col": 3, "file": 0, "line": 1352}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1355}, "message": "Assuming the condition is true"}, {"location": {"col": 3, "file": 0, "line": 1355}, "message": "Taking true branch"}, {"location": {"col": 4, "file": 0, "line": 1356}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 2, "line": 30}, "message": "expanded from macro 'e_dbg'"}, {"location": {"col": 2, "file": 3, "line": 5170}, "message": "expanded from macro 'netdev_dbg'"}, {"location": {"col": 4, "file": 0, "line": 1358}, "message": "Taking true branch"}, {"location": {"col": 4, "file": 0, "line": 1360}, "message": "Control jumps to line 1464"}, {"location": {"col": 7, "file": 0, "line": 1468}, "message": "'cleaned_count' is < E1000_RX_BUFFER_WRITE"}, {"location": {"col": 3, "file": 0, "line": 1468}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1327}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 7, "file": 0, "line": 1328}, "message": "Assuming the condition is false"}, {"location": {"col": 3, "file": 0, "line": 1328}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1338}, "message": "Assuming 'i' is equal to field 'count'"}, {"location": {"col": 3, "file": 0, "line": 1338}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 1352}, "message": "Assuming the condition is false"}, {"location": {"col": 3, "file": 0, "line": 1352}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1355}, "message": "Assuming the condition is true"}, {"location": {"col": 3, "file": 0, "line": 1355}, "message": "Taking true branch"}, {"location": {"col": 4, "file": 0, "line": 1356}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 2, "line": 30}, "message": "expanded from macro 'e_dbg'"}, {"location": {"col": 2, "file": 3, "line": 5170}, "message": "expanded from macro 'netdev_dbg'"}, {"location": {"col": 4, "file": 0, "line": 1358}, "message": "Taking true branch"}, {"location": {"col": 4, "file": 0, "line": 1360}, "message": "Control jumps to line 1464"}, {"location": {"col": 3, "file": 0, "line": 1465}, "message": "Null pointer value stored to field 'skb'"}, {"location": {"col": 7, "file": 0, "line": 1468}, "message": "'cleaned_count' is < E1000_RX_BUFFER_WRITE"}, {"location": {"col": 3, "file": 0, "line": 1468}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1327}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 7, "file": 0, "line": 1328}, "message": "Assuming the condition is false"}, {"location": {"col": 3, "file": 0, "line": 1328}, "message": "Taking false branch"}, {"location": {"col": 3, "file": 0, "line": 1331}, "message": "Null pointer value stored to 'skb'"}, {"location": {"col": 12, "file": 0, "line": 1335}, "message": "Access to field 'data' results in a dereference of a null pointer (loaded from variable 'skb')"}, {"location": {"col": 40, "file": 1, "line": 40}, "message": "expanded from macro 'prefetch'"}, {"location": {"col": 12, "file": 0, "line": 1335}, "message": "Access to field 'data' results in a dereference of a null pointer (loaded from variable 'skb')"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/intel/e1000e/netdev.c", "reportHash": "934847ec32a4bf5e534c8651081022ef", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 2551}, "message": "Value stored to 'current_itr' is never read"}, {"location": {"col": 3, "file": 0, "line": 2551}, "message": "Value stored to 'current_itr' is never read"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/intel/e1000e/netdev.c", "reportHash": "c54e0498a6f98f96fe9ed9f089b294ff", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 0, "line": 6690}, "message": "Value stored to 'retval' is never read"}, {"location": {"col": 5, "file": 0, "line": 6690}, "message": "Value stored to 'retval' is never read"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/intel/e1000e/netdev.c", "reportHash": "0e896cfae468f8c1ec911cafe5204dcd", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
