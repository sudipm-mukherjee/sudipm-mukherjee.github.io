<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/scsi/lpfc/lpfc_scsi.c", "content": "/*******************************************************************\n * This file is part of the Emulex Linux Device Driver for         *\n * Fibre Channel Host Bus Adapters.                                *\n * Copyright (C) 2017-2020 Broadcom. All Rights Reserved. The term *\n * \u201cBroadcom\u201d refers to Broadcom Inc. and/or its subsidiaries.  *\n * Copyright (C) 2004-2016 Emulex.  All rights reserved.           *\n * EMULEX and SLI are trademarks of Emulex.                        *\n * www.broadcom.com                                                *\n * Portions Copyright (C) 2004-2005 Christoph Hellwig              *\n *                                                                 *\n * This program is free software; you can redistribute it and/or   *\n * modify it under the terms of version 2 of the GNU General       *\n * Public License as published by the Free Software Foundation.    *\n * This program is distributed in the hope that it will be useful. *\n * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *\n * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *\n * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *\n * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *\n * TO BE LEGALLY INVALID.  See the GNU General Public License for  *\n * more details, a copy of which can be found in the file COPYING  *\n * included with this package.                                     *\n *******************************************************************/\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <asm/unaligned.h>\n#include <linux/t10-pi.h>\n#include <linux/crc-t10dif.h>\n#include <net/checksum.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_transport_fc.h>\n\n#include \"lpfc_version.h\"\n#include \"lpfc_hw4.h\"\n#include \"lpfc_hw.h\"\n#include \"lpfc_sli.h\"\n#include \"lpfc_sli4.h\"\n#include \"lpfc_nl.h\"\n#include \"lpfc_disc.h\"\n#include \"lpfc.h\"\n#include \"lpfc_scsi.h\"\n#include \"lpfc_logmsg.h\"\n#include \"lpfc_crtn.h\"\n#include \"lpfc_vport.h\"\n\n#define LPFC_RESET_WAIT  2\n#define LPFC_ABORT_WAIT  2\n\nstatic char *dif_op_str[] = {\n\t\"PROT_NORMAL\",\n\t\"PROT_READ_INSERT\",\n\t\"PROT_WRITE_STRIP\",\n\t\"PROT_READ_STRIP\",\n\t\"PROT_WRITE_INSERT\",\n\t\"PROT_READ_PASS\",\n\t\"PROT_WRITE_PASS\",\n};\n\nstruct scsi_dif_tuple {\n\t__be16 guard_tag;       /* Checksum */\n\t__be16 app_tag;         /* Opaque storage */\n\t__be32 ref_tag;         /* Target LBA or indirect LBA */\n};\n\nstatic struct lpfc_rport_data *\nlpfc_rport_data_from_scsi_device(struct scsi_device *sdev)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)sdev->host->hostdata;\n\n\tif (vport->phba->cfg_fof)\n\t\treturn ((struct lpfc_device_data *)sdev->hostdata)->rport_data;\n\telse\n\t\treturn (struct lpfc_rport_data *)sdev->hostdata;\n}\n\nstatic void\nlpfc_release_scsi_buf_s4(struct lpfc_hba *phba, struct lpfc_io_buf *psb);\nstatic void\nlpfc_release_scsi_buf_s3(struct lpfc_hba *phba, struct lpfc_io_buf *psb);\nstatic int\nlpfc_prot_group_type(struct lpfc_hba *phba, struct scsi_cmnd *sc);\n\nstatic inline unsigned\nlpfc_cmd_blksize(struct scsi_cmnd *sc)\n{\n\treturn sc->device->sector_size;\n}\n\n#define LPFC_CHECK_PROTECT_GUARD\t1\n#define LPFC_CHECK_PROTECT_REF\t\t2\nstatic inline unsigned\nlpfc_cmd_protect(struct scsi_cmnd *sc, int flag)\n{\n\treturn 1;\n}\n\nstatic inline unsigned\nlpfc_cmd_guard_csum(struct scsi_cmnd *sc)\n{\n\tif (lpfc_prot_group_type(NULL, sc) == LPFC_PG_TYPE_NO_DIF)\n\t\treturn 0;\n\tif (scsi_host_get_guard(sc->device->host) == SHOST_DIX_GUARD_IP)\n\t\treturn 1;\n\treturn 0;\n}\n\n/**\n * lpfc_sli4_set_rsp_sgl_last - Set the last bit in the response sge.\n * @phba: Pointer to HBA object.\n * @lpfc_cmd: lpfc scsi command object pointer.\n *\n * This function is called from the lpfc_prep_task_mgmt_cmd function to\n * set the last bit in the response sge entry.\n **/\nstatic void\nlpfc_sli4_set_rsp_sgl_last(struct lpfc_hba *phba,\n\t\t\t\tstruct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct sli4_sge *sgl = (struct sli4_sge *)lpfc_cmd->dma_sgl;\n\tif (sgl) {\n\t\tsgl += 1;\n\t\tsgl->word2 = le32_to_cpu(sgl->word2);\n\t\tbf_set(lpfc_sli4_sge_last, sgl, 1);\n\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t}\n}\n\n/**\n * lpfc_update_stats - Update statistical data for the command completion\n * @vport: The virtual port on which this call is executing.\n * @lpfc_cmd: lpfc scsi command object pointer.\n *\n * This function is called when there is a command completion and this\n * function updates the statistical data for the command completion.\n **/\nstatic void\nlpfc_update_stats(struct lpfc_vport *vport, struct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_rport_data *rdata;\n\tstruct lpfc_nodelist *pnode;\n\tstruct scsi_cmnd *cmd = lpfc_cmd->pCmd;\n\tunsigned long flags;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tunsigned long latency;\n\tint i;\n\n\tif (!vport->stat_data_enabled ||\n\t    vport->stat_data_blocked ||\n\t    (cmd->result))\n\t\treturn;\n\n\tlatency = jiffies_to_msecs((long)jiffies - (long)lpfc_cmd->start_time);\n\trdata = lpfc_cmd->rdata;\n\tpnode = rdata->pnode;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (!pnode ||\n\t    !pnode->lat_data ||\n\t    (phba->bucket_type == LPFC_NO_BUCKET)) {\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\treturn;\n\t}\n\n\tif (phba->bucket_type == LPFC_LINEAR_BUCKET) {\n\t\ti = (latency + phba->bucket_step - 1 - phba->bucket_base)/\n\t\t\tphba->bucket_step;\n\t\t/* check array subscript bounds */\n\t\tif (i < 0)\n\t\t\ti = 0;\n\t\telse if (i >= LPFC_MAX_BUCKET_COUNT)\n\t\t\ti = LPFC_MAX_BUCKET_COUNT - 1;\n\t} else {\n\t\tfor (i = 0; i < LPFC_MAX_BUCKET_COUNT-1; i++)\n\t\t\tif (latency <= (phba->bucket_base +\n\t\t\t\t((1<<i)*phba->bucket_step)))\n\t\t\t\tbreak;\n\t}\n\n\tpnode->lat_data[i].cmd_count++;\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n}\n\n/**\n * lpfc_rampdown_queue_depth - Post RAMP_DOWN_QUEUE event to worker thread\n * @phba: The Hba for which this call is being executed.\n *\n * This routine is called when there is resource error in driver or firmware.\n * This routine posts WORKER_RAMP_DOWN_QUEUE event for @phba. This routine\n * posts at most 1 event each second. This routine wakes up worker thread of\n * @phba to process WORKER_RAM_DOWN_EVENT event.\n *\n * This routine should be called with no lock held.\n **/\nvoid\nlpfc_rampdown_queue_depth(struct lpfc_hba *phba)\n{\n\tunsigned long flags;\n\tuint32_t evt_posted;\n\tunsigned long expires;\n\n\tspin_lock_irqsave(&phba->hbalock, flags);\n\tatomic_inc(&phba->num_rsrc_err);\n\tphba->last_rsrc_error_time = jiffies;\n\n\texpires = phba->last_ramp_down_time + QUEUE_RAMP_DOWN_INTERVAL;\n\tif (time_after(expires, jiffies)) {\n\t\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\t\treturn;\n\t}\n\n\tphba->last_ramp_down_time = jiffies;\n\n\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\n\tspin_lock_irqsave(&phba->pport->work_port_lock, flags);\n\tevt_posted = phba->pport->work_port_events & WORKER_RAMP_DOWN_QUEUE;\n\tif (!evt_posted)\n\t\tphba->pport->work_port_events |= WORKER_RAMP_DOWN_QUEUE;\n\tspin_unlock_irqrestore(&phba->pport->work_port_lock, flags);\n\n\tif (!evt_posted)\n\t\tlpfc_worker_wake_up(phba);\n\treturn;\n}\n\n/**\n * lpfc_ramp_down_queue_handler - WORKER_RAMP_DOWN_QUEUE event handler\n * @phba: The Hba for which this call is being executed.\n *\n * This routine is called to  process WORKER_RAMP_DOWN_QUEUE event for worker\n * thread.This routine reduces queue depth for all scsi device on each vport\n * associated with @phba.\n **/\nvoid\nlpfc_ramp_down_queue_handler(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport **vports;\n\tstruct Scsi_Host  *shost;\n\tstruct scsi_device *sdev;\n\tunsigned long new_queue_depth;\n\tunsigned long num_rsrc_err, num_cmd_success;\n\tint i;\n\n\tnum_rsrc_err = atomic_read(&phba->num_rsrc_err);\n\tnum_cmd_success = atomic_read(&phba->num_cmd_success);\n\n\t/*\n\t * The error and success command counters are global per\n\t * driver instance.  If another handler has already\n\t * operated on this error event, just exit.\n\t */\n\tif (num_rsrc_err == 0)\n\t\treturn;\n\n\tvports = lpfc_create_vport_work_array(phba);\n\tif (vports != NULL)\n\t\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\n\t\t\tshost = lpfc_shost_from_vport(vports[i]);\n\t\t\tshost_for_each_device(sdev, shost) {\n\t\t\t\tnew_queue_depth =\n\t\t\t\t\tsdev->queue_depth * num_rsrc_err /\n\t\t\t\t\t(num_rsrc_err + num_cmd_success);\n\t\t\t\tif (!new_queue_depth)\n\t\t\t\t\tnew_queue_depth = sdev->queue_depth - 1;\n\t\t\t\telse\n\t\t\t\t\tnew_queue_depth = sdev->queue_depth -\n\t\t\t\t\t\t\t\tnew_queue_depth;\n\t\t\t\tscsi_change_queue_depth(sdev, new_queue_depth);\n\t\t\t}\n\t\t}\n\tlpfc_destroy_vport_work_array(phba, vports);\n\tatomic_set(&phba->num_rsrc_err, 0);\n\tatomic_set(&phba->num_cmd_success, 0);\n}\n\n/**\n * lpfc_scsi_dev_block - set all scsi hosts to block state\n * @phba: Pointer to HBA context object.\n *\n * This function walks vport list and set each SCSI host to block state\n * by invoking fc_remote_port_delete() routine. This function is invoked\n * with EEH when device's PCI slot has been permanently disabled.\n **/\nvoid\nlpfc_scsi_dev_block(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport **vports;\n\tstruct Scsi_Host  *shost;\n\tstruct scsi_device *sdev;\n\tstruct fc_rport *rport;\n\tint i;\n\n\tvports = lpfc_create_vport_work_array(phba);\n\tif (vports != NULL)\n\t\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\n\t\t\tshost = lpfc_shost_from_vport(vports[i]);\n\t\t\tshost_for_each_device(sdev, shost) {\n\t\t\t\trport = starget_to_rport(scsi_target(sdev));\n\t\t\t\tfc_remote_port_delete(rport);\n\t\t\t}\n\t\t}\n\tlpfc_destroy_vport_work_array(phba, vports);\n}\n\n/**\n * lpfc_new_scsi_buf_s3 - Scsi buffer allocator for HBA with SLI3 IF spec\n * @vport: The virtual port for which this call being executed.\n * @num_to_alloc: The requested number of buffers to allocate.\n *\n * This routine allocates a scsi buffer for device with SLI-3 interface spec,\n * the scsi buffer contains all the necessary information needed to initiate\n * a SCSI I/O. The non-DMAable buffer region contains information to build\n * the IOCB. The DMAable region contains memory for the FCP CMND, FCP RSP,\n * and the initial BPL. In addition to allocating memory, the FCP CMND and\n * FCP RSP BDEs are setup in the BPL and the BPL BDE is setup in the IOCB.\n *\n * Return codes:\n *   int - number of scsi buffers that were allocated.\n *   0 = failure, less than num_to_alloc is a partial failure.\n **/\nstatic int\nlpfc_new_scsi_buf_s3(struct lpfc_vport *vport, int num_to_alloc)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_io_buf *psb;\n\tstruct ulp_bde64 *bpl;\n\tIOCB_t *iocb;\n\tdma_addr_t pdma_phys_fcp_cmd;\n\tdma_addr_t pdma_phys_fcp_rsp;\n\tdma_addr_t pdma_phys_sgl;\n\tuint16_t iotag;\n\tint bcnt, bpl_size;\n\n\tbpl_size = phba->cfg_sg_dma_buf_size -\n\t\t(sizeof(struct fcp_cmnd) + sizeof(struct fcp_rsp));\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t \"9067 ALLOC %d scsi_bufs: %d (%d + %d + %d)\\n\",\n\t\t\t num_to_alloc, phba->cfg_sg_dma_buf_size,\n\t\t\t (int)sizeof(struct fcp_cmnd),\n\t\t\t (int)sizeof(struct fcp_rsp), bpl_size);\n\n\tfor (bcnt = 0; bcnt < num_to_alloc; bcnt++) {\n\t\tpsb = kzalloc(sizeof(struct lpfc_io_buf), GFP_KERNEL);\n\t\tif (!psb)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get memory from the pci pool to map the virt space to pci\n\t\t * bus space for an I/O.  The DMA buffer includes space for the\n\t\t * struct fcp_cmnd, struct fcp_rsp and the number of bde's\n\t\t * necessary to support the sg_tablesize.\n\t\t */\n\t\tpsb->data = dma_pool_zalloc(phba->lpfc_sg_dma_buf_pool,\n\t\t\t\t\tGFP_KERNEL, &psb->dma_handle);\n\t\tif (!psb->data) {\n\t\t\tkfree(psb);\n\t\t\tbreak;\n\t\t}\n\n\n\t\t/* Allocate iotag for psb->cur_iocbq. */\n\t\tiotag = lpfc_sli_next_iotag(phba, &psb->cur_iocbq);\n\t\tif (iotag == 0) {\n\t\t\tdma_pool_free(phba->lpfc_sg_dma_buf_pool,\n\t\t\t\t      psb->data, psb->dma_handle);\n\t\t\tkfree(psb);\n\t\t\tbreak;\n\t\t}\n\t\tpsb->cur_iocbq.iocb_flag |= LPFC_IO_FCP;\n\n\t\tpsb->fcp_cmnd = psb->data;\n\t\tpsb->fcp_rsp = psb->data + sizeof(struct fcp_cmnd);\n\t\tpsb->dma_sgl = psb->data + sizeof(struct fcp_cmnd) +\n\t\t\tsizeof(struct fcp_rsp);\n\n\t\t/* Initialize local short-hand pointers. */\n\t\tbpl = (struct ulp_bde64 *)psb->dma_sgl;\n\t\tpdma_phys_fcp_cmd = psb->dma_handle;\n\t\tpdma_phys_fcp_rsp = psb->dma_handle + sizeof(struct fcp_cmnd);\n\t\tpdma_phys_sgl = psb->dma_handle + sizeof(struct fcp_cmnd) +\n\t\t\tsizeof(struct fcp_rsp);\n\n\t\t/*\n\t\t * The first two bdes are the FCP_CMD and FCP_RSP. The balance\n\t\t * are sg list bdes.  Initialize the first two and leave the\n\t\t * rest for queuecommand.\n\t\t */\n\t\tbpl[0].addrHigh = le32_to_cpu(putPaddrHigh(pdma_phys_fcp_cmd));\n\t\tbpl[0].addrLow = le32_to_cpu(putPaddrLow(pdma_phys_fcp_cmd));\n\t\tbpl[0].tus.f.bdeSize = sizeof(struct fcp_cmnd);\n\t\tbpl[0].tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t\tbpl[0].tus.w = le32_to_cpu(bpl[0].tus.w);\n\n\t\t/* Setup the physical region for the FCP RSP */\n\t\tbpl[1].addrHigh = le32_to_cpu(putPaddrHigh(pdma_phys_fcp_rsp));\n\t\tbpl[1].addrLow = le32_to_cpu(putPaddrLow(pdma_phys_fcp_rsp));\n\t\tbpl[1].tus.f.bdeSize = sizeof(struct fcp_rsp);\n\t\tbpl[1].tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t\tbpl[1].tus.w = le32_to_cpu(bpl[1].tus.w);\n\n\t\t/*\n\t\t * Since the IOCB for the FCP I/O is built into this\n\t\t * lpfc_scsi_buf, initialize it with all known data now.\n\t\t */\n\t\tiocb = &psb->cur_iocbq.iocb;\n\t\tiocb->un.fcpi64.bdl.ulpIoTag32 = 0;\n\t\tif ((phba->sli_rev == 3) &&\n\t\t\t\t!(phba->sli3_options & LPFC_SLI3_BG_ENABLED)) {\n\t\t\t/* fill in immediate fcp command BDE */\n\t\t\tiocb->un.fcpi64.bdl.bdeFlags = BUFF_TYPE_BDE_IMMED;\n\t\t\tiocb->un.fcpi64.bdl.bdeSize = sizeof(struct fcp_cmnd);\n\t\t\tiocb->un.fcpi64.bdl.addrLow = offsetof(IOCB_t,\n\t\t\t\t\tunsli3.fcp_ext.icd);\n\t\t\tiocb->un.fcpi64.bdl.addrHigh = 0;\n\t\t\tiocb->ulpBdeCount = 0;\n\t\t\tiocb->ulpLe = 0;\n\t\t\t/* fill in response BDE */\n\t\t\tiocb->unsli3.fcp_ext.rbde.tus.f.bdeFlags =\n\t\t\t\t\t\t\tBUFF_TYPE_BDE_64;\n\t\t\tiocb->unsli3.fcp_ext.rbde.tus.f.bdeSize =\n\t\t\t\tsizeof(struct fcp_rsp);\n\t\t\tiocb->unsli3.fcp_ext.rbde.addrLow =\n\t\t\t\tputPaddrLow(pdma_phys_fcp_rsp);\n\t\t\tiocb->unsli3.fcp_ext.rbde.addrHigh =\n\t\t\t\tputPaddrHigh(pdma_phys_fcp_rsp);\n\t\t} else {\n\t\t\tiocb->un.fcpi64.bdl.bdeFlags = BUFF_TYPE_BLP_64;\n\t\t\tiocb->un.fcpi64.bdl.bdeSize =\n\t\t\t\t\t(2 * sizeof(struct ulp_bde64));\n\t\t\tiocb->un.fcpi64.bdl.addrLow =\n\t\t\t\t\tputPaddrLow(pdma_phys_sgl);\n\t\t\tiocb->un.fcpi64.bdl.addrHigh =\n\t\t\t\t\tputPaddrHigh(pdma_phys_sgl);\n\t\t\tiocb->ulpBdeCount = 1;\n\t\t\tiocb->ulpLe = 1;\n\t\t}\n\t\tiocb->ulpClass = CLASS3;\n\t\tpsb->status = IOSTAT_SUCCESS;\n\t\t/* Put it back into the SCSI buffer list */\n\t\tpsb->cur_iocbq.context1  = psb;\n\t\tspin_lock_init(&psb->buf_lock);\n\t\tlpfc_release_scsi_buf_s3(phba, psb);\n\n\t}\n\n\treturn bcnt;\n}\n\n/**\n * lpfc_sli4_vport_delete_fcp_xri_aborted -Remove all ndlp references for vport\n * @vport: pointer to lpfc vport data structure.\n *\n * This routine is invoked by the vport cleanup for deletions and the cleanup\n * for an ndlp on removal.\n **/\nvoid\nlpfc_sli4_vport_delete_fcp_xri_aborted(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_io_buf *psb, *next_psb;\n\tstruct lpfc_sli4_hdw_queue *qp;\n\tunsigned long iflag = 0;\n\tint idx;\n\n\tif (!(vport->cfg_enable_fc4_type & LPFC_ENABLE_FCP))\n\t\treturn;\n\n\tspin_lock_irqsave(&phba->hbalock, iflag);\n\tfor (idx = 0; idx < phba->cfg_hdw_queue; idx++) {\n\t\tqp = &phba->sli4_hba.hdwq[idx];\n\n\t\tspin_lock(&qp->abts_io_buf_list_lock);\n\t\tlist_for_each_entry_safe(psb, next_psb,\n\t\t\t\t\t &qp->lpfc_abts_io_buf_list, list) {\n\t\t\tif (psb->cur_iocbq.iocb_flag & LPFC_IO_NVME)\n\t\t\t\tcontinue;\n\n\t\t\tif (psb->rdata && psb->rdata->pnode &&\n\t\t\t    psb->rdata->pnode->vport == vport)\n\t\t\t\tpsb->rdata = NULL;\n\t\t}\n\t\tspin_unlock(&qp->abts_io_buf_list_lock);\n\t}\n\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n}\n\n/**\n * lpfc_sli4_io_xri_aborted - Fast-path process of fcp xri abort\n * @phba: pointer to lpfc hba data structure.\n * @axri: pointer to the fcp xri abort wcqe structure.\n * @idx: index into hdwq\n *\n * This routine is invoked by the worker thread to process a SLI4 fast-path\n * FCP or NVME aborted xri.\n **/\nvoid\nlpfc_sli4_io_xri_aborted(struct lpfc_hba *phba,\n\t\t\t struct sli4_wcqe_xri_aborted *axri, int idx)\n{\n\tuint16_t xri = bf_get(lpfc_wcqe_xa_xri, axri);\n\tuint16_t rxid = bf_get(lpfc_wcqe_xa_remote_xid, axri);\n\tstruct lpfc_io_buf *psb, *next_psb;\n\tstruct lpfc_sli4_hdw_queue *qp;\n\tunsigned long iflag = 0;\n\tstruct lpfc_iocbq *iocbq;\n\tint i;\n\tstruct lpfc_nodelist *ndlp;\n\tint rrq_empty = 0;\n\tstruct lpfc_sli_ring *pring = phba->sli4_hba.els_wq->pring;\n\n\tif (!(phba->cfg_enable_fc4_type & LPFC_ENABLE_FCP))\n\t\treturn;\n\n\tqp = &phba->sli4_hba.hdwq[idx];\n\tspin_lock_irqsave(&phba->hbalock, iflag);\n\tspin_lock(&qp->abts_io_buf_list_lock);\n\tlist_for_each_entry_safe(psb, next_psb,\n\t\t&qp->lpfc_abts_io_buf_list, list) {\n\t\tif (psb->cur_iocbq.sli4_xritag == xri) {\n\t\t\tlist_del_init(&psb->list);\n\t\t\tpsb->flags &= ~LPFC_SBUF_XBUSY;\n\t\t\tpsb->status = IOSTAT_SUCCESS;\n\t\t\tif (psb->cur_iocbq.iocb_flag & LPFC_IO_NVME) {\n\t\t\t\tqp->abts_nvme_io_bufs--;\n\t\t\t\tspin_unlock(&qp->abts_io_buf_list_lock);\n\t\t\t\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n\t\t\t\tlpfc_sli4_nvme_xri_aborted(phba, axri, psb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tqp->abts_scsi_io_bufs--;\n\t\t\tspin_unlock(&qp->abts_io_buf_list_lock);\n\n\t\t\tif (psb->rdata && psb->rdata->pnode)\n\t\t\t\tndlp = psb->rdata->pnode;\n\t\t\telse\n\t\t\t\tndlp = NULL;\n\n\t\t\trrq_empty = list_empty(&phba->active_rrq_list);\n\t\t\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n\t\t\tif (ndlp) {\n\t\t\t\tlpfc_set_rrq_active(phba, ndlp,\n\t\t\t\t\tpsb->cur_iocbq.sli4_lxritag, rxid, 1);\n\t\t\t\tlpfc_sli4_abts_err_handler(phba, ndlp, axri);\n\t\t\t}\n\t\t\tlpfc_release_scsi_buf_s4(phba, psb);\n\t\t\tif (rrq_empty)\n\t\t\t\tlpfc_worker_wake_up(phba);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&qp->abts_io_buf_list_lock);\n\tfor (i = 1; i <= phba->sli.last_iotag; i++) {\n\t\tiocbq = phba->sli.iocbq_lookup[i];\n\n\t\tif (!(iocbq->iocb_flag & LPFC_IO_FCP) ||\n\t\t    (iocbq->iocb_flag & LPFC_IO_LIBDFC))\n\t\t\tcontinue;\n\t\tif (iocbq->sli4_xritag != xri)\n\t\t\tcontinue;\n\t\tpsb = container_of(iocbq, struct lpfc_io_buf, cur_iocbq);\n\t\tpsb->flags &= ~LPFC_SBUF_XBUSY;\n\t\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n\t\tif (!list_empty(&pring->txq))\n\t\t\tlpfc_worker_wake_up(phba);\n\t\treturn;\n\n\t}\n\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n}\n\n/**\n * lpfc_get_scsi_buf_s3 - Get a scsi buffer from lpfc_scsi_buf_list of the HBA\n * @phba: The HBA for which this call is being executed.\n * @ndlp: pointer to a node-list data structure.\n * @cmnd: Pointer to scsi_cmnd data structure.\n *\n * This routine removes a scsi buffer from head of @phba lpfc_scsi_buf_list list\n * and returns to caller.\n *\n * Return codes:\n *   NULL - Error\n *   Pointer to lpfc_scsi_buf - Success\n **/\nstatic struct lpfc_io_buf *\nlpfc_get_scsi_buf_s3(struct lpfc_hba *phba, struct lpfc_nodelist *ndlp,\n\t\t     struct scsi_cmnd *cmnd)\n{\n\tstruct lpfc_io_buf *lpfc_cmd = NULL;\n\tstruct list_head *scsi_buf_list_get = &phba->lpfc_scsi_buf_list_get;\n\tunsigned long iflag = 0;\n\n\tspin_lock_irqsave(&phba->scsi_buf_list_get_lock, iflag);\n\tlist_remove_head(scsi_buf_list_get, lpfc_cmd, struct lpfc_io_buf,\n\t\t\t list);\n\tif (!lpfc_cmd) {\n\t\tspin_lock(&phba->scsi_buf_list_put_lock);\n\t\tlist_splice(&phba->lpfc_scsi_buf_list_put,\n\t\t\t    &phba->lpfc_scsi_buf_list_get);\n\t\tINIT_LIST_HEAD(&phba->lpfc_scsi_buf_list_put);\n\t\tlist_remove_head(scsi_buf_list_get, lpfc_cmd,\n\t\t\t\t struct lpfc_io_buf, list);\n\t\tspin_unlock(&phba->scsi_buf_list_put_lock);\n\t}\n\tspin_unlock_irqrestore(&phba->scsi_buf_list_get_lock, iflag);\n\n\tif (lpfc_ndlp_check_qdepth(phba, ndlp) && lpfc_cmd) {\n\t\tatomic_inc(&ndlp->cmd_pending);\n\t\tlpfc_cmd->flags |= LPFC_SBUF_BUMP_QDEPTH;\n\t}\n\treturn  lpfc_cmd;\n}\n/**\n * lpfc_get_scsi_buf_s4 - Get a scsi buffer from io_buf_list of the HBA\n * @phba: The HBA for which this call is being executed.\n * @ndlp: pointer to a node-list data structure.\n * @cmnd: Pointer to scsi_cmnd data structure.\n *\n * This routine removes a scsi buffer from head of @hdwq io_buf_list\n * and returns to caller.\n *\n * Return codes:\n *   NULL - Error\n *   Pointer to lpfc_scsi_buf - Success\n **/\nstatic struct lpfc_io_buf *\nlpfc_get_scsi_buf_s4(struct lpfc_hba *phba, struct lpfc_nodelist *ndlp,\n\t\t     struct scsi_cmnd *cmnd)\n{\n\tstruct lpfc_io_buf *lpfc_cmd;\n\tstruct lpfc_sli4_hdw_queue *qp;\n\tstruct sli4_sge *sgl;\n\tdma_addr_t pdma_phys_fcp_rsp;\n\tdma_addr_t pdma_phys_fcp_cmd;\n\tuint32_t cpu, idx;\n\tint tag;\n\tstruct fcp_cmd_rsp_buf *tmp = NULL;\n\n\tcpu = raw_smp_processor_id();\n\tif (cmnd && phba->cfg_fcp_io_sched == LPFC_FCP_SCHED_BY_HDWQ) {\n\t\ttag = blk_mq_unique_tag(cmnd->request);\n\t\tidx = blk_mq_unique_tag_to_hwq(tag);\n\t} else {\n\t\tidx = phba->sli4_hba.cpu_map[cpu].hdwq;\n\t}\n\n\tlpfc_cmd = lpfc_get_io_buf(phba, ndlp, idx,\n\t\t\t\t   !phba->cfg_xri_rebalancing);\n\tif (!lpfc_cmd) {\n\t\tqp = &phba->sli4_hba.hdwq[idx];\n\t\tqp->empty_io_bufs++;\n\t\treturn NULL;\n\t}\n\n\t/* Setup key fields in buffer that may have been changed\n\t * if other protocols used this buffer.\n\t */\n\tlpfc_cmd->cur_iocbq.iocb_flag = LPFC_IO_FCP;\n\tlpfc_cmd->prot_seg_cnt = 0;\n\tlpfc_cmd->seg_cnt = 0;\n\tlpfc_cmd->timeout = 0;\n\tlpfc_cmd->flags = 0;\n\tlpfc_cmd->start_time = jiffies;\n\tlpfc_cmd->waitq = NULL;\n\tlpfc_cmd->cpu = cpu;\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tlpfc_cmd->prot_data_type = 0;\n#endif\n\ttmp = lpfc_get_cmd_rsp_buf_per_hdwq(phba, lpfc_cmd);\n\tif (!tmp) {\n\t\tlpfc_release_io_buf(phba, lpfc_cmd, lpfc_cmd->hdwq);\n\t\treturn NULL;\n\t}\n\n\tlpfc_cmd->fcp_cmnd = tmp->fcp_cmnd;\n\tlpfc_cmd->fcp_rsp = tmp->fcp_rsp;\n\n\t/*\n\t * The first two SGEs are the FCP_CMD and FCP_RSP.\n\t * The balance are sg list bdes. Initialize the\n\t * first two and leave the rest for queuecommand.\n\t */\n\tsgl = (struct sli4_sge *)lpfc_cmd->dma_sgl;\n\tpdma_phys_fcp_cmd = tmp->fcp_cmd_rsp_dma_handle;\n\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(pdma_phys_fcp_cmd));\n\tsgl->addr_lo = cpu_to_le32(putPaddrLow(pdma_phys_fcp_cmd));\n\tsgl->word2 = le32_to_cpu(sgl->word2);\n\tbf_set(lpfc_sli4_sge_last, sgl, 0);\n\tsgl->word2 = cpu_to_le32(sgl->word2);\n\tsgl->sge_len = cpu_to_le32(sizeof(struct fcp_cmnd));\n\tsgl++;\n\n\t/* Setup the physical region for the FCP RSP */\n\tpdma_phys_fcp_rsp = pdma_phys_fcp_cmd + sizeof(struct fcp_cmnd);\n\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(pdma_phys_fcp_rsp));\n\tsgl->addr_lo = cpu_to_le32(putPaddrLow(pdma_phys_fcp_rsp));\n\tsgl->word2 = le32_to_cpu(sgl->word2);\n\tbf_set(lpfc_sli4_sge_last, sgl, 1);\n\tsgl->word2 = cpu_to_le32(sgl->word2);\n\tsgl->sge_len = cpu_to_le32(sizeof(struct fcp_rsp));\n\n\tif (lpfc_ndlp_check_qdepth(phba, ndlp)) {\n\t\tatomic_inc(&ndlp->cmd_pending);\n\t\tlpfc_cmd->flags |= LPFC_SBUF_BUMP_QDEPTH;\n\t}\n\treturn  lpfc_cmd;\n}\n/**\n * lpfc_get_scsi_buf - Get a scsi buffer from lpfc_scsi_buf_list of the HBA\n * @phba: The HBA for which this call is being executed.\n * @ndlp: pointer to a node-list data structure.\n * @cmnd: Pointer to scsi_cmnd data structure.\n *\n * This routine removes a scsi buffer from head of @phba lpfc_scsi_buf_list list\n * and returns to caller.\n *\n * Return codes:\n *   NULL - Error\n *   Pointer to lpfc_scsi_buf - Success\n **/\nstatic struct lpfc_io_buf*\nlpfc_get_scsi_buf(struct lpfc_hba *phba, struct lpfc_nodelist *ndlp,\n\t\t  struct scsi_cmnd *cmnd)\n{\n\treturn  phba->lpfc_get_scsi_buf(phba, ndlp, cmnd);\n}\n\n/**\n * lpfc_release_scsi_buf - Return a scsi buffer back to hba scsi buf list\n * @phba: The Hba for which this call is being executed.\n * @psb: The scsi buffer which is being released.\n *\n * This routine releases @psb scsi buffer by adding it to tail of @phba\n * lpfc_scsi_buf_list list.\n **/\nstatic void\nlpfc_release_scsi_buf_s3(struct lpfc_hba *phba, struct lpfc_io_buf *psb)\n{\n\tunsigned long iflag = 0;\n\n\tpsb->seg_cnt = 0;\n\tpsb->prot_seg_cnt = 0;\n\n\tspin_lock_irqsave(&phba->scsi_buf_list_put_lock, iflag);\n\tpsb->pCmd = NULL;\n\tpsb->cur_iocbq.iocb_flag = LPFC_IO_FCP;\n\tlist_add_tail(&psb->list, &phba->lpfc_scsi_buf_list_put);\n\tspin_unlock_irqrestore(&phba->scsi_buf_list_put_lock, iflag);\n}\n\n/**\n * lpfc_release_scsi_buf_s4: Return a scsi buffer back to hba scsi buf list.\n * @phba: The Hba for which this call is being executed.\n * @psb: The scsi buffer which is being released.\n *\n * This routine releases @psb scsi buffer by adding it to tail of @hdwq\n * io_buf_list list. For SLI4 XRI's are tied to the scsi buffer\n * and cannot be reused for at least RA_TOV amount of time if it was\n * aborted.\n **/\nstatic void\nlpfc_release_scsi_buf_s4(struct lpfc_hba *phba, struct lpfc_io_buf *psb)\n{\n\tstruct lpfc_sli4_hdw_queue *qp;\n\tunsigned long iflag = 0;\n\n\tpsb->seg_cnt = 0;\n\tpsb->prot_seg_cnt = 0;\n\n\tqp = psb->hdwq;\n\tif (psb->flags & LPFC_SBUF_XBUSY) {\n\t\tspin_lock_irqsave(&qp->abts_io_buf_list_lock, iflag);\n\t\tpsb->pCmd = NULL;\n\t\tlist_add_tail(&psb->list, &qp->lpfc_abts_io_buf_list);\n\t\tqp->abts_scsi_io_bufs++;\n\t\tspin_unlock_irqrestore(&qp->abts_io_buf_list_lock, iflag);\n\t} else {\n\t\tlpfc_release_io_buf(phba, (struct lpfc_io_buf *)psb, qp);\n\t}\n}\n\n/**\n * lpfc_release_scsi_buf: Return a scsi buffer back to hba scsi buf list.\n * @phba: The Hba for which this call is being executed.\n * @psb: The scsi buffer which is being released.\n *\n * This routine releases @psb scsi buffer by adding it to tail of @phba\n * lpfc_scsi_buf_list list.\n **/\nstatic void\nlpfc_release_scsi_buf(struct lpfc_hba *phba, struct lpfc_io_buf *psb)\n{\n\tif ((psb->flags & LPFC_SBUF_BUMP_QDEPTH) && psb->ndlp)\n\t\tatomic_dec(&psb->ndlp->cmd_pending);\n\n\tpsb->flags &= ~LPFC_SBUF_BUMP_QDEPTH;\n\tphba->lpfc_release_scsi_buf(phba, psb);\n}\n\n/**\n * lpfc_fcpcmd_to_iocb - copy the fcp_cmd data into the IOCB\n * @data: A pointer to the immediate command data portion of the IOCB.\n * @fcp_cmnd: The FCP Command that is provided by the SCSI layer.\n *\n * The routine copies the entire FCP command from @fcp_cmnd to @data while\n * byte swapping the data to big endian format for transmission on the wire.\n **/\nstatic void\nlpfc_fcpcmd_to_iocb(u8 *data, struct fcp_cmnd *fcp_cmnd)\n{\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < sizeof(struct fcp_cmnd);\n\t     i += sizeof(uint32_t), j++) {\n\t\t((uint32_t *)data)[j] = cpu_to_be32(((uint32_t *)fcp_cmnd)[j]);\n\t}\n}\n\n/**\n * lpfc_scsi_prep_dma_buf_s3 - DMA mapping for scsi buffer to SLI3 IF spec\n * @phba: The Hba for which this call is being executed.\n * @lpfc_cmd: The scsi buffer which is going to be mapped.\n *\n * This routine does the pci dma mapping for scatter-gather list of scsi cmnd\n * field of @lpfc_cmd for device with SLI-3 interface spec. This routine scans\n * through sg elements and format the bde. This routine also initializes all\n * IOCB fields which are dependent on scsi command request buffer.\n *\n * Return codes:\n *   1 - Error\n *   0 - Success\n **/\nstatic int\nlpfc_scsi_prep_dma_buf_s3(struct lpfc_hba *phba, struct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\n\tstruct scatterlist *sgel = NULL;\n\tstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\n\tstruct ulp_bde64 *bpl = (struct ulp_bde64 *)lpfc_cmd->dma_sgl;\n\tstruct lpfc_iocbq *iocbq = &lpfc_cmd->cur_iocbq;\n\tIOCB_t *iocb_cmd = &lpfc_cmd->cur_iocbq.iocb;\n\tstruct ulp_bde64 *data_bde = iocb_cmd->unsli3.fcp_ext.dbde;\n\tdma_addr_t physaddr;\n\tuint32_t num_bde = 0;\n\tint nseg, datadir = scsi_cmnd->sc_data_direction;\n\n\t/*\n\t * There are three possibilities here - use scatter-gather segment, use\n\t * the single mapping, or neither.  Start the lpfc command prep by\n\t * bumping the bpl beyond the fcp_cmnd and fcp_rsp regions to the first\n\t * data bde entry.\n\t */\n\tbpl += 2;\n\tif (scsi_sg_count(scsi_cmnd)) {\n\t\t/*\n\t\t * The driver stores the segment count returned from pci_map_sg\n\t\t * because this a count of dma-mappings used to map the use_sg\n\t\t * pages.  They are not guaranteed to be the same for those\n\t\t * architectures that implement an IOMMU.\n\t\t */\n\n\t\tnseg = dma_map_sg(&phba->pcidev->dev, scsi_sglist(scsi_cmnd),\n\t\t\t\t  scsi_sg_count(scsi_cmnd), datadir);\n\t\tif (unlikely(!nseg))\n\t\t\treturn 1;\n\n\t\tlpfc_cmd->seg_cnt = nseg;\n\t\tif (lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9064 BLKGRD: %s: Too many sg segments\"\n\t\t\t\t\t\" from dma_map_sg.  Config %d, seg_cnt\"\n\t\t\t\t\t\" %d\\n\", __func__, phba->cfg_sg_seg_cnt,\n\t\t\t\t\tlpfc_cmd->seg_cnt);\n\t\t\tWARN_ON_ONCE(lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt);\n\t\t\tlpfc_cmd->seg_cnt = 0;\n\t\t\tscsi_dma_unmap(scsi_cmnd);\n\t\t\treturn 2;\n\t\t}\n\n\t\t/*\n\t\t * The driver established a maximum scatter-gather segment count\n\t\t * during probe that limits the number of sg elements in any\n\t\t * single scsi command.  Just run through the seg_cnt and format\n\t\t * the bde's.\n\t\t * When using SLI-3 the driver will try to fit all the BDEs into\n\t\t * the IOCB. If it can't then the BDEs get added to a BPL as it\n\t\t * does for SLI-2 mode.\n\t\t */\n\t\tscsi_for_each_sg(scsi_cmnd, sgel, nseg, num_bde) {\n\t\t\tphysaddr = sg_dma_address(sgel);\n\t\t\tif (phba->sli_rev == 3 &&\n\t\t\t    !(phba->sli3_options & LPFC_SLI3_BG_ENABLED) &&\n\t\t\t    !(iocbq->iocb_flag & DSS_SECURITY_OP) &&\n\t\t\t    nseg <= LPFC_EXT_DATA_BDE_COUNT) {\n\t\t\t\tdata_bde->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t\t\t\tdata_bde->tus.f.bdeSize = sg_dma_len(sgel);\n\t\t\t\tdata_bde->addrLow = putPaddrLow(physaddr);\n\t\t\t\tdata_bde->addrHigh = putPaddrHigh(physaddr);\n\t\t\t\tdata_bde++;\n\t\t\t} else {\n\t\t\t\tbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t\t\t\tbpl->tus.f.bdeSize = sg_dma_len(sgel);\n\t\t\t\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\t\t\t\tbpl->addrLow =\n\t\t\t\t\tle32_to_cpu(putPaddrLow(physaddr));\n\t\t\t\tbpl->addrHigh =\n\t\t\t\t\tle32_to_cpu(putPaddrHigh(physaddr));\n\t\t\t\tbpl++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Finish initializing those IOCB fields that are dependent on the\n\t * scsi_cmnd request_buffer.  Note that for SLI-2 the bdeSize is\n\t * explicitly reinitialized and for SLI-3 the extended bde count is\n\t * explicitly reinitialized since all iocb memory resources are reused.\n\t */\n\tif (phba->sli_rev == 3 &&\n\t    !(phba->sli3_options & LPFC_SLI3_BG_ENABLED) &&\n\t    !(iocbq->iocb_flag & DSS_SECURITY_OP)) {\n\t\tif (num_bde > LPFC_EXT_DATA_BDE_COUNT) {\n\t\t\t/*\n\t\t\t * The extended IOCB format can only fit 3 BDE or a BPL.\n\t\t\t * This I/O has more than 3 BDE so the 1st data bde will\n\t\t\t * be a BPL that is filled in here.\n\t\t\t */\n\t\t\tphysaddr = lpfc_cmd->dma_handle;\n\t\t\tdata_bde->tus.f.bdeFlags = BUFF_TYPE_BLP_64;\n\t\t\tdata_bde->tus.f.bdeSize = (num_bde *\n\t\t\t\t\t\t   sizeof(struct ulp_bde64));\n\t\t\tphysaddr += (sizeof(struct fcp_cmnd) +\n\t\t\t\t     sizeof(struct fcp_rsp) +\n\t\t\t\t     (2 * sizeof(struct ulp_bde64)));\n\t\t\tdata_bde->addrHigh = putPaddrHigh(physaddr);\n\t\t\tdata_bde->addrLow = putPaddrLow(physaddr);\n\t\t\t/* ebde count includes the response bde and data bpl */\n\t\t\tiocb_cmd->unsli3.fcp_ext.ebde_count = 2;\n\t\t} else {\n\t\t\t/* ebde count includes the response bde and data bdes */\n\t\t\tiocb_cmd->unsli3.fcp_ext.ebde_count = (num_bde + 1);\n\t\t}\n\t} else {\n\t\tiocb_cmd->un.fcpi64.bdl.bdeSize =\n\t\t\t((num_bde + 2) * sizeof(struct ulp_bde64));\n\t\tiocb_cmd->unsli3.fcp_ext.ebde_count = (num_bde + 1);\n\t}\n\tfcp_cmnd->fcpDl = cpu_to_be32(scsi_bufflen(scsi_cmnd));\n\n\t/*\n\t * Due to difference in data length between DIF/non-DIF paths,\n\t * we need to set word 4 of IOCB here\n\t */\n\tiocb_cmd->un.fcpi.fcpi_parm = scsi_bufflen(scsi_cmnd);\n\tlpfc_fcpcmd_to_iocb(iocb_cmd->unsli3.fcp_ext.icd, fcp_cmnd);\n\treturn 0;\n}\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\n/* Return BG_ERR_INIT if error injection is detected by Initiator */\n#define BG_ERR_INIT\t0x1\n/* Return BG_ERR_TGT if error injection is detected by Target */\n#define BG_ERR_TGT\t0x2\n/* Return BG_ERR_SWAP if swapping CSUM<-->CRC is required for error injection */\n#define BG_ERR_SWAP\t0x10\n/**\n * Return BG_ERR_CHECK if disabling Guard/Ref/App checking is required for\n * error injection\n **/\n#define BG_ERR_CHECK\t0x20\n\n/**\n * lpfc_bg_err_inject - Determine if we should inject an error\n * @phba: The Hba for which this call is being executed.\n * @sc: The SCSI command to examine\n * @reftag: (out) BlockGuard reference tag for transmitted data\n * @apptag: (out) BlockGuard application tag for transmitted data\n * @new_guard: (in) Value to replace CRC with if needed\n *\n * Returns BG_ERR_* bit mask or 0 if request ignored\n **/\nstatic int\nlpfc_bg_err_inject(struct lpfc_hba *phba, struct scsi_cmnd *sc,\n\t\tuint32_t *reftag, uint16_t *apptag, uint32_t new_guard)\n{\n\tstruct scatterlist *sgpe; /* s/g prot entry */\n\tstruct lpfc_io_buf *lpfc_cmd = NULL;\n\tstruct scsi_dif_tuple *src = NULL;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_rport_data *rdata;\n\tuint32_t op = scsi_get_prot_op(sc);\n\tuint32_t blksize;\n\tuint32_t numblks;\n\tsector_t lba;\n\tint rc = 0;\n\tint blockoff = 0;\n\n\tif (op == SCSI_PROT_NORMAL)\n\t\treturn 0;\n\n\tsgpe = scsi_prot_sglist(sc);\n\tlba = scsi_get_lba(sc);\n\n\t/* First check if we need to match the LBA */\n\tif (phba->lpfc_injerr_lba != LPFC_INJERR_LBA_OFF) {\n\t\tblksize = lpfc_cmd_blksize(sc);\n\t\tnumblks = (scsi_bufflen(sc) + blksize - 1) / blksize;\n\n\t\t/* Make sure we have the right LBA if one is specified */\n\t\tif ((phba->lpfc_injerr_lba < lba) ||\n\t\t\t(phba->lpfc_injerr_lba >= (lba + numblks)))\n\t\t\treturn 0;\n\t\tif (sgpe) {\n\t\t\tblockoff = phba->lpfc_injerr_lba - lba;\n\t\t\tnumblks = sg_dma_len(sgpe) /\n\t\t\t\tsizeof(struct scsi_dif_tuple);\n\t\t\tif (numblks < blockoff)\n\t\t\t\tblockoff = numblks;\n\t\t}\n\t}\n\n\t/* Next check if we need to match the remote NPortID or WWPN */\n\trdata = lpfc_rport_data_from_scsi_device(sc->device);\n\tif (rdata && rdata->pnode) {\n\t\tndlp = rdata->pnode;\n\n\t\t/* Make sure we have the right NPortID if one is specified */\n\t\tif (phba->lpfc_injerr_nportid  &&\n\t\t\t(phba->lpfc_injerr_nportid != ndlp->nlp_DID))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Make sure we have the right WWPN if one is specified.\n\t\t * wwn[0] should be a non-zero NAA in a good WWPN.\n\t\t */\n\t\tif (phba->lpfc_injerr_wwpn.u.wwn[0]  &&\n\t\t\t(memcmp(&ndlp->nlp_portname, &phba->lpfc_injerr_wwpn,\n\t\t\t\tsizeof(struct lpfc_name)) != 0))\n\t\t\treturn 0;\n\t}\n\n\t/* Setup a ptr to the protection data if the SCSI host provides it */\n\tif (sgpe) {\n\t\tsrc = (struct scsi_dif_tuple *)sg_virt(sgpe);\n\t\tsrc += blockoff;\n\t\tlpfc_cmd = (struct lpfc_io_buf *)sc->host_scribble;\n\t}\n\n\t/* Should we change the Reference Tag */\n\tif (reftag) {\n\t\tif (phba->lpfc_injerr_wref_cnt) {\n\t\t\tswitch (op) {\n\t\t\tcase SCSI_PROT_WRITE_PASS:\n\t\t\t\tif (src) {\n\t\t\t\t\t/*\n\t\t\t\t\t * For WRITE_PASS, force the error\n\t\t\t\t\t * to be sent on the wire. It should\n\t\t\t\t\t * be detected by the Target.\n\t\t\t\t\t * If blockoff != 0 error will be\n\t\t\t\t\t * inserted in middle of the IO.\n\t\t\t\t\t */\n\n\t\t\t\t\tlpfc_printf_log(phba, KERN_ERR,\n\t\t\t\t\t\t\tLOG_TRACE_EVENT,\n\t\t\t\t\t\"9076 BLKGRD: Injecting reftag error: \"\n\t\t\t\t\t\"write lba x%lx + x%x oldrefTag x%x\\n\",\n\t\t\t\t\t(unsigned long)lba, blockoff,\n\t\t\t\t\tbe32_to_cpu(src->ref_tag));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Save the old ref_tag so we can\n\t\t\t\t\t * restore it on completion.\n\t\t\t\t\t */\n\t\t\t\t\tif (lpfc_cmd) {\n\t\t\t\t\t\tlpfc_cmd->prot_data_type =\n\t\t\t\t\t\t\tLPFC_INJERR_REFTAG;\n\t\t\t\t\t\tlpfc_cmd->prot_data_segment =\n\t\t\t\t\t\t\tsrc;\n\t\t\t\t\t\tlpfc_cmd->prot_data =\n\t\t\t\t\t\t\tsrc->ref_tag;\n\t\t\t\t\t}\n\t\t\t\t\tsrc->ref_tag = cpu_to_be32(0xDEADBEEF);\n\t\t\t\t\tphba->lpfc_injerr_wref_cnt--;\n\t\t\t\t\tif (phba->lpfc_injerr_wref_cnt == 0) {\n\t\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t  0, sizeof(struct lpfc_name));\n\t\t\t\t\t}\n\t\t\t\t\trc = BG_ERR_TGT | BG_ERR_CHECK;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tcase SCSI_PROT_WRITE_INSERT:\n\t\t\t\t/*\n\t\t\t\t * For WRITE_INSERT, force the error\n\t\t\t\t * to be sent on the wire. It should be\n\t\t\t\t * detected by the Target.\n\t\t\t\t */\n\t\t\t\t/* DEADBEEF will be the reftag on the wire */\n\t\t\t\t*reftag = 0xDEADBEEF;\n\t\t\t\tphba->lpfc_injerr_wref_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_wref_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\t\t\t\trc = BG_ERR_TGT | BG_ERR_CHECK;\n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9078 BLKGRD: Injecting reftag error: \"\n\t\t\t\t\t\"write lba x%lx\\n\", (unsigned long)lba);\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PROT_WRITE_STRIP:\n\t\t\t\t/*\n\t\t\t\t * For WRITE_STRIP and WRITE_PASS,\n\t\t\t\t * force the error on data\n\t\t\t\t * being copied from SLI-Host to SLI-Port.\n\t\t\t\t */\n\t\t\t\t*reftag = 0xDEADBEEF;\n\t\t\t\tphba->lpfc_injerr_wref_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_wref_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\t\t\t\trc = BG_ERR_INIT;\n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9077 BLKGRD: Injecting reftag error: \"\n\t\t\t\t\t\"write lba x%lx\\n\", (unsigned long)lba);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (phba->lpfc_injerr_rref_cnt) {\n\t\t\tswitch (op) {\n\t\t\tcase SCSI_PROT_READ_INSERT:\n\t\t\tcase SCSI_PROT_READ_STRIP:\n\t\t\tcase SCSI_PROT_READ_PASS:\n\t\t\t\t/*\n\t\t\t\t * For READ_STRIP and READ_PASS, force the\n\t\t\t\t * error on data being read off the wire. It\n\t\t\t\t * should force an IO error to the driver.\n\t\t\t\t */\n\t\t\t\t*reftag = 0xDEADBEEF;\n\t\t\t\tphba->lpfc_injerr_rref_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_rref_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\t\t\t\trc = BG_ERR_INIT;\n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9079 BLKGRD: Injecting reftag error: \"\n\t\t\t\t\t\"read lba x%lx\\n\", (unsigned long)lba);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Should we change the Application Tag */\n\tif (apptag) {\n\t\tif (phba->lpfc_injerr_wapp_cnt) {\n\t\t\tswitch (op) {\n\t\t\tcase SCSI_PROT_WRITE_PASS:\n\t\t\t\tif (src) {\n\t\t\t\t\t/*\n\t\t\t\t\t * For WRITE_PASS, force the error\n\t\t\t\t\t * to be sent on the wire. It should\n\t\t\t\t\t * be detected by the Target.\n\t\t\t\t\t * If blockoff != 0 error will be\n\t\t\t\t\t * inserted in middle of the IO.\n\t\t\t\t\t */\n\n\t\t\t\t\tlpfc_printf_log(phba, KERN_ERR,\n\t\t\t\t\t\t\tLOG_TRACE_EVENT,\n\t\t\t\t\t\"9080 BLKGRD: Injecting apptag error: \"\n\t\t\t\t\t\"write lba x%lx + x%x oldappTag x%x\\n\",\n\t\t\t\t\t(unsigned long)lba, blockoff,\n\t\t\t\t\tbe16_to_cpu(src->app_tag));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Save the old app_tag so we can\n\t\t\t\t\t * restore it on completion.\n\t\t\t\t\t */\n\t\t\t\t\tif (lpfc_cmd) {\n\t\t\t\t\t\tlpfc_cmd->prot_data_type =\n\t\t\t\t\t\t\tLPFC_INJERR_APPTAG;\n\t\t\t\t\t\tlpfc_cmd->prot_data_segment =\n\t\t\t\t\t\t\tsrc;\n\t\t\t\t\t\tlpfc_cmd->prot_data =\n\t\t\t\t\t\t\tsrc->app_tag;\n\t\t\t\t\t}\n\t\t\t\t\tsrc->app_tag = cpu_to_be16(0xDEAD);\n\t\t\t\t\tphba->lpfc_injerr_wapp_cnt--;\n\t\t\t\t\tif (phba->lpfc_injerr_wapp_cnt == 0) {\n\t\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t  0, sizeof(struct lpfc_name));\n\t\t\t\t\t}\n\t\t\t\t\trc = BG_ERR_TGT | BG_ERR_CHECK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tcase SCSI_PROT_WRITE_INSERT:\n\t\t\t\t/*\n\t\t\t\t * For WRITE_INSERT, force the\n\t\t\t\t * error to be sent on the wire. It should be\n\t\t\t\t * detected by the Target.\n\t\t\t\t */\n\t\t\t\t/* DEAD will be the apptag on the wire */\n\t\t\t\t*apptag = 0xDEAD;\n\t\t\t\tphba->lpfc_injerr_wapp_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_wapp_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\t\t\t\trc = BG_ERR_TGT | BG_ERR_CHECK;\n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"0813 BLKGRD: Injecting apptag error: \"\n\t\t\t\t\t\"write lba x%lx\\n\", (unsigned long)lba);\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PROT_WRITE_STRIP:\n\t\t\t\t/*\n\t\t\t\t * For WRITE_STRIP and WRITE_PASS,\n\t\t\t\t * force the error on data\n\t\t\t\t * being copied from SLI-Host to SLI-Port.\n\t\t\t\t */\n\t\t\t\t*apptag = 0xDEAD;\n\t\t\t\tphba->lpfc_injerr_wapp_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_wapp_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\t\t\t\trc = BG_ERR_INIT;\n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"0812 BLKGRD: Injecting apptag error: \"\n\t\t\t\t\t\"write lba x%lx\\n\", (unsigned long)lba);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (phba->lpfc_injerr_rapp_cnt) {\n\t\t\tswitch (op) {\n\t\t\tcase SCSI_PROT_READ_INSERT:\n\t\t\tcase SCSI_PROT_READ_STRIP:\n\t\t\tcase SCSI_PROT_READ_PASS:\n\t\t\t\t/*\n\t\t\t\t * For READ_STRIP and READ_PASS, force the\n\t\t\t\t * error on data being read off the wire. It\n\t\t\t\t * should force an IO error to the driver.\n\t\t\t\t */\n\t\t\t\t*apptag = 0xDEAD;\n\t\t\t\tphba->lpfc_injerr_rapp_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_rapp_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\t\t\t\trc = BG_ERR_INIT;\n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"0814 BLKGRD: Injecting apptag error: \"\n\t\t\t\t\t\"read lba x%lx\\n\", (unsigned long)lba);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/* Should we change the Guard Tag */\n\tif (new_guard) {\n\t\tif (phba->lpfc_injerr_wgrd_cnt) {\n\t\t\tswitch (op) {\n\t\t\tcase SCSI_PROT_WRITE_PASS:\n\t\t\t\trc = BG_ERR_CHECK;\n\t\t\t\tfallthrough;\n\n\t\t\tcase SCSI_PROT_WRITE_INSERT:\n\t\t\t\t/*\n\t\t\t\t * For WRITE_INSERT, force the\n\t\t\t\t * error to be sent on the wire. It should be\n\t\t\t\t * detected by the Target.\n\t\t\t\t */\n\t\t\t\tphba->lpfc_injerr_wgrd_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_wgrd_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\n\t\t\t\trc |= BG_ERR_TGT | BG_ERR_SWAP;\n\t\t\t\t/* Signals the caller to swap CRC->CSUM */\n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"0817 BLKGRD: Injecting guard error: \"\n\t\t\t\t\t\"write lba x%lx\\n\", (unsigned long)lba);\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PROT_WRITE_STRIP:\n\t\t\t\t/*\n\t\t\t\t * For WRITE_STRIP and WRITE_PASS,\n\t\t\t\t * force the error on data\n\t\t\t\t * being copied from SLI-Host to SLI-Port.\n\t\t\t\t */\n\t\t\t\tphba->lpfc_injerr_wgrd_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_wgrd_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\n\t\t\t\trc = BG_ERR_INIT | BG_ERR_SWAP;\n\t\t\t\t/* Signals the caller to swap CRC->CSUM */\n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"0816 BLKGRD: Injecting guard error: \"\n\t\t\t\t\t\"write lba x%lx\\n\", (unsigned long)lba);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (phba->lpfc_injerr_rgrd_cnt) {\n\t\t\tswitch (op) {\n\t\t\tcase SCSI_PROT_READ_INSERT:\n\t\t\tcase SCSI_PROT_READ_STRIP:\n\t\t\tcase SCSI_PROT_READ_PASS:\n\t\t\t\t/*\n\t\t\t\t * For READ_STRIP and READ_PASS, force the\n\t\t\t\t * error on data being read off the wire. It\n\t\t\t\t * should force an IO error to the driver.\n\t\t\t\t */\n\t\t\t\tphba->lpfc_injerr_rgrd_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_rgrd_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\n\t\t\t\trc = BG_ERR_INIT | BG_ERR_SWAP;\n\t\t\t\t/* Signals the caller to swap CRC->CSUM */\n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"0818 BLKGRD: Injecting guard error: \"\n\t\t\t\t\t\"read lba x%lx\\n\", (unsigned long)lba);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc;\n}\n#endif\n\n/**\n * lpfc_sc_to_bg_opcodes - Determine the BlockGuard opcodes to be used with\n * the specified SCSI command.\n * @phba: The Hba for which this call is being executed.\n * @sc: The SCSI command to examine\n * @txop: (out) BlockGuard operation for transmitted data\n * @rxop: (out) BlockGuard operation for received data\n *\n * Returns: zero on success; non-zero if tx and/or rx op cannot be determined\n *\n **/\nstatic int\nlpfc_sc_to_bg_opcodes(struct lpfc_hba *phba, struct scsi_cmnd *sc,\n\t\tuint8_t *txop, uint8_t *rxop)\n{\n\tuint8_t ret = 0;\n\n\tif (lpfc_cmd_guard_csum(sc)) {\n\t\tswitch (scsi_get_prot_op(sc)) {\n\t\tcase SCSI_PROT_READ_INSERT:\n\t\tcase SCSI_PROT_WRITE_STRIP:\n\t\t\t*rxop = BG_OP_IN_NODIF_OUT_CSUM;\n\t\t\t*txop = BG_OP_IN_CSUM_OUT_NODIF;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_READ_STRIP:\n\t\tcase SCSI_PROT_WRITE_INSERT:\n\t\t\t*rxop = BG_OP_IN_CRC_OUT_NODIF;\n\t\t\t*txop = BG_OP_IN_NODIF_OUT_CRC;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_READ_PASS:\n\t\tcase SCSI_PROT_WRITE_PASS:\n\t\t\t*rxop = BG_OP_IN_CRC_OUT_CSUM;\n\t\t\t*txop = BG_OP_IN_CSUM_OUT_CRC;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_NORMAL:\n\t\tdefault:\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"9063 BLKGRD: Bad op/guard:%d/IP combination\\n\",\n\t\t\t\t\tscsi_get_prot_op(sc));\n\t\t\tret = 1;\n\t\t\tbreak;\n\n\t\t}\n\t} else {\n\t\tswitch (scsi_get_prot_op(sc)) {\n\t\tcase SCSI_PROT_READ_STRIP:\n\t\tcase SCSI_PROT_WRITE_INSERT:\n\t\t\t*rxop = BG_OP_IN_CRC_OUT_NODIF;\n\t\t\t*txop = BG_OP_IN_NODIF_OUT_CRC;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_READ_PASS:\n\t\tcase SCSI_PROT_WRITE_PASS:\n\t\t\t*rxop = BG_OP_IN_CRC_OUT_CRC;\n\t\t\t*txop = BG_OP_IN_CRC_OUT_CRC;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_READ_INSERT:\n\t\tcase SCSI_PROT_WRITE_STRIP:\n\t\t\t*rxop = BG_OP_IN_NODIF_OUT_CRC;\n\t\t\t*txop = BG_OP_IN_CRC_OUT_NODIF;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_NORMAL:\n\t\tdefault:\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"9075 BLKGRD: Bad op/guard:%d/CRC combination\\n\",\n\t\t\t\t\tscsi_get_prot_op(sc));\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n/**\n * lpfc_bg_err_opcodes - reDetermine the BlockGuard opcodes to be used with\n * the specified SCSI command in order to force a guard tag error.\n * @phba: The Hba for which this call is being executed.\n * @sc: The SCSI command to examine\n * @txop: (out) BlockGuard operation for transmitted data\n * @rxop: (out) BlockGuard operation for received data\n *\n * Returns: zero on success; non-zero if tx and/or rx op cannot be determined\n *\n **/\nstatic int\nlpfc_bg_err_opcodes(struct lpfc_hba *phba, struct scsi_cmnd *sc,\n\t\tuint8_t *txop, uint8_t *rxop)\n{\n\tuint8_t ret = 0;\n\n\tif (lpfc_cmd_guard_csum(sc)) {\n\t\tswitch (scsi_get_prot_op(sc)) {\n\t\tcase SCSI_PROT_READ_INSERT:\n\t\tcase SCSI_PROT_WRITE_STRIP:\n\t\t\t*rxop = BG_OP_IN_NODIF_OUT_CRC;\n\t\t\t*txop = BG_OP_IN_CRC_OUT_NODIF;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_READ_STRIP:\n\t\tcase SCSI_PROT_WRITE_INSERT:\n\t\t\t*rxop = BG_OP_IN_CSUM_OUT_NODIF;\n\t\t\t*txop = BG_OP_IN_NODIF_OUT_CSUM;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_READ_PASS:\n\t\tcase SCSI_PROT_WRITE_PASS:\n\t\t\t*rxop = BG_OP_IN_CSUM_OUT_CRC;\n\t\t\t*txop = BG_OP_IN_CRC_OUT_CSUM;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_NORMAL:\n\t\tdefault:\n\t\t\tbreak;\n\n\t\t}\n\t} else {\n\t\tswitch (scsi_get_prot_op(sc)) {\n\t\tcase SCSI_PROT_READ_STRIP:\n\t\tcase SCSI_PROT_WRITE_INSERT:\n\t\t\t*rxop = BG_OP_IN_CSUM_OUT_NODIF;\n\t\t\t*txop = BG_OP_IN_NODIF_OUT_CSUM;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_READ_PASS:\n\t\tcase SCSI_PROT_WRITE_PASS:\n\t\t\t*rxop = BG_OP_IN_CSUM_OUT_CSUM;\n\t\t\t*txop = BG_OP_IN_CSUM_OUT_CSUM;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_READ_INSERT:\n\t\tcase SCSI_PROT_WRITE_STRIP:\n\t\t\t*rxop = BG_OP_IN_NODIF_OUT_CSUM;\n\t\t\t*txop = BG_OP_IN_CSUM_OUT_NODIF;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_NORMAL:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n#endif\n\n/**\n * lpfc_bg_setup_bpl - Setup BlockGuard BPL with no protection data\n * @phba: The Hba for which this call is being executed.\n * @sc: pointer to scsi command we're working on\n * @bpl: pointer to buffer list for protection groups\n * @datasegcnt: number of segments of data that have been dma mapped\n *\n * This function sets up BPL buffer list for protection groups of\n * type LPFC_PG_TYPE_NO_DIF\n *\n * This is usually used when the HBA is instructed to generate\n * DIFs and insert them into data stream (or strip DIF from\n * incoming data stream)\n *\n * The buffer list consists of just one protection group described\n * below:\n *                                +-------------------------+\n *   start of prot group  -->     |          PDE_5          |\n *                                +-------------------------+\n *                                |          PDE_6          |\n *                                +-------------------------+\n *                                |         Data BDE        |\n *                                +-------------------------+\n *                                |more Data BDE's ... (opt)|\n *                                +-------------------------+\n *\n *\n * Note: Data s/g buffers have been dma mapped\n *\n * Returns the number of BDEs added to the BPL.\n **/\nstatic int\nlpfc_bg_setup_bpl(struct lpfc_hba *phba, struct scsi_cmnd *sc,\n\t\tstruct ulp_bde64 *bpl, int datasegcnt)\n{\n\tstruct scatterlist *sgde = NULL; /* s/g data entry */\n\tstruct lpfc_pde5 *pde5 = NULL;\n\tstruct lpfc_pde6 *pde6 = NULL;\n\tdma_addr_t physaddr;\n\tint i = 0, num_bde = 0, status;\n\tint datadir = sc->sc_data_direction;\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tuint32_t rc;\n#endif\n\tuint32_t checking = 1;\n\tuint32_t reftag;\n\tuint8_t txop, rxop;\n\n\tstatus  = lpfc_sc_to_bg_opcodes(phba, sc, &txop, &rxop);\n\tif (status)\n\t\tgoto out;\n\n\t/* extract some info from the scsi command for pde*/\n\treftag = (uint32_t)scsi_get_lba(sc); /* Truncate LBA */\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\trc = lpfc_bg_err_inject(phba, sc, &reftag, NULL, 1);\n\tif (rc) {\n\t\tif (rc & BG_ERR_SWAP)\n\t\t\tlpfc_bg_err_opcodes(phba, sc, &txop, &rxop);\n\t\tif (rc & BG_ERR_CHECK)\n\t\t\tchecking = 0;\n\t}\n#endif\n\n\t/* setup PDE5 with what we have */\n\tpde5 = (struct lpfc_pde5 *) bpl;\n\tmemset(pde5, 0, sizeof(struct lpfc_pde5));\n\tbf_set(pde5_type, pde5, LPFC_PDE5_DESCRIPTOR);\n\n\t/* Endianness conversion if necessary for PDE5 */\n\tpde5->word0 = cpu_to_le32(pde5->word0);\n\tpde5->reftag = cpu_to_le32(reftag);\n\n\t/* advance bpl and increment bde count */\n\tnum_bde++;\n\tbpl++;\n\tpde6 = (struct lpfc_pde6 *) bpl;\n\n\t/* setup PDE6 with the rest of the info */\n\tmemset(pde6, 0, sizeof(struct lpfc_pde6));\n\tbf_set(pde6_type, pde6, LPFC_PDE6_DESCRIPTOR);\n\tbf_set(pde6_optx, pde6, txop);\n\tbf_set(pde6_oprx, pde6, rxop);\n\n\t/*\n\t * We only need to check the data on READs, for WRITEs\n\t * protection data is automatically generated, not checked.\n\t */\n\tif (datadir == DMA_FROM_DEVICE) {\n\t\tif (lpfc_cmd_protect(sc, LPFC_CHECK_PROTECT_GUARD))\n\t\t\tbf_set(pde6_ce, pde6, checking);\n\t\telse\n\t\t\tbf_set(pde6_ce, pde6, 0);\n\n\t\tif (lpfc_cmd_protect(sc, LPFC_CHECK_PROTECT_REF))\n\t\t\tbf_set(pde6_re, pde6, checking);\n\t\telse\n\t\t\tbf_set(pde6_re, pde6, 0);\n\t}\n\tbf_set(pde6_ai, pde6, 1);\n\tbf_set(pde6_ae, pde6, 0);\n\tbf_set(pde6_apptagval, pde6, 0);\n\n\t/* Endianness conversion if necessary for PDE6 */\n\tpde6->word0 = cpu_to_le32(pde6->word0);\n\tpde6->word1 = cpu_to_le32(pde6->word1);\n\tpde6->word2 = cpu_to_le32(pde6->word2);\n\n\t/* advance bpl and increment bde count */\n\tnum_bde++;\n\tbpl++;\n\n\t/* assumption: caller has already run dma_map_sg on command data */\n\tscsi_for_each_sg(sc, sgde, datasegcnt, i) {\n\t\tphysaddr = sg_dma_address(sgde);\n\t\tbpl->addrLow = le32_to_cpu(putPaddrLow(physaddr));\n\t\tbpl->addrHigh = le32_to_cpu(putPaddrHigh(physaddr));\n\t\tbpl->tus.f.bdeSize = sg_dma_len(sgde);\n\t\tif (datadir == DMA_TO_DEVICE)\n\t\t\tbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t\telse\n\t\t\tbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64I;\n\t\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\t\tbpl++;\n\t\tnum_bde++;\n\t}\n\nout:\n\treturn num_bde;\n}\n\n/**\n * lpfc_bg_setup_bpl_prot - Setup BlockGuard BPL with protection data\n * @phba: The Hba for which this call is being executed.\n * @sc: pointer to scsi command we're working on\n * @bpl: pointer to buffer list for protection groups\n * @datacnt: number of segments of data that have been dma mapped\n * @protcnt: number of segment of protection data that have been dma mapped\n *\n * This function sets up BPL buffer list for protection groups of\n * type LPFC_PG_TYPE_DIF\n *\n * This is usually used when DIFs are in their own buffers,\n * separate from the data. The HBA can then by instructed\n * to place the DIFs in the outgoing stream.  For read operations,\n * The HBA could extract the DIFs and place it in DIF buffers.\n *\n * The buffer list for this type consists of one or more of the\n * protection groups described below:\n *                                    +-------------------------+\n *   start of first prot group  -->   |          PDE_5          |\n *                                    +-------------------------+\n *                                    |          PDE_6          |\n *                                    +-------------------------+\n *                                    |      PDE_7 (Prot BDE)   |\n *                                    +-------------------------+\n *                                    |        Data BDE         |\n *                                    +-------------------------+\n *                                    |more Data BDE's ... (opt)|\n *                                    +-------------------------+\n *   start of new  prot group  -->    |          PDE_5          |\n *                                    +-------------------------+\n *                                    |          ...            |\n *                                    +-------------------------+\n *\n * Note: It is assumed that both data and protection s/g buffers have been\n *       mapped for DMA\n *\n * Returns the number of BDEs added to the BPL.\n **/\nstatic int\nlpfc_bg_setup_bpl_prot(struct lpfc_hba *phba, struct scsi_cmnd *sc,\n\t\tstruct ulp_bde64 *bpl, int datacnt, int protcnt)\n{\n\tstruct scatterlist *sgde = NULL; /* s/g data entry */\n\tstruct scatterlist *sgpe = NULL; /* s/g prot entry */\n\tstruct lpfc_pde5 *pde5 = NULL;\n\tstruct lpfc_pde6 *pde6 = NULL;\n\tstruct lpfc_pde7 *pde7 = NULL;\n\tdma_addr_t dataphysaddr, protphysaddr;\n\tunsigned short curr_data = 0, curr_prot = 0;\n\tunsigned int split_offset;\n\tunsigned int protgroup_len, protgroup_offset = 0, protgroup_remainder;\n\tunsigned int protgrp_blks, protgrp_bytes;\n\tunsigned int remainder, subtotal;\n\tint status;\n\tint datadir = sc->sc_data_direction;\n\tunsigned char pgdone = 0, alldone = 0;\n\tunsigned blksize;\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tuint32_t rc;\n#endif\n\tuint32_t checking = 1;\n\tuint32_t reftag;\n\tuint8_t txop, rxop;\n\tint num_bde = 0;\n\n\tsgpe = scsi_prot_sglist(sc);\n\tsgde = scsi_sglist(sc);\n\n\tif (!sgpe || !sgde) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"9020 Invalid s/g entry: data=x%px prot=x%px\\n\",\n\t\t\t\tsgpe, sgde);\n\t\treturn 0;\n\t}\n\n\tstatus = lpfc_sc_to_bg_opcodes(phba, sc, &txop, &rxop);\n\tif (status)\n\t\tgoto out;\n\n\t/* extract some info from the scsi command */\n\tblksize = lpfc_cmd_blksize(sc);\n\treftag = (uint32_t)scsi_get_lba(sc); /* Truncate LBA */\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\trc = lpfc_bg_err_inject(phba, sc, &reftag, NULL, 1);\n\tif (rc) {\n\t\tif (rc & BG_ERR_SWAP)\n\t\t\tlpfc_bg_err_opcodes(phba, sc, &txop, &rxop);\n\t\tif (rc & BG_ERR_CHECK)\n\t\t\tchecking = 0;\n\t}\n#endif\n\n\tsplit_offset = 0;\n\tdo {\n\t\t/* Check to see if we ran out of space */\n\t\tif (num_bde >= (phba->cfg_total_seg_cnt - 2))\n\t\t\treturn num_bde + 3;\n\n\t\t/* setup PDE5 with what we have */\n\t\tpde5 = (struct lpfc_pde5 *) bpl;\n\t\tmemset(pde5, 0, sizeof(struct lpfc_pde5));\n\t\tbf_set(pde5_type, pde5, LPFC_PDE5_DESCRIPTOR);\n\n\t\t/* Endianness conversion if necessary for PDE5 */\n\t\tpde5->word0 = cpu_to_le32(pde5->word0);\n\t\tpde5->reftag = cpu_to_le32(reftag);\n\n\t\t/* advance bpl and increment bde count */\n\t\tnum_bde++;\n\t\tbpl++;\n\t\tpde6 = (struct lpfc_pde6 *) bpl;\n\n\t\t/* setup PDE6 with the rest of the info */\n\t\tmemset(pde6, 0, sizeof(struct lpfc_pde6));\n\t\tbf_set(pde6_type, pde6, LPFC_PDE6_DESCRIPTOR);\n\t\tbf_set(pde6_optx, pde6, txop);\n\t\tbf_set(pde6_oprx, pde6, rxop);\n\n\t\tif (lpfc_cmd_protect(sc, LPFC_CHECK_PROTECT_GUARD))\n\t\t\tbf_set(pde6_ce, pde6, checking);\n\t\telse\n\t\t\tbf_set(pde6_ce, pde6, 0);\n\n\t\tif (lpfc_cmd_protect(sc, LPFC_CHECK_PROTECT_REF))\n\t\t\tbf_set(pde6_re, pde6, checking);\n\t\telse\n\t\t\tbf_set(pde6_re, pde6, 0);\n\n\t\tbf_set(pde6_ai, pde6, 1);\n\t\tbf_set(pde6_ae, pde6, 0);\n\t\tbf_set(pde6_apptagval, pde6, 0);\n\n\t\t/* Endianness conversion if necessary for PDE6 */\n\t\tpde6->word0 = cpu_to_le32(pde6->word0);\n\t\tpde6->word1 = cpu_to_le32(pde6->word1);\n\t\tpde6->word2 = cpu_to_le32(pde6->word2);\n\n\t\t/* advance bpl and increment bde count */\n\t\tnum_bde++;\n\t\tbpl++;\n\n\t\t/* setup the first BDE that points to protection buffer */\n\t\tprotphysaddr = sg_dma_address(sgpe) + protgroup_offset;\n\t\tprotgroup_len = sg_dma_len(sgpe) - protgroup_offset;\n\n\t\t/* must be integer multiple of the DIF block length */\n\t\tBUG_ON(protgroup_len % 8);\n\n\t\tpde7 = (struct lpfc_pde7 *) bpl;\n\t\tmemset(pde7, 0, sizeof(struct lpfc_pde7));\n\t\tbf_set(pde7_type, pde7, LPFC_PDE7_DESCRIPTOR);\n\n\t\tpde7->addrHigh = le32_to_cpu(putPaddrHigh(protphysaddr));\n\t\tpde7->addrLow = le32_to_cpu(putPaddrLow(protphysaddr));\n\n\t\tprotgrp_blks = protgroup_len / 8;\n\t\tprotgrp_bytes = protgrp_blks * blksize;\n\n\t\t/* check if this pde is crossing the 4K boundary; if so split */\n\t\tif ((pde7->addrLow & 0xfff) + protgroup_len > 0x1000) {\n\t\t\tprotgroup_remainder = 0x1000 - (pde7->addrLow & 0xfff);\n\t\t\tprotgroup_offset += protgroup_remainder;\n\t\t\tprotgrp_blks = protgroup_remainder / 8;\n\t\t\tprotgrp_bytes = protgrp_blks * blksize;\n\t\t} else {\n\t\t\tprotgroup_offset = 0;\n\t\t\tcurr_prot++;\n\t\t}\n\n\t\tnum_bde++;\n\n\t\t/* setup BDE's for data blocks associated with DIF data */\n\t\tpgdone = 0;\n\t\tsubtotal = 0; /* total bytes processed for current prot grp */\n\t\twhile (!pgdone) {\n\t\t\t/* Check to see if we ran out of space */\n\t\t\tif (num_bde >= phba->cfg_total_seg_cnt)\n\t\t\t\treturn num_bde + 1;\n\n\t\t\tif (!sgde) {\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9065 BLKGRD:%s Invalid data segment\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbpl++;\n\t\t\tdataphysaddr = sg_dma_address(sgde) + split_offset;\n\t\t\tbpl->addrLow = le32_to_cpu(putPaddrLow(dataphysaddr));\n\t\t\tbpl->addrHigh = le32_to_cpu(putPaddrHigh(dataphysaddr));\n\n\t\t\tremainder = sg_dma_len(sgde) - split_offset;\n\n\t\t\tif ((subtotal + remainder) <= protgrp_bytes) {\n\t\t\t\t/* we can use this whole buffer */\n\t\t\t\tbpl->tus.f.bdeSize = remainder;\n\t\t\t\tsplit_offset = 0;\n\n\t\t\t\tif ((subtotal + remainder) == protgrp_bytes)\n\t\t\t\t\tpgdone = 1;\n\t\t\t} else {\n\t\t\t\t/* must split this buffer with next prot grp */\n\t\t\t\tbpl->tus.f.bdeSize = protgrp_bytes - subtotal;\n\t\t\t\tsplit_offset += bpl->tus.f.bdeSize;\n\t\t\t}\n\n\t\t\tsubtotal += bpl->tus.f.bdeSize;\n\n\t\t\tif (datadir == DMA_TO_DEVICE)\n\t\t\t\tbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t\t\telse\n\t\t\t\tbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64I;\n\t\t\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\n\t\t\tnum_bde++;\n\t\t\tcurr_data++;\n\n\t\t\tif (split_offset)\n\t\t\t\tbreak;\n\n\t\t\t/* Move to the next s/g segment if possible */\n\t\t\tsgde = sg_next(sgde);\n\n\t\t}\n\n\t\tif (protgroup_offset) {\n\t\t\t/* update the reference tag */\n\t\t\treftag += protgrp_blks;\n\t\t\tbpl++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* are we done ? */\n\t\tif (curr_prot == protcnt) {\n\t\t\talldone = 1;\n\t\t} else if (curr_prot < protcnt) {\n\t\t\t/* advance to next prot buffer */\n\t\t\tsgpe = sg_next(sgpe);\n\t\t\tbpl++;\n\n\t\t\t/* update the reference tag */\n\t\t\treftag += protgrp_blks;\n\t\t} else {\n\t\t\t/* if we're here, we have a bug */\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9054 BLKGRD: bug in %s\\n\", __func__);\n\t\t}\n\n\t} while (!alldone);\nout:\n\n\treturn num_bde;\n}\n\n/**\n * lpfc_bg_setup_sgl - Setup BlockGuard SGL with no protection data\n * @phba: The Hba for which this call is being executed.\n * @sc: pointer to scsi command we're working on\n * @sgl: pointer to buffer list for protection groups\n * @datasegcnt: number of segments of data that have been dma mapped\n * @lpfc_cmd: lpfc scsi command object pointer.\n *\n * This function sets up SGL buffer list for protection groups of\n * type LPFC_PG_TYPE_NO_DIF\n *\n * This is usually used when the HBA is instructed to generate\n * DIFs and insert them into data stream (or strip DIF from\n * incoming data stream)\n *\n * The buffer list consists of just one protection group described\n * below:\n *                                +-------------------------+\n *   start of prot group  -->     |         DI_SEED         |\n *                                +-------------------------+\n *                                |         Data SGE        |\n *                                +-------------------------+\n *                                |more Data SGE's ... (opt)|\n *                                +-------------------------+\n *\n *\n * Note: Data s/g buffers have been dma mapped\n *\n * Returns the number of SGEs added to the SGL.\n **/\nstatic int\nlpfc_bg_setup_sgl(struct lpfc_hba *phba, struct scsi_cmnd *sc,\n\t\tstruct sli4_sge *sgl, int datasegcnt,\n\t\tstruct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct scatterlist *sgde = NULL; /* s/g data entry */\n\tstruct sli4_sge_diseed *diseed = NULL;\n\tdma_addr_t physaddr;\n\tint i = 0, num_sge = 0, status;\n\tuint32_t reftag;\n\tuint8_t txop, rxop;\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tuint32_t rc;\n#endif\n\tuint32_t checking = 1;\n\tuint32_t dma_len;\n\tuint32_t dma_offset = 0;\n\tstruct sli4_hybrid_sgl *sgl_xtra = NULL;\n\tint j;\n\tbool lsp_just_set = false;\n\n\tstatus  = lpfc_sc_to_bg_opcodes(phba, sc, &txop, &rxop);\n\tif (status)\n\t\tgoto out;\n\n\t/* extract some info from the scsi command for pde*/\n\treftag = (uint32_t)scsi_get_lba(sc); /* Truncate LBA */\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\trc = lpfc_bg_err_inject(phba, sc, &reftag, NULL, 1);\n\tif (rc) {\n\t\tif (rc & BG_ERR_SWAP)\n\t\t\tlpfc_bg_err_opcodes(phba, sc, &txop, &rxop);\n\t\tif (rc & BG_ERR_CHECK)\n\t\t\tchecking = 0;\n\t}\n#endif\n\n\t/* setup DISEED with what we have */\n\tdiseed = (struct sli4_sge_diseed *) sgl;\n\tmemset(diseed, 0, sizeof(struct sli4_sge_diseed));\n\tbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_DISEED);\n\n\t/* Endianness conversion if necessary */\n\tdiseed->ref_tag = cpu_to_le32(reftag);\n\tdiseed->ref_tag_tran = diseed->ref_tag;\n\n\t/*\n\t * We only need to check the data on READs, for WRITEs\n\t * protection data is automatically generated, not checked.\n\t */\n\tif (sc->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tif (lpfc_cmd_protect(sc, LPFC_CHECK_PROTECT_GUARD))\n\t\t\tbf_set(lpfc_sli4_sge_dif_ce, diseed, checking);\n\t\telse\n\t\t\tbf_set(lpfc_sli4_sge_dif_ce, diseed, 0);\n\n\t\tif (lpfc_cmd_protect(sc, LPFC_CHECK_PROTECT_REF))\n\t\t\tbf_set(lpfc_sli4_sge_dif_re, diseed, checking);\n\t\telse\n\t\t\tbf_set(lpfc_sli4_sge_dif_re, diseed, 0);\n\t}\n\n\t/* setup DISEED with the rest of the info */\n\tbf_set(lpfc_sli4_sge_dif_optx, diseed, txop);\n\tbf_set(lpfc_sli4_sge_dif_oprx, diseed, rxop);\n\n\tbf_set(lpfc_sli4_sge_dif_ai, diseed, 1);\n\tbf_set(lpfc_sli4_sge_dif_me, diseed, 0);\n\n\t/* Endianness conversion if necessary for DISEED */\n\tdiseed->word2 = cpu_to_le32(diseed->word2);\n\tdiseed->word3 = cpu_to_le32(diseed->word3);\n\n\t/* advance bpl and increment sge count */\n\tnum_sge++;\n\tsgl++;\n\n\t/* assumption: caller has already run dma_map_sg on command data */\n\tsgde = scsi_sglist(sc);\n\tj = 3;\n\tfor (i = 0; i < datasegcnt; i++) {\n\t\t/* clear it */\n\t\tsgl->word2 = 0;\n\n\t\t/* do we need to expand the segment */\n\t\tif (!lsp_just_set && !((j + 1) % phba->border_sge_num) &&\n\t\t    ((datasegcnt - 1) != i)) {\n\t\t\t/* set LSP type */\n\t\t\tbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_LSP);\n\n\t\t\tsgl_xtra = lpfc_get_sgl_per_hdwq(phba, lpfc_cmd);\n\n\t\t\tif (unlikely(!sgl_xtra)) {\n\t\t\t\tlpfc_cmd->seg_cnt = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsgl->addr_lo = cpu_to_le32(putPaddrLow(\n\t\t\t\t\t\tsgl_xtra->dma_phys_sgl));\n\t\t\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(\n\t\t\t\t\t\tsgl_xtra->dma_phys_sgl));\n\n\t\t} else {\n\t\t\tbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_DATA);\n\t\t}\n\n\t\tif (!(bf_get(lpfc_sli4_sge_type, sgl) & LPFC_SGE_TYPE_LSP)) {\n\t\t\tif ((datasegcnt - 1) == i)\n\t\t\t\tbf_set(lpfc_sli4_sge_last, sgl, 1);\n\t\t\tphysaddr = sg_dma_address(sgde);\n\t\t\tdma_len = sg_dma_len(sgde);\n\t\t\tsgl->addr_lo = cpu_to_le32(putPaddrLow(physaddr));\n\t\t\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(physaddr));\n\n\t\t\tbf_set(lpfc_sli4_sge_offset, sgl, dma_offset);\n\t\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\t\tsgl->sge_len = cpu_to_le32(dma_len);\n\n\t\t\tdma_offset += dma_len;\n\t\t\tsgde = sg_next(sgde);\n\n\t\t\tsgl++;\n\t\t\tnum_sge++;\n\t\t\tlsp_just_set = false;\n\n\t\t} else {\n\t\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\t\tsgl->sge_len = cpu_to_le32(phba->cfg_sg_dma_buf_size);\n\n\t\t\tsgl = (struct sli4_sge *)sgl_xtra->dma_sgl;\n\t\t\ti = i - 1;\n\n\t\t\tlsp_just_set = true;\n\t\t}\n\n\t\tj++;\n\n\t}\n\nout:\n\treturn num_sge;\n}\n\n/**\n * lpfc_bg_setup_sgl_prot - Setup BlockGuard SGL with protection data\n * @phba: The Hba for which this call is being executed.\n * @sc: pointer to scsi command we're working on\n * @sgl: pointer to buffer list for protection groups\n * @datacnt: number of segments of data that have been dma mapped\n * @protcnt: number of segment of protection data that have been dma mapped\n * @lpfc_cmd: lpfc scsi command object pointer.\n *\n * This function sets up SGL buffer list for protection groups of\n * type LPFC_PG_TYPE_DIF\n *\n * This is usually used when DIFs are in their own buffers,\n * separate from the data. The HBA can then by instructed\n * to place the DIFs in the outgoing stream.  For read operations,\n * The HBA could extract the DIFs and place it in DIF buffers.\n *\n * The buffer list for this type consists of one or more of the\n * protection groups described below:\n *                                    +-------------------------+\n *   start of first prot group  -->   |         DISEED          |\n *                                    +-------------------------+\n *                                    |      DIF (Prot SGE)     |\n *                                    +-------------------------+\n *                                    |        Data SGE         |\n *                                    +-------------------------+\n *                                    |more Data SGE's ... (opt)|\n *                                    +-------------------------+\n *   start of new  prot group  -->    |         DISEED          |\n *                                    +-------------------------+\n *                                    |          ...            |\n *                                    +-------------------------+\n *\n * Note: It is assumed that both data and protection s/g buffers have been\n *       mapped for DMA\n *\n * Returns the number of SGEs added to the SGL.\n **/\nstatic int\nlpfc_bg_setup_sgl_prot(struct lpfc_hba *phba, struct scsi_cmnd *sc,\n\t\tstruct sli4_sge *sgl, int datacnt, int protcnt,\n\t\tstruct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct scatterlist *sgde = NULL; /* s/g data entry */\n\tstruct scatterlist *sgpe = NULL; /* s/g prot entry */\n\tstruct sli4_sge_diseed *diseed = NULL;\n\tdma_addr_t dataphysaddr, protphysaddr;\n\tunsigned short curr_data = 0, curr_prot = 0;\n\tunsigned int split_offset;\n\tunsigned int protgroup_len, protgroup_offset = 0, protgroup_remainder;\n\tunsigned int protgrp_blks, protgrp_bytes;\n\tunsigned int remainder, subtotal;\n\tint status;\n\tunsigned char pgdone = 0, alldone = 0;\n\tunsigned blksize;\n\tuint32_t reftag;\n\tuint8_t txop, rxop;\n\tuint32_t dma_len;\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tuint32_t rc;\n#endif\n\tuint32_t checking = 1;\n\tuint32_t dma_offset = 0;\n\tint num_sge = 0, j = 2;\n\tstruct sli4_hybrid_sgl *sgl_xtra = NULL;\n\n\tsgpe = scsi_prot_sglist(sc);\n\tsgde = scsi_sglist(sc);\n\n\tif (!sgpe || !sgde) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"9082 Invalid s/g entry: data=x%px prot=x%px\\n\",\n\t\t\t\tsgpe, sgde);\n\t\treturn 0;\n\t}\n\n\tstatus = lpfc_sc_to_bg_opcodes(phba, sc, &txop, &rxop);\n\tif (status)\n\t\tgoto out;\n\n\t/* extract some info from the scsi command */\n\tblksize = lpfc_cmd_blksize(sc);\n\treftag = (uint32_t)scsi_get_lba(sc); /* Truncate LBA */\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\trc = lpfc_bg_err_inject(phba, sc, &reftag, NULL, 1);\n\tif (rc) {\n\t\tif (rc & BG_ERR_SWAP)\n\t\t\tlpfc_bg_err_opcodes(phba, sc, &txop, &rxop);\n\t\tif (rc & BG_ERR_CHECK)\n\t\t\tchecking = 0;\n\t}\n#endif\n\n\tsplit_offset = 0;\n\tdo {\n\t\t/* Check to see if we ran out of space */\n\t\tif ((num_sge >= (phba->cfg_total_seg_cnt - 2)) &&\n\t\t    !(phba->cfg_xpsgl))\n\t\t\treturn num_sge + 3;\n\n\t\t/* DISEED and DIF have to be together */\n\t\tif (!((j + 1) % phba->border_sge_num) ||\n\t\t    !((j + 2) % phba->border_sge_num) ||\n\t\t    !((j + 3) % phba->border_sge_num)) {\n\t\t\tsgl->word2 = 0;\n\n\t\t\t/* set LSP type */\n\t\t\tbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_LSP);\n\n\t\t\tsgl_xtra = lpfc_get_sgl_per_hdwq(phba, lpfc_cmd);\n\n\t\t\tif (unlikely(!sgl_xtra)) {\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tsgl->addr_lo = cpu_to_le32(putPaddrLow(\n\t\t\t\t\t\tsgl_xtra->dma_phys_sgl));\n\t\t\t\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(\n\t\t\t\t\t\t       sgl_xtra->dma_phys_sgl));\n\t\t\t}\n\n\t\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\t\tsgl->sge_len = cpu_to_le32(phba->cfg_sg_dma_buf_size);\n\n\t\t\tsgl = (struct sli4_sge *)sgl_xtra->dma_sgl;\n\t\t\tj = 0;\n\t\t}\n\n\t\t/* setup DISEED with what we have */\n\t\tdiseed = (struct sli4_sge_diseed *) sgl;\n\t\tmemset(diseed, 0, sizeof(struct sli4_sge_diseed));\n\t\tbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_DISEED);\n\n\t\t/* Endianness conversion if necessary */\n\t\tdiseed->ref_tag = cpu_to_le32(reftag);\n\t\tdiseed->ref_tag_tran = diseed->ref_tag;\n\n\t\tif (lpfc_cmd_protect(sc, LPFC_CHECK_PROTECT_GUARD)) {\n\t\t\tbf_set(lpfc_sli4_sge_dif_ce, diseed, checking);\n\n\t\t} else {\n\t\t\tbf_set(lpfc_sli4_sge_dif_ce, diseed, 0);\n\t\t\t/*\n\t\t\t * When in this mode, the hardware will replace\n\t\t\t * the guard tag from the host with a\n\t\t\t * newly generated good CRC for the wire.\n\t\t\t * Switch to raw mode here to avoid this\n\t\t\t * behavior. What the host sends gets put on the wire.\n\t\t\t */\n\t\t\tif (txop == BG_OP_IN_CRC_OUT_CRC) {\n\t\t\t\ttxop = BG_OP_RAW_MODE;\n\t\t\t\trxop = BG_OP_RAW_MODE;\n\t\t\t}\n\t\t}\n\n\n\t\tif (lpfc_cmd_protect(sc, LPFC_CHECK_PROTECT_REF))\n\t\t\tbf_set(lpfc_sli4_sge_dif_re, diseed, checking);\n\t\telse\n\t\t\tbf_set(lpfc_sli4_sge_dif_re, diseed, 0);\n\n\t\t/* setup DISEED with the rest of the info */\n\t\tbf_set(lpfc_sli4_sge_dif_optx, diseed, txop);\n\t\tbf_set(lpfc_sli4_sge_dif_oprx, diseed, rxop);\n\n\t\tbf_set(lpfc_sli4_sge_dif_ai, diseed, 1);\n\t\tbf_set(lpfc_sli4_sge_dif_me, diseed, 0);\n\n\t\t/* Endianness conversion if necessary for DISEED */\n\t\tdiseed->word2 = cpu_to_le32(diseed->word2);\n\t\tdiseed->word3 = cpu_to_le32(diseed->word3);\n\n\t\t/* advance sgl and increment bde count */\n\t\tnum_sge++;\n\n\t\tsgl++;\n\t\tj++;\n\n\t\t/* setup the first BDE that points to protection buffer */\n\t\tprotphysaddr = sg_dma_address(sgpe) + protgroup_offset;\n\t\tprotgroup_len = sg_dma_len(sgpe) - protgroup_offset;\n\n\t\t/* must be integer multiple of the DIF block length */\n\t\tBUG_ON(protgroup_len % 8);\n\n\t\t/* Now setup DIF SGE */\n\t\tsgl->word2 = 0;\n\t\tbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_DIF);\n\t\tsgl->addr_hi = le32_to_cpu(putPaddrHigh(protphysaddr));\n\t\tsgl->addr_lo = le32_to_cpu(putPaddrLow(protphysaddr));\n\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\tsgl->sge_len = 0;\n\n\t\tprotgrp_blks = protgroup_len / 8;\n\t\tprotgrp_bytes = protgrp_blks * blksize;\n\n\t\t/* check if DIF SGE is crossing the 4K boundary; if so split */\n\t\tif ((sgl->addr_lo & 0xfff) + protgroup_len > 0x1000) {\n\t\t\tprotgroup_remainder = 0x1000 - (sgl->addr_lo & 0xfff);\n\t\t\tprotgroup_offset += protgroup_remainder;\n\t\t\tprotgrp_blks = protgroup_remainder / 8;\n\t\t\tprotgrp_bytes = protgrp_blks * blksize;\n\t\t} else {\n\t\t\tprotgroup_offset = 0;\n\t\t\tcurr_prot++;\n\t\t}\n\n\t\tnum_sge++;\n\n\t\t/* setup SGE's for data blocks associated with DIF data */\n\t\tpgdone = 0;\n\t\tsubtotal = 0; /* total bytes processed for current prot grp */\n\n\t\tsgl++;\n\t\tj++;\n\n\t\twhile (!pgdone) {\n\t\t\t/* Check to see if we ran out of space */\n\t\t\tif ((num_sge >= phba->cfg_total_seg_cnt) &&\n\t\t\t    !phba->cfg_xpsgl)\n\t\t\t\treturn num_sge + 1;\n\n\t\t\tif (!sgde) {\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9086 BLKGRD:%s Invalid data segment\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (!((j + 1) % phba->border_sge_num)) {\n\t\t\t\tsgl->word2 = 0;\n\n\t\t\t\t/* set LSP type */\n\t\t\t\tbf_set(lpfc_sli4_sge_type, sgl,\n\t\t\t\t       LPFC_SGE_TYPE_LSP);\n\n\t\t\t\tsgl_xtra = lpfc_get_sgl_per_hdwq(phba,\n\t\t\t\t\t\t\t\t lpfc_cmd);\n\n\t\t\t\tif (unlikely(!sgl_xtra)) {\n\t\t\t\t\tgoto out;\n\t\t\t\t} else {\n\t\t\t\t\tsgl->addr_lo = cpu_to_le32(\n\t\t\t\t\t  putPaddrLow(sgl_xtra->dma_phys_sgl));\n\t\t\t\t\tsgl->addr_hi = cpu_to_le32(\n\t\t\t\t\t  putPaddrHigh(sgl_xtra->dma_phys_sgl));\n\t\t\t\t}\n\n\t\t\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\t\t\tsgl->sge_len = cpu_to_le32(\n\t\t\t\t\t\t     phba->cfg_sg_dma_buf_size);\n\n\t\t\t\tsgl = (struct sli4_sge *)sgl_xtra->dma_sgl;\n\t\t\t} else {\n\t\t\t\tdataphysaddr = sg_dma_address(sgde) +\n\t\t\t\t\t\t\t\t   split_offset;\n\n\t\t\t\tremainder = sg_dma_len(sgde) - split_offset;\n\n\t\t\t\tif ((subtotal + remainder) <= protgrp_bytes) {\n\t\t\t\t\t/* we can use this whole buffer */\n\t\t\t\t\tdma_len = remainder;\n\t\t\t\t\tsplit_offset = 0;\n\n\t\t\t\t\tif ((subtotal + remainder) ==\n\t\t\t\t\t\t\t\t  protgrp_bytes)\n\t\t\t\t\t\tpgdone = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* must split this buffer with next\n\t\t\t\t\t * prot grp\n\t\t\t\t\t */\n\t\t\t\t\tdma_len = protgrp_bytes - subtotal;\n\t\t\t\t\tsplit_offset += dma_len;\n\t\t\t\t}\n\n\t\t\t\tsubtotal += dma_len;\n\n\t\t\t\tsgl->word2 = 0;\n\t\t\t\tsgl->addr_lo = cpu_to_le32(putPaddrLow(\n\t\t\t\t\t\t\t\t dataphysaddr));\n\t\t\t\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(\n\t\t\t\t\t\t\t\t dataphysaddr));\n\t\t\t\tbf_set(lpfc_sli4_sge_last, sgl, 0);\n\t\t\t\tbf_set(lpfc_sli4_sge_offset, sgl, dma_offset);\n\t\t\t\tbf_set(lpfc_sli4_sge_type, sgl,\n\t\t\t\t       LPFC_SGE_TYPE_DATA);\n\n\t\t\t\tsgl->sge_len = cpu_to_le32(dma_len);\n\t\t\t\tdma_offset += dma_len;\n\n\t\t\t\tnum_sge++;\n\t\t\t\tcurr_data++;\n\n\t\t\t\tif (split_offset) {\n\t\t\t\t\tsgl++;\n\t\t\t\t\tj++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* Move to the next s/g segment if possible */\n\t\t\t\tsgde = sg_next(sgde);\n\n\t\t\t\tsgl++;\n\t\t\t}\n\n\t\t\tj++;\n\t\t}\n\n\t\tif (protgroup_offset) {\n\t\t\t/* update the reference tag */\n\t\t\treftag += protgrp_blks;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* are we done ? */\n\t\tif (curr_prot == protcnt) {\n\t\t\t/* mark the last SGL */\n\t\t\tsgl--;\n\t\t\tbf_set(lpfc_sli4_sge_last, sgl, 1);\n\t\t\talldone = 1;\n\t\t} else if (curr_prot < protcnt) {\n\t\t\t/* advance to next prot buffer */\n\t\t\tsgpe = sg_next(sgpe);\n\n\t\t\t/* update the reference tag */\n\t\t\treftag += protgrp_blks;\n\t\t} else {\n\t\t\t/* if we're here, we have a bug */\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9085 BLKGRD: bug in %s\\n\", __func__);\n\t\t}\n\n\t} while (!alldone);\n\nout:\n\n\treturn num_sge;\n}\n\n/**\n * lpfc_prot_group_type - Get prtotection group type of SCSI command\n * @phba: The Hba for which this call is being executed.\n * @sc: pointer to scsi command we're working on\n *\n * Given a SCSI command that supports DIF, determine composition of protection\n * groups involved in setting up buffer lists\n *\n * Returns: Protection group type (with or without DIF)\n *\n **/\nstatic int\nlpfc_prot_group_type(struct lpfc_hba *phba, struct scsi_cmnd *sc)\n{\n\tint ret = LPFC_PG_TYPE_INVALID;\n\tunsigned char op = scsi_get_prot_op(sc);\n\n\tswitch (op) {\n\tcase SCSI_PROT_READ_STRIP:\n\tcase SCSI_PROT_WRITE_INSERT:\n\t\tret = LPFC_PG_TYPE_NO_DIF;\n\t\tbreak;\n\tcase SCSI_PROT_READ_INSERT:\n\tcase SCSI_PROT_WRITE_STRIP:\n\tcase SCSI_PROT_READ_PASS:\n\tcase SCSI_PROT_WRITE_PASS:\n\t\tret = LPFC_PG_TYPE_DIF_BUF;\n\t\tbreak;\n\tdefault:\n\t\tif (phba)\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9021 Unsupported protection op:%d\\n\",\n\t\t\t\t\top);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n/**\n * lpfc_bg_scsi_adjust_dl - Adjust SCSI data length for BlockGuard\n * @phba: The Hba for which this call is being executed.\n * @lpfc_cmd: The scsi buffer which is going to be adjusted.\n *\n * Adjust the data length to account for how much data\n * is actually on the wire.\n *\n * returns the adjusted data length\n **/\nstatic int\nlpfc_bg_scsi_adjust_dl(struct lpfc_hba *phba,\n\t\t       struct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct scsi_cmnd *sc = lpfc_cmd->pCmd;\n\tint fcpdl;\n\n\tfcpdl = scsi_bufflen(sc);\n\n\t/* Check if there is protection data on the wire */\n\tif (sc->sc_data_direction == DMA_FROM_DEVICE) {\n\t\t/* Read check for protection data */\n\t\tif (scsi_get_prot_op(sc) ==  SCSI_PROT_READ_INSERT)\n\t\t\treturn fcpdl;\n\n\t} else {\n\t\t/* Write check for protection data */\n\t\tif (scsi_get_prot_op(sc) ==  SCSI_PROT_WRITE_STRIP)\n\t\t\treturn fcpdl;\n\t}\n\n\t/*\n\t * If we are in DIF Type 1 mode every data block has a 8 byte\n\t * DIF (trailer) attached to it. Must ajust FCP data length\n\t * to account for the protection data.\n\t */\n\tfcpdl += (fcpdl / lpfc_cmd_blksize(sc)) * 8;\n\n\treturn fcpdl;\n}\n\n/**\n * lpfc_bg_scsi_prep_dma_buf_s3 - DMA mapping for scsi buffer to SLI3 IF spec\n * @phba: The Hba for which this call is being executed.\n * @lpfc_cmd: The scsi buffer which is going to be prep'ed.\n *\n * This is the protection/DIF aware version of\n * lpfc_scsi_prep_dma_buf(). It may be a good idea to combine the\n * two functions eventually, but for now, it's here.\n * RETURNS 0 - SUCCESS,\n *         1 - Failed DMA map, retry.\n *         2 - Invalid scsi cmd or prot-type. Do not rety.\n **/\nstatic int\nlpfc_bg_scsi_prep_dma_buf_s3(struct lpfc_hba *phba,\n\t\tstruct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\n\tstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\n\tstruct ulp_bde64 *bpl = (struct ulp_bde64 *)lpfc_cmd->dma_sgl;\n\tIOCB_t *iocb_cmd = &lpfc_cmd->cur_iocbq.iocb;\n\tuint32_t num_bde = 0;\n\tint datasegcnt, protsegcnt, datadir = scsi_cmnd->sc_data_direction;\n\tint prot_group_type = 0;\n\tint fcpdl;\n\tint ret = 1;\n\tstruct lpfc_vport *vport = phba->pport;\n\n\t/*\n\t * Start the lpfc command prep by bumping the bpl beyond fcp_cmnd\n\t *  fcp_rsp regions to the first data bde entry\n\t */\n\tbpl += 2;\n\tif (scsi_sg_count(scsi_cmnd)) {\n\t\t/*\n\t\t * The driver stores the segment count returned from pci_map_sg\n\t\t * because this a count of dma-mappings used to map the use_sg\n\t\t * pages.  They are not guaranteed to be the same for those\n\t\t * architectures that implement an IOMMU.\n\t\t */\n\t\tdatasegcnt = dma_map_sg(&phba->pcidev->dev,\n\t\t\t\t\tscsi_sglist(scsi_cmnd),\n\t\t\t\t\tscsi_sg_count(scsi_cmnd), datadir);\n\t\tif (unlikely(!datasegcnt))\n\t\t\treturn 1;\n\n\t\tlpfc_cmd->seg_cnt = datasegcnt;\n\n\t\t/* First check if data segment count from SCSI Layer is good */\n\t\tif (lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt) {\n\t\t\tWARN_ON_ONCE(lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt);\n\t\t\tret = 2;\n\t\t\tgoto err;\n\t\t}\n\n\t\tprot_group_type = lpfc_prot_group_type(phba, scsi_cmnd);\n\n\t\tswitch (prot_group_type) {\n\t\tcase LPFC_PG_TYPE_NO_DIF:\n\n\t\t\t/* Here we need to add a PDE5 and PDE6 to the count */\n\t\t\tif ((lpfc_cmd->seg_cnt + 2) > phba->cfg_total_seg_cnt) {\n\t\t\t\tret = 2;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tnum_bde = lpfc_bg_setup_bpl(phba, scsi_cmnd, bpl,\n\t\t\t\t\tdatasegcnt);\n\t\t\t/* we should have 2 or more entries in buffer list */\n\t\t\tif (num_bde < 2) {\n\t\t\t\tret = 2;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LPFC_PG_TYPE_DIF_BUF:\n\t\t\t/*\n\t\t\t * This type indicates that protection buffers are\n\t\t\t * passed to the driver, so that needs to be prepared\n\t\t\t * for DMA\n\t\t\t */\n\t\t\tprotsegcnt = dma_map_sg(&phba->pcidev->dev,\n\t\t\t\t\tscsi_prot_sglist(scsi_cmnd),\n\t\t\t\t\tscsi_prot_sg_count(scsi_cmnd), datadir);\n\t\t\tif (unlikely(!protsegcnt)) {\n\t\t\t\tscsi_dma_unmap(scsi_cmnd);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tlpfc_cmd->prot_seg_cnt = protsegcnt;\n\n\t\t\t/*\n\t\t\t * There is a minimun of 4 BPLs used for every\n\t\t\t * protection data segment.\n\t\t\t */\n\t\t\tif ((lpfc_cmd->prot_seg_cnt * 4) >\n\t\t\t    (phba->cfg_total_seg_cnt - 2)) {\n\t\t\t\tret = 2;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tnum_bde = lpfc_bg_setup_bpl_prot(phba, scsi_cmnd, bpl,\n\t\t\t\t\tdatasegcnt, protsegcnt);\n\t\t\t/* we should have 3 or more entries in buffer list */\n\t\t\tif ((num_bde < 3) ||\n\t\t\t    (num_bde > phba->cfg_total_seg_cnt)) {\n\t\t\t\tret = 2;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LPFC_PG_TYPE_INVALID:\n\t\tdefault:\n\t\t\tscsi_dma_unmap(scsi_cmnd);\n\t\t\tlpfc_cmd->seg_cnt = 0;\n\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9022 Unexpected protection group %i\\n\",\n\t\t\t\t\tprot_group_type);\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\t/*\n\t * Finish initializing those IOCB fields that are dependent on the\n\t * scsi_cmnd request_buffer.  Note that the bdeSize is explicitly\n\t * reinitialized since all iocb memory resources are used many times\n\t * for transmit, receive, and continuation bpl's.\n\t */\n\tiocb_cmd->un.fcpi64.bdl.bdeSize = (2 * sizeof(struct ulp_bde64));\n\tiocb_cmd->un.fcpi64.bdl.bdeSize += (num_bde * sizeof(struct ulp_bde64));\n\tiocb_cmd->ulpBdeCount = 1;\n\tiocb_cmd->ulpLe = 1;\n\n\tfcpdl = lpfc_bg_scsi_adjust_dl(phba, lpfc_cmd);\n\tfcp_cmnd->fcpDl = be32_to_cpu(fcpdl);\n\n\t/*\n\t * Due to difference in data length between DIF/non-DIF paths,\n\t * we need to set word 4 of IOCB here\n\t */\n\tiocb_cmd->un.fcpi.fcpi_parm = fcpdl;\n\n\t/*\n\t * For First burst, we may need to adjust the initial transfer\n\t * length for DIF\n\t */\n\tif (iocb_cmd->un.fcpi.fcpi_XRdy &&\n\t    (fcpdl < vport->cfg_first_burst_size))\n\t\tiocb_cmd->un.fcpi.fcpi_XRdy = fcpdl;\n\n\treturn 0;\nerr:\n\tif (lpfc_cmd->seg_cnt)\n\t\tscsi_dma_unmap(scsi_cmnd);\n\tif (lpfc_cmd->prot_seg_cnt)\n\t\tdma_unmap_sg(&phba->pcidev->dev, scsi_prot_sglist(scsi_cmnd),\n\t\t\t     scsi_prot_sg_count(scsi_cmnd),\n\t\t\t     scsi_cmnd->sc_data_direction);\n\n\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"9023 Cannot setup S/G List for HBA\"\n\t\t\t\"IO segs %d/%d BPL %d SCSI %d: %d %d\\n\",\n\t\t\tlpfc_cmd->seg_cnt, lpfc_cmd->prot_seg_cnt,\n\t\t\tphba->cfg_total_seg_cnt, phba->cfg_sg_seg_cnt,\n\t\t\tprot_group_type, num_bde);\n\n\tlpfc_cmd->seg_cnt = 0;\n\tlpfc_cmd->prot_seg_cnt = 0;\n\treturn ret;\n}\n\n/*\n * This function calcuates the T10 DIF guard tag\n * on the specified data using a CRC algorithmn\n * using crc_t10dif.\n */\nstatic uint16_t\nlpfc_bg_crc(uint8_t *data, int count)\n{\n\tuint16_t crc = 0;\n\tuint16_t x;\n\n\tcrc = crc_t10dif(data, count);\n\tx = cpu_to_be16(crc);\n\treturn x;\n}\n\n/*\n * This function calcuates the T10 DIF guard tag\n * on the specified data using a CSUM algorithmn\n * using ip_compute_csum.\n */\nstatic uint16_t\nlpfc_bg_csum(uint8_t *data, int count)\n{\n\tuint16_t ret;\n\n\tret = ip_compute_csum(data, count);\n\treturn ret;\n}\n\n/*\n * This function examines the protection data to try to determine\n * what type of T10-DIF error occurred.\n */\nstatic void\nlpfc_calc_bg_err(struct lpfc_hba *phba, struct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct scatterlist *sgpe; /* s/g prot entry */\n\tstruct scatterlist *sgde; /* s/g data entry */\n\tstruct scsi_cmnd *cmd = lpfc_cmd->pCmd;\n\tstruct scsi_dif_tuple *src = NULL;\n\tuint8_t *data_src = NULL;\n\tuint16_t guard_tag;\n\tuint16_t start_app_tag, app_tag;\n\tuint32_t start_ref_tag, ref_tag;\n\tint prot, protsegcnt;\n\tint err_type, len, data_len;\n\tint chk_ref, chk_app, chk_guard;\n\tuint16_t sum;\n\tunsigned blksize;\n\n\terr_type = BGS_GUARD_ERR_MASK;\n\tsum = 0;\n\tguard_tag = 0;\n\n\t/* First check to see if there is protection data to examine */\n\tprot = scsi_get_prot_op(cmd);\n\tif ((prot == SCSI_PROT_READ_STRIP) ||\n\t    (prot == SCSI_PROT_WRITE_INSERT) ||\n\t    (prot == SCSI_PROT_NORMAL))\n\t\tgoto out;\n\n\t/* Currently the driver just supports ref_tag and guard_tag checking */\n\tchk_ref = 1;\n\tchk_app = 0;\n\tchk_guard = 0;\n\n\t/* Setup a ptr to the protection data provided by the SCSI host */\n\tsgpe = scsi_prot_sglist(cmd);\n\tprotsegcnt = lpfc_cmd->prot_seg_cnt;\n\n\tif (sgpe && protsegcnt) {\n\n\t\t/*\n\t\t * We will only try to verify guard tag if the segment\n\t\t * data length is a multiple of the blksize.\n\t\t */\n\t\tsgde = scsi_sglist(cmd);\n\t\tblksize = lpfc_cmd_blksize(cmd);\n\t\tdata_src = (uint8_t *)sg_virt(sgde);\n\t\tdata_len = sgde->length;\n\t\tif ((data_len & (blksize - 1)) == 0)\n\t\t\tchk_guard = 1;\n\n\t\tsrc = (struct scsi_dif_tuple *)sg_virt(sgpe);\n\t\tstart_ref_tag = (uint32_t)scsi_get_lba(cmd); /* Truncate LBA */\n\t\tstart_app_tag = src->app_tag;\n\t\tlen = sgpe->length;\n\t\twhile (src && protsegcnt) {\n\t\t\twhile (len) {\n\n\t\t\t\t/*\n\t\t\t\t * First check to see if a protection data\n\t\t\t\t * check is valid\n\t\t\t\t */\n\t\t\t\tif ((src->ref_tag == T10_PI_REF_ESCAPE) ||\n\t\t\t\t    (src->app_tag == T10_PI_APP_ESCAPE)) {\n\t\t\t\t\tstart_ref_tag++;\n\t\t\t\t\tgoto skipit;\n\t\t\t\t}\n\n\t\t\t\t/* First Guard Tag checking */\n\t\t\t\tif (chk_guard) {\n\t\t\t\t\tguard_tag = src->guard_tag;\n\t\t\t\t\tif (lpfc_cmd_guard_csum(cmd))\n\t\t\t\t\t\tsum = lpfc_bg_csum(data_src,\n\t\t\t\t\t\t\t\t   blksize);\n\t\t\t\t\telse\n\t\t\t\t\t\tsum = lpfc_bg_crc(data_src,\n\t\t\t\t\t\t\t\t  blksize);\n\t\t\t\t\tif ((guard_tag != sum)) {\n\t\t\t\t\t\terr_type = BGS_GUARD_ERR_MASK;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Reference Tag checking */\n\t\t\t\tref_tag = be32_to_cpu(src->ref_tag);\n\t\t\t\tif (chk_ref && (ref_tag != start_ref_tag)) {\n\t\t\t\t\terr_type = BGS_REFTAG_ERR_MASK;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tstart_ref_tag++;\n\n\t\t\t\t/* App Tag checking */\n\t\t\t\tapp_tag = src->app_tag;\n\t\t\t\tif (chk_app && (app_tag != start_app_tag)) {\n\t\t\t\t\terr_type = BGS_APPTAG_ERR_MASK;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\nskipit:\n\t\t\t\tlen -= sizeof(struct scsi_dif_tuple);\n\t\t\t\tif (len < 0)\n\t\t\t\t\tlen = 0;\n\t\t\t\tsrc++;\n\n\t\t\t\tdata_src += blksize;\n\t\t\t\tdata_len -= blksize;\n\n\t\t\t\t/*\n\t\t\t\t * Are we at the end of the Data segment?\n\t\t\t\t * The data segment is only used for Guard\n\t\t\t\t * tag checking.\n\t\t\t\t */\n\t\t\t\tif (chk_guard && (data_len == 0)) {\n\t\t\t\t\tchk_guard = 0;\n\t\t\t\t\tsgde = sg_next(sgde);\n\t\t\t\t\tif (!sgde)\n\t\t\t\t\t\tgoto out;\n\n\t\t\t\t\tdata_src = (uint8_t *)sg_virt(sgde);\n\t\t\t\t\tdata_len = sgde->length;\n\t\t\t\t\tif ((data_len & (blksize - 1)) == 0)\n\t\t\t\t\t\tchk_guard = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Goto the next Protection data segment */\n\t\t\tsgpe = sg_next(sgpe);\n\t\t\tif (sgpe) {\n\t\t\t\tsrc = (struct scsi_dif_tuple *)sg_virt(sgpe);\n\t\t\t\tlen = sgpe->length;\n\t\t\t} else {\n\t\t\t\tsrc = NULL;\n\t\t\t}\n\t\t\tprotsegcnt--;\n\t\t}\n\t}\nout:\n\tif (err_type == BGS_GUARD_ERR_MASK) {\n\t\tscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\n\t\t\t\t\t0x10, 0x1);\n\t\tcmd->result = DRIVER_SENSE << 24 | DID_ABORT << 16 |\n\t\t\t      SAM_STAT_CHECK_CONDITION;\n\t\tphba->bg_guard_err_cnt++;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9069 BLKGRD: LBA %lx grd_tag error %x != %x\\n\",\n\t\t\t\t(unsigned long)scsi_get_lba(cmd),\n\t\t\t\tsum, guard_tag);\n\n\t} else if (err_type == BGS_REFTAG_ERR_MASK) {\n\t\tscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\n\t\t\t\t\t0x10, 0x3);\n\t\tcmd->result = DRIVER_SENSE << 24 | DID_ABORT << 16 |\n\t\t\t      SAM_STAT_CHECK_CONDITION;\n\n\t\tphba->bg_reftag_err_cnt++;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9066 BLKGRD: LBA %lx ref_tag error %x != %x\\n\",\n\t\t\t\t(unsigned long)scsi_get_lba(cmd),\n\t\t\t\tref_tag, start_ref_tag);\n\n\t} else if (err_type == BGS_APPTAG_ERR_MASK) {\n\t\tscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\n\t\t\t\t\t0x10, 0x2);\n\t\tcmd->result = DRIVER_SENSE << 24 | DID_ABORT << 16 |\n\t\t\t      SAM_STAT_CHECK_CONDITION;\n\n\t\tphba->bg_apptag_err_cnt++;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9041 BLKGRD: LBA %lx app_tag error %x != %x\\n\",\n\t\t\t\t(unsigned long)scsi_get_lba(cmd),\n\t\t\t\tapp_tag, start_app_tag);\n\t}\n}\n\n/*\n * This function checks for BlockGuard errors detected by\n * the HBA.  In case of errors, the ASC/ASCQ fields in the\n * sense buffer will be set accordingly, paired with\n * ILLEGAL_REQUEST to signal to the kernel that the HBA\n * detected corruption.\n *\n * Returns:\n *  0 - No error found\n *  1 - BlockGuard error found\n * -1 - Internal error (bad profile, ...etc)\n */\nstatic int\nlpfc_sli4_parse_bg_err(struct lpfc_hba *phba, struct lpfc_io_buf *lpfc_cmd,\n\t\t       struct lpfc_wcqe_complete *wcqe)\n{\n\tstruct scsi_cmnd *cmd = lpfc_cmd->pCmd;\n\tint ret = 0;\n\tu32 status = bf_get(lpfc_wcqe_c_status, wcqe);\n\tu32 bghm = 0;\n\tu32 bgstat = 0;\n\tu64 failing_sector = 0;\n\n\tif (status == CQE_STATUS_DI_ERROR) {\n\t\tif (bf_get(lpfc_wcqe_c_bg_ge, wcqe)) /* Guard Check failed */\n\t\t\tbgstat |= BGS_GUARD_ERR_MASK;\n\t\tif (bf_get(lpfc_wcqe_c_bg_ae, wcqe)) /* AppTag Check failed */\n\t\t\tbgstat |= BGS_APPTAG_ERR_MASK;\n\t\tif (bf_get(lpfc_wcqe_c_bg_re, wcqe)) /* RefTag Check failed */\n\t\t\tbgstat |= BGS_REFTAG_ERR_MASK;\n\n\t\t/* Check to see if there was any good data before the error */\n\t\tif (bf_get(lpfc_wcqe_c_bg_tdpv, wcqe)) {\n\t\t\tbgstat |= BGS_HI_WATER_MARK_PRESENT_MASK;\n\t\t\tbghm = wcqe->total_data_placed;\n\t\t}\n\n\t\t/*\n\t\t * Set ALL the error bits to indicate we don't know what\n\t\t * type of error it is.\n\t\t */\n\t\tif (!bgstat)\n\t\t\tbgstat |= (BGS_REFTAG_ERR_MASK | BGS_APPTAG_ERR_MASK |\n\t\t\t\tBGS_GUARD_ERR_MASK);\n\t}\n\n\tif (lpfc_bgs_get_guard_err(bgstat)) {\n\t\tret = 1;\n\n\t\tscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\n\t\t\t\t\t0x10, 0x1);\n\t\tcmd->result = DRIVER_SENSE << 24 | DID_ABORT << 16 |\n\t\t\t      SAM_STAT_CHECK_CONDITION;\n\t\tphba->bg_guard_err_cnt++;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9059 BLKGRD: Guard Tag error in cmd\"\n\t\t\t\t\" 0x%x lba 0x%llx blk cnt 0x%x \"\n\t\t\t\t\"bgstat=x%x bghm=x%x\\n\", cmd->cmnd[0],\n\t\t\t\t(unsigned long long)scsi_get_lba(cmd),\n\t\t\t\tblk_rq_sectors(cmd->request), bgstat, bghm);\n\t}\n\n\tif (lpfc_bgs_get_reftag_err(bgstat)) {\n\t\tret = 1;\n\n\t\tscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\n\t\t\t\t\t0x10, 0x3);\n\t\tcmd->result = DRIVER_SENSE << 24 | DID_ABORT << 16 |\n\t\t\t      SAM_STAT_CHECK_CONDITION;\n\n\t\tphba->bg_reftag_err_cnt++;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9060 BLKGRD: Ref Tag error in cmd\"\n\t\t\t\t\" 0x%x lba 0x%llx blk cnt 0x%x \"\n\t\t\t\t\"bgstat=x%x bghm=x%x\\n\", cmd->cmnd[0],\n\t\t\t\t(unsigned long long)scsi_get_lba(cmd),\n\t\t\t\tblk_rq_sectors(cmd->request), bgstat, bghm);\n\t}\n\n\tif (lpfc_bgs_get_apptag_err(bgstat)) {\n\t\tret = 1;\n\n\t\tscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\n\t\t\t\t\t0x10, 0x2);\n\t\tcmd->result = DRIVER_SENSE << 24 | DID_ABORT << 16 |\n\t\t\t      SAM_STAT_CHECK_CONDITION;\n\n\t\tphba->bg_apptag_err_cnt++;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9062 BLKGRD: App Tag error in cmd\"\n\t\t\t\t\" 0x%x lba 0x%llx blk cnt 0x%x \"\n\t\t\t\t\"bgstat=x%x bghm=x%x\\n\", cmd->cmnd[0],\n\t\t\t\t(unsigned long long)scsi_get_lba(cmd),\n\t\t\t\tblk_rq_sectors(cmd->request), bgstat, bghm);\n\t}\n\n\tif (lpfc_bgs_get_hi_water_mark_present(bgstat)) {\n\t\t/*\n\t\t * setup sense data descriptor 0 per SPC-4 as an information\n\t\t * field, and put the failing LBA in it.\n\t\t * This code assumes there was also a guard/app/ref tag error\n\t\t * indication.\n\t\t */\n\t\tcmd->sense_buffer[7] = 0xc;   /* Additional sense length */\n\t\tcmd->sense_buffer[8] = 0;     /* Information descriptor type */\n\t\tcmd->sense_buffer[9] = 0xa;   /* Additional descriptor length */\n\t\tcmd->sense_buffer[10] = 0x80; /* Validity bit */\n\n\t\t/* bghm is a \"on the wire\" FC frame based count */\n\t\tswitch (scsi_get_prot_op(cmd)) {\n\t\tcase SCSI_PROT_READ_INSERT:\n\t\tcase SCSI_PROT_WRITE_STRIP:\n\t\t\tbghm /= cmd->device->sector_size;\n\t\t\tbreak;\n\t\tcase SCSI_PROT_READ_STRIP:\n\t\tcase SCSI_PROT_WRITE_INSERT:\n\t\tcase SCSI_PROT_READ_PASS:\n\t\tcase SCSI_PROT_WRITE_PASS:\n\t\t\tbghm /= (cmd->device->sector_size +\n\t\t\t\tsizeof(struct scsi_dif_tuple));\n\t\t\tbreak;\n\t\t}\n\n\t\tfailing_sector = scsi_get_lba(cmd);\n\t\tfailing_sector += bghm;\n\n\t\t/* Descriptor Information */\n\t\tput_unaligned_be64(failing_sector, &cmd->sense_buffer[12]);\n\t}\n\n\tif (!ret) {\n\t\t/* No error was reported - problem in FW? */\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9068 BLKGRD: Unknown error in cmd\"\n\t\t\t\t\" 0x%x lba 0x%llx blk cnt 0x%x \"\n\t\t\t\t\"bgstat=x%x bghm=x%x\\n\", cmd->cmnd[0],\n\t\t\t\t(unsigned long long)scsi_get_lba(cmd),\n\t\t\t\tblk_rq_sectors(cmd->request), bgstat, bghm);\n\n\t\t/* Calcuate what type of error it was */\n\t\tlpfc_calc_bg_err(phba, lpfc_cmd);\n\t}\n\treturn ret;\n}\n\n/*\n * This function checks for BlockGuard errors detected by\n * the HBA.  In case of errors, the ASC/ASCQ fields in the\n * sense buffer will be set accordingly, paired with\n * ILLEGAL_REQUEST to signal to the kernel that the HBA\n * detected corruption.\n *\n * Returns:\n *  0 - No error found\n *  1 - BlockGuard error found\n * -1 - Internal error (bad profile, ...etc)\n */\nstatic int\nlpfc_parse_bg_err(struct lpfc_hba *phba, struct lpfc_io_buf *lpfc_cmd,\n\t\t  struct lpfc_iocbq *pIocbOut)\n{\n\tstruct scsi_cmnd *cmd = lpfc_cmd->pCmd;\n\tstruct sli3_bg_fields *bgf = &pIocbOut->iocb.unsli3.sli3_bg;\n\tint ret = 0;\n\tuint32_t bghm = bgf->bghm;\n\tuint32_t bgstat = bgf->bgstat;\n\tuint64_t failing_sector = 0;\n\n\tif (lpfc_bgs_get_invalid_prof(bgstat)) {\n\t\tcmd->result = DID_ERROR << 16;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9072 BLKGRD: Invalid BG Profile in cmd\"\n\t\t\t\t\" 0x%x lba 0x%llx blk cnt 0x%x \"\n\t\t\t\t\"bgstat=x%x bghm=x%x\\n\", cmd->cmnd[0],\n\t\t\t\t(unsigned long long)scsi_get_lba(cmd),\n\t\t\t\tblk_rq_sectors(cmd->request), bgstat, bghm);\n\t\tret = (-1);\n\t\tgoto out;\n\t}\n\n\tif (lpfc_bgs_get_uninit_dif_block(bgstat)) {\n\t\tcmd->result = DID_ERROR << 16;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9073 BLKGRD: Invalid BG PDIF Block in cmd\"\n\t\t\t\t\" 0x%x lba 0x%llx blk cnt 0x%x \"\n\t\t\t\t\"bgstat=x%x bghm=x%x\\n\", cmd->cmnd[0],\n\t\t\t\t(unsigned long long)scsi_get_lba(cmd),\n\t\t\t\tblk_rq_sectors(cmd->request), bgstat, bghm);\n\t\tret = (-1);\n\t\tgoto out;\n\t}\n\n\tif (lpfc_bgs_get_guard_err(bgstat)) {\n\t\tret = 1;\n\n\t\tscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\n\t\t\t\t0x10, 0x1);\n\t\tcmd->result = DRIVER_SENSE << 24 | DID_ABORT << 16 |\n\t\t\t      SAM_STAT_CHECK_CONDITION;\n\t\tphba->bg_guard_err_cnt++;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9055 BLKGRD: Guard Tag error in cmd\"\n\t\t\t\t\" 0x%x lba 0x%llx blk cnt 0x%x \"\n\t\t\t\t\"bgstat=x%x bghm=x%x\\n\", cmd->cmnd[0],\n\t\t\t\t(unsigned long long)scsi_get_lba(cmd),\n\t\t\t\tblk_rq_sectors(cmd->request), bgstat, bghm);\n\t}\n\n\tif (lpfc_bgs_get_reftag_err(bgstat)) {\n\t\tret = 1;\n\n\t\tscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\n\t\t\t\t0x10, 0x3);\n\t\tcmd->result = DRIVER_SENSE << 24 | DID_ABORT << 16 |\n\t\t\t      SAM_STAT_CHECK_CONDITION;\n\n\t\tphba->bg_reftag_err_cnt++;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9056 BLKGRD: Ref Tag error in cmd\"\n\t\t\t\t\" 0x%x lba 0x%llx blk cnt 0x%x \"\n\t\t\t\t\"bgstat=x%x bghm=x%x\\n\", cmd->cmnd[0],\n\t\t\t\t(unsigned long long)scsi_get_lba(cmd),\n\t\t\t\tblk_rq_sectors(cmd->request), bgstat, bghm);\n\t}\n\n\tif (lpfc_bgs_get_apptag_err(bgstat)) {\n\t\tret = 1;\n\n\t\tscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\n\t\t\t\t0x10, 0x2);\n\t\tcmd->result = DRIVER_SENSE << 24 | DID_ABORT << 16 |\n\t\t\t      SAM_STAT_CHECK_CONDITION;\n\n\t\tphba->bg_apptag_err_cnt++;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9061 BLKGRD: App Tag error in cmd\"\n\t\t\t\t\" 0x%x lba 0x%llx blk cnt 0x%x \"\n\t\t\t\t\"bgstat=x%x bghm=x%x\\n\", cmd->cmnd[0],\n\t\t\t\t(unsigned long long)scsi_get_lba(cmd),\n\t\t\t\tblk_rq_sectors(cmd->request), bgstat, bghm);\n\t}\n\n\tif (lpfc_bgs_get_hi_water_mark_present(bgstat)) {\n\t\t/*\n\t\t * setup sense data descriptor 0 per SPC-4 as an information\n\t\t * field, and put the failing LBA in it.\n\t\t * This code assumes there was also a guard/app/ref tag error\n\t\t * indication.\n\t\t */\n\t\tcmd->sense_buffer[7] = 0xc;   /* Additional sense length */\n\t\tcmd->sense_buffer[8] = 0;     /* Information descriptor type */\n\t\tcmd->sense_buffer[9] = 0xa;   /* Additional descriptor length */\n\t\tcmd->sense_buffer[10] = 0x80; /* Validity bit */\n\n\t\t/* bghm is a \"on the wire\" FC frame based count */\n\t\tswitch (scsi_get_prot_op(cmd)) {\n\t\tcase SCSI_PROT_READ_INSERT:\n\t\tcase SCSI_PROT_WRITE_STRIP:\n\t\t\tbghm /= cmd->device->sector_size;\n\t\t\tbreak;\n\t\tcase SCSI_PROT_READ_STRIP:\n\t\tcase SCSI_PROT_WRITE_INSERT:\n\t\tcase SCSI_PROT_READ_PASS:\n\t\tcase SCSI_PROT_WRITE_PASS:\n\t\t\tbghm /= (cmd->device->sector_size +\n\t\t\t\tsizeof(struct scsi_dif_tuple));\n\t\t\tbreak;\n\t\t}\n\n\t\tfailing_sector = scsi_get_lba(cmd);\n\t\tfailing_sector += bghm;\n\n\t\t/* Descriptor Information */\n\t\tput_unaligned_be64(failing_sector, &cmd->sense_buffer[12]);\n\t}\n\n\tif (!ret) {\n\t\t/* No error was reported - problem in FW? */\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9057 BLKGRD: Unknown error in cmd\"\n\t\t\t\t\" 0x%x lba 0x%llx blk cnt 0x%x \"\n\t\t\t\t\"bgstat=x%x bghm=x%x\\n\", cmd->cmnd[0],\n\t\t\t\t(unsigned long long)scsi_get_lba(cmd),\n\t\t\t\tblk_rq_sectors(cmd->request), bgstat, bghm);\n\n\t\t/* Calcuate what type of error it was */\n\t\tlpfc_calc_bg_err(phba, lpfc_cmd);\n\t}\nout:\n\treturn ret;\n}\n\n/**\n * lpfc_scsi_prep_dma_buf_s4 - DMA mapping for scsi buffer to SLI4 IF spec\n * @phba: The Hba for which this call is being executed.\n * @lpfc_cmd: The scsi buffer which is going to be mapped.\n *\n * This routine does the pci dma mapping for scatter-gather list of scsi cmnd\n * field of @lpfc_cmd for device with SLI-4 interface spec.\n *\n * Return codes:\n *\t2 - Error - Do not retry\n *\t1 - Error - Retry\n *\t0 - Success\n **/\nstatic int\nlpfc_scsi_prep_dma_buf_s4(struct lpfc_hba *phba, struct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\n\tstruct scatterlist *sgel = NULL;\n\tstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\n\tstruct sli4_sge *sgl = (struct sli4_sge *)lpfc_cmd->dma_sgl;\n\tstruct sli4_sge *first_data_sgl;\n\tstruct lpfc_iocbq *pwqeq = &lpfc_cmd->cur_iocbq;\n\tstruct lpfc_vport *vport = phba->pport;\n\tunion lpfc_wqe128 *wqe = &pwqeq->wqe;\n\tdma_addr_t physaddr;\n\tuint32_t num_bde = 0;\n\tuint32_t dma_len;\n\tuint32_t dma_offset = 0;\n\tint nseg, i, j;\n\tstruct ulp_bde64 *bde;\n\tbool lsp_just_set = false;\n\tstruct sli4_hybrid_sgl *sgl_xtra = NULL;\n\n\t/*\n\t * There are three possibilities here - use scatter-gather segment, use\n\t * the single mapping, or neither.  Start the lpfc command prep by\n\t * bumping the bpl beyond the fcp_cmnd and fcp_rsp regions to the first\n\t * data bde entry.\n\t */\n\tif (scsi_sg_count(scsi_cmnd)) {\n\t\t/*\n\t\t * The driver stores the segment count returned from pci_map_sg\n\t\t * because this a count of dma-mappings used to map the use_sg\n\t\t * pages.  They are not guaranteed to be the same for those\n\t\t * architectures that implement an IOMMU.\n\t\t */\n\n\t\tnseg = scsi_dma_map(scsi_cmnd);\n\t\tif (unlikely(nseg <= 0))\n\t\t\treturn 1;\n\t\tsgl += 1;\n\t\t/* clear the last flag in the fcp_rsp map entry */\n\t\tsgl->word2 = le32_to_cpu(sgl->word2);\n\t\tbf_set(lpfc_sli4_sge_last, sgl, 0);\n\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\tsgl += 1;\n\t\tfirst_data_sgl = sgl;\n\t\tlpfc_cmd->seg_cnt = nseg;\n\t\tif (!phba->cfg_xpsgl &&\n\t\t    lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9074 BLKGRD:\"\n\t\t\t\t\t\" %s: Too many sg segments from \"\n\t\t\t\t\t\"dma_map_sg.  Config %d, seg_cnt %d\\n\",\n\t\t\t\t\t__func__, phba->cfg_sg_seg_cnt,\n\t\t\t\t\tlpfc_cmd->seg_cnt);\n\t\t\tWARN_ON_ONCE(lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt);\n\t\t\tlpfc_cmd->seg_cnt = 0;\n\t\t\tscsi_dma_unmap(scsi_cmnd);\n\t\t\treturn 2;\n\t\t}\n\n\t\t/*\n\t\t * The driver established a maximum scatter-gather segment count\n\t\t * during probe that limits the number of sg elements in any\n\t\t * single scsi command.  Just run through the seg_cnt and format\n\t\t * the sge's.\n\t\t * When using SLI-3 the driver will try to fit all the BDEs into\n\t\t * the IOCB. If it can't then the BDEs get added to a BPL as it\n\t\t * does for SLI-2 mode.\n\t\t */\n\n\t\t/* for tracking segment boundaries */\n\t\tsgel = scsi_sglist(scsi_cmnd);\n\t\tj = 2;\n\t\tfor (i = 0; i < nseg; i++) {\n\t\t\tsgl->word2 = 0;\n\t\t\tif ((num_bde + 1) == nseg) {\n\t\t\t\tbf_set(lpfc_sli4_sge_last, sgl, 1);\n\t\t\t\tbf_set(lpfc_sli4_sge_type, sgl,\n\t\t\t\t       LPFC_SGE_TYPE_DATA);\n\t\t\t} else {\n\t\t\t\tbf_set(lpfc_sli4_sge_last, sgl, 0);\n\n\t\t\t\t/* do we need to expand the segment */\n\t\t\t\tif (!lsp_just_set &&\n\t\t\t\t    !((j + 1) % phba->border_sge_num) &&\n\t\t\t\t    ((nseg - 1) != i)) {\n\t\t\t\t\t/* set LSP type */\n\t\t\t\t\tbf_set(lpfc_sli4_sge_type, sgl,\n\t\t\t\t\t       LPFC_SGE_TYPE_LSP);\n\n\t\t\t\t\tsgl_xtra = lpfc_get_sgl_per_hdwq(\n\t\t\t\t\t\t\tphba, lpfc_cmd);\n\n\t\t\t\t\tif (unlikely(!sgl_xtra)) {\n\t\t\t\t\t\tlpfc_cmd->seg_cnt = 0;\n\t\t\t\t\t\tscsi_dma_unmap(scsi_cmnd);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tsgl->addr_lo = cpu_to_le32(putPaddrLow(\n\t\t\t\t\t\t       sgl_xtra->dma_phys_sgl));\n\t\t\t\t\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(\n\t\t\t\t\t\t       sgl_xtra->dma_phys_sgl));\n\n\t\t\t\t} else {\n\t\t\t\t\tbf_set(lpfc_sli4_sge_type, sgl,\n\t\t\t\t\t       LPFC_SGE_TYPE_DATA);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!(bf_get(lpfc_sli4_sge_type, sgl) &\n\t\t\t\t     LPFC_SGE_TYPE_LSP)) {\n\t\t\t\tif ((nseg - 1) == i)\n\t\t\t\t\tbf_set(lpfc_sli4_sge_last, sgl, 1);\n\n\t\t\t\tphysaddr = sg_dma_address(sgel);\n\t\t\t\tdma_len = sg_dma_len(sgel);\n\t\t\t\tsgl->addr_lo = cpu_to_le32(putPaddrLow(\n\t\t\t\t\t\t\t   physaddr));\n\t\t\t\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(\n\t\t\t\t\t\t\t   physaddr));\n\n\t\t\t\tbf_set(lpfc_sli4_sge_offset, sgl, dma_offset);\n\t\t\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\t\t\tsgl->sge_len = cpu_to_le32(dma_len);\n\n\t\t\t\tdma_offset += dma_len;\n\t\t\t\tsgel = sg_next(sgel);\n\n\t\t\t\tsgl++;\n\t\t\t\tlsp_just_set = false;\n\n\t\t\t} else {\n\t\t\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\t\t\tsgl->sge_len = cpu_to_le32(\n\t\t\t\t\t\t     phba->cfg_sg_dma_buf_size);\n\n\t\t\t\tsgl = (struct sli4_sge *)sgl_xtra->dma_sgl;\n\t\t\t\ti = i - 1;\n\n\t\t\t\tlsp_just_set = true;\n\t\t\t}\n\n\t\t\tj++;\n\t\t}\n\t\t/*\n\t\t * Setup the first Payload BDE. For FCoE we just key off\n\t\t * Performance Hints, for FC we use lpfc_enable_pbde.\n\t\t * We populate words 13-15 of IOCB/WQE.\n\t\t */\n\t\tif ((phba->sli3_options & LPFC_SLI4_PERFH_ENABLED) ||\n\t\t    phba->cfg_enable_pbde) {\n\t\t\tbde = (struct ulp_bde64 *)\n\t\t\t\t&wqe->words[13];\n\t\t\tbde->addrLow = first_data_sgl->addr_lo;\n\t\t\tbde->addrHigh = first_data_sgl->addr_hi;\n\t\t\tbde->tus.f.bdeSize =\n\t\t\t\t\tle32_to_cpu(first_data_sgl->sge_len);\n\t\t\tbde->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t\t\tbde->tus.w = cpu_to_le32(bde->tus.w);\n\n\t\t} else {\n\t\t\tmemset(&wqe->words[13], 0, (sizeof(uint32_t) * 3));\n\t\t}\n\t} else {\n\t\tsgl += 1;\n\t\t/* clear the last flag in the fcp_rsp map entry */\n\t\tsgl->word2 = le32_to_cpu(sgl->word2);\n\t\tbf_set(lpfc_sli4_sge_last, sgl, 1);\n\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\n\t\tif ((phba->sli3_options & LPFC_SLI4_PERFH_ENABLED) ||\n\t\t    phba->cfg_enable_pbde) {\n\t\t\tbde = (struct ulp_bde64 *)\n\t\t\t\t&wqe->words[13];\n\t\t\tmemset(bde, 0, (sizeof(uint32_t) * 3));\n\t\t}\n\t}\n\n\t/* Word 11 */\n\tif (phba->cfg_enable_pbde)\n\t\tbf_set(wqe_pbde, &wqe->generic.wqe_com, 1);\n\n\t/*\n\t * Finish initializing those IOCB fields that are dependent on the\n\t * scsi_cmnd request_buffer.  Note that for SLI-2 the bdeSize is\n\t * explicitly reinitialized.\n\t * all iocb memory resources are reused.\n\t */\n\tfcp_cmnd->fcpDl = cpu_to_be32(scsi_bufflen(scsi_cmnd));\n\t/* Set first-burst provided it was successfully negotiated */\n\tif (!(phba->hba_flag & HBA_FCOE_MODE) &&\n\t    vport->cfg_first_burst_size &&\n\t    scsi_cmnd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tu32 init_len, total_len;\n\n\t\ttotal_len = be32_to_cpu(fcp_cmnd->fcpDl);\n\t\tinit_len = min(total_len, vport->cfg_first_burst_size);\n\n\t\t/* Word 4 & 5 */\n\t\twqe->fcp_iwrite.initial_xfer_len = init_len;\n\t\twqe->fcp_iwrite.total_xfer_len = total_len;\n\t} else {\n\t\t/* Word 4 */\n\t\twqe->fcp_iwrite.total_xfer_len =\n\t\t\tbe32_to_cpu(fcp_cmnd->fcpDl);\n\t}\n\n\t/*\n\t * If the OAS driver feature is enabled and the lun is enabled for\n\t * OAS, set the oas iocb related flags.\n\t */\n\tif ((phba->cfg_fof) && ((struct lpfc_device_data *)\n\t\tscsi_cmnd->device->hostdata)->oas_enabled) {\n\t\tlpfc_cmd->cur_iocbq.iocb_flag |= (LPFC_IO_OAS | LPFC_IO_FOF);\n\t\tlpfc_cmd->cur_iocbq.priority = ((struct lpfc_device_data *)\n\t\t\tscsi_cmnd->device->hostdata)->priority;\n\n\t\t/* Word 10 */\n\t\tbf_set(wqe_oas, &wqe->generic.wqe_com, 1);\n\t\tbf_set(wqe_ccpe, &wqe->generic.wqe_com, 1);\n\n\t\tif (lpfc_cmd->cur_iocbq.priority)\n\t\t\tbf_set(wqe_ccp, &wqe->generic.wqe_com,\n\t\t\t       (lpfc_cmd->cur_iocbq.priority << 1));\n\t\telse\n\t\t\tbf_set(wqe_ccp, &wqe->generic.wqe_com,\n\t\t\t       (phba->cfg_XLanePriority << 1));\n\t}\n\n\treturn 0;\n}\n\n/**\n * lpfc_bg_scsi_prep_dma_buf_s4 - DMA mapping for scsi buffer to SLI4 IF spec\n * @phba: The Hba for which this call is being executed.\n * @lpfc_cmd: The scsi buffer which is going to be mapped.\n *\n * This is the protection/DIF aware version of\n * lpfc_scsi_prep_dma_buf(). It may be a good idea to combine the\n * two functions eventually, but for now, it's here\n * Return codes:\n *\t2 - Error - Do not retry\n *\t1 - Error - Retry\n *\t0 - Success\n **/\nstatic int\nlpfc_bg_scsi_prep_dma_buf_s4(struct lpfc_hba *phba,\n\t\tstruct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\n\tstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\n\tstruct sli4_sge *sgl = (struct sli4_sge *)(lpfc_cmd->dma_sgl);\n\tstruct lpfc_iocbq *pwqeq = &lpfc_cmd->cur_iocbq;\n\tunion lpfc_wqe128 *wqe = &pwqeq->wqe;\n\tuint32_t num_sge = 0;\n\tint datasegcnt, protsegcnt, datadir = scsi_cmnd->sc_data_direction;\n\tint prot_group_type = 0;\n\tint fcpdl;\n\tint ret = 1;\n\tstruct lpfc_vport *vport = phba->pport;\n\n\t/*\n\t * Start the lpfc command prep by bumping the sgl beyond fcp_cmnd\n\t *  fcp_rsp regions to the first data sge entry\n\t */\n\tif (scsi_sg_count(scsi_cmnd)) {\n\t\t/*\n\t\t * The driver stores the segment count returned from pci_map_sg\n\t\t * because this a count of dma-mappings used to map the use_sg\n\t\t * pages.  They are not guaranteed to be the same for those\n\t\t * architectures that implement an IOMMU.\n\t\t */\n\t\tdatasegcnt = dma_map_sg(&phba->pcidev->dev,\n\t\t\t\t\tscsi_sglist(scsi_cmnd),\n\t\t\t\t\tscsi_sg_count(scsi_cmnd), datadir);\n\t\tif (unlikely(!datasegcnt))\n\t\t\treturn 1;\n\n\t\tsgl += 1;\n\t\t/* clear the last flag in the fcp_rsp map entry */\n\t\tsgl->word2 = le32_to_cpu(sgl->word2);\n\t\tbf_set(lpfc_sli4_sge_last, sgl, 0);\n\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\n\t\tsgl += 1;\n\t\tlpfc_cmd->seg_cnt = datasegcnt;\n\n\t\t/* First check if data segment count from SCSI Layer is good */\n\t\tif (lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt &&\n\t\t    !phba->cfg_xpsgl) {\n\t\t\tWARN_ON_ONCE(lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt);\n\t\t\tret = 2;\n\t\t\tgoto err;\n\t\t}\n\n\t\tprot_group_type = lpfc_prot_group_type(phba, scsi_cmnd);\n\n\t\tswitch (prot_group_type) {\n\t\tcase LPFC_PG_TYPE_NO_DIF:\n\t\t\t/* Here we need to add a DISEED to the count */\n\t\t\tif (((lpfc_cmd->seg_cnt + 1) >\n\t\t\t\t\tphba->cfg_total_seg_cnt) &&\n\t\t\t    !phba->cfg_xpsgl) {\n\t\t\t\tret = 2;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tnum_sge = lpfc_bg_setup_sgl(phba, scsi_cmnd, sgl,\n\t\t\t\t\tdatasegcnt, lpfc_cmd);\n\n\t\t\t/* we should have 2 or more entries in buffer list */\n\t\t\tif (num_sge < 2) {\n\t\t\t\tret = 2;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LPFC_PG_TYPE_DIF_BUF:\n\t\t\t/*\n\t\t\t * This type indicates that protection buffers are\n\t\t\t * passed to the driver, so that needs to be prepared\n\t\t\t * for DMA\n\t\t\t */\n\t\t\tprotsegcnt = dma_map_sg(&phba->pcidev->dev,\n\t\t\t\t\tscsi_prot_sglist(scsi_cmnd),\n\t\t\t\t\tscsi_prot_sg_count(scsi_cmnd), datadir);\n\t\t\tif (unlikely(!protsegcnt)) {\n\t\t\t\tscsi_dma_unmap(scsi_cmnd);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tlpfc_cmd->prot_seg_cnt = protsegcnt;\n\t\t\t/*\n\t\t\t * There is a minimun of 3 SGEs used for every\n\t\t\t * protection data segment.\n\t\t\t */\n\t\t\tif (((lpfc_cmd->prot_seg_cnt * 3) >\n\t\t\t\t\t(phba->cfg_total_seg_cnt - 2)) &&\n\t\t\t    !phba->cfg_xpsgl) {\n\t\t\t\tret = 2;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tnum_sge = lpfc_bg_setup_sgl_prot(phba, scsi_cmnd, sgl,\n\t\t\t\t\tdatasegcnt, protsegcnt, lpfc_cmd);\n\n\t\t\t/* we should have 3 or more entries in buffer list */\n\t\t\tif (num_sge < 3 ||\n\t\t\t    (num_sge > phba->cfg_total_seg_cnt &&\n\t\t\t     !phba->cfg_xpsgl)) {\n\t\t\t\tret = 2;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LPFC_PG_TYPE_INVALID:\n\t\tdefault:\n\t\t\tscsi_dma_unmap(scsi_cmnd);\n\t\t\tlpfc_cmd->seg_cnt = 0;\n\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9083 Unexpected protection group %i\\n\",\n\t\t\t\t\tprot_group_type);\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\tswitch (scsi_get_prot_op(scsi_cmnd)) {\n\tcase SCSI_PROT_WRITE_STRIP:\n\tcase SCSI_PROT_READ_STRIP:\n\t\tlpfc_cmd->cur_iocbq.iocb_flag |= LPFC_IO_DIF_STRIP;\n\t\tbreak;\n\tcase SCSI_PROT_WRITE_INSERT:\n\tcase SCSI_PROT_READ_INSERT:\n\t\tlpfc_cmd->cur_iocbq.iocb_flag |= LPFC_IO_DIF_INSERT;\n\t\tbreak;\n\tcase SCSI_PROT_WRITE_PASS:\n\tcase SCSI_PROT_READ_PASS:\n\t\tlpfc_cmd->cur_iocbq.iocb_flag |= LPFC_IO_DIF_PASS;\n\t\tbreak;\n\t}\n\n\tfcpdl = lpfc_bg_scsi_adjust_dl(phba, lpfc_cmd);\n\tfcp_cmnd->fcpDl = be32_to_cpu(fcpdl);\n\n\t/* Set first-burst provided it was successfully negotiated */\n\tif (!(phba->hba_flag & HBA_FCOE_MODE) &&\n\t    vport->cfg_first_burst_size &&\n\t    scsi_cmnd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tu32 init_len, total_len;\n\n\t\ttotal_len = be32_to_cpu(fcp_cmnd->fcpDl);\n\t\tinit_len = min(total_len, vport->cfg_first_burst_size);\n\n\t\t/* Word 4 & 5 */\n\t\twqe->fcp_iwrite.initial_xfer_len = init_len;\n\t\twqe->fcp_iwrite.total_xfer_len = total_len;\n\t} else {\n\t\t/* Word 4 */\n\t\twqe->fcp_iwrite.total_xfer_len =\n\t\t\tbe32_to_cpu(fcp_cmnd->fcpDl);\n\t}\n\n\t/*\n\t * If the OAS driver feature is enabled and the lun is enabled for\n\t * OAS, set the oas iocb related flags.\n\t */\n\tif ((phba->cfg_fof) && ((struct lpfc_device_data *)\n\t\tscsi_cmnd->device->hostdata)->oas_enabled) {\n\t\tlpfc_cmd->cur_iocbq.iocb_flag |= (LPFC_IO_OAS | LPFC_IO_FOF);\n\n\t\t/* Word 10 */\n\t\tbf_set(wqe_oas, &wqe->generic.wqe_com, 1);\n\t\tbf_set(wqe_ccpe, &wqe->generic.wqe_com, 1);\n\t\tbf_set(wqe_ccp, &wqe->generic.wqe_com,\n\t\t       (phba->cfg_XLanePriority << 1));\n\t}\n\n\t/* Word 7. DIF Flags */\n\tif (lpfc_cmd->cur_iocbq.iocb_flag & LPFC_IO_DIF_PASS)\n\t\tbf_set(wqe_dif, &wqe->generic.wqe_com, LPFC_WQE_DIF_PASSTHRU);\n\telse if (lpfc_cmd->cur_iocbq.iocb_flag & LPFC_IO_DIF_STRIP)\n\t\tbf_set(wqe_dif, &wqe->generic.wqe_com, LPFC_WQE_DIF_STRIP);\n\telse if (lpfc_cmd->cur_iocbq.iocb_flag & LPFC_IO_DIF_INSERT)\n\t\tbf_set(wqe_dif, &wqe->generic.wqe_com, LPFC_WQE_DIF_INSERT);\n\n\tlpfc_cmd->cur_iocbq.iocb_flag &= ~(LPFC_IO_DIF_PASS |\n\t\t\t\t LPFC_IO_DIF_STRIP | LPFC_IO_DIF_INSERT);\n\n\treturn 0;\nerr:\n\tif (lpfc_cmd->seg_cnt)\n\t\tscsi_dma_unmap(scsi_cmnd);\n\tif (lpfc_cmd->prot_seg_cnt)\n\t\tdma_unmap_sg(&phba->pcidev->dev, scsi_prot_sglist(scsi_cmnd),\n\t\t\t     scsi_prot_sg_count(scsi_cmnd),\n\t\t\t     scsi_cmnd->sc_data_direction);\n\n\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"9084 Cannot setup S/G List for HBA\"\n\t\t\t\"IO segs %d/%d SGL %d SCSI %d: %d %d\\n\",\n\t\t\tlpfc_cmd->seg_cnt, lpfc_cmd->prot_seg_cnt,\n\t\t\tphba->cfg_total_seg_cnt, phba->cfg_sg_seg_cnt,\n\t\t\tprot_group_type, num_sge);\n\n\tlpfc_cmd->seg_cnt = 0;\n\tlpfc_cmd->prot_seg_cnt = 0;\n\treturn ret;\n}\n\n/**\n * lpfc_scsi_prep_dma_buf - Wrapper function for DMA mapping of scsi buffer\n * @phba: The Hba for which this call is being executed.\n * @lpfc_cmd: The scsi buffer which is going to be mapped.\n *\n * This routine wraps the actual DMA mapping function pointer from the\n * lpfc_hba struct.\n *\n * Return codes:\n *\t1 - Error\n *\t0 - Success\n **/\nstatic inline int\nlpfc_scsi_prep_dma_buf(struct lpfc_hba *phba, struct lpfc_io_buf *lpfc_cmd)\n{\n\treturn phba->lpfc_scsi_prep_dma_buf(phba, lpfc_cmd);\n}\n\n/**\n * lpfc_bg_scsi_prep_dma_buf - Wrapper function for DMA mapping of scsi buffer\n * using BlockGuard.\n * @phba: The Hba for which this call is being executed.\n * @lpfc_cmd: The scsi buffer which is going to be mapped.\n *\n * This routine wraps the actual DMA mapping function pointer from the\n * lpfc_hba struct.\n *\n * Return codes:\n *\t1 - Error\n *\t0 - Success\n **/\nstatic inline int\nlpfc_bg_scsi_prep_dma_buf(struct lpfc_hba *phba, struct lpfc_io_buf *lpfc_cmd)\n{\n\treturn phba->lpfc_bg_scsi_prep_dma_buf(phba, lpfc_cmd);\n}\n\n/**\n * lpfc_scsi_prep_cmnd_buf - Wrapper function for IOCB/WQE mapping of scsi\n * buffer\n * @phba: The Hba for which this call is being executed.\n * @lpfc_cmd: The scsi buffer which is going to be mapped.\n * @tmo: Timeout value for IO\n *\n * This routine initializes IOCB/WQE data structure from scsi command\n *\n * Return codes:\n *\t1 - Error\n *\t0 - Success\n **/\nstatic inline int\nlpfc_scsi_prep_cmnd_buf(struct lpfc_vport *vport, struct lpfc_io_buf *lpfc_cmd,\n\t\t\tuint8_t tmo)\n{\n\treturn vport->phba->lpfc_scsi_prep_cmnd_buf(vport, lpfc_cmd, tmo);\n}\n\n/**\n * lpfc_send_scsi_error_event - Posts an event when there is SCSI error\n * @phba: Pointer to hba context object.\n * @vport: Pointer to vport object.\n * @lpfc_cmd: Pointer to lpfc scsi command which reported the error.\n * @rsp_iocb: Pointer to response iocb object which reported error.\n *\n * This function posts an event when there is a SCSI command reporting\n * error from the scsi device.\n **/\nstatic void\nlpfc_send_scsi_error_event(struct lpfc_hba *phba, struct lpfc_vport *vport,\n\t\tstruct lpfc_io_buf *lpfc_cmd, uint32_t fcpi_parm) {\n\tstruct scsi_cmnd *cmnd = lpfc_cmd->pCmd;\n\tstruct fcp_rsp *fcprsp = lpfc_cmd->fcp_rsp;\n\tuint32_t resp_info = fcprsp->rspStatus2;\n\tuint32_t scsi_status = fcprsp->rspStatus3;\n\tstruct lpfc_fast_path_event *fast_path_evt = NULL;\n\tstruct lpfc_nodelist *pnode = lpfc_cmd->rdata->pnode;\n\tunsigned long flags;\n\n\tif (!pnode)\n\t\treturn;\n\n\t/* If there is queuefull or busy condition send a scsi event */\n\tif ((cmnd->result == SAM_STAT_TASK_SET_FULL) ||\n\t\t(cmnd->result == SAM_STAT_BUSY)) {\n\t\tfast_path_evt = lpfc_alloc_fast_evt(phba);\n\t\tif (!fast_path_evt)\n\t\t\treturn;\n\t\tfast_path_evt->un.scsi_evt.event_type =\n\t\t\tFC_REG_SCSI_EVENT;\n\t\tfast_path_evt->un.scsi_evt.subcategory =\n\t\t(cmnd->result == SAM_STAT_TASK_SET_FULL) ?\n\t\tLPFC_EVENT_QFULL : LPFC_EVENT_DEVBSY;\n\t\tfast_path_evt->un.scsi_evt.lun = cmnd->device->lun;\n\t\tmemcpy(&fast_path_evt->un.scsi_evt.wwpn,\n\t\t\t&pnode->nlp_portname, sizeof(struct lpfc_name));\n\t\tmemcpy(&fast_path_evt->un.scsi_evt.wwnn,\n\t\t\t&pnode->nlp_nodename, sizeof(struct lpfc_name));\n\t} else if ((resp_info & SNS_LEN_VALID) && fcprsp->rspSnsLen &&\n\t\t((cmnd->cmnd[0] == READ_10) || (cmnd->cmnd[0] == WRITE_10))) {\n\t\tfast_path_evt = lpfc_alloc_fast_evt(phba);\n\t\tif (!fast_path_evt)\n\t\t\treturn;\n\t\tfast_path_evt->un.check_cond_evt.scsi_event.event_type =\n\t\t\tFC_REG_SCSI_EVENT;\n\t\tfast_path_evt->un.check_cond_evt.scsi_event.subcategory =\n\t\t\tLPFC_EVENT_CHECK_COND;\n\t\tfast_path_evt->un.check_cond_evt.scsi_event.lun =\n\t\t\tcmnd->device->lun;\n\t\tmemcpy(&fast_path_evt->un.check_cond_evt.scsi_event.wwpn,\n\t\t\t&pnode->nlp_portname, sizeof(struct lpfc_name));\n\t\tmemcpy(&fast_path_evt->un.check_cond_evt.scsi_event.wwnn,\n\t\t\t&pnode->nlp_nodename, sizeof(struct lpfc_name));\n\t\tfast_path_evt->un.check_cond_evt.sense_key =\n\t\t\tcmnd->sense_buffer[2] & 0xf;\n\t\tfast_path_evt->un.check_cond_evt.asc = cmnd->sense_buffer[12];\n\t\tfast_path_evt->un.check_cond_evt.ascq = cmnd->sense_buffer[13];\n\t} else if ((cmnd->sc_data_direction == DMA_FROM_DEVICE) &&\n\t\t     fcpi_parm &&\n\t\t     ((be32_to_cpu(fcprsp->rspResId) != fcpi_parm) ||\n\t\t\t((scsi_status == SAM_STAT_GOOD) &&\n\t\t\t!(resp_info & (RESID_UNDER | RESID_OVER))))) {\n\t\t/*\n\t\t * If status is good or resid does not match with fcp_param and\n\t\t * there is valid fcpi_parm, then there is a read_check error\n\t\t */\n\t\tfast_path_evt = lpfc_alloc_fast_evt(phba);\n\t\tif (!fast_path_evt)\n\t\t\treturn;\n\t\tfast_path_evt->un.read_check_error.header.event_type =\n\t\t\tFC_REG_FABRIC_EVENT;\n\t\tfast_path_evt->un.read_check_error.header.subcategory =\n\t\t\tLPFC_EVENT_FCPRDCHKERR;\n\t\tmemcpy(&fast_path_evt->un.read_check_error.header.wwpn,\n\t\t\t&pnode->nlp_portname, sizeof(struct lpfc_name));\n\t\tmemcpy(&fast_path_evt->un.read_check_error.header.wwnn,\n\t\t\t&pnode->nlp_nodename, sizeof(struct lpfc_name));\n\t\tfast_path_evt->un.read_check_error.lun = cmnd->device->lun;\n\t\tfast_path_evt->un.read_check_error.opcode = cmnd->cmnd[0];\n\t\tfast_path_evt->un.read_check_error.fcpiparam =\n\t\t\tfcpi_parm;\n\t} else\n\t\treturn;\n\n\tfast_path_evt->vport = vport;\n\tspin_lock_irqsave(&phba->hbalock, flags);\n\tlist_add_tail(&fast_path_evt->work_evt.evt_listp, &phba->work_list);\n\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\tlpfc_worker_wake_up(phba);\n\treturn;\n}\n\n/**\n * lpfc_scsi_unprep_dma_buf - Un-map DMA mapping of SG-list for dev\n * @phba: The HBA for which this call is being executed.\n * @psb: The scsi buffer which is going to be un-mapped.\n *\n * This routine does DMA un-mapping of scatter gather list of scsi command\n * field of @lpfc_cmd for device with SLI-3 interface spec.\n **/\nstatic void\nlpfc_scsi_unprep_dma_buf(struct lpfc_hba *phba, struct lpfc_io_buf *psb)\n{\n\t/*\n\t * There are only two special cases to consider.  (1) the scsi command\n\t * requested scatter-gather usage or (2) the scsi command allocated\n\t * a request buffer, but did not request use_sg.  There is a third\n\t * case, but it does not require resource deallocation.\n\t */\n\tif (psb->seg_cnt > 0)\n\t\tscsi_dma_unmap(psb->pCmd);\n\tif (psb->prot_seg_cnt > 0)\n\t\tdma_unmap_sg(&phba->pcidev->dev, scsi_prot_sglist(psb->pCmd),\n\t\t\t\tscsi_prot_sg_count(psb->pCmd),\n\t\t\t\tpsb->pCmd->sc_data_direction);\n}\n\n/**\n * lpfc_handler_fcp_err - FCP response handler\n * @vport: The virtual port for which this call is being executed.\n * @lpfc_cmd: Pointer to lpfc_io_buf data structure.\n * @rsp_iocb: The response IOCB which contains FCP error.\n *\n * This routine is called to process response IOCB with status field\n * IOSTAT_FCP_RSP_ERROR. This routine sets result field of scsi command\n * based upon SCSI and FCP error.\n **/\nstatic void\nlpfc_handle_fcp_err(struct lpfc_vport *vport, struct lpfc_io_buf *lpfc_cmd,\n\t\t    uint32_t fcpi_parm)\n{\n\tstruct scsi_cmnd *cmnd = lpfc_cmd->pCmd;\n\tstruct fcp_cmnd *fcpcmd = lpfc_cmd->fcp_cmnd;\n\tstruct fcp_rsp *fcprsp = lpfc_cmd->fcp_rsp;\n\tuint32_t resp_info = fcprsp->rspStatus2;\n\tuint32_t scsi_status = fcprsp->rspStatus3;\n\tuint32_t *lp;\n\tuint32_t host_status = DID_OK;\n\tuint32_t rsplen = 0;\n\tuint32_t fcpDl;\n\tuint32_t logit = LOG_FCP | LOG_FCP_ERROR;\n\n\n\t/*\n\t *  If this is a task management command, there is no\n\t *  scsi packet associated with this lpfc_cmd.  The driver\n\t *  consumes it.\n\t */\n\tif (fcpcmd->fcpCntl2) {\n\t\tscsi_status = 0;\n\t\tgoto out;\n\t}\n\n\tif (resp_info & RSP_LEN_VALID) {\n\t\trsplen = be32_to_cpu(fcprsp->rspRspLen);\n\t\tif (rsplen != 0 && rsplen != 4 && rsplen != 8) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"2719 Invalid response length: \"\n\t\t\t\t\t \"tgt x%x lun x%llx cmnd x%x rsplen \"\n\t\t\t\t\t \"x%x\\n\", cmnd->device->id,\n\t\t\t\t\t cmnd->device->lun, cmnd->cmnd[0],\n\t\t\t\t\t rsplen);\n\t\t\thost_status = DID_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fcprsp->rspInfo3 != RSP_NO_FAILURE) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2757 Protocol failure detected during \"\n\t\t\t\t \"processing of FCP I/O op: \"\n\t\t\t\t \"tgt x%x lun x%llx cmnd x%x rspInfo3 x%x\\n\",\n\t\t\t\t cmnd->device->id,\n\t\t\t\t cmnd->device->lun, cmnd->cmnd[0],\n\t\t\t\t fcprsp->rspInfo3);\n\t\t\thost_status = DID_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif ((resp_info & SNS_LEN_VALID) && fcprsp->rspSnsLen) {\n\t\tuint32_t snslen = be32_to_cpu(fcprsp->rspSnsLen);\n\t\tif (snslen > SCSI_SENSE_BUFFERSIZE)\n\t\t\tsnslen = SCSI_SENSE_BUFFERSIZE;\n\n\t\tif (resp_info & RSP_LEN_VALID)\n\t\t  rsplen = be32_to_cpu(fcprsp->rspRspLen);\n\t\tmemcpy(cmnd->sense_buffer, &fcprsp->rspInfo0 + rsplen, snslen);\n\t}\n\tlp = (uint32_t *)cmnd->sense_buffer;\n\n\t/* special handling for under run conditions */\n\tif (!scsi_status && (resp_info & RESID_UNDER)) {\n\t\t/* don't log under runs if fcp set... */\n\t\tif (vport->cfg_log_verbose & LOG_FCP)\n\t\t\tlogit = LOG_FCP_ERROR;\n\t\t/* unless operator says so */\n\t\tif (vport->cfg_log_verbose & LOG_FCP_UNDER)\n\t\t\tlogit = LOG_FCP_UNDER;\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_WARNING, logit,\n\t\t\t \"9024 FCP command x%x failed: x%x SNS x%x x%x \"\n\t\t\t \"Data: x%x x%x x%x x%x x%x\\n\",\n\t\t\t cmnd->cmnd[0], scsi_status,\n\t\t\t be32_to_cpu(*lp), be32_to_cpu(*(lp + 3)), resp_info,\n\t\t\t be32_to_cpu(fcprsp->rspResId),\n\t\t\t be32_to_cpu(fcprsp->rspSnsLen),\n\t\t\t be32_to_cpu(fcprsp->rspRspLen),\n\t\t\t fcprsp->rspInfo3);\n\n\tscsi_set_resid(cmnd, 0);\n\tfcpDl = be32_to_cpu(fcpcmd->fcpDl);\n\tif (resp_info & RESID_UNDER) {\n\t\tscsi_set_resid(cmnd, be32_to_cpu(fcprsp->rspResId));\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP_UNDER,\n\t\t\t\t \"9025 FCP Underrun, expected %d, \"\n\t\t\t\t \"residual %d Data: x%x x%x x%x\\n\",\n\t\t\t\t fcpDl,\n\t\t\t\t scsi_get_resid(cmnd), fcpi_parm, cmnd->cmnd[0],\n\t\t\t\t cmnd->underflow);\n\n\t\t/*\n\t\t * If there is an under run, check if under run reported by\n\t\t * storage array is same as the under run reported by HBA.\n\t\t * If this is not same, there is a dropped frame.\n\t\t */\n\t\tif (fcpi_parm && (scsi_get_resid(cmnd) != fcpi_parm)) {\n\t\t\tlpfc_printf_vlog(vport, KERN_WARNING,\n\t\t\t\t\t LOG_FCP | LOG_FCP_ERROR,\n\t\t\t\t\t \"9026 FCP Read Check Error \"\n\t\t\t\t\t \"and Underrun Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t\t fcpDl,\n\t\t\t\t\t scsi_get_resid(cmnd), fcpi_parm,\n\t\t\t\t\t cmnd->cmnd[0]);\n\t\t\tscsi_set_resid(cmnd, scsi_bufflen(cmnd));\n\t\t\thost_status = DID_ERROR;\n\t\t}\n\t\t/*\n\t\t * The cmnd->underflow is the minimum number of bytes that must\n\t\t * be transferred for this command.  Provided a sense condition\n\t\t * is not present, make sure the actual amount transferred is at\n\t\t * least the underflow value or fail.\n\t\t */\n\t\tif (!(resp_info & SNS_LEN_VALID) &&\n\t\t    (scsi_status == SAM_STAT_GOOD) &&\n\t\t    (scsi_bufflen(cmnd) - scsi_get_resid(cmnd)\n\t\t     < cmnd->underflow)) {\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t\t \"9027 FCP command x%x residual \"\n\t\t\t\t\t \"underrun converted to error \"\n\t\t\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t\t\t cmnd->cmnd[0], scsi_bufflen(cmnd),\n\t\t\t\t\t scsi_get_resid(cmnd), cmnd->underflow);\n\t\t\thost_status = DID_ERROR;\n\t\t}\n\t} else if (resp_info & RESID_OVER) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t\t \"9028 FCP command x%x residual overrun error. \"\n\t\t\t\t \"Data: x%x x%x\\n\", cmnd->cmnd[0],\n\t\t\t\t scsi_bufflen(cmnd), scsi_get_resid(cmnd));\n\t\thost_status = DID_ERROR;\n\n\t/*\n\t * Check SLI validation that all the transfer was actually done\n\t * (fcpi_parm should be zero). Apply check only to reads.\n\t */\n\t} else if (fcpi_parm) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP | LOG_FCP_ERROR,\n\t\t\t\t \"9029 FCP %s Check Error Data: \"\n\t\t\t\t \"x%x x%x x%x x%x x%x\\n\",\n\t\t\t\t ((cmnd->sc_data_direction == DMA_FROM_DEVICE) ?\n\t\t\t\t \"Read\" : \"Write\"),\n\t\t\t\t fcpDl, be32_to_cpu(fcprsp->rspResId),\n\t\t\t\t fcpi_parm, cmnd->cmnd[0], scsi_status);\n\n\t\t/* There is some issue with the LPe12000 that causes it\n\t\t * to miscalculate the fcpi_parm and falsely trip this\n\t\t * recovery logic.  Detect this case and don't error when true.\n\t\t */\n\t\tif (fcpi_parm > fcpDl)\n\t\t\tgoto out;\n\n\t\tswitch (scsi_status) {\n\t\tcase SAM_STAT_GOOD:\n\t\tcase SAM_STAT_CHECK_CONDITION:\n\t\t\t/* Fabric dropped a data frame. Fail any successful\n\t\t\t * command in which we detected dropped frames.\n\t\t\t * A status of good or some check conditions could\n\t\t\t * be considered a successful command.\n\t\t\t */\n\t\t\thost_status = DID_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tscsi_set_resid(cmnd, scsi_bufflen(cmnd));\n\t}\n\n out:\n\tcmnd->result = host_status << 16 | scsi_status;\n\tlpfc_send_scsi_error_event(vport->phba, vport, lpfc_cmd, fcpi_parm);\n}\n\n/**\n * lpfc_fcp_io_cmd_wqe_cmpl - Complete a FCP IO\n * @phba: The hba for which this call is being executed.\n * @pwqeIn: The command WQE for the scsi cmnd.\n * @pwqeOut: The response WQE for the scsi cmnd.\n *\n * This routine assigns scsi command result by looking into response WQE\n * status field appropriately. This routine handles QUEUE FULL condition as\n * well by ramping down device queue depth.\n **/\nstatic void\nlpfc_fcp_io_cmd_wqe_cmpl(struct lpfc_hba *phba, struct lpfc_iocbq *pwqeIn,\n\t\t\t struct lpfc_wcqe_complete *wcqe)\n{\n\tstruct lpfc_io_buf *lpfc_cmd =\n\t\t(struct lpfc_io_buf *)pwqeIn->context1;\n\tstruct lpfc_vport *vport = pwqeIn->vport;\n\tstruct lpfc_rport_data *rdata;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct scsi_cmnd *cmd;\n\tunsigned long flags;\n\tstruct lpfc_fast_path_event *fast_path_evt;\n\tstruct Scsi_Host *shost;\n\tu32 logit = LOG_FCP;\n\tu32 status, idx;\n\tunsigned long iflags = 0;\n\n\t/* Sanity check on return of outstanding command */\n\tif (!lpfc_cmd) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"9032 Null lpfc_cmd pointer. No \"\n\t\t\t\t \"release, skip completion\\n\");\n\t\treturn;\n\t}\n\n\trdata = lpfc_cmd->rdata;\n\tndlp = rdata->pnode;\n\n\tif (bf_get(lpfc_wcqe_c_xb, wcqe)) {\n\t\t/* TOREMOVE - currently this flag is checked during\n\t\t * the release of lpfc_iocbq. Remove once we move\n\t\t * to lpfc_wqe_job construct.\n\t\t *\n\t\t * This needs to be done outside buf_lock\n\t\t */\n\t\tspin_lock_irqsave(&phba->hbalock, iflags);\n\t\tlpfc_cmd->cur_iocbq.iocb_flag |= LPFC_EXCHANGE_BUSY;\n\t\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\t}\n\n\t/* Guard against abort handler being called at same time */\n\tspin_lock(&lpfc_cmd->buf_lock);\n\n\t/* Sanity check on return of outstanding command */\n\tcmd = lpfc_cmd->pCmd;\n\tif (!cmd || !phba) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"9042 I/O completion: Not an active IO\\n\");\n\t\tspin_unlock(&lpfc_cmd->buf_lock);\n\t\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n\t\treturn;\n\t}\n\tidx = lpfc_cmd->cur_iocbq.hba_wqidx;\n\tif (phba->sli4_hba.hdwq)\n\t\tphba->sli4_hba.hdwq[idx].scsi_cstat.io_cmpls++;\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (unlikely(phba->hdwqstat_on & LPFC_CHECK_SCSI_IO))\n\t\tthis_cpu_inc(phba->sli4_hba.c_stat->cmpl_io);\n#endif\n\tshost = cmd->device->host;\n\n\tstatus = bf_get(lpfc_wcqe_c_status, wcqe);\n\tlpfc_cmd->status = (status & LPFC_IOCB_STATUS_MASK);\n\tlpfc_cmd->result = (wcqe->parameter & IOERR_PARAM_MASK);\n\n\tlpfc_cmd->flags &= ~LPFC_SBUF_XBUSY;\n\tif (bf_get(lpfc_wcqe_c_xb, wcqe))\n\t\tlpfc_cmd->flags |= LPFC_SBUF_XBUSY;\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (lpfc_cmd->prot_data_type) {\n\t\tstruct scsi_dif_tuple *src = NULL;\n\n\t\tsrc =  (struct scsi_dif_tuple *)lpfc_cmd->prot_data_segment;\n\t\t/*\n\t\t * Used to restore any changes to protection\n\t\t * data for error injection.\n\t\t */\n\t\tswitch (lpfc_cmd->prot_data_type) {\n\t\tcase LPFC_INJERR_REFTAG:\n\t\t\tsrc->ref_tag =\n\t\t\t\tlpfc_cmd->prot_data;\n\t\t\tbreak;\n\t\tcase LPFC_INJERR_APPTAG:\n\t\t\tsrc->app_tag =\n\t\t\t\t(uint16_t)lpfc_cmd->prot_data;\n\t\t\tbreak;\n\t\tcase LPFC_INJERR_GUARD:\n\t\t\tsrc->guard_tag =\n\t\t\t\t(uint16_t)lpfc_cmd->prot_data;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tlpfc_cmd->prot_data = 0;\n\t\tlpfc_cmd->prot_data_type = 0;\n\t\tlpfc_cmd->prot_data_segment = NULL;\n\t}\n#endif\n\tif (unlikely(lpfc_cmd->status)) {\n\t\tif (lpfc_cmd->status == IOSTAT_LOCAL_REJECT &&\n\t\t    (lpfc_cmd->result & IOERR_DRVR_MASK))\n\t\t\tlpfc_cmd->status = IOSTAT_DRIVER_REJECT;\n\t\telse if (lpfc_cmd->status >= IOSTAT_CNT)\n\t\t\tlpfc_cmd->status = IOSTAT_DEFAULT;\n\t\tif (lpfc_cmd->status == IOSTAT_FCP_RSP_ERROR &&\n\t\t    !lpfc_cmd->fcp_rsp->rspStatus3 &&\n\t\t    (lpfc_cmd->fcp_rsp->rspStatus2 & RESID_UNDER) &&\n\t\t    !(vport->cfg_log_verbose & LOG_FCP_UNDER))\n\t\t\tlogit = 0;\n\t\telse\n\t\t\tlogit = LOG_FCP | LOG_FCP_UNDER;\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, logit,\n\t\t\t\t \"9034 FCP cmd x%x failed <%d/%lld> \"\n\t\t\t\t \"status: x%x result: x%x \"\n\t\t\t\t \"sid: x%x did: x%x oxid: x%x \"\n\t\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t\t cmd->cmnd[0],\n\t\t\t\t cmd->device ? cmd->device->id : 0xffff,\n\t\t\t\t cmd->device ? cmd->device->lun : 0xffff,\n\t\t\t\t lpfc_cmd->status, lpfc_cmd->result,\n\t\t\t\t vport->fc_myDID,\n\t\t\t\t (ndlp) ? ndlp->nlp_DID : 0,\n\t\t\t\t lpfc_cmd->cur_iocbq.sli4_xritag,\n\t\t\t\t wcqe->parameter, wcqe->total_data_placed,\n\t\t\t\t lpfc_cmd->cur_iocbq.iotag);\n\t}\n\n\tswitch (lpfc_cmd->status) {\n\tcase IOSTAT_SUCCESS:\n\t\tcmd->result = DID_OK << 16;\n\t\tbreak;\n\tcase IOSTAT_FCP_RSP_ERROR:\n\t\tlpfc_handle_fcp_err(vport, lpfc_cmd,\n\t\t\t\t    pwqeIn->wqe.fcp_iread.total_xfer_len -\n\t\t\t\t    wcqe->total_data_placed);\n\t\tbreak;\n\tcase IOSTAT_NPORT_BSY:\n\tcase IOSTAT_FABRIC_BSY:\n\t\tcmd->result = DID_TRANSPORT_DISRUPTED << 16;\n\t\tfast_path_evt = lpfc_alloc_fast_evt(phba);\n\t\tif (!fast_path_evt)\n\t\t\tbreak;\n\t\tfast_path_evt->un.fabric_evt.event_type =\n\t\t\tFC_REG_FABRIC_EVENT;\n\t\tfast_path_evt->un.fabric_evt.subcategory =\n\t\t\t(lpfc_cmd->status == IOSTAT_NPORT_BSY) ?\n\t\t\tLPFC_EVENT_PORT_BUSY : LPFC_EVENT_FABRIC_BUSY;\n\t\tif (ndlp) {\n\t\t\tmemcpy(&fast_path_evt->un.fabric_evt.wwpn,\n\t\t\t       &ndlp->nlp_portname,\n\t\t\t\tsizeof(struct lpfc_name));\n\t\t\tmemcpy(&fast_path_evt->un.fabric_evt.wwnn,\n\t\t\t       &ndlp->nlp_nodename,\n\t\t\t\tsizeof(struct lpfc_name));\n\t\t}\n\t\tfast_path_evt->vport = vport;\n\t\tfast_path_evt->work_evt.evt =\n\t\t\tLPFC_EVT_FASTPATH_MGMT_EVT;\n\t\tspin_lock_irqsave(&phba->hbalock, flags);\n\t\tlist_add_tail(&fast_path_evt->work_evt.evt_listp,\n\t\t\t      &phba->work_list);\n\t\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\t\tlpfc_worker_wake_up(phba);\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, logit,\n\t\t\t\t \"9035 Fabric/Node busy FCP cmd x%x failed\"\n\t\t\t\t \" <%d/%lld> \"\n\t\t\t\t \"status: x%x result: x%x \"\n\t\t\t\t \"sid: x%x did: x%x oxid: x%x \"\n\t\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t\t cmd->cmnd[0],\n\t\t\t\t cmd->device ? cmd->device->id : 0xffff,\n\t\t\t\t cmd->device ? cmd->device->lun : 0xffff,\n\t\t\t\t lpfc_cmd->status, lpfc_cmd->result,\n\t\t\t\t vport->fc_myDID,\n\t\t\t\t (ndlp) ? ndlp->nlp_DID : 0,\n\t\t\t\t lpfc_cmd->cur_iocbq.sli4_xritag,\n\t\t\t\t wcqe->parameter,\n\t\t\t\t wcqe->total_data_placed,\n\t\t\t\t lpfc_cmd->cur_iocbq.iocb.ulpIoTag);\n\t\tbreak;\n\tcase IOSTAT_REMOTE_STOP:\n\t\tif (ndlp) {\n\t\t\t/* This I/O was aborted by the target, we don't\n\t\t\t * know the rxid and because we did not send the\n\t\t\t * ABTS we cannot generate and RRQ.\n\t\t\t */\n\t\t\tlpfc_set_rrq_active(phba, ndlp,\n\t\t\t\t\t    lpfc_cmd->cur_iocbq.sli4_lxritag,\n\t\t\t\t\t    0, 0);\n\t\t}\n\t\tfallthrough;\n\tcase IOSTAT_LOCAL_REJECT:\n\t\tif (lpfc_cmd->result & IOERR_DRVR_MASK)\n\t\t\tlpfc_cmd->status = IOSTAT_DRIVER_REJECT;\n\t\tif (lpfc_cmd->result == IOERR_ELXSEC_KEY_UNWRAP_ERROR ||\n\t\t    lpfc_cmd->result ==\n\t\t    IOERR_ELXSEC_KEY_UNWRAP_COMPARE_ERROR ||\n\t\t    lpfc_cmd->result == IOERR_ELXSEC_CRYPTO_ERROR ||\n\t\t    lpfc_cmd->result ==\n\t\t    IOERR_ELXSEC_CRYPTO_COMPARE_ERROR) {\n\t\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\t\tbreak;\n\t\t}\n\t\tif (lpfc_cmd->result == IOERR_INVALID_RPI ||\n\t\t    lpfc_cmd->result == IOERR_NO_RESOURCES ||\n\t\t    lpfc_cmd->result == IOERR_ABORT_REQUESTED ||\n\t\t    lpfc_cmd->result == IOERR_SLER_CMD_RCV_FAILURE) {\n\t\t\tcmd->result = DID_REQUEUE << 16;\n\t\t\tbreak;\n\t\t}\n\t\tif ((lpfc_cmd->result == IOERR_RX_DMA_FAILED ||\n\t\t     lpfc_cmd->result == IOERR_TX_DMA_FAILED) &&\n\t\t     status == CQE_STATUS_DI_ERROR) {\n\t\t\tif (scsi_get_prot_op(cmd) !=\n\t\t\t    SCSI_PROT_NORMAL) {\n\t\t\t\t/*\n\t\t\t\t * This is a response for a BG enabled\n\t\t\t\t * cmd. Parse BG error\n\t\t\t\t */\n\t\t\t\tlpfc_sli4_parse_bg_err(phba, lpfc_cmd,\n\t\t\t\t\t\t       wcqe);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_BG,\n\t\t\t\t \"9040 non-zero BGSTAT on unprotected cmd\\n\");\n\t\t}\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, logit,\n\t\t\t\t \"9036 Local Reject FCP cmd x%x failed\"\n\t\t\t\t \" <%d/%lld> \"\n\t\t\t\t \"status: x%x result: x%x \"\n\t\t\t\t \"sid: x%x did: x%x oxid: x%x \"\n\t\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t\t cmd->cmnd[0],\n\t\t\t\t cmd->device ? cmd->device->id : 0xffff,\n\t\t\t\t cmd->device ? cmd->device->lun : 0xffff,\n\t\t\t\t lpfc_cmd->status, lpfc_cmd->result,\n\t\t\t\t vport->fc_myDID,\n\t\t\t\t (ndlp) ? ndlp->nlp_DID : 0,\n\t\t\t\t lpfc_cmd->cur_iocbq.sli4_xritag,\n\t\t\t\t wcqe->parameter,\n\t\t\t\t wcqe->total_data_placed,\n\t\t\t\t lpfc_cmd->cur_iocbq.iocb.ulpIoTag);\n\t\tfallthrough;\n\tdefault:\n\t\tif (lpfc_cmd->status >= IOSTAT_CNT)\n\t\t\tlpfc_cmd->status = IOSTAT_DEFAULT;\n\t\tcmd->result = DID_ERROR << 16;\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_IOERR,\n\t\t\t\t \"9037 FCP Completion Error: xri %x \"\n\t\t\t\t \"status x%x result x%x [x%x] \"\n\t\t\t\t \"placed x%x\\n\",\n\t\t\t\t lpfc_cmd->cur_iocbq.sli4_xritag,\n\t\t\t\t lpfc_cmd->status, lpfc_cmd->result,\n\t\t\t\t wcqe->parameter,\n\t\t\t\t wcqe->total_data_placed);\n\t}\n\tif (cmd->result || lpfc_cmd->fcp_rsp->rspSnsLen) {\n\t\tu32 *lp = (u32 *)cmd->sense_buffer;\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t \"9039 Iodone <%d/%llu> cmd x%p, error \"\n\t\t\t\t \"x%x SNS x%x x%x Data: x%x x%x\\n\",\n\t\t\t\t cmd->device->id, cmd->device->lun, cmd,\n\t\t\t\t cmd->result, *lp, *(lp + 3), cmd->retries,\n\t\t\t\t scsi_get_resid(cmd));\n\t}\n\n\tlpfc_update_stats(vport, lpfc_cmd);\n\n\tif (vport->cfg_max_scsicmpl_time &&\n\t    time_after(jiffies, lpfc_cmd->start_time +\n\t    msecs_to_jiffies(vport->cfg_max_scsicmpl_time))) {\n\t\tspin_lock_irqsave(shost->host_lock, flags);\n\t\tif (ndlp) {\n\t\t\tif (ndlp->cmd_qdepth >\n\t\t\t\tatomic_read(&ndlp->cmd_pending) &&\n\t\t\t\t(atomic_read(&ndlp->cmd_pending) >\n\t\t\t\tLPFC_MIN_TGT_QDEPTH) &&\n\t\t\t\t(cmd->cmnd[0] == READ_10 ||\n\t\t\t\tcmd->cmnd[0] == WRITE_10))\n\t\t\t\tndlp->cmd_qdepth =\n\t\t\t\t\tatomic_read(&ndlp->cmd_pending);\n\n\t\t\tndlp->last_change_time = jiffies;\n\t\t}\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t}\n\tlpfc_scsi_unprep_dma_buf(phba, lpfc_cmd);\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (lpfc_cmd->ts_cmd_start) {\n\t\tlpfc_cmd->ts_isr_cmpl = lpfc_cmd->cur_iocbq.isr_timestamp;\n\t\tlpfc_cmd->ts_data_io = ktime_get_ns();\n\t\tphba->ktime_last_cmd = lpfc_cmd->ts_data_io;\n\t\tlpfc_io_ktime(phba, lpfc_cmd);\n\t}\n#endif\n\tlpfc_cmd->pCmd = NULL;\n\tspin_unlock(&lpfc_cmd->buf_lock);\n\n\t/* The sdev is not guaranteed to be valid post scsi_done upcall. */\n\tcmd->scsi_done(cmd);\n\n\t/*\n\t * If there is an abort thread waiting for command completion\n\t * wake up the thread.\n\t */\n\tspin_lock(&lpfc_cmd->buf_lock);\n\tlpfc_cmd->cur_iocbq.iocb_flag &= ~LPFC_DRIVER_ABORTED;\n\tif (lpfc_cmd->waitq)\n\t\twake_up(lpfc_cmd->waitq);\n\tspin_unlock(&lpfc_cmd->buf_lock);\n\n\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n}\n\n/**\n * lpfc_scsi_cmd_iocb_cmpl - Scsi cmnd IOCB completion routine\n * @phba: The Hba for which this call is being executed.\n * @pIocbIn: The command IOCBQ for the scsi cmnd.\n * @pIocbOut: The response IOCBQ for the scsi cmnd.\n *\n * This routine assigns scsi command result by looking into response IOCB\n * status field appropriately. This routine handles QUEUE FULL condition as\n * well by ramping down device queue depth.\n **/\nstatic void\nlpfc_scsi_cmd_iocb_cmpl(struct lpfc_hba *phba, struct lpfc_iocbq *pIocbIn,\n\t\t\tstruct lpfc_iocbq *pIocbOut)\n{\n\tstruct lpfc_io_buf *lpfc_cmd =\n\t\t(struct lpfc_io_buf *) pIocbIn->context1;\n\tstruct lpfc_vport      *vport = pIocbIn->vport;\n\tstruct lpfc_rport_data *rdata = lpfc_cmd->rdata;\n\tstruct lpfc_nodelist *pnode = rdata->pnode;\n\tstruct scsi_cmnd *cmd;\n\tunsigned long flags;\n\tstruct lpfc_fast_path_event *fast_path_evt;\n\tstruct Scsi_Host *shost;\n\tint idx;\n\tuint32_t logit = LOG_FCP;\n\n\t/* Guard against abort handler being called at same time */\n\tspin_lock(&lpfc_cmd->buf_lock);\n\n\t/* Sanity check on return of outstanding command */\n\tcmd = lpfc_cmd->pCmd;\n\tif (!cmd || !phba) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2621 IO completion: Not an active IO\\n\");\n\t\tspin_unlock(&lpfc_cmd->buf_lock);\n\t\treturn;\n\t}\n\n\tidx = lpfc_cmd->cur_iocbq.hba_wqidx;\n\tif (phba->sli4_hba.hdwq)\n\t\tphba->sli4_hba.hdwq[idx].scsi_cstat.io_cmpls++;\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (unlikely(phba->hdwqstat_on & LPFC_CHECK_SCSI_IO))\n\t\tthis_cpu_inc(phba->sli4_hba.c_stat->cmpl_io);\n#endif\n\tshost = cmd->device->host;\n\n\tlpfc_cmd->result = (pIocbOut->iocb.un.ulpWord[4] & IOERR_PARAM_MASK);\n\tlpfc_cmd->status = pIocbOut->iocb.ulpStatus;\n\t/* pick up SLI4 exhange busy status from HBA */\n\tif (pIocbOut->iocb_flag & LPFC_EXCHANGE_BUSY)\n\t\tlpfc_cmd->flags |= LPFC_SBUF_XBUSY;\n\telse\n\t\tlpfc_cmd->flags &= ~LPFC_SBUF_XBUSY;\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (lpfc_cmd->prot_data_type) {\n\t\tstruct scsi_dif_tuple *src = NULL;\n\n\t\tsrc =  (struct scsi_dif_tuple *)lpfc_cmd->prot_data_segment;\n\t\t/*\n\t\t * Used to restore any changes to protection\n\t\t * data for error injection.\n\t\t */\n\t\tswitch (lpfc_cmd->prot_data_type) {\n\t\tcase LPFC_INJERR_REFTAG:\n\t\t\tsrc->ref_tag =\n\t\t\t\tlpfc_cmd->prot_data;\n\t\t\tbreak;\n\t\tcase LPFC_INJERR_APPTAG:\n\t\t\tsrc->app_tag =\n\t\t\t\t(uint16_t)lpfc_cmd->prot_data;\n\t\t\tbreak;\n\t\tcase LPFC_INJERR_GUARD:\n\t\t\tsrc->guard_tag =\n\t\t\t\t(uint16_t)lpfc_cmd->prot_data;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tlpfc_cmd->prot_data = 0;\n\t\tlpfc_cmd->prot_data_type = 0;\n\t\tlpfc_cmd->prot_data_segment = NULL;\n\t}\n#endif\n\n\tif (unlikely(lpfc_cmd->status)) {\n\t\tif (lpfc_cmd->status == IOSTAT_LOCAL_REJECT &&\n\t\t    (lpfc_cmd->result & IOERR_DRVR_MASK))\n\t\t\tlpfc_cmd->status = IOSTAT_DRIVER_REJECT;\n\t\telse if (lpfc_cmd->status >= IOSTAT_CNT)\n\t\t\tlpfc_cmd->status = IOSTAT_DEFAULT;\n\t\tif (lpfc_cmd->status == IOSTAT_FCP_RSP_ERROR &&\n\t\t    !lpfc_cmd->fcp_rsp->rspStatus3 &&\n\t\t    (lpfc_cmd->fcp_rsp->rspStatus2 & RESID_UNDER) &&\n\t\t    !(vport->cfg_log_verbose & LOG_FCP_UNDER))\n\t\t\tlogit = 0;\n\t\telse\n\t\t\tlogit = LOG_FCP | LOG_FCP_UNDER;\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, logit,\n\t\t\t \"9030 FCP cmd x%x failed <%d/%lld> \"\n\t\t\t \"status: x%x result: x%x \"\n\t\t\t \"sid: x%x did: x%x oxid: x%x \"\n\t\t\t \"Data: x%x x%x\\n\",\n\t\t\t cmd->cmnd[0],\n\t\t\t cmd->device ? cmd->device->id : 0xffff,\n\t\t\t cmd->device ? cmd->device->lun : 0xffff,\n\t\t\t lpfc_cmd->status, lpfc_cmd->result,\n\t\t\t vport->fc_myDID,\n\t\t\t (pnode) ? pnode->nlp_DID : 0,\n\t\t\t phba->sli_rev == LPFC_SLI_REV4 ?\n\t\t\t     lpfc_cmd->cur_iocbq.sli4_xritag : 0xffff,\n\t\t\t pIocbOut->iocb.ulpContext,\n\t\t\t lpfc_cmd->cur_iocbq.iocb.ulpIoTag);\n\n\t\tswitch (lpfc_cmd->status) {\n\t\tcase IOSTAT_FCP_RSP_ERROR:\n\t\t\t/* Call FCP RSP handler to determine result */\n\t\t\tlpfc_handle_fcp_err(vport, lpfc_cmd,\n\t\t\t\t\t    pIocbOut->iocb.un.fcpi.fcpi_parm);\n\t\t\tbreak;\n\t\tcase IOSTAT_NPORT_BSY:\n\t\tcase IOSTAT_FABRIC_BSY:\n\t\t\tcmd->result = DID_TRANSPORT_DISRUPTED << 16;\n\t\t\tfast_path_evt = lpfc_alloc_fast_evt(phba);\n\t\t\tif (!fast_path_evt)\n\t\t\t\tbreak;\n\t\t\tfast_path_evt->un.fabric_evt.event_type =\n\t\t\t\tFC_REG_FABRIC_EVENT;\n\t\t\tfast_path_evt->un.fabric_evt.subcategory =\n\t\t\t\t(lpfc_cmd->status == IOSTAT_NPORT_BSY) ?\n\t\t\t\tLPFC_EVENT_PORT_BUSY : LPFC_EVENT_FABRIC_BUSY;\n\t\t\tif (pnode) {\n\t\t\t\tmemcpy(&fast_path_evt->un.fabric_evt.wwpn,\n\t\t\t\t\t&pnode->nlp_portname,\n\t\t\t\t\tsizeof(struct lpfc_name));\n\t\t\t\tmemcpy(&fast_path_evt->un.fabric_evt.wwnn,\n\t\t\t\t\t&pnode->nlp_nodename,\n\t\t\t\t\tsizeof(struct lpfc_name));\n\t\t\t}\n\t\t\tfast_path_evt->vport = vport;\n\t\t\tfast_path_evt->work_evt.evt =\n\t\t\t\tLPFC_EVT_FASTPATH_MGMT_EVT;\n\t\t\tspin_lock_irqsave(&phba->hbalock, flags);\n\t\t\tlist_add_tail(&fast_path_evt->work_evt.evt_listp,\n\t\t\t\t&phba->work_list);\n\t\t\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\t\t\tlpfc_worker_wake_up(phba);\n\t\t\tbreak;\n\t\tcase IOSTAT_LOCAL_REJECT:\n\t\tcase IOSTAT_REMOTE_STOP:\n\t\t\tif (lpfc_cmd->result == IOERR_ELXSEC_KEY_UNWRAP_ERROR ||\n\t\t\t    lpfc_cmd->result ==\n\t\t\t\t\tIOERR_ELXSEC_KEY_UNWRAP_COMPARE_ERROR ||\n\t\t\t    lpfc_cmd->result == IOERR_ELXSEC_CRYPTO_ERROR ||\n\t\t\t    lpfc_cmd->result ==\n\t\t\t\t\tIOERR_ELXSEC_CRYPTO_COMPARE_ERROR) {\n\t\t\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (lpfc_cmd->result == IOERR_INVALID_RPI ||\n\t\t\t    lpfc_cmd->result == IOERR_NO_RESOURCES ||\n\t\t\t    lpfc_cmd->result == IOERR_ABORT_REQUESTED ||\n\t\t\t    lpfc_cmd->result == IOERR_SLER_CMD_RCV_FAILURE) {\n\t\t\t\tcmd->result = DID_REQUEUE << 16;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((lpfc_cmd->result == IOERR_RX_DMA_FAILED ||\n\t\t\t     lpfc_cmd->result == IOERR_TX_DMA_FAILED) &&\n\t\t\t     pIocbOut->iocb.unsli3.sli3_bg.bgstat) {\n\t\t\t\tif (scsi_get_prot_op(cmd) != SCSI_PROT_NORMAL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This is a response for a BG enabled\n\t\t\t\t\t * cmd. Parse BG error\n\t\t\t\t\t */\n\t\t\t\t\tlpfc_parse_bg_err(phba, lpfc_cmd,\n\t\t\t\t\t\t\tpIocbOut);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tlpfc_printf_vlog(vport, KERN_WARNING,\n\t\t\t\t\t\t\tLOG_BG,\n\t\t\t\t\t\t\t\"9031 non-zero BGSTAT \"\n\t\t\t\t\t\t\t\"on unprotected cmd\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((lpfc_cmd->status == IOSTAT_REMOTE_STOP)\n\t\t\t\t&& (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\t\t&& pnode) {\n\t\t\t\t/* This IO was aborted by the target, we don't\n\t\t\t\t * know the rxid and because we did not send the\n\t\t\t\t * ABTS we cannot generate and RRQ.\n\t\t\t\t */\n\t\t\t\tlpfc_set_rrq_active(phba, pnode,\n\t\t\t\t\tlpfc_cmd->cur_iocbq.sli4_lxritag,\n\t\t\t\t\t0, 0);\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tcmd->result = DID_ERROR << 16;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!pnode || (pnode->nlp_state != NLP_STE_MAPPED_NODE))\n\t\t\tcmd->result = DID_TRANSPORT_DISRUPTED << 16 |\n\t\t\t\t      SAM_STAT_BUSY;\n\t} else\n\t\tcmd->result = DID_OK << 16;\n\n\tif (cmd->result || lpfc_cmd->fcp_rsp->rspSnsLen) {\n\t\tuint32_t *lp = (uint32_t *)cmd->sense_buffer;\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t \"0710 Iodone <%d/%llu> cmd x%px, error \"\n\t\t\t\t \"x%x SNS x%x x%x Data: x%x x%x\\n\",\n\t\t\t\t cmd->device->id, cmd->device->lun, cmd,\n\t\t\t\t cmd->result, *lp, *(lp + 3), cmd->retries,\n\t\t\t\t scsi_get_resid(cmd));\n\t}\n\n\tlpfc_update_stats(vport, lpfc_cmd);\n\tif (vport->cfg_max_scsicmpl_time &&\n\t   time_after(jiffies, lpfc_cmd->start_time +\n\t\tmsecs_to_jiffies(vport->cfg_max_scsicmpl_time))) {\n\t\tspin_lock_irqsave(shost->host_lock, flags);\n\t\tif (pnode) {\n\t\t\tif (pnode->cmd_qdepth >\n\t\t\t\tatomic_read(&pnode->cmd_pending) &&\n\t\t\t\t(atomic_read(&pnode->cmd_pending) >\n\t\t\t\tLPFC_MIN_TGT_QDEPTH) &&\n\t\t\t\t((cmd->cmnd[0] == READ_10) ||\n\t\t\t\t(cmd->cmnd[0] == WRITE_10)))\n\t\t\t\tpnode->cmd_qdepth =\n\t\t\t\t\tatomic_read(&pnode->cmd_pending);\n\n\t\t\tpnode->last_change_time = jiffies;\n\t\t}\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t}\n\tlpfc_scsi_unprep_dma_buf(phba, lpfc_cmd);\n\n\tlpfc_cmd->pCmd = NULL;\n\tspin_unlock(&lpfc_cmd->buf_lock);\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (lpfc_cmd->ts_cmd_start) {\n\t\tlpfc_cmd->ts_isr_cmpl = pIocbIn->isr_timestamp;\n\t\tlpfc_cmd->ts_data_io = ktime_get_ns();\n\t\tphba->ktime_last_cmd = lpfc_cmd->ts_data_io;\n\t\tlpfc_io_ktime(phba, lpfc_cmd);\n\t}\n#endif\n\t/* The sdev is not guaranteed to be valid post scsi_done upcall. */\n\tcmd->scsi_done(cmd);\n\n\t/*\n\t * If there is an abort thread waiting for command completion\n\t * wake up the thread.\n\t */\n\tspin_lock(&lpfc_cmd->buf_lock);\n\tlpfc_cmd->cur_iocbq.iocb_flag &= ~LPFC_DRIVER_ABORTED;\n\tif (lpfc_cmd->waitq)\n\t\twake_up(lpfc_cmd->waitq);\n\tspin_unlock(&lpfc_cmd->buf_lock);\n\n\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n}\n\n/**\n * lpfc_scsi_prep_cmnd_buf_s3 - SLI-3 IOCB init for the IO\n * @phba: Pointer to vport object for which I/O is executed\n * @lpfc_cmd: The scsi buffer which is going to be prep'ed.\n * @tmo: timeout value for the IO\n *\n * Based on the data-direction of the command, initialize IOCB\n * in the I/O buffer. Fill in the IOCB fields which are independent\n * of the scsi buffer\n *\n * RETURNS 0 - SUCCESS,\n **/\nstatic int lpfc_scsi_prep_cmnd_buf_s3(struct lpfc_vport *vport,\n\t\t\t\t      struct lpfc_io_buf *lpfc_cmd,\n\t\t\t\t      uint8_t tmo)\n{\n\tIOCB_t *iocb_cmd = &lpfc_cmd->cur_iocbq.iocb;\n\tstruct lpfc_iocbq *piocbq = &lpfc_cmd->cur_iocbq;\n\tstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\n\tstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\n\tstruct lpfc_nodelist *pnode = lpfc_cmd->ndlp;\n\tint datadir = scsi_cmnd->sc_data_direction;\n\tu32 fcpdl;\n\n\tpiocbq->iocb.un.fcpi.fcpi_XRdy = 0;\n\n\t/*\n\t * There are three possibilities here - use scatter-gather segment, use\n\t * the single mapping, or neither.  Start the lpfc command prep by\n\t * bumping the bpl beyond the fcp_cmnd and fcp_rsp regions to the first\n\t * data bde entry.\n\t */\n\tif (scsi_sg_count(scsi_cmnd)) {\n\t\tif (datadir == DMA_TO_DEVICE) {\n\t\t\tiocb_cmd->ulpCommand = CMD_FCP_IWRITE64_CR;\n\t\t\tiocb_cmd->ulpPU = PARM_READ_CHECK;\n\t\t\tif (vport->cfg_first_burst_size &&\n\t\t\t    (pnode->nlp_flag & NLP_FIRSTBURST)) {\n\t\t\t\tu32 xrdy_len;\n\n\t\t\t\tfcpdl = scsi_bufflen(scsi_cmnd);\n\t\t\t\txrdy_len = min(fcpdl,\n\t\t\t\t\t       vport->cfg_first_burst_size);\n\t\t\t\tpiocbq->iocb.un.fcpi.fcpi_XRdy = xrdy_len;\n\t\t\t}\n\t\t\tfcp_cmnd->fcpCntl3 = WRITE_DATA;\n\t\t} else {\n\t\t\tiocb_cmd->ulpCommand = CMD_FCP_IREAD64_CR;\n\t\t\tiocb_cmd->ulpPU = PARM_READ_CHECK;\n\t\t\tfcp_cmnd->fcpCntl3 = READ_DATA;\n\t\t}\n\t} else {\n\t\tiocb_cmd->ulpCommand = CMD_FCP_ICMND64_CR;\n\t\tiocb_cmd->un.fcpi.fcpi_parm = 0;\n\t\tiocb_cmd->ulpPU = 0;\n\t\tfcp_cmnd->fcpCntl3 = 0;\n\t}\n\n\t/*\n\t * Finish initializing those IOCB fields that are independent\n\t * of the scsi_cmnd request_buffer\n\t */\n\tpiocbq->iocb.ulpContext = pnode->nlp_rpi;\n\tif (pnode->nlp_fcp_info & NLP_FCP_2_DEVICE)\n\t\tpiocbq->iocb.ulpFCP2Rcvy = 1;\n\telse\n\t\tpiocbq->iocb.ulpFCP2Rcvy = 0;\n\n\tpiocbq->iocb.ulpClass = (pnode->nlp_fcp_info & 0x0f);\n\tpiocbq->context1  = lpfc_cmd;\n\tif (!piocbq->iocb_cmpl)\n\t\tpiocbq->iocb_cmpl = lpfc_scsi_cmd_iocb_cmpl;\n\tpiocbq->iocb.ulpTimeout = tmo;\n\tpiocbq->vport = vport;\n\treturn 0;\n}\n\n/**\n * lpfc_scsi_prep_cmnd_buf_s4 - SLI-4 WQE init for the IO\n * @phba: Pointer to vport object for which I/O is executed\n * @lpfc_cmd: The scsi buffer which is going to be prep'ed.\n * @tmo: timeout value for the IO\n *\n * Based on the data-direction of the command copy WQE template\n * to I/O buffer WQE. Fill in the WQE fields which are independent\n * of the scsi buffer\n *\n * RETURNS 0 - SUCCESS,\n **/\nstatic int lpfc_scsi_prep_cmnd_buf_s4(struct lpfc_vport *vport,\n\t\t\t\t      struct lpfc_io_buf *lpfc_cmd,\n\t\t\t\t      uint8_t tmo)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\n\tstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\n\tstruct lpfc_sli4_hdw_queue *hdwq = NULL;\n\tstruct lpfc_iocbq *pwqeq = &lpfc_cmd->cur_iocbq;\n\tstruct lpfc_nodelist *pnode = lpfc_cmd->ndlp;\n\tunion lpfc_wqe128 *wqe = &pwqeq->wqe;\n\tu16 idx = lpfc_cmd->hdwq_no;\n\tint datadir = scsi_cmnd->sc_data_direction;\n\n\thdwq = &phba->sli4_hba.hdwq[idx];\n\n\t/* Initialize 64 bytes only */\n\tmemset(wqe, 0, sizeof(union lpfc_wqe128));\n\n\t/*\n\t * There are three possibilities here - use scatter-gather segment, use\n\t * the single mapping, or neither.\n\t */\n\tif (scsi_sg_count(scsi_cmnd)) {\n\t\tif (datadir == DMA_TO_DEVICE) {\n\t\t\t/* From the iwrite template, initialize words 7 -  11 */\n\t\t\tmemcpy(&wqe->words[7],\n\t\t\t       &lpfc_iwrite_cmd_template.words[7],\n\t\t\t       sizeof(uint32_t) * 5);\n\n\t\t\tfcp_cmnd->fcpCntl3 = WRITE_DATA;\n\t\t\tif (hdwq)\n\t\t\t\thdwq->scsi_cstat.output_requests++;\n\t\t} else {\n\t\t\t/* From the iread template, initialize words 7 - 11 */\n\t\t\tmemcpy(&wqe->words[7],\n\t\t\t       &lpfc_iread_cmd_template.words[7],\n\t\t\t       sizeof(uint32_t) * 5);\n\n\t\t\t/* Word 7 */\n\t\t\tbf_set(wqe_tmo, &wqe->fcp_iread.wqe_com, tmo);\n\n\t\t\tfcp_cmnd->fcpCntl3 = READ_DATA;\n\t\t\tif (hdwq)\n\t\t\t\thdwq->scsi_cstat.input_requests++;\n\t\t}\n\t} else {\n\t\t/* From the icmnd template, initialize words 4 - 11 */\n\t\tmemcpy(&wqe->words[4], &lpfc_icmnd_cmd_template.words[4],\n\t\t       sizeof(uint32_t) * 8);\n\n\t\t/* Word 7 */\n\t\tbf_set(wqe_tmo, &wqe->fcp_icmd.wqe_com, tmo);\n\n\t\tfcp_cmnd->fcpCntl3 = 0;\n\t\tif (hdwq)\n\t\t\thdwq->scsi_cstat.control_requests++;\n\t}\n\n\t/*\n\t * Finish initializing those WQE fields that are independent\n\t * of the request_buffer\n\t */\n\n\t /* Word 3 */\n\tbf_set(payload_offset_len, &wqe->fcp_icmd,\n\t       sizeof(struct fcp_cmnd) + sizeof(struct fcp_rsp));\n\n\t/* Word 6 */\n\tbf_set(wqe_ctxt_tag, &wqe->generic.wqe_com,\n\t       phba->sli4_hba.rpi_ids[pnode->nlp_rpi]);\n\tbf_set(wqe_xri_tag, &wqe->generic.wqe_com, pwqeq->sli4_xritag);\n\n\t/* Word 7*/\n\tif (pnode->nlp_fcp_info & NLP_FCP_2_DEVICE)\n\t\tbf_set(wqe_erp, &wqe->generic.wqe_com, 1);\n\n\tbf_set(wqe_class, &wqe->generic.wqe_com,\n\t       (pnode->nlp_fcp_info & 0x0f));\n\n\t /* Word 8 */\n\twqe->generic.wqe_com.abort_tag = pwqeq->iotag;\n\n\t/* Word 9 */\n\tbf_set(wqe_reqtag, &wqe->generic.wqe_com, pwqeq->iotag);\n\n\tpwqeq->vport = vport;\n\tpwqeq->vport = vport;\n\tpwqeq->context1 = lpfc_cmd;\n\tpwqeq->hba_wqidx = lpfc_cmd->hdwq_no;\n\tpwqeq->wqe_cmpl = lpfc_fcp_io_cmd_wqe_cmpl;\n\n\treturn 0;\n}\n\n/**\n * lpfc_scsi_prep_cmnd - Wrapper func for convert scsi cmnd to FCP info unit\n * @vport: The virtual port for which this call is being executed.\n * @lpfc_cmd: The scsi command which needs to send.\n * @pnode: Pointer to lpfc_nodelist.\n *\n * This routine initializes fcp_cmnd and iocb data structure from scsi command\n * to transfer for device with SLI3 interface spec.\n **/\nstatic int\nlpfc_scsi_prep_cmnd(struct lpfc_vport *vport, struct lpfc_io_buf *lpfc_cmd,\n\t\t    struct lpfc_nodelist *pnode)\n{\n\tstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\n\tstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\n\tu8 *ptr;\n\n\tif (!pnode)\n\t\treturn 0;\n\n\tlpfc_cmd->fcp_rsp->rspSnsLen = 0;\n\t/* clear task management bits */\n\tlpfc_cmd->fcp_cmnd->fcpCntl2 = 0;\n\n\tint_to_scsilun(lpfc_cmd->pCmd->device->lun,\n\t\t       &lpfc_cmd->fcp_cmnd->fcp_lun);\n\n\tptr = &fcp_cmnd->fcpCdb[0];\n\tmemcpy(ptr, scsi_cmnd->cmnd, scsi_cmnd->cmd_len);\n\tif (scsi_cmnd->cmd_len < LPFC_FCP_CDB_LEN) {\n\t\tptr += scsi_cmnd->cmd_len;\n\t\tmemset(ptr, 0, (LPFC_FCP_CDB_LEN - scsi_cmnd->cmd_len));\n\t}\n\n\tfcp_cmnd->fcpCntl1 = SIMPLE_Q;\n\n\tlpfc_scsi_prep_cmnd_buf(vport, lpfc_cmd, lpfc_cmd->timeout);\n\n\treturn 0;\n}\n\n/**\n * lpfc_scsi_prep_task_mgmt_cmd - Convert SLI3 scsi TM cmd to FCP info unit\n * @vport: The virtual port for which this call is being executed.\n * @lpfc_cmd: Pointer to lpfc_io_buf data structure.\n * @lun: Logical unit number.\n * @task_mgmt_cmd: SCSI task management command.\n *\n * This routine creates FCP information unit corresponding to @task_mgmt_cmd\n * for device with SLI-3 interface spec.\n *\n * Return codes:\n *   0 - Error\n *   1 - Success\n **/\nstatic int\nlpfc_scsi_prep_task_mgmt_cmd(struct lpfc_vport *vport,\n\t\t\t     struct lpfc_io_buf *lpfc_cmd,\n\t\t\t     uint64_t lun,\n\t\t\t     uint8_t task_mgmt_cmd)\n{\n\tstruct lpfc_iocbq *piocbq;\n\tIOCB_t *piocb;\n\tstruct fcp_cmnd *fcp_cmnd;\n\tstruct lpfc_rport_data *rdata = lpfc_cmd->rdata;\n\tstruct lpfc_nodelist *ndlp = rdata->pnode;\n\n\tif (!ndlp || ndlp->nlp_state != NLP_STE_MAPPED_NODE)\n\t\treturn 0;\n\n\tpiocbq = &(lpfc_cmd->cur_iocbq);\n\tpiocbq->vport = vport;\n\n\tpiocb = &piocbq->iocb;\n\n\tfcp_cmnd = lpfc_cmd->fcp_cmnd;\n\t/* Clear out any old data in the FCP command area */\n\tmemset(fcp_cmnd, 0, sizeof(struct fcp_cmnd));\n\tint_to_scsilun(lun, &fcp_cmnd->fcp_lun);\n\tfcp_cmnd->fcpCntl2 = task_mgmt_cmd;\n\tif (vport->phba->sli_rev == 3 &&\n\t    !(vport->phba->sli3_options & LPFC_SLI3_BG_ENABLED))\n\t\tlpfc_fcpcmd_to_iocb(piocb->unsli3.fcp_ext.icd, fcp_cmnd);\n\tpiocb->ulpCommand = CMD_FCP_ICMND64_CR;\n\tpiocb->ulpContext = ndlp->nlp_rpi;\n\tif (vport->phba->sli_rev == LPFC_SLI_REV4) {\n\t\tpiocb->ulpContext =\n\t\t  vport->phba->sli4_hba.rpi_ids[ndlp->nlp_rpi];\n\t}\n\tpiocb->ulpFCP2Rcvy = (ndlp->nlp_fcp_info & NLP_FCP_2_DEVICE) ? 1 : 0;\n\tpiocb->ulpClass = (ndlp->nlp_fcp_info & 0x0f);\n\tpiocb->ulpPU = 0;\n\tpiocb->un.fcpi.fcpi_parm = 0;\n\n\t/* ulpTimeout is only one byte */\n\tif (lpfc_cmd->timeout > 0xff) {\n\t\t/*\n\t\t * Do not timeout the command at the firmware level.\n\t\t * The driver will provide the timeout mechanism.\n\t\t */\n\t\tpiocb->ulpTimeout = 0;\n\t} else\n\t\tpiocb->ulpTimeout = lpfc_cmd->timeout;\n\n\tif (vport->phba->sli_rev == LPFC_SLI_REV4)\n\t\tlpfc_sli4_set_rsp_sgl_last(vport->phba, lpfc_cmd);\n\n\treturn 1;\n}\n\n/**\n * lpfc_scsi_api_table_setup - Set up scsi api function jump table\n * @phba: The hba struct for which this call is being executed.\n * @dev_grp: The HBA PCI-Device group number.\n *\n * This routine sets up the SCSI interface API function jump table in @phba\n * struct.\n * Returns: 0 - success, -ENODEV - failure.\n **/\nint\nlpfc_scsi_api_table_setup(struct lpfc_hba *phba, uint8_t dev_grp)\n{\n\n\tphba->lpfc_scsi_unprep_dma_buf = lpfc_scsi_unprep_dma_buf;\n\n\tswitch (dev_grp) {\n\tcase LPFC_PCI_DEV_LP:\n\t\tphba->lpfc_scsi_prep_dma_buf = lpfc_scsi_prep_dma_buf_s3;\n\t\tphba->lpfc_bg_scsi_prep_dma_buf = lpfc_bg_scsi_prep_dma_buf_s3;\n\t\tphba->lpfc_release_scsi_buf = lpfc_release_scsi_buf_s3;\n\t\tphba->lpfc_get_scsi_buf = lpfc_get_scsi_buf_s3;\n\t\tphba->lpfc_scsi_prep_cmnd_buf = lpfc_scsi_prep_cmnd_buf_s3;\n\t\tbreak;\n\tcase LPFC_PCI_DEV_OC:\n\t\tphba->lpfc_scsi_prep_dma_buf = lpfc_scsi_prep_dma_buf_s4;\n\t\tphba->lpfc_bg_scsi_prep_dma_buf = lpfc_bg_scsi_prep_dma_buf_s4;\n\t\tphba->lpfc_release_scsi_buf = lpfc_release_scsi_buf_s4;\n\t\tphba->lpfc_get_scsi_buf = lpfc_get_scsi_buf_s4;\n\t\tphba->lpfc_scsi_prep_cmnd_buf = lpfc_scsi_prep_cmnd_buf_s4;\n\t\tbreak;\n\tdefault:\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"1418 Invalid HBA PCI-device group: 0x%x\\n\",\n\t\t\t\tdev_grp);\n\t\treturn -ENODEV;\n\t}\n\tphba->lpfc_rampdown_queue_depth = lpfc_rampdown_queue_depth;\n\tphba->lpfc_scsi_cmd_iocb_cmpl = lpfc_scsi_cmd_iocb_cmpl;\n\treturn 0;\n}\n\n/**\n * lpfc_taskmgmt_def_cmpl - IOCB completion routine for task management command\n * @phba: The Hba for which this call is being executed.\n * @cmdiocbq: Pointer to lpfc_iocbq data structure.\n * @rspiocbq: Pointer to lpfc_iocbq data structure.\n *\n * This routine is IOCB completion routine for device reset and target reset\n * routine. This routine release scsi buffer associated with lpfc_cmd.\n **/\nstatic void\nlpfc_tskmgmt_def_cmpl(struct lpfc_hba *phba,\n\t\t\tstruct lpfc_iocbq *cmdiocbq,\n\t\t\tstruct lpfc_iocbq *rspiocbq)\n{\n\tstruct lpfc_io_buf *lpfc_cmd =\n\t\t(struct lpfc_io_buf *) cmdiocbq->context1;\n\tif (lpfc_cmd)\n\t\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n\treturn;\n}\n\n/**\n * lpfc_check_pci_resettable - Walks list of devices on pci_dev's bus to check\n *                             if issuing a pci_bus_reset is possibly unsafe\n * @phba: lpfc_hba pointer.\n *\n * Description:\n * Walks the bus_list to ensure only PCI devices with Emulex\n * vendor id, device ids that support hot reset, and only one occurrence\n * of function 0.\n *\n * Returns:\n * -EBADSLT,  detected invalid device\n *      0,    successful\n */\nint\nlpfc_check_pci_resettable(struct lpfc_hba *phba)\n{\n\tconst struct pci_dev *pdev = phba->pcidev;\n\tstruct pci_dev *ptr = NULL;\n\tu8 counter = 0;\n\n\t/* Walk the list of devices on the pci_dev's bus */\n\tlist_for_each_entry(ptr, &pdev->bus->devices, bus_list) {\n\t\t/* Check for Emulex Vendor ID */\n\t\tif (ptr->vendor != PCI_VENDOR_ID_EMULEX) {\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\t\t\"8346 Non-Emulex vendor found: \"\n\t\t\t\t\t\"0x%04x\\n\", ptr->vendor);\n\t\t\treturn -EBADSLT;\n\t\t}\n\n\t\t/* Check for valid Emulex Device ID */\n\t\tswitch (ptr->device) {\n\t\tcase PCI_DEVICE_ID_LANCER_FC:\n\t\tcase PCI_DEVICE_ID_LANCER_G6_FC:\n\t\tcase PCI_DEVICE_ID_LANCER_G7_FC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\t\t\"8347 Invalid device found: \"\n\t\t\t\t\t\"0x%04x\\n\", ptr->device);\n\t\t\treturn -EBADSLT;\n\t\t}\n\n\t\t/* Check for only one function 0 ID to ensure only one HBA on\n\t\t * secondary bus\n\t\t */\n\t\tif (ptr->devfn == 0) {\n\t\t\tif (++counter > 1) {\n\t\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\t\t\t\"8348 More than one device on \"\n\t\t\t\t\t\t\"secondary bus found\\n\");\n\t\t\t\treturn -EBADSLT;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * lpfc_info - Info entry point of scsi_host_template data structure\n * @host: The scsi host for which this call is being executed.\n *\n * This routine provides module information about hba.\n *\n * Reutrn code:\n *   Pointer to char - Success.\n **/\nconst char *\nlpfc_info(struct Scsi_Host *host)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) host->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint link_speed = 0;\n\tstatic char lpfcinfobuf[384];\n\tchar tmp[384] = {0};\n\n\tmemset(lpfcinfobuf, 0, sizeof(lpfcinfobuf));\n\tif (phba && phba->pcidev){\n\t\t/* Model Description */\n\t\tscnprintf(tmp, sizeof(tmp), phba->ModelDesc);\n\t\tif (strlcat(lpfcinfobuf, tmp, sizeof(lpfcinfobuf)) >=\n\t\t    sizeof(lpfcinfobuf))\n\t\t\tgoto buffer_done;\n\n\t\t/* PCI Info */\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \" on PCI bus %02x device %02x irq %d\",\n\t\t\t  phba->pcidev->bus->number, phba->pcidev->devfn,\n\t\t\t  phba->pcidev->irq);\n\t\tif (strlcat(lpfcinfobuf, tmp, sizeof(lpfcinfobuf)) >=\n\t\t    sizeof(lpfcinfobuf))\n\t\t\tgoto buffer_done;\n\n\t\t/* Port Number */\n\t\tif (phba->Port[0]) {\n\t\t\tscnprintf(tmp, sizeof(tmp), \" port %s\", phba->Port);\n\t\t\tif (strlcat(lpfcinfobuf, tmp, sizeof(lpfcinfobuf)) >=\n\t\t\t    sizeof(lpfcinfobuf))\n\t\t\t\tgoto buffer_done;\n\t\t}\n\n\t\t/* Link Speed */\n\t\tlink_speed = lpfc_sli_port_speed_get(phba);\n\t\tif (link_speed != 0) {\n\t\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t\t  \" Logical Link Speed: %d Mbps\", link_speed);\n\t\t\tif (strlcat(lpfcinfobuf, tmp, sizeof(lpfcinfobuf)) >=\n\t\t\t    sizeof(lpfcinfobuf))\n\t\t\t\tgoto buffer_done;\n\t\t}\n\n\t\t/* PCI resettable */\n\t\tif (!lpfc_check_pci_resettable(phba)) {\n\t\t\tscnprintf(tmp, sizeof(tmp), \" PCI resettable\");\n\t\t\tstrlcat(lpfcinfobuf, tmp, sizeof(lpfcinfobuf));\n\t\t}\n\t}\n\nbuffer_done:\n\treturn lpfcinfobuf;\n}\n\n/**\n * lpfc_poll_rearm_time - Routine to modify fcp_poll timer of hba\n * @phba: The Hba for which this call is being executed.\n *\n * This routine modifies fcp_poll_timer  field of @phba by cfg_poll_tmo.\n * The default value of cfg_poll_tmo is 10 milliseconds.\n **/\nstatic __inline__ void lpfc_poll_rearm_timer(struct lpfc_hba * phba)\n{\n\tunsigned long  poll_tmo_expires =\n\t\t(jiffies + msecs_to_jiffies(phba->cfg_poll_tmo));\n\n\tif (!list_empty(&phba->sli.sli3_ring[LPFC_FCP_RING].txcmplq))\n\t\tmod_timer(&phba->fcp_poll_timer,\n\t\t\t  poll_tmo_expires);\n}\n\n/**\n * lpfc_poll_start_timer - Routine to start fcp_poll_timer of HBA\n * @phba: The Hba for which this call is being executed.\n *\n * This routine starts the fcp_poll_timer of @phba.\n **/\nvoid lpfc_poll_start_timer(struct lpfc_hba * phba)\n{\n\tlpfc_poll_rearm_timer(phba);\n}\n\n/**\n * lpfc_poll_timeout - Restart polling timer\n * @t: Timer construct where lpfc_hba data structure pointer is obtained.\n *\n * This routine restarts fcp_poll timer, when FCP ring  polling is enable\n * and FCP Ring interrupt is disable.\n **/\nvoid lpfc_poll_timeout(struct timer_list *t)\n{\n\tstruct lpfc_hba *phba = from_timer(phba, t, fcp_poll_timer);\n\n\tif (phba->cfg_poll & ENABLE_FCP_RING_POLLING) {\n\t\tlpfc_sli_handle_fast_ring_event(phba,\n\t\t\t&phba->sli.sli3_ring[LPFC_FCP_RING], HA_R0RE_REQ);\n\n\t\tif (phba->cfg_poll & DISABLE_FCP_RING_INT)\n\t\t\tlpfc_poll_rearm_timer(phba);\n\t}\n}\n\n/**\n * lpfc_queuecommand - scsi_host_template queuecommand entry point\n * @shost: kernel scsi host pointer.\n * @cmnd: Pointer to scsi_cmnd data structure.\n *\n * Driver registers this routine to scsi midlayer to submit a @cmd to process.\n * This routine prepares an IOCB from scsi command and provides to firmware.\n * The @done callback is invoked after driver finished processing the command.\n *\n * Return value :\n *   0 - Success\n *   SCSI_MLQUEUE_HOST_BUSY - Block all devices served by this host temporarily.\n **/\nstatic int\nlpfc_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *cmnd)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_rport_data *rdata;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_io_buf *lpfc_cmd;\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(cmnd->device));\n\tint err, idx;\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tuint64_t start = 0L;\n\n\tif (phba->ktime_on)\n\t\tstart = ktime_get_ns();\n#endif\n\n\trdata = lpfc_rport_data_from_scsi_device(cmnd->device);\n\n\t/* sanity check on references */\n\tif (unlikely(!rdata) || unlikely(!rport))\n\t\tgoto out_fail_command;\n\n\terr = fc_remote_port_chkready(rport);\n\tif (err) {\n\t\tcmnd->result = err;\n\t\tgoto out_fail_command;\n\t}\n\tndlp = rdata->pnode;\n\n\tif ((scsi_get_prot_op(cmnd) != SCSI_PROT_NORMAL) &&\n\t\t(!(phba->sli3_options & LPFC_SLI3_BG_ENABLED))) {\n\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"9058 BLKGRD: ERROR: rcvd protected cmd:%02x\"\n\t\t\t\t\" op:%02x str=%s without registering for\"\n\t\t\t\t\" BlockGuard - Rejecting command\\n\",\n\t\t\t\tcmnd->cmnd[0], scsi_get_prot_op(cmnd),\n\t\t\t\tdif_op_str[scsi_get_prot_op(cmnd)]);\n\t\tgoto out_fail_command;\n\t}\n\n\t/*\n\t * Catch race where our node has transitioned, but the\n\t * transport is still transitioning.\n\t */\n\tif (!ndlp)\n\t\tgoto out_tgt_busy;\n\tif (lpfc_ndlp_check_qdepth(phba, ndlp)) {\n\t\tif (atomic_read(&ndlp->cmd_pending) >= ndlp->cmd_qdepth) {\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP_ERROR,\n\t\t\t\t\t \"3377 Target Queue Full, scsi Id:%d \"\n\t\t\t\t\t \"Qdepth:%d Pending command:%d\"\n\t\t\t\t\t \" WWNN:%02x:%02x:%02x:%02x:\"\n\t\t\t\t\t \"%02x:%02x:%02x:%02x, \"\n\t\t\t\t\t \" WWPN:%02x:%02x:%02x:%02x:\"\n\t\t\t\t\t \"%02x:%02x:%02x:%02x\",\n\t\t\t\t\t ndlp->nlp_sid, ndlp->cmd_qdepth,\n\t\t\t\t\t atomic_read(&ndlp->cmd_pending),\n\t\t\t\t\t ndlp->nlp_nodename.u.wwn[0],\n\t\t\t\t\t ndlp->nlp_nodename.u.wwn[1],\n\t\t\t\t\t ndlp->nlp_nodename.u.wwn[2],\n\t\t\t\t\t ndlp->nlp_nodename.u.wwn[3],\n\t\t\t\t\t ndlp->nlp_nodename.u.wwn[4],\n\t\t\t\t\t ndlp->nlp_nodename.u.wwn[5],\n\t\t\t\t\t ndlp->nlp_nodename.u.wwn[6],\n\t\t\t\t\t ndlp->nlp_nodename.u.wwn[7],\n\t\t\t\t\t ndlp->nlp_portname.u.wwn[0],\n\t\t\t\t\t ndlp->nlp_portname.u.wwn[1],\n\t\t\t\t\t ndlp->nlp_portname.u.wwn[2],\n\t\t\t\t\t ndlp->nlp_portname.u.wwn[3],\n\t\t\t\t\t ndlp->nlp_portname.u.wwn[4],\n\t\t\t\t\t ndlp->nlp_portname.u.wwn[5],\n\t\t\t\t\t ndlp->nlp_portname.u.wwn[6],\n\t\t\t\t\t ndlp->nlp_portname.u.wwn[7]);\n\t\t\tgoto out_tgt_busy;\n\t\t}\n\t}\n\n\tlpfc_cmd = lpfc_get_scsi_buf(phba, ndlp, cmnd);\n\tif (lpfc_cmd == NULL) {\n\t\tlpfc_rampdown_queue_depth(phba);\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP_ERROR,\n\t\t\t\t \"0707 driver's buffer pool is empty, \"\n\t\t\t\t \"IO busied\\n\");\n\t\tgoto out_host_busy;\n\t}\n\n\t/*\n\t * Store the midlayer's command structure for the completion phase\n\t * and complete the command initialization.\n\t */\n\tlpfc_cmd->pCmd  = cmnd;\n\tlpfc_cmd->rdata = rdata;\n\tlpfc_cmd->ndlp = ndlp;\n\tlpfc_cmd->cur_iocbq.iocb_cmpl = NULL;\n\tcmnd->host_scribble = (unsigned char *)lpfc_cmd;\n\n\terr = lpfc_scsi_prep_cmnd(vport, lpfc_cmd, ndlp);\n\tif (err)\n\t\tgoto out_host_busy_release_buf;\n\n\tif (scsi_get_prot_op(cmnd) != SCSI_PROT_NORMAL) {\n\t\tif (vport->phba->cfg_enable_bg) {\n\t\t\tlpfc_printf_vlog(vport,\n\t\t\t\t\t KERN_INFO, LOG_SCSI_CMD,\n\t\t\t\t\t \"9033 BLKGRD: rcvd %s cmd:x%x \"\n\t\t\t\t\t \"sector x%llx cnt %u pt %x\\n\",\n\t\t\t\t\t dif_op_str[scsi_get_prot_op(cmnd)],\n\t\t\t\t\t cmnd->cmnd[0],\n\t\t\t\t\t (unsigned long long)scsi_get_lba(cmnd),\n\t\t\t\t\t blk_rq_sectors(cmnd->request),\n\t\t\t\t\t (cmnd->cmnd[1]>>5));\n\t\t}\n\t\terr = lpfc_bg_scsi_prep_dma_buf(phba, lpfc_cmd);\n\t} else {\n\t\tif (vport->phba->cfg_enable_bg) {\n\t\t\tlpfc_printf_vlog(vport,\n\t\t\t\t\t KERN_INFO, LOG_SCSI_CMD,\n\t\t\t\t\t \"9038 BLKGRD: rcvd PROT_NORMAL cmd: \"\n\t\t\t\t\t \"x%x sector x%llx cnt %u pt %x\\n\",\n\t\t\t\t\t cmnd->cmnd[0],\n\t\t\t\t\t (unsigned long long)scsi_get_lba(cmnd),\n\t\t\t\t\t blk_rq_sectors(cmnd->request),\n\t\t\t\t\t (cmnd->cmnd[1]>>5));\n\t\t}\n\t\terr = lpfc_scsi_prep_dma_buf(phba, lpfc_cmd);\n\t}\n\n\tif (unlikely(err)) {\n\t\tif (err == 2) {\n\t\t\tcmnd->result = DID_ERROR << 16;\n\t\t\tgoto out_fail_command_release_buf;\n\t\t}\n\t\tgoto out_host_busy_free_buf;\n\t}\n\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (unlikely(phba->hdwqstat_on & LPFC_CHECK_SCSI_IO))\n\t\tthis_cpu_inc(phba->sli4_hba.c_stat->xmt_io);\n#endif\n\t/* Issue I/O to adapter */\n\terr = lpfc_sli_issue_fcp_io(phba, LPFC_FCP_RING,\n\t\t\t\t    &lpfc_cmd->cur_iocbq,\n\t\t\t\t    SLI_IOCB_RET_IOCB);\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (start) {\n\t\tlpfc_cmd->ts_cmd_start = start;\n\t\tlpfc_cmd->ts_last_cmd = phba->ktime_last_cmd;\n\t\tlpfc_cmd->ts_cmd_wqput = ktime_get_ns();\n\t} else {\n\t\tlpfc_cmd->ts_cmd_start = 0;\n\t}\n#endif\n\tif (err) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t   \"3376 FCP could not issue IOCB err %x \"\n\t\t\t\t   \"FCP cmd x%x <%d/%llu> \"\n\t\t\t\t   \"sid: x%x did: x%x oxid: x%x \"\n\t\t\t\t   \"Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t   err, cmnd->cmnd[0],\n\t\t\t\t   cmnd->device ? cmnd->device->id : 0xffff,\n\t\t\t\t   cmnd->device ? cmnd->device->lun : (u64)-1,\n\t\t\t\t   vport->fc_myDID, ndlp->nlp_DID,\n\t\t\t\t   phba->sli_rev == LPFC_SLI_REV4 ?\n\t\t\t\t   lpfc_cmd->cur_iocbq.sli4_xritag : 0xffff,\n\t\t\t\t   phba->sli_rev == LPFC_SLI_REV4 ?\n\t\t\t\t   phba->sli4_hba.rpi_ids[ndlp->nlp_rpi] :\n\t\t\t\t   lpfc_cmd->cur_iocbq.iocb.ulpContext,\n\t\t\t\t   lpfc_cmd->cur_iocbq.iotag,\n\t\t\t\t   phba->sli_rev == LPFC_SLI_REV4 ?\n\t\t\t\t   bf_get(wqe_tmo,\n\t\t\t\t   &lpfc_cmd->cur_iocbq.wqe.generic.wqe_com) :\n\t\t\t\t   lpfc_cmd->cur_iocbq.iocb.ulpTimeout,\n\t\t\t\t   (uint32_t)\n\t\t\t\t   (cmnd->request->timeout / 1000));\n\n\t\tgoto out_host_busy_free_buf;\n\t}\n\n\tif (phba->cfg_poll & ENABLE_FCP_RING_POLLING) {\n\t\tlpfc_sli_handle_fast_ring_event(phba,\n\t\t\t&phba->sli.sli3_ring[LPFC_FCP_RING], HA_R0RE_REQ);\n\n\t\tif (phba->cfg_poll & DISABLE_FCP_RING_INT)\n\t\t\tlpfc_poll_rearm_timer(phba);\n\t}\n\n\tif (phba->cfg_xri_rebalancing)\n\t\tlpfc_keep_pvt_pool_above_lowwm(phba, lpfc_cmd->hdwq_no);\n\n\treturn 0;\n\n out_host_busy_free_buf:\n\tidx = lpfc_cmd->hdwq_no;\n\tlpfc_scsi_unprep_dma_buf(phba, lpfc_cmd);\n\tif (phba->sli4_hba.hdwq) {\n\t\tswitch (lpfc_cmd->fcp_cmnd->fcpCntl3) {\n\t\tcase WRITE_DATA:\n\t\t\tphba->sli4_hba.hdwq[idx].scsi_cstat.output_requests--;\n\t\t\tbreak;\n\t\tcase READ_DATA:\n\t\t\tphba->sli4_hba.hdwq[idx].scsi_cstat.input_requests--;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphba->sli4_hba.hdwq[idx].scsi_cstat.control_requests--;\n\t\t}\n\t}\n out_host_busy_release_buf:\n\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n out_host_busy:\n\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n out_tgt_busy:\n\treturn SCSI_MLQUEUE_TARGET_BUSY;\n\n out_fail_command_release_buf:\n\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n\n out_fail_command:\n\tcmnd->scsi_done(cmnd);\n\treturn 0;\n}\n\n\n/**\n * lpfc_abort_handler - scsi_host_template eh_abort_handler entry point\n * @cmnd: Pointer to scsi_cmnd data structure.\n *\n * This routine aborts @cmnd pending in base driver.\n *\n * Return code :\n *   0x2003 - Error\n *   0x2002 - Success\n **/\nstatic int\nlpfc_abort_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct Scsi_Host  *shost = cmnd->device->host;\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_iocbq *iocb;\n\tstruct lpfc_io_buf *lpfc_cmd;\n\tint ret = SUCCESS, status = 0;\n\tstruct lpfc_sli_ring *pring_s4 = NULL;\n\tstruct lpfc_sli_ring *pring = NULL;\n\tint ret_val;\n\tunsigned long flags;\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(waitq);\n\n\tstatus = fc_block_scsi_eh(cmnd);\n\tif (status != 0 && status != SUCCESS)\n\t\treturn status;\n\n\tlpfc_cmd = (struct lpfc_io_buf *)cmnd->host_scribble;\n\tif (!lpfc_cmd)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&phba->hbalock, flags);\n\t/* driver queued commands are in process of being flushed */\n\tif (phba->hba_flag & HBA_IOQ_FLUSH) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t\"3168 SCSI Layer abort requested I/O has been \"\n\t\t\t\"flushed by LLD.\\n\");\n\t\tret = FAILED;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Guard against IO completion being called at same time */\n\tspin_lock(&lpfc_cmd->buf_lock);\n\n\tif (!lpfc_cmd->pCmd) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t \"2873 SCSI Layer I/O Abort Request IO CMPL Status \"\n\t\t\t \"x%x ID %d LUN %llu\\n\",\n\t\t\t SUCCESS, cmnd->device->id, cmnd->device->lun);\n\t\tgoto out_unlock_buf;\n\t}\n\n\tiocb = &lpfc_cmd->cur_iocbq;\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tpring_s4 = phba->sli4_hba.hdwq[iocb->hba_wqidx].io_wq->pring;\n\t\tif (!pring_s4) {\n\t\t\tret = FAILED;\n\t\t\tgoto out_unlock_buf;\n\t\t}\n\t\tspin_lock(&pring_s4->ring_lock);\n\t}\n\t/* the command is in process of being cancelled */\n\tif (!(iocb->iocb_flag & LPFC_IO_ON_TXCMPLQ)) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t\"3169 SCSI Layer abort requested I/O has been \"\n\t\t\t\"cancelled by LLD.\\n\");\n\t\tret = FAILED;\n\t\tgoto out_unlock_ring;\n\t}\n\t/*\n\t * If pCmd field of the corresponding lpfc_io_buf structure\n\t * points to a different SCSI command, then the driver has\n\t * already completed this command, but the midlayer did not\n\t * see the completion before the eh fired. Just return SUCCESS.\n\t */\n\tif (lpfc_cmd->pCmd != cmnd) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t\"3170 SCSI Layer abort requested I/O has been \"\n\t\t\t\"completed by LLD.\\n\");\n\t\tgoto out_unlock_ring;\n\t}\n\n\tBUG_ON(iocb->context1 != lpfc_cmd);\n\n\t/* abort issued in recovery is still in progress */\n\tif (iocb->iocb_flag & LPFC_DRIVER_ABORTED) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t \"3389 SCSI Layer I/O Abort Request is pending\\n\");\n\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tspin_unlock(&pring_s4->ring_lock);\n\t\tspin_unlock(&lpfc_cmd->buf_lock);\n\t\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\t\tgoto wait_for_cmpl;\n\t}\n\n\tlpfc_cmd->waitq = &waitq;\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tspin_unlock(&pring_s4->ring_lock);\n\t\tret_val = lpfc_sli4_issue_abort_iotag(phba, iocb,\n\t\t\t\t\t\t      lpfc_sli4_abort_fcp_cmpl);\n\t} else {\n\t\tpring = &phba->sli.sli3_ring[LPFC_FCP_RING];\n\t\tret_val = lpfc_sli_issue_abort_iotag(phba, pring, iocb,\n\t\t\t\t\t\t     lpfc_sli_abort_fcp_cmpl);\n\t}\n\n\tif (ret_val != IOCB_SUCCESS) {\n\t\t/* Indicate the IO is not being aborted by the driver. */\n\t\tlpfc_cmd->waitq = NULL;\n\t\tspin_unlock(&lpfc_cmd->buf_lock);\n\t\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\t\tret = FAILED;\n\t\tgoto out;\n\t}\n\n\t/* no longer need the lock after this point */\n\tspin_unlock(&lpfc_cmd->buf_lock);\n\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\n\tif (phba->cfg_poll & DISABLE_FCP_RING_INT)\n\t\tlpfc_sli_handle_fast_ring_event(phba,\n\t\t\t&phba->sli.sli3_ring[LPFC_FCP_RING], HA_R0RE_REQ);\n\nwait_for_cmpl:\n\t/*\n\t * iocb_flag is set to LPFC_DRIVER_ABORTED before we wait\n\t * for abort to complete.\n\t */\n\twait_event_timeout(waitq,\n\t\t\t  (lpfc_cmd->pCmd != cmnd),\n\t\t\t   msecs_to_jiffies(2*vport->cfg_devloss_tmo*1000));\n\n\tspin_lock(&lpfc_cmd->buf_lock);\n\n\tif (lpfc_cmd->pCmd == cmnd) {\n\t\tret = FAILED;\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0748 abort handler timed out waiting \"\n\t\t\t\t \"for aborting I/O (xri:x%x) to complete: \"\n\t\t\t\t \"ret %#x, ID %d, LUN %llu\\n\",\n\t\t\t\t iocb->sli4_xritag, ret,\n\t\t\t\t cmnd->device->id, cmnd->device->lun);\n\t}\n\n\tlpfc_cmd->waitq = NULL;\n\n\tspin_unlock(&lpfc_cmd->buf_lock);\n\tgoto out;\n\nout_unlock_ring:\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_unlock(&pring_s4->ring_lock);\nout_unlock_buf:\n\tspin_unlock(&lpfc_cmd->buf_lock);\nout_unlock:\n\tspin_unlock_irqrestore(&phba->hbalock, flags);\nout:\n\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t \"0749 SCSI Layer I/O Abort Request Status x%x ID %d \"\n\t\t\t \"LUN %llu\\n\", ret, cmnd->device->id,\n\t\t\t cmnd->device->lun);\n\treturn ret;\n}\n\nstatic char *\nlpfc_taskmgmt_name(uint8_t task_mgmt_cmd)\n{\n\tswitch (task_mgmt_cmd) {\n\tcase FCP_ABORT_TASK_SET:\n\t\treturn \"ABORT_TASK_SET\";\n\tcase FCP_CLEAR_TASK_SET:\n\t\treturn \"FCP_CLEAR_TASK_SET\";\n\tcase FCP_BUS_RESET:\n\t\treturn \"FCP_BUS_RESET\";\n\tcase FCP_LUN_RESET:\n\t\treturn \"FCP_LUN_RESET\";\n\tcase FCP_TARGET_RESET:\n\t\treturn \"FCP_TARGET_RESET\";\n\tcase FCP_CLEAR_ACA:\n\t\treturn \"FCP_CLEAR_ACA\";\n\tcase FCP_TERMINATE_TASK:\n\t\treturn \"FCP_TERMINATE_TASK\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\n\n/**\n * lpfc_check_fcp_rsp - check the returned fcp_rsp to see if task failed\n * @vport: The virtual port for which this call is being executed.\n * @lpfc_cmd: Pointer to lpfc_io_buf data structure.\n *\n * This routine checks the FCP RSP INFO to see if the tsk mgmt command succeded\n *\n * Return code :\n *   0x2003 - Error\n *   0x2002 - Success\n **/\nstatic int\nlpfc_check_fcp_rsp(struct lpfc_vport *vport, struct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct fcp_rsp *fcprsp = lpfc_cmd->fcp_rsp;\n\tuint32_t rsp_info;\n\tuint32_t rsp_len;\n\tuint8_t  rsp_info_code;\n\tint ret = FAILED;\n\n\n\tif (fcprsp == NULL)\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t \"0703 fcp_rsp is missing\\n\");\n\telse {\n\t\trsp_info = fcprsp->rspStatus2;\n\t\trsp_len = be32_to_cpu(fcprsp->rspRspLen);\n\t\trsp_info_code = fcprsp->rspInfo3;\n\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t LOG_FCP,\n\t\t\t\t \"0706 fcp_rsp valid 0x%x,\"\n\t\t\t\t \" rsp len=%d code 0x%x\\n\",\n\t\t\t\t rsp_info,\n\t\t\t\t rsp_len, rsp_info_code);\n\n\t\t/* If FCP_RSP_LEN_VALID bit is one, then the FCP_RSP_LEN\n\t\t * field specifies the number of valid bytes of FCP_RSP_INFO.\n\t\t * The FCP_RSP_LEN field shall be set to 0x04 or 0x08\n\t\t */\n\t\tif ((fcprsp->rspStatus2 & RSP_LEN_VALID) &&\n\t\t    ((rsp_len == 8) || (rsp_len == 4))) {\n\t\t\tswitch (rsp_info_code) {\n\t\t\tcase RSP_NO_FAILURE:\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t\t\t \"0715 Task Mgmt No Failure\\n\");\n\t\t\t\tret = SUCCESS;\n\t\t\t\tbreak;\n\t\t\tcase RSP_TM_NOT_SUPPORTED: /* TM rejected */\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t\t\t \"0716 Task Mgmt Target \"\n\t\t\t\t\t\t\"reject\\n\");\n\t\t\t\tbreak;\n\t\t\tcase RSP_TM_NOT_COMPLETED: /* TM failed */\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t\t\t \"0717 Task Mgmt Target \"\n\t\t\t\t\t\t\"failed TM\\n\");\n\t\t\t\tbreak;\n\t\t\tcase RSP_TM_INVALID_LU: /* TM to invalid LU! */\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t\t\t \"0718 Task Mgmt to invalid \"\n\t\t\t\t\t\t\"LUN\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n/**\n * lpfc_send_taskmgmt - Generic SCSI Task Mgmt Handler\n * @vport: The virtual port for which this call is being executed.\n * @cmnd: Pointer to scsi_cmnd data structure.\n * @tgt_id: Target ID of remote device.\n * @lun_id: Lun number for the TMF\n * @task_mgmt_cmd: type of TMF to send\n *\n * This routine builds and sends a TMF (SCSI Task Mgmt Function) to\n * a remote port.\n *\n * Return Code:\n *   0x2003 - Error\n *   0x2002 - Success.\n **/\nstatic int\nlpfc_send_taskmgmt(struct lpfc_vport *vport, struct scsi_cmnd *cmnd,\n\t\t   unsigned int tgt_id, uint64_t lun_id,\n\t\t   uint8_t task_mgmt_cmd)\n{\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_io_buf *lpfc_cmd;\n\tstruct lpfc_iocbq *iocbq;\n\tstruct lpfc_iocbq *iocbqrsp;\n\tstruct lpfc_rport_data *rdata;\n\tstruct lpfc_nodelist *pnode;\n\tint ret;\n\tint status;\n\n\trdata = lpfc_rport_data_from_scsi_device(cmnd->device);\n\tif (!rdata || !rdata->pnode)\n\t\treturn FAILED;\n\tpnode = rdata->pnode;\n\n\tlpfc_cmd = lpfc_get_scsi_buf(phba, pnode, NULL);\n\tif (lpfc_cmd == NULL)\n\t\treturn FAILED;\n\tlpfc_cmd->timeout = phba->cfg_task_mgmt_tmo;\n\tlpfc_cmd->rdata = rdata;\n\tlpfc_cmd->pCmd = cmnd;\n\tlpfc_cmd->ndlp = pnode;\n\n\tstatus = lpfc_scsi_prep_task_mgmt_cmd(vport, lpfc_cmd, lun_id,\n\t\t\t\t\t   task_mgmt_cmd);\n\tif (!status) {\n\t\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n\t\treturn FAILED;\n\t}\n\n\tiocbq = &lpfc_cmd->cur_iocbq;\n\tiocbqrsp = lpfc_sli_get_iocbq(phba);\n\tif (iocbqrsp == NULL) {\n\t\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n\t\treturn FAILED;\n\t}\n\tiocbq->iocb_cmpl = lpfc_tskmgmt_def_cmpl;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t \"0702 Issue %s to TGT %d LUN %llu \"\n\t\t\t \"rpi x%x nlp_flag x%x Data: x%x x%x\\n\",\n\t\t\t lpfc_taskmgmt_name(task_mgmt_cmd), tgt_id, lun_id,\n\t\t\t pnode->nlp_rpi, pnode->nlp_flag, iocbq->sli4_xritag,\n\t\t\t iocbq->iocb_flag);\n\n\tstatus = lpfc_sli_issue_iocb_wait(phba, LPFC_FCP_RING,\n\t\t\t\t\t  iocbq, iocbqrsp, lpfc_cmd->timeout);\n\tif ((status != IOCB_SUCCESS) ||\n\t    (iocbqrsp->iocb.ulpStatus != IOSTAT_SUCCESS)) {\n\t\tif (status != IOCB_SUCCESS ||\n\t\t    iocbqrsp->iocb.ulpStatus != IOSTAT_FCP_RSP_ERROR)\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"0727 TMF %s to TGT %d LUN %llu \"\n\t\t\t\t\t \"failed (%d, %d) iocb_flag x%x\\n\",\n\t\t\t\t\t lpfc_taskmgmt_name(task_mgmt_cmd),\n\t\t\t\t\t tgt_id, lun_id,\n\t\t\t\t\t iocbqrsp->iocb.ulpStatus,\n\t\t\t\t\t iocbqrsp->iocb.un.ulpWord[4],\n\t\t\t\t\t iocbq->iocb_flag);\n\t\t/* if ulpStatus != IOCB_SUCCESS, then status == IOCB_SUCCESS */\n\t\tif (status == IOCB_SUCCESS) {\n\t\t\tif (iocbqrsp->iocb.ulpStatus == IOSTAT_FCP_RSP_ERROR)\n\t\t\t\t/* Something in the FCP_RSP was invalid.\n\t\t\t\t * Check conditions */\n\t\t\t\tret = lpfc_check_fcp_rsp(vport, lpfc_cmd);\n\t\t\telse\n\t\t\t\tret = FAILED;\n\t\t} else if (status == IOCB_TIMEDOUT) {\n\t\t\tret = TIMEOUT_ERROR;\n\t\t} else {\n\t\t\tret = FAILED;\n\t\t}\n\t} else\n\t\tret = SUCCESS;\n\n\tlpfc_sli_release_iocbq(phba, iocbqrsp);\n\n\tif (ret != TIMEOUT_ERROR)\n\t\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n\n\treturn ret;\n}\n\n/**\n * lpfc_chk_tgt_mapped -\n * @vport: The virtual port to check on\n * @cmnd: Pointer to scsi_cmnd data structure.\n *\n * This routine delays until the scsi target (aka rport) for the\n * command exists (is present and logged in) or we declare it non-existent.\n *\n * Return code :\n *  0x2003 - Error\n *  0x2002 - Success\n **/\nstatic int\nlpfc_chk_tgt_mapped(struct lpfc_vport *vport, struct scsi_cmnd *cmnd)\n{\n\tstruct lpfc_rport_data *rdata;\n\tstruct lpfc_nodelist *pnode;\n\tunsigned long later;\n\n\trdata = lpfc_rport_data_from_scsi_device(cmnd->device);\n\tif (!rdata) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\"0797 Tgt Map rport failure: rdata x%px\\n\", rdata);\n\t\treturn FAILED;\n\t}\n\tpnode = rdata->pnode;\n\t/*\n\t * If target is not in a MAPPED state, delay until\n\t * target is rediscovered or devloss timeout expires.\n\t */\n\tlater = msecs_to_jiffies(2 * vport->cfg_devloss_tmo * 1000) + jiffies;\n\twhile (time_after(later, jiffies)) {\n\t\tif (!pnode)\n\t\t\treturn FAILED;\n\t\tif (pnode->nlp_state == NLP_STE_MAPPED_NODE)\n\t\t\treturn SUCCESS;\n\t\tschedule_timeout_uninterruptible(msecs_to_jiffies(500));\n\t\trdata = lpfc_rport_data_from_scsi_device(cmnd->device);\n\t\tif (!rdata)\n\t\t\treturn FAILED;\n\t\tpnode = rdata->pnode;\n\t}\n\tif (!pnode || (pnode->nlp_state != NLP_STE_MAPPED_NODE))\n\t\treturn FAILED;\n\treturn SUCCESS;\n}\n\n/**\n * lpfc_reset_flush_io_context -\n * @vport: The virtual port (scsi_host) for the flush context\n * @tgt_id: If aborting by Target contect - specifies the target id\n * @lun_id: If aborting by Lun context - specifies the lun id\n * @context: specifies the context level to flush at.\n *\n * After a reset condition via TMF, we need to flush orphaned i/o\n * contexts from the adapter. This routine aborts any contexts\n * outstanding, then waits for their completions. The wait is\n * bounded by devloss_tmo though.\n *\n * Return code :\n *  0x2003 - Error\n *  0x2002 - Success\n **/\nstatic int\nlpfc_reset_flush_io_context(struct lpfc_vport *vport, uint16_t tgt_id,\n\t\t\tuint64_t lun_id, lpfc_ctx_cmd context)\n{\n\tstruct lpfc_hba   *phba = vport->phba;\n\tunsigned long later;\n\tint cnt;\n\n\tcnt = lpfc_sli_sum_iocb(vport, tgt_id, lun_id, context);\n\tif (cnt)\n\t\tlpfc_sli_abort_taskmgmt(vport,\n\t\t\t\t\t&phba->sli.sli3_ring[LPFC_FCP_RING],\n\t\t\t\t\ttgt_id, lun_id, context);\n\tlater = msecs_to_jiffies(2 * vport->cfg_devloss_tmo * 1000) + jiffies;\n\twhile (time_after(later, jiffies) && cnt) {\n\t\tschedule_timeout_uninterruptible(msecs_to_jiffies(20));\n\t\tcnt = lpfc_sli_sum_iocb(vport, tgt_id, lun_id, context);\n\t}\n\tif (cnt) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"0724 I/O flush failure for context %s : cnt x%x\\n\",\n\t\t\t((context == LPFC_CTX_LUN) ? \"LUN\" :\n\t\t\t ((context == LPFC_CTX_TGT) ? \"TGT\" :\n\t\t\t  ((context == LPFC_CTX_HOST) ? \"HOST\" : \"Unknown\"))),\n\t\t\tcnt);\n\t\treturn FAILED;\n\t}\n\treturn SUCCESS;\n}\n\n/**\n * lpfc_device_reset_handler - scsi_host_template eh_device_reset entry point\n * @cmnd: Pointer to scsi_cmnd data structure.\n *\n * This routine does a device reset by sending a LUN_RESET task management\n * command.\n *\n * Return code :\n *  0x2003 - Error\n *  0x2002 - Success\n **/\nstatic int\nlpfc_device_reset_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct Scsi_Host  *shost = cmnd->device->host;\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_rport_data *rdata;\n\tstruct lpfc_nodelist *pnode;\n\tunsigned tgt_id = cmnd->device->id;\n\tuint64_t lun_id = cmnd->device->lun;\n\tstruct lpfc_scsi_event_header scsi_event;\n\tint status;\n\n\trdata = lpfc_rport_data_from_scsi_device(cmnd->device);\n\tif (!rdata || !rdata->pnode) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0798 Device Reset rdata failure: rdata x%px\\n\",\n\t\t\t\t rdata);\n\t\treturn FAILED;\n\t}\n\tpnode = rdata->pnode;\n\tstatus = fc_block_scsi_eh(cmnd);\n\tif (status != 0 && status != SUCCESS)\n\t\treturn status;\n\n\tstatus = lpfc_chk_tgt_mapped(vport, cmnd);\n\tif (status == FAILED) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"0721 Device Reset rport failure: rdata x%px\\n\", rdata);\n\t\treturn FAILED;\n\t}\n\n\tscsi_event.event_type = FC_REG_SCSI_EVENT;\n\tscsi_event.subcategory = LPFC_EVENT_LUNRESET;\n\tscsi_event.lun = lun_id;\n\tmemcpy(scsi_event.wwpn, &pnode->nlp_portname, sizeof(struct lpfc_name));\n\tmemcpy(scsi_event.wwnn, &pnode->nlp_nodename, sizeof(struct lpfc_name));\n\n\tfc_host_post_vendor_event(shost, fc_get_event_number(),\n\t\tsizeof(scsi_event), (char *)&scsi_event, LPFC_NL_VENDOR_ID);\n\n\tstatus = lpfc_send_taskmgmt(vport, cmnd, tgt_id, lun_id,\n\t\t\t\t\t\tFCP_LUN_RESET);\n\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0713 SCSI layer issued Device Reset (%d, %llu) \"\n\t\t\t \"return x%x\\n\", tgt_id, lun_id, status);\n\n\t/*\n\t * We have to clean up i/o as : they may be orphaned by the TMF;\n\t * or if the TMF failed, they may be in an indeterminate state.\n\t * So, continue on.\n\t * We will report success if all the i/o aborts successfully.\n\t */\n\tif (status == SUCCESS)\n\t\tstatus = lpfc_reset_flush_io_context(vport, tgt_id, lun_id,\n\t\t\t\t\t\tLPFC_CTX_LUN);\n\n\treturn status;\n}\n\n/**\n * lpfc_target_reset_handler - scsi_host_template eh_target_reset entry point\n * @cmnd: Pointer to scsi_cmnd data structure.\n *\n * This routine does a target reset by sending a TARGET_RESET task management\n * command.\n *\n * Return code :\n *  0x2003 - Error\n *  0x2002 - Success\n **/\nstatic int\nlpfc_target_reset_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct Scsi_Host  *shost = cmnd->device->host;\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_rport_data *rdata;\n\tstruct lpfc_nodelist *pnode;\n\tunsigned tgt_id = cmnd->device->id;\n\tuint64_t lun_id = cmnd->device->lun;\n\tstruct lpfc_scsi_event_header scsi_event;\n\tint status;\n\n\trdata = lpfc_rport_data_from_scsi_device(cmnd->device);\n\tif (!rdata || !rdata->pnode) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0799 Target Reset rdata failure: rdata x%px\\n\",\n\t\t\t\t rdata);\n\t\treturn FAILED;\n\t}\n\tpnode = rdata->pnode;\n\tstatus = fc_block_scsi_eh(cmnd);\n\tif (status != 0 && status != SUCCESS)\n\t\treturn status;\n\n\tstatus = lpfc_chk_tgt_mapped(vport, cmnd);\n\tif (status == FAILED) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"0722 Target Reset rport failure: rdata x%px\\n\", rdata);\n\t\tif (pnode) {\n\t\t\tspin_lock_irq(&pnode->lock);\n\t\t\tpnode->nlp_flag &= ~NLP_NPR_ADISC;\n\t\t\tpnode->nlp_fcp_info &= ~NLP_FCP_2_DEVICE;\n\t\t\tspin_unlock_irq(&pnode->lock);\n\t\t}\n\t\tlpfc_reset_flush_io_context(vport, tgt_id, lun_id,\n\t\t\t\t\t  LPFC_CTX_TGT);\n\t\treturn FAST_IO_FAIL;\n\t}\n\n\tscsi_event.event_type = FC_REG_SCSI_EVENT;\n\tscsi_event.subcategory = LPFC_EVENT_TGTRESET;\n\tscsi_event.lun = 0;\n\tmemcpy(scsi_event.wwpn, &pnode->nlp_portname, sizeof(struct lpfc_name));\n\tmemcpy(scsi_event.wwnn, &pnode->nlp_nodename, sizeof(struct lpfc_name));\n\n\tfc_host_post_vendor_event(shost, fc_get_event_number(),\n\t\tsizeof(scsi_event), (char *)&scsi_event, LPFC_NL_VENDOR_ID);\n\n\tstatus = lpfc_send_taskmgmt(vport, cmnd, tgt_id, lun_id,\n\t\t\t\t\tFCP_TARGET_RESET);\n\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0723 SCSI layer issued Target Reset (%d, %llu) \"\n\t\t\t \"return x%x\\n\", tgt_id, lun_id, status);\n\n\t/*\n\t * We have to clean up i/o as : they may be orphaned by the TMF;\n\t * or if the TMF failed, they may be in an indeterminate state.\n\t * So, continue on.\n\t * We will report success if all the i/o aborts successfully.\n\t */\n\tif (status == SUCCESS)\n\t\tstatus = lpfc_reset_flush_io_context(vport, tgt_id, lun_id,\n\t\t\t\t\t  LPFC_CTX_TGT);\n\treturn status;\n}\n\n/**\n * lpfc_bus_reset_handler - scsi_host_template eh_bus_reset_handler entry point\n * @cmnd: Pointer to scsi_cmnd data structure.\n *\n * This routine does target reset to all targets on @cmnd->device->host.\n * This emulates Parallel SCSI Bus Reset Semantics.\n *\n * Return code :\n *  0x2003 - Error\n *  0x2002 - Success\n **/\nstatic int\nlpfc_bus_reset_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct Scsi_Host  *shost = cmnd->device->host;\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_nodelist *ndlp = NULL;\n\tstruct lpfc_scsi_event_header scsi_event;\n\tint match;\n\tint ret = SUCCESS, status, i;\n\n\tscsi_event.event_type = FC_REG_SCSI_EVENT;\n\tscsi_event.subcategory = LPFC_EVENT_BUSRESET;\n\tscsi_event.lun = 0;\n\tmemcpy(scsi_event.wwpn, &vport->fc_portname, sizeof(struct lpfc_name));\n\tmemcpy(scsi_event.wwnn, &vport->fc_nodename, sizeof(struct lpfc_name));\n\n\tfc_host_post_vendor_event(shost, fc_get_event_number(),\n\t\tsizeof(scsi_event), (char *)&scsi_event, LPFC_NL_VENDOR_ID);\n\n\tstatus = fc_block_scsi_eh(cmnd);\n\tif (status != 0 && status != SUCCESS)\n\t\treturn status;\n\n\t/*\n\t * Since the driver manages a single bus device, reset all\n\t * targets known to the driver.  Should any target reset\n\t * fail, this routine returns failure to the midlayer.\n\t */\n\tfor (i = 0; i < LPFC_MAX_TARGET; i++) {\n\t\t/* Search for mapped node by target ID */\n\t\tmatch = 0;\n\t\tspin_lock_irq(shost->host_lock);\n\t\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\n\n\t\t\tif (vport->phba->cfg_fcp2_no_tgt_reset &&\n\t\t\t    (ndlp->nlp_fcp_info & NLP_FCP_2_DEVICE))\n\t\t\t\tcontinue;\n\t\t\tif (ndlp->nlp_state == NLP_STE_MAPPED_NODE &&\n\t\t\t    ndlp->nlp_sid == i &&\n\t\t\t    ndlp->rport &&\n\t\t\t    ndlp->nlp_type & NLP_FCP_TARGET) {\n\t\t\t\tmatch = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(shost->host_lock);\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tstatus = lpfc_send_taskmgmt(vport, cmnd,\n\t\t\t\t\ti, 0, FCP_TARGET_RESET);\n\n\t\tif (status != SUCCESS) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"0700 Bus Reset on target %d failed\\n\",\n\t\t\t\t\t i);\n\t\t\tret = FAILED;\n\t\t}\n\t}\n\t/*\n\t * We have to clean up i/o as : they may be orphaned by the TMFs\n\t * above; or if any of the TMFs failed, they may be in an\n\t * indeterminate state.\n\t * We will report success if all the i/o aborts successfully.\n\t */\n\n\tstatus = lpfc_reset_flush_io_context(vport, 0, 0, LPFC_CTX_HOST);\n\tif (status != SUCCESS)\n\t\tret = FAILED;\n\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0714 SCSI layer issued Bus Reset Data: x%x\\n\", ret);\n\treturn ret;\n}\n\n/**\n * lpfc_host_reset_handler - scsi_host_template eh_host_reset_handler entry pt\n * @cmnd: Pointer to scsi_cmnd data structure.\n *\n * This routine does host reset to the adaptor port. It brings the HBA\n * offline, performs a board restart, and then brings the board back online.\n * The lpfc_offline calls lpfc_sli_hba_down which will abort and local\n * reject all outstanding SCSI commands to the host and error returned\n * back to SCSI mid-level. As this will be SCSI mid-level's last resort\n * of error handling, it will only return error if resetting of the adapter\n * is not successful; in all other cases, will return success.\n *\n * Return code :\n *  0x2003 - Error\n *  0x2002 - Success\n **/\nstatic int\nlpfc_host_reset_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct Scsi_Host *shost = cmnd->device->host;\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\tint rc, ret = SUCCESS;\n\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"3172 SCSI layer issued Host Reset Data:\\n\");\n\n\tlpfc_offline_prep(phba, LPFC_MBX_WAIT);\n\tlpfc_offline(phba);\n\trc = lpfc_sli_brdrestart(phba);\n\tif (rc)\n\t\tgoto error;\n\n\trc = lpfc_online(phba);\n\tif (rc)\n\t\tgoto error;\n\n\tlpfc_unblock_mgmt_io(phba);\n\n\treturn ret;\nerror:\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"3323 Failed host reset\\n\");\n\tlpfc_unblock_mgmt_io(phba);\n\treturn FAILED;\n}\n\n/**\n * lpfc_slave_alloc - scsi_host_template slave_alloc entry point\n * @sdev: Pointer to scsi_device.\n *\n * This routine populates the cmds_per_lun count + 2 scsi_bufs into  this host's\n * globally available list of scsi buffers. This routine also makes sure scsi\n * buffer is not allocated more than HBA limit conveyed to midlayer. This list\n * of scsi buffer exists for the lifetime of the driver.\n *\n * Return codes:\n *   non-0 - Error\n *   0 - Success\n **/\nstatic int\nlpfc_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) sdev->host->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\n\tuint32_t total = 0;\n\tuint32_t num_to_alloc = 0;\n\tint num_allocated = 0;\n\tuint32_t sdev_cnt;\n\tstruct lpfc_device_data *device_data;\n\tunsigned long flags;\n\tstruct lpfc_name target_wwpn;\n\n\tif (!rport || fc_remote_port_chkready(rport))\n\t\treturn -ENXIO;\n\n\tif (phba->cfg_fof) {\n\n\t\t/*\n\t\t * Check to see if the device data structure for the lun\n\t\t * exists.  If not, create one.\n\t\t */\n\n\t\tu64_to_wwn(rport->port_name, target_wwpn.u.wwn);\n\t\tspin_lock_irqsave(&phba->devicelock, flags);\n\t\tdevice_data = __lpfc_get_device_data(phba,\n\t\t\t\t\t\t     &phba->luns,\n\t\t\t\t\t\t     &vport->fc_portname,\n\t\t\t\t\t\t     &target_wwpn,\n\t\t\t\t\t\t     sdev->lun);\n\t\tif (!device_data) {\n\t\t\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\t\t\tdevice_data = lpfc_create_device_data(phba,\n\t\t\t\t\t\t\t&vport->fc_portname,\n\t\t\t\t\t\t\t&target_wwpn,\n\t\t\t\t\t\t\tsdev->lun,\n\t\t\t\t\t\t\tphba->cfg_XLanePriority,\n\t\t\t\t\t\t\ttrue);\n\t\t\tif (!device_data)\n\t\t\t\treturn -ENOMEM;\n\t\t\tspin_lock_irqsave(&phba->devicelock, flags);\n\t\t\tlist_add_tail(&device_data->listentry, &phba->luns);\n\t\t}\n\t\tdevice_data->rport_data = rport->dd_data;\n\t\tdevice_data->available = true;\n\t\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\t\tsdev->hostdata = device_data;\n\t} else {\n\t\tsdev->hostdata = rport->dd_data;\n\t}\n\tsdev_cnt = atomic_inc_return(&phba->sdev_cnt);\n\n\t/* For SLI4, all IO buffers are pre-allocated */\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\treturn 0;\n\n\t/* This code path is now ONLY for SLI3 adapters */\n\n\t/*\n\t * Populate the cmds_per_lun count scsi_bufs into this host's globally\n\t * available list of scsi buffers.  Don't allocate more than the\n\t * HBA limit conveyed to the midlayer via the host structure.  The\n\t * formula accounts for the lun_queue_depth + error handlers + 1\n\t * extra.  This list of scsi bufs exists for the lifetime of the driver.\n\t */\n\ttotal = phba->total_scsi_bufs;\n\tnum_to_alloc = vport->cfg_lun_queue_depth + 2;\n\n\t/* If allocated buffers are enough do nothing */\n\tif ((sdev_cnt * (vport->cfg_lun_queue_depth + 2)) < total)\n\t\treturn 0;\n\n\t/* Allow some exchanges to be available always to complete discovery */\n\tif (total >= phba->cfg_hba_queue_depth - LPFC_DISC_IOCB_BUFF_COUNT ) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t\t \"0704 At limitation of %d preallocated \"\n\t\t\t\t \"command buffers\\n\", total);\n\t\treturn 0;\n\t/* Allow some exchanges to be available always to complete discovery */\n\t} else if (total + num_to_alloc >\n\t\tphba->cfg_hba_queue_depth - LPFC_DISC_IOCB_BUFF_COUNT ) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t\t \"0705 Allocation request of %d \"\n\t\t\t\t \"command buffers will exceed max of %d.  \"\n\t\t\t\t \"Reducing allocation request to %d.\\n\",\n\t\t\t\t num_to_alloc, phba->cfg_hba_queue_depth,\n\t\t\t\t (phba->cfg_hba_queue_depth - total));\n\t\tnum_to_alloc = phba->cfg_hba_queue_depth - total;\n\t}\n\tnum_allocated = lpfc_new_scsi_buf_s3(vport, num_to_alloc);\n\tif (num_to_alloc != num_allocated) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"0708 Allocation request of %d \"\n\t\t\t\t\t \"command buffers did not succeed.  \"\n\t\t\t\t\t \"Allocated %d buffers.\\n\",\n\t\t\t\t\t num_to_alloc, num_allocated);\n\t}\n\tif (num_allocated > 0)\n\t\tphba->total_scsi_bufs += num_allocated;\n\treturn 0;\n}\n\n/**\n * lpfc_slave_configure - scsi_host_template slave_configure entry point\n * @sdev: Pointer to scsi_device.\n *\n * This routine configures following items\n *   - Tag command queuing support for @sdev if supported.\n *   - Enable SLI polling for fcp ring if ENABLE_FCP_RING_POLLING flag is set.\n *\n * Return codes:\n *   0 - Success\n **/\nstatic int\nlpfc_slave_configure(struct scsi_device *sdev)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) sdev->host->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tscsi_change_queue_depth(sdev, vport->cfg_lun_queue_depth);\n\n\tif (phba->cfg_poll & ENABLE_FCP_RING_POLLING) {\n\t\tlpfc_sli_handle_fast_ring_event(phba,\n\t\t\t&phba->sli.sli3_ring[LPFC_FCP_RING], HA_R0RE_REQ);\n\t\tif (phba->cfg_poll & DISABLE_FCP_RING_INT)\n\t\t\tlpfc_poll_rearm_timer(phba);\n\t}\n\n\treturn 0;\n}\n\n/**\n * lpfc_slave_destroy - slave_destroy entry point of SHT data structure\n * @sdev: Pointer to scsi_device.\n *\n * This routine sets @sdev hostatdata filed to null.\n **/\nstatic void\nlpfc_slave_destroy(struct scsi_device *sdev)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) sdev->host->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tunsigned long flags;\n\tstruct lpfc_device_data *device_data = sdev->hostdata;\n\n\tatomic_dec(&phba->sdev_cnt);\n\tif ((phba->cfg_fof) && (device_data)) {\n\t\tspin_lock_irqsave(&phba->devicelock, flags);\n\t\tdevice_data->available = false;\n\t\tif (!device_data->oas_enabled)\n\t\t\tlpfc_delete_device_data(phba, device_data);\n\t\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\t}\n\tsdev->hostdata = NULL;\n\treturn;\n}\n\n/**\n * lpfc_create_device_data - creates and initializes device data structure for OAS\n * @phba: Pointer to host bus adapter structure.\n * @vport_wwpn: Pointer to vport's wwpn information\n * @target_wwpn: Pointer to target's wwpn information\n * @lun: Lun on target\n * @pri: Priority\n * @atomic_create: Flag to indicate if memory should be allocated using the\n *\t\t  GFP_ATOMIC flag or not.\n *\n * This routine creates a device data structure which will contain identifying\n * information for the device (host wwpn, target wwpn, lun), state of OAS,\n * whether or not the corresponding lun is available by the system,\n * and pointer to the rport data.\n *\n * Return codes:\n *   NULL - Error\n *   Pointer to lpfc_device_data - Success\n **/\nstruct lpfc_device_data*\nlpfc_create_device_data(struct lpfc_hba *phba, struct lpfc_name *vport_wwpn,\n\t\t\tstruct lpfc_name *target_wwpn, uint64_t lun,\n\t\t\tuint32_t pri, bool atomic_create)\n{\n\n\tstruct lpfc_device_data *lun_info;\n\tint memory_flags;\n\n\tif (unlikely(!phba) || !vport_wwpn || !target_wwpn  ||\n\t    !(phba->cfg_fof))\n\t\treturn NULL;\n\n\t/* Attempt to create the device data to contain lun info */\n\n\tif (atomic_create)\n\t\tmemory_flags = GFP_ATOMIC;\n\telse\n\t\tmemory_flags = GFP_KERNEL;\n\tlun_info = mempool_alloc(phba->device_data_mem_pool, memory_flags);\n\tif (!lun_info)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&lun_info->listentry);\n\tlun_info->rport_data  = NULL;\n\tmemcpy(&lun_info->device_id.vport_wwpn, vport_wwpn,\n\t       sizeof(struct lpfc_name));\n\tmemcpy(&lun_info->device_id.target_wwpn, target_wwpn,\n\t       sizeof(struct lpfc_name));\n\tlun_info->device_id.lun = lun;\n\tlun_info->oas_enabled = false;\n\tlun_info->priority = pri;\n\tlun_info->available = false;\n\treturn lun_info;\n}\n\n/**\n * lpfc_delete_device_data - frees a device data structure for OAS\n * @phba: Pointer to host bus adapter structure.\n * @lun_info: Pointer to device data structure to free.\n *\n * This routine frees the previously allocated device data structure passed.\n *\n **/\nvoid\nlpfc_delete_device_data(struct lpfc_hba *phba,\n\t\t\tstruct lpfc_device_data *lun_info)\n{\n\n\tif (unlikely(!phba) || !lun_info  ||\n\t    !(phba->cfg_fof))\n\t\treturn;\n\n\tif (!list_empty(&lun_info->listentry))\n\t\tlist_del(&lun_info->listentry);\n\tmempool_free(lun_info, phba->device_data_mem_pool);\n\treturn;\n}\n\n/**\n * __lpfc_get_device_data - returns the device data for the specified lun\n * @phba: Pointer to host bus adapter structure.\n * @list: Point to list to search.\n * @vport_wwpn: Pointer to vport's wwpn information\n * @target_wwpn: Pointer to target's wwpn information\n * @lun: Lun on target\n *\n * This routine searches the list passed for the specified lun's device data.\n * This function does not hold locks, it is the responsibility of the caller\n * to ensure the proper lock is held before calling the function.\n *\n * Return codes:\n *   NULL - Error\n *   Pointer to lpfc_device_data - Success\n **/\nstruct lpfc_device_data*\n__lpfc_get_device_data(struct lpfc_hba *phba, struct list_head *list,\n\t\t       struct lpfc_name *vport_wwpn,\n\t\t       struct lpfc_name *target_wwpn, uint64_t lun)\n{\n\n\tstruct lpfc_device_data *lun_info;\n\n\tif (unlikely(!phba) || !list || !vport_wwpn || !target_wwpn ||\n\t    !phba->cfg_fof)\n\t\treturn NULL;\n\n\t/* Check to see if the lun is already enabled for OAS. */\n\n\tlist_for_each_entry(lun_info, list, listentry) {\n\t\tif ((memcmp(&lun_info->device_id.vport_wwpn, vport_wwpn,\n\t\t\t    sizeof(struct lpfc_name)) == 0) &&\n\t\t    (memcmp(&lun_info->device_id.target_wwpn, target_wwpn,\n\t\t\t    sizeof(struct lpfc_name)) == 0) &&\n\t\t    (lun_info->device_id.lun == lun))\n\t\t\treturn lun_info;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * lpfc_find_next_oas_lun - searches for the next oas lun\n * @phba: Pointer to host bus adapter structure.\n * @vport_wwpn: Pointer to vport's wwpn information\n * @target_wwpn: Pointer to target's wwpn information\n * @starting_lun: Pointer to the lun to start searching for\n * @found_vport_wwpn: Pointer to the found lun's vport wwpn information\n * @found_target_wwpn: Pointer to the found lun's target wwpn information\n * @found_lun: Pointer to the found lun.\n * @found_lun_status: Pointer to status of the found lun.\n * @found_lun_pri: Pointer to priority of the found lun.\n *\n * This routine searches the luns list for the specified lun\n * or the first lun for the vport/target.  If the vport wwpn contains\n * a zero value then a specific vport is not specified. In this case\n * any vport which contains the lun will be considered a match.  If the\n * target wwpn contains a zero value then a specific target is not specified.\n * In this case any target which contains the lun will be considered a\n * match.  If the lun is found, the lun, vport wwpn, target wwpn and lun status\n * are returned.  The function will also return the next lun if available.\n * If the next lun is not found, starting_lun parameter will be set to\n * NO_MORE_OAS_LUN.\n *\n * Return codes:\n *   non-0 - Error\n *   0 - Success\n **/\nbool\nlpfc_find_next_oas_lun(struct lpfc_hba *phba, struct lpfc_name *vport_wwpn,\n\t\t       struct lpfc_name *target_wwpn, uint64_t *starting_lun,\n\t\t       struct lpfc_name *found_vport_wwpn,\n\t\t       struct lpfc_name *found_target_wwpn,\n\t\t       uint64_t *found_lun,\n\t\t       uint32_t *found_lun_status,\n\t\t       uint32_t *found_lun_pri)\n{\n\n\tunsigned long flags;\n\tstruct lpfc_device_data *lun_info;\n\tstruct lpfc_device_id *device_id;\n\tuint64_t lun;\n\tbool found = false;\n\n\tif (unlikely(!phba) || !vport_wwpn || !target_wwpn ||\n\t    !starting_lun || !found_vport_wwpn ||\n\t    !found_target_wwpn || !found_lun || !found_lun_status ||\n\t    (*starting_lun == NO_MORE_OAS_LUN) ||\n\t    !phba->cfg_fof)\n\t\treturn false;\n\n\tlun = *starting_lun;\n\t*found_lun = NO_MORE_OAS_LUN;\n\t*starting_lun = NO_MORE_OAS_LUN;\n\n\t/* Search for lun or the lun closet in value */\n\n\tspin_lock_irqsave(&phba->devicelock, flags);\n\tlist_for_each_entry(lun_info, &phba->luns, listentry) {\n\t\tif (((wwn_to_u64(vport_wwpn->u.wwn) == 0) ||\n\t\t     (memcmp(&lun_info->device_id.vport_wwpn, vport_wwpn,\n\t\t\t    sizeof(struct lpfc_name)) == 0)) &&\n\t\t    ((wwn_to_u64(target_wwpn->u.wwn) == 0) ||\n\t\t     (memcmp(&lun_info->device_id.target_wwpn, target_wwpn,\n\t\t\t    sizeof(struct lpfc_name)) == 0)) &&\n\t\t    (lun_info->oas_enabled)) {\n\t\t\tdevice_id = &lun_info->device_id;\n\t\t\tif ((!found) &&\n\t\t\t    ((lun == FIND_FIRST_OAS_LUN) ||\n\t\t\t     (device_id->lun == lun))) {\n\t\t\t\t*found_lun = device_id->lun;\n\t\t\t\tmemcpy(found_vport_wwpn,\n\t\t\t\t       &device_id->vport_wwpn,\n\t\t\t\t       sizeof(struct lpfc_name));\n\t\t\t\tmemcpy(found_target_wwpn,\n\t\t\t\t       &device_id->target_wwpn,\n\t\t\t\t       sizeof(struct lpfc_name));\n\t\t\t\tif (lun_info->available)\n\t\t\t\t\t*found_lun_status =\n\t\t\t\t\t\tOAS_LUN_STATUS_EXISTS;\n\t\t\t\telse\n\t\t\t\t\t*found_lun_status = 0;\n\t\t\t\t*found_lun_pri = lun_info->priority;\n\t\t\t\tif (phba->cfg_oas_flags & OAS_FIND_ANY_VPORT)\n\t\t\t\t\tmemset(vport_wwpn, 0x0,\n\t\t\t\t\t       sizeof(struct lpfc_name));\n\t\t\t\tif (phba->cfg_oas_flags & OAS_FIND_ANY_TARGET)\n\t\t\t\t\tmemset(target_wwpn, 0x0,\n\t\t\t\t\t       sizeof(struct lpfc_name));\n\t\t\t\tfound = true;\n\t\t\t} else if (found) {\n\t\t\t\t*starting_lun = device_id->lun;\n\t\t\t\tmemcpy(vport_wwpn, &device_id->vport_wwpn,\n\t\t\t\t       sizeof(struct lpfc_name));\n\t\t\t\tmemcpy(target_wwpn, &device_id->target_wwpn,\n\t\t\t\t       sizeof(struct lpfc_name));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\treturn found;\n}\n\n/**\n * lpfc_enable_oas_lun - enables a lun for OAS operations\n * @phba: Pointer to host bus adapter structure.\n * @vport_wwpn: Pointer to vport's wwpn information\n * @target_wwpn: Pointer to target's wwpn information\n * @lun: Lun\n * @pri: Priority\n *\n * This routine enables a lun for oas operations.  The routines does so by\n * doing the following :\n *\n *   1) Checks to see if the device data for the lun has been created.\n *   2) If found, sets the OAS enabled flag if not set and returns.\n *   3) Otherwise, creates a device data structure.\n *   4) If successfully created, indicates the device data is for an OAS lun,\n *   indicates the lun is not available and add to the list of luns.\n *\n * Return codes:\n *   false - Error\n *   true - Success\n **/\nbool\nlpfc_enable_oas_lun(struct lpfc_hba *phba, struct lpfc_name *vport_wwpn,\n\t\t    struct lpfc_name *target_wwpn, uint64_t lun, uint8_t pri)\n{\n\n\tstruct lpfc_device_data *lun_info;\n\tunsigned long flags;\n\n\tif (unlikely(!phba) || !vport_wwpn || !target_wwpn ||\n\t    !phba->cfg_fof)\n\t\treturn false;\n\n\tspin_lock_irqsave(&phba->devicelock, flags);\n\n\t/* Check to see if the device data for the lun has been created */\n\tlun_info = __lpfc_get_device_data(phba, &phba->luns, vport_wwpn,\n\t\t\t\t\t  target_wwpn, lun);\n\tif (lun_info) {\n\t\tif (!lun_info->oas_enabled)\n\t\t\tlun_info->oas_enabled = true;\n\t\tlun_info->priority = pri;\n\t\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\t\treturn true;\n\t}\n\n\t/* Create an lun info structure and add to list of luns */\n\tlun_info = lpfc_create_device_data(phba, vport_wwpn, target_wwpn, lun,\n\t\t\t\t\t   pri, true);\n\tif (lun_info) {\n\t\tlun_info->oas_enabled = true;\n\t\tlun_info->priority = pri;\n\t\tlun_info->available = false;\n\t\tlist_add_tail(&lun_info->listentry, &phba->luns);\n\t\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\t\treturn true;\n\t}\n\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\treturn false;\n}\n\n/**\n * lpfc_disable_oas_lun - disables a lun for OAS operations\n * @phba: Pointer to host bus adapter structure.\n * @vport_wwpn: Pointer to vport's wwpn information\n * @target_wwpn: Pointer to target's wwpn information\n * @lun: Lun\n * @pri: Priority\n *\n * This routine disables a lun for oas operations.  The routines does so by\n * doing the following :\n *\n *   1) Checks to see if the device data for the lun is created.\n *   2) If present, clears the flag indicating this lun is for OAS.\n *   3) If the lun is not available by the system, the device data is\n *   freed.\n *\n * Return codes:\n *   false - Error\n *   true - Success\n **/\nbool\nlpfc_disable_oas_lun(struct lpfc_hba *phba, struct lpfc_name *vport_wwpn,\n\t\t     struct lpfc_name *target_wwpn, uint64_t lun, uint8_t pri)\n{\n\n\tstruct lpfc_device_data *lun_info;\n\tunsigned long flags;\n\n\tif (unlikely(!phba) || !vport_wwpn || !target_wwpn ||\n\t    !phba->cfg_fof)\n\t\treturn false;\n\n\tspin_lock_irqsave(&phba->devicelock, flags);\n\n\t/* Check to see if the lun is available. */\n\tlun_info = __lpfc_get_device_data(phba,\n\t\t\t\t\t  &phba->luns, vport_wwpn,\n\t\t\t\t\t  target_wwpn, lun);\n\tif (lun_info) {\n\t\tlun_info->oas_enabled = false;\n\t\tlun_info->priority = pri;\n\t\tif (!lun_info->available)\n\t\t\tlpfc_delete_device_data(phba, lun_info);\n\t\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\t\treturn true;\n\t}\n\n\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\treturn false;\n}\n\nstatic int\nlpfc_no_command(struct Scsi_Host *shost, struct scsi_cmnd *cmnd)\n{\n\treturn SCSI_MLQUEUE_HOST_BUSY;\n}\n\nstatic int\nlpfc_no_handler(struct scsi_cmnd *cmnd)\n{\n\treturn FAILED;\n}\n\nstatic int\nlpfc_no_slave(struct scsi_device *sdev)\n{\n\treturn -ENODEV;\n}\n\nstruct scsi_host_template lpfc_template_nvme = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= LPFC_DRIVER_NAME,\n\t.proc_name\t\t= LPFC_DRIVER_NAME,\n\t.info\t\t\t= lpfc_info,\n\t.queuecommand\t\t= lpfc_no_command,\n\t.eh_abort_handler\t= lpfc_no_handler,\n\t.eh_device_reset_handler = lpfc_no_handler,\n\t.eh_target_reset_handler = lpfc_no_handler,\n\t.eh_bus_reset_handler\t= lpfc_no_handler,\n\t.eh_host_reset_handler  = lpfc_no_handler,\n\t.slave_alloc\t\t= lpfc_no_slave,\n\t.slave_configure\t= lpfc_no_slave,\n\t.scan_finished\t\t= lpfc_scan_finished,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= 1,\n\t.cmd_per_lun\t\t= 1,\n\t.shost_attrs\t\t= lpfc_hba_attrs,\n\t.max_sectors\t\t= 0xFFFFFFFF,\n\t.vendor_id\t\t= LPFC_NL_VENDOR_ID,\n\t.track_queue_depth\t= 0,\n};\n\nstruct scsi_host_template lpfc_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= LPFC_DRIVER_NAME,\n\t.proc_name\t\t= LPFC_DRIVER_NAME,\n\t.info\t\t\t= lpfc_info,\n\t.queuecommand\t\t= lpfc_queuecommand,\n\t.eh_timed_out\t\t= fc_eh_timed_out,\n\t.eh_abort_handler\t= lpfc_abort_handler,\n\t.eh_device_reset_handler = lpfc_device_reset_handler,\n\t.eh_target_reset_handler = lpfc_target_reset_handler,\n\t.eh_bus_reset_handler\t= lpfc_bus_reset_handler,\n\t.eh_host_reset_handler  = lpfc_host_reset_handler,\n\t.slave_alloc\t\t= lpfc_slave_alloc,\n\t.slave_configure\t= lpfc_slave_configure,\n\t.slave_destroy\t\t= lpfc_slave_destroy,\n\t.scan_finished\t\t= lpfc_scan_finished,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= LPFC_DEFAULT_SG_SEG_CNT,\n\t.cmd_per_lun\t\t= LPFC_CMD_PER_LUN,\n\t.shost_attrs\t\t= lpfc_hba_attrs,\n\t.max_sectors\t\t= 0xFFFFFFFF,\n\t.vendor_id\t\t= LPFC_NL_VENDOR_ID,\n\t.change_queue_depth\t= scsi_change_queue_depth,\n\t.track_queue_depth\t= 1,\n};\n"}}, "reports": [{"events": [{"location": {"col": 17, "file": 0, "line": 6320}, "message": "ERROR: function lpfc_create_device_data called on line 6552 inside lock on line 6538 but uses GFP_KERNEL"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/lpfc/lpfc_scsi.c", "reportHash": "a1054a32a5dfa65beb596c3e6a1f7c81", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 0, "line": 5537}, "message": "preceding lock on line 5435"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/lpfc/lpfc_scsi.c", "reportHash": "9c090b2bc6bd219e38ee4f9dc7ea3ee5", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
