<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c", "content": "/* bnx2x_main.c: QLogic Everest network driver.\n *\n * Copyright (c) 2007-2013 Broadcom Corporation\n * Copyright (c) 2014 QLogic Corporation\n * All rights reserved\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation.\n *\n * Maintained by: Ariel Elior <ariel.elior@qlogic.com>\n * Written by: Eliezer Tamir\n * Based on code from Michael Chan's bnx2 driver\n * UDP CSUM errata workaround by Arik Gendelman\n * Slowpath and fastpath rework by Vladislav Zolotarov\n * Statistics and Link management by Yitchak Gertner\n *\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/device.h>  /* for dev_info() */\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/aer.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/dma-mapping.h>\n#include <linux/bitops.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <asm/byteorder.h>\n#include <linux/time.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/if_vlan.h>\n#include <linux/crash_dump.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/tcp.h>\n#include <net/vxlan.h>\n#include <net/checksum.h>\n#include <net/ip6_checksum.h>\n#include <linux/workqueue.h>\n#include <linux/crc32.h>\n#include <linux/crc32c.h>\n#include <linux/prefetch.h>\n#include <linux/zlib.h>\n#include <linux/io.h>\n#include <linux/semaphore.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include \"bnx2x.h\"\n#include \"bnx2x_init.h\"\n#include \"bnx2x_init_ops.h\"\n#include \"bnx2x_cmn.h\"\n#include \"bnx2x_vfpf.h\"\n#include \"bnx2x_dcb.h\"\n#include \"bnx2x_sp.h\"\n#include <linux/firmware.h>\n#include \"bnx2x_fw_file_hdr.h\"\n/* FW files */\n#define FW_FILE_VERSION\t\t\t\t\t\\\n\t__stringify(BCM_5710_FW_MAJOR_VERSION) \".\"\t\\\n\t__stringify(BCM_5710_FW_MINOR_VERSION) \".\"\t\\\n\t__stringify(BCM_5710_FW_REVISION_VERSION) \".\"\t\\\n\t__stringify(BCM_5710_FW_ENGINEERING_VERSION)\n#define FW_FILE_NAME_E1\t\t\"bnx2x/bnx2x-e1-\" FW_FILE_VERSION \".fw\"\n#define FW_FILE_NAME_E1H\t\"bnx2x/bnx2x-e1h-\" FW_FILE_VERSION \".fw\"\n#define FW_FILE_NAME_E2\t\t\"bnx2x/bnx2x-e2-\" FW_FILE_VERSION \".fw\"\n\n/* Time in jiffies before concluding the transmitter is hung */\n#define TX_TIMEOUT\t\t(5*HZ)\n\nMODULE_AUTHOR(\"Eliezer Tamir\");\nMODULE_DESCRIPTION(\"QLogic \"\n\t\t   \"BCM57710/57711/57711E/\"\n\t\t   \"57712/57712_MF/57800/57800_MF/57810/57810_MF/\"\n\t\t   \"57840/57840_MF Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(FW_FILE_NAME_E1);\nMODULE_FIRMWARE(FW_FILE_NAME_E1H);\nMODULE_FIRMWARE(FW_FILE_NAME_E2);\n\nint bnx2x_num_queues;\nmodule_param_named(num_queues, bnx2x_num_queues, int, 0444);\nMODULE_PARM_DESC(num_queues,\n\t\t \" Set number of queues (default is as a number of CPUs)\");\n\nstatic int disable_tpa;\nmodule_param(disable_tpa, int, 0444);\nMODULE_PARM_DESC(disable_tpa, \" Disable the TPA (LRO) feature\");\n\nstatic int int_mode;\nmodule_param(int_mode, int, 0444);\nMODULE_PARM_DESC(int_mode, \" Force interrupt mode other than MSI-X \"\n\t\t\t\t\"(1 INT#x; 2 MSI)\");\n\nstatic int dropless_fc;\nmodule_param(dropless_fc, int, 0444);\nMODULE_PARM_DESC(dropless_fc, \" Pause on exhausted host ring\");\n\nstatic int mrrs = -1;\nmodule_param(mrrs, int, 0444);\nMODULE_PARM_DESC(mrrs, \" Force Max Read Req Size (0..3) (for debug)\");\n\nstatic int debug;\nmodule_param(debug, int, 0444);\nMODULE_PARM_DESC(debug, \" Default debug msglevel\");\n\nstatic struct workqueue_struct *bnx2x_wq;\nstruct workqueue_struct *bnx2x_iov_wq;\n\nstruct bnx2x_mac_vals {\n\tu32 xmac_addr;\n\tu32 xmac_val;\n\tu32 emac_addr;\n\tu32 emac_val;\n\tu32 umac_addr[2];\n\tu32 umac_val[2];\n\tu32 bmac_addr;\n\tu32 bmac_val[2];\n};\n\nenum bnx2x_board_type {\n\tBCM57710 = 0,\n\tBCM57711,\n\tBCM57711E,\n\tBCM57712,\n\tBCM57712_MF,\n\tBCM57712_VF,\n\tBCM57800,\n\tBCM57800_MF,\n\tBCM57800_VF,\n\tBCM57810,\n\tBCM57810_MF,\n\tBCM57810_VF,\n\tBCM57840_4_10,\n\tBCM57840_2_20,\n\tBCM57840_MF,\n\tBCM57840_VF,\n\tBCM57811,\n\tBCM57811_MF,\n\tBCM57840_O,\n\tBCM57840_MFO,\n\tBCM57811_VF\n};\n\n/* indexed by board_type, above */\nstatic struct {\n\tchar *name;\n} board_info[] = {\n\t[BCM57710]\t= { \"QLogic BCM57710 10 Gigabit PCIe [Everest]\" },\n\t[BCM57711]\t= { \"QLogic BCM57711 10 Gigabit PCIe\" },\n\t[BCM57711E]\t= { \"QLogic BCM57711E 10 Gigabit PCIe\" },\n\t[BCM57712]\t= { \"QLogic BCM57712 10 Gigabit Ethernet\" },\n\t[BCM57712_MF]\t= { \"QLogic BCM57712 10 Gigabit Ethernet Multi Function\" },\n\t[BCM57712_VF]\t= { \"QLogic BCM57712 10 Gigabit Ethernet Virtual Function\" },\n\t[BCM57800]\t= { \"QLogic BCM57800 10 Gigabit Ethernet\" },\n\t[BCM57800_MF]\t= { \"QLogic BCM57800 10 Gigabit Ethernet Multi Function\" },\n\t[BCM57800_VF]\t= { \"QLogic BCM57800 10 Gigabit Ethernet Virtual Function\" },\n\t[BCM57810]\t= { \"QLogic BCM57810 10 Gigabit Ethernet\" },\n\t[BCM57810_MF]\t= { \"QLogic BCM57810 10 Gigabit Ethernet Multi Function\" },\n\t[BCM57810_VF]\t= { \"QLogic BCM57810 10 Gigabit Ethernet Virtual Function\" },\n\t[BCM57840_4_10]\t= { \"QLogic BCM57840 10 Gigabit Ethernet\" },\n\t[BCM57840_2_20]\t= { \"QLogic BCM57840 20 Gigabit Ethernet\" },\n\t[BCM57840_MF]\t= { \"QLogic BCM57840 10/20 Gigabit Ethernet Multi Function\" },\n\t[BCM57840_VF]\t= { \"QLogic BCM57840 10/20 Gigabit Ethernet Virtual Function\" },\n\t[BCM57811]\t= { \"QLogic BCM57811 10 Gigabit Ethernet\" },\n\t[BCM57811_MF]\t= { \"QLogic BCM57811 10 Gigabit Ethernet Multi Function\" },\n\t[BCM57840_O]\t= { \"QLogic BCM57840 10/20 Gigabit Ethernet\" },\n\t[BCM57840_MFO]\t= { \"QLogic BCM57840 10/20 Gigabit Ethernet Multi Function\" },\n\t[BCM57811_VF]\t= { \"QLogic BCM57840 10/20 Gigabit Ethernet Virtual Function\" }\n};\n\n#ifndef PCI_DEVICE_ID_NX2_57710\n#define PCI_DEVICE_ID_NX2_57710\t\tCHIP_NUM_57710\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57711\n#define PCI_DEVICE_ID_NX2_57711\t\tCHIP_NUM_57711\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57711E\n#define PCI_DEVICE_ID_NX2_57711E\tCHIP_NUM_57711E\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57712\n#define PCI_DEVICE_ID_NX2_57712\t\tCHIP_NUM_57712\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57712_MF\n#define PCI_DEVICE_ID_NX2_57712_MF\tCHIP_NUM_57712_MF\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57712_VF\n#define PCI_DEVICE_ID_NX2_57712_VF\tCHIP_NUM_57712_VF\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57800\n#define PCI_DEVICE_ID_NX2_57800\t\tCHIP_NUM_57800\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57800_MF\n#define PCI_DEVICE_ID_NX2_57800_MF\tCHIP_NUM_57800_MF\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57800_VF\n#define PCI_DEVICE_ID_NX2_57800_VF\tCHIP_NUM_57800_VF\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57810\n#define PCI_DEVICE_ID_NX2_57810\t\tCHIP_NUM_57810\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57810_MF\n#define PCI_DEVICE_ID_NX2_57810_MF\tCHIP_NUM_57810_MF\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57840_O\n#define PCI_DEVICE_ID_NX2_57840_O\tCHIP_NUM_57840_OBSOLETE\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57810_VF\n#define PCI_DEVICE_ID_NX2_57810_VF\tCHIP_NUM_57810_VF\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57840_4_10\n#define PCI_DEVICE_ID_NX2_57840_4_10\tCHIP_NUM_57840_4_10\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57840_2_20\n#define PCI_DEVICE_ID_NX2_57840_2_20\tCHIP_NUM_57840_2_20\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57840_MFO\n#define PCI_DEVICE_ID_NX2_57840_MFO\tCHIP_NUM_57840_MF_OBSOLETE\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57840_MF\n#define PCI_DEVICE_ID_NX2_57840_MF\tCHIP_NUM_57840_MF\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57840_VF\n#define PCI_DEVICE_ID_NX2_57840_VF\tCHIP_NUM_57840_VF\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57811\n#define PCI_DEVICE_ID_NX2_57811\t\tCHIP_NUM_57811\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57811_MF\n#define PCI_DEVICE_ID_NX2_57811_MF\tCHIP_NUM_57811_MF\n#endif\n#ifndef PCI_DEVICE_ID_NX2_57811_VF\n#define PCI_DEVICE_ID_NX2_57811_VF\tCHIP_NUM_57811_VF\n#endif\n\nstatic const struct pci_device_id bnx2x_pci_tbl[] = {\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57710), BCM57710 },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57711), BCM57711 },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57711E), BCM57711E },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57712), BCM57712 },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57712_MF), BCM57712_MF },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57712_VF), BCM57712_VF },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57800), BCM57800 },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57800_MF), BCM57800_MF },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57800_VF), BCM57800_VF },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57810), BCM57810 },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57810_MF), BCM57810_MF },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57840_O), BCM57840_O },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57840_4_10), BCM57840_4_10 },\n\t{ PCI_VDEVICE(QLOGIC,\tPCI_DEVICE_ID_NX2_57840_4_10), BCM57840_4_10 },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57840_2_20), BCM57840_2_20 },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57810_VF), BCM57810_VF },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57840_MFO), BCM57840_MFO },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57840_MF), BCM57840_MF },\n\t{ PCI_VDEVICE(QLOGIC,\tPCI_DEVICE_ID_NX2_57840_MF), BCM57840_MF },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57840_VF), BCM57840_VF },\n\t{ PCI_VDEVICE(QLOGIC,\tPCI_DEVICE_ID_NX2_57840_VF), BCM57840_VF },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57811), BCM57811 },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57811_MF), BCM57811_MF },\n\t{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57811_VF), BCM57811_VF },\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(pci, bnx2x_pci_tbl);\n\nconst u32 dmae_reg_go_c[] = {\n\tDMAE_REG_GO_C0, DMAE_REG_GO_C1, DMAE_REG_GO_C2, DMAE_REG_GO_C3,\n\tDMAE_REG_GO_C4, DMAE_REG_GO_C5, DMAE_REG_GO_C6, DMAE_REG_GO_C7,\n\tDMAE_REG_GO_C8, DMAE_REG_GO_C9, DMAE_REG_GO_C10, DMAE_REG_GO_C11,\n\tDMAE_REG_GO_C12, DMAE_REG_GO_C13, DMAE_REG_GO_C14, DMAE_REG_GO_C15\n};\n\n/* Global resources for unloading a previously loaded device */\n#define BNX2X_PREV_WAIT_NEEDED 1\nstatic DEFINE_SEMAPHORE(bnx2x_prev_sem);\nstatic LIST_HEAD(bnx2x_prev_list);\n\n/* Forward declaration */\nstatic struct cnic_eth_dev *bnx2x_cnic_probe(struct net_device *dev);\nstatic u32 bnx2x_rx_ustorm_prods_offset(struct bnx2x_fastpath *fp);\nstatic int bnx2x_set_storm_rx_mode(struct bnx2x *bp);\n\n/****************************************************************************\n* General service functions\n****************************************************************************/\n\nstatic int bnx2x_hwtstamp_ioctl(struct bnx2x *bp, struct ifreq *ifr);\n\nstatic void __storm_memset_dma_mapping(struct bnx2x *bp,\n\t\t\t\t       u32 addr, dma_addr_t mapping)\n{\n\tREG_WR(bp,  addr, U64_LO(mapping));\n\tREG_WR(bp,  addr + 4, U64_HI(mapping));\n}\n\nstatic void storm_memset_spq_addr(struct bnx2x *bp,\n\t\t\t\t  dma_addr_t mapping, u16 abs_fid)\n{\n\tu32 addr = XSEM_REG_FAST_MEMORY +\n\t\t\tXSTORM_SPQ_PAGE_BASE_OFFSET(abs_fid);\n\n\t__storm_memset_dma_mapping(bp, addr, mapping);\n}\n\nstatic void storm_memset_vf_to_pf(struct bnx2x *bp, u16 abs_fid,\n\t\t\t\t  u16 pf_id)\n{\n\tREG_WR8(bp, BAR_XSTRORM_INTMEM + XSTORM_VF_TO_PF_OFFSET(abs_fid),\n\t\tpf_id);\n\tREG_WR8(bp, BAR_CSTRORM_INTMEM + CSTORM_VF_TO_PF_OFFSET(abs_fid),\n\t\tpf_id);\n\tREG_WR8(bp, BAR_TSTRORM_INTMEM + TSTORM_VF_TO_PF_OFFSET(abs_fid),\n\t\tpf_id);\n\tREG_WR8(bp, BAR_USTRORM_INTMEM + USTORM_VF_TO_PF_OFFSET(abs_fid),\n\t\tpf_id);\n}\n\nstatic void storm_memset_func_en(struct bnx2x *bp, u16 abs_fid,\n\t\t\t\t u8 enable)\n{\n\tREG_WR8(bp, BAR_XSTRORM_INTMEM + XSTORM_FUNC_EN_OFFSET(abs_fid),\n\t\tenable);\n\tREG_WR8(bp, BAR_CSTRORM_INTMEM + CSTORM_FUNC_EN_OFFSET(abs_fid),\n\t\tenable);\n\tREG_WR8(bp, BAR_TSTRORM_INTMEM + TSTORM_FUNC_EN_OFFSET(abs_fid),\n\t\tenable);\n\tREG_WR8(bp, BAR_USTRORM_INTMEM + USTORM_FUNC_EN_OFFSET(abs_fid),\n\t\tenable);\n}\n\nstatic void storm_memset_eq_data(struct bnx2x *bp,\n\t\t\t\t struct event_ring_data *eq_data,\n\t\t\t\tu16 pfid)\n{\n\tsize_t size = sizeof(struct event_ring_data);\n\n\tu32 addr = BAR_CSTRORM_INTMEM + CSTORM_EVENT_RING_DATA_OFFSET(pfid);\n\n\t__storm_memset_struct(bp, addr, size, (u32 *)eq_data);\n}\n\nstatic void storm_memset_eq_prod(struct bnx2x *bp, u16 eq_prod,\n\t\t\t\t u16 pfid)\n{\n\tu32 addr = BAR_CSTRORM_INTMEM + CSTORM_EVENT_RING_PROD_OFFSET(pfid);\n\tREG_WR16(bp, addr, eq_prod);\n}\n\n/* used only at init\n * locking is done by mcp\n */\nstatic void bnx2x_reg_wr_ind(struct bnx2x *bp, u32 addr, u32 val)\n{\n\tpci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS, addr);\n\tpci_write_config_dword(bp->pdev, PCICFG_GRC_DATA, val);\n\tpci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS,\n\t\t\t       PCICFG_VENDOR_ID_OFFSET);\n}\n\nstatic u32 bnx2x_reg_rd_ind(struct bnx2x *bp, u32 addr)\n{\n\tu32 val;\n\n\tpci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS, addr);\n\tpci_read_config_dword(bp->pdev, PCICFG_GRC_DATA, &val);\n\tpci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS,\n\t\t\t       PCICFG_VENDOR_ID_OFFSET);\n\n\treturn val;\n}\n\n#define DMAE_DP_SRC_GRC\t\t\"grc src_addr [%08x]\"\n#define DMAE_DP_SRC_PCI\t\t\"pci src_addr [%x:%08x]\"\n#define DMAE_DP_DST_GRC\t\t\"grc dst_addr [%08x]\"\n#define DMAE_DP_DST_PCI\t\t\"pci dst_addr [%x:%08x]\"\n#define DMAE_DP_DST_NONE\t\"dst_addr [none]\"\n\nstatic void bnx2x_dp_dmae(struct bnx2x *bp,\n\t\t\t  struct dmae_command *dmae, int msglvl)\n{\n\tu32 src_type = dmae->opcode & DMAE_COMMAND_SRC;\n\tint i;\n\n\tswitch (dmae->opcode & DMAE_COMMAND_DST) {\n\tcase DMAE_CMD_DST_PCI:\n\t\tif (src_type == DMAE_CMD_SRC_PCI)\n\t\t\tDP(msglvl, \"DMAE: opcode 0x%08x\\n\"\n\t\t\t   \"src [%x:%08x], len [%d*4], dst [%x:%08x]\\n\"\n\t\t\t   \"comp_addr [%x:%08x], comp_val 0x%08x\\n\",\n\t\t\t   dmae->opcode, dmae->src_addr_hi, dmae->src_addr_lo,\n\t\t\t   dmae->len, dmae->dst_addr_hi, dmae->dst_addr_lo,\n\t\t\t   dmae->comp_addr_hi, dmae->comp_addr_lo,\n\t\t\t   dmae->comp_val);\n\t\telse\n\t\t\tDP(msglvl, \"DMAE: opcode 0x%08x\\n\"\n\t\t\t   \"src [%08x], len [%d*4], dst [%x:%08x]\\n\"\n\t\t\t   \"comp_addr [%x:%08x], comp_val 0x%08x\\n\",\n\t\t\t   dmae->opcode, dmae->src_addr_lo >> 2,\n\t\t\t   dmae->len, dmae->dst_addr_hi, dmae->dst_addr_lo,\n\t\t\t   dmae->comp_addr_hi, dmae->comp_addr_lo,\n\t\t\t   dmae->comp_val);\n\t\tbreak;\n\tcase DMAE_CMD_DST_GRC:\n\t\tif (src_type == DMAE_CMD_SRC_PCI)\n\t\t\tDP(msglvl, \"DMAE: opcode 0x%08x\\n\"\n\t\t\t   \"src [%x:%08x], len [%d*4], dst_addr [%08x]\\n\"\n\t\t\t   \"comp_addr [%x:%08x], comp_val 0x%08x\\n\",\n\t\t\t   dmae->opcode, dmae->src_addr_hi, dmae->src_addr_lo,\n\t\t\t   dmae->len, dmae->dst_addr_lo >> 2,\n\t\t\t   dmae->comp_addr_hi, dmae->comp_addr_lo,\n\t\t\t   dmae->comp_val);\n\t\telse\n\t\t\tDP(msglvl, \"DMAE: opcode 0x%08x\\n\"\n\t\t\t   \"src [%08x], len [%d*4], dst [%08x]\\n\"\n\t\t\t   \"comp_addr [%x:%08x], comp_val 0x%08x\\n\",\n\t\t\t   dmae->opcode, dmae->src_addr_lo >> 2,\n\t\t\t   dmae->len, dmae->dst_addr_lo >> 2,\n\t\t\t   dmae->comp_addr_hi, dmae->comp_addr_lo,\n\t\t\t   dmae->comp_val);\n\t\tbreak;\n\tdefault:\n\t\tif (src_type == DMAE_CMD_SRC_PCI)\n\t\t\tDP(msglvl, \"DMAE: opcode 0x%08x\\n\"\n\t\t\t   \"src_addr [%x:%08x]  len [%d * 4]  dst_addr [none]\\n\"\n\t\t\t   \"comp_addr [%x:%08x]  comp_val 0x%08x\\n\",\n\t\t\t   dmae->opcode, dmae->src_addr_hi, dmae->src_addr_lo,\n\t\t\t   dmae->len, dmae->comp_addr_hi, dmae->comp_addr_lo,\n\t\t\t   dmae->comp_val);\n\t\telse\n\t\t\tDP(msglvl, \"DMAE: opcode 0x%08x\\n\"\n\t\t\t   \"src_addr [%08x]  len [%d * 4]  dst_addr [none]\\n\"\n\t\t\t   \"comp_addr [%x:%08x]  comp_val 0x%08x\\n\",\n\t\t\t   dmae->opcode, dmae->src_addr_lo >> 2,\n\t\t\t   dmae->len, dmae->comp_addr_hi, dmae->comp_addr_lo,\n\t\t\t   dmae->comp_val);\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < (sizeof(struct dmae_command)/4); i++)\n\t\tDP(msglvl, \"DMAE RAW [%02d]: 0x%08x\\n\",\n\t\t   i, *(((u32 *)dmae) + i));\n}\n\n/* copy command into DMAE command memory and set DMAE command go */\nvoid bnx2x_post_dmae(struct bnx2x *bp, struct dmae_command *dmae, int idx)\n{\n\tu32 cmd_offset;\n\tint i;\n\n\tcmd_offset = (DMAE_REG_CMD_MEM + sizeof(struct dmae_command) * idx);\n\tfor (i = 0; i < (sizeof(struct dmae_command)/4); i++) {\n\t\tREG_WR(bp, cmd_offset + i*4, *(((u32 *)dmae) + i));\n\t}\n\tREG_WR(bp, dmae_reg_go_c[idx], 1);\n}\n\nu32 bnx2x_dmae_opcode_add_comp(u32 opcode, u8 comp_type)\n{\n\treturn opcode | ((comp_type << DMAE_COMMAND_C_DST_SHIFT) |\n\t\t\t   DMAE_CMD_C_ENABLE);\n}\n\nu32 bnx2x_dmae_opcode_clr_src_reset(u32 opcode)\n{\n\treturn opcode & ~DMAE_CMD_SRC_RESET;\n}\n\nu32 bnx2x_dmae_opcode(struct bnx2x *bp, u8 src_type, u8 dst_type,\n\t\t\t     bool with_comp, u8 comp_type)\n{\n\tu32 opcode = 0;\n\n\topcode |= ((src_type << DMAE_COMMAND_SRC_SHIFT) |\n\t\t   (dst_type << DMAE_COMMAND_DST_SHIFT));\n\n\topcode |= (DMAE_CMD_SRC_RESET | DMAE_CMD_DST_RESET);\n\n\topcode |= (BP_PORT(bp) ? DMAE_CMD_PORT_1 : DMAE_CMD_PORT_0);\n\topcode |= ((BP_VN(bp) << DMAE_CMD_E1HVN_SHIFT) |\n\t\t   (BP_VN(bp) << DMAE_COMMAND_DST_VN_SHIFT));\n\topcode |= (DMAE_COM_SET_ERR << DMAE_COMMAND_ERR_POLICY_SHIFT);\n\n#ifdef __BIG_ENDIAN\n\topcode |= DMAE_CMD_ENDIANITY_B_DW_SWAP;\n#else\n\topcode |= DMAE_CMD_ENDIANITY_DW_SWAP;\n#endif\n\tif (with_comp)\n\t\topcode = bnx2x_dmae_opcode_add_comp(opcode, comp_type);\n\treturn opcode;\n}\n\nvoid bnx2x_prep_dmae_with_comp(struct bnx2x *bp,\n\t\t\t\t      struct dmae_command *dmae,\n\t\t\t\t      u8 src_type, u8 dst_type)\n{\n\tmemset(dmae, 0, sizeof(struct dmae_command));\n\n\t/* set the opcode */\n\tdmae->opcode = bnx2x_dmae_opcode(bp, src_type, dst_type,\n\t\t\t\t\t true, DMAE_COMP_PCI);\n\n\t/* fill in the completion parameters */\n\tdmae->comp_addr_lo = U64_LO(bnx2x_sp_mapping(bp, wb_comp));\n\tdmae->comp_addr_hi = U64_HI(bnx2x_sp_mapping(bp, wb_comp));\n\tdmae->comp_val = DMAE_COMP_VAL;\n}\n\n/* issue a dmae command over the init-channel and wait for completion */\nint bnx2x_issue_dmae_with_comp(struct bnx2x *bp, struct dmae_command *dmae,\n\t\t\t       u32 *comp)\n{\n\tint cnt = CHIP_REV_IS_SLOW(bp) ? (400000) : 4000;\n\tint rc = 0;\n\n\tbnx2x_dp_dmae(bp, dmae, BNX2X_MSG_DMAE);\n\n\t/* Lock the dmae channel. Disable BHs to prevent a dead-lock\n\t * as long as this code is called both from syscall context and\n\t * from ndo_set_rx_mode() flow that may be called from BH.\n\t */\n\n\tspin_lock_bh(&bp->dmae_lock);\n\n\t/* reset completion */\n\t*comp = 0;\n\n\t/* post the command on the channel used for initializations */\n\tbnx2x_post_dmae(bp, dmae, INIT_DMAE_C(bp));\n\n\t/* wait for completion */\n\tudelay(5);\n\twhile ((*comp & ~DMAE_PCI_ERR_FLAG) != DMAE_COMP_VAL) {\n\n\t\tif (!cnt ||\n\t\t    (bp->recovery_state != BNX2X_RECOVERY_DONE &&\n\t\t     bp->recovery_state != BNX2X_RECOVERY_NIC_LOADING)) {\n\t\t\tBNX2X_ERR(\"DMAE timeout!\\n\");\n\t\t\trc = DMAE_TIMEOUT;\n\t\t\tgoto unlock;\n\t\t}\n\t\tcnt--;\n\t\tudelay(50);\n\t}\n\tif (*comp & DMAE_PCI_ERR_FLAG) {\n\t\tBNX2X_ERR(\"DMAE PCI error!\\n\");\n\t\trc = DMAE_PCI_ERROR;\n\t}\n\nunlock:\n\n\tspin_unlock_bh(&bp->dmae_lock);\n\n\treturn rc;\n}\n\nvoid bnx2x_write_dmae(struct bnx2x *bp, dma_addr_t dma_addr, u32 dst_addr,\n\t\t      u32 len32)\n{\n\tint rc;\n\tstruct dmae_command dmae;\n\n\tif (!bp->dmae_ready) {\n\t\tu32 *data = bnx2x_sp(bp, wb_data[0]);\n\n\t\tif (CHIP_IS_E1(bp))\n\t\t\tbnx2x_init_ind_wr(bp, dst_addr, data, len32);\n\t\telse\n\t\t\tbnx2x_init_str_wr(bp, dst_addr, data, len32);\n\t\treturn;\n\t}\n\n\t/* set opcode and fixed command fields */\n\tbnx2x_prep_dmae_with_comp(bp, &dmae, DMAE_SRC_PCI, DMAE_DST_GRC);\n\n\t/* fill in addresses and len */\n\tdmae.src_addr_lo = U64_LO(dma_addr);\n\tdmae.src_addr_hi = U64_HI(dma_addr);\n\tdmae.dst_addr_lo = dst_addr >> 2;\n\tdmae.dst_addr_hi = 0;\n\tdmae.len = len32;\n\n\t/* issue the command and wait for completion */\n\trc = bnx2x_issue_dmae_with_comp(bp, &dmae, bnx2x_sp(bp, wb_comp));\n\tif (rc) {\n\t\tBNX2X_ERR(\"DMAE returned failure %d\\n\", rc);\n#ifdef BNX2X_STOP_ON_ERROR\n\t\tbnx2x_panic();\n#endif\n\t}\n}\n\nvoid bnx2x_read_dmae(struct bnx2x *bp, u32 src_addr, u32 len32)\n{\n\tint rc;\n\tstruct dmae_command dmae;\n\n\tif (!bp->dmae_ready) {\n\t\tu32 *data = bnx2x_sp(bp, wb_data[0]);\n\t\tint i;\n\n\t\tif (CHIP_IS_E1(bp))\n\t\t\tfor (i = 0; i < len32; i++)\n\t\t\t\tdata[i] = bnx2x_reg_rd_ind(bp, src_addr + i*4);\n\t\telse\n\t\t\tfor (i = 0; i < len32; i++)\n\t\t\t\tdata[i] = REG_RD(bp, src_addr + i*4);\n\n\t\treturn;\n\t}\n\n\t/* set opcode and fixed command fields */\n\tbnx2x_prep_dmae_with_comp(bp, &dmae, DMAE_SRC_GRC, DMAE_DST_PCI);\n\n\t/* fill in addresses and len */\n\tdmae.src_addr_lo = src_addr >> 2;\n\tdmae.src_addr_hi = 0;\n\tdmae.dst_addr_lo = U64_LO(bnx2x_sp_mapping(bp, wb_data));\n\tdmae.dst_addr_hi = U64_HI(bnx2x_sp_mapping(bp, wb_data));\n\tdmae.len = len32;\n\n\t/* issue the command and wait for completion */\n\trc = bnx2x_issue_dmae_with_comp(bp, &dmae, bnx2x_sp(bp, wb_comp));\n\tif (rc) {\n\t\tBNX2X_ERR(\"DMAE returned failure %d\\n\", rc);\n#ifdef BNX2X_STOP_ON_ERROR\n\t\tbnx2x_panic();\n#endif\n\t}\n}\n\nstatic void bnx2x_write_dmae_phys_len(struct bnx2x *bp, dma_addr_t phys_addr,\n\t\t\t\t      u32 addr, u32 len)\n{\n\tint dmae_wr_max = DMAE_LEN32_WR_MAX(bp);\n\tint offset = 0;\n\n\twhile (len > dmae_wr_max) {\n\t\tbnx2x_write_dmae(bp, phys_addr + offset,\n\t\t\t\t addr + offset, dmae_wr_max);\n\t\toffset += dmae_wr_max * 4;\n\t\tlen -= dmae_wr_max;\n\t}\n\n\tbnx2x_write_dmae(bp, phys_addr + offset, addr + offset, len);\n}\n\nenum storms {\n\t   XSTORM,\n\t   TSTORM,\n\t   CSTORM,\n\t   USTORM,\n\t   MAX_STORMS\n};\n\n#define STORMS_NUM 4\n#define REGS_IN_ENTRY 4\n\nstatic inline int bnx2x_get_assert_list_entry(struct bnx2x *bp,\n\t\t\t\t\t      enum storms storm,\n\t\t\t\t\t      int entry)\n{\n\tswitch (storm) {\n\tcase XSTORM:\n\t\treturn XSTORM_ASSERT_LIST_OFFSET(entry);\n\tcase TSTORM:\n\t\treturn TSTORM_ASSERT_LIST_OFFSET(entry);\n\tcase CSTORM:\n\t\treturn CSTORM_ASSERT_LIST_OFFSET(entry);\n\tcase USTORM:\n\t\treturn USTORM_ASSERT_LIST_OFFSET(entry);\n\tcase MAX_STORMS:\n\tdefault:\n\t\tBNX2X_ERR(\"unknown storm\\n\");\n\t}\n\treturn -EINVAL;\n}\n\nstatic int bnx2x_mc_assert(struct bnx2x *bp)\n{\n\tchar last_idx;\n\tint i, j, rc = 0;\n\tenum storms storm;\n\tu32 regs[REGS_IN_ENTRY];\n\tu32 bar_storm_intmem[STORMS_NUM] = {\n\t\tBAR_XSTRORM_INTMEM,\n\t\tBAR_TSTRORM_INTMEM,\n\t\tBAR_CSTRORM_INTMEM,\n\t\tBAR_USTRORM_INTMEM\n\t};\n\tu32 storm_assert_list_index[STORMS_NUM] = {\n\t\tXSTORM_ASSERT_LIST_INDEX_OFFSET,\n\t\tTSTORM_ASSERT_LIST_INDEX_OFFSET,\n\t\tCSTORM_ASSERT_LIST_INDEX_OFFSET,\n\t\tUSTORM_ASSERT_LIST_INDEX_OFFSET\n\t};\n\tchar *storms_string[STORMS_NUM] = {\n\t\t\"XSTORM\",\n\t\t\"TSTORM\",\n\t\t\"CSTORM\",\n\t\t\"USTORM\"\n\t};\n\n\tfor (storm = XSTORM; storm < MAX_STORMS; storm++) {\n\t\tlast_idx = REG_RD8(bp, bar_storm_intmem[storm] +\n\t\t\t\t   storm_assert_list_index[storm]);\n\t\tif (last_idx)\n\t\t\tBNX2X_ERR(\"%s_ASSERT_LIST_INDEX 0x%x\\n\",\n\t\t\t\t  storms_string[storm], last_idx);\n\n\t\t/* print the asserts */\n\t\tfor (i = 0; i < STROM_ASSERT_ARRAY_SIZE; i++) {\n\t\t\t/* read a single assert entry */\n\t\t\tfor (j = 0; j < REGS_IN_ENTRY; j++)\n\t\t\t\tregs[j] = REG_RD(bp, bar_storm_intmem[storm] +\n\t\t\t\t\t  bnx2x_get_assert_list_entry(bp,\n\t\t\t\t\t\t\t\t      storm,\n\t\t\t\t\t\t\t\t      i) +\n\t\t\t\t\t  sizeof(u32) * j);\n\n\t\t\t/* log entry if it contains a valid assert */\n\t\t\tif (regs[0] != COMMON_ASM_INVALID_ASSERT_OPCODE) {\n\t\t\t\tBNX2X_ERR(\"%s_ASSERT_INDEX 0x%x = 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t\t\t\t  storms_string[storm], i, regs[3],\n\t\t\t\t\t  regs[2], regs[1], regs[0]);\n\t\t\t\trc++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tBNX2X_ERR(\"Chip Revision: %s, FW Version: %d_%d_%d\\n\",\n\t\t  CHIP_IS_E1(bp) ? \"everest1\" :\n\t\t  CHIP_IS_E1H(bp) ? \"everest1h\" :\n\t\t  CHIP_IS_E2(bp) ? \"everest2\" : \"everest3\",\n\t\t  BCM_5710_FW_MAJOR_VERSION,\n\t\t  BCM_5710_FW_MINOR_VERSION,\n\t\t  BCM_5710_FW_REVISION_VERSION);\n\n\treturn rc;\n}\n\n#define MCPR_TRACE_BUFFER_SIZE\t(0x800)\n#define SCRATCH_BUFFER_SIZE(bp)\t\\\n\t(CHIP_IS_E1(bp) ? 0x10000 : (CHIP_IS_E1H(bp) ? 0x20000 : 0x28000))\n\nvoid bnx2x_fw_dump_lvl(struct bnx2x *bp, const char *lvl)\n{\n\tu32 addr, val;\n\tu32 mark, offset;\n\t__be32 data[9];\n\tint word;\n\tu32 trace_shmem_base;\n\tif (BP_NOMCP(bp)) {\n\t\tBNX2X_ERR(\"NO MCP - can not dump\\n\");\n\t\treturn;\n\t}\n\tnetdev_printk(lvl, bp->dev, \"bc %d.%d.%d\\n\",\n\t\t(bp->common.bc_ver & 0xff0000) >> 16,\n\t\t(bp->common.bc_ver & 0xff00) >> 8,\n\t\t(bp->common.bc_ver & 0xff));\n\n\tif (pci_channel_offline(bp->pdev)) {\n\t\tBNX2X_ERR(\"Cannot dump MCP info while in PCI error\\n\");\n\t\treturn;\n\t}\n\n\tval = REG_RD(bp, MCP_REG_MCPR_CPU_PROGRAM_COUNTER);\n\tif (val == REG_RD(bp, MCP_REG_MCPR_CPU_PROGRAM_COUNTER))\n\t\tBNX2X_ERR(\"%s\" \"MCP PC at 0x%x\\n\", lvl, val);\n\n\tif (BP_PATH(bp) == 0)\n\t\ttrace_shmem_base = bp->common.shmem_base;\n\telse\n\t\ttrace_shmem_base = SHMEM2_RD(bp, other_shmem_base_addr);\n\n\t/* sanity */\n\tif (trace_shmem_base < MCPR_SCRATCH_BASE(bp) + MCPR_TRACE_BUFFER_SIZE ||\n\t    trace_shmem_base >= MCPR_SCRATCH_BASE(bp) +\n\t\t\t\tSCRATCH_BUFFER_SIZE(bp)) {\n\t\tBNX2X_ERR(\"Unable to dump trace buffer (mark %x)\\n\",\n\t\t\t  trace_shmem_base);\n\t\treturn;\n\t}\n\n\taddr = trace_shmem_base - MCPR_TRACE_BUFFER_SIZE;\n\n\t/* validate TRCB signature */\n\tmark = REG_RD(bp, addr);\n\tif (mark != MFW_TRACE_SIGNATURE) {\n\t\tBNX2X_ERR(\"Trace buffer signature is missing.\");\n\t\treturn ;\n\t}\n\n\t/* read cyclic buffer pointer */\n\taddr += 4;\n\tmark = REG_RD(bp, addr);\n\tmark = MCPR_SCRATCH_BASE(bp) + ((mark + 0x3) & ~0x3) - 0x08000000;\n\tif (mark >= trace_shmem_base || mark < addr + 4) {\n\t\tBNX2X_ERR(\"Mark doesn't fall inside Trace Buffer\\n\");\n\t\treturn;\n\t}\n\tprintk(\"%s\" \"begin fw dump (mark 0x%x)\\n\", lvl, mark);\n\n\tprintk(\"%s\", lvl);\n\n\t/* dump buffer after the mark */\n\tfor (offset = mark; offset < trace_shmem_base; offset += 0x8*4) {\n\t\tfor (word = 0; word < 8; word++)\n\t\t\tdata[word] = htonl(REG_RD(bp, offset + 4*word));\n\t\tdata[8] = 0x0;\n\t\tpr_cont(\"%s\", (char *)data);\n\t}\n\n\t/* dump buffer before the mark */\n\tfor (offset = addr + 4; offset <= mark; offset += 0x8*4) {\n\t\tfor (word = 0; word < 8; word++)\n\t\t\tdata[word] = htonl(REG_RD(bp, offset + 4*word));\n\t\tdata[8] = 0x0;\n\t\tpr_cont(\"%s\", (char *)data);\n\t}\n\tprintk(\"%s\" \"end of fw dump\\n\", lvl);\n}\n\nstatic void bnx2x_fw_dump(struct bnx2x *bp)\n{\n\tbnx2x_fw_dump_lvl(bp, KERN_ERR);\n}\n\nstatic void bnx2x_hc_int_disable(struct bnx2x *bp)\n{\n\tint port = BP_PORT(bp);\n\tu32 addr = port ? HC_REG_CONFIG_1 : HC_REG_CONFIG_0;\n\tu32 val = REG_RD(bp, addr);\n\n\t/* in E1 we must use only PCI configuration space to disable\n\t * MSI/MSIX capability\n\t * It's forbidden to disable IGU_PF_CONF_MSI_MSIX_EN in HC block\n\t */\n\tif (CHIP_IS_E1(bp)) {\n\t\t/* Since IGU_PF_CONF_MSI_MSIX_EN still always on\n\t\t * Use mask register to prevent from HC sending interrupts\n\t\t * after we exit the function\n\t\t */\n\t\tREG_WR(bp, HC_REG_INT_MASK + port*4, 0);\n\n\t\tval &= ~(HC_CONFIG_0_REG_SINGLE_ISR_EN_0 |\n\t\t\t HC_CONFIG_0_REG_INT_LINE_EN_0 |\n\t\t\t HC_CONFIG_0_REG_ATTN_BIT_EN_0);\n\t} else\n\t\tval &= ~(HC_CONFIG_0_REG_SINGLE_ISR_EN_0 |\n\t\t\t HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0 |\n\t\t\t HC_CONFIG_0_REG_INT_LINE_EN_0 |\n\t\t\t HC_CONFIG_0_REG_ATTN_BIT_EN_0);\n\n\tDP(NETIF_MSG_IFDOWN,\n\t   \"write %x to HC %d (addr 0x%x)\\n\",\n\t   val, port, addr);\n\n\tREG_WR(bp, addr, val);\n\tif (REG_RD(bp, addr) != val)\n\t\tBNX2X_ERR(\"BUG! Proper val not read from IGU!\\n\");\n}\n\nstatic void bnx2x_igu_int_disable(struct bnx2x *bp)\n{\n\tu32 val = REG_RD(bp, IGU_REG_PF_CONFIGURATION);\n\n\tval &= ~(IGU_PF_CONF_MSI_MSIX_EN |\n\t\t IGU_PF_CONF_INT_LINE_EN |\n\t\t IGU_PF_CONF_ATTN_BIT_EN);\n\n\tDP(NETIF_MSG_IFDOWN, \"write %x to IGU\\n\", val);\n\n\tREG_WR(bp, IGU_REG_PF_CONFIGURATION, val);\n\tif (REG_RD(bp, IGU_REG_PF_CONFIGURATION) != val)\n\t\tBNX2X_ERR(\"BUG! Proper val not read from IGU!\\n\");\n}\n\nstatic void bnx2x_int_disable(struct bnx2x *bp)\n{\n\tif (bp->common.int_block == INT_BLOCK_HC)\n\t\tbnx2x_hc_int_disable(bp);\n\telse\n\t\tbnx2x_igu_int_disable(bp);\n}\n\nvoid bnx2x_panic_dump(struct bnx2x *bp, bool disable_int)\n{\n\tint i;\n\tu16 j;\n\tstruct hc_sp_status_block_data sp_sb_data;\n\tint func = BP_FUNC(bp);\n#ifdef BNX2X_STOP_ON_ERROR\n\tu16 start = 0, end = 0;\n\tu8 cos;\n#endif\n\tif (IS_PF(bp) && disable_int)\n\t\tbnx2x_int_disable(bp);\n\n\tbp->stats_state = STATS_STATE_DISABLED;\n\tbp->eth_stats.unrecoverable_error++;\n\tDP(BNX2X_MSG_STATS, \"stats_state - DISABLED\\n\");\n\n\tBNX2X_ERR(\"begin crash dump -----------------\\n\");\n\n\t/* Indices */\n\t/* Common */\n\tif (IS_PF(bp)) {\n\t\tstruct host_sp_status_block *def_sb = bp->def_status_blk;\n\t\tint data_size, cstorm_offset;\n\n\t\tBNX2X_ERR(\"def_idx(0x%x)  def_att_idx(0x%x)  attn_state(0x%x)  spq_prod_idx(0x%x) next_stats_cnt(0x%x)\\n\",\n\t\t\t  bp->def_idx, bp->def_att_idx, bp->attn_state,\n\t\t\t  bp->spq_prod_idx, bp->stats_counter);\n\t\tBNX2X_ERR(\"DSB: attn bits(0x%x)  ack(0x%x)  id(0x%x)  idx(0x%x)\\n\",\n\t\t\t  def_sb->atten_status_block.attn_bits,\n\t\t\t  def_sb->atten_status_block.attn_bits_ack,\n\t\t\t  def_sb->atten_status_block.status_block_id,\n\t\t\t  def_sb->atten_status_block.attn_bits_index);\n\t\tBNX2X_ERR(\"     def (\");\n\t\tfor (i = 0; i < HC_SP_SB_MAX_INDICES; i++)\n\t\t\tpr_cont(\"0x%x%s\",\n\t\t\t\tdef_sb->sp_sb.index_values[i],\n\t\t\t\t(i == HC_SP_SB_MAX_INDICES - 1) ? \")  \" : \" \");\n\n\t\tdata_size = sizeof(struct hc_sp_status_block_data) /\n\t\t\t    sizeof(u32);\n\t\tcstorm_offset = CSTORM_SP_STATUS_BLOCK_DATA_OFFSET(func);\n\t\tfor (i = 0; i < data_size; i++)\n\t\t\t*((u32 *)&sp_sb_data + i) =\n\t\t\t\tREG_RD(bp, BAR_CSTRORM_INTMEM + cstorm_offset +\n\t\t\t\t\t   i * sizeof(u32));\n\n\t\tpr_cont(\"igu_sb_id(0x%x)  igu_seg_id(0x%x) pf_id(0x%x)  vnic_id(0x%x)  vf_id(0x%x)  vf_valid (0x%x) state(0x%x)\\n\",\n\t\t\tsp_sb_data.igu_sb_id,\n\t\t\tsp_sb_data.igu_seg_id,\n\t\t\tsp_sb_data.p_func.pf_id,\n\t\t\tsp_sb_data.p_func.vnic_id,\n\t\t\tsp_sb_data.p_func.vf_id,\n\t\t\tsp_sb_data.p_func.vf_valid,\n\t\t\tsp_sb_data.state);\n\t}\n\n\tfor_each_eth_queue(bp, i) {\n\t\tstruct bnx2x_fastpath *fp = &bp->fp[i];\n\t\tint loop;\n\t\tstruct hc_status_block_data_e2 sb_data_e2;\n\t\tstruct hc_status_block_data_e1x sb_data_e1x;\n\t\tstruct hc_status_block_sm  *hc_sm_p =\n\t\t\tCHIP_IS_E1x(bp) ?\n\t\t\tsb_data_e1x.common.state_machine :\n\t\t\tsb_data_e2.common.state_machine;\n\t\tstruct hc_index_data *hc_index_p =\n\t\t\tCHIP_IS_E1x(bp) ?\n\t\t\tsb_data_e1x.index_data :\n\t\t\tsb_data_e2.index_data;\n\t\tu8 data_size, cos;\n\t\tu32 *sb_data_p;\n\t\tstruct bnx2x_fp_txdata txdata;\n\n\t\tif (!bp->fp)\n\t\t\tbreak;\n\n\t\tif (!fp->rx_cons_sb)\n\t\t\tcontinue;\n\n\t\t/* Rx */\n\t\tBNX2X_ERR(\"fp%d: rx_bd_prod(0x%x)  rx_bd_cons(0x%x)  rx_comp_prod(0x%x)  rx_comp_cons(0x%x)  *rx_cons_sb(0x%x)\\n\",\n\t\t\t  i, fp->rx_bd_prod, fp->rx_bd_cons,\n\t\t\t  fp->rx_comp_prod,\n\t\t\t  fp->rx_comp_cons, le16_to_cpu(*fp->rx_cons_sb));\n\t\tBNX2X_ERR(\"     rx_sge_prod(0x%x)  last_max_sge(0x%x)  fp_hc_idx(0x%x)\\n\",\n\t\t\t  fp->rx_sge_prod, fp->last_max_sge,\n\t\t\t  le16_to_cpu(fp->fp_hc_idx));\n\n\t\t/* Tx */\n\t\tfor_each_cos_in_tx_queue(fp, cos)\n\t\t{\n\t\t\tif (!fp->txdata_ptr[cos])\n\t\t\t\tbreak;\n\n\t\t\ttxdata = *fp->txdata_ptr[cos];\n\n\t\t\tif (!txdata.tx_cons_sb)\n\t\t\t\tcontinue;\n\n\t\t\tBNX2X_ERR(\"fp%d: tx_pkt_prod(0x%x)  tx_pkt_cons(0x%x)  tx_bd_prod(0x%x)  tx_bd_cons(0x%x)  *tx_cons_sb(0x%x)\\n\",\n\t\t\t\t  i, txdata.tx_pkt_prod,\n\t\t\t\t  txdata.tx_pkt_cons, txdata.tx_bd_prod,\n\t\t\t\t  txdata.tx_bd_cons,\n\t\t\t\t  le16_to_cpu(*txdata.tx_cons_sb));\n\t\t}\n\n\t\tloop = CHIP_IS_E1x(bp) ?\n\t\t\tHC_SB_MAX_INDICES_E1X : HC_SB_MAX_INDICES_E2;\n\n\t\t/* host sb data */\n\n\t\tif (IS_FCOE_FP(fp))\n\t\t\tcontinue;\n\n\t\tBNX2X_ERR(\"     run indexes (\");\n\t\tfor (j = 0; j < HC_SB_MAX_SM; j++)\n\t\t\tpr_cont(\"0x%x%s\",\n\t\t\t       fp->sb_running_index[j],\n\t\t\t       (j == HC_SB_MAX_SM - 1) ? \")\" : \" \");\n\n\t\tBNX2X_ERR(\"     indexes (\");\n\t\tfor (j = 0; j < loop; j++)\n\t\t\tpr_cont(\"0x%x%s\",\n\t\t\t       fp->sb_index_values[j],\n\t\t\t       (j == loop - 1) ? \")\" : \" \");\n\n\t\t/* VF cannot access FW refelection for status block */\n\t\tif (IS_VF(bp))\n\t\t\tcontinue;\n\n\t\t/* fw sb data */\n\t\tdata_size = CHIP_IS_E1x(bp) ?\n\t\t\tsizeof(struct hc_status_block_data_e1x) :\n\t\t\tsizeof(struct hc_status_block_data_e2);\n\t\tdata_size /= sizeof(u32);\n\t\tsb_data_p = CHIP_IS_E1x(bp) ?\n\t\t\t(u32 *)&sb_data_e1x :\n\t\t\t(u32 *)&sb_data_e2;\n\t\t/* copy sb data in here */\n\t\tfor (j = 0; j < data_size; j++)\n\t\t\t*(sb_data_p + j) = REG_RD(bp, BAR_CSTRORM_INTMEM +\n\t\t\t\tCSTORM_STATUS_BLOCK_DATA_OFFSET(fp->fw_sb_id) +\n\t\t\t\tj * sizeof(u32));\n\n\t\tif (!CHIP_IS_E1x(bp)) {\n\t\t\tpr_cont(\"pf_id(0x%x)  vf_id(0x%x)  vf_valid(0x%x) vnic_id(0x%x)  same_igu_sb_1b(0x%x) state(0x%x)\\n\",\n\t\t\t\tsb_data_e2.common.p_func.pf_id,\n\t\t\t\tsb_data_e2.common.p_func.vf_id,\n\t\t\t\tsb_data_e2.common.p_func.vf_valid,\n\t\t\t\tsb_data_e2.common.p_func.vnic_id,\n\t\t\t\tsb_data_e2.common.same_igu_sb_1b,\n\t\t\t\tsb_data_e2.common.state);\n\t\t} else {\n\t\t\tpr_cont(\"pf_id(0x%x)  vf_id(0x%x)  vf_valid(0x%x) vnic_id(0x%x)  same_igu_sb_1b(0x%x) state(0x%x)\\n\",\n\t\t\t\tsb_data_e1x.common.p_func.pf_id,\n\t\t\t\tsb_data_e1x.common.p_func.vf_id,\n\t\t\t\tsb_data_e1x.common.p_func.vf_valid,\n\t\t\t\tsb_data_e1x.common.p_func.vnic_id,\n\t\t\t\tsb_data_e1x.common.same_igu_sb_1b,\n\t\t\t\tsb_data_e1x.common.state);\n\t\t}\n\n\t\t/* SB_SMs data */\n\t\tfor (j = 0; j < HC_SB_MAX_SM; j++) {\n\t\t\tpr_cont(\"SM[%d] __flags (0x%x) igu_sb_id (0x%x)  igu_seg_id(0x%x) time_to_expire (0x%x) timer_value(0x%x)\\n\",\n\t\t\t\tj, hc_sm_p[j].__flags,\n\t\t\t\thc_sm_p[j].igu_sb_id,\n\t\t\t\thc_sm_p[j].igu_seg_id,\n\t\t\t\thc_sm_p[j].time_to_expire,\n\t\t\t\thc_sm_p[j].timer_value);\n\t\t}\n\n\t\t/* Indices data */\n\t\tfor (j = 0; j < loop; j++) {\n\t\t\tpr_cont(\"INDEX[%d] flags (0x%x) timeout (0x%x)\\n\", j,\n\t\t\t       hc_index_p[j].flags,\n\t\t\t       hc_index_p[j].timeout);\n\t\t}\n\t}\n\n#ifdef BNX2X_STOP_ON_ERROR\n\tif (IS_PF(bp)) {\n\t\t/* event queue */\n\t\tBNX2X_ERR(\"eq cons %x prod %x\\n\", bp->eq_cons, bp->eq_prod);\n\t\tfor (i = 0; i < NUM_EQ_DESC; i++) {\n\t\t\tu32 *data = (u32 *)&bp->eq_ring[i].message.data;\n\n\t\t\tBNX2X_ERR(\"event queue [%d]: header: opcode %d, error %d\\n\",\n\t\t\t\t  i, bp->eq_ring[i].message.opcode,\n\t\t\t\t  bp->eq_ring[i].message.error);\n\t\t\tBNX2X_ERR(\"data: %x %x %x\\n\",\n\t\t\t\t  data[0], data[1], data[2]);\n\t\t}\n\t}\n\n\t/* Rings */\n\t/* Rx */\n\tfor_each_valid_rx_queue(bp, i) {\n\t\tstruct bnx2x_fastpath *fp = &bp->fp[i];\n\n\t\tif (!bp->fp)\n\t\t\tbreak;\n\n\t\tif (!fp->rx_cons_sb)\n\t\t\tcontinue;\n\n\t\tstart = RX_BD(le16_to_cpu(*fp->rx_cons_sb) - 10);\n\t\tend = RX_BD(le16_to_cpu(*fp->rx_cons_sb) + 503);\n\t\tfor (j = start; j != end; j = RX_BD(j + 1)) {\n\t\t\tu32 *rx_bd = (u32 *)&fp->rx_desc_ring[j];\n\t\t\tstruct sw_rx_bd *sw_bd = &fp->rx_buf_ring[j];\n\n\t\t\tBNX2X_ERR(\"fp%d: rx_bd[%x]=[%x:%x]  sw_bd=[%p]\\n\",\n\t\t\t\t  i, j, rx_bd[1], rx_bd[0], sw_bd->data);\n\t\t}\n\n\t\tstart = RX_SGE(fp->rx_sge_prod);\n\t\tend = RX_SGE(fp->last_max_sge);\n\t\tfor (j = start; j != end; j = RX_SGE(j + 1)) {\n\t\t\tu32 *rx_sge = (u32 *)&fp->rx_sge_ring[j];\n\t\t\tstruct sw_rx_page *sw_page = &fp->rx_page_ring[j];\n\n\t\t\tBNX2X_ERR(\"fp%d: rx_sge[%x]=[%x:%x]  sw_page=[%p]\\n\",\n\t\t\t\t  i, j, rx_sge[1], rx_sge[0], sw_page->page);\n\t\t}\n\n\t\tstart = RCQ_BD(fp->rx_comp_cons - 10);\n\t\tend = RCQ_BD(fp->rx_comp_cons + 503);\n\t\tfor (j = start; j != end; j = RCQ_BD(j + 1)) {\n\t\t\tu32 *cqe = (u32 *)&fp->rx_comp_ring[j];\n\n\t\t\tBNX2X_ERR(\"fp%d: cqe[%x]=[%x:%x:%x:%x]\\n\",\n\t\t\t\t  i, j, cqe[0], cqe[1], cqe[2], cqe[3]);\n\t\t}\n\t}\n\n\t/* Tx */\n\tfor_each_valid_tx_queue(bp, i) {\n\t\tstruct bnx2x_fastpath *fp = &bp->fp[i];\n\n\t\tif (!bp->fp)\n\t\t\tbreak;\n\n\t\tfor_each_cos_in_tx_queue(fp, cos) {\n\t\t\tstruct bnx2x_fp_txdata *txdata = fp->txdata_ptr[cos];\n\n\t\t\tif (!fp->txdata_ptr[cos])\n\t\t\t\tbreak;\n\n\t\t\tif (!txdata->tx_cons_sb)\n\t\t\t\tcontinue;\n\n\t\t\tstart = TX_BD(le16_to_cpu(*txdata->tx_cons_sb) - 10);\n\t\t\tend = TX_BD(le16_to_cpu(*txdata->tx_cons_sb) + 245);\n\t\t\tfor (j = start; j != end; j = TX_BD(j + 1)) {\n\t\t\t\tstruct sw_tx_bd *sw_bd =\n\t\t\t\t\t&txdata->tx_buf_ring[j];\n\n\t\t\t\tBNX2X_ERR(\"fp%d: txdata %d, packet[%x]=[%p,%x]\\n\",\n\t\t\t\t\t  i, cos, j, sw_bd->skb,\n\t\t\t\t\t  sw_bd->first_bd);\n\t\t\t}\n\n\t\t\tstart = TX_BD(txdata->tx_bd_cons - 10);\n\t\t\tend = TX_BD(txdata->tx_bd_cons + 254);\n\t\t\tfor (j = start; j != end; j = TX_BD(j + 1)) {\n\t\t\t\tu32 *tx_bd = (u32 *)&txdata->tx_desc_ring[j];\n\n\t\t\t\tBNX2X_ERR(\"fp%d: txdata %d, tx_bd[%x]=[%x:%x:%x:%x]\\n\",\n\t\t\t\t\t  i, cos, j, tx_bd[0], tx_bd[1],\n\t\t\t\t\t  tx_bd[2], tx_bd[3]);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tif (IS_PF(bp)) {\n\t\tint tmp_msg_en = bp->msg_enable;\n\n\t\tbnx2x_fw_dump(bp);\n\t\tbp->msg_enable |= NETIF_MSG_HW;\n\t\tBNX2X_ERR(\"Idle check (1st round) ----------\\n\");\n\t\tbnx2x_idle_chk(bp);\n\t\tBNX2X_ERR(\"Idle check (2nd round) ----------\\n\");\n\t\tbnx2x_idle_chk(bp);\n\t\tbp->msg_enable = tmp_msg_en;\n\t\tbnx2x_mc_assert(bp);\n\t}\n\n\tBNX2X_ERR(\"end crash dump -----------------\\n\");\n}\n\n/*\n * FLR Support for E2\n *\n * bnx2x_pf_flr_clnup() is called during nic_load in the per function HW\n * initialization.\n */\n#define FLR_WAIT_USEC\t\t10000\t/* 10 milliseconds */\n#define FLR_WAIT_INTERVAL\t50\t/* usec */\n#define\tFLR_POLL_CNT\t\t(FLR_WAIT_USEC/FLR_WAIT_INTERVAL) /* 200 */\n\nstruct pbf_pN_buf_regs {\n\tint pN;\n\tu32 init_crd;\n\tu32 crd;\n\tu32 crd_freed;\n};\n\nstruct pbf_pN_cmd_regs {\n\tint pN;\n\tu32 lines_occup;\n\tu32 lines_freed;\n};\n\nstatic void bnx2x_pbf_pN_buf_flushed(struct bnx2x *bp,\n\t\t\t\t     struct pbf_pN_buf_regs *regs,\n\t\t\t\t     u32 poll_count)\n{\n\tu32 init_crd, crd, crd_start, crd_freed, crd_freed_start;\n\tu32 cur_cnt = poll_count;\n\n\tcrd_freed = crd_freed_start = REG_RD(bp, regs->crd_freed);\n\tcrd = crd_start = REG_RD(bp, regs->crd);\n\tinit_crd = REG_RD(bp, regs->init_crd);\n\n\tDP(BNX2X_MSG_SP, \"INIT CREDIT[%d] : %x\\n\", regs->pN, init_crd);\n\tDP(BNX2X_MSG_SP, \"CREDIT[%d]      : s:%x\\n\", regs->pN, crd);\n\tDP(BNX2X_MSG_SP, \"CREDIT_FREED[%d]: s:%x\\n\", regs->pN, crd_freed);\n\n\twhile ((crd != init_crd) && ((u32)SUB_S32(crd_freed, crd_freed_start) <\n\t       (init_crd - crd_start))) {\n\t\tif (cur_cnt--) {\n\t\t\tudelay(FLR_WAIT_INTERVAL);\n\t\t\tcrd = REG_RD(bp, regs->crd);\n\t\t\tcrd_freed = REG_RD(bp, regs->crd_freed);\n\t\t} else {\n\t\t\tDP(BNX2X_MSG_SP, \"PBF tx buffer[%d] timed out\\n\",\n\t\t\t   regs->pN);\n\t\t\tDP(BNX2X_MSG_SP, \"CREDIT[%d]      : c:%x\\n\",\n\t\t\t   regs->pN, crd);\n\t\t\tDP(BNX2X_MSG_SP, \"CREDIT_FREED[%d]: c:%x\\n\",\n\t\t\t   regs->pN, crd_freed);\n\t\t\tbreak;\n\t\t}\n\t}\n\tDP(BNX2X_MSG_SP, \"Waited %d*%d usec for PBF tx buffer[%d]\\n\",\n\t   poll_count-cur_cnt, FLR_WAIT_INTERVAL, regs->pN);\n}\n\nstatic void bnx2x_pbf_pN_cmd_flushed(struct bnx2x *bp,\n\t\t\t\t     struct pbf_pN_cmd_regs *regs,\n\t\t\t\t     u32 poll_count)\n{\n\tu32 occup, to_free, freed, freed_start;\n\tu32 cur_cnt = poll_count;\n\n\toccup = to_free = REG_RD(bp, regs->lines_occup);\n\tfreed = freed_start = REG_RD(bp, regs->lines_freed);\n\n\tDP(BNX2X_MSG_SP, \"OCCUPANCY[%d]   : s:%x\\n\", regs->pN, occup);\n\tDP(BNX2X_MSG_SP, \"LINES_FREED[%d] : s:%x\\n\", regs->pN, freed);\n\n\twhile (occup && ((u32)SUB_S32(freed, freed_start) < to_free)) {\n\t\tif (cur_cnt--) {\n\t\t\tudelay(FLR_WAIT_INTERVAL);\n\t\t\toccup = REG_RD(bp, regs->lines_occup);\n\t\t\tfreed = REG_RD(bp, regs->lines_freed);\n\t\t} else {\n\t\t\tDP(BNX2X_MSG_SP, \"PBF cmd queue[%d] timed out\\n\",\n\t\t\t   regs->pN);\n\t\t\tDP(BNX2X_MSG_SP, \"OCCUPANCY[%d]   : s:%x\\n\",\n\t\t\t   regs->pN, occup);\n\t\t\tDP(BNX2X_MSG_SP, \"LINES_FREED[%d] : s:%x\\n\",\n\t\t\t   regs->pN, freed);\n\t\t\tbreak;\n\t\t}\n\t}\n\tDP(BNX2X_MSG_SP, \"Waited %d*%d usec for PBF cmd queue[%d]\\n\",\n\t   poll_count-cur_cnt, FLR_WAIT_INTERVAL, regs->pN);\n}\n\nstatic u32 bnx2x_flr_clnup_reg_poll(struct bnx2x *bp, u32 reg,\n\t\t\t\t    u32 expected, u32 poll_count)\n{\n\tu32 cur_cnt = poll_count;\n\tu32 val;\n\n\twhile ((val = REG_RD(bp, reg)) != expected && cur_cnt--)\n\t\tudelay(FLR_WAIT_INTERVAL);\n\n\treturn val;\n}\n\nint bnx2x_flr_clnup_poll_hw_counter(struct bnx2x *bp, u32 reg,\n\t\t\t\t    char *msg, u32 poll_cnt)\n{\n\tu32 val = bnx2x_flr_clnup_reg_poll(bp, reg, 0, poll_cnt);\n\tif (val != 0) {\n\t\tBNX2X_ERR(\"%s usage count=%d\\n\", msg, val);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* Common routines with VF FLR cleanup */\nu32 bnx2x_flr_clnup_poll_count(struct bnx2x *bp)\n{\n\t/* adjust polling timeout */\n\tif (CHIP_REV_IS_EMUL(bp))\n\t\treturn FLR_POLL_CNT * 2000;\n\n\tif (CHIP_REV_IS_FPGA(bp))\n\t\treturn FLR_POLL_CNT * 120;\n\n\treturn FLR_POLL_CNT;\n}\n\nvoid bnx2x_tx_hw_flushed(struct bnx2x *bp, u32 poll_count)\n{\n\tstruct pbf_pN_cmd_regs cmd_regs[] = {\n\t\t{0, (CHIP_IS_E3B0(bp)) ?\n\t\t\tPBF_REG_TQ_OCCUPANCY_Q0 :\n\t\t\tPBF_REG_P0_TQ_OCCUPANCY,\n\t\t    (CHIP_IS_E3B0(bp)) ?\n\t\t\tPBF_REG_TQ_LINES_FREED_CNT_Q0 :\n\t\t\tPBF_REG_P0_TQ_LINES_FREED_CNT},\n\t\t{1, (CHIP_IS_E3B0(bp)) ?\n\t\t\tPBF_REG_TQ_OCCUPANCY_Q1 :\n\t\t\tPBF_REG_P1_TQ_OCCUPANCY,\n\t\t    (CHIP_IS_E3B0(bp)) ?\n\t\t\tPBF_REG_TQ_LINES_FREED_CNT_Q1 :\n\t\t\tPBF_REG_P1_TQ_LINES_FREED_CNT},\n\t\t{4, (CHIP_IS_E3B0(bp)) ?\n\t\t\tPBF_REG_TQ_OCCUPANCY_LB_Q :\n\t\t\tPBF_REG_P4_TQ_OCCUPANCY,\n\t\t    (CHIP_IS_E3B0(bp)) ?\n\t\t\tPBF_REG_TQ_LINES_FREED_CNT_LB_Q :\n\t\t\tPBF_REG_P4_TQ_LINES_FREED_CNT}\n\t};\n\n\tstruct pbf_pN_buf_regs buf_regs[] = {\n\t\t{0, (CHIP_IS_E3B0(bp)) ?\n\t\t\tPBF_REG_INIT_CRD_Q0 :\n\t\t\tPBF_REG_P0_INIT_CRD ,\n\t\t    (CHIP_IS_E3B0(bp)) ?\n\t\t\tPBF_REG_CREDIT_Q0 :\n\t\t\tPBF_REG_P0_CREDIT,\n\t\t    (CHIP_IS_E3B0(bp)) ?\n\t\t\tPBF_REG_INTERNAL_CRD_FREED_CNT_Q0 :\n\t\t\tPBF_REG_P0_INTERNAL_CRD_FREED_CNT},\n\t\t{1, (CHIP_IS_E3B0(bp)) ?\n\t\t\tPBF_REG_INIT_CRD_Q1 :\n\t\t\tPBF_REG_P1_INIT_CRD,\n\t\t    (CHIP_IS_E3B0(bp)) ?\n\t\t\tPBF_REG_CREDIT_Q1 :\n\t\t\tPBF_REG_P1_CREDIT,\n\t\t    (CHIP_IS_E3B0(bp)) ?\n\t\t\tPBF_REG_INTERNAL_CRD_FREED_CNT_Q1 :\n\t\t\tPBF_REG_P1_INTERNAL_CRD_FREED_CNT},\n\t\t{4, (CHIP_IS_E3B0(bp)) ?\n\t\t\tPBF_REG_INIT_CRD_LB_Q :\n\t\t\tPBF_REG_P4_INIT_CRD,\n\t\t    (CHIP_IS_E3B0(bp)) ?\n\t\t\tPBF_REG_CREDIT_LB_Q :\n\t\t\tPBF_REG_P4_CREDIT,\n\t\t    (CHIP_IS_E3B0(bp)) ?\n\t\t\tPBF_REG_INTERNAL_CRD_FREED_CNT_LB_Q :\n\t\t\tPBF_REG_P4_INTERNAL_CRD_FREED_CNT},\n\t};\n\n\tint i;\n\n\t/* Verify the command queues are flushed P0, P1, P4 */\n\tfor (i = 0; i < ARRAY_SIZE(cmd_regs); i++)\n\t\tbnx2x_pbf_pN_cmd_flushed(bp, &cmd_regs[i], poll_count);\n\n\t/* Verify the transmission buffers are flushed P0, P1, P4 */\n\tfor (i = 0; i < ARRAY_SIZE(buf_regs); i++)\n\t\tbnx2x_pbf_pN_buf_flushed(bp, &buf_regs[i], poll_count);\n}\n\n#define OP_GEN_PARAM(param) \\\n\t(((param) << SDM_OP_GEN_COMP_PARAM_SHIFT) & SDM_OP_GEN_COMP_PARAM)\n\n#define OP_GEN_TYPE(type) \\\n\t(((type) << SDM_OP_GEN_COMP_TYPE_SHIFT) & SDM_OP_GEN_COMP_TYPE)\n\n#define OP_GEN_AGG_VECT(index) \\\n\t(((index) << SDM_OP_GEN_AGG_VECT_IDX_SHIFT) & SDM_OP_GEN_AGG_VECT_IDX)\n\nint bnx2x_send_final_clnup(struct bnx2x *bp, u8 clnup_func, u32 poll_cnt)\n{\n\tu32 op_gen_command = 0;\n\tu32 comp_addr = BAR_CSTRORM_INTMEM +\n\t\t\tCSTORM_FINAL_CLEANUP_COMPLETE_OFFSET(clnup_func);\n\tint ret = 0;\n\n\tif (REG_RD(bp, comp_addr)) {\n\t\tBNX2X_ERR(\"Cleanup complete was not 0 before sending\\n\");\n\t\treturn 1;\n\t}\n\n\top_gen_command |= OP_GEN_PARAM(XSTORM_AGG_INT_FINAL_CLEANUP_INDEX);\n\top_gen_command |= OP_GEN_TYPE(XSTORM_AGG_INT_FINAL_CLEANUP_COMP_TYPE);\n\top_gen_command |= OP_GEN_AGG_VECT(clnup_func);\n\top_gen_command |= 1 << SDM_OP_GEN_AGG_VECT_IDX_VALID_SHIFT;\n\n\tDP(BNX2X_MSG_SP, \"sending FW Final cleanup\\n\");\n\tREG_WR(bp, XSDM_REG_OPERATION_GEN, op_gen_command);\n\n\tif (bnx2x_flr_clnup_reg_poll(bp, comp_addr, 1, poll_cnt) != 1) {\n\t\tBNX2X_ERR(\"FW final cleanup did not succeed\\n\");\n\t\tDP(BNX2X_MSG_SP, \"At timeout completion address contained %x\\n\",\n\t\t   (REG_RD(bp, comp_addr)));\n\t\tbnx2x_panic();\n\t\treturn 1;\n\t}\n\t/* Zero completion for next FLR */\n\tREG_WR(bp, comp_addr, 0);\n\n\treturn ret;\n}\n\nu8 bnx2x_is_pcie_pending(struct pci_dev *dev)\n{\n\tu16 status;\n\n\tpcie_capability_read_word(dev, PCI_EXP_DEVSTA, &status);\n\treturn status & PCI_EXP_DEVSTA_TRPND;\n}\n\n/* PF FLR specific routines\n*/\nstatic int bnx2x_poll_hw_usage_counters(struct bnx2x *bp, u32 poll_cnt)\n{\n\t/* wait for CFC PF usage-counter to zero (includes all the VFs) */\n\tif (bnx2x_flr_clnup_poll_hw_counter(bp,\n\t\t\tCFC_REG_NUM_LCIDS_INSIDE_PF,\n\t\t\t\"CFC PF usage counter timed out\",\n\t\t\tpoll_cnt))\n\t\treturn 1;\n\n\t/* Wait for DQ PF usage-counter to zero (until DQ cleanup) */\n\tif (bnx2x_flr_clnup_poll_hw_counter(bp,\n\t\t\tDORQ_REG_PF_USAGE_CNT,\n\t\t\t\"DQ PF usage counter timed out\",\n\t\t\tpoll_cnt))\n\t\treturn 1;\n\n\t/* Wait for QM PF usage-counter to zero (until DQ cleanup) */\n\tif (bnx2x_flr_clnup_poll_hw_counter(bp,\n\t\t\tQM_REG_PF_USG_CNT_0 + 4*BP_FUNC(bp),\n\t\t\t\"QM PF usage counter timed out\",\n\t\t\tpoll_cnt))\n\t\treturn 1;\n\n\t/* Wait for Timer PF usage-counters to zero (until DQ cleanup) */\n\tif (bnx2x_flr_clnup_poll_hw_counter(bp,\n\t\t\tTM_REG_LIN0_VNIC_UC + 4*BP_PORT(bp),\n\t\t\t\"Timers VNIC usage counter timed out\",\n\t\t\tpoll_cnt))\n\t\treturn 1;\n\tif (bnx2x_flr_clnup_poll_hw_counter(bp,\n\t\t\tTM_REG_LIN0_NUM_SCANS + 4*BP_PORT(bp),\n\t\t\t\"Timers NUM_SCANS usage counter timed out\",\n\t\t\tpoll_cnt))\n\t\treturn 1;\n\n\t/* Wait DMAE PF usage counter to zero */\n\tif (bnx2x_flr_clnup_poll_hw_counter(bp,\n\t\t\tdmae_reg_go_c[INIT_DMAE_C(bp)],\n\t\t\t\"DMAE command register timed out\",\n\t\t\tpoll_cnt))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void bnx2x_hw_enable_status(struct bnx2x *bp)\n{\n\tu32 val;\n\n\tval = REG_RD(bp, CFC_REG_WEAK_ENABLE_PF);\n\tDP(BNX2X_MSG_SP, \"CFC_REG_WEAK_ENABLE_PF is 0x%x\\n\", val);\n\n\tval = REG_RD(bp, PBF_REG_DISABLE_PF);\n\tDP(BNX2X_MSG_SP, \"PBF_REG_DISABLE_PF is 0x%x\\n\", val);\n\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSI_EN);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSI_EN is 0x%x\\n\", val);\n\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSIX_EN);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSIX_EN is 0x%x\\n\", val);\n\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSIX_FUNC_MASK);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSIX_FUNC_MASK is 0x%x\\n\", val);\n\n\tval = REG_RD(bp, PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR is 0x%x\\n\", val);\n\n\tval = REG_RD(bp, PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR is 0x%x\\n\", val);\n\n\tval = REG_RD(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER is 0x%x\\n\",\n\t   val);\n}\n\nstatic int bnx2x_pf_flr_clnup(struct bnx2x *bp)\n{\n\tu32 poll_cnt = bnx2x_flr_clnup_poll_count(bp);\n\n\tDP(BNX2X_MSG_SP, \"Cleanup after FLR PF[%d]\\n\", BP_ABS_FUNC(bp));\n\n\t/* Re-enable PF target read access */\n\tREG_WR(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_TARGET_READ, 1);\n\n\t/* Poll HW usage counters */\n\tDP(BNX2X_MSG_SP, \"Polling usage counters\\n\");\n\tif (bnx2x_poll_hw_usage_counters(bp, poll_cnt))\n\t\treturn -EBUSY;\n\n\t/* Zero the igu 'trailing edge' and 'leading edge' */\n\n\t/* Send the FW cleanup command */\n\tif (bnx2x_send_final_clnup(bp, (u8)BP_FUNC(bp), poll_cnt))\n\t\treturn -EBUSY;\n\n\t/* ATC cleanup */\n\n\t/* Verify TX hw is flushed */\n\tbnx2x_tx_hw_flushed(bp, poll_cnt);\n\n\t/* Wait 100ms (not adjusted according to platform) */\n\tmsleep(100);\n\n\t/* Verify no pending pci transactions */\n\tif (bnx2x_is_pcie_pending(bp->pdev))\n\t\tBNX2X_ERR(\"PCIE Transactions still pending\\n\");\n\n\t/* Debug */\n\tbnx2x_hw_enable_status(bp);\n\n\t/*\n\t * Master enable - Due to WB DMAE writes performed before this\n\t * register is re-initialized as part of the regular function init\n\t */\n\tREG_WR(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER, 1);\n\n\treturn 0;\n}\n\nstatic void bnx2x_hc_int_enable(struct bnx2x *bp)\n{\n\tint port = BP_PORT(bp);\n\tu32 addr = port ? HC_REG_CONFIG_1 : HC_REG_CONFIG_0;\n\tu32 val = REG_RD(bp, addr);\n\tbool msix = (bp->flags & USING_MSIX_FLAG) ? true : false;\n\tbool single_msix = (bp->flags & USING_SINGLE_MSIX_FLAG) ? true : false;\n\tbool msi = (bp->flags & USING_MSI_FLAG) ? true : false;\n\n\tif (msix) {\n\t\tval &= ~(HC_CONFIG_0_REG_SINGLE_ISR_EN_0 |\n\t\t\t HC_CONFIG_0_REG_INT_LINE_EN_0);\n\t\tval |= (HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0 |\n\t\t\tHC_CONFIG_0_REG_ATTN_BIT_EN_0);\n\t\tif (single_msix)\n\t\t\tval |= HC_CONFIG_0_REG_SINGLE_ISR_EN_0;\n\t} else if (msi) {\n\t\tval &= ~HC_CONFIG_0_REG_INT_LINE_EN_0;\n\t\tval |= (HC_CONFIG_0_REG_SINGLE_ISR_EN_0 |\n\t\t\tHC_CONFIG_0_REG_MSI_MSIX_INT_EN_0 |\n\t\t\tHC_CONFIG_0_REG_ATTN_BIT_EN_0);\n\t} else {\n\t\tval |= (HC_CONFIG_0_REG_SINGLE_ISR_EN_0 |\n\t\t\tHC_CONFIG_0_REG_MSI_MSIX_INT_EN_0 |\n\t\t\tHC_CONFIG_0_REG_INT_LINE_EN_0 |\n\t\t\tHC_CONFIG_0_REG_ATTN_BIT_EN_0);\n\n\t\tif (!CHIP_IS_E1(bp)) {\n\t\t\tDP(NETIF_MSG_IFUP,\n\t\t\t   \"write %x to HC %d (addr 0x%x)\\n\", val, port, addr);\n\n\t\t\tREG_WR(bp, addr, val);\n\n\t\t\tval &= ~HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0;\n\t\t}\n\t}\n\n\tif (CHIP_IS_E1(bp))\n\t\tREG_WR(bp, HC_REG_INT_MASK + port*4, 0x1FFFF);\n\n\tDP(NETIF_MSG_IFUP,\n\t   \"write %x to HC %d (addr 0x%x) mode %s\\n\", val, port, addr,\n\t   (msix ? \"MSI-X\" : (msi ? \"MSI\" : \"INTx\")));\n\n\tREG_WR(bp, addr, val);\n\t/*\n\t * Ensure that HC_CONFIG is written before leading/trailing edge config\n\t */\n\tbarrier();\n\n\tif (!CHIP_IS_E1(bp)) {\n\t\t/* init leading/trailing edge */\n\t\tif (IS_MF(bp)) {\n\t\t\tval = (0xee0f | (1 << (BP_VN(bp) + 4)));\n\t\t\tif (bp->port.pmf)\n\t\t\t\t/* enable nig and gpio3 attention */\n\t\t\t\tval |= 0x1100;\n\t\t} else\n\t\t\tval = 0xffff;\n\n\t\tREG_WR(bp, HC_REG_TRAILING_EDGE_0 + port*8, val);\n\t\tREG_WR(bp, HC_REG_LEADING_EDGE_0 + port*8, val);\n\t}\n}\n\nstatic void bnx2x_igu_int_enable(struct bnx2x *bp)\n{\n\tu32 val;\n\tbool msix = (bp->flags & USING_MSIX_FLAG) ? true : false;\n\tbool single_msix = (bp->flags & USING_SINGLE_MSIX_FLAG) ? true : false;\n\tbool msi = (bp->flags & USING_MSI_FLAG) ? true : false;\n\n\tval = REG_RD(bp, IGU_REG_PF_CONFIGURATION);\n\n\tif (msix) {\n\t\tval &= ~(IGU_PF_CONF_INT_LINE_EN |\n\t\t\t IGU_PF_CONF_SINGLE_ISR_EN);\n\t\tval |= (IGU_PF_CONF_MSI_MSIX_EN |\n\t\t\tIGU_PF_CONF_ATTN_BIT_EN);\n\n\t\tif (single_msix)\n\t\t\tval |= IGU_PF_CONF_SINGLE_ISR_EN;\n\t} else if (msi) {\n\t\tval &= ~IGU_PF_CONF_INT_LINE_EN;\n\t\tval |= (IGU_PF_CONF_MSI_MSIX_EN |\n\t\t\tIGU_PF_CONF_ATTN_BIT_EN |\n\t\t\tIGU_PF_CONF_SINGLE_ISR_EN);\n\t} else {\n\t\tval &= ~IGU_PF_CONF_MSI_MSIX_EN;\n\t\tval |= (IGU_PF_CONF_INT_LINE_EN |\n\t\t\tIGU_PF_CONF_ATTN_BIT_EN |\n\t\t\tIGU_PF_CONF_SINGLE_ISR_EN);\n\t}\n\n\t/* Clean previous status - need to configure igu prior to ack*/\n\tif ((!msix) || single_msix) {\n\t\tREG_WR(bp, IGU_REG_PF_CONFIGURATION, val);\n\t\tbnx2x_ack_int(bp);\n\t}\n\n\tval |= IGU_PF_CONF_FUNC_EN;\n\n\tDP(NETIF_MSG_IFUP, \"write 0x%x to IGU  mode %s\\n\",\n\t   val, (msix ? \"MSI-X\" : (msi ? \"MSI\" : \"INTx\")));\n\n\tREG_WR(bp, IGU_REG_PF_CONFIGURATION, val);\n\n\tif (val & IGU_PF_CONF_INT_LINE_EN)\n\t\tpci_intx(bp->pdev, true);\n\n\tbarrier();\n\n\t/* init leading/trailing edge */\n\tif (IS_MF(bp)) {\n\t\tval = (0xee0f | (1 << (BP_VN(bp) + 4)));\n\t\tif (bp->port.pmf)\n\t\t\t/* enable nig and gpio3 attention */\n\t\t\tval |= 0x1100;\n\t} else\n\t\tval = 0xffff;\n\n\tREG_WR(bp, IGU_REG_TRAILING_EDGE_LATCH, val);\n\tREG_WR(bp, IGU_REG_LEADING_EDGE_LATCH, val);\n}\n\nvoid bnx2x_int_enable(struct bnx2x *bp)\n{\n\tif (bp->common.int_block == INT_BLOCK_HC)\n\t\tbnx2x_hc_int_enable(bp);\n\telse\n\t\tbnx2x_igu_int_enable(bp);\n}\n\nvoid bnx2x_int_disable_sync(struct bnx2x *bp, int disable_hw)\n{\n\tint msix = (bp->flags & USING_MSIX_FLAG) ? 1 : 0;\n\tint i, offset;\n\n\tif (disable_hw)\n\t\t/* prevent the HW from sending interrupts */\n\t\tbnx2x_int_disable(bp);\n\n\t/* make sure all ISRs are done */\n\tif (msix) {\n\t\tsynchronize_irq(bp->msix_table[0].vector);\n\t\toffset = 1;\n\t\tif (CNIC_SUPPORT(bp))\n\t\t\toffset++;\n\t\tfor_each_eth_queue(bp, i)\n\t\t\tsynchronize_irq(bp->msix_table[offset++].vector);\n\t} else\n\t\tsynchronize_irq(bp->pdev->irq);\n\n\t/* make sure sp_task is not running */\n\tcancel_delayed_work(&bp->sp_task);\n\tcancel_delayed_work(&bp->period_task);\n\tflush_workqueue(bnx2x_wq);\n}\n\n/* fast path */\n\n/*\n * General service functions\n */\n\n/* Return true if succeeded to acquire the lock */\nstatic bool bnx2x_trylock_hw_lock(struct bnx2x *bp, u32 resource)\n{\n\tu32 lock_status;\n\tu32 resource_bit = (1 << resource);\n\tint func = BP_FUNC(bp);\n\tu32 hw_lock_control_reg;\n\n\tDP(NETIF_MSG_HW | NETIF_MSG_IFUP,\n\t   \"Trying to take a lock on resource %d\\n\", resource);\n\n\t/* Validating that the resource is within range */\n\tif (resource > HW_LOCK_MAX_RESOURCE_VALUE) {\n\t\tDP(NETIF_MSG_HW | NETIF_MSG_IFUP,\n\t\t   \"resource(0x%x) > HW_LOCK_MAX_RESOURCE_VALUE(0x%x)\\n\",\n\t\t   resource, HW_LOCK_MAX_RESOURCE_VALUE);\n\t\treturn false;\n\t}\n\n\tif (func <= 5)\n\t\thw_lock_control_reg = (MISC_REG_DRIVER_CONTROL_1 + func*8);\n\telse\n\t\thw_lock_control_reg =\n\t\t\t\t(MISC_REG_DRIVER_CONTROL_7 + (func - 6)*8);\n\n\t/* Try to acquire the lock */\n\tREG_WR(bp, hw_lock_control_reg + 4, resource_bit);\n\tlock_status = REG_RD(bp, hw_lock_control_reg);\n\tif (lock_status & resource_bit)\n\t\treturn true;\n\n\tDP(NETIF_MSG_HW | NETIF_MSG_IFUP,\n\t   \"Failed to get a lock on resource %d\\n\", resource);\n\treturn false;\n}\n\n/**\n * bnx2x_get_leader_lock_resource - get the recovery leader resource id\n *\n * @bp:\tdriver handle\n *\n * Returns the recovery leader resource id according to the engine this function\n * belongs to. Currently only only 2 engines is supported.\n */\nstatic int bnx2x_get_leader_lock_resource(struct bnx2x *bp)\n{\n\tif (BP_PATH(bp))\n\t\treturn HW_LOCK_RESOURCE_RECOVERY_LEADER_1;\n\telse\n\t\treturn HW_LOCK_RESOURCE_RECOVERY_LEADER_0;\n}\n\n/**\n * bnx2x_trylock_leader_lock- try to acquire a leader lock.\n *\n * @bp: driver handle\n *\n * Tries to acquire a leader lock for current engine.\n */\nstatic bool bnx2x_trylock_leader_lock(struct bnx2x *bp)\n{\n\treturn bnx2x_trylock_hw_lock(bp, bnx2x_get_leader_lock_resource(bp));\n}\n\nstatic void bnx2x_cnic_cfc_comp(struct bnx2x *bp, int cid, u8 err);\n\n/* schedule the sp task and mark that interrupt occurred (runs from ISR) */\nstatic int bnx2x_schedule_sp_task(struct bnx2x *bp)\n{\n\t/* Set the interrupt occurred bit for the sp-task to recognize it\n\t * must ack the interrupt and transition according to the IGU\n\t * state machine.\n\t */\n\tatomic_set(&bp->interrupt_occurred, 1);\n\n\t/* The sp_task must execute only after this bit\n\t * is set, otherwise we will get out of sync and miss all\n\t * further interrupts. Hence, the barrier.\n\t */\n\tsmp_wmb();\n\n\t/* schedule sp_task to workqueue */\n\treturn queue_delayed_work(bnx2x_wq, &bp->sp_task, 0);\n}\n\nvoid bnx2x_sp_event(struct bnx2x_fastpath *fp, union eth_rx_cqe *rr_cqe)\n{\n\tstruct bnx2x *bp = fp->bp;\n\tint cid = SW_CID(rr_cqe->ramrod_cqe.conn_and_cmd_data);\n\tint command = CQE_CMD(rr_cqe->ramrod_cqe.conn_and_cmd_data);\n\tenum bnx2x_queue_cmd drv_cmd = BNX2X_Q_CMD_MAX;\n\tstruct bnx2x_queue_sp_obj *q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\n\n\tDP(BNX2X_MSG_SP,\n\t   \"fp %d  cid %d  got ramrod #%d  state is %x  type is %d\\n\",\n\t   fp->index, cid, command, bp->state,\n\t   rr_cqe->ramrod_cqe.ramrod_type);\n\n\t/* If cid is within VF range, replace the slowpath object with the\n\t * one corresponding to this VF\n\t */\n\tif (cid >= BNX2X_FIRST_VF_CID  &&\n\t    cid < BNX2X_FIRST_VF_CID + BNX2X_VF_CIDS)\n\t\tbnx2x_iov_set_queue_sp_obj(bp, cid, &q_obj);\n\n\tswitch (command) {\n\tcase (RAMROD_CMD_ID_ETH_CLIENT_UPDATE):\n\t\tDP(BNX2X_MSG_SP, \"got UPDATE ramrod. CID %d\\n\", cid);\n\t\tdrv_cmd = BNX2X_Q_CMD_UPDATE;\n\t\tbreak;\n\n\tcase (RAMROD_CMD_ID_ETH_CLIENT_SETUP):\n\t\tDP(BNX2X_MSG_SP, \"got MULTI[%d] setup ramrod\\n\", cid);\n\t\tdrv_cmd = BNX2X_Q_CMD_SETUP;\n\t\tbreak;\n\n\tcase (RAMROD_CMD_ID_ETH_TX_QUEUE_SETUP):\n\t\tDP(BNX2X_MSG_SP, \"got MULTI[%d] tx-only setup ramrod\\n\", cid);\n\t\tdrv_cmd = BNX2X_Q_CMD_SETUP_TX_ONLY;\n\t\tbreak;\n\n\tcase (RAMROD_CMD_ID_ETH_HALT):\n\t\tDP(BNX2X_MSG_SP, \"got MULTI[%d] halt ramrod\\n\", cid);\n\t\tdrv_cmd = BNX2X_Q_CMD_HALT;\n\t\tbreak;\n\n\tcase (RAMROD_CMD_ID_ETH_TERMINATE):\n\t\tDP(BNX2X_MSG_SP, \"got MULTI[%d] terminate ramrod\\n\", cid);\n\t\tdrv_cmd = BNX2X_Q_CMD_TERMINATE;\n\t\tbreak;\n\n\tcase (RAMROD_CMD_ID_ETH_EMPTY):\n\t\tDP(BNX2X_MSG_SP, \"got MULTI[%d] empty ramrod\\n\", cid);\n\t\tdrv_cmd = BNX2X_Q_CMD_EMPTY;\n\t\tbreak;\n\n\tcase (RAMROD_CMD_ID_ETH_TPA_UPDATE):\n\t\tDP(BNX2X_MSG_SP, \"got tpa update ramrod CID=%d\\n\", cid);\n\t\tdrv_cmd = BNX2X_Q_CMD_UPDATE_TPA;\n\t\tbreak;\n\n\tdefault:\n\t\tBNX2X_ERR(\"unexpected MC reply (%d) on fp[%d]\\n\",\n\t\t\t  command, fp->index);\n\t\treturn;\n\t}\n\n\tif ((drv_cmd != BNX2X_Q_CMD_MAX) &&\n\t    q_obj->complete_cmd(bp, q_obj, drv_cmd))\n\t\t/* q_obj->complete_cmd() failure means that this was\n\t\t * an unexpected completion.\n\t\t *\n\t\t * In this case we don't want to increase the bp->spq_left\n\t\t * because apparently we haven't sent this command the first\n\t\t * place.\n\t\t */\n#ifdef BNX2X_STOP_ON_ERROR\n\t\tbnx2x_panic();\n#else\n\t\treturn;\n#endif\n\n\tsmp_mb__before_atomic();\n\tatomic_inc(&bp->cq_spq_left);\n\t/* push the change in bp->spq_left and towards the memory */\n\tsmp_mb__after_atomic();\n\n\tDP(BNX2X_MSG_SP, \"bp->cq_spq_left %x\\n\", atomic_read(&bp->cq_spq_left));\n\n\tif ((drv_cmd == BNX2X_Q_CMD_UPDATE) && (IS_FCOE_FP(fp)) &&\n\t    (!!test_bit(BNX2X_AFEX_FCOE_Q_UPDATE_PENDING, &bp->sp_state))) {\n\t\t/* if Q update ramrod is completed for last Q in AFEX vif set\n\t\t * flow, then ACK MCP at the end\n\t\t *\n\t\t * mark pending ACK to MCP bit.\n\t\t * prevent case that both bits are cleared.\n\t\t * At the end of load/unload driver checks that\n\t\t * sp_state is cleared, and this order prevents\n\t\t * races\n\t\t */\n\t\tsmp_mb__before_atomic();\n\t\tset_bit(BNX2X_AFEX_PENDING_VIFSET_MCP_ACK, &bp->sp_state);\n\t\twmb();\n\t\tclear_bit(BNX2X_AFEX_FCOE_Q_UPDATE_PENDING, &bp->sp_state);\n\t\tsmp_mb__after_atomic();\n\n\t\t/* schedule the sp task as mcp ack is required */\n\t\tbnx2x_schedule_sp_task(bp);\n\t}\n\n\treturn;\n}\n\nirqreturn_t bnx2x_interrupt(int irq, void *dev_instance)\n{\n\tstruct bnx2x *bp = netdev_priv(dev_instance);\n\tu16 status = bnx2x_ack_int(bp);\n\tu16 mask;\n\tint i;\n\tu8 cos;\n\n\t/* Return here if interrupt is shared and it's not for us */\n\tif (unlikely(status == 0)) {\n\t\tDP(NETIF_MSG_INTR, \"not our interrupt!\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\tDP(NETIF_MSG_INTR, \"got an interrupt  status 0x%x\\n\", status);\n\n#ifdef BNX2X_STOP_ON_ERROR\n\tif (unlikely(bp->panic))\n\t\treturn IRQ_HANDLED;\n#endif\n\n\tfor_each_eth_queue(bp, i) {\n\t\tstruct bnx2x_fastpath *fp = &bp->fp[i];\n\n\t\tmask = 0x2 << (fp->index + CNIC_SUPPORT(bp));\n\t\tif (status & mask) {\n\t\t\t/* Handle Rx or Tx according to SB id */\n\t\t\tfor_each_cos_in_tx_queue(fp, cos)\n\t\t\t\tprefetch(fp->txdata_ptr[cos]->tx_cons_sb);\n\t\t\tprefetch(&fp->sb_running_index[SM_RX_ID]);\n\t\t\tnapi_schedule_irqoff(&bnx2x_fp(bp, fp->index, napi));\n\t\t\tstatus &= ~mask;\n\t\t}\n\t}\n\n\tif (CNIC_SUPPORT(bp)) {\n\t\tmask = 0x2;\n\t\tif (status & (mask | 0x1)) {\n\t\t\tstruct cnic_ops *c_ops = NULL;\n\n\t\t\trcu_read_lock();\n\t\t\tc_ops = rcu_dereference(bp->cnic_ops);\n\t\t\tif (c_ops && (bp->cnic_eth_dev.drv_state &\n\t\t\t\t      CNIC_DRV_STATE_HANDLES_IRQ))\n\t\t\t\tc_ops->cnic_handler(bp->cnic_data, NULL);\n\t\t\trcu_read_unlock();\n\n\t\t\tstatus &= ~mask;\n\t\t}\n\t}\n\n\tif (unlikely(status & 0x1)) {\n\n\t\t/* schedule sp task to perform default status block work, ack\n\t\t * attentions and enable interrupts.\n\t\t */\n\t\tbnx2x_schedule_sp_task(bp);\n\n\t\tstatus &= ~0x1;\n\t\tif (!status)\n\t\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (unlikely(status))\n\t\tDP(NETIF_MSG_INTR, \"got an unknown interrupt! (status 0x%x)\\n\",\n\t\t   status);\n\n\treturn IRQ_HANDLED;\n}\n\n/* Link */\n\n/*\n * General service functions\n */\n\nint bnx2x_acquire_hw_lock(struct bnx2x *bp, u32 resource)\n{\n\tu32 lock_status;\n\tu32 resource_bit = (1 << resource);\n\tint func = BP_FUNC(bp);\n\tu32 hw_lock_control_reg;\n\tint cnt;\n\n\t/* Validating that the resource is within range */\n\tif (resource > HW_LOCK_MAX_RESOURCE_VALUE) {\n\t\tBNX2X_ERR(\"resource(0x%x) > HW_LOCK_MAX_RESOURCE_VALUE(0x%x)\\n\",\n\t\t   resource, HW_LOCK_MAX_RESOURCE_VALUE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (func <= 5) {\n\t\thw_lock_control_reg = (MISC_REG_DRIVER_CONTROL_1 + func*8);\n\t} else {\n\t\thw_lock_control_reg =\n\t\t\t\t(MISC_REG_DRIVER_CONTROL_7 + (func - 6)*8);\n\t}\n\n\t/* Validating that the resource is not already taken */\n\tlock_status = REG_RD(bp, hw_lock_control_reg);\n\tif (lock_status & resource_bit) {\n\t\tBNX2X_ERR(\"lock_status 0x%x  resource_bit 0x%x\\n\",\n\t\t   lock_status, resource_bit);\n\t\treturn -EEXIST;\n\t}\n\n\t/* Try for 5 second every 5ms */\n\tfor (cnt = 0; cnt < 1000; cnt++) {\n\t\t/* Try to acquire the lock */\n\t\tREG_WR(bp, hw_lock_control_reg + 4, resource_bit);\n\t\tlock_status = REG_RD(bp, hw_lock_control_reg);\n\t\tif (lock_status & resource_bit)\n\t\t\treturn 0;\n\n\t\tusleep_range(5000, 10000);\n\t}\n\tBNX2X_ERR(\"Timeout\\n\");\n\treturn -EAGAIN;\n}\n\nint bnx2x_release_leader_lock(struct bnx2x *bp)\n{\n\treturn bnx2x_release_hw_lock(bp, bnx2x_get_leader_lock_resource(bp));\n}\n\nint bnx2x_release_hw_lock(struct bnx2x *bp, u32 resource)\n{\n\tu32 lock_status;\n\tu32 resource_bit = (1 << resource);\n\tint func = BP_FUNC(bp);\n\tu32 hw_lock_control_reg;\n\n\t/* Validating that the resource is within range */\n\tif (resource > HW_LOCK_MAX_RESOURCE_VALUE) {\n\t\tBNX2X_ERR(\"resource(0x%x) > HW_LOCK_MAX_RESOURCE_VALUE(0x%x)\\n\",\n\t\t   resource, HW_LOCK_MAX_RESOURCE_VALUE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (func <= 5) {\n\t\thw_lock_control_reg = (MISC_REG_DRIVER_CONTROL_1 + func*8);\n\t} else {\n\t\thw_lock_control_reg =\n\t\t\t\t(MISC_REG_DRIVER_CONTROL_7 + (func - 6)*8);\n\t}\n\n\t/* Validating that the resource is currently taken */\n\tlock_status = REG_RD(bp, hw_lock_control_reg);\n\tif (!(lock_status & resource_bit)) {\n\t\tBNX2X_ERR(\"lock_status 0x%x resource_bit 0x%x. Unlock was called but lock wasn't taken!\\n\",\n\t\t\t  lock_status, resource_bit);\n\t\treturn -EFAULT;\n\t}\n\n\tREG_WR(bp, hw_lock_control_reg, resource_bit);\n\treturn 0;\n}\n\nint bnx2x_get_gpio(struct bnx2x *bp, int gpio_num, u8 port)\n{\n\t/* The GPIO should be swapped if swap register is set and active */\n\tint gpio_port = (REG_RD(bp, NIG_REG_PORT_SWAP) &&\n\t\t\t REG_RD(bp, NIG_REG_STRAP_OVERRIDE)) ^ port;\n\tint gpio_shift = gpio_num +\n\t\t\t(gpio_port ? MISC_REGISTERS_GPIO_PORT_SHIFT : 0);\n\tu32 gpio_mask = (1 << gpio_shift);\n\tu32 gpio_reg;\n\tint value;\n\n\tif (gpio_num > MISC_REGISTERS_GPIO_3) {\n\t\tBNX2X_ERR(\"Invalid GPIO %d\\n\", gpio_num);\n\t\treturn -EINVAL;\n\t}\n\n\t/* read GPIO value */\n\tgpio_reg = REG_RD(bp, MISC_REG_GPIO);\n\n\t/* get the requested pin value */\n\tif ((gpio_reg & gpio_mask) == gpio_mask)\n\t\tvalue = 1;\n\telse\n\t\tvalue = 0;\n\n\treturn value;\n}\n\nint bnx2x_set_gpio(struct bnx2x *bp, int gpio_num, u32 mode, u8 port)\n{\n\t/* The GPIO should be swapped if swap register is set and active */\n\tint gpio_port = (REG_RD(bp, NIG_REG_PORT_SWAP) &&\n\t\t\t REG_RD(bp, NIG_REG_STRAP_OVERRIDE)) ^ port;\n\tint gpio_shift = gpio_num +\n\t\t\t(gpio_port ? MISC_REGISTERS_GPIO_PORT_SHIFT : 0);\n\tu32 gpio_mask = (1 << gpio_shift);\n\tu32 gpio_reg;\n\n\tif (gpio_num > MISC_REGISTERS_GPIO_3) {\n\t\tBNX2X_ERR(\"Invalid GPIO %d\\n\", gpio_num);\n\t\treturn -EINVAL;\n\t}\n\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_GPIO);\n\t/* read GPIO and mask except the float bits */\n\tgpio_reg = (REG_RD(bp, MISC_REG_GPIO) & MISC_REGISTERS_GPIO_FLOAT);\n\n\tswitch (mode) {\n\tcase MISC_REGISTERS_GPIO_OUTPUT_LOW:\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"Set GPIO %d (shift %d) -> output low\\n\",\n\t\t   gpio_num, gpio_shift);\n\t\t/* clear FLOAT and set CLR */\n\t\tgpio_reg &= ~(gpio_mask << MISC_REGISTERS_GPIO_FLOAT_POS);\n\t\tgpio_reg |=  (gpio_mask << MISC_REGISTERS_GPIO_CLR_POS);\n\t\tbreak;\n\n\tcase MISC_REGISTERS_GPIO_OUTPUT_HIGH:\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"Set GPIO %d (shift %d) -> output high\\n\",\n\t\t   gpio_num, gpio_shift);\n\t\t/* clear FLOAT and set SET */\n\t\tgpio_reg &= ~(gpio_mask << MISC_REGISTERS_GPIO_FLOAT_POS);\n\t\tgpio_reg |=  (gpio_mask << MISC_REGISTERS_GPIO_SET_POS);\n\t\tbreak;\n\n\tcase MISC_REGISTERS_GPIO_INPUT_HI_Z:\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"Set GPIO %d (shift %d) -> input\\n\",\n\t\t   gpio_num, gpio_shift);\n\t\t/* set FLOAT */\n\t\tgpio_reg |= (gpio_mask << MISC_REGISTERS_GPIO_FLOAT_POS);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tREG_WR(bp, MISC_REG_GPIO, gpio_reg);\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_GPIO);\n\n\treturn 0;\n}\n\nint bnx2x_set_mult_gpio(struct bnx2x *bp, u8 pins, u32 mode)\n{\n\tu32 gpio_reg = 0;\n\tint rc = 0;\n\n\t/* Any port swapping should be handled by caller. */\n\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_GPIO);\n\t/* read GPIO and mask except the float bits */\n\tgpio_reg = REG_RD(bp, MISC_REG_GPIO);\n\tgpio_reg &= ~(pins << MISC_REGISTERS_GPIO_FLOAT_POS);\n\tgpio_reg &= ~(pins << MISC_REGISTERS_GPIO_CLR_POS);\n\tgpio_reg &= ~(pins << MISC_REGISTERS_GPIO_SET_POS);\n\n\tswitch (mode) {\n\tcase MISC_REGISTERS_GPIO_OUTPUT_LOW:\n\t\tDP(NETIF_MSG_LINK, \"Set GPIO 0x%x -> output low\\n\", pins);\n\t\t/* set CLR */\n\t\tgpio_reg |= (pins << MISC_REGISTERS_GPIO_CLR_POS);\n\t\tbreak;\n\n\tcase MISC_REGISTERS_GPIO_OUTPUT_HIGH:\n\t\tDP(NETIF_MSG_LINK, \"Set GPIO 0x%x -> output high\\n\", pins);\n\t\t/* set SET */\n\t\tgpio_reg |= (pins << MISC_REGISTERS_GPIO_SET_POS);\n\t\tbreak;\n\n\tcase MISC_REGISTERS_GPIO_INPUT_HI_Z:\n\t\tDP(NETIF_MSG_LINK, \"Set GPIO 0x%x -> input\\n\", pins);\n\t\t/* set FLOAT */\n\t\tgpio_reg |= (pins << MISC_REGISTERS_GPIO_FLOAT_POS);\n\t\tbreak;\n\n\tdefault:\n\t\tBNX2X_ERR(\"Invalid GPIO mode assignment %d\\n\", mode);\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (rc == 0)\n\t\tREG_WR(bp, MISC_REG_GPIO, gpio_reg);\n\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_GPIO);\n\n\treturn rc;\n}\n\nint bnx2x_set_gpio_int(struct bnx2x *bp, int gpio_num, u32 mode, u8 port)\n{\n\t/* The GPIO should be swapped if swap register is set and active */\n\tint gpio_port = (REG_RD(bp, NIG_REG_PORT_SWAP) &&\n\t\t\t REG_RD(bp, NIG_REG_STRAP_OVERRIDE)) ^ port;\n\tint gpio_shift = gpio_num +\n\t\t\t(gpio_port ? MISC_REGISTERS_GPIO_PORT_SHIFT : 0);\n\tu32 gpio_mask = (1 << gpio_shift);\n\tu32 gpio_reg;\n\n\tif (gpio_num > MISC_REGISTERS_GPIO_3) {\n\t\tBNX2X_ERR(\"Invalid GPIO %d\\n\", gpio_num);\n\t\treturn -EINVAL;\n\t}\n\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_GPIO);\n\t/* read GPIO int */\n\tgpio_reg = REG_RD(bp, MISC_REG_GPIO_INT);\n\n\tswitch (mode) {\n\tcase MISC_REGISTERS_GPIO_INT_OUTPUT_CLR:\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"Clear GPIO INT %d (shift %d) -> output low\\n\",\n\t\t   gpio_num, gpio_shift);\n\t\t/* clear SET and set CLR */\n\t\tgpio_reg &= ~(gpio_mask << MISC_REGISTERS_GPIO_INT_SET_POS);\n\t\tgpio_reg |=  (gpio_mask << MISC_REGISTERS_GPIO_INT_CLR_POS);\n\t\tbreak;\n\n\tcase MISC_REGISTERS_GPIO_INT_OUTPUT_SET:\n\t\tDP(NETIF_MSG_LINK,\n\t\t   \"Set GPIO INT %d (shift %d) -> output high\\n\",\n\t\t   gpio_num, gpio_shift);\n\t\t/* clear CLR and set SET */\n\t\tgpio_reg &= ~(gpio_mask << MISC_REGISTERS_GPIO_INT_CLR_POS);\n\t\tgpio_reg |=  (gpio_mask << MISC_REGISTERS_GPIO_INT_SET_POS);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tREG_WR(bp, MISC_REG_GPIO_INT, gpio_reg);\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_GPIO);\n\n\treturn 0;\n}\n\nstatic int bnx2x_set_spio(struct bnx2x *bp, int spio, u32 mode)\n{\n\tu32 spio_reg;\n\n\t/* Only 2 SPIOs are configurable */\n\tif ((spio != MISC_SPIO_SPIO4) && (spio != MISC_SPIO_SPIO5)) {\n\t\tBNX2X_ERR(\"Invalid SPIO 0x%x\\n\", spio);\n\t\treturn -EINVAL;\n\t}\n\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_SPIO);\n\t/* read SPIO and mask except the float bits */\n\tspio_reg = (REG_RD(bp, MISC_REG_SPIO) & MISC_SPIO_FLOAT);\n\n\tswitch (mode) {\n\tcase MISC_SPIO_OUTPUT_LOW:\n\t\tDP(NETIF_MSG_HW, \"Set SPIO 0x%x -> output low\\n\", spio);\n\t\t/* clear FLOAT and set CLR */\n\t\tspio_reg &= ~(spio << MISC_SPIO_FLOAT_POS);\n\t\tspio_reg |=  (spio << MISC_SPIO_CLR_POS);\n\t\tbreak;\n\n\tcase MISC_SPIO_OUTPUT_HIGH:\n\t\tDP(NETIF_MSG_HW, \"Set SPIO 0x%x -> output high\\n\", spio);\n\t\t/* clear FLOAT and set SET */\n\t\tspio_reg &= ~(spio << MISC_SPIO_FLOAT_POS);\n\t\tspio_reg |=  (spio << MISC_SPIO_SET_POS);\n\t\tbreak;\n\n\tcase MISC_SPIO_INPUT_HI_Z:\n\t\tDP(NETIF_MSG_HW, \"Set SPIO 0x%x -> input\\n\", spio);\n\t\t/* set FLOAT */\n\t\tspio_reg |= (spio << MISC_SPIO_FLOAT_POS);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tREG_WR(bp, MISC_REG_SPIO, spio_reg);\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_SPIO);\n\n\treturn 0;\n}\n\nvoid bnx2x_calc_fc_adv(struct bnx2x *bp)\n{\n\tu8 cfg_idx = bnx2x_get_link_cfg_idx(bp);\n\n\tbp->port.advertising[cfg_idx] &= ~(ADVERTISED_Asym_Pause |\n\t\t\t\t\t   ADVERTISED_Pause);\n\tswitch (bp->link_vars.ieee_fc &\n\t\tMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_MASK) {\n\tcase MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH:\n\t\tbp->port.advertising[cfg_idx] |= (ADVERTISED_Asym_Pause |\n\t\t\t\t\t\t  ADVERTISED_Pause);\n\t\tbreak;\n\n\tcase MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC:\n\t\tbp->port.advertising[cfg_idx] |= ADVERTISED_Asym_Pause;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void bnx2x_set_requested_fc(struct bnx2x *bp)\n{\n\t/* Initialize link parameters structure variables\n\t * It is recommended to turn off RX FC for jumbo frames\n\t *  for better performance\n\t */\n\tif (CHIP_IS_E1x(bp) && (bp->dev->mtu > 5000))\n\t\tbp->link_params.req_fc_auto_adv = BNX2X_FLOW_CTRL_TX;\n\telse\n\t\tbp->link_params.req_fc_auto_adv = BNX2X_FLOW_CTRL_BOTH;\n}\n\nstatic void bnx2x_init_dropless_fc(struct bnx2x *bp)\n{\n\tu32 pause_enabled = 0;\n\n\tif (!CHIP_IS_E1(bp) && bp->dropless_fc && bp->link_vars.link_up) {\n\t\tif (bp->link_vars.flow_ctrl & BNX2X_FLOW_CTRL_TX)\n\t\t\tpause_enabled = 1;\n\n\t\tREG_WR(bp, BAR_USTRORM_INTMEM +\n\t\t\t   USTORM_ETH_PAUSE_ENABLED_OFFSET(BP_PORT(bp)),\n\t\t       pause_enabled);\n\t}\n\n\tDP(NETIF_MSG_IFUP | NETIF_MSG_LINK, \"dropless_fc is %s\\n\",\n\t   pause_enabled ? \"enabled\" : \"disabled\");\n}\n\nint bnx2x_initial_phy_init(struct bnx2x *bp, int load_mode)\n{\n\tint rc, cfx_idx = bnx2x_get_link_cfg_idx(bp);\n\tu16 req_line_speed = bp->link_params.req_line_speed[cfx_idx];\n\n\tif (!BP_NOMCP(bp)) {\n\t\tbnx2x_set_requested_fc(bp);\n\t\tbnx2x_acquire_phy_lock(bp);\n\n\t\tif (load_mode == LOAD_DIAG) {\n\t\t\tstruct link_params *lp = &bp->link_params;\n\t\t\tlp->loopback_mode = LOOPBACK_XGXS;\n\t\t\t/* Prefer doing PHY loopback at highest speed */\n\t\t\tif (lp->req_line_speed[cfx_idx] < SPEED_20000) {\n\t\t\t\tif (lp->speed_cap_mask[cfx_idx] &\n\t\t\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_20G)\n\t\t\t\t\tlp->req_line_speed[cfx_idx] =\n\t\t\t\t\tSPEED_20000;\n\t\t\t\telse if (lp->speed_cap_mask[cfx_idx] &\n\t\t\t\t\t    PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)\n\t\t\t\t\t\tlp->req_line_speed[cfx_idx] =\n\t\t\t\t\t\tSPEED_10000;\n\t\t\t\telse\n\t\t\t\t\tlp->req_line_speed[cfx_idx] =\n\t\t\t\t\tSPEED_1000;\n\t\t\t}\n\t\t}\n\n\t\tif (load_mode == LOAD_LOOPBACK_EXT) {\n\t\t\tstruct link_params *lp = &bp->link_params;\n\t\t\tlp->loopback_mode = LOOPBACK_EXT;\n\t\t}\n\n\t\trc = bnx2x_phy_init(&bp->link_params, &bp->link_vars);\n\n\t\tbnx2x_release_phy_lock(bp);\n\n\t\tbnx2x_init_dropless_fc(bp);\n\n\t\tbnx2x_calc_fc_adv(bp);\n\n\t\tif (bp->link_vars.link_up) {\n\t\t\tbnx2x_stats_handle(bp, STATS_EVENT_LINK_UP);\n\t\t\tbnx2x_link_report(bp);\n\t\t}\n\t\tqueue_delayed_work(bnx2x_wq, &bp->period_task, 0);\n\t\tbp->link_params.req_line_speed[cfx_idx] = req_line_speed;\n\t\treturn rc;\n\t}\n\tBNX2X_ERR(\"Bootcode is missing - can not initialize link\\n\");\n\treturn -EINVAL;\n}\n\nvoid bnx2x_link_set(struct bnx2x *bp)\n{\n\tif (!BP_NOMCP(bp)) {\n\t\tbnx2x_acquire_phy_lock(bp);\n\t\tbnx2x_phy_init(&bp->link_params, &bp->link_vars);\n\t\tbnx2x_release_phy_lock(bp);\n\n\t\tbnx2x_init_dropless_fc(bp);\n\n\t\tbnx2x_calc_fc_adv(bp);\n\t} else\n\t\tBNX2X_ERR(\"Bootcode is missing - can not set link\\n\");\n}\n\nstatic void bnx2x__link_reset(struct bnx2x *bp)\n{\n\tif (!BP_NOMCP(bp)) {\n\t\tbnx2x_acquire_phy_lock(bp);\n\t\tbnx2x_lfa_reset(&bp->link_params, &bp->link_vars);\n\t\tbnx2x_release_phy_lock(bp);\n\t} else\n\t\tBNX2X_ERR(\"Bootcode is missing - can not reset link\\n\");\n}\n\nvoid bnx2x_force_link_reset(struct bnx2x *bp)\n{\n\tbnx2x_acquire_phy_lock(bp);\n\tbnx2x_link_reset(&bp->link_params, &bp->link_vars, 1);\n\tbnx2x_release_phy_lock(bp);\n}\n\nu8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes)\n{\n\tu8 rc = 0;\n\n\tif (!BP_NOMCP(bp)) {\n\t\tbnx2x_acquire_phy_lock(bp);\n\t\trc = bnx2x_test_link(&bp->link_params, &bp->link_vars,\n\t\t\t\t     is_serdes);\n\t\tbnx2x_release_phy_lock(bp);\n\t} else\n\t\tBNX2X_ERR(\"Bootcode is missing - can not test link\\n\");\n\n\treturn rc;\n}\n\n/* Calculates the sum of vn_min_rates.\n   It's needed for further normalizing of the min_rates.\n   Returns:\n     sum of vn_min_rates.\n       or\n     0 - if all the min_rates are 0.\n     In the later case fairness algorithm should be deactivated.\n     If not all min_rates are zero then those that are zeroes will be set to 1.\n */\nstatic void bnx2x_calc_vn_min(struct bnx2x *bp,\n\t\t\t\t      struct cmng_init_input *input)\n{\n\tint all_zero = 1;\n\tint vn;\n\n\tfor (vn = VN_0; vn < BP_MAX_VN_NUM(bp); vn++) {\n\t\tu32 vn_cfg = bp->mf_config[vn];\n\t\tu32 vn_min_rate = ((vn_cfg & FUNC_MF_CFG_MIN_BW_MASK) >>\n\t\t\t\t   FUNC_MF_CFG_MIN_BW_SHIFT) * 100;\n\n\t\t/* Skip hidden vns */\n\t\tif (vn_cfg & FUNC_MF_CFG_FUNC_HIDE)\n\t\t\tvn_min_rate = 0;\n\t\t/* If min rate is zero - set it to 1 */\n\t\telse if (!vn_min_rate)\n\t\t\tvn_min_rate = DEF_MIN_RATE;\n\t\telse\n\t\t\tall_zero = 0;\n\n\t\tinput->vnic_min_rate[vn] = vn_min_rate;\n\t}\n\n\t/* if ETS or all min rates are zeros - disable fairness */\n\tif (BNX2X_IS_ETS_ENABLED(bp)) {\n\t\tinput->flags.cmng_enables &=\n\t\t\t\t\t~CMNG_FLAGS_PER_PORT_FAIRNESS_VN;\n\t\tDP(NETIF_MSG_IFUP, \"Fairness will be disabled due to ETS\\n\");\n\t} else if (all_zero) {\n\t\tinput->flags.cmng_enables &=\n\t\t\t\t\t~CMNG_FLAGS_PER_PORT_FAIRNESS_VN;\n\t\tDP(NETIF_MSG_IFUP,\n\t\t   \"All MIN values are zeroes fairness will be disabled\\n\");\n\t} else\n\t\tinput->flags.cmng_enables |=\n\t\t\t\t\tCMNG_FLAGS_PER_PORT_FAIRNESS_VN;\n}\n\nstatic void bnx2x_calc_vn_max(struct bnx2x *bp, int vn,\n\t\t\t\t    struct cmng_init_input *input)\n{\n\tu16 vn_max_rate;\n\tu32 vn_cfg = bp->mf_config[vn];\n\n\tif (vn_cfg & FUNC_MF_CFG_FUNC_HIDE)\n\t\tvn_max_rate = 0;\n\telse {\n\t\tu32 maxCfg = bnx2x_extract_max_cfg(bp, vn_cfg);\n\n\t\tif (IS_MF_PERCENT_BW(bp)) {\n\t\t\t/* maxCfg in percents of linkspeed */\n\t\t\tvn_max_rate = (bp->link_vars.line_speed * maxCfg) / 100;\n\t\t} else /* SD modes */\n\t\t\t/* maxCfg is absolute in 100Mb units */\n\t\t\tvn_max_rate = maxCfg * 100;\n\t}\n\n\tDP(NETIF_MSG_IFUP, \"vn %d: vn_max_rate %d\\n\", vn, vn_max_rate);\n\n\tinput->vnic_max_rate[vn] = vn_max_rate;\n}\n\nstatic int bnx2x_get_cmng_fns_mode(struct bnx2x *bp)\n{\n\tif (CHIP_REV_IS_SLOW(bp))\n\t\treturn CMNG_FNS_NONE;\n\tif (IS_MF(bp))\n\t\treturn CMNG_FNS_MINMAX;\n\n\treturn CMNG_FNS_NONE;\n}\n\nvoid bnx2x_read_mf_cfg(struct bnx2x *bp)\n{\n\tint vn, n = (CHIP_MODE_IS_4_PORT(bp) ? 2 : 1);\n\n\tif (BP_NOMCP(bp))\n\t\treturn; /* what should be the default value in this case */\n\n\t/* For 2 port configuration the absolute function number formula\n\t * is:\n\t *      abs_func = 2 * vn + BP_PORT + BP_PATH\n\t *\n\t *      and there are 4 functions per port\n\t *\n\t * For 4 port configuration it is\n\t *      abs_func = 4 * vn + 2 * BP_PORT + BP_PATH\n\t *\n\t *      and there are 2 functions per port\n\t */\n\tfor (vn = VN_0; vn < BP_MAX_VN_NUM(bp); vn++) {\n\t\tint /*abs*/func = n * (2 * vn + BP_PORT(bp)) + BP_PATH(bp);\n\n\t\tif (func >= E1H_FUNC_MAX)\n\t\t\tbreak;\n\n\t\tbp->mf_config[vn] =\n\t\t\tMF_CFG_RD(bp, func_mf_config[func].config);\n\t}\n\tif (bp->mf_config[BP_VN(bp)] & FUNC_MF_CFG_FUNC_DISABLED) {\n\t\tDP(NETIF_MSG_IFUP, \"mf_cfg function disabled\\n\");\n\t\tbp->flags |= MF_FUNC_DIS;\n\t} else {\n\t\tDP(NETIF_MSG_IFUP, \"mf_cfg function enabled\\n\");\n\t\tbp->flags &= ~MF_FUNC_DIS;\n\t}\n}\n\nstatic void bnx2x_cmng_fns_init(struct bnx2x *bp, u8 read_cfg, u8 cmng_type)\n{\n\tstruct cmng_init_input input;\n\tmemset(&input, 0, sizeof(struct cmng_init_input));\n\n\tinput.port_rate = bp->link_vars.line_speed;\n\n\tif (cmng_type == CMNG_FNS_MINMAX && input.port_rate) {\n\t\tint vn;\n\n\t\t/* read mf conf from shmem */\n\t\tif (read_cfg)\n\t\t\tbnx2x_read_mf_cfg(bp);\n\n\t\t/* vn_weight_sum and enable fairness if not 0 */\n\t\tbnx2x_calc_vn_min(bp, &input);\n\n\t\t/* calculate and set min-max rate for each vn */\n\t\tif (bp->port.pmf)\n\t\t\tfor (vn = VN_0; vn < BP_MAX_VN_NUM(bp); vn++)\n\t\t\t\tbnx2x_calc_vn_max(bp, vn, &input);\n\n\t\t/* always enable rate shaping and fairness */\n\t\tinput.flags.cmng_enables |=\n\t\t\t\t\tCMNG_FLAGS_PER_PORT_RATE_SHAPING_VN;\n\n\t\tbnx2x_init_cmng(&input, &bp->cmng);\n\t\treturn;\n\t}\n\n\t/* rate shaping and fairness are disabled */\n\tDP(NETIF_MSG_IFUP,\n\t   \"rate shaping and fairness are disabled\\n\");\n}\n\nstatic void storm_memset_cmng(struct bnx2x *bp,\n\t\t\t      struct cmng_init *cmng,\n\t\t\t      u8 port)\n{\n\tint vn;\n\tsize_t size = sizeof(struct cmng_struct_per_port);\n\n\tu32 addr = BAR_XSTRORM_INTMEM +\n\t\t\tXSTORM_CMNG_PER_PORT_VARS_OFFSET(port);\n\n\t__storm_memset_struct(bp, addr, size, (u32 *)&cmng->port);\n\n\tfor (vn = VN_0; vn < BP_MAX_VN_NUM(bp); vn++) {\n\t\tint func = func_by_vn(bp, vn);\n\n\t\taddr = BAR_XSTRORM_INTMEM +\n\t\t       XSTORM_RATE_SHAPING_PER_VN_VARS_OFFSET(func);\n\t\tsize = sizeof(struct rate_shaping_vars_per_vn);\n\t\t__storm_memset_struct(bp, addr, size,\n\t\t\t\t      (u32 *)&cmng->vnic.vnic_max_rate[vn]);\n\n\t\taddr = BAR_XSTRORM_INTMEM +\n\t\t       XSTORM_FAIRNESS_PER_VN_VARS_OFFSET(func);\n\t\tsize = sizeof(struct fairness_vars_per_vn);\n\t\t__storm_memset_struct(bp, addr, size,\n\t\t\t\t      (u32 *)&cmng->vnic.vnic_min_rate[vn]);\n\t}\n}\n\n/* init cmng mode in HW according to local configuration */\nvoid bnx2x_set_local_cmng(struct bnx2x *bp)\n{\n\tint cmng_fns = bnx2x_get_cmng_fns_mode(bp);\n\n\tif (cmng_fns != CMNG_FNS_NONE) {\n\t\tbnx2x_cmng_fns_init(bp, false, cmng_fns);\n\t\tstorm_memset_cmng(bp, &bp->cmng, BP_PORT(bp));\n\t} else {\n\t\t/* rate shaping and fairness are disabled */\n\t\tDP(NETIF_MSG_IFUP,\n\t\t   \"single function mode without fairness\\n\");\n\t}\n}\n\n/* This function is called upon link interrupt */\nstatic void bnx2x_link_attn(struct bnx2x *bp)\n{\n\t/* Make sure that we are synced with the current statistics */\n\tbnx2x_stats_handle(bp, STATS_EVENT_STOP);\n\n\tbnx2x_link_update(&bp->link_params, &bp->link_vars);\n\n\tbnx2x_init_dropless_fc(bp);\n\n\tif (bp->link_vars.link_up) {\n\n\t\tif (bp->link_vars.mac_type != MAC_TYPE_EMAC) {\n\t\t\tstruct host_port_stats *pstats;\n\n\t\t\tpstats = bnx2x_sp(bp, port_stats);\n\t\t\t/* reset old mac stats */\n\t\t\tmemset(&(pstats->mac_stx[0]), 0,\n\t\t\t       sizeof(struct mac_stx));\n\t\t}\n\t\tif (bp->state == BNX2X_STATE_OPEN)\n\t\t\tbnx2x_stats_handle(bp, STATS_EVENT_LINK_UP);\n\t}\n\n\tif (bp->link_vars.link_up && bp->link_vars.line_speed)\n\t\tbnx2x_set_local_cmng(bp);\n\n\t__bnx2x_link_report(bp);\n\n\tif (IS_MF(bp))\n\t\tbnx2x_link_sync_notify(bp);\n}\n\nvoid bnx2x__link_status_update(struct bnx2x *bp)\n{\n\tif (bp->state != BNX2X_STATE_OPEN)\n\t\treturn;\n\n\t/* read updated dcb configuration */\n\tif (IS_PF(bp)) {\n\t\tbnx2x_dcbx_pmf_update(bp);\n\t\tbnx2x_link_status_update(&bp->link_params, &bp->link_vars);\n\t\tif (bp->link_vars.link_up)\n\t\t\tbnx2x_stats_handle(bp, STATS_EVENT_LINK_UP);\n\t\telse\n\t\t\tbnx2x_stats_handle(bp, STATS_EVENT_STOP);\n\t\t\t/* indicate link status */\n\t\tbnx2x_link_report(bp);\n\n\t} else { /* VF */\n\t\tbp->port.supported[0] |= (SUPPORTED_10baseT_Half |\n\t\t\t\t\t  SUPPORTED_10baseT_Full |\n\t\t\t\t\t  SUPPORTED_100baseT_Half |\n\t\t\t\t\t  SUPPORTED_100baseT_Full |\n\t\t\t\t\t  SUPPORTED_1000baseT_Full |\n\t\t\t\t\t  SUPPORTED_2500baseX_Full |\n\t\t\t\t\t  SUPPORTED_10000baseT_Full |\n\t\t\t\t\t  SUPPORTED_TP |\n\t\t\t\t\t  SUPPORTED_FIBRE |\n\t\t\t\t\t  SUPPORTED_Autoneg |\n\t\t\t\t\t  SUPPORTED_Pause |\n\t\t\t\t\t  SUPPORTED_Asym_Pause);\n\t\tbp->port.advertising[0] = bp->port.supported[0];\n\n\t\tbp->link_params.bp = bp;\n\t\tbp->link_params.port = BP_PORT(bp);\n\t\tbp->link_params.req_duplex[0] = DUPLEX_FULL;\n\t\tbp->link_params.req_flow_ctrl[0] = BNX2X_FLOW_CTRL_NONE;\n\t\tbp->link_params.req_line_speed[0] = SPEED_10000;\n\t\tbp->link_params.speed_cap_mask[0] = 0x7f0000;\n\t\tbp->link_params.switch_cfg = SWITCH_CFG_10G;\n\t\tbp->link_vars.mac_type = MAC_TYPE_BMAC;\n\t\tbp->link_vars.line_speed = SPEED_10000;\n\t\tbp->link_vars.link_status =\n\t\t\t(LINK_STATUS_LINK_UP |\n\t\t\t LINK_STATUS_SPEED_AND_DUPLEX_10GTFD);\n\t\tbp->link_vars.link_up = 1;\n\t\tbp->link_vars.duplex = DUPLEX_FULL;\n\t\tbp->link_vars.flow_ctrl = BNX2X_FLOW_CTRL_NONE;\n\t\t__bnx2x_link_report(bp);\n\n\t\tbnx2x_sample_bulletin(bp);\n\n\t\t/* if bulletin board did not have an update for link status\n\t\t * __bnx2x_link_report will report current status\n\t\t * but it will NOT duplicate report in case of already reported\n\t\t * during sampling bulletin board.\n\t\t */\n\t\tbnx2x_stats_handle(bp, STATS_EVENT_LINK_UP);\n\t}\n}\n\nstatic int bnx2x_afex_func_update(struct bnx2x *bp, u16 vifid,\n\t\t\t\t  u16 vlan_val, u8 allowed_prio)\n{\n\tstruct bnx2x_func_state_params func_params = {NULL};\n\tstruct bnx2x_func_afex_update_params *f_update_params =\n\t\t&func_params.params.afex_update;\n\n\tfunc_params.f_obj = &bp->func_obj;\n\tfunc_params.cmd = BNX2X_F_CMD_AFEX_UPDATE;\n\n\t/* no need to wait for RAMROD completion, so don't\n\t * set RAMROD_COMP_WAIT flag\n\t */\n\n\tf_update_params->vif_id = vifid;\n\tf_update_params->afex_default_vlan = vlan_val;\n\tf_update_params->allowed_priorities = allowed_prio;\n\n\t/* if ramrod can not be sent, response to MCP immediately */\n\tif (bnx2x_func_state_change(bp, &func_params) < 0)\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_AFEX_VIFSET_ACK, 0);\n\n\treturn 0;\n}\n\nstatic int bnx2x_afex_handle_vif_list_cmd(struct bnx2x *bp, u8 cmd_type,\n\t\t\t\t\t  u16 vif_index, u8 func_bit_map)\n{\n\tstruct bnx2x_func_state_params func_params = {NULL};\n\tstruct bnx2x_func_afex_viflists_params *update_params =\n\t\t&func_params.params.afex_viflists;\n\tint rc;\n\tu32 drv_msg_code;\n\n\t/* validate only LIST_SET and LIST_GET are received from switch */\n\tif ((cmd_type != VIF_LIST_RULE_GET) && (cmd_type != VIF_LIST_RULE_SET))\n\t\tBNX2X_ERR(\"BUG! afex_handle_vif_list_cmd invalid type 0x%x\\n\",\n\t\t\t  cmd_type);\n\n\tfunc_params.f_obj = &bp->func_obj;\n\tfunc_params.cmd = BNX2X_F_CMD_AFEX_VIFLISTS;\n\n\t/* set parameters according to cmd_type */\n\tupdate_params->afex_vif_list_command = cmd_type;\n\tupdate_params->vif_list_index = vif_index;\n\tupdate_params->func_bit_map =\n\t\t(cmd_type == VIF_LIST_RULE_GET) ? 0 : func_bit_map;\n\tupdate_params->func_to_clear = 0;\n\tdrv_msg_code =\n\t\t(cmd_type == VIF_LIST_RULE_GET) ?\n\t\tDRV_MSG_CODE_AFEX_LISTGET_ACK :\n\t\tDRV_MSG_CODE_AFEX_LISTSET_ACK;\n\n\t/* if ramrod can not be sent, respond to MCP immediately for\n\t * SET and GET requests (other are not triggered from MCP)\n\t */\n\trc = bnx2x_func_state_change(bp, &func_params);\n\tif (rc < 0)\n\t\tbnx2x_fw_command(bp, drv_msg_code, 0);\n\n\treturn 0;\n}\n\nstatic void bnx2x_handle_afex_cmd(struct bnx2x *bp, u32 cmd)\n{\n\tstruct afex_stats afex_stats;\n\tu32 func = BP_ABS_FUNC(bp);\n\tu32 mf_config;\n\tu16 vlan_val;\n\tu32 vlan_prio;\n\tu16 vif_id;\n\tu8 allowed_prio;\n\tu8 vlan_mode;\n\tu32 addr_to_write, vifid, addrs, stats_type, i;\n\n\tif (cmd & DRV_STATUS_AFEX_LISTGET_REQ) {\n\t\tvifid = SHMEM2_RD(bp, afex_param1_to_driver[BP_FW_MB_IDX(bp)]);\n\t\tDP(BNX2X_MSG_MCP,\n\t\t   \"afex: got MCP req LISTGET_REQ for vifid 0x%x\\n\", vifid);\n\t\tbnx2x_afex_handle_vif_list_cmd(bp, VIF_LIST_RULE_GET, vifid, 0);\n\t}\n\n\tif (cmd & DRV_STATUS_AFEX_LISTSET_REQ) {\n\t\tvifid = SHMEM2_RD(bp, afex_param1_to_driver[BP_FW_MB_IDX(bp)]);\n\t\taddrs = SHMEM2_RD(bp, afex_param2_to_driver[BP_FW_MB_IDX(bp)]);\n\t\tDP(BNX2X_MSG_MCP,\n\t\t   \"afex: got MCP req LISTSET_REQ for vifid 0x%x addrs 0x%x\\n\",\n\t\t   vifid, addrs);\n\t\tbnx2x_afex_handle_vif_list_cmd(bp, VIF_LIST_RULE_SET, vifid,\n\t\t\t\t\t       addrs);\n\t}\n\n\tif (cmd & DRV_STATUS_AFEX_STATSGET_REQ) {\n\t\taddr_to_write = SHMEM2_RD(bp,\n\t\t\tafex_scratchpad_addr_to_write[BP_FW_MB_IDX(bp)]);\n\t\tstats_type = SHMEM2_RD(bp,\n\t\t\tafex_param1_to_driver[BP_FW_MB_IDX(bp)]);\n\n\t\tDP(BNX2X_MSG_MCP,\n\t\t   \"afex: got MCP req STATSGET_REQ, write to addr 0x%x\\n\",\n\t\t   addr_to_write);\n\n\t\tbnx2x_afex_collect_stats(bp, (void *)&afex_stats, stats_type);\n\n\t\t/* write response to scratchpad, for MCP */\n\t\tfor (i = 0; i < (sizeof(struct afex_stats)/sizeof(u32)); i++)\n\t\t\tREG_WR(bp, addr_to_write + i*sizeof(u32),\n\t\t\t       *(((u32 *)(&afex_stats))+i));\n\n\t\t/* send ack message to MCP */\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_AFEX_STATSGET_ACK, 0);\n\t}\n\n\tif (cmd & DRV_STATUS_AFEX_VIFSET_REQ) {\n\t\tmf_config = MF_CFG_RD(bp, func_mf_config[func].config);\n\t\tbp->mf_config[BP_VN(bp)] = mf_config;\n\t\tDP(BNX2X_MSG_MCP,\n\t\t   \"afex: got MCP req VIFSET_REQ, mf_config 0x%x\\n\",\n\t\t   mf_config);\n\n\t\t/* if VIF_SET is \"enabled\" */\n\t\tif (!(mf_config & FUNC_MF_CFG_FUNC_DISABLED)) {\n\t\t\t/* set rate limit directly to internal RAM */\n\t\t\tstruct cmng_init_input cmng_input;\n\t\t\tstruct rate_shaping_vars_per_vn m_rs_vn;\n\t\t\tsize_t size = sizeof(struct rate_shaping_vars_per_vn);\n\t\t\tu32 addr = BAR_XSTRORM_INTMEM +\n\t\t\t    XSTORM_RATE_SHAPING_PER_VN_VARS_OFFSET(BP_FUNC(bp));\n\n\t\t\tbp->mf_config[BP_VN(bp)] = mf_config;\n\n\t\t\tbnx2x_calc_vn_max(bp, BP_VN(bp), &cmng_input);\n\t\t\tm_rs_vn.vn_counter.rate =\n\t\t\t\tcmng_input.vnic_max_rate[BP_VN(bp)];\n\t\t\tm_rs_vn.vn_counter.quota =\n\t\t\t\t(m_rs_vn.vn_counter.rate *\n\t\t\t\t RS_PERIODIC_TIMEOUT_USEC) / 8;\n\n\t\t\t__storm_memset_struct(bp, addr, size, (u32 *)&m_rs_vn);\n\n\t\t\t/* read relevant values from mf_cfg struct in shmem */\n\t\t\tvif_id =\n\t\t\t\t(MF_CFG_RD(bp, func_mf_config[func].e1hov_tag) &\n\t\t\t\t FUNC_MF_CFG_E1HOV_TAG_MASK) >>\n\t\t\t\tFUNC_MF_CFG_E1HOV_TAG_SHIFT;\n\t\t\tvlan_val =\n\t\t\t\t(MF_CFG_RD(bp, func_mf_config[func].e1hov_tag) &\n\t\t\t\t FUNC_MF_CFG_AFEX_VLAN_MASK) >>\n\t\t\t\tFUNC_MF_CFG_AFEX_VLAN_SHIFT;\n\t\t\tvlan_prio = (mf_config &\n\t\t\t\t     FUNC_MF_CFG_TRANSMIT_PRIORITY_MASK) >>\n\t\t\t\t    FUNC_MF_CFG_TRANSMIT_PRIORITY_SHIFT;\n\t\t\tvlan_val |= (vlan_prio << VLAN_PRIO_SHIFT);\n\t\t\tvlan_mode =\n\t\t\t\t(MF_CFG_RD(bp,\n\t\t\t\t\t   func_mf_config[func].afex_config) &\n\t\t\t\t FUNC_MF_CFG_AFEX_VLAN_MODE_MASK) >>\n\t\t\t\tFUNC_MF_CFG_AFEX_VLAN_MODE_SHIFT;\n\t\t\tallowed_prio =\n\t\t\t\t(MF_CFG_RD(bp,\n\t\t\t\t\t   func_mf_config[func].afex_config) &\n\t\t\t\t FUNC_MF_CFG_AFEX_COS_FILTER_MASK) >>\n\t\t\t\tFUNC_MF_CFG_AFEX_COS_FILTER_SHIFT;\n\n\t\t\t/* send ramrod to FW, return in case of failure */\n\t\t\tif (bnx2x_afex_func_update(bp, vif_id, vlan_val,\n\t\t\t\t\t\t   allowed_prio))\n\t\t\t\treturn;\n\n\t\t\tbp->afex_def_vlan_tag = vlan_val;\n\t\t\tbp->afex_vlan_mode = vlan_mode;\n\t\t} else {\n\t\t\t/* notify link down because BP->flags is disabled */\n\t\t\tbnx2x_link_report(bp);\n\n\t\t\t/* send INVALID VIF ramrod to FW */\n\t\t\tbnx2x_afex_func_update(bp, 0xFFFF, 0, 0);\n\n\t\t\t/* Reset the default afex VLAN */\n\t\t\tbp->afex_def_vlan_tag = -1;\n\t\t}\n\t}\n}\n\nstatic void bnx2x_handle_update_svid_cmd(struct bnx2x *bp)\n{\n\tstruct bnx2x_func_switch_update_params *switch_update_params;\n\tstruct bnx2x_func_state_params func_params;\n\n\tmemset(&func_params, 0, sizeof(struct bnx2x_func_state_params));\n\tswitch_update_params = &func_params.params.switch_update;\n\tfunc_params.f_obj = &bp->func_obj;\n\tfunc_params.cmd = BNX2X_F_CMD_SWITCH_UPDATE;\n\n\t/* Prepare parameters for function state transitions */\n\t__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\n\t__set_bit(RAMROD_RETRY, &func_params.ramrod_flags);\n\n\tif (IS_MF_UFP(bp) || IS_MF_BD(bp)) {\n\t\tint func = BP_ABS_FUNC(bp);\n\t\tu32 val;\n\n\t\t/* Re-learn the S-tag from shmem */\n\t\tval = MF_CFG_RD(bp, func_mf_config[func].e1hov_tag) &\n\t\t\t\tFUNC_MF_CFG_E1HOV_TAG_MASK;\n\t\tif (val != FUNC_MF_CFG_E1HOV_TAG_DEFAULT) {\n\t\t\tbp->mf_ov = val;\n\t\t} else {\n\t\t\tBNX2X_ERR(\"Got an SVID event, but no tag is configured in shmem\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* Configure new S-tag in LLH */\n\t\tREG_WR(bp, NIG_REG_LLH0_FUNC_VLAN_ID + BP_PORT(bp) * 8,\n\t\t       bp->mf_ov);\n\n\t\t/* Send Ramrod to update FW of change */\n\t\t__set_bit(BNX2X_F_UPDATE_SD_VLAN_TAG_CHNG,\n\t\t\t  &switch_update_params->changes);\n\t\tswitch_update_params->vlan = bp->mf_ov;\n\n\t\tif (bnx2x_func_state_change(bp, &func_params) < 0) {\n\t\t\tBNX2X_ERR(\"Failed to configure FW of S-tag Change to %02x\\n\",\n\t\t\t\t  bp->mf_ov);\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tDP(BNX2X_MSG_MCP, \"Configured S-tag %02x\\n\",\n\t\t\t   bp->mf_ov);\n\t\t}\n\t} else {\n\t\tgoto fail;\n\t}\n\n\tbnx2x_fw_command(bp, DRV_MSG_CODE_OEM_UPDATE_SVID_OK, 0);\n\treturn;\nfail:\n\tbnx2x_fw_command(bp, DRV_MSG_CODE_OEM_UPDATE_SVID_FAILURE, 0);\n}\n\nstatic void bnx2x_pmf_update(struct bnx2x *bp)\n{\n\tint port = BP_PORT(bp);\n\tu32 val;\n\n\tbp->port.pmf = 1;\n\tDP(BNX2X_MSG_MCP, \"pmf %d\\n\", bp->port.pmf);\n\n\t/*\n\t * We need the mb() to ensure the ordering between the writing to\n\t * bp->port.pmf here and reading it from the bnx2x_periodic_task().\n\t */\n\tsmp_mb();\n\n\t/* queue a periodic task */\n\tqueue_delayed_work(bnx2x_wq, &bp->period_task, 0);\n\n\tbnx2x_dcbx_pmf_update(bp);\n\n\t/* enable nig attention */\n\tval = (0xff0f | (1 << (BP_VN(bp) + 4)));\n\tif (bp->common.int_block == INT_BLOCK_HC) {\n\t\tREG_WR(bp, HC_REG_TRAILING_EDGE_0 + port*8, val);\n\t\tREG_WR(bp, HC_REG_LEADING_EDGE_0 + port*8, val);\n\t} else if (!CHIP_IS_E1x(bp)) {\n\t\tREG_WR(bp, IGU_REG_TRAILING_EDGE_LATCH, val);\n\t\tREG_WR(bp, IGU_REG_LEADING_EDGE_LATCH, val);\n\t}\n\n\tbnx2x_stats_handle(bp, STATS_EVENT_PMF);\n}\n\n/* end of Link */\n\n/* slow path */\n\n/*\n * General service functions\n */\n\n/* send the MCP a request, block until there is a reply */\nu32 bnx2x_fw_command(struct bnx2x *bp, u32 command, u32 param)\n{\n\tint mb_idx = BP_FW_MB_IDX(bp);\n\tu32 seq;\n\tu32 rc = 0;\n\tu32 cnt = 1;\n\tu8 delay = CHIP_REV_IS_SLOW(bp) ? 100 : 10;\n\n\tmutex_lock(&bp->fw_mb_mutex);\n\tseq = ++bp->fw_seq;\n\tSHMEM_WR(bp, func_mb[mb_idx].drv_mb_param, param);\n\tSHMEM_WR(bp, func_mb[mb_idx].drv_mb_header, (command | seq));\n\n\tDP(BNX2X_MSG_MCP, \"wrote command (%x) to FW MB param 0x%08x\\n\",\n\t\t\t(command | seq), param);\n\n\tdo {\n\t\t/* let the FW do it's magic ... */\n\t\tmsleep(delay);\n\n\t\trc = SHMEM_RD(bp, func_mb[mb_idx].fw_mb_header);\n\n\t\t/* Give the FW up to 5 second (500*10ms) */\n\t} while ((seq != (rc & FW_MSG_SEQ_NUMBER_MASK)) && (cnt++ < 500));\n\n\tDP(BNX2X_MSG_MCP, \"[after %d ms] read (%x) seq is (%x) from FW MB\\n\",\n\t   cnt*delay, rc, seq);\n\n\t/* is this a reply to our command? */\n\tif (seq == (rc & FW_MSG_SEQ_NUMBER_MASK))\n\t\trc &= FW_MSG_CODE_MASK;\n\telse {\n\t\t/* FW BUG! */\n\t\tBNX2X_ERR(\"FW failed to respond!\\n\");\n\t\tbnx2x_fw_dump(bp);\n\t\trc = 0;\n\t}\n\tmutex_unlock(&bp->fw_mb_mutex);\n\n\treturn rc;\n}\n\nstatic void storm_memset_func_cfg(struct bnx2x *bp,\n\t\t\t\t struct tstorm_eth_function_common_config *tcfg,\n\t\t\t\t u16 abs_fid)\n{\n\tsize_t size = sizeof(struct tstorm_eth_function_common_config);\n\n\tu32 addr = BAR_TSTRORM_INTMEM +\n\t\t\tTSTORM_FUNCTION_COMMON_CONFIG_OFFSET(abs_fid);\n\n\t__storm_memset_struct(bp, addr, size, (u32 *)tcfg);\n}\n\nvoid bnx2x_func_init(struct bnx2x *bp, struct bnx2x_func_init_params *p)\n{\n\tif (CHIP_IS_E1x(bp)) {\n\t\tstruct tstorm_eth_function_common_config tcfg = {0};\n\n\t\tstorm_memset_func_cfg(bp, &tcfg, p->func_id);\n\t}\n\n\t/* Enable the function in the FW */\n\tstorm_memset_vf_to_pf(bp, p->func_id, p->pf_id);\n\tstorm_memset_func_en(bp, p->func_id, 1);\n\n\t/* spq */\n\tif (p->spq_active) {\n\t\tstorm_memset_spq_addr(bp, p->spq_map, p->func_id);\n\t\tREG_WR(bp, XSEM_REG_FAST_MEMORY +\n\t\t       XSTORM_SPQ_PROD_OFFSET(p->func_id), p->spq_prod);\n\t}\n}\n\n/**\n * bnx2x_get_common_flags - Return common flags\n *\n * @bp:\t\tdevice handle\n * @fp:\t\tqueue handle\n * @zero_stats:\tTRUE if statistics zeroing is needed\n *\n * Return the flags that are common for the Tx-only and not normal connections.\n */\nstatic unsigned long bnx2x_get_common_flags(struct bnx2x *bp,\n\t\t\t\t\t    struct bnx2x_fastpath *fp,\n\t\t\t\t\t    bool zero_stats)\n{\n\tunsigned long flags = 0;\n\n\t/* PF driver will always initialize the Queue to an ACTIVE state */\n\t__set_bit(BNX2X_Q_FLG_ACTIVE, &flags);\n\n\t/* tx only connections collect statistics (on the same index as the\n\t * parent connection). The statistics are zeroed when the parent\n\t * connection is initialized.\n\t */\n\n\t__set_bit(BNX2X_Q_FLG_STATS, &flags);\n\tif (zero_stats)\n\t\t__set_bit(BNX2X_Q_FLG_ZERO_STATS, &flags);\n\n\tif (bp->flags & TX_SWITCHING)\n\t\t__set_bit(BNX2X_Q_FLG_TX_SWITCH, &flags);\n\n\t__set_bit(BNX2X_Q_FLG_PCSUM_ON_PKT, &flags);\n\t__set_bit(BNX2X_Q_FLG_TUN_INC_INNER_IP_ID, &flags);\n\n#ifdef BNX2X_STOP_ON_ERROR\n\t__set_bit(BNX2X_Q_FLG_TX_SEC, &flags);\n#endif\n\n\treturn flags;\n}\n\nstatic unsigned long bnx2x_get_q_flags(struct bnx2x *bp,\n\t\t\t\t       struct bnx2x_fastpath *fp,\n\t\t\t\t       bool leading)\n{\n\tunsigned long flags = 0;\n\n\t/* calculate other queue flags */\n\tif (IS_MF_SD(bp))\n\t\t__set_bit(BNX2X_Q_FLG_OV, &flags);\n\n\tif (IS_FCOE_FP(fp)) {\n\t\t__set_bit(BNX2X_Q_FLG_FCOE, &flags);\n\t\t/* For FCoE - force usage of default priority (for afex) */\n\t\t__set_bit(BNX2X_Q_FLG_FORCE_DEFAULT_PRI, &flags);\n\t}\n\n\tif (fp->mode != TPA_MODE_DISABLED) {\n\t\t__set_bit(BNX2X_Q_FLG_TPA, &flags);\n\t\t__set_bit(BNX2X_Q_FLG_TPA_IPV6, &flags);\n\t\tif (fp->mode == TPA_MODE_GRO)\n\t\t\t__set_bit(BNX2X_Q_FLG_TPA_GRO, &flags);\n\t}\n\n\tif (leading) {\n\t\t__set_bit(BNX2X_Q_FLG_LEADING_RSS, &flags);\n\t\t__set_bit(BNX2X_Q_FLG_MCAST, &flags);\n\t}\n\n\t/* Always set HW VLAN stripping */\n\t__set_bit(BNX2X_Q_FLG_VLAN, &flags);\n\n\t/* configure silent vlan removal */\n\tif (IS_MF_AFEX(bp))\n\t\t__set_bit(BNX2X_Q_FLG_SILENT_VLAN_REM, &flags);\n\n\treturn flags | bnx2x_get_common_flags(bp, fp, true);\n}\n\nstatic void bnx2x_pf_q_prep_general(struct bnx2x *bp,\n\tstruct bnx2x_fastpath *fp, struct bnx2x_general_setup_params *gen_init,\n\tu8 cos)\n{\n\tgen_init->stat_id = bnx2x_stats_id(fp);\n\tgen_init->spcl_id = fp->cl_id;\n\n\t/* Always use mini-jumbo MTU for FCoE L2 ring */\n\tif (IS_FCOE_FP(fp))\n\t\tgen_init->mtu = BNX2X_FCOE_MINI_JUMBO_MTU;\n\telse\n\t\tgen_init->mtu = bp->dev->mtu;\n\n\tgen_init->cos = cos;\n\n\tgen_init->fp_hsi = ETH_FP_HSI_VERSION;\n}\n\nstatic void bnx2x_pf_rx_q_prep(struct bnx2x *bp,\n\tstruct bnx2x_fastpath *fp, struct rxq_pause_params *pause,\n\tstruct bnx2x_rxq_setup_params *rxq_init)\n{\n\tu8 max_sge = 0;\n\tu16 sge_sz = 0;\n\tu16 tpa_agg_size = 0;\n\n\tif (fp->mode != TPA_MODE_DISABLED) {\n\t\tpause->sge_th_lo = SGE_TH_LO(bp);\n\t\tpause->sge_th_hi = SGE_TH_HI(bp);\n\n\t\t/* validate SGE ring has enough to cross high threshold */\n\t\tWARN_ON(bp->dropless_fc &&\n\t\t\t\tpause->sge_th_hi + FW_PREFETCH_CNT >\n\t\t\t\tMAX_RX_SGE_CNT * NUM_RX_SGE_PAGES);\n\n\t\ttpa_agg_size = TPA_AGG_SIZE;\n\t\tmax_sge = SGE_PAGE_ALIGN(bp->dev->mtu) >>\n\t\t\tSGE_PAGE_SHIFT;\n\t\tmax_sge = ((max_sge + PAGES_PER_SGE - 1) &\n\t\t\t  (~(PAGES_PER_SGE-1))) >> PAGES_PER_SGE_SHIFT;\n\t\tsge_sz = (u16)min_t(u32, SGE_PAGES, 0xffff);\n\t}\n\n\t/* pause - not for e1 */\n\tif (!CHIP_IS_E1(bp)) {\n\t\tpause->bd_th_lo = BD_TH_LO(bp);\n\t\tpause->bd_th_hi = BD_TH_HI(bp);\n\n\t\tpause->rcq_th_lo = RCQ_TH_LO(bp);\n\t\tpause->rcq_th_hi = RCQ_TH_HI(bp);\n\t\t/*\n\t\t * validate that rings have enough entries to cross\n\t\t * high thresholds\n\t\t */\n\t\tWARN_ON(bp->dropless_fc &&\n\t\t\t\tpause->bd_th_hi + FW_PREFETCH_CNT >\n\t\t\t\tbp->rx_ring_size);\n\t\tWARN_ON(bp->dropless_fc &&\n\t\t\t\tpause->rcq_th_hi + FW_PREFETCH_CNT >\n\t\t\t\tNUM_RCQ_RINGS * MAX_RCQ_DESC_CNT);\n\n\t\tpause->pri_map = 1;\n\t}\n\n\t/* rxq setup */\n\trxq_init->dscr_map = fp->rx_desc_mapping;\n\trxq_init->sge_map = fp->rx_sge_mapping;\n\trxq_init->rcq_map = fp->rx_comp_mapping;\n\trxq_init->rcq_np_map = fp->rx_comp_mapping + BCM_PAGE_SIZE;\n\n\t/* This should be a maximum number of data bytes that may be\n\t * placed on the BD (not including paddings).\n\t */\n\trxq_init->buf_sz = fp->rx_buf_size - BNX2X_FW_RX_ALIGN_START -\n\t\t\t   BNX2X_FW_RX_ALIGN_END - IP_HEADER_ALIGNMENT_PADDING;\n\n\trxq_init->cl_qzone_id = fp->cl_qzone_id;\n\trxq_init->tpa_agg_sz = tpa_agg_size;\n\trxq_init->sge_buf_sz = sge_sz;\n\trxq_init->max_sges_pkt = max_sge;\n\trxq_init->rss_engine_id = BP_FUNC(bp);\n\trxq_init->mcast_engine_id = BP_FUNC(bp);\n\n\t/* Maximum number or simultaneous TPA aggregation for this Queue.\n\t *\n\t * For PF Clients it should be the maximum available number.\n\t * VF driver(s) may want to define it to a smaller value.\n\t */\n\trxq_init->max_tpa_queues = MAX_AGG_QS(bp);\n\n\trxq_init->cache_line_log = BNX2X_RX_ALIGN_SHIFT;\n\trxq_init->fw_sb_id = fp->fw_sb_id;\n\n\tif (IS_FCOE_FP(fp))\n\t\trxq_init->sb_cq_index = HC_SP_INDEX_ETH_FCOE_RX_CQ_CONS;\n\telse\n\t\trxq_init->sb_cq_index = HC_INDEX_ETH_RX_CQ_CONS;\n\t/* configure silent vlan removal\n\t * if multi function mode is afex, then mask default vlan\n\t */\n\tif (IS_MF_AFEX(bp)) {\n\t\trxq_init->silent_removal_value = bp->afex_def_vlan_tag;\n\t\trxq_init->silent_removal_mask = VLAN_VID_MASK;\n\t}\n}\n\nstatic void bnx2x_pf_tx_q_prep(struct bnx2x *bp,\n\tstruct bnx2x_fastpath *fp, struct bnx2x_txq_setup_params *txq_init,\n\tu8 cos)\n{\n\ttxq_init->dscr_map = fp->txdata_ptr[cos]->tx_desc_mapping;\n\ttxq_init->sb_cq_index = HC_INDEX_ETH_FIRST_TX_CQ_CONS + cos;\n\ttxq_init->traffic_type = LLFC_TRAFFIC_TYPE_NW;\n\ttxq_init->fw_sb_id = fp->fw_sb_id;\n\n\t/*\n\t * set the tss leading client id for TX classification ==\n\t * leading RSS client id\n\t */\n\ttxq_init->tss_leading_cl_id = bnx2x_fp(bp, 0, cl_id);\n\n\tif (IS_FCOE_FP(fp)) {\n\t\ttxq_init->sb_cq_index = HC_SP_INDEX_ETH_FCOE_TX_CQ_CONS;\n\t\ttxq_init->traffic_type = LLFC_TRAFFIC_TYPE_FCOE;\n\t}\n}\n\nstatic void bnx2x_pf_init(struct bnx2x *bp)\n{\n\tstruct bnx2x_func_init_params func_init = {0};\n\tstruct event_ring_data eq_data = { {0} };\n\n\tif (!CHIP_IS_E1x(bp)) {\n\t\t/* reset IGU PF statistics: MSIX + ATTN */\n\t\t/* PF */\n\t\tREG_WR(bp, IGU_REG_STATISTIC_NUM_MESSAGE_SENT +\n\t\t\t   BNX2X_IGU_STAS_MSG_VF_CNT*4 +\n\t\t\t   (CHIP_MODE_IS_4_PORT(bp) ?\n\t\t\t\tBP_FUNC(bp) : BP_VN(bp))*4, 0);\n\t\t/* ATTN */\n\t\tREG_WR(bp, IGU_REG_STATISTIC_NUM_MESSAGE_SENT +\n\t\t\t   BNX2X_IGU_STAS_MSG_VF_CNT*4 +\n\t\t\t   BNX2X_IGU_STAS_MSG_PF_CNT*4 +\n\t\t\t   (CHIP_MODE_IS_4_PORT(bp) ?\n\t\t\t\tBP_FUNC(bp) : BP_VN(bp))*4, 0);\n\t}\n\n\tfunc_init.spq_active = true;\n\tfunc_init.pf_id = BP_FUNC(bp);\n\tfunc_init.func_id = BP_FUNC(bp);\n\tfunc_init.spq_map = bp->spq_mapping;\n\tfunc_init.spq_prod = bp->spq_prod_idx;\n\n\tbnx2x_func_init(bp, &func_init);\n\n\tmemset(&(bp->cmng), 0, sizeof(struct cmng_struct_per_port));\n\n\t/*\n\t * Congestion management values depend on the link rate\n\t * There is no active link so initial link rate is set to 10 Gbps.\n\t * When the link comes up The congestion management values are\n\t * re-calculated according to the actual link rate.\n\t */\n\tbp->link_vars.line_speed = SPEED_10000;\n\tbnx2x_cmng_fns_init(bp, true, bnx2x_get_cmng_fns_mode(bp));\n\n\t/* Only the PMF sets the HW */\n\tif (bp->port.pmf)\n\t\tstorm_memset_cmng(bp, &bp->cmng, BP_PORT(bp));\n\n\t/* init Event Queue - PCI bus guarantees correct endianity*/\n\teq_data.base_addr.hi = U64_HI(bp->eq_mapping);\n\teq_data.base_addr.lo = U64_LO(bp->eq_mapping);\n\teq_data.producer = bp->eq_prod;\n\teq_data.index_id = HC_SP_INDEX_EQ_CONS;\n\teq_data.sb_id = DEF_SB_ID;\n\tstorm_memset_eq_data(bp, &eq_data, BP_FUNC(bp));\n}\n\nstatic void bnx2x_e1h_disable(struct bnx2x *bp)\n{\n\tint port = BP_PORT(bp);\n\n\tbnx2x_tx_disable(bp);\n\n\tREG_WR(bp, NIG_REG_LLH0_FUNC_EN + port*8, 0);\n}\n\nstatic void bnx2x_e1h_enable(struct bnx2x *bp)\n{\n\tint port = BP_PORT(bp);\n\n\tif (!(IS_MF_UFP(bp) && BNX2X_IS_MF_SD_PROTOCOL_FCOE(bp)))\n\t\tREG_WR(bp, NIG_REG_LLH0_FUNC_EN + port * 8, 1);\n\n\t/* Tx queue should be only re-enabled */\n\tnetif_tx_wake_all_queues(bp->dev);\n\n\t/*\n\t * Should not call netif_carrier_on since it will be called if the link\n\t * is up when checking for link state\n\t */\n}\n\n#define DRV_INFO_ETH_STAT_NUM_MACS_REQUIRED 3\n\nstatic void bnx2x_drv_info_ether_stat(struct bnx2x *bp)\n{\n\tstruct eth_stats_info *ether_stat =\n\t\t&bp->slowpath->drv_info_to_mcp.ether_stat;\n\tstruct bnx2x_vlan_mac_obj *mac_obj =\n\t\t&bp->sp_objs->mac_obj;\n\tint i;\n\n\tstrlcpy(ether_stat->version, DRV_MODULE_VERSION,\n\t\tETH_STAT_INFO_VERSION_LEN);\n\n\t/* get DRV_INFO_ETH_STAT_NUM_MACS_REQUIRED macs, placing them in the\n\t * mac_local field in ether_stat struct. The base address is offset by 2\n\t * bytes to account for the field being 8 bytes but a mac address is\n\t * only 6 bytes. Likewise, the stride for the get_n_elements function is\n\t * 2 bytes to compensate from the 6 bytes of a mac to the 8 bytes\n\t * allocated by the ether_stat struct, so the macs will land in their\n\t * proper positions.\n\t */\n\tfor (i = 0; i < DRV_INFO_ETH_STAT_NUM_MACS_REQUIRED; i++)\n\t\tmemset(ether_stat->mac_local + i, 0,\n\t\t       sizeof(ether_stat->mac_local[0]));\n\tmac_obj->get_n_elements(bp, &bp->sp_objs[0].mac_obj,\n\t\t\t\tDRV_INFO_ETH_STAT_NUM_MACS_REQUIRED,\n\t\t\t\tether_stat->mac_local + MAC_PAD, MAC_PAD,\n\t\t\t\tETH_ALEN);\n\tether_stat->mtu_size = bp->dev->mtu;\n\tif (bp->dev->features & NETIF_F_RXCSUM)\n\t\tether_stat->feature_flags |= FEATURE_ETH_CHKSUM_OFFLOAD_MASK;\n\tif (bp->dev->features & NETIF_F_TSO)\n\t\tether_stat->feature_flags |= FEATURE_ETH_LSO_MASK;\n\tether_stat->feature_flags |= bp->common.boot_mode;\n\n\tether_stat->promiscuous_mode = (bp->dev->flags & IFF_PROMISC) ? 1 : 0;\n\n\tether_stat->txq_size = bp->tx_ring_size;\n\tether_stat->rxq_size = bp->rx_ring_size;\n\n#ifdef CONFIG_BNX2X_SRIOV\n\tether_stat->vf_cnt = IS_SRIOV(bp) ? bp->vfdb->sriov.nr_virtfn : 0;\n#endif\n}\n\nstatic void bnx2x_drv_info_fcoe_stat(struct bnx2x *bp)\n{\n\tstruct bnx2x_dcbx_app_params *app = &bp->dcbx_port_params.app;\n\tstruct fcoe_stats_info *fcoe_stat =\n\t\t&bp->slowpath->drv_info_to_mcp.fcoe_stat;\n\n\tif (!CNIC_LOADED(bp))\n\t\treturn;\n\n\tmemcpy(fcoe_stat->mac_local + MAC_PAD, bp->fip_mac, ETH_ALEN);\n\n\tfcoe_stat->qos_priority =\n\t\tapp->traffic_type_priority[LLFC_TRAFFIC_TYPE_FCOE];\n\n\t/* insert FCoE stats from ramrod response */\n\tif (!NO_FCOE(bp)) {\n\t\tstruct tstorm_per_queue_stats *fcoe_q_tstorm_stats =\n\t\t\t&bp->fw_stats_data->queue_stats[FCOE_IDX(bp)].\n\t\t\ttstorm_queue_statistics;\n\n\t\tstruct xstorm_per_queue_stats *fcoe_q_xstorm_stats =\n\t\t\t&bp->fw_stats_data->queue_stats[FCOE_IDX(bp)].\n\t\t\txstorm_queue_statistics;\n\n\t\tstruct fcoe_statistics_params *fw_fcoe_stat =\n\t\t\t&bp->fw_stats_data->fcoe;\n\n\t\tADD_64_LE(fcoe_stat->rx_bytes_hi, LE32_0,\n\t\t\t  fcoe_stat->rx_bytes_lo,\n\t\t\t  fw_fcoe_stat->rx_stat0.fcoe_rx_byte_cnt);\n\n\t\tADD_64_LE(fcoe_stat->rx_bytes_hi,\n\t\t\t  fcoe_q_tstorm_stats->rcv_ucast_bytes.hi,\n\t\t\t  fcoe_stat->rx_bytes_lo,\n\t\t\t  fcoe_q_tstorm_stats->rcv_ucast_bytes.lo);\n\n\t\tADD_64_LE(fcoe_stat->rx_bytes_hi,\n\t\t\t  fcoe_q_tstorm_stats->rcv_bcast_bytes.hi,\n\t\t\t  fcoe_stat->rx_bytes_lo,\n\t\t\t  fcoe_q_tstorm_stats->rcv_bcast_bytes.lo);\n\n\t\tADD_64_LE(fcoe_stat->rx_bytes_hi,\n\t\t\t  fcoe_q_tstorm_stats->rcv_mcast_bytes.hi,\n\t\t\t  fcoe_stat->rx_bytes_lo,\n\t\t\t  fcoe_q_tstorm_stats->rcv_mcast_bytes.lo);\n\n\t\tADD_64_LE(fcoe_stat->rx_frames_hi, LE32_0,\n\t\t\t  fcoe_stat->rx_frames_lo,\n\t\t\t  fw_fcoe_stat->rx_stat0.fcoe_rx_pkt_cnt);\n\n\t\tADD_64_LE(fcoe_stat->rx_frames_hi, LE32_0,\n\t\t\t  fcoe_stat->rx_frames_lo,\n\t\t\t  fcoe_q_tstorm_stats->rcv_ucast_pkts);\n\n\t\tADD_64_LE(fcoe_stat->rx_frames_hi, LE32_0,\n\t\t\t  fcoe_stat->rx_frames_lo,\n\t\t\t  fcoe_q_tstorm_stats->rcv_bcast_pkts);\n\n\t\tADD_64_LE(fcoe_stat->rx_frames_hi, LE32_0,\n\t\t\t  fcoe_stat->rx_frames_lo,\n\t\t\t  fcoe_q_tstorm_stats->rcv_mcast_pkts);\n\n\t\tADD_64_LE(fcoe_stat->tx_bytes_hi, LE32_0,\n\t\t\t  fcoe_stat->tx_bytes_lo,\n\t\t\t  fw_fcoe_stat->tx_stat.fcoe_tx_byte_cnt);\n\n\t\tADD_64_LE(fcoe_stat->tx_bytes_hi,\n\t\t\t  fcoe_q_xstorm_stats->ucast_bytes_sent.hi,\n\t\t\t  fcoe_stat->tx_bytes_lo,\n\t\t\t  fcoe_q_xstorm_stats->ucast_bytes_sent.lo);\n\n\t\tADD_64_LE(fcoe_stat->tx_bytes_hi,\n\t\t\t  fcoe_q_xstorm_stats->bcast_bytes_sent.hi,\n\t\t\t  fcoe_stat->tx_bytes_lo,\n\t\t\t  fcoe_q_xstorm_stats->bcast_bytes_sent.lo);\n\n\t\tADD_64_LE(fcoe_stat->tx_bytes_hi,\n\t\t\t  fcoe_q_xstorm_stats->mcast_bytes_sent.hi,\n\t\t\t  fcoe_stat->tx_bytes_lo,\n\t\t\t  fcoe_q_xstorm_stats->mcast_bytes_sent.lo);\n\n\t\tADD_64_LE(fcoe_stat->tx_frames_hi, LE32_0,\n\t\t\t  fcoe_stat->tx_frames_lo,\n\t\t\t  fw_fcoe_stat->tx_stat.fcoe_tx_pkt_cnt);\n\n\t\tADD_64_LE(fcoe_stat->tx_frames_hi, LE32_0,\n\t\t\t  fcoe_stat->tx_frames_lo,\n\t\t\t  fcoe_q_xstorm_stats->ucast_pkts_sent);\n\n\t\tADD_64_LE(fcoe_stat->tx_frames_hi, LE32_0,\n\t\t\t  fcoe_stat->tx_frames_lo,\n\t\t\t  fcoe_q_xstorm_stats->bcast_pkts_sent);\n\n\t\tADD_64_LE(fcoe_stat->tx_frames_hi, LE32_0,\n\t\t\t  fcoe_stat->tx_frames_lo,\n\t\t\t  fcoe_q_xstorm_stats->mcast_pkts_sent);\n\t}\n\n\t/* ask L5 driver to add data to the struct */\n\tbnx2x_cnic_notify(bp, CNIC_CTL_FCOE_STATS_GET_CMD);\n}\n\nstatic void bnx2x_drv_info_iscsi_stat(struct bnx2x *bp)\n{\n\tstruct bnx2x_dcbx_app_params *app = &bp->dcbx_port_params.app;\n\tstruct iscsi_stats_info *iscsi_stat =\n\t\t&bp->slowpath->drv_info_to_mcp.iscsi_stat;\n\n\tif (!CNIC_LOADED(bp))\n\t\treturn;\n\n\tmemcpy(iscsi_stat->mac_local + MAC_PAD, bp->cnic_eth_dev.iscsi_mac,\n\t       ETH_ALEN);\n\n\tiscsi_stat->qos_priority =\n\t\tapp->traffic_type_priority[LLFC_TRAFFIC_TYPE_ISCSI];\n\n\t/* ask L5 driver to add data to the struct */\n\tbnx2x_cnic_notify(bp, CNIC_CTL_ISCSI_STATS_GET_CMD);\n}\n\n/* called due to MCP event (on pmf):\n *\treread new bandwidth configuration\n *\tconfigure FW\n *\tnotify others function about the change\n */\nstatic void bnx2x_config_mf_bw(struct bnx2x *bp)\n{\n\t/* Workaround for MFW bug.\n\t * MFW is not supposed to generate BW attention in\n\t * single function mode.\n\t */\n\tif (!IS_MF(bp)) {\n\t\tDP(BNX2X_MSG_MCP,\n\t\t   \"Ignoring MF BW config in single function mode\\n\");\n\t\treturn;\n\t}\n\n\tif (bp->link_vars.link_up) {\n\t\tbnx2x_cmng_fns_init(bp, true, CMNG_FNS_MINMAX);\n\t\tbnx2x_link_sync_notify(bp);\n\t}\n\tstorm_memset_cmng(bp, &bp->cmng, BP_PORT(bp));\n}\n\nstatic void bnx2x_set_mf_bw(struct bnx2x *bp)\n{\n\tbnx2x_config_mf_bw(bp);\n\tbnx2x_fw_command(bp, DRV_MSG_CODE_SET_MF_BW_ACK, 0);\n}\n\nstatic void bnx2x_handle_eee_event(struct bnx2x *bp)\n{\n\tDP(BNX2X_MSG_MCP, \"EEE - LLDP event\\n\");\n\tbnx2x_fw_command(bp, DRV_MSG_CODE_EEE_RESULTS_ACK, 0);\n}\n\n#define BNX2X_UPDATE_DRV_INFO_IND_LENGTH\t(20)\n#define BNX2X_UPDATE_DRV_INFO_IND_COUNT\t\t(25)\n\nstatic void bnx2x_handle_drv_info_req(struct bnx2x *bp)\n{\n\tenum drv_info_opcode op_code;\n\tu32 drv_info_ctl = SHMEM2_RD(bp, drv_info_control);\n\tbool release = false;\n\tint wait;\n\n\t/* if drv_info version supported by MFW doesn't match - send NACK */\n\tif ((drv_info_ctl & DRV_INFO_CONTROL_VER_MASK) != DRV_INFO_CUR_VER) {\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_DRV_INFO_NACK, 0);\n\t\treturn;\n\t}\n\n\top_code = (drv_info_ctl & DRV_INFO_CONTROL_OP_CODE_MASK) >>\n\t\t  DRV_INFO_CONTROL_OP_CODE_SHIFT;\n\n\t/* Must prevent other flows from accessing drv_info_to_mcp */\n\tmutex_lock(&bp->drv_info_mutex);\n\n\tmemset(&bp->slowpath->drv_info_to_mcp, 0,\n\t       sizeof(union drv_info_to_mcp));\n\n\tswitch (op_code) {\n\tcase ETH_STATS_OPCODE:\n\t\tbnx2x_drv_info_ether_stat(bp);\n\t\tbreak;\n\tcase FCOE_STATS_OPCODE:\n\t\tbnx2x_drv_info_fcoe_stat(bp);\n\t\tbreak;\n\tcase ISCSI_STATS_OPCODE:\n\t\tbnx2x_drv_info_iscsi_stat(bp);\n\t\tbreak;\n\tdefault:\n\t\t/* if op code isn't supported - send NACK */\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_DRV_INFO_NACK, 0);\n\t\tgoto out;\n\t}\n\n\t/* if we got drv_info attn from MFW then these fields are defined in\n\t * shmem2 for sure\n\t */\n\tSHMEM2_WR(bp, drv_info_host_addr_lo,\n\t\tU64_LO(bnx2x_sp_mapping(bp, drv_info_to_mcp)));\n\tSHMEM2_WR(bp, drv_info_host_addr_hi,\n\t\tU64_HI(bnx2x_sp_mapping(bp, drv_info_to_mcp)));\n\n\tbnx2x_fw_command(bp, DRV_MSG_CODE_DRV_INFO_ACK, 0);\n\n\t/* Since possible management wants both this and get_driver_version\n\t * need to wait until management notifies us it finished utilizing\n\t * the buffer.\n\t */\n\tif (!SHMEM2_HAS(bp, mfw_drv_indication)) {\n\t\tDP(BNX2X_MSG_MCP, \"Management does not support indication\\n\");\n\t} else if (!bp->drv_info_mng_owner) {\n\t\tu32 bit = MFW_DRV_IND_READ_DONE_OFFSET((BP_ABS_FUNC(bp) >> 1));\n\n\t\tfor (wait = 0; wait < BNX2X_UPDATE_DRV_INFO_IND_COUNT; wait++) {\n\t\t\tu32 indication = SHMEM2_RD(bp, mfw_drv_indication);\n\n\t\t\t/* Management is done; need to clear indication */\n\t\t\tif (indication & bit) {\n\t\t\t\tSHMEM2_WR(bp, mfw_drv_indication,\n\t\t\t\t\t  indication & ~bit);\n\t\t\t\trelease = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmsleep(BNX2X_UPDATE_DRV_INFO_IND_LENGTH);\n\t\t}\n\t}\n\tif (!release) {\n\t\tDP(BNX2X_MSG_MCP, \"Management did not release indication\\n\");\n\t\tbp->drv_info_mng_owner = true;\n\t}\n\nout:\n\tmutex_unlock(&bp->drv_info_mutex);\n}\n\nstatic u32 bnx2x_update_mng_version_utility(u8 *version, bool bnx2x_format)\n{\n\tu8 vals[4];\n\tint i = 0;\n\n\tif (bnx2x_format) {\n\t\ti = sscanf(version, \"1.%c%hhd.%hhd.%hhd\",\n\t\t\t   &vals[0], &vals[1], &vals[2], &vals[3]);\n\t\tif (i > 0)\n\t\t\tvals[0] -= '0';\n\t} else {\n\t\ti = sscanf(version, \"%hhd.%hhd.%hhd.%hhd\",\n\t\t\t   &vals[0], &vals[1], &vals[2], &vals[3]);\n\t}\n\n\twhile (i < 4)\n\t\tvals[i++] = 0;\n\n\treturn (vals[0] << 24) | (vals[1] << 16) | (vals[2] << 8) | vals[3];\n}\n\nvoid bnx2x_update_mng_version(struct bnx2x *bp)\n{\n\tu32 iscsiver = DRV_VER_NOT_LOADED;\n\tu32 fcoever = DRV_VER_NOT_LOADED;\n\tu32 ethver = DRV_VER_NOT_LOADED;\n\tint idx = BP_FW_MB_IDX(bp);\n\tu8 *version;\n\n\tif (!SHMEM2_HAS(bp, func_os_drv_ver))\n\t\treturn;\n\n\tmutex_lock(&bp->drv_info_mutex);\n\t/* Must not proceed when `bnx2x_handle_drv_info_req' is feasible */\n\tif (bp->drv_info_mng_owner)\n\t\tgoto out;\n\n\tif (bp->state != BNX2X_STATE_OPEN)\n\t\tgoto out;\n\n\t/* Parse ethernet driver version */\n\tethver = bnx2x_update_mng_version_utility(DRV_MODULE_VERSION, true);\n\tif (!CNIC_LOADED(bp))\n\t\tgoto out;\n\n\t/* Try getting storage driver version via cnic */\n\tmemset(&bp->slowpath->drv_info_to_mcp, 0,\n\t       sizeof(union drv_info_to_mcp));\n\tbnx2x_drv_info_iscsi_stat(bp);\n\tversion = bp->slowpath->drv_info_to_mcp.iscsi_stat.version;\n\tiscsiver = bnx2x_update_mng_version_utility(version, false);\n\n\tmemset(&bp->slowpath->drv_info_to_mcp, 0,\n\t       sizeof(union drv_info_to_mcp));\n\tbnx2x_drv_info_fcoe_stat(bp);\n\tversion = bp->slowpath->drv_info_to_mcp.fcoe_stat.version;\n\tfcoever = bnx2x_update_mng_version_utility(version, false);\n\nout:\n\tSHMEM2_WR(bp, func_os_drv_ver[idx].versions[DRV_PERS_ETHERNET], ethver);\n\tSHMEM2_WR(bp, func_os_drv_ver[idx].versions[DRV_PERS_ISCSI], iscsiver);\n\tSHMEM2_WR(bp, func_os_drv_ver[idx].versions[DRV_PERS_FCOE], fcoever);\n\n\tmutex_unlock(&bp->drv_info_mutex);\n\n\tDP(BNX2X_MSG_MCP, \"Setting driver version: ETH [%08x] iSCSI [%08x] FCoE [%08x]\\n\",\n\t   ethver, iscsiver, fcoever);\n}\n\nvoid bnx2x_update_mfw_dump(struct bnx2x *bp)\n{\n\tu32 drv_ver;\n\tu32 valid_dump;\n\n\tif (!SHMEM2_HAS(bp, drv_info))\n\t\treturn;\n\n\t/* Update Driver load time, possibly broken in y2038 */\n\tSHMEM2_WR(bp, drv_info.epoc, (u32)ktime_get_real_seconds());\n\n\tdrv_ver = bnx2x_update_mng_version_utility(DRV_MODULE_VERSION, true);\n\tSHMEM2_WR(bp, drv_info.drv_ver, drv_ver);\n\n\tSHMEM2_WR(bp, drv_info.fw_ver, REG_RD(bp, XSEM_REG_PRAM));\n\n\t/* Check & notify On-Chip dump. */\n\tvalid_dump = SHMEM2_RD(bp, drv_info.valid_dump);\n\n\tif (valid_dump & FIRST_DUMP_VALID)\n\t\tDP(NETIF_MSG_IFUP, \"A valid On-Chip MFW dump found on 1st partition\\n\");\n\n\tif (valid_dump & SECOND_DUMP_VALID)\n\t\tDP(NETIF_MSG_IFUP, \"A valid On-Chip MFW dump found on 2nd partition\\n\");\n}\n\nstatic void bnx2x_oem_event(struct bnx2x *bp, u32 event)\n{\n\tu32 cmd_ok, cmd_fail;\n\n\t/* sanity */\n\tif (event & DRV_STATUS_DCC_EVENT_MASK &&\n\t    event & DRV_STATUS_OEM_EVENT_MASK) {\n\t\tBNX2X_ERR(\"Received simultaneous events %08x\\n\", event);\n\t\treturn;\n\t}\n\n\tif (event & DRV_STATUS_DCC_EVENT_MASK) {\n\t\tcmd_fail = DRV_MSG_CODE_DCC_FAILURE;\n\t\tcmd_ok = DRV_MSG_CODE_DCC_OK;\n\t} else /* if (event & DRV_STATUS_OEM_EVENT_MASK) */ {\n\t\tcmd_fail = DRV_MSG_CODE_OEM_FAILURE;\n\t\tcmd_ok = DRV_MSG_CODE_OEM_OK;\n\t}\n\n\tDP(BNX2X_MSG_MCP, \"oem_event 0x%x\\n\", event);\n\n\tif (event & (DRV_STATUS_DCC_DISABLE_ENABLE_PF |\n\t\t     DRV_STATUS_OEM_DISABLE_ENABLE_PF)) {\n\t\t/* This is the only place besides the function initialization\n\t\t * where the bp->flags can change so it is done without any\n\t\t * locks\n\t\t */\n\t\tif (bp->mf_config[BP_VN(bp)] & FUNC_MF_CFG_FUNC_DISABLED) {\n\t\t\tDP(BNX2X_MSG_MCP, \"mf_cfg function disabled\\n\");\n\t\t\tbp->flags |= MF_FUNC_DIS;\n\n\t\t\tbnx2x_e1h_disable(bp);\n\t\t} else {\n\t\t\tDP(BNX2X_MSG_MCP, \"mf_cfg function enabled\\n\");\n\t\t\tbp->flags &= ~MF_FUNC_DIS;\n\n\t\t\tbnx2x_e1h_enable(bp);\n\t\t}\n\t\tevent &= ~(DRV_STATUS_DCC_DISABLE_ENABLE_PF |\n\t\t\t   DRV_STATUS_OEM_DISABLE_ENABLE_PF);\n\t}\n\n\tif (event & (DRV_STATUS_DCC_BANDWIDTH_ALLOCATION |\n\t\t     DRV_STATUS_OEM_BANDWIDTH_ALLOCATION)) {\n\t\tbnx2x_config_mf_bw(bp);\n\t\tevent &= ~(DRV_STATUS_DCC_BANDWIDTH_ALLOCATION |\n\t\t\t   DRV_STATUS_OEM_BANDWIDTH_ALLOCATION);\n\t}\n\n\t/* Report results to MCP */\n\tif (event)\n\t\tbnx2x_fw_command(bp, cmd_fail, 0);\n\telse\n\t\tbnx2x_fw_command(bp, cmd_ok, 0);\n}\n\n/* must be called under the spq lock */\nstatic struct eth_spe *bnx2x_sp_get_next(struct bnx2x *bp)\n{\n\tstruct eth_spe *next_spe = bp->spq_prod_bd;\n\n\tif (bp->spq_prod_bd == bp->spq_last_bd) {\n\t\tbp->spq_prod_bd = bp->spq;\n\t\tbp->spq_prod_idx = 0;\n\t\tDP(BNX2X_MSG_SP, \"end of spq\\n\");\n\t} else {\n\t\tbp->spq_prod_bd++;\n\t\tbp->spq_prod_idx++;\n\t}\n\treturn next_spe;\n}\n\n/* must be called under the spq lock */\nstatic void bnx2x_sp_prod_update(struct bnx2x *bp)\n{\n\tint func = BP_FUNC(bp);\n\n\t/*\n\t * Make sure that BD data is updated before writing the producer:\n\t * BD data is written to the memory, the producer is read from the\n\t * memory, thus we need a full memory barrier to ensure the ordering.\n\t */\n\tmb();\n\n\tREG_WR16_RELAXED(bp, BAR_XSTRORM_INTMEM + XSTORM_SPQ_PROD_OFFSET(func),\n\t\t\t bp->spq_prod_idx);\n}\n\n/**\n * bnx2x_is_contextless_ramrod - check if the current command ends on EQ\n *\n * @cmd:\tcommand to check\n * @cmd_type:\tcommand type\n */\nstatic bool bnx2x_is_contextless_ramrod(int cmd, int cmd_type)\n{\n\tif ((cmd_type == NONE_CONNECTION_TYPE) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_FORWARD_SETUP) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_CLASSIFICATION_RULES) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_FILTER_RULES) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_MULTICAST_RULES) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_SET_MAC) ||\n\t    (cmd == RAMROD_CMD_ID_ETH_RSS_UPDATE))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n/**\n * bnx2x_sp_post - place a single command on an SP ring\n *\n * @bp:\t\tdriver handle\n * @command:\tcommand to place (e.g. SETUP, FILTER_RULES, etc.)\n * @cid:\tSW CID the command is related to\n * @data_hi:\tcommand private data address (high 32 bits)\n * @data_lo:\tcommand private data address (low 32 bits)\n * @cmd_type:\tcommand type (e.g. NONE, ETH)\n *\n * SP data is handled as if it's always an address pair, thus data fields are\n * not swapped to little endian in upper functions. Instead this function swaps\n * data as if it's two u32 fields.\n */\nint bnx2x_sp_post(struct bnx2x *bp, int command, int cid,\n\t\t  u32 data_hi, u32 data_lo, int cmd_type)\n{\n\tstruct eth_spe *spe;\n\tu16 type;\n\tbool common = bnx2x_is_contextless_ramrod(command, cmd_type);\n\n#ifdef BNX2X_STOP_ON_ERROR\n\tif (unlikely(bp->panic)) {\n\t\tBNX2X_ERR(\"Can't post SP when there is panic\\n\");\n\t\treturn -EIO;\n\t}\n#endif\n\n\tspin_lock_bh(&bp->spq_lock);\n\n\tif (common) {\n\t\tif (!atomic_read(&bp->eq_spq_left)) {\n\t\t\tBNX2X_ERR(\"BUG! EQ ring full!\\n\");\n\t\t\tspin_unlock_bh(&bp->spq_lock);\n\t\t\tbnx2x_panic();\n\t\t\treturn -EBUSY;\n\t\t}\n\t} else if (!atomic_read(&bp->cq_spq_left)) {\n\t\t\tBNX2X_ERR(\"BUG! SPQ ring full!\\n\");\n\t\t\tspin_unlock_bh(&bp->spq_lock);\n\t\t\tbnx2x_panic();\n\t\t\treturn -EBUSY;\n\t}\n\n\tspe = bnx2x_sp_get_next(bp);\n\n\t/* CID needs port number to be encoded int it */\n\tspe->hdr.conn_and_cmd_data =\n\t\t\tcpu_to_le32((command << SPE_HDR_CMD_ID_SHIFT) |\n\t\t\t\t    HW_CID(bp, cid));\n\n\t/* In some cases, type may already contain the func-id\n\t * mainly in SRIOV related use cases, so we add it here only\n\t * if it's not already set.\n\t */\n\tif (!(cmd_type & SPE_HDR_FUNCTION_ID)) {\n\t\ttype = (cmd_type << SPE_HDR_CONN_TYPE_SHIFT) &\n\t\t\tSPE_HDR_CONN_TYPE;\n\t\ttype |= ((BP_FUNC(bp) << SPE_HDR_FUNCTION_ID_SHIFT) &\n\t\t\t SPE_HDR_FUNCTION_ID);\n\t} else {\n\t\ttype = cmd_type;\n\t}\n\n\tspe->hdr.type = cpu_to_le16(type);\n\n\tspe->data.update_data_addr.hi = cpu_to_le32(data_hi);\n\tspe->data.update_data_addr.lo = cpu_to_le32(data_lo);\n\n\t/*\n\t * It's ok if the actual decrement is issued towards the memory\n\t * somewhere between the spin_lock and spin_unlock. Thus no\n\t * more explicit memory barrier is needed.\n\t */\n\tif (common)\n\t\tatomic_dec(&bp->eq_spq_left);\n\telse\n\t\tatomic_dec(&bp->cq_spq_left);\n\n\tDP(BNX2X_MSG_SP,\n\t   \"SPQE[%x] (%x:%x)  (cmd, common?) (%d,%d)  hw_cid %x  data (%x:%x) type(0x%x) left (CQ, EQ) (%x,%x)\\n\",\n\t   bp->spq_prod_idx, (u32)U64_HI(bp->spq_mapping),\n\t   (u32)(U64_LO(bp->spq_mapping) +\n\t   (void *)bp->spq_prod_bd - (void *)bp->spq), command, common,\n\t   HW_CID(bp, cid), data_hi, data_lo, type,\n\t   atomic_read(&bp->cq_spq_left), atomic_read(&bp->eq_spq_left));\n\n\tbnx2x_sp_prod_update(bp);\n\tspin_unlock_bh(&bp->spq_lock);\n\treturn 0;\n}\n\n/* acquire split MCP access lock register */\nstatic int bnx2x_acquire_alr(struct bnx2x *bp)\n{\n\tu32 j, val;\n\tint rc = 0;\n\n\tmight_sleep();\n\tfor (j = 0; j < 1000; j++) {\n\t\tREG_WR(bp, MCP_REG_MCPR_ACCESS_LOCK, MCPR_ACCESS_LOCK_LOCK);\n\t\tval = REG_RD(bp, MCP_REG_MCPR_ACCESS_LOCK);\n\t\tif (val & MCPR_ACCESS_LOCK_LOCK)\n\t\t\tbreak;\n\n\t\tusleep_range(5000, 10000);\n\t}\n\tif (!(val & MCPR_ACCESS_LOCK_LOCK)) {\n\t\tBNX2X_ERR(\"Cannot acquire MCP access lock register\\n\");\n\t\trc = -EBUSY;\n\t}\n\n\treturn rc;\n}\n\n/* release split MCP access lock register */\nstatic void bnx2x_release_alr(struct bnx2x *bp)\n{\n\tREG_WR(bp, MCP_REG_MCPR_ACCESS_LOCK, 0);\n}\n\n#define BNX2X_DEF_SB_ATT_IDX\t0x0001\n#define BNX2X_DEF_SB_IDX\t0x0002\n\nstatic u16 bnx2x_update_dsb_idx(struct bnx2x *bp)\n{\n\tstruct host_sp_status_block *def_sb = bp->def_status_blk;\n\tu16 rc = 0;\n\n\tbarrier(); /* status block is written to by the chip */\n\tif (bp->def_att_idx != def_sb->atten_status_block.attn_bits_index) {\n\t\tbp->def_att_idx = def_sb->atten_status_block.attn_bits_index;\n\t\trc |= BNX2X_DEF_SB_ATT_IDX;\n\t}\n\n\tif (bp->def_idx != def_sb->sp_sb.running_index) {\n\t\tbp->def_idx = def_sb->sp_sb.running_index;\n\t\trc |= BNX2X_DEF_SB_IDX;\n\t}\n\n\t/* Do not reorder: indices reading should complete before handling */\n\tbarrier();\n\treturn rc;\n}\n\n/*\n * slow path service functions\n */\n\nstatic void bnx2x_attn_int_asserted(struct bnx2x *bp, u32 asserted)\n{\n\tint port = BP_PORT(bp);\n\tu32 aeu_addr = port ? MISC_REG_AEU_MASK_ATTN_FUNC_1 :\n\t\t\t      MISC_REG_AEU_MASK_ATTN_FUNC_0;\n\tu32 nig_int_mask_addr = port ? NIG_REG_MASK_INTERRUPT_PORT1 :\n\t\t\t\t       NIG_REG_MASK_INTERRUPT_PORT0;\n\tu32 aeu_mask;\n\tu32 nig_mask = 0;\n\tu32 reg_addr;\n\n\tif (bp->attn_state & asserted)\n\t\tBNX2X_ERR(\"IGU ERROR\\n\");\n\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_PORT0_ATT_MASK + port);\n\taeu_mask = REG_RD(bp, aeu_addr);\n\n\tDP(NETIF_MSG_HW, \"aeu_mask %x  newly asserted %x\\n\",\n\t   aeu_mask, asserted);\n\taeu_mask &= ~(asserted & 0x3ff);\n\tDP(NETIF_MSG_HW, \"new mask %x\\n\", aeu_mask);\n\n\tREG_WR(bp, aeu_addr, aeu_mask);\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_PORT0_ATT_MASK + port);\n\n\tDP(NETIF_MSG_HW, \"attn_state %x\\n\", bp->attn_state);\n\tbp->attn_state |= asserted;\n\tDP(NETIF_MSG_HW, \"new state %x\\n\", bp->attn_state);\n\n\tif (asserted & ATTN_HARD_WIRED_MASK) {\n\t\tif (asserted & ATTN_NIG_FOR_FUNC) {\n\n\t\t\tbnx2x_acquire_phy_lock(bp);\n\n\t\t\t/* save nig interrupt mask */\n\t\t\tnig_mask = REG_RD(bp, nig_int_mask_addr);\n\n\t\t\t/* If nig_mask is not set, no need to call the update\n\t\t\t * function.\n\t\t\t */\n\t\t\tif (nig_mask) {\n\t\t\t\tREG_WR(bp, nig_int_mask_addr, 0);\n\n\t\t\t\tbnx2x_link_attn(bp);\n\t\t\t}\n\n\t\t\t/* handle unicore attn? */\n\t\t}\n\t\tif (asserted & ATTN_SW_TIMER_4_FUNC)\n\t\t\tDP(NETIF_MSG_HW, \"ATTN_SW_TIMER_4_FUNC!\\n\");\n\n\t\tif (asserted & GPIO_2_FUNC)\n\t\t\tDP(NETIF_MSG_HW, \"GPIO_2_FUNC!\\n\");\n\n\t\tif (asserted & GPIO_3_FUNC)\n\t\t\tDP(NETIF_MSG_HW, \"GPIO_3_FUNC!\\n\");\n\n\t\tif (asserted & GPIO_4_FUNC)\n\t\t\tDP(NETIF_MSG_HW, \"GPIO_4_FUNC!\\n\");\n\n\t\tif (port == 0) {\n\t\t\tif (asserted & ATTN_GENERAL_ATTN_1) {\n\t\t\t\tDP(NETIF_MSG_HW, \"ATTN_GENERAL_ATTN_1!\\n\");\n\t\t\t\tREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_1, 0x0);\n\t\t\t}\n\t\t\tif (asserted & ATTN_GENERAL_ATTN_2) {\n\t\t\t\tDP(NETIF_MSG_HW, \"ATTN_GENERAL_ATTN_2!\\n\");\n\t\t\t\tREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_2, 0x0);\n\t\t\t}\n\t\t\tif (asserted & ATTN_GENERAL_ATTN_3) {\n\t\t\t\tDP(NETIF_MSG_HW, \"ATTN_GENERAL_ATTN_3!\\n\");\n\t\t\t\tREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_3, 0x0);\n\t\t\t}\n\t\t} else {\n\t\t\tif (asserted & ATTN_GENERAL_ATTN_4) {\n\t\t\t\tDP(NETIF_MSG_HW, \"ATTN_GENERAL_ATTN_4!\\n\");\n\t\t\t\tREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_4, 0x0);\n\t\t\t}\n\t\t\tif (asserted & ATTN_GENERAL_ATTN_5) {\n\t\t\t\tDP(NETIF_MSG_HW, \"ATTN_GENERAL_ATTN_5!\\n\");\n\t\t\t\tREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_5, 0x0);\n\t\t\t}\n\t\t\tif (asserted & ATTN_GENERAL_ATTN_6) {\n\t\t\t\tDP(NETIF_MSG_HW, \"ATTN_GENERAL_ATTN_6!\\n\");\n\t\t\t\tREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_6, 0x0);\n\t\t\t}\n\t\t}\n\n\t} /* if hardwired */\n\n\tif (bp->common.int_block == INT_BLOCK_HC)\n\t\treg_addr = (HC_REG_COMMAND_REG + port*32 +\n\t\t\t    COMMAND_REG_ATTN_BITS_SET);\n\telse\n\t\treg_addr = (BAR_IGU_INTMEM + IGU_CMD_ATTN_BIT_SET_UPPER*8);\n\n\tDP(NETIF_MSG_HW, \"about to mask 0x%08x at %s addr 0x%x\\n\", asserted,\n\t   (bp->common.int_block == INT_BLOCK_HC) ? \"HC\" : \"IGU\", reg_addr);\n\tREG_WR(bp, reg_addr, asserted);\n\n\t/* now set back the mask */\n\tif (asserted & ATTN_NIG_FOR_FUNC) {\n\t\t/* Verify that IGU ack through BAR was written before restoring\n\t\t * NIG mask. This loop should exit after 2-3 iterations max.\n\t\t */\n\t\tif (bp->common.int_block != INT_BLOCK_HC) {\n\t\t\tu32 cnt = 0, igu_acked;\n\t\t\tdo {\n\t\t\t\tigu_acked = REG_RD(bp,\n\t\t\t\t\t\t   IGU_REG_ATTENTION_ACK_BITS);\n\t\t\t} while (((igu_acked & ATTN_NIG_FOR_FUNC) == 0) &&\n\t\t\t\t (++cnt < MAX_IGU_ATTN_ACK_TO));\n\t\t\tif (!igu_acked)\n\t\t\t\tDP(NETIF_MSG_HW,\n\t\t\t\t   \"Failed to verify IGU ack on time\\n\");\n\t\t\tbarrier();\n\t\t}\n\t\tREG_WR(bp, nig_int_mask_addr, nig_mask);\n\t\tbnx2x_release_phy_lock(bp);\n\t}\n}\n\nstatic void bnx2x_fan_failure(struct bnx2x *bp)\n{\n\tint port = BP_PORT(bp);\n\tu32 ext_phy_config;\n\t/* mark the failure */\n\text_phy_config =\n\t\tSHMEM_RD(bp,\n\t\t\t dev_info.port_hw_config[port].external_phy_config);\n\n\text_phy_config &= ~PORT_HW_CFG_XGXS_EXT_PHY_TYPE_MASK;\n\text_phy_config |= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE;\n\tSHMEM_WR(bp, dev_info.port_hw_config[port].external_phy_config,\n\t\t ext_phy_config);\n\n\t/* log the failure */\n\tnetdev_err(bp->dev, \"Fan Failure on Network Controller has caused the driver to shutdown the card to prevent permanent damage.\\n\"\n\t\t\t    \"Please contact OEM Support for assistance\\n\");\n\n\t/* Schedule device reset (unload)\n\t * This is due to some boards consuming sufficient power when driver is\n\t * up to overheat if fan fails.\n\t */\n\tbnx2x_schedule_sp_rtnl(bp, BNX2X_SP_RTNL_FAN_FAILURE, 0);\n}\n\nstatic void bnx2x_attn_int_deasserted0(struct bnx2x *bp, u32 attn)\n{\n\tint port = BP_PORT(bp);\n\tint reg_offset;\n\tu32 val;\n\n\treg_offset = (port ? MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0 :\n\t\t\t     MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0);\n\n\tif (attn & AEU_INPUTS_ATTN_BITS_SPIO5) {\n\n\t\tval = REG_RD(bp, reg_offset);\n\t\tval &= ~AEU_INPUTS_ATTN_BITS_SPIO5;\n\t\tREG_WR(bp, reg_offset, val);\n\n\t\tBNX2X_ERR(\"SPIO5 hw attention\\n\");\n\n\t\t/* Fan failure attention */\n\t\tbnx2x_hw_reset_phy(&bp->link_params);\n\t\tbnx2x_fan_failure(bp);\n\t}\n\n\tif ((attn & bp->link_vars.aeu_int_mask) && bp->port.pmf) {\n\t\tbnx2x_acquire_phy_lock(bp);\n\t\tbnx2x_handle_module_detect_int(&bp->link_params);\n\t\tbnx2x_release_phy_lock(bp);\n\t}\n\n\tif (attn & HW_INTERRUPT_ASSERT_SET_0) {\n\n\t\tval = REG_RD(bp, reg_offset);\n\t\tval &= ~(attn & HW_INTERRUPT_ASSERT_SET_0);\n\t\tREG_WR(bp, reg_offset, val);\n\n\t\tBNX2X_ERR(\"FATAL HW block attention set0 0x%x\\n\",\n\t\t\t  (u32)(attn & HW_INTERRUPT_ASSERT_SET_0));\n\t\tbnx2x_panic();\n\t}\n}\n\nstatic void bnx2x_attn_int_deasserted1(struct bnx2x *bp, u32 attn)\n{\n\tu32 val;\n\n\tif (attn & AEU_INPUTS_ATTN_BITS_DOORBELLQ_HW_INTERRUPT) {\n\n\t\tval = REG_RD(bp, DORQ_REG_DORQ_INT_STS_CLR);\n\t\tBNX2X_ERR(\"DB hw attention 0x%x\\n\", val);\n\t\t/* DORQ discard attention */\n\t\tif (val & 0x2)\n\t\t\tBNX2X_ERR(\"FATAL error from DORQ\\n\");\n\t}\n\n\tif (attn & HW_INTERRUPT_ASSERT_SET_1) {\n\n\t\tint port = BP_PORT(bp);\n\t\tint reg_offset;\n\n\t\treg_offset = (port ? MISC_REG_AEU_ENABLE1_FUNC_1_OUT_1 :\n\t\t\t\t     MISC_REG_AEU_ENABLE1_FUNC_0_OUT_1);\n\n\t\tval = REG_RD(bp, reg_offset);\n\t\tval &= ~(attn & HW_INTERRUPT_ASSERT_SET_1);\n\t\tREG_WR(bp, reg_offset, val);\n\n\t\tBNX2X_ERR(\"FATAL HW block attention set1 0x%x\\n\",\n\t\t\t  (u32)(attn & HW_INTERRUPT_ASSERT_SET_1));\n\t\tbnx2x_panic();\n\t}\n}\n\nstatic void bnx2x_attn_int_deasserted2(struct bnx2x *bp, u32 attn)\n{\n\tu32 val;\n\n\tif (attn & AEU_INPUTS_ATTN_BITS_CFC_HW_INTERRUPT) {\n\n\t\tval = REG_RD(bp, CFC_REG_CFC_INT_STS_CLR);\n\t\tBNX2X_ERR(\"CFC hw attention 0x%x\\n\", val);\n\t\t/* CFC error attention */\n\t\tif (val & 0x2)\n\t\t\tBNX2X_ERR(\"FATAL error from CFC\\n\");\n\t}\n\n\tif (attn & AEU_INPUTS_ATTN_BITS_PXP_HW_INTERRUPT) {\n\t\tval = REG_RD(bp, PXP_REG_PXP_INT_STS_CLR_0);\n\t\tBNX2X_ERR(\"PXP hw attention-0 0x%x\\n\", val);\n\t\t/* RQ_USDMDP_FIFO_OVERFLOW */\n\t\tif (val & 0x18000)\n\t\t\tBNX2X_ERR(\"FATAL error from PXP\\n\");\n\n\t\tif (!CHIP_IS_E1x(bp)) {\n\t\t\tval = REG_RD(bp, PXP_REG_PXP_INT_STS_CLR_1);\n\t\t\tBNX2X_ERR(\"PXP hw attention-1 0x%x\\n\", val);\n\t\t}\n\t}\n\n\tif (attn & HW_INTERRUPT_ASSERT_SET_2) {\n\n\t\tint port = BP_PORT(bp);\n\t\tint reg_offset;\n\n\t\treg_offset = (port ? MISC_REG_AEU_ENABLE1_FUNC_1_OUT_2 :\n\t\t\t\t     MISC_REG_AEU_ENABLE1_FUNC_0_OUT_2);\n\n\t\tval = REG_RD(bp, reg_offset);\n\t\tval &= ~(attn & HW_INTERRUPT_ASSERT_SET_2);\n\t\tREG_WR(bp, reg_offset, val);\n\n\t\tBNX2X_ERR(\"FATAL HW block attention set2 0x%x\\n\",\n\t\t\t  (u32)(attn & HW_INTERRUPT_ASSERT_SET_2));\n\t\tbnx2x_panic();\n\t}\n}\n\nstatic void bnx2x_attn_int_deasserted3(struct bnx2x *bp, u32 attn)\n{\n\tu32 val;\n\n\tif (attn & EVEREST_GEN_ATTN_IN_USE_MASK) {\n\n\t\tif (attn & BNX2X_PMF_LINK_ASSERT) {\n\t\t\tint func = BP_FUNC(bp);\n\n\t\t\tREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_12 + func*4, 0);\n\t\t\tbnx2x_read_mf_cfg(bp);\n\t\t\tbp->mf_config[BP_VN(bp)] = MF_CFG_RD(bp,\n\t\t\t\t\tfunc_mf_config[BP_ABS_FUNC(bp)].config);\n\t\t\tval = SHMEM_RD(bp,\n\t\t\t\t       func_mb[BP_FW_MB_IDX(bp)].drv_status);\n\n\t\t\tif (val & (DRV_STATUS_DCC_EVENT_MASK |\n\t\t\t\t   DRV_STATUS_OEM_EVENT_MASK))\n\t\t\t\tbnx2x_oem_event(bp,\n\t\t\t\t\t(val & (DRV_STATUS_DCC_EVENT_MASK |\n\t\t\t\t\t\tDRV_STATUS_OEM_EVENT_MASK)));\n\n\t\t\tif (val & DRV_STATUS_SET_MF_BW)\n\t\t\t\tbnx2x_set_mf_bw(bp);\n\n\t\t\tif (val & DRV_STATUS_DRV_INFO_REQ)\n\t\t\t\tbnx2x_handle_drv_info_req(bp);\n\n\t\t\tif (val & DRV_STATUS_VF_DISABLED)\n\t\t\t\tbnx2x_schedule_iov_task(bp,\n\t\t\t\t\t\t\tBNX2X_IOV_HANDLE_FLR);\n\n\t\t\tif ((bp->port.pmf == 0) && (val & DRV_STATUS_PMF))\n\t\t\t\tbnx2x_pmf_update(bp);\n\n\t\t\tif (bp->port.pmf &&\n\t\t\t    (val & DRV_STATUS_DCBX_NEGOTIATION_RESULTS) &&\n\t\t\t\tbp->dcbx_enabled > 0)\n\t\t\t\t/* start dcbx state machine */\n\t\t\t\tbnx2x_dcbx_set_params(bp,\n\t\t\t\t\tBNX2X_DCBX_STATE_NEG_RECEIVED);\n\t\t\tif (val & DRV_STATUS_AFEX_EVENT_MASK)\n\t\t\t\tbnx2x_handle_afex_cmd(bp,\n\t\t\t\t\tval & DRV_STATUS_AFEX_EVENT_MASK);\n\t\t\tif (val & DRV_STATUS_EEE_NEGOTIATION_RESULTS)\n\t\t\t\tbnx2x_handle_eee_event(bp);\n\n\t\t\tif (val & DRV_STATUS_OEM_UPDATE_SVID)\n\t\t\t\tbnx2x_schedule_sp_rtnl(bp,\n\t\t\t\t\tBNX2X_SP_RTNL_UPDATE_SVID, 0);\n\n\t\t\tif (bp->link_vars.periodic_flags &\n\t\t\t    PERIODIC_FLAGS_LINK_EVENT) {\n\t\t\t\t/*  sync with link */\n\t\t\t\tbnx2x_acquire_phy_lock(bp);\n\t\t\t\tbp->link_vars.periodic_flags &=\n\t\t\t\t\t~PERIODIC_FLAGS_LINK_EVENT;\n\t\t\t\tbnx2x_release_phy_lock(bp);\n\t\t\t\tif (IS_MF(bp))\n\t\t\t\t\tbnx2x_link_sync_notify(bp);\n\t\t\t\tbnx2x_link_report(bp);\n\t\t\t}\n\t\t\t/* Always call it here: bnx2x_link_report() will\n\t\t\t * prevent the link indication duplication.\n\t\t\t */\n\t\t\tbnx2x__link_status_update(bp);\n\t\t} else if (attn & BNX2X_MC_ASSERT_BITS) {\n\n\t\t\tBNX2X_ERR(\"MC assert!\\n\");\n\t\t\tbnx2x_mc_assert(bp);\n\t\t\tREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_10, 0);\n\t\t\tREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_9, 0);\n\t\t\tREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_8, 0);\n\t\t\tREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_7, 0);\n\t\t\tbnx2x_panic();\n\n\t\t} else if (attn & BNX2X_MCP_ASSERT) {\n\n\t\t\tBNX2X_ERR(\"MCP assert!\\n\");\n\t\t\tREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_11, 0);\n\t\t\tbnx2x_fw_dump(bp);\n\n\t\t} else\n\t\t\tBNX2X_ERR(\"Unknown HW assert! (attn 0x%x)\\n\", attn);\n\t}\n\n\tif (attn & EVEREST_LATCHED_ATTN_IN_USE_MASK) {\n\t\tBNX2X_ERR(\"LATCHED attention 0x%08x (masked)\\n\", attn);\n\t\tif (attn & BNX2X_GRC_TIMEOUT) {\n\t\t\tval = CHIP_IS_E1(bp) ? 0 :\n\t\t\t\t\tREG_RD(bp, MISC_REG_GRC_TIMEOUT_ATTN);\n\t\t\tBNX2X_ERR(\"GRC time-out 0x%08x\\n\", val);\n\t\t}\n\t\tif (attn & BNX2X_GRC_RSV) {\n\t\t\tval = CHIP_IS_E1(bp) ? 0 :\n\t\t\t\t\tREG_RD(bp, MISC_REG_GRC_RSV_ATTN);\n\t\t\tBNX2X_ERR(\"GRC reserved 0x%08x\\n\", val);\n\t\t}\n\t\tREG_WR(bp, MISC_REG_AEU_CLR_LATCH_SIGNAL, 0x7ff);\n\t}\n}\n\n/*\n * Bits map:\n * 0-7   - Engine0 load counter.\n * 8-15  - Engine1 load counter.\n * 16    - Engine0 RESET_IN_PROGRESS bit.\n * 17    - Engine1 RESET_IN_PROGRESS bit.\n * 18    - Engine0 ONE_IS_LOADED. Set when there is at least one active function\n *         on the engine\n * 19    - Engine1 ONE_IS_LOADED.\n * 20    - Chip reset flow bit. When set none-leader must wait for both engines\n *         leader to complete (check for both RESET_IN_PROGRESS bits and not for\n *         just the one belonging to its engine).\n *\n */\n#define BNX2X_RECOVERY_GLOB_REG\t\tMISC_REG_GENERIC_POR_1\n\n#define BNX2X_PATH0_LOAD_CNT_MASK\t0x000000ff\n#define BNX2X_PATH0_LOAD_CNT_SHIFT\t0\n#define BNX2X_PATH1_LOAD_CNT_MASK\t0x0000ff00\n#define BNX2X_PATH1_LOAD_CNT_SHIFT\t8\n#define BNX2X_PATH0_RST_IN_PROG_BIT\t0x00010000\n#define BNX2X_PATH1_RST_IN_PROG_BIT\t0x00020000\n#define BNX2X_GLOBAL_RESET_BIT\t\t0x00040000\n\n/*\n * Set the GLOBAL_RESET bit.\n *\n * Should be run under rtnl lock\n */\nvoid bnx2x_set_reset_global(struct bnx2x *bp)\n{\n\tu32 val;\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n\tval = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\n\tREG_WR(bp, BNX2X_RECOVERY_GLOB_REG, val | BNX2X_GLOBAL_RESET_BIT);\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n}\n\n/*\n * Clear the GLOBAL_RESET bit.\n *\n * Should be run under rtnl lock\n */\nstatic void bnx2x_clear_reset_global(struct bnx2x *bp)\n{\n\tu32 val;\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n\tval = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\n\tREG_WR(bp, BNX2X_RECOVERY_GLOB_REG, val & (~BNX2X_GLOBAL_RESET_BIT));\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n}\n\n/*\n * Checks the GLOBAL_RESET bit.\n *\n * should be run under rtnl lock\n */\nstatic bool bnx2x_reset_is_global(struct bnx2x *bp)\n{\n\tu32 val = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\n\n\tDP(NETIF_MSG_HW, \"GEN_REG_VAL=0x%08x\\n\", val);\n\treturn (val & BNX2X_GLOBAL_RESET_BIT) ? true : false;\n}\n\n/*\n * Clear RESET_IN_PROGRESS bit for the current engine.\n *\n * Should be run under rtnl lock\n */\nstatic void bnx2x_set_reset_done(struct bnx2x *bp)\n{\n\tu32 val;\n\tu32 bit = BP_PATH(bp) ?\n\t\tBNX2X_PATH1_RST_IN_PROG_BIT : BNX2X_PATH0_RST_IN_PROG_BIT;\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n\tval = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\n\n\t/* Clear the bit */\n\tval &= ~bit;\n\tREG_WR(bp, BNX2X_RECOVERY_GLOB_REG, val);\n\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n}\n\n/*\n * Set RESET_IN_PROGRESS for the current engine.\n *\n * should be run under rtnl lock\n */\nvoid bnx2x_set_reset_in_progress(struct bnx2x *bp)\n{\n\tu32 val;\n\tu32 bit = BP_PATH(bp) ?\n\t\tBNX2X_PATH1_RST_IN_PROG_BIT : BNX2X_PATH0_RST_IN_PROG_BIT;\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n\tval = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\n\n\t/* Set the bit */\n\tval |= bit;\n\tREG_WR(bp, BNX2X_RECOVERY_GLOB_REG, val);\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n}\n\n/*\n * Checks the RESET_IN_PROGRESS bit for the given engine.\n * should be run under rtnl lock\n */\nbool bnx2x_reset_is_done(struct bnx2x *bp, int engine)\n{\n\tu32 val = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\n\tu32 bit = engine ?\n\t\tBNX2X_PATH1_RST_IN_PROG_BIT : BNX2X_PATH0_RST_IN_PROG_BIT;\n\n\t/* return false if bit is set */\n\treturn (val & bit) ? false : true;\n}\n\n/*\n * set pf load for the current pf.\n *\n * should be run under rtnl lock\n */\nvoid bnx2x_set_pf_load(struct bnx2x *bp)\n{\n\tu32 val1, val;\n\tu32 mask = BP_PATH(bp) ? BNX2X_PATH1_LOAD_CNT_MASK :\n\t\t\t     BNX2X_PATH0_LOAD_CNT_MASK;\n\tu32 shift = BP_PATH(bp) ? BNX2X_PATH1_LOAD_CNT_SHIFT :\n\t\t\t     BNX2X_PATH0_LOAD_CNT_SHIFT;\n\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n\tval = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\n\n\tDP(NETIF_MSG_IFUP, \"Old GEN_REG_VAL=0x%08x\\n\", val);\n\n\t/* get the current counter value */\n\tval1 = (val & mask) >> shift;\n\n\t/* set bit of that PF */\n\tval1 |= (1 << bp->pf_num);\n\n\t/* clear the old value */\n\tval &= ~mask;\n\n\t/* set the new one */\n\tval |= ((val1 << shift) & mask);\n\n\tREG_WR(bp, BNX2X_RECOVERY_GLOB_REG, val);\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n}\n\n/**\n * bnx2x_clear_pf_load - clear pf load mark\n *\n * @bp:\t\tdriver handle\n *\n * Should be run under rtnl lock.\n * Decrements the load counter for the current engine. Returns\n * whether other functions are still loaded\n */\nbool bnx2x_clear_pf_load(struct bnx2x *bp)\n{\n\tu32 val1, val;\n\tu32 mask = BP_PATH(bp) ? BNX2X_PATH1_LOAD_CNT_MASK :\n\t\t\t     BNX2X_PATH0_LOAD_CNT_MASK;\n\tu32 shift = BP_PATH(bp) ? BNX2X_PATH1_LOAD_CNT_SHIFT :\n\t\t\t     BNX2X_PATH0_LOAD_CNT_SHIFT;\n\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n\tval = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\n\tDP(NETIF_MSG_IFDOWN, \"Old GEN_REG_VAL=0x%08x\\n\", val);\n\n\t/* get the current counter value */\n\tval1 = (val & mask) >> shift;\n\n\t/* clear bit of that PF */\n\tval1 &= ~(1 << bp->pf_num);\n\n\t/* clear the old value */\n\tval &= ~mask;\n\n\t/* set the new one */\n\tval |= ((val1 << shift) & mask);\n\n\tREG_WR(bp, BNX2X_RECOVERY_GLOB_REG, val);\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n\treturn val1 != 0;\n}\n\n/*\n * Read the load status for the current engine.\n *\n * should be run under rtnl lock\n */\nstatic bool bnx2x_get_load_status(struct bnx2x *bp, int engine)\n{\n\tu32 mask = (engine ? BNX2X_PATH1_LOAD_CNT_MASK :\n\t\t\t     BNX2X_PATH0_LOAD_CNT_MASK);\n\tu32 shift = (engine ? BNX2X_PATH1_LOAD_CNT_SHIFT :\n\t\t\t     BNX2X_PATH0_LOAD_CNT_SHIFT);\n\tu32 val = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\n\n\tDP(NETIF_MSG_HW | NETIF_MSG_IFUP, \"GLOB_REG=0x%08x\\n\", val);\n\n\tval = (val & mask) >> shift;\n\n\tDP(NETIF_MSG_HW | NETIF_MSG_IFUP, \"load mask for engine %d = 0x%x\\n\",\n\t   engine, val);\n\n\treturn val != 0;\n}\n\nstatic void _print_parity(struct bnx2x *bp, u32 reg)\n{\n\tpr_cont(\" [0x%08x] \", REG_RD(bp, reg));\n}\n\nstatic void _print_next_block(int idx, const char *blk)\n{\n\tpr_cont(\"%s%s\", idx ? \", \" : \"\", blk);\n}\n\nstatic bool bnx2x_check_blocks_with_parity0(struct bnx2x *bp, u32 sig,\n\t\t\t\t\t    int *par_num, bool print)\n{\n\tu32 cur_bit;\n\tbool res;\n\tint i;\n\n\tres = false;\n\n\tfor (i = 0; sig; i++) {\n\t\tcur_bit = (0x1UL << i);\n\t\tif (sig & cur_bit) {\n\t\t\tres |= true; /* Each bit is real error! */\n\n\t\t\tif (print) {\n\t\t\t\tswitch (cur_bit) {\n\t\t\t\tcase AEU_INPUTS_ATTN_BITS_BRB_PARITY_ERROR:\n\t\t\t\t\t_print_next_block((*par_num)++, \"BRB\");\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      BRB1_REG_BRB1_PRTY_STS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AEU_INPUTS_ATTN_BITS_PARSER_PARITY_ERROR:\n\t\t\t\t\t_print_next_block((*par_num)++,\n\t\t\t\t\t\t\t  \"PARSER\");\n\t\t\t\t\t_print_parity(bp, PRS_REG_PRS_PRTY_STS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AEU_INPUTS_ATTN_BITS_TSDM_PARITY_ERROR:\n\t\t\t\t\t_print_next_block((*par_num)++, \"TSDM\");\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      TSDM_REG_TSDM_PRTY_STS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AEU_INPUTS_ATTN_BITS_SEARCHER_PARITY_ERROR:\n\t\t\t\t\t_print_next_block((*par_num)++,\n\t\t\t\t\t\t\t  \"SEARCHER\");\n\t\t\t\t\t_print_parity(bp, SRC_REG_SRC_PRTY_STS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AEU_INPUTS_ATTN_BITS_TCM_PARITY_ERROR:\n\t\t\t\t\t_print_next_block((*par_num)++, \"TCM\");\n\t\t\t\t\t_print_parity(bp, TCM_REG_TCM_PRTY_STS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AEU_INPUTS_ATTN_BITS_TSEMI_PARITY_ERROR:\n\t\t\t\t\t_print_next_block((*par_num)++,\n\t\t\t\t\t\t\t  \"TSEMI\");\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      TSEM_REG_TSEM_PRTY_STS_0);\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      TSEM_REG_TSEM_PRTY_STS_1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AEU_INPUTS_ATTN_BITS_PBCLIENT_PARITY_ERROR:\n\t\t\t\t\t_print_next_block((*par_num)++, \"XPB\");\n\t\t\t\t\t_print_parity(bp, GRCBASE_XPB +\n\t\t\t\t\t\t\t  PB_REG_PB_PRTY_STS);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Clear the bit */\n\t\t\tsig &= ~cur_bit;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic bool bnx2x_check_blocks_with_parity1(struct bnx2x *bp, u32 sig,\n\t\t\t\t\t    int *par_num, bool *global,\n\t\t\t\t\t    bool print)\n{\n\tu32 cur_bit;\n\tbool res;\n\tint i;\n\n\tres = false;\n\n\tfor (i = 0; sig; i++) {\n\t\tcur_bit = (0x1UL << i);\n\t\tif (sig & cur_bit) {\n\t\t\tres |= true; /* Each bit is real error! */\n\t\t\tswitch (cur_bit) {\n\t\t\tcase AEU_INPUTS_ATTN_BITS_PBF_PARITY_ERROR:\n\t\t\t\tif (print) {\n\t\t\t\t\t_print_next_block((*par_num)++, \"PBF\");\n\t\t\t\t\t_print_parity(bp, PBF_REG_PBF_PRTY_STS);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_QM_PARITY_ERROR:\n\t\t\t\tif (print) {\n\t\t\t\t\t_print_next_block((*par_num)++, \"QM\");\n\t\t\t\t\t_print_parity(bp, QM_REG_QM_PRTY_STS);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_TIMERS_PARITY_ERROR:\n\t\t\t\tif (print) {\n\t\t\t\t\t_print_next_block((*par_num)++, \"TM\");\n\t\t\t\t\t_print_parity(bp, TM_REG_TM_PRTY_STS);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_XSDM_PARITY_ERROR:\n\t\t\t\tif (print) {\n\t\t\t\t\t_print_next_block((*par_num)++, \"XSDM\");\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      XSDM_REG_XSDM_PRTY_STS);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_XCM_PARITY_ERROR:\n\t\t\t\tif (print) {\n\t\t\t\t\t_print_next_block((*par_num)++, \"XCM\");\n\t\t\t\t\t_print_parity(bp, XCM_REG_XCM_PRTY_STS);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_XSEMI_PARITY_ERROR:\n\t\t\t\tif (print) {\n\t\t\t\t\t_print_next_block((*par_num)++,\n\t\t\t\t\t\t\t  \"XSEMI\");\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      XSEM_REG_XSEM_PRTY_STS_0);\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      XSEM_REG_XSEM_PRTY_STS_1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_DOORBELLQ_PARITY_ERROR:\n\t\t\t\tif (print) {\n\t\t\t\t\t_print_next_block((*par_num)++,\n\t\t\t\t\t\t\t  \"DOORBELLQ\");\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      DORQ_REG_DORQ_PRTY_STS);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_NIG_PARITY_ERROR:\n\t\t\t\tif (print) {\n\t\t\t\t\t_print_next_block((*par_num)++, \"NIG\");\n\t\t\t\t\tif (CHIP_IS_E1x(bp)) {\n\t\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t\tNIG_REG_NIG_PRTY_STS);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t\tNIG_REG_NIG_PRTY_STS_0);\n\t\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t\tNIG_REG_NIG_PRTY_STS_1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_VAUX_PCI_CORE_PARITY_ERROR:\n\t\t\t\tif (print)\n\t\t\t\t\t_print_next_block((*par_num)++,\n\t\t\t\t\t\t\t  \"VAUX PCI CORE\");\n\t\t\t\t*global = true;\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_DEBUG_PARITY_ERROR:\n\t\t\t\tif (print) {\n\t\t\t\t\t_print_next_block((*par_num)++,\n\t\t\t\t\t\t\t  \"DEBUG\");\n\t\t\t\t\t_print_parity(bp, DBG_REG_DBG_PRTY_STS);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_USDM_PARITY_ERROR:\n\t\t\t\tif (print) {\n\t\t\t\t\t_print_next_block((*par_num)++, \"USDM\");\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      USDM_REG_USDM_PRTY_STS);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_UCM_PARITY_ERROR:\n\t\t\t\tif (print) {\n\t\t\t\t\t_print_next_block((*par_num)++, \"UCM\");\n\t\t\t\t\t_print_parity(bp, UCM_REG_UCM_PRTY_STS);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_USEMI_PARITY_ERROR:\n\t\t\t\tif (print) {\n\t\t\t\t\t_print_next_block((*par_num)++,\n\t\t\t\t\t\t\t  \"USEMI\");\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      USEM_REG_USEM_PRTY_STS_0);\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      USEM_REG_USEM_PRTY_STS_1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_UPB_PARITY_ERROR:\n\t\t\t\tif (print) {\n\t\t\t\t\t_print_next_block((*par_num)++, \"UPB\");\n\t\t\t\t\t_print_parity(bp, GRCBASE_UPB +\n\t\t\t\t\t\t\t  PB_REG_PB_PRTY_STS);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_CSDM_PARITY_ERROR:\n\t\t\t\tif (print) {\n\t\t\t\t\t_print_next_block((*par_num)++, \"CSDM\");\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      CSDM_REG_CSDM_PRTY_STS);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_CCM_PARITY_ERROR:\n\t\t\t\tif (print) {\n\t\t\t\t\t_print_next_block((*par_num)++, \"CCM\");\n\t\t\t\t\t_print_parity(bp, CCM_REG_CCM_PRTY_STS);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Clear the bit */\n\t\t\tsig &= ~cur_bit;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic bool bnx2x_check_blocks_with_parity2(struct bnx2x *bp, u32 sig,\n\t\t\t\t\t    int *par_num, bool print)\n{\n\tu32 cur_bit;\n\tbool res;\n\tint i;\n\n\tres = false;\n\n\tfor (i = 0; sig; i++) {\n\t\tcur_bit = (0x1UL << i);\n\t\tif (sig & cur_bit) {\n\t\t\tres = true; /* Each bit is real error! */\n\t\t\tif (print) {\n\t\t\t\tswitch (cur_bit) {\n\t\t\t\tcase AEU_INPUTS_ATTN_BITS_CSEMI_PARITY_ERROR:\n\t\t\t\t\t_print_next_block((*par_num)++,\n\t\t\t\t\t\t\t  \"CSEMI\");\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      CSEM_REG_CSEM_PRTY_STS_0);\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      CSEM_REG_CSEM_PRTY_STS_1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AEU_INPUTS_ATTN_BITS_PXP_PARITY_ERROR:\n\t\t\t\t\t_print_next_block((*par_num)++, \"PXP\");\n\t\t\t\t\t_print_parity(bp, PXP_REG_PXP_PRTY_STS);\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      PXP2_REG_PXP2_PRTY_STS_0);\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      PXP2_REG_PXP2_PRTY_STS_1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AEU_IN_ATTN_BITS_PXPPCICLOCKCLIENT_PARITY_ERROR:\n\t\t\t\t\t_print_next_block((*par_num)++,\n\t\t\t\t\t\t\t  \"PXPPCICLOCKCLIENT\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase AEU_INPUTS_ATTN_BITS_CFC_PARITY_ERROR:\n\t\t\t\t\t_print_next_block((*par_num)++, \"CFC\");\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      CFC_REG_CFC_PRTY_STS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AEU_INPUTS_ATTN_BITS_CDU_PARITY_ERROR:\n\t\t\t\t\t_print_next_block((*par_num)++, \"CDU\");\n\t\t\t\t\t_print_parity(bp, CDU_REG_CDU_PRTY_STS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AEU_INPUTS_ATTN_BITS_DMAE_PARITY_ERROR:\n\t\t\t\t\t_print_next_block((*par_num)++, \"DMAE\");\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      DMAE_REG_DMAE_PRTY_STS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AEU_INPUTS_ATTN_BITS_IGU_PARITY_ERROR:\n\t\t\t\t\t_print_next_block((*par_num)++, \"IGU\");\n\t\t\t\t\tif (CHIP_IS_E1x(bp))\n\t\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t\tHC_REG_HC_PRTY_STS);\n\t\t\t\t\telse\n\t\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t\tIGU_REG_IGU_PRTY_STS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AEU_INPUTS_ATTN_BITS_MISC_PARITY_ERROR:\n\t\t\t\t\t_print_next_block((*par_num)++, \"MISC\");\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      MISC_REG_MISC_PRTY_STS);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Clear the bit */\n\t\t\tsig &= ~cur_bit;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic bool bnx2x_check_blocks_with_parity3(struct bnx2x *bp, u32 sig,\n\t\t\t\t\t    int *par_num, bool *global,\n\t\t\t\t\t    bool print)\n{\n\tbool res = false;\n\tu32 cur_bit;\n\tint i;\n\n\tfor (i = 0; sig; i++) {\n\t\tcur_bit = (0x1UL << i);\n\t\tif (sig & cur_bit) {\n\t\t\tswitch (cur_bit) {\n\t\t\tcase AEU_INPUTS_ATTN_BITS_MCP_LATCHED_ROM_PARITY:\n\t\t\t\tif (print)\n\t\t\t\t\t_print_next_block((*par_num)++,\n\t\t\t\t\t\t\t  \"MCP ROM\");\n\t\t\t\t*global = true;\n\t\t\t\tres = true;\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_RX_PARITY:\n\t\t\t\tif (print)\n\t\t\t\t\t_print_next_block((*par_num)++,\n\t\t\t\t\t\t\t  \"MCP UMP RX\");\n\t\t\t\t*global = true;\n\t\t\t\tres = true;\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_TX_PARITY:\n\t\t\t\tif (print)\n\t\t\t\t\t_print_next_block((*par_num)++,\n\t\t\t\t\t\t\t  \"MCP UMP TX\");\n\t\t\t\t*global = true;\n\t\t\t\tres = true;\n\t\t\t\tbreak;\n\t\t\tcase AEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY:\n\t\t\t\t(*par_num)++;\n\t\t\t\t/* clear latched SCPAD PATIRY from MCP */\n\t\t\t\tREG_WR(bp, MISC_REG_AEU_CLR_LATCH_SIGNAL,\n\t\t\t\t       1UL << 10);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Clear the bit */\n\t\t\tsig &= ~cur_bit;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic bool bnx2x_check_blocks_with_parity4(struct bnx2x *bp, u32 sig,\n\t\t\t\t\t    int *par_num, bool print)\n{\n\tu32 cur_bit;\n\tbool res;\n\tint i;\n\n\tres = false;\n\n\tfor (i = 0; sig; i++) {\n\t\tcur_bit = (0x1UL << i);\n\t\tif (sig & cur_bit) {\n\t\t\tres = true; /* Each bit is real error! */\n\t\t\tif (print) {\n\t\t\t\tswitch (cur_bit) {\n\t\t\t\tcase AEU_INPUTS_ATTN_BITS_PGLUE_PARITY_ERROR:\n\t\t\t\t\t_print_next_block((*par_num)++,\n\t\t\t\t\t\t\t  \"PGLUE_B\");\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      PGLUE_B_REG_PGLUE_B_PRTY_STS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AEU_INPUTS_ATTN_BITS_ATC_PARITY_ERROR:\n\t\t\t\t\t_print_next_block((*par_num)++, \"ATC\");\n\t\t\t\t\t_print_parity(bp,\n\t\t\t\t\t\t      ATC_REG_ATC_PRTY_STS);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Clear the bit */\n\t\t\tsig &= ~cur_bit;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic bool bnx2x_parity_attn(struct bnx2x *bp, bool *global, bool print,\n\t\t\t      u32 *sig)\n{\n\tbool res = false;\n\n\tif ((sig[0] & HW_PRTY_ASSERT_SET_0) ||\n\t    (sig[1] & HW_PRTY_ASSERT_SET_1) ||\n\t    (sig[2] & HW_PRTY_ASSERT_SET_2) ||\n\t    (sig[3] & HW_PRTY_ASSERT_SET_3) ||\n\t    (sig[4] & HW_PRTY_ASSERT_SET_4)) {\n\t\tint par_num = 0;\n\n\t\tDP(NETIF_MSG_HW, \"Was parity error: HW block parity attention:\\n\"\n\t\t\t\t \"[0]:0x%08x [1]:0x%08x [2]:0x%08x [3]:0x%08x [4]:0x%08x\\n\",\n\t\t\t  sig[0] & HW_PRTY_ASSERT_SET_0,\n\t\t\t  sig[1] & HW_PRTY_ASSERT_SET_1,\n\t\t\t  sig[2] & HW_PRTY_ASSERT_SET_2,\n\t\t\t  sig[3] & HW_PRTY_ASSERT_SET_3,\n\t\t\t  sig[4] & HW_PRTY_ASSERT_SET_4);\n\t\tif (print) {\n\t\t\tif (((sig[0] & HW_PRTY_ASSERT_SET_0) ||\n\t\t\t     (sig[1] & HW_PRTY_ASSERT_SET_1) ||\n\t\t\t     (sig[2] & HW_PRTY_ASSERT_SET_2) ||\n\t\t\t     (sig[4] & HW_PRTY_ASSERT_SET_4)) ||\n\t\t\t     (sig[3] & HW_PRTY_ASSERT_SET_3_WITHOUT_SCPAD)) {\n\t\t\t\tnetdev_err(bp->dev,\n\t\t\t\t\t   \"Parity errors detected in blocks: \");\n\t\t\t} else {\n\t\t\t\tprint = false;\n\t\t\t}\n\t\t}\n\t\tres |= bnx2x_check_blocks_with_parity0(bp,\n\t\t\tsig[0] & HW_PRTY_ASSERT_SET_0, &par_num, print);\n\t\tres |= bnx2x_check_blocks_with_parity1(bp,\n\t\t\tsig[1] & HW_PRTY_ASSERT_SET_1, &par_num, global, print);\n\t\tres |= bnx2x_check_blocks_with_parity2(bp,\n\t\t\tsig[2] & HW_PRTY_ASSERT_SET_2, &par_num, print);\n\t\tres |= bnx2x_check_blocks_with_parity3(bp,\n\t\t\tsig[3] & HW_PRTY_ASSERT_SET_3, &par_num, global, print);\n\t\tres |= bnx2x_check_blocks_with_parity4(bp,\n\t\t\tsig[4] & HW_PRTY_ASSERT_SET_4, &par_num, print);\n\n\t\tif (print)\n\t\t\tpr_cont(\"\\n\");\n\t}\n\n\treturn res;\n}\n\n/**\n * bnx2x_chk_parity_attn - checks for parity attentions.\n *\n * @bp:\t\tdriver handle\n * @global:\ttrue if there was a global attention\n * @print:\tshow parity attention in syslog\n */\nbool bnx2x_chk_parity_attn(struct bnx2x *bp, bool *global, bool print)\n{\n\tstruct attn_route attn = { {0} };\n\tint port = BP_PORT(bp);\n\n\tattn.sig[0] = REG_RD(bp,\n\t\tMISC_REG_AEU_AFTER_INVERT_1_FUNC_0 +\n\t\t\t     port*4);\n\tattn.sig[1] = REG_RD(bp,\n\t\tMISC_REG_AEU_AFTER_INVERT_2_FUNC_0 +\n\t\t\t     port*4);\n\tattn.sig[2] = REG_RD(bp,\n\t\tMISC_REG_AEU_AFTER_INVERT_3_FUNC_0 +\n\t\t\t     port*4);\n\tattn.sig[3] = REG_RD(bp,\n\t\tMISC_REG_AEU_AFTER_INVERT_4_FUNC_0 +\n\t\t\t     port*4);\n\t/* Since MCP attentions can't be disabled inside the block, we need to\n\t * read AEU registers to see whether they're currently disabled\n\t */\n\tattn.sig[3] &= ((REG_RD(bp,\n\t\t\t\t!port ? MISC_REG_AEU_ENABLE4_FUNC_0_OUT_0\n\t\t\t\t      : MISC_REG_AEU_ENABLE4_FUNC_1_OUT_0) &\n\t\t\t MISC_AEU_ENABLE_MCP_PRTY_BITS) |\n\t\t\t~MISC_AEU_ENABLE_MCP_PRTY_BITS);\n\n\tif (!CHIP_IS_E1x(bp))\n\t\tattn.sig[4] = REG_RD(bp,\n\t\t\tMISC_REG_AEU_AFTER_INVERT_5_FUNC_0 +\n\t\t\t\t     port*4);\n\n\treturn bnx2x_parity_attn(bp, global, print, attn.sig);\n}\n\nstatic void bnx2x_attn_int_deasserted4(struct bnx2x *bp, u32 attn)\n{\n\tu32 val;\n\tif (attn & AEU_INPUTS_ATTN_BITS_PGLUE_HW_INTERRUPT) {\n\n\t\tval = REG_RD(bp, PGLUE_B_REG_PGLUE_B_INT_STS_CLR);\n\t\tBNX2X_ERR(\"PGLUE hw attention 0x%x\\n\", val);\n\t\tif (val & PGLUE_B_PGLUE_B_INT_STS_REG_ADDRESS_ERROR)\n\t\t\tBNX2X_ERR(\"PGLUE_B_PGLUE_B_INT_STS_REG_ADDRESS_ERROR\\n\");\n\t\tif (val & PGLUE_B_PGLUE_B_INT_STS_REG_INCORRECT_RCV_BEHAVIOR)\n\t\t\tBNX2X_ERR(\"PGLUE_B_PGLUE_B_INT_STS_REG_INCORRECT_RCV_BEHAVIOR\\n\");\n\t\tif (val & PGLUE_B_PGLUE_B_INT_STS_REG_WAS_ERROR_ATTN)\n\t\t\tBNX2X_ERR(\"PGLUE_B_PGLUE_B_INT_STS_REG_WAS_ERROR_ATTN\\n\");\n\t\tif (val & PGLUE_B_PGLUE_B_INT_STS_REG_VF_LENGTH_VIOLATION_ATTN)\n\t\t\tBNX2X_ERR(\"PGLUE_B_PGLUE_B_INT_STS_REG_VF_LENGTH_VIOLATION_ATTN\\n\");\n\t\tif (val &\n\t\t    PGLUE_B_PGLUE_B_INT_STS_REG_VF_GRC_SPACE_VIOLATION_ATTN)\n\t\t\tBNX2X_ERR(\"PGLUE_B_PGLUE_B_INT_STS_REG_VF_GRC_SPACE_VIOLATION_ATTN\\n\");\n\t\tif (val &\n\t\t    PGLUE_B_PGLUE_B_INT_STS_REG_VF_MSIX_BAR_VIOLATION_ATTN)\n\t\t\tBNX2X_ERR(\"PGLUE_B_PGLUE_B_INT_STS_REG_VF_MSIX_BAR_VIOLATION_ATTN\\n\");\n\t\tif (val & PGLUE_B_PGLUE_B_INT_STS_REG_TCPL_ERROR_ATTN)\n\t\t\tBNX2X_ERR(\"PGLUE_B_PGLUE_B_INT_STS_REG_TCPL_ERROR_ATTN\\n\");\n\t\tif (val & PGLUE_B_PGLUE_B_INT_STS_REG_TCPL_IN_TWO_RCBS_ATTN)\n\t\t\tBNX2X_ERR(\"PGLUE_B_PGLUE_B_INT_STS_REG_TCPL_IN_TWO_RCBS_ATTN\\n\");\n\t\tif (val & PGLUE_B_PGLUE_B_INT_STS_REG_CSSNOOP_FIFO_OVERFLOW)\n\t\t\tBNX2X_ERR(\"PGLUE_B_PGLUE_B_INT_STS_REG_CSSNOOP_FIFO_OVERFLOW\\n\");\n\t}\n\tif (attn & AEU_INPUTS_ATTN_BITS_ATC_HW_INTERRUPT) {\n\t\tval = REG_RD(bp, ATC_REG_ATC_INT_STS_CLR);\n\t\tBNX2X_ERR(\"ATC hw attention 0x%x\\n\", val);\n\t\tif (val & ATC_ATC_INT_STS_REG_ADDRESS_ERROR)\n\t\t\tBNX2X_ERR(\"ATC_ATC_INT_STS_REG_ADDRESS_ERROR\\n\");\n\t\tif (val & ATC_ATC_INT_STS_REG_ATC_TCPL_TO_NOT_PEND)\n\t\t\tBNX2X_ERR(\"ATC_ATC_INT_STS_REG_ATC_TCPL_TO_NOT_PEND\\n\");\n\t\tif (val & ATC_ATC_INT_STS_REG_ATC_GPA_MULTIPLE_HITS)\n\t\t\tBNX2X_ERR(\"ATC_ATC_INT_STS_REG_ATC_GPA_MULTIPLE_HITS\\n\");\n\t\tif (val & ATC_ATC_INT_STS_REG_ATC_RCPL_TO_EMPTY_CNT)\n\t\t\tBNX2X_ERR(\"ATC_ATC_INT_STS_REG_ATC_RCPL_TO_EMPTY_CNT\\n\");\n\t\tif (val & ATC_ATC_INT_STS_REG_ATC_TCPL_ERROR)\n\t\t\tBNX2X_ERR(\"ATC_ATC_INT_STS_REG_ATC_TCPL_ERROR\\n\");\n\t\tif (val & ATC_ATC_INT_STS_REG_ATC_IREQ_LESS_THAN_STU)\n\t\t\tBNX2X_ERR(\"ATC_ATC_INT_STS_REG_ATC_IREQ_LESS_THAN_STU\\n\");\n\t}\n\n\tif (attn & (AEU_INPUTS_ATTN_BITS_PGLUE_PARITY_ERROR |\n\t\t    AEU_INPUTS_ATTN_BITS_ATC_PARITY_ERROR)) {\n\t\tBNX2X_ERR(\"FATAL parity attention set4 0x%x\\n\",\n\t\t(u32)(attn & (AEU_INPUTS_ATTN_BITS_PGLUE_PARITY_ERROR |\n\t\t    AEU_INPUTS_ATTN_BITS_ATC_PARITY_ERROR)));\n\t}\n}\n\nstatic void bnx2x_attn_int_deasserted(struct bnx2x *bp, u32 deasserted)\n{\n\tstruct attn_route attn, *group_mask;\n\tint port = BP_PORT(bp);\n\tint index;\n\tu32 reg_addr;\n\tu32 val;\n\tu32 aeu_mask;\n\tbool global = false;\n\n\t/* need to take HW lock because MCP or other port might also\n\t   try to handle this event */\n\tbnx2x_acquire_alr(bp);\n\n\tif (bnx2x_chk_parity_attn(bp, &global, true)) {\n#ifndef BNX2X_STOP_ON_ERROR\n\t\tbp->recovery_state = BNX2X_RECOVERY_INIT;\n\t\tschedule_delayed_work(&bp->sp_rtnl_task, 0);\n\t\t/* Disable HW interrupts */\n\t\tbnx2x_int_disable(bp);\n\t\t/* In case of parity errors don't handle attentions so that\n\t\t * other function would \"see\" parity errors.\n\t\t */\n#else\n\t\tbnx2x_panic();\n#endif\n\t\tbnx2x_release_alr(bp);\n\t\treturn;\n\t}\n\n\tattn.sig[0] = REG_RD(bp, MISC_REG_AEU_AFTER_INVERT_1_FUNC_0 + port*4);\n\tattn.sig[1] = REG_RD(bp, MISC_REG_AEU_AFTER_INVERT_2_FUNC_0 + port*4);\n\tattn.sig[2] = REG_RD(bp, MISC_REG_AEU_AFTER_INVERT_3_FUNC_0 + port*4);\n\tattn.sig[3] = REG_RD(bp, MISC_REG_AEU_AFTER_INVERT_4_FUNC_0 + port*4);\n\tif (!CHIP_IS_E1x(bp))\n\t\tattn.sig[4] =\n\t\t      REG_RD(bp, MISC_REG_AEU_AFTER_INVERT_5_FUNC_0 + port*4);\n\telse\n\t\tattn.sig[4] = 0;\n\n\tDP(NETIF_MSG_HW, \"attn: %08x %08x %08x %08x %08x\\n\",\n\t   attn.sig[0], attn.sig[1], attn.sig[2], attn.sig[3], attn.sig[4]);\n\n\tfor (index = 0; index < MAX_DYNAMIC_ATTN_GRPS; index++) {\n\t\tif (deasserted & (1 << index)) {\n\t\t\tgroup_mask = &bp->attn_group[index];\n\n\t\t\tDP(NETIF_MSG_HW, \"group[%d]: %08x %08x %08x %08x %08x\\n\",\n\t\t\t   index,\n\t\t\t   group_mask->sig[0], group_mask->sig[1],\n\t\t\t   group_mask->sig[2], group_mask->sig[3],\n\t\t\t   group_mask->sig[4]);\n\n\t\t\tbnx2x_attn_int_deasserted4(bp,\n\t\t\t\t\tattn.sig[4] & group_mask->sig[4]);\n\t\t\tbnx2x_attn_int_deasserted3(bp,\n\t\t\t\t\tattn.sig[3] & group_mask->sig[3]);\n\t\t\tbnx2x_attn_int_deasserted1(bp,\n\t\t\t\t\tattn.sig[1] & group_mask->sig[1]);\n\t\t\tbnx2x_attn_int_deasserted2(bp,\n\t\t\t\t\tattn.sig[2] & group_mask->sig[2]);\n\t\t\tbnx2x_attn_int_deasserted0(bp,\n\t\t\t\t\tattn.sig[0] & group_mask->sig[0]);\n\t\t}\n\t}\n\n\tbnx2x_release_alr(bp);\n\n\tif (bp->common.int_block == INT_BLOCK_HC)\n\t\treg_addr = (HC_REG_COMMAND_REG + port*32 +\n\t\t\t    COMMAND_REG_ATTN_BITS_CLR);\n\telse\n\t\treg_addr = (BAR_IGU_INTMEM + IGU_CMD_ATTN_BIT_CLR_UPPER*8);\n\n\tval = ~deasserted;\n\tDP(NETIF_MSG_HW, \"about to mask 0x%08x at %s addr 0x%x\\n\", val,\n\t   (bp->common.int_block == INT_BLOCK_HC) ? \"HC\" : \"IGU\", reg_addr);\n\tREG_WR(bp, reg_addr, val);\n\n\tif (~bp->attn_state & deasserted)\n\t\tBNX2X_ERR(\"IGU ERROR\\n\");\n\n\treg_addr = port ? MISC_REG_AEU_MASK_ATTN_FUNC_1 :\n\t\t\t  MISC_REG_AEU_MASK_ATTN_FUNC_0;\n\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_PORT0_ATT_MASK + port);\n\taeu_mask = REG_RD(bp, reg_addr);\n\n\tDP(NETIF_MSG_HW, \"aeu_mask %x  newly deasserted %x\\n\",\n\t   aeu_mask, deasserted);\n\taeu_mask |= (deasserted & 0x3ff);\n\tDP(NETIF_MSG_HW, \"new mask %x\\n\", aeu_mask);\n\n\tREG_WR(bp, reg_addr, aeu_mask);\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_PORT0_ATT_MASK + port);\n\n\tDP(NETIF_MSG_HW, \"attn_state %x\\n\", bp->attn_state);\n\tbp->attn_state &= ~deasserted;\n\tDP(NETIF_MSG_HW, \"new state %x\\n\", bp->attn_state);\n}\n\nstatic void bnx2x_attn_int(struct bnx2x *bp)\n{\n\t/* read local copy of bits */\n\tu32 attn_bits = le32_to_cpu(bp->def_status_blk->atten_status_block.\n\t\t\t\t\t\t\t\tattn_bits);\n\tu32 attn_ack = le32_to_cpu(bp->def_status_blk->atten_status_block.\n\t\t\t\t\t\t\t\tattn_bits_ack);\n\tu32 attn_state = bp->attn_state;\n\n\t/* look for changed bits */\n\tu32 asserted   =  attn_bits & ~attn_ack & ~attn_state;\n\tu32 deasserted = ~attn_bits &  attn_ack &  attn_state;\n\n\tDP(NETIF_MSG_HW,\n\t   \"attn_bits %x  attn_ack %x  asserted %x  deasserted %x\\n\",\n\t   attn_bits, attn_ack, asserted, deasserted);\n\n\tif (~(attn_bits ^ attn_ack) & (attn_bits ^ attn_state))\n\t\tBNX2X_ERR(\"BAD attention state\\n\");\n\n\t/* handle bits that were raised */\n\tif (asserted)\n\t\tbnx2x_attn_int_asserted(bp, asserted);\n\n\tif (deasserted)\n\t\tbnx2x_attn_int_deasserted(bp, deasserted);\n}\n\nvoid bnx2x_igu_ack_sb(struct bnx2x *bp, u8 igu_sb_id, u8 segment,\n\t\t      u16 index, u8 op, u8 update)\n{\n\tu32 igu_addr = bp->igu_base_addr;\n\tigu_addr += (IGU_CMD_INT_ACK_BASE + igu_sb_id)*8;\n\tbnx2x_igu_ack_sb_gen(bp, igu_sb_id, segment, index, op, update,\n\t\t\t     igu_addr);\n}\n\nstatic void bnx2x_update_eq_prod(struct bnx2x *bp, u16 prod)\n{\n\t/* No memory barriers */\n\tstorm_memset_eq_prod(bp, prod, BP_FUNC(bp));\n}\n\nstatic int  bnx2x_cnic_handle_cfc_del(struct bnx2x *bp, u32 cid,\n\t\t\t\t      union event_ring_elem *elem)\n{\n\tu8 err = elem->message.error;\n\n\tif (!bp->cnic_eth_dev.starting_cid  ||\n\t    (cid < bp->cnic_eth_dev.starting_cid &&\n\t    cid != bp->cnic_eth_dev.iscsi_l2_cid))\n\t\treturn 1;\n\n\tDP(BNX2X_MSG_SP, \"got delete ramrod for CNIC CID %d\\n\", cid);\n\n\tif (unlikely(err)) {\n\n\t\tBNX2X_ERR(\"got delete ramrod for CNIC CID %d with error!\\n\",\n\t\t\t  cid);\n\t\tbnx2x_panic_dump(bp, false);\n\t}\n\tbnx2x_cnic_cfc_comp(bp, cid, err);\n\treturn 0;\n}\n\nstatic void bnx2x_handle_mcast_eqe(struct bnx2x *bp)\n{\n\tstruct bnx2x_mcast_ramrod_params rparam;\n\tint rc;\n\n\tmemset(&rparam, 0, sizeof(rparam));\n\n\trparam.mcast_obj = &bp->mcast_obj;\n\n\tnetif_addr_lock_bh(bp->dev);\n\n\t/* Clear pending state for the last command */\n\tbp->mcast_obj.raw.clear_pending(&bp->mcast_obj.raw);\n\n\t/* If there are pending mcast commands - send them */\n\tif (bp->mcast_obj.check_pending(&bp->mcast_obj)) {\n\t\trc = bnx2x_config_mcast(bp, &rparam, BNX2X_MCAST_CMD_CONT);\n\t\tif (rc < 0)\n\t\t\tBNX2X_ERR(\"Failed to send pending mcast commands: %d\\n\",\n\t\t\t\t  rc);\n\t}\n\n\tnetif_addr_unlock_bh(bp->dev);\n}\n\nstatic void bnx2x_handle_classification_eqe(struct bnx2x *bp,\n\t\t\t\t\t    union event_ring_elem *elem)\n{\n\tunsigned long ramrod_flags = 0;\n\tint rc = 0;\n\tu32 echo = le32_to_cpu(elem->message.data.eth_event.echo);\n\tu32 cid = echo & BNX2X_SWCID_MASK;\n\tstruct bnx2x_vlan_mac_obj *vlan_mac_obj;\n\n\t/* Always push next commands out, don't wait here */\n\t__set_bit(RAMROD_CONT, &ramrod_flags);\n\n\tswitch (echo >> BNX2X_SWCID_SHIFT) {\n\tcase BNX2X_FILTER_MAC_PENDING:\n\t\tDP(BNX2X_MSG_SP, \"Got SETUP_MAC completions\\n\");\n\t\tif (CNIC_LOADED(bp) && (cid == BNX2X_ISCSI_ETH_CID(bp)))\n\t\t\tvlan_mac_obj = &bp->iscsi_l2_mac_obj;\n\t\telse\n\t\t\tvlan_mac_obj = &bp->sp_objs[cid].mac_obj;\n\n\t\tbreak;\n\tcase BNX2X_FILTER_VLAN_PENDING:\n\t\tDP(BNX2X_MSG_SP, \"Got SETUP_VLAN completions\\n\");\n\t\tvlan_mac_obj = &bp->sp_objs[cid].vlan_obj;\n\t\tbreak;\n\tcase BNX2X_FILTER_MCAST_PENDING:\n\t\tDP(BNX2X_MSG_SP, \"Got SETUP_MCAST completions\\n\");\n\t\t/* This is only relevant for 57710 where multicast MACs are\n\t\t * configured as unicast MACs using the same ramrod.\n\t\t */\n\t\tbnx2x_handle_mcast_eqe(bp);\n\t\treturn;\n\tdefault:\n\t\tBNX2X_ERR(\"Unsupported classification command: 0x%x\\n\", echo);\n\t\treturn;\n\t}\n\n\trc = vlan_mac_obj->complete(bp, vlan_mac_obj, elem, &ramrod_flags);\n\n\tif (rc < 0)\n\t\tBNX2X_ERR(\"Failed to schedule new commands: %d\\n\", rc);\n\telse if (rc > 0)\n\t\tDP(BNX2X_MSG_SP, \"Scheduled next pending commands...\\n\");\n}\n\nstatic void bnx2x_set_iscsi_eth_rx_mode(struct bnx2x *bp, bool start);\n\nstatic void bnx2x_handle_rx_mode_eqe(struct bnx2x *bp)\n{\n\tnetif_addr_lock_bh(bp->dev);\n\n\tclear_bit(BNX2X_FILTER_RX_MODE_PENDING, &bp->sp_state);\n\n\t/* Send rx_mode command again if was requested */\n\tif (test_and_clear_bit(BNX2X_FILTER_RX_MODE_SCHED, &bp->sp_state))\n\t\tbnx2x_set_storm_rx_mode(bp);\n\telse if (test_and_clear_bit(BNX2X_FILTER_ISCSI_ETH_START_SCHED,\n\t\t\t\t    &bp->sp_state))\n\t\tbnx2x_set_iscsi_eth_rx_mode(bp, true);\n\telse if (test_and_clear_bit(BNX2X_FILTER_ISCSI_ETH_STOP_SCHED,\n\t\t\t\t    &bp->sp_state))\n\t\tbnx2x_set_iscsi_eth_rx_mode(bp, false);\n\n\tnetif_addr_unlock_bh(bp->dev);\n}\n\nstatic void bnx2x_after_afex_vif_lists(struct bnx2x *bp,\n\t\t\t\t\t      union event_ring_elem *elem)\n{\n\tif (elem->message.data.vif_list_event.echo == VIF_LIST_RULE_GET) {\n\t\tDP(BNX2X_MSG_SP,\n\t\t   \"afex: ramrod completed VIF LIST_GET, addrs 0x%x\\n\",\n\t\t   elem->message.data.vif_list_event.func_bit_map);\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_AFEX_LISTGET_ACK,\n\t\t\telem->message.data.vif_list_event.func_bit_map);\n\t} else if (elem->message.data.vif_list_event.echo ==\n\t\t   VIF_LIST_RULE_SET) {\n\t\tDP(BNX2X_MSG_SP, \"afex: ramrod completed VIF LIST_SET\\n\");\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_AFEX_LISTSET_ACK, 0);\n\t}\n}\n\n/* called with rtnl_lock */\nstatic void bnx2x_after_function_update(struct bnx2x *bp)\n{\n\tint q, rc;\n\tstruct bnx2x_fastpath *fp;\n\tstruct bnx2x_queue_state_params queue_params = {NULL};\n\tstruct bnx2x_queue_update_params *q_update_params =\n\t\t&queue_params.params.update;\n\n\t/* Send Q update command with afex vlan removal values for all Qs */\n\tqueue_params.cmd = BNX2X_Q_CMD_UPDATE;\n\n\t/* set silent vlan removal values according to vlan mode */\n\t__set_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM_CHNG,\n\t\t  &q_update_params->update_flags);\n\t__set_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM,\n\t\t  &q_update_params->update_flags);\n\t__set_bit(RAMROD_COMP_WAIT, &queue_params.ramrod_flags);\n\n\t/* in access mode mark mask and value are 0 to strip all vlans */\n\tif (bp->afex_vlan_mode == FUNC_MF_CFG_AFEX_VLAN_ACCESS_MODE) {\n\t\tq_update_params->silent_removal_value = 0;\n\t\tq_update_params->silent_removal_mask = 0;\n\t} else {\n\t\tq_update_params->silent_removal_value =\n\t\t\t(bp->afex_def_vlan_tag & VLAN_VID_MASK);\n\t\tq_update_params->silent_removal_mask = VLAN_VID_MASK;\n\t}\n\n\tfor_each_eth_queue(bp, q) {\n\t\t/* Set the appropriate Queue object */\n\t\tfp = &bp->fp[q];\n\t\tqueue_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\n\n\t\t/* send the ramrod */\n\t\trc = bnx2x_queue_state_change(bp, &queue_params);\n\t\tif (rc < 0)\n\t\t\tBNX2X_ERR(\"Failed to config silent vlan rem for Q %d\\n\",\n\t\t\t\t  q);\n\t}\n\n\tif (!NO_FCOE(bp) && CNIC_ENABLED(bp)) {\n\t\tfp = &bp->fp[FCOE_IDX(bp)];\n\t\tqueue_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\n\n\t\t/* clear pending completion bit */\n\t\t__clear_bit(RAMROD_COMP_WAIT, &queue_params.ramrod_flags);\n\n\t\t/* mark latest Q bit */\n\t\tsmp_mb__before_atomic();\n\t\tset_bit(BNX2X_AFEX_FCOE_Q_UPDATE_PENDING, &bp->sp_state);\n\t\tsmp_mb__after_atomic();\n\n\t\t/* send Q update ramrod for FCoE Q */\n\t\trc = bnx2x_queue_state_change(bp, &queue_params);\n\t\tif (rc < 0)\n\t\t\tBNX2X_ERR(\"Failed to config silent vlan rem for Q %d\\n\",\n\t\t\t\t  q);\n\t} else {\n\t\t/* If no FCoE ring - ACK MCP now */\n\t\tbnx2x_link_report(bp);\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_AFEX_VIFSET_ACK, 0);\n\t}\n}\n\nstatic struct bnx2x_queue_sp_obj *bnx2x_cid_to_q_obj(\n\tstruct bnx2x *bp, u32 cid)\n{\n\tDP(BNX2X_MSG_SP, \"retrieving fp from cid %d\\n\", cid);\n\n\tif (CNIC_LOADED(bp) && (cid == BNX2X_FCOE_ETH_CID(bp)))\n\t\treturn &bnx2x_fcoe_sp_obj(bp, q_obj);\n\telse\n\t\treturn &bp->sp_objs[CID_TO_FP(cid, bp)].q_obj;\n}\n\nstatic void bnx2x_eq_int(struct bnx2x *bp)\n{\n\tu16 hw_cons, sw_cons, sw_prod;\n\tunion event_ring_elem *elem;\n\tu8 echo;\n\tu32 cid;\n\tu8 opcode;\n\tint rc, spqe_cnt = 0;\n\tstruct bnx2x_queue_sp_obj *q_obj;\n\tstruct bnx2x_func_sp_obj *f_obj = &bp->func_obj;\n\tstruct bnx2x_raw_obj *rss_raw = &bp->rss_conf_obj.raw;\n\n\thw_cons = le16_to_cpu(*bp->eq_cons_sb);\n\n\t/* The hw_cos range is 1-255, 257 - the sw_cons range is 0-254, 256.\n\t * when we get the next-page we need to adjust so the loop\n\t * condition below will be met. The next element is the size of a\n\t * regular element and hence incrementing by 1\n\t */\n\tif ((hw_cons & EQ_DESC_MAX_PAGE) == EQ_DESC_MAX_PAGE)\n\t\thw_cons++;\n\n\t/* This function may never run in parallel with itself for a\n\t * specific bp, thus there is no need in \"paired\" read memory\n\t * barrier here.\n\t */\n\tsw_cons = bp->eq_cons;\n\tsw_prod = bp->eq_prod;\n\n\tDP(BNX2X_MSG_SP, \"EQ:  hw_cons %u  sw_cons %u bp->eq_spq_left %x\\n\",\n\t\t\thw_cons, sw_cons, atomic_read(&bp->eq_spq_left));\n\n\tfor (; sw_cons != hw_cons;\n\t      sw_prod = NEXT_EQ_IDX(sw_prod), sw_cons = NEXT_EQ_IDX(sw_cons)) {\n\n\t\telem = &bp->eq_ring[EQ_DESC(sw_cons)];\n\n\t\trc = bnx2x_iov_eq_sp_event(bp, elem);\n\t\tif (!rc) {\n\t\t\tDP(BNX2X_MSG_IOV, \"bnx2x_iov_eq_sp_event returned %d\\n\",\n\t\t\t   rc);\n\t\t\tgoto next_spqe;\n\t\t}\n\n\t\topcode = elem->message.opcode;\n\n\t\t/* handle eq element */\n\t\tswitch (opcode) {\n\t\tcase EVENT_RING_OPCODE_VF_PF_CHANNEL:\n\t\t\tbnx2x_vf_mbx_schedule(bp,\n\t\t\t\t\t      &elem->message.data.vf_pf_event);\n\t\t\tcontinue;\n\n\t\tcase EVENT_RING_OPCODE_STAT_QUERY:\n\t\t\tDP_AND((BNX2X_MSG_SP | BNX2X_MSG_STATS),\n\t\t\t       \"got statistics comp event %d\\n\",\n\t\t\t       bp->stats_comp++);\n\t\t\t/* nothing to do with stats comp */\n\t\t\tgoto next_spqe;\n\n\t\tcase EVENT_RING_OPCODE_CFC_DEL:\n\t\t\t/* handle according to cid range */\n\t\t\t/*\n\t\t\t * we may want to verify here that the bp state is\n\t\t\t * HALTING\n\t\t\t */\n\n\t\t\t/* elem CID originates from FW; actually LE */\n\t\t\tcid = SW_CID(elem->message.data.cfc_del_event.cid);\n\n\t\t\tDP(BNX2X_MSG_SP,\n\t\t\t   \"got delete ramrod for MULTI[%d]\\n\", cid);\n\n\t\t\tif (CNIC_LOADED(bp) &&\n\t\t\t    !bnx2x_cnic_handle_cfc_del(bp, cid, elem))\n\t\t\t\tgoto next_spqe;\n\n\t\t\tq_obj = bnx2x_cid_to_q_obj(bp, cid);\n\n\t\t\tif (q_obj->complete_cmd(bp, q_obj, BNX2X_Q_CMD_CFC_DEL))\n\t\t\t\tbreak;\n\n\t\t\tgoto next_spqe;\n\n\t\tcase EVENT_RING_OPCODE_STOP_TRAFFIC:\n\t\t\tDP(BNX2X_MSG_SP | BNX2X_MSG_DCB, \"got STOP TRAFFIC\\n\");\n\t\t\tbnx2x_dcbx_set_params(bp, BNX2X_DCBX_STATE_TX_PAUSED);\n\t\t\tif (f_obj->complete_cmd(bp, f_obj,\n\t\t\t\t\t\tBNX2X_F_CMD_TX_STOP))\n\t\t\t\tbreak;\n\t\t\tgoto next_spqe;\n\n\t\tcase EVENT_RING_OPCODE_START_TRAFFIC:\n\t\t\tDP(BNX2X_MSG_SP | BNX2X_MSG_DCB, \"got START TRAFFIC\\n\");\n\t\t\tbnx2x_dcbx_set_params(bp, BNX2X_DCBX_STATE_TX_RELEASED);\n\t\t\tif (f_obj->complete_cmd(bp, f_obj,\n\t\t\t\t\t\tBNX2X_F_CMD_TX_START))\n\t\t\t\tbreak;\n\t\t\tgoto next_spqe;\n\n\t\tcase EVENT_RING_OPCODE_FUNCTION_UPDATE:\n\t\t\techo = elem->message.data.function_update_event.echo;\n\t\t\tif (echo == SWITCH_UPDATE) {\n\t\t\t\tDP(BNX2X_MSG_SP | NETIF_MSG_IFUP,\n\t\t\t\t   \"got FUNC_SWITCH_UPDATE ramrod\\n\");\n\t\t\t\tif (f_obj->complete_cmd(\n\t\t\t\t\tbp, f_obj, BNX2X_F_CMD_SWITCH_UPDATE))\n\t\t\t\t\tbreak;\n\n\t\t\t} else {\n\t\t\t\tint cmd = BNX2X_SP_RTNL_AFEX_F_UPDATE;\n\n\t\t\t\tDP(BNX2X_MSG_SP | BNX2X_MSG_MCP,\n\t\t\t\t   \"AFEX: ramrod completed FUNCTION_UPDATE\\n\");\n\t\t\t\tf_obj->complete_cmd(bp, f_obj,\n\t\t\t\t\t\t    BNX2X_F_CMD_AFEX_UPDATE);\n\n\t\t\t\t/* We will perform the Queues update from\n\t\t\t\t * sp_rtnl task as all Queue SP operations\n\t\t\t\t * should run under rtnl_lock.\n\t\t\t\t */\n\t\t\t\tbnx2x_schedule_sp_rtnl(bp, cmd, 0);\n\t\t\t}\n\n\t\t\tgoto next_spqe;\n\n\t\tcase EVENT_RING_OPCODE_AFEX_VIF_LISTS:\n\t\t\tf_obj->complete_cmd(bp, f_obj,\n\t\t\t\t\t    BNX2X_F_CMD_AFEX_VIFLISTS);\n\t\t\tbnx2x_after_afex_vif_lists(bp, elem);\n\t\t\tgoto next_spqe;\n\t\tcase EVENT_RING_OPCODE_FUNCTION_START:\n\t\t\tDP(BNX2X_MSG_SP | NETIF_MSG_IFUP,\n\t\t\t   \"got FUNC_START ramrod\\n\");\n\t\t\tif (f_obj->complete_cmd(bp, f_obj, BNX2X_F_CMD_START))\n\t\t\t\tbreak;\n\n\t\t\tgoto next_spqe;\n\n\t\tcase EVENT_RING_OPCODE_FUNCTION_STOP:\n\t\t\tDP(BNX2X_MSG_SP | NETIF_MSG_IFUP,\n\t\t\t   \"got FUNC_STOP ramrod\\n\");\n\t\t\tif (f_obj->complete_cmd(bp, f_obj, BNX2X_F_CMD_STOP))\n\t\t\t\tbreak;\n\n\t\t\tgoto next_spqe;\n\n\t\tcase EVENT_RING_OPCODE_SET_TIMESYNC:\n\t\t\tDP(BNX2X_MSG_SP | BNX2X_MSG_PTP,\n\t\t\t   \"got set_timesync ramrod completion\\n\");\n\t\t\tif (f_obj->complete_cmd(bp, f_obj,\n\t\t\t\t\t\tBNX2X_F_CMD_SET_TIMESYNC))\n\t\t\t\tbreak;\n\t\t\tgoto next_spqe;\n\t\t}\n\n\t\tswitch (opcode | bp->state) {\n\t\tcase (EVENT_RING_OPCODE_RSS_UPDATE_RULES |\n\t\t      BNX2X_STATE_OPEN):\n\t\tcase (EVENT_RING_OPCODE_RSS_UPDATE_RULES |\n\t\t      BNX2X_STATE_OPENING_WAIT4_PORT):\n\t\tcase (EVENT_RING_OPCODE_RSS_UPDATE_RULES |\n\t\t      BNX2X_STATE_CLOSING_WAIT4_HALT):\n\t\t\tDP(BNX2X_MSG_SP, \"got RSS_UPDATE ramrod. CID %d\\n\",\n\t\t\t   SW_CID(elem->message.data.eth_event.echo));\n\t\t\trss_raw->clear_pending(rss_raw);\n\t\t\tbreak;\n\n\t\tcase (EVENT_RING_OPCODE_SET_MAC | BNX2X_STATE_OPEN):\n\t\tcase (EVENT_RING_OPCODE_SET_MAC | BNX2X_STATE_DIAG):\n\t\tcase (EVENT_RING_OPCODE_SET_MAC |\n\t\t      BNX2X_STATE_CLOSING_WAIT4_HALT):\n\t\tcase (EVENT_RING_OPCODE_CLASSIFICATION_RULES |\n\t\t      BNX2X_STATE_OPEN):\n\t\tcase (EVENT_RING_OPCODE_CLASSIFICATION_RULES |\n\t\t      BNX2X_STATE_DIAG):\n\t\tcase (EVENT_RING_OPCODE_CLASSIFICATION_RULES |\n\t\t      BNX2X_STATE_CLOSING_WAIT4_HALT):\n\t\t\tDP(BNX2X_MSG_SP, \"got (un)set vlan/mac ramrod\\n\");\n\t\t\tbnx2x_handle_classification_eqe(bp, elem);\n\t\t\tbreak;\n\n\t\tcase (EVENT_RING_OPCODE_MULTICAST_RULES |\n\t\t      BNX2X_STATE_OPEN):\n\t\tcase (EVENT_RING_OPCODE_MULTICAST_RULES |\n\t\t      BNX2X_STATE_DIAG):\n\t\tcase (EVENT_RING_OPCODE_MULTICAST_RULES |\n\t\t      BNX2X_STATE_CLOSING_WAIT4_HALT):\n\t\t\tDP(BNX2X_MSG_SP, \"got mcast ramrod\\n\");\n\t\t\tbnx2x_handle_mcast_eqe(bp);\n\t\t\tbreak;\n\n\t\tcase (EVENT_RING_OPCODE_FILTERS_RULES |\n\t\t      BNX2X_STATE_OPEN):\n\t\tcase (EVENT_RING_OPCODE_FILTERS_RULES |\n\t\t      BNX2X_STATE_DIAG):\n\t\tcase (EVENT_RING_OPCODE_FILTERS_RULES |\n\t\t      BNX2X_STATE_CLOSING_WAIT4_HALT):\n\t\t\tDP(BNX2X_MSG_SP, \"got rx_mode ramrod\\n\");\n\t\t\tbnx2x_handle_rx_mode_eqe(bp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* unknown event log error and continue */\n\t\t\tBNX2X_ERR(\"Unknown EQ event %d, bp->state 0x%x\\n\",\n\t\t\t\t  elem->message.opcode, bp->state);\n\t\t}\nnext_spqe:\n\t\tspqe_cnt++;\n\t} /* for */\n\n\tsmp_mb__before_atomic();\n\tatomic_add(spqe_cnt, &bp->eq_spq_left);\n\n\tbp->eq_cons = sw_cons;\n\tbp->eq_prod = sw_prod;\n\t/* Make sure that above mem writes were issued towards the memory */\n\tsmp_wmb();\n\n\t/* update producer */\n\tbnx2x_update_eq_prod(bp, bp->eq_prod);\n}\n\nstatic void bnx2x_sp_task(struct work_struct *work)\n{\n\tstruct bnx2x *bp = container_of(work, struct bnx2x, sp_task.work);\n\n\tDP(BNX2X_MSG_SP, \"sp task invoked\\n\");\n\n\t/* make sure the atomic interrupt_occurred has been written */\n\tsmp_rmb();\n\tif (atomic_read(&bp->interrupt_occurred)) {\n\n\t\t/* what work needs to be performed? */\n\t\tu16 status = bnx2x_update_dsb_idx(bp);\n\n\t\tDP(BNX2X_MSG_SP, \"status %x\\n\", status);\n\t\tDP(BNX2X_MSG_SP, \"setting interrupt_occurred to 0\\n\");\n\t\tatomic_set(&bp->interrupt_occurred, 0);\n\n\t\t/* HW attentions */\n\t\tif (status & BNX2X_DEF_SB_ATT_IDX) {\n\t\t\tbnx2x_attn_int(bp);\n\t\t\tstatus &= ~BNX2X_DEF_SB_ATT_IDX;\n\t\t}\n\n\t\t/* SP events: STAT_QUERY and others */\n\t\tif (status & BNX2X_DEF_SB_IDX) {\n\t\t\tstruct bnx2x_fastpath *fp = bnx2x_fcoe_fp(bp);\n\n\t\t\tif (FCOE_INIT(bp) &&\n\t\t\t    (bnx2x_has_rx_work(fp) || bnx2x_has_tx_work(fp))) {\n\t\t\t\t/* Prevent local bottom-halves from running as\n\t\t\t\t * we are going to change the local NAPI list.\n\t\t\t\t */\n\t\t\t\tlocal_bh_disable();\n\t\t\t\tnapi_schedule(&bnx2x_fcoe(bp, napi));\n\t\t\t\tlocal_bh_enable();\n\t\t\t}\n\n\t\t\t/* Handle EQ completions */\n\t\t\tbnx2x_eq_int(bp);\n\t\t\tbnx2x_ack_sb(bp, bp->igu_dsb_id, USTORM_ID,\n\t\t\t\t     le16_to_cpu(bp->def_idx), IGU_INT_NOP, 1);\n\n\t\t\tstatus &= ~BNX2X_DEF_SB_IDX;\n\t\t}\n\n\t\t/* if status is non zero then perhaps something went wrong */\n\t\tif (unlikely(status))\n\t\t\tDP(BNX2X_MSG_SP,\n\t\t\t   \"got an unknown interrupt! (status 0x%x)\\n\", status);\n\n\t\t/* ack status block only if something was actually handled */\n\t\tbnx2x_ack_sb(bp, bp->igu_dsb_id, ATTENTION_ID,\n\t\t\t     le16_to_cpu(bp->def_att_idx), IGU_INT_ENABLE, 1);\n\t}\n\n\t/* afex - poll to check if VIFSET_ACK should be sent to MFW */\n\tif (test_and_clear_bit(BNX2X_AFEX_PENDING_VIFSET_MCP_ACK,\n\t\t\t       &bp->sp_state)) {\n\t\tbnx2x_link_report(bp);\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_AFEX_VIFSET_ACK, 0);\n\t}\n}\n\nirqreturn_t bnx2x_msix_sp_int(int irq, void *dev_instance)\n{\n\tstruct net_device *dev = dev_instance;\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tbnx2x_ack_sb(bp, bp->igu_dsb_id, USTORM_ID, 0,\n\t\t     IGU_INT_DISABLE, 0);\n\n#ifdef BNX2X_STOP_ON_ERROR\n\tif (unlikely(bp->panic))\n\t\treturn IRQ_HANDLED;\n#endif\n\n\tif (CNIC_LOADED(bp)) {\n\t\tstruct cnic_ops *c_ops;\n\n\t\trcu_read_lock();\n\t\tc_ops = rcu_dereference(bp->cnic_ops);\n\t\tif (c_ops)\n\t\t\tc_ops->cnic_handler(bp->cnic_data, NULL);\n\t\trcu_read_unlock();\n\t}\n\n\t/* schedule sp task to perform default status block work, ack\n\t * attentions and enable interrupts.\n\t */\n\tbnx2x_schedule_sp_task(bp);\n\n\treturn IRQ_HANDLED;\n}\n\n/* end of slow path */\n\nvoid bnx2x_drv_pulse(struct bnx2x *bp)\n{\n\tSHMEM_WR(bp, func_mb[BP_FW_MB_IDX(bp)].drv_pulse_mb,\n\t\t bp->fw_drv_pulse_wr_seq);\n}\n\nstatic void bnx2x_timer(struct timer_list *t)\n{\n\tstruct bnx2x *bp = from_timer(bp, t, timer);\n\n\tif (!netif_running(bp->dev))\n\t\treturn;\n\n\tif (IS_PF(bp) &&\n\t    !BP_NOMCP(bp)) {\n\t\tint mb_idx = BP_FW_MB_IDX(bp);\n\t\tu16 drv_pulse;\n\t\tu16 mcp_pulse;\n\n\t\t++bp->fw_drv_pulse_wr_seq;\n\t\tbp->fw_drv_pulse_wr_seq &= DRV_PULSE_SEQ_MASK;\n\t\tdrv_pulse = bp->fw_drv_pulse_wr_seq;\n\t\tbnx2x_drv_pulse(bp);\n\n\t\tmcp_pulse = (SHMEM_RD(bp, func_mb[mb_idx].mcp_pulse_mb) &\n\t\t\t     MCP_PULSE_SEQ_MASK);\n\t\t/* The delta between driver pulse and mcp response\n\t\t * should not get too big. If the MFW is more than 5 pulses\n\t\t * behind, we should worry about it enough to generate an error\n\t\t * log.\n\t\t */\n\t\tif (((drv_pulse - mcp_pulse) & MCP_PULSE_SEQ_MASK) > 5)\n\t\t\tBNX2X_ERR(\"MFW seems hanged: drv_pulse (0x%x) != mcp_pulse (0x%x)\\n\",\n\t\t\t\t  drv_pulse, mcp_pulse);\n\t}\n\n\tif (bp->state == BNX2X_STATE_OPEN)\n\t\tbnx2x_stats_handle(bp, STATS_EVENT_UPDATE);\n\n\t/* sample pf vf bulletin board for new posts from pf */\n\tif (IS_VF(bp))\n\t\tbnx2x_timer_sriov(bp);\n\n\tmod_timer(&bp->timer, jiffies + bp->current_interval);\n}\n\n/* end of Statistics */\n\n/* nic init */\n\n/*\n * nic init service functions\n */\n\nstatic void bnx2x_fill(struct bnx2x *bp, u32 addr, int fill, u32 len)\n{\n\tu32 i;\n\tif (!(len%4) && !(addr%4))\n\t\tfor (i = 0; i < len; i += 4)\n\t\t\tREG_WR(bp, addr + i, fill);\n\telse\n\t\tfor (i = 0; i < len; i++)\n\t\t\tREG_WR8(bp, addr + i, fill);\n}\n\n/* helper: writes FP SP data to FW - data_size in dwords */\nstatic void bnx2x_wr_fp_sb_data(struct bnx2x *bp,\n\t\t\t\tint fw_sb_id,\n\t\t\t\tu32 *sb_data_p,\n\t\t\t\tu32 data_size)\n{\n\tint index;\n\tfor (index = 0; index < data_size; index++)\n\t\tREG_WR(bp, BAR_CSTRORM_INTMEM +\n\t\t\tCSTORM_STATUS_BLOCK_DATA_OFFSET(fw_sb_id) +\n\t\t\tsizeof(u32)*index,\n\t\t\t*(sb_data_p + index));\n}\n\nstatic void bnx2x_zero_fp_sb(struct bnx2x *bp, int fw_sb_id)\n{\n\tu32 *sb_data_p;\n\tu32 data_size = 0;\n\tstruct hc_status_block_data_e2 sb_data_e2;\n\tstruct hc_status_block_data_e1x sb_data_e1x;\n\n\t/* disable the function first */\n\tif (!CHIP_IS_E1x(bp)) {\n\t\tmemset(&sb_data_e2, 0, sizeof(struct hc_status_block_data_e2));\n\t\tsb_data_e2.common.state = SB_DISABLED;\n\t\tsb_data_e2.common.p_func.vf_valid = false;\n\t\tsb_data_p = (u32 *)&sb_data_e2;\n\t\tdata_size = sizeof(struct hc_status_block_data_e2)/sizeof(u32);\n\t} else {\n\t\tmemset(&sb_data_e1x, 0,\n\t\t       sizeof(struct hc_status_block_data_e1x));\n\t\tsb_data_e1x.common.state = SB_DISABLED;\n\t\tsb_data_e1x.common.p_func.vf_valid = false;\n\t\tsb_data_p = (u32 *)&sb_data_e1x;\n\t\tdata_size = sizeof(struct hc_status_block_data_e1x)/sizeof(u32);\n\t}\n\tbnx2x_wr_fp_sb_data(bp, fw_sb_id, sb_data_p, data_size);\n\n\tbnx2x_fill(bp, BAR_CSTRORM_INTMEM +\n\t\t\tCSTORM_STATUS_BLOCK_OFFSET(fw_sb_id), 0,\n\t\t\tCSTORM_STATUS_BLOCK_SIZE);\n\tbnx2x_fill(bp, BAR_CSTRORM_INTMEM +\n\t\t\tCSTORM_SYNC_BLOCK_OFFSET(fw_sb_id), 0,\n\t\t\tCSTORM_SYNC_BLOCK_SIZE);\n}\n\n/* helper:  writes SP SB data to FW */\nstatic void bnx2x_wr_sp_sb_data(struct bnx2x *bp,\n\t\tstruct hc_sp_status_block_data *sp_sb_data)\n{\n\tint func = BP_FUNC(bp);\n\tint i;\n\tfor (i = 0; i < sizeof(struct hc_sp_status_block_data)/sizeof(u32); i++)\n\t\tREG_WR(bp, BAR_CSTRORM_INTMEM +\n\t\t\tCSTORM_SP_STATUS_BLOCK_DATA_OFFSET(func) +\n\t\t\ti*sizeof(u32),\n\t\t\t*((u32 *)sp_sb_data + i));\n}\n\nstatic void bnx2x_zero_sp_sb(struct bnx2x *bp)\n{\n\tint func = BP_FUNC(bp);\n\tstruct hc_sp_status_block_data sp_sb_data;\n\tmemset(&sp_sb_data, 0, sizeof(struct hc_sp_status_block_data));\n\n\tsp_sb_data.state = SB_DISABLED;\n\tsp_sb_data.p_func.vf_valid = false;\n\n\tbnx2x_wr_sp_sb_data(bp, &sp_sb_data);\n\n\tbnx2x_fill(bp, BAR_CSTRORM_INTMEM +\n\t\t\tCSTORM_SP_STATUS_BLOCK_OFFSET(func), 0,\n\t\t\tCSTORM_SP_STATUS_BLOCK_SIZE);\n\tbnx2x_fill(bp, BAR_CSTRORM_INTMEM +\n\t\t\tCSTORM_SP_SYNC_BLOCK_OFFSET(func), 0,\n\t\t\tCSTORM_SP_SYNC_BLOCK_SIZE);\n}\n\nstatic void bnx2x_setup_ndsb_state_machine(struct hc_status_block_sm *hc_sm,\n\t\t\t\t\t   int igu_sb_id, int igu_seg_id)\n{\n\thc_sm->igu_sb_id = igu_sb_id;\n\thc_sm->igu_seg_id = igu_seg_id;\n\thc_sm->timer_value = 0xFF;\n\thc_sm->time_to_expire = 0xFFFFFFFF;\n}\n\n/* allocates state machine ids. */\nstatic void bnx2x_map_sb_state_machines(struct hc_index_data *index_data)\n{\n\t/* zero out state machine indices */\n\t/* rx indices */\n\tindex_data[HC_INDEX_ETH_RX_CQ_CONS].flags &= ~HC_INDEX_DATA_SM_ID;\n\n\t/* tx indices */\n\tindex_data[HC_INDEX_OOO_TX_CQ_CONS].flags &= ~HC_INDEX_DATA_SM_ID;\n\tindex_data[HC_INDEX_ETH_TX_CQ_CONS_COS0].flags &= ~HC_INDEX_DATA_SM_ID;\n\tindex_data[HC_INDEX_ETH_TX_CQ_CONS_COS1].flags &= ~HC_INDEX_DATA_SM_ID;\n\tindex_data[HC_INDEX_ETH_TX_CQ_CONS_COS2].flags &= ~HC_INDEX_DATA_SM_ID;\n\n\t/* map indices */\n\t/* rx indices */\n\tindex_data[HC_INDEX_ETH_RX_CQ_CONS].flags |=\n\t\tSM_RX_ID << HC_INDEX_DATA_SM_ID_SHIFT;\n\n\t/* tx indices */\n\tindex_data[HC_INDEX_OOO_TX_CQ_CONS].flags |=\n\t\tSM_TX_ID << HC_INDEX_DATA_SM_ID_SHIFT;\n\tindex_data[HC_INDEX_ETH_TX_CQ_CONS_COS0].flags |=\n\t\tSM_TX_ID << HC_INDEX_DATA_SM_ID_SHIFT;\n\tindex_data[HC_INDEX_ETH_TX_CQ_CONS_COS1].flags |=\n\t\tSM_TX_ID << HC_INDEX_DATA_SM_ID_SHIFT;\n\tindex_data[HC_INDEX_ETH_TX_CQ_CONS_COS2].flags |=\n\t\tSM_TX_ID << HC_INDEX_DATA_SM_ID_SHIFT;\n}\n\nvoid bnx2x_init_sb(struct bnx2x *bp, dma_addr_t mapping, int vfid,\n\t\t\t  u8 vf_valid, int fw_sb_id, int igu_sb_id)\n{\n\tint igu_seg_id;\n\n\tstruct hc_status_block_data_e2 sb_data_e2;\n\tstruct hc_status_block_data_e1x sb_data_e1x;\n\tstruct hc_status_block_sm  *hc_sm_p;\n\tint data_size;\n\tu32 *sb_data_p;\n\n\tif (CHIP_INT_MODE_IS_BC(bp))\n\t\tigu_seg_id = HC_SEG_ACCESS_NORM;\n\telse\n\t\tigu_seg_id = IGU_SEG_ACCESS_NORM;\n\n\tbnx2x_zero_fp_sb(bp, fw_sb_id);\n\n\tif (!CHIP_IS_E1x(bp)) {\n\t\tmemset(&sb_data_e2, 0, sizeof(struct hc_status_block_data_e2));\n\t\tsb_data_e2.common.state = SB_ENABLED;\n\t\tsb_data_e2.common.p_func.pf_id = BP_FUNC(bp);\n\t\tsb_data_e2.common.p_func.vf_id = vfid;\n\t\tsb_data_e2.common.p_func.vf_valid = vf_valid;\n\t\tsb_data_e2.common.p_func.vnic_id = BP_VN(bp);\n\t\tsb_data_e2.common.same_igu_sb_1b = true;\n\t\tsb_data_e2.common.host_sb_addr.hi = U64_HI(mapping);\n\t\tsb_data_e2.common.host_sb_addr.lo = U64_LO(mapping);\n\t\thc_sm_p = sb_data_e2.common.state_machine;\n\t\tsb_data_p = (u32 *)&sb_data_e2;\n\t\tdata_size = sizeof(struct hc_status_block_data_e2)/sizeof(u32);\n\t\tbnx2x_map_sb_state_machines(sb_data_e2.index_data);\n\t} else {\n\t\tmemset(&sb_data_e1x, 0,\n\t\t       sizeof(struct hc_status_block_data_e1x));\n\t\tsb_data_e1x.common.state = SB_ENABLED;\n\t\tsb_data_e1x.common.p_func.pf_id = BP_FUNC(bp);\n\t\tsb_data_e1x.common.p_func.vf_id = 0xff;\n\t\tsb_data_e1x.common.p_func.vf_valid = false;\n\t\tsb_data_e1x.common.p_func.vnic_id = BP_VN(bp);\n\t\tsb_data_e1x.common.same_igu_sb_1b = true;\n\t\tsb_data_e1x.common.host_sb_addr.hi = U64_HI(mapping);\n\t\tsb_data_e1x.common.host_sb_addr.lo = U64_LO(mapping);\n\t\thc_sm_p = sb_data_e1x.common.state_machine;\n\t\tsb_data_p = (u32 *)&sb_data_e1x;\n\t\tdata_size = sizeof(struct hc_status_block_data_e1x)/sizeof(u32);\n\t\tbnx2x_map_sb_state_machines(sb_data_e1x.index_data);\n\t}\n\n\tbnx2x_setup_ndsb_state_machine(&hc_sm_p[SM_RX_ID],\n\t\t\t\t       igu_sb_id, igu_seg_id);\n\tbnx2x_setup_ndsb_state_machine(&hc_sm_p[SM_TX_ID],\n\t\t\t\t       igu_sb_id, igu_seg_id);\n\n\tDP(NETIF_MSG_IFUP, \"Init FW SB %d\\n\", fw_sb_id);\n\n\t/* write indices to HW - PCI guarantees endianity of regpairs */\n\tbnx2x_wr_fp_sb_data(bp, fw_sb_id, sb_data_p, data_size);\n}\n\nstatic void bnx2x_update_coalesce_sb(struct bnx2x *bp, u8 fw_sb_id,\n\t\t\t\t     u16 tx_usec, u16 rx_usec)\n{\n\tbnx2x_update_coalesce_sb_index(bp, fw_sb_id, HC_INDEX_ETH_RX_CQ_CONS,\n\t\t\t\t    false, rx_usec);\n\tbnx2x_update_coalesce_sb_index(bp, fw_sb_id,\n\t\t\t\t       HC_INDEX_ETH_TX_CQ_CONS_COS0, false,\n\t\t\t\t       tx_usec);\n\tbnx2x_update_coalesce_sb_index(bp, fw_sb_id,\n\t\t\t\t       HC_INDEX_ETH_TX_CQ_CONS_COS1, false,\n\t\t\t\t       tx_usec);\n\tbnx2x_update_coalesce_sb_index(bp, fw_sb_id,\n\t\t\t\t       HC_INDEX_ETH_TX_CQ_CONS_COS2, false,\n\t\t\t\t       tx_usec);\n}\n\nstatic void bnx2x_init_def_sb(struct bnx2x *bp)\n{\n\tstruct host_sp_status_block *def_sb = bp->def_status_blk;\n\tdma_addr_t mapping = bp->def_status_blk_mapping;\n\tint igu_sp_sb_index;\n\tint igu_seg_id;\n\tint port = BP_PORT(bp);\n\tint func = BP_FUNC(bp);\n\tint reg_offset, reg_offset_en5;\n\tu64 section;\n\tint index;\n\tstruct hc_sp_status_block_data sp_sb_data;\n\tmemset(&sp_sb_data, 0, sizeof(struct hc_sp_status_block_data));\n\n\tif (CHIP_INT_MODE_IS_BC(bp)) {\n\t\tigu_sp_sb_index = DEF_SB_IGU_ID;\n\t\tigu_seg_id = HC_SEG_ACCESS_DEF;\n\t} else {\n\t\tigu_sp_sb_index = bp->igu_dsb_id;\n\t\tigu_seg_id = IGU_SEG_ACCESS_DEF;\n\t}\n\n\t/* ATTN */\n\tsection = ((u64)mapping) + offsetof(struct host_sp_status_block,\n\t\t\t\t\t    atten_status_block);\n\tdef_sb->atten_status_block.status_block_id = igu_sp_sb_index;\n\n\tbp->attn_state = 0;\n\n\treg_offset = (port ? MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0 :\n\t\t\t     MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0);\n\treg_offset_en5 = (port ? MISC_REG_AEU_ENABLE5_FUNC_1_OUT_0 :\n\t\t\t\t MISC_REG_AEU_ENABLE5_FUNC_0_OUT_0);\n\tfor (index = 0; index < MAX_DYNAMIC_ATTN_GRPS; index++) {\n\t\tint sindex;\n\t\t/* take care of sig[0]..sig[4] */\n\t\tfor (sindex = 0; sindex < 4; sindex++)\n\t\t\tbp->attn_group[index].sig[sindex] =\n\t\t\t   REG_RD(bp, reg_offset + sindex*0x4 + 0x10*index);\n\n\t\tif (!CHIP_IS_E1x(bp))\n\t\t\t/*\n\t\t\t * enable5 is separate from the rest of the registers,\n\t\t\t * and therefore the address skip is 4\n\t\t\t * and not 16 between the different groups\n\t\t\t */\n\t\t\tbp->attn_group[index].sig[4] = REG_RD(bp,\n\t\t\t\t\treg_offset_en5 + 0x4*index);\n\t\telse\n\t\t\tbp->attn_group[index].sig[4] = 0;\n\t}\n\n\tif (bp->common.int_block == INT_BLOCK_HC) {\n\t\treg_offset = (port ? HC_REG_ATTN_MSG1_ADDR_L :\n\t\t\t\t     HC_REG_ATTN_MSG0_ADDR_L);\n\n\t\tREG_WR(bp, reg_offset, U64_LO(section));\n\t\tREG_WR(bp, reg_offset + 4, U64_HI(section));\n\t} else if (!CHIP_IS_E1x(bp)) {\n\t\tREG_WR(bp, IGU_REG_ATTN_MSG_ADDR_L, U64_LO(section));\n\t\tREG_WR(bp, IGU_REG_ATTN_MSG_ADDR_H, U64_HI(section));\n\t}\n\n\tsection = ((u64)mapping) + offsetof(struct host_sp_status_block,\n\t\t\t\t\t    sp_sb);\n\n\tbnx2x_zero_sp_sb(bp);\n\n\t/* PCI guarantees endianity of regpairs */\n\tsp_sb_data.state\t\t= SB_ENABLED;\n\tsp_sb_data.host_sb_addr.lo\t= U64_LO(section);\n\tsp_sb_data.host_sb_addr.hi\t= U64_HI(section);\n\tsp_sb_data.igu_sb_id\t\t= igu_sp_sb_index;\n\tsp_sb_data.igu_seg_id\t\t= igu_seg_id;\n\tsp_sb_data.p_func.pf_id\t\t= func;\n\tsp_sb_data.p_func.vnic_id\t= BP_VN(bp);\n\tsp_sb_data.p_func.vf_id\t\t= 0xff;\n\n\tbnx2x_wr_sp_sb_data(bp, &sp_sb_data);\n\n\tbnx2x_ack_sb(bp, bp->igu_dsb_id, USTORM_ID, 0, IGU_INT_ENABLE, 0);\n}\n\nvoid bnx2x_update_coalesce(struct bnx2x *bp)\n{\n\tint i;\n\n\tfor_each_eth_queue(bp, i)\n\t\tbnx2x_update_coalesce_sb(bp, bp->fp[i].fw_sb_id,\n\t\t\t\t\t bp->tx_ticks, bp->rx_ticks);\n}\n\nstatic void bnx2x_init_sp_ring(struct bnx2x *bp)\n{\n\tspin_lock_init(&bp->spq_lock);\n\tatomic_set(&bp->cq_spq_left, MAX_SPQ_PENDING);\n\n\tbp->spq_prod_idx = 0;\n\tbp->dsb_sp_prod = BNX2X_SP_DSB_INDEX;\n\tbp->spq_prod_bd = bp->spq;\n\tbp->spq_last_bd = bp->spq_prod_bd + MAX_SP_DESC_CNT;\n}\n\nstatic void bnx2x_init_eq_ring(struct bnx2x *bp)\n{\n\tint i;\n\tfor (i = 1; i <= NUM_EQ_PAGES; i++) {\n\t\tunion event_ring_elem *elem =\n\t\t\t&bp->eq_ring[EQ_DESC_CNT_PAGE * i - 1];\n\n\t\telem->next_page.addr.hi =\n\t\t\tcpu_to_le32(U64_HI(bp->eq_mapping +\n\t\t\t\t   BCM_PAGE_SIZE * (i % NUM_EQ_PAGES)));\n\t\telem->next_page.addr.lo =\n\t\t\tcpu_to_le32(U64_LO(bp->eq_mapping +\n\t\t\t\t   BCM_PAGE_SIZE*(i % NUM_EQ_PAGES)));\n\t}\n\tbp->eq_cons = 0;\n\tbp->eq_prod = NUM_EQ_DESC;\n\tbp->eq_cons_sb = BNX2X_EQ_INDEX;\n\t/* we want a warning message before it gets wrought... */\n\tatomic_set(&bp->eq_spq_left,\n\t\tmin_t(int, MAX_SP_DESC_CNT - MAX_SPQ_PENDING, NUM_EQ_DESC) - 1);\n}\n\n/* called with netif_addr_lock_bh() */\nstatic int bnx2x_set_q_rx_mode(struct bnx2x *bp, u8 cl_id,\n\t\t\t       unsigned long rx_mode_flags,\n\t\t\t       unsigned long rx_accept_flags,\n\t\t\t       unsigned long tx_accept_flags,\n\t\t\t       unsigned long ramrod_flags)\n{\n\tstruct bnx2x_rx_mode_ramrod_params ramrod_param;\n\tint rc;\n\n\tmemset(&ramrod_param, 0, sizeof(ramrod_param));\n\n\t/* Prepare ramrod parameters */\n\tramrod_param.cid = 0;\n\tramrod_param.cl_id = cl_id;\n\tramrod_param.rx_mode_obj = &bp->rx_mode_obj;\n\tramrod_param.func_id = BP_FUNC(bp);\n\n\tramrod_param.pstate = &bp->sp_state;\n\tramrod_param.state = BNX2X_FILTER_RX_MODE_PENDING;\n\n\tramrod_param.rdata = bnx2x_sp(bp, rx_mode_rdata);\n\tramrod_param.rdata_mapping = bnx2x_sp_mapping(bp, rx_mode_rdata);\n\n\tset_bit(BNX2X_FILTER_RX_MODE_PENDING, &bp->sp_state);\n\n\tramrod_param.ramrod_flags = ramrod_flags;\n\tramrod_param.rx_mode_flags = rx_mode_flags;\n\n\tramrod_param.rx_accept_flags = rx_accept_flags;\n\tramrod_param.tx_accept_flags = tx_accept_flags;\n\n\trc = bnx2x_config_rx_mode(bp, &ramrod_param);\n\tif (rc < 0) {\n\t\tBNX2X_ERR(\"Set rx_mode %d failed\\n\", bp->rx_mode);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_fill_accept_flags(struct bnx2x *bp, u32 rx_mode,\n\t\t\t\t   unsigned long *rx_accept_flags,\n\t\t\t\t   unsigned long *tx_accept_flags)\n{\n\t/* Clear the flags first */\n\t*rx_accept_flags = 0;\n\t*tx_accept_flags = 0;\n\n\tswitch (rx_mode) {\n\tcase BNX2X_RX_MODE_NONE:\n\t\t/*\n\t\t * 'drop all' supersedes any accept flags that may have been\n\t\t * passed to the function.\n\t\t */\n\t\tbreak;\n\tcase BNX2X_RX_MODE_NORMAL:\n\t\t__set_bit(BNX2X_ACCEPT_UNICAST, rx_accept_flags);\n\t\t__set_bit(BNX2X_ACCEPT_MULTICAST, rx_accept_flags);\n\t\t__set_bit(BNX2X_ACCEPT_BROADCAST, rx_accept_flags);\n\n\t\t/* internal switching mode */\n\t\t__set_bit(BNX2X_ACCEPT_UNICAST, tx_accept_flags);\n\t\t__set_bit(BNX2X_ACCEPT_MULTICAST, tx_accept_flags);\n\t\t__set_bit(BNX2X_ACCEPT_BROADCAST, tx_accept_flags);\n\n\t\tif (bp->accept_any_vlan) {\n\t\t\t__set_bit(BNX2X_ACCEPT_ANY_VLAN, rx_accept_flags);\n\t\t\t__set_bit(BNX2X_ACCEPT_ANY_VLAN, tx_accept_flags);\n\t\t}\n\n\t\tbreak;\n\tcase BNX2X_RX_MODE_ALLMULTI:\n\t\t__set_bit(BNX2X_ACCEPT_UNICAST, rx_accept_flags);\n\t\t__set_bit(BNX2X_ACCEPT_ALL_MULTICAST, rx_accept_flags);\n\t\t__set_bit(BNX2X_ACCEPT_BROADCAST, rx_accept_flags);\n\n\t\t/* internal switching mode */\n\t\t__set_bit(BNX2X_ACCEPT_UNICAST, tx_accept_flags);\n\t\t__set_bit(BNX2X_ACCEPT_ALL_MULTICAST, tx_accept_flags);\n\t\t__set_bit(BNX2X_ACCEPT_BROADCAST, tx_accept_flags);\n\n\t\tif (bp->accept_any_vlan) {\n\t\t\t__set_bit(BNX2X_ACCEPT_ANY_VLAN, rx_accept_flags);\n\t\t\t__set_bit(BNX2X_ACCEPT_ANY_VLAN, tx_accept_flags);\n\t\t}\n\n\t\tbreak;\n\tcase BNX2X_RX_MODE_PROMISC:\n\t\t/* According to definition of SI mode, iface in promisc mode\n\t\t * should receive matched and unmatched (in resolution of port)\n\t\t * unicast packets.\n\t\t */\n\t\t__set_bit(BNX2X_ACCEPT_UNMATCHED, rx_accept_flags);\n\t\t__set_bit(BNX2X_ACCEPT_UNICAST, rx_accept_flags);\n\t\t__set_bit(BNX2X_ACCEPT_ALL_MULTICAST, rx_accept_flags);\n\t\t__set_bit(BNX2X_ACCEPT_BROADCAST, rx_accept_flags);\n\n\t\t/* internal switching mode */\n\t\t__set_bit(BNX2X_ACCEPT_ALL_MULTICAST, tx_accept_flags);\n\t\t__set_bit(BNX2X_ACCEPT_BROADCAST, tx_accept_flags);\n\n\t\tif (IS_MF_SI(bp))\n\t\t\t__set_bit(BNX2X_ACCEPT_ALL_UNICAST, tx_accept_flags);\n\t\telse\n\t\t\t__set_bit(BNX2X_ACCEPT_UNICAST, tx_accept_flags);\n\n\t\t__set_bit(BNX2X_ACCEPT_ANY_VLAN, rx_accept_flags);\n\t\t__set_bit(BNX2X_ACCEPT_ANY_VLAN, tx_accept_flags);\n\n\t\tbreak;\n\tdefault:\n\t\tBNX2X_ERR(\"Unknown rx_mode: %d\\n\", rx_mode);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* called with netif_addr_lock_bh() */\nstatic int bnx2x_set_storm_rx_mode(struct bnx2x *bp)\n{\n\tunsigned long rx_mode_flags = 0, ramrod_flags = 0;\n\tunsigned long rx_accept_flags = 0, tx_accept_flags = 0;\n\tint rc;\n\n\tif (!NO_FCOE(bp))\n\t\t/* Configure rx_mode of FCoE Queue */\n\t\t__set_bit(BNX2X_RX_MODE_FCOE_ETH, &rx_mode_flags);\n\n\trc = bnx2x_fill_accept_flags(bp, bp->rx_mode, &rx_accept_flags,\n\t\t\t\t     &tx_accept_flags);\n\tif (rc)\n\t\treturn rc;\n\n\t__set_bit(RAMROD_RX, &ramrod_flags);\n\t__set_bit(RAMROD_TX, &ramrod_flags);\n\n\treturn bnx2x_set_q_rx_mode(bp, bp->fp->cl_id, rx_mode_flags,\n\t\t\t\t   rx_accept_flags, tx_accept_flags,\n\t\t\t\t   ramrod_flags);\n}\n\nstatic void bnx2x_init_internal_common(struct bnx2x *bp)\n{\n\tint i;\n\n\t/* Zero this manually as its initialization is\n\t   currently missing in the initTool */\n\tfor (i = 0; i < (USTORM_AGG_DATA_SIZE >> 2); i++)\n\t\tREG_WR(bp, BAR_USTRORM_INTMEM +\n\t\t       USTORM_AGG_DATA_OFFSET + i * 4, 0);\n\tif (!CHIP_IS_E1x(bp)) {\n\t\tREG_WR8(bp, BAR_CSTRORM_INTMEM + CSTORM_IGU_MODE_OFFSET,\n\t\t\tCHIP_INT_MODE_IS_BC(bp) ?\n\t\t\tHC_IGU_BC_MODE : HC_IGU_NBC_MODE);\n\t}\n}\n\nstatic void bnx2x_init_internal(struct bnx2x *bp, u32 load_code)\n{\n\tswitch (load_code) {\n\tcase FW_MSG_CODE_DRV_LOAD_COMMON:\n\tcase FW_MSG_CODE_DRV_LOAD_COMMON_CHIP:\n\t\tbnx2x_init_internal_common(bp);\n\t\tfallthrough;\n\n\tcase FW_MSG_CODE_DRV_LOAD_PORT:\n\t\t/* nothing to do */\n\t\tfallthrough;\n\n\tcase FW_MSG_CODE_DRV_LOAD_FUNCTION:\n\t\t/* internal memory per function is\n\t\t   initialized inside bnx2x_pf_init */\n\t\tbreak;\n\n\tdefault:\n\t\tBNX2X_ERR(\"Unknown load_code (0x%x) from MCP\\n\", load_code);\n\t\tbreak;\n\t}\n}\n\nstatic inline u8 bnx2x_fp_igu_sb_id(struct bnx2x_fastpath *fp)\n{\n\treturn fp->bp->igu_base_sb + fp->index + CNIC_SUPPORT(fp->bp);\n}\n\nstatic inline u8 bnx2x_fp_fw_sb_id(struct bnx2x_fastpath *fp)\n{\n\treturn fp->bp->base_fw_ndsb + fp->index + CNIC_SUPPORT(fp->bp);\n}\n\nstatic u8 bnx2x_fp_cl_id(struct bnx2x_fastpath *fp)\n{\n\tif (CHIP_IS_E1x(fp->bp))\n\t\treturn BP_L_ID(fp->bp) + fp->index;\n\telse\t/* We want Client ID to be the same as IGU SB ID for 57712 */\n\t\treturn bnx2x_fp_igu_sb_id(fp);\n}\n\nstatic void bnx2x_init_eth_fp(struct bnx2x *bp, int fp_idx)\n{\n\tstruct bnx2x_fastpath *fp = &bp->fp[fp_idx];\n\tu8 cos;\n\tunsigned long q_type = 0;\n\tu32 cids[BNX2X_MULTI_TX_COS] = { 0 };\n\tfp->rx_queue = fp_idx;\n\tfp->cid = fp_idx;\n\tfp->cl_id = bnx2x_fp_cl_id(fp);\n\tfp->fw_sb_id = bnx2x_fp_fw_sb_id(fp);\n\tfp->igu_sb_id = bnx2x_fp_igu_sb_id(fp);\n\t/* qZone id equals to FW (per path) client id */\n\tfp->cl_qzone_id  = bnx2x_fp_qzone_id(fp);\n\n\t/* init shortcut */\n\tfp->ustorm_rx_prods_offset = bnx2x_rx_ustorm_prods_offset(fp);\n\n\t/* Setup SB indices */\n\tfp->rx_cons_sb = BNX2X_RX_SB_INDEX;\n\n\t/* Configure Queue State object */\n\t__set_bit(BNX2X_Q_TYPE_HAS_RX, &q_type);\n\t__set_bit(BNX2X_Q_TYPE_HAS_TX, &q_type);\n\n\tBUG_ON(fp->max_cos > BNX2X_MULTI_TX_COS);\n\n\t/* init tx data */\n\tfor_each_cos_in_tx_queue(fp, cos) {\n\t\tbnx2x_init_txdata(bp, fp->txdata_ptr[cos],\n\t\t\t\t  CID_COS_TO_TX_ONLY_CID(fp->cid, cos, bp),\n\t\t\t\t  FP_COS_TO_TXQ(fp, cos, bp),\n\t\t\t\t  BNX2X_TX_SB_INDEX_BASE + cos, fp);\n\t\tcids[cos] = fp->txdata_ptr[cos]->cid;\n\t}\n\n\t/* nothing more for vf to do here */\n\tif (IS_VF(bp))\n\t\treturn;\n\n\tbnx2x_init_sb(bp, fp->status_blk_mapping, BNX2X_VF_ID_INVALID, false,\n\t\t      fp->fw_sb_id, fp->igu_sb_id);\n\tbnx2x_update_fpsb_idx(fp);\n\tbnx2x_init_queue_obj(bp, &bnx2x_sp_obj(bp, fp).q_obj, fp->cl_id, cids,\n\t\t\t     fp->max_cos, BP_FUNC(bp), bnx2x_sp(bp, q_rdata),\n\t\t\t     bnx2x_sp_mapping(bp, q_rdata), q_type);\n\n\t/**\n\t * Configure classification DBs: Always enable Tx switching\n\t */\n\tbnx2x_init_vlan_mac_fp_objs(fp, BNX2X_OBJ_TYPE_RX_TX);\n\n\tDP(NETIF_MSG_IFUP,\n\t   \"queue[%d]:  bnx2x_init_sb(%p,%p)  cl_id %d  fw_sb %d  igu_sb %d\\n\",\n\t   fp_idx, bp, fp->status_blk.e2_sb, fp->cl_id, fp->fw_sb_id,\n\t   fp->igu_sb_id);\n}\n\nstatic void bnx2x_init_tx_ring_one(struct bnx2x_fp_txdata *txdata)\n{\n\tint i;\n\n\tfor (i = 1; i <= NUM_TX_RINGS; i++) {\n\t\tstruct eth_tx_next_bd *tx_next_bd =\n\t\t\t&txdata->tx_desc_ring[TX_DESC_CNT * i - 1].next_bd;\n\n\t\ttx_next_bd->addr_hi =\n\t\t\tcpu_to_le32(U64_HI(txdata->tx_desc_mapping +\n\t\t\t\t    BCM_PAGE_SIZE*(i % NUM_TX_RINGS)));\n\t\ttx_next_bd->addr_lo =\n\t\t\tcpu_to_le32(U64_LO(txdata->tx_desc_mapping +\n\t\t\t\t    BCM_PAGE_SIZE*(i % NUM_TX_RINGS)));\n\t}\n\n\t*txdata->tx_cons_sb = cpu_to_le16(0);\n\n\tSET_FLAG(txdata->tx_db.data.header.header, DOORBELL_HDR_DB_TYPE, 1);\n\ttxdata->tx_db.data.zero_fill1 = 0;\n\ttxdata->tx_db.data.prod = 0;\n\n\ttxdata->tx_pkt_prod = 0;\n\ttxdata->tx_pkt_cons = 0;\n\ttxdata->tx_bd_prod = 0;\n\ttxdata->tx_bd_cons = 0;\n\ttxdata->tx_pkt = 0;\n}\n\nstatic void bnx2x_init_tx_rings_cnic(struct bnx2x *bp)\n{\n\tint i;\n\n\tfor_each_tx_queue_cnic(bp, i)\n\t\tbnx2x_init_tx_ring_one(bp->fp[i].txdata_ptr[0]);\n}\n\nstatic void bnx2x_init_tx_rings(struct bnx2x *bp)\n{\n\tint i;\n\tu8 cos;\n\n\tfor_each_eth_queue(bp, i)\n\t\tfor_each_cos_in_tx_queue(&bp->fp[i], cos)\n\t\t\tbnx2x_init_tx_ring_one(bp->fp[i].txdata_ptr[cos]);\n}\n\nstatic void bnx2x_init_fcoe_fp(struct bnx2x *bp)\n{\n\tstruct bnx2x_fastpath *fp = bnx2x_fcoe_fp(bp);\n\tunsigned long q_type = 0;\n\n\tbnx2x_fcoe(bp, rx_queue) = BNX2X_NUM_ETH_QUEUES(bp);\n\tbnx2x_fcoe(bp, cl_id) = bnx2x_cnic_eth_cl_id(bp,\n\t\t\t\t\t\t     BNX2X_FCOE_ETH_CL_ID_IDX);\n\tbnx2x_fcoe(bp, cid) = BNX2X_FCOE_ETH_CID(bp);\n\tbnx2x_fcoe(bp, fw_sb_id) = DEF_SB_ID;\n\tbnx2x_fcoe(bp, igu_sb_id) = bp->igu_dsb_id;\n\tbnx2x_fcoe(bp, rx_cons_sb) = BNX2X_FCOE_L2_RX_INDEX;\n\tbnx2x_init_txdata(bp, bnx2x_fcoe(bp, txdata_ptr[0]),\n\t\t\t  fp->cid, FCOE_TXQ_IDX(bp), BNX2X_FCOE_L2_TX_INDEX,\n\t\t\t  fp);\n\n\tDP(NETIF_MSG_IFUP, \"created fcoe tx data (fp index %d)\\n\", fp->index);\n\n\t/* qZone id equals to FW (per path) client id */\n\tbnx2x_fcoe(bp, cl_qzone_id) = bnx2x_fp_qzone_id(fp);\n\t/* init shortcut */\n\tbnx2x_fcoe(bp, ustorm_rx_prods_offset) =\n\t\tbnx2x_rx_ustorm_prods_offset(fp);\n\n\t/* Configure Queue State object */\n\t__set_bit(BNX2X_Q_TYPE_HAS_RX, &q_type);\n\t__set_bit(BNX2X_Q_TYPE_HAS_TX, &q_type);\n\n\t/* No multi-CoS for FCoE L2 client */\n\tBUG_ON(fp->max_cos != 1);\n\n\tbnx2x_init_queue_obj(bp, &bnx2x_sp_obj(bp, fp).q_obj, fp->cl_id,\n\t\t\t     &fp->cid, 1, BP_FUNC(bp), bnx2x_sp(bp, q_rdata),\n\t\t\t     bnx2x_sp_mapping(bp, q_rdata), q_type);\n\n\tDP(NETIF_MSG_IFUP,\n\t   \"queue[%d]: bnx2x_init_sb(%p,%p) cl_id %d fw_sb %d igu_sb %d\\n\",\n\t   fp->index, bp, fp->status_blk.e2_sb, fp->cl_id, fp->fw_sb_id,\n\t   fp->igu_sb_id);\n}\n\nvoid bnx2x_nic_init_cnic(struct bnx2x *bp)\n{\n\tif (!NO_FCOE(bp))\n\t\tbnx2x_init_fcoe_fp(bp);\n\n\tbnx2x_init_sb(bp, bp->cnic_sb_mapping,\n\t\t      BNX2X_VF_ID_INVALID, false,\n\t\t      bnx2x_cnic_fw_sb_id(bp), bnx2x_cnic_igu_sb_id(bp));\n\n\t/* ensure status block indices were read */\n\trmb();\n\tbnx2x_init_rx_rings_cnic(bp);\n\tbnx2x_init_tx_rings_cnic(bp);\n\n\t/* flush all */\n\tmb();\n}\n\nvoid bnx2x_pre_irq_nic_init(struct bnx2x *bp)\n{\n\tint i;\n\n\t/* Setup NIC internals and enable interrupts */\n\tfor_each_eth_queue(bp, i)\n\t\tbnx2x_init_eth_fp(bp, i);\n\n\t/* ensure status block indices were read */\n\trmb();\n\tbnx2x_init_rx_rings(bp);\n\tbnx2x_init_tx_rings(bp);\n\n\tif (IS_PF(bp)) {\n\t\t/* Initialize MOD_ABS interrupts */\n\t\tbnx2x_init_mod_abs_int(bp, &bp->link_vars, bp->common.chip_id,\n\t\t\t\t       bp->common.shmem_base,\n\t\t\t\t       bp->common.shmem2_base, BP_PORT(bp));\n\n\t\t/* initialize the default status block and sp ring */\n\t\tbnx2x_init_def_sb(bp);\n\t\tbnx2x_update_dsb_idx(bp);\n\t\tbnx2x_init_sp_ring(bp);\n\t} else {\n\t\tbnx2x_memset_stats(bp);\n\t}\n}\n\nvoid bnx2x_post_irq_nic_init(struct bnx2x *bp, u32 load_code)\n{\n\tbnx2x_init_eq_ring(bp);\n\tbnx2x_init_internal(bp, load_code);\n\tbnx2x_pf_init(bp);\n\tbnx2x_stats_init(bp);\n\n\t/* flush all before enabling interrupts */\n\tmb();\n\n\tbnx2x_int_enable(bp);\n\n\t/* Check for SPIO5 */\n\tbnx2x_attn_int_deasserted0(bp,\n\t\tREG_RD(bp, MISC_REG_AEU_AFTER_INVERT_1_FUNC_0 + BP_PORT(bp)*4) &\n\t\t\t\t   AEU_INPUTS_ATTN_BITS_SPIO5);\n}\n\n/* gzip service functions */\nstatic int bnx2x_gunzip_init(struct bnx2x *bp)\n{\n\tbp->gunzip_buf = dma_alloc_coherent(&bp->pdev->dev, FW_BUF_SIZE,\n\t\t\t\t\t    &bp->gunzip_mapping, GFP_KERNEL);\n\tif (bp->gunzip_buf  == NULL)\n\t\tgoto gunzip_nomem1;\n\n\tbp->strm = kmalloc(sizeof(*bp->strm), GFP_KERNEL);\n\tif (bp->strm  == NULL)\n\t\tgoto gunzip_nomem2;\n\n\tbp->strm->workspace = vmalloc(zlib_inflate_workspacesize());\n\tif (bp->strm->workspace == NULL)\n\t\tgoto gunzip_nomem3;\n\n\treturn 0;\n\ngunzip_nomem3:\n\tkfree(bp->strm);\n\tbp->strm = NULL;\n\ngunzip_nomem2:\n\tdma_free_coherent(&bp->pdev->dev, FW_BUF_SIZE, bp->gunzip_buf,\n\t\t\t  bp->gunzip_mapping);\n\tbp->gunzip_buf = NULL;\n\ngunzip_nomem1:\n\tBNX2X_ERR(\"Cannot allocate firmware buffer for un-compression\\n\");\n\treturn -ENOMEM;\n}\n\nstatic void bnx2x_gunzip_end(struct bnx2x *bp)\n{\n\tif (bp->strm) {\n\t\tvfree(bp->strm->workspace);\n\t\tkfree(bp->strm);\n\t\tbp->strm = NULL;\n\t}\n\n\tif (bp->gunzip_buf) {\n\t\tdma_free_coherent(&bp->pdev->dev, FW_BUF_SIZE, bp->gunzip_buf,\n\t\t\t\t  bp->gunzip_mapping);\n\t\tbp->gunzip_buf = NULL;\n\t}\n}\n\nstatic int bnx2x_gunzip(struct bnx2x *bp, const u8 *zbuf, int len)\n{\n\tint n, rc;\n\n\t/* check gzip header */\n\tif ((zbuf[0] != 0x1f) || (zbuf[1] != 0x8b) || (zbuf[2] != Z_DEFLATED)) {\n\t\tBNX2X_ERR(\"Bad gzip header\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tn = 10;\n\n#define FNAME\t\t\t\t0x8\n\n\tif (zbuf[3] & FNAME)\n\t\twhile ((zbuf[n++] != 0) && (n < len));\n\n\tbp->strm->next_in = (typeof(bp->strm->next_in))zbuf + n;\n\tbp->strm->avail_in = len - n;\n\tbp->strm->next_out = bp->gunzip_buf;\n\tbp->strm->avail_out = FW_BUF_SIZE;\n\n\trc = zlib_inflateInit2(bp->strm, -MAX_WBITS);\n\tif (rc != Z_OK)\n\t\treturn rc;\n\n\trc = zlib_inflate(bp->strm, Z_FINISH);\n\tif ((rc != Z_OK) && (rc != Z_STREAM_END))\n\t\tnetdev_err(bp->dev, \"Firmware decompression error: %s\\n\",\n\t\t\t   bp->strm->msg);\n\n\tbp->gunzip_outlen = (FW_BUF_SIZE - bp->strm->avail_out);\n\tif (bp->gunzip_outlen & 0x3)\n\t\tnetdev_err(bp->dev,\n\t\t\t   \"Firmware decompression error: gunzip_outlen (%d) not aligned\\n\",\n\t\t\t\tbp->gunzip_outlen);\n\tbp->gunzip_outlen >>= 2;\n\n\tzlib_inflateEnd(bp->strm);\n\n\tif (rc == Z_STREAM_END)\n\t\treturn 0;\n\n\treturn rc;\n}\n\n/* nic load/unload */\n\n/*\n * General service functions\n */\n\n/* send a NIG loopback debug packet */\nstatic void bnx2x_lb_pckt(struct bnx2x *bp)\n{\n\tu32 wb_write[3];\n\n\t/* Ethernet source and destination addresses */\n\twb_write[0] = 0x55555555;\n\twb_write[1] = 0x55555555;\n\twb_write[2] = 0x20;\t\t/* SOP */\n\tREG_WR_DMAE(bp, NIG_REG_DEBUG_PACKET_LB, wb_write, 3);\n\n\t/* NON-IP protocol */\n\twb_write[0] = 0x09000000;\n\twb_write[1] = 0x55555555;\n\twb_write[2] = 0x10;\t\t/* EOP, eop_bvalid = 0 */\n\tREG_WR_DMAE(bp, NIG_REG_DEBUG_PACKET_LB, wb_write, 3);\n}\n\n/* some of the internal memories\n * are not directly readable from the driver\n * to test them we send debug packets\n */\nstatic int bnx2x_int_mem_test(struct bnx2x *bp)\n{\n\tint factor;\n\tint count, i;\n\tu32 val = 0;\n\n\tif (CHIP_REV_IS_FPGA(bp))\n\t\tfactor = 120;\n\telse if (CHIP_REV_IS_EMUL(bp))\n\t\tfactor = 200;\n\telse\n\t\tfactor = 1;\n\n\t/* Disable inputs of parser neighbor blocks */\n\tREG_WR(bp, TSDM_REG_ENABLE_IN1, 0x0);\n\tREG_WR(bp, TCM_REG_PRS_IFEN, 0x0);\n\tREG_WR(bp, CFC_REG_DEBUG0, 0x1);\n\tREG_WR(bp, NIG_REG_PRS_REQ_IN_EN, 0x0);\n\n\t/*  Write 0 to parser credits for CFC search request */\n\tREG_WR(bp, PRS_REG_CFC_SEARCH_INITIAL_CREDIT, 0x0);\n\n\t/* send Ethernet packet */\n\tbnx2x_lb_pckt(bp);\n\n\t/* TODO do i reset NIG statistic? */\n\t/* Wait until NIG register shows 1 packet of size 0x10 */\n\tcount = 1000 * factor;\n\twhile (count) {\n\n\t\tbnx2x_read_dmae(bp, NIG_REG_STAT2_BRB_OCTET, 2);\n\t\tval = *bnx2x_sp(bp, wb_data[0]);\n\t\tif (val == 0x10)\n\t\t\tbreak;\n\n\t\tusleep_range(10000, 20000);\n\t\tcount--;\n\t}\n\tif (val != 0x10) {\n\t\tBNX2X_ERR(\"NIG timeout  val = 0x%x\\n\", val);\n\t\treturn -1;\n\t}\n\n\t/* Wait until PRS register shows 1 packet */\n\tcount = 1000 * factor;\n\twhile (count) {\n\t\tval = REG_RD(bp, PRS_REG_NUM_OF_PACKETS);\n\t\tif (val == 1)\n\t\t\tbreak;\n\n\t\tusleep_range(10000, 20000);\n\t\tcount--;\n\t}\n\tif (val != 0x1) {\n\t\tBNX2X_ERR(\"PRS timeout val = 0x%x\\n\", val);\n\t\treturn -2;\n\t}\n\n\t/* Reset and init BRB, PRS */\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_CLEAR, 0x03);\n\tmsleep(50);\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_SET, 0x03);\n\tmsleep(50);\n\tbnx2x_init_block(bp, BLOCK_BRB1, PHASE_COMMON);\n\tbnx2x_init_block(bp, BLOCK_PRS, PHASE_COMMON);\n\n\tDP(NETIF_MSG_HW, \"part2\\n\");\n\n\t/* Disable inputs of parser neighbor blocks */\n\tREG_WR(bp, TSDM_REG_ENABLE_IN1, 0x0);\n\tREG_WR(bp, TCM_REG_PRS_IFEN, 0x0);\n\tREG_WR(bp, CFC_REG_DEBUG0, 0x1);\n\tREG_WR(bp, NIG_REG_PRS_REQ_IN_EN, 0x0);\n\n\t/* Write 0 to parser credits for CFC search request */\n\tREG_WR(bp, PRS_REG_CFC_SEARCH_INITIAL_CREDIT, 0x0);\n\n\t/* send 10 Ethernet packets */\n\tfor (i = 0; i < 10; i++)\n\t\tbnx2x_lb_pckt(bp);\n\n\t/* Wait until NIG register shows 10 + 1\n\t   packets of size 11*0x10 = 0xb0 */\n\tcount = 1000 * factor;\n\twhile (count) {\n\n\t\tbnx2x_read_dmae(bp, NIG_REG_STAT2_BRB_OCTET, 2);\n\t\tval = *bnx2x_sp(bp, wb_data[0]);\n\t\tif (val == 0xb0)\n\t\t\tbreak;\n\n\t\tusleep_range(10000, 20000);\n\t\tcount--;\n\t}\n\tif (val != 0xb0) {\n\t\tBNX2X_ERR(\"NIG timeout  val = 0x%x\\n\", val);\n\t\treturn -3;\n\t}\n\n\t/* Wait until PRS register shows 2 packets */\n\tval = REG_RD(bp, PRS_REG_NUM_OF_PACKETS);\n\tif (val != 2)\n\t\tBNX2X_ERR(\"PRS timeout  val = 0x%x\\n\", val);\n\n\t/* Write 1 to parser credits for CFC search request */\n\tREG_WR(bp, PRS_REG_CFC_SEARCH_INITIAL_CREDIT, 0x1);\n\n\t/* Wait until PRS register shows 3 packets */\n\tmsleep(10 * factor);\n\t/* Wait until NIG register shows 1 packet of size 0x10 */\n\tval = REG_RD(bp, PRS_REG_NUM_OF_PACKETS);\n\tif (val != 3)\n\t\tBNX2X_ERR(\"PRS timeout  val = 0x%x\\n\", val);\n\n\t/* clear NIG EOP FIFO */\n\tfor (i = 0; i < 11; i++)\n\t\tREG_RD(bp, NIG_REG_INGRESS_EOP_LB_FIFO);\n\tval = REG_RD(bp, NIG_REG_INGRESS_EOP_LB_EMPTY);\n\tif (val != 1) {\n\t\tBNX2X_ERR(\"clear of NIG failed\\n\");\n\t\treturn -4;\n\t}\n\n\t/* Reset and init BRB, PRS, NIG */\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_CLEAR, 0x03);\n\tmsleep(50);\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_SET, 0x03);\n\tmsleep(50);\n\tbnx2x_init_block(bp, BLOCK_BRB1, PHASE_COMMON);\n\tbnx2x_init_block(bp, BLOCK_PRS, PHASE_COMMON);\n\tif (!CNIC_SUPPORT(bp))\n\t\t/* set NIC mode */\n\t\tREG_WR(bp, PRS_REG_NIC_MODE, 1);\n\n\t/* Enable inputs of parser neighbor blocks */\n\tREG_WR(bp, TSDM_REG_ENABLE_IN1, 0x7fffffff);\n\tREG_WR(bp, TCM_REG_PRS_IFEN, 0x1);\n\tREG_WR(bp, CFC_REG_DEBUG0, 0x0);\n\tREG_WR(bp, NIG_REG_PRS_REQ_IN_EN, 0x1);\n\n\tDP(NETIF_MSG_HW, \"done\\n\");\n\n\treturn 0; /* OK */\n}\n\nstatic void bnx2x_enable_blocks_attention(struct bnx2x *bp)\n{\n\tu32 val;\n\n\tREG_WR(bp, PXP_REG_PXP_INT_MASK_0, 0);\n\tif (!CHIP_IS_E1x(bp))\n\t\tREG_WR(bp, PXP_REG_PXP_INT_MASK_1, 0x40);\n\telse\n\t\tREG_WR(bp, PXP_REG_PXP_INT_MASK_1, 0);\n\tREG_WR(bp, DORQ_REG_DORQ_INT_MASK, 0);\n\tREG_WR(bp, CFC_REG_CFC_INT_MASK, 0);\n\t/*\n\t * mask read length error interrupts in brb for parser\n\t * (parsing unit and 'checksum and crc' unit)\n\t * these errors are legal (PU reads fixed length and CAC can cause\n\t * read length error on truncated packets)\n\t */\n\tREG_WR(bp, BRB1_REG_BRB1_INT_MASK, 0xFC00);\n\tREG_WR(bp, QM_REG_QM_INT_MASK, 0);\n\tREG_WR(bp, TM_REG_TM_INT_MASK, 0);\n\tREG_WR(bp, XSDM_REG_XSDM_INT_MASK_0, 0);\n\tREG_WR(bp, XSDM_REG_XSDM_INT_MASK_1, 0);\n\tREG_WR(bp, XCM_REG_XCM_INT_MASK, 0);\n/*\tREG_WR(bp, XSEM_REG_XSEM_INT_MASK_0, 0); */\n/*\tREG_WR(bp, XSEM_REG_XSEM_INT_MASK_1, 0); */\n\tREG_WR(bp, USDM_REG_USDM_INT_MASK_0, 0);\n\tREG_WR(bp, USDM_REG_USDM_INT_MASK_1, 0);\n\tREG_WR(bp, UCM_REG_UCM_INT_MASK, 0);\n/*\tREG_WR(bp, USEM_REG_USEM_INT_MASK_0, 0); */\n/*\tREG_WR(bp, USEM_REG_USEM_INT_MASK_1, 0); */\n\tREG_WR(bp, GRCBASE_UPB + PB_REG_PB_INT_MASK, 0);\n\tREG_WR(bp, CSDM_REG_CSDM_INT_MASK_0, 0);\n\tREG_WR(bp, CSDM_REG_CSDM_INT_MASK_1, 0);\n\tREG_WR(bp, CCM_REG_CCM_INT_MASK, 0);\n/*\tREG_WR(bp, CSEM_REG_CSEM_INT_MASK_0, 0); */\n/*\tREG_WR(bp, CSEM_REG_CSEM_INT_MASK_1, 0); */\n\n\tval = PXP2_PXP2_INT_MASK_0_REG_PGL_CPL_AFT  |\n\t\tPXP2_PXP2_INT_MASK_0_REG_PGL_CPL_OF |\n\t\tPXP2_PXP2_INT_MASK_0_REG_PGL_PCIE_ATTN;\n\tif (!CHIP_IS_E1x(bp))\n\t\tval |= PXP2_PXP2_INT_MASK_0_REG_PGL_READ_BLOCKED |\n\t\t\tPXP2_PXP2_INT_MASK_0_REG_PGL_WRITE_BLOCKED;\n\tREG_WR(bp, PXP2_REG_PXP2_INT_MASK_0, val);\n\n\tREG_WR(bp, TSDM_REG_TSDM_INT_MASK_0, 0);\n\tREG_WR(bp, TSDM_REG_TSDM_INT_MASK_1, 0);\n\tREG_WR(bp, TCM_REG_TCM_INT_MASK, 0);\n/*\tREG_WR(bp, TSEM_REG_TSEM_INT_MASK_0, 0); */\n\n\tif (!CHIP_IS_E1x(bp))\n\t\t/* enable VFC attentions: bits 11 and 12, bits 31:13 reserved */\n\t\tREG_WR(bp, TSEM_REG_TSEM_INT_MASK_1, 0x07ff);\n\n\tREG_WR(bp, CDU_REG_CDU_INT_MASK, 0);\n\tREG_WR(bp, DMAE_REG_DMAE_INT_MASK, 0);\n/*\tREG_WR(bp, MISC_REG_MISC_INT_MASK, 0); */\n\tREG_WR(bp, PBF_REG_PBF_INT_MASK, 0x18);\t\t/* bit 3,4 masked */\n}\n\nstatic void bnx2x_reset_common(struct bnx2x *bp)\n{\n\tu32 val = 0x1400;\n\n\t/* reset_common */\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_CLEAR,\n\t       0xd3ffff7f);\n\n\tif (CHIP_IS_E3(bp)) {\n\t\tval |= MISC_REGISTERS_RESET_REG_2_MSTAT0;\n\t\tval |= MISC_REGISTERS_RESET_REG_2_MSTAT1;\n\t}\n\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR, val);\n}\n\nstatic void bnx2x_setup_dmae(struct bnx2x *bp)\n{\n\tbp->dmae_ready = 0;\n\tspin_lock_init(&bp->dmae_lock);\n}\n\nstatic void bnx2x_init_pxp(struct bnx2x *bp)\n{\n\tu16 devctl;\n\tint r_order, w_order;\n\n\tpcie_capability_read_word(bp->pdev, PCI_EXP_DEVCTL, &devctl);\n\tDP(NETIF_MSG_HW, \"read 0x%x from devctl\\n\", devctl);\n\tw_order = ((devctl & PCI_EXP_DEVCTL_PAYLOAD) >> 5);\n\tif (bp->mrrs == -1)\n\t\tr_order = ((devctl & PCI_EXP_DEVCTL_READRQ) >> 12);\n\telse {\n\t\tDP(NETIF_MSG_HW, \"force read order to %d\\n\", bp->mrrs);\n\t\tr_order = bp->mrrs;\n\t}\n\n\tbnx2x_init_pxp_arb(bp, r_order, w_order);\n}\n\nstatic void bnx2x_setup_fan_failure_detection(struct bnx2x *bp)\n{\n\tint is_required;\n\tu32 val;\n\tint port;\n\n\tif (BP_NOMCP(bp))\n\t\treturn;\n\n\tis_required = 0;\n\tval = SHMEM_RD(bp, dev_info.shared_hw_config.config2) &\n\t      SHARED_HW_CFG_FAN_FAILURE_MASK;\n\n\tif (val == SHARED_HW_CFG_FAN_FAILURE_ENABLED)\n\t\tis_required = 1;\n\n\t/*\n\t * The fan failure mechanism is usually related to the PHY type since\n\t * the power consumption of the board is affected by the PHY. Currently,\n\t * fan is required for most designs with SFX7101, BCM8727 and BCM8481.\n\t */\n\telse if (val == SHARED_HW_CFG_FAN_FAILURE_PHY_TYPE)\n\t\tfor (port = PORT_0; port < PORT_MAX; port++) {\n\t\t\tis_required |=\n\t\t\t\tbnx2x_fan_failure_det_req(\n\t\t\t\t\tbp,\n\t\t\t\t\tbp->common.shmem_base,\n\t\t\t\t\tbp->common.shmem2_base,\n\t\t\t\t\tport);\n\t\t}\n\n\tDP(NETIF_MSG_HW, \"fan detection setting: %d\\n\", is_required);\n\n\tif (is_required == 0)\n\t\treturn;\n\n\t/* Fan failure is indicated by SPIO 5 */\n\tbnx2x_set_spio(bp, MISC_SPIO_SPIO5, MISC_SPIO_INPUT_HI_Z);\n\n\t/* set to active low mode */\n\tval = REG_RD(bp, MISC_REG_SPIO_INT);\n\tval |= (MISC_SPIO_SPIO5 << MISC_SPIO_INT_OLD_SET_POS);\n\tREG_WR(bp, MISC_REG_SPIO_INT, val);\n\n\t/* enable interrupt to signal the IGU */\n\tval = REG_RD(bp, MISC_REG_SPIO_EVENT_EN);\n\tval |= MISC_SPIO_SPIO5;\n\tREG_WR(bp, MISC_REG_SPIO_EVENT_EN, val);\n}\n\nvoid bnx2x_pf_disable(struct bnx2x *bp)\n{\n\tu32 val = REG_RD(bp, IGU_REG_PF_CONFIGURATION);\n\tval &= ~IGU_PF_CONF_FUNC_EN;\n\n\tREG_WR(bp, IGU_REG_PF_CONFIGURATION, val);\n\tREG_WR(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER, 0);\n\tREG_WR(bp, CFC_REG_WEAK_ENABLE_PF, 0);\n}\n\nstatic void bnx2x__common_init_phy(struct bnx2x *bp)\n{\n\tu32 shmem_base[2], shmem2_base[2];\n\t/* Avoid common init in case MFW supports LFA */\n\tif (SHMEM2_RD(bp, size) >\n\t    (u32)offsetof(struct shmem2_region, lfa_host_addr[BP_PORT(bp)]))\n\t\treturn;\n\tshmem_base[0] =  bp->common.shmem_base;\n\tshmem2_base[0] = bp->common.shmem2_base;\n\tif (!CHIP_IS_E1x(bp)) {\n\t\tshmem_base[1] =\n\t\t\tSHMEM2_RD(bp, other_shmem_base_addr);\n\t\tshmem2_base[1] =\n\t\t\tSHMEM2_RD(bp, other_shmem2_base_addr);\n\t}\n\tbnx2x_acquire_phy_lock(bp);\n\tbnx2x_common_init_phy(bp, shmem_base, shmem2_base,\n\t\t\t      bp->common.chip_id);\n\tbnx2x_release_phy_lock(bp);\n}\n\nstatic void bnx2x_config_endianity(struct bnx2x *bp, u32 val)\n{\n\tREG_WR(bp, PXP2_REG_RQ_QM_ENDIAN_M, val);\n\tREG_WR(bp, PXP2_REG_RQ_TM_ENDIAN_M, val);\n\tREG_WR(bp, PXP2_REG_RQ_SRC_ENDIAN_M, val);\n\tREG_WR(bp, PXP2_REG_RQ_CDU_ENDIAN_M, val);\n\tREG_WR(bp, PXP2_REG_RQ_DBG_ENDIAN_M, val);\n\n\t/* make sure this value is 0 */\n\tREG_WR(bp, PXP2_REG_RQ_HC_ENDIAN_M, 0);\n\n\tREG_WR(bp, PXP2_REG_RD_QM_SWAP_MODE, val);\n\tREG_WR(bp, PXP2_REG_RD_TM_SWAP_MODE, val);\n\tREG_WR(bp, PXP2_REG_RD_SRC_SWAP_MODE, val);\n\tREG_WR(bp, PXP2_REG_RD_CDURD_SWAP_MODE, val);\n}\n\nstatic void bnx2x_set_endianity(struct bnx2x *bp)\n{\n#ifdef __BIG_ENDIAN\n\tbnx2x_config_endianity(bp, 1);\n#else\n\tbnx2x_config_endianity(bp, 0);\n#endif\n}\n\nstatic void bnx2x_reset_endianity(struct bnx2x *bp)\n{\n\tbnx2x_config_endianity(bp, 0);\n}\n\n/**\n * bnx2x_init_hw_common - initialize the HW at the COMMON phase.\n *\n * @bp:\t\tdriver handle\n */\nstatic int bnx2x_init_hw_common(struct bnx2x *bp)\n{\n\tu32 val;\n\n\tDP(NETIF_MSG_HW, \"starting common init  func %d\\n\", BP_ABS_FUNC(bp));\n\n\t/*\n\t * take the RESET lock to protect undi_unload flow from accessing\n\t * registers while we're resetting the chip\n\t */\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RESET);\n\n\tbnx2x_reset_common(bp);\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_SET, 0xffffffff);\n\n\tval = 0xfffc;\n\tif (CHIP_IS_E3(bp)) {\n\t\tval |= MISC_REGISTERS_RESET_REG_2_MSTAT0;\n\t\tval |= MISC_REGISTERS_RESET_REG_2_MSTAT1;\n\t}\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET, val);\n\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RESET);\n\n\tbnx2x_init_block(bp, BLOCK_MISC, PHASE_COMMON);\n\n\tif (!CHIP_IS_E1x(bp)) {\n\t\tu8 abs_func_id;\n\n\t\t/**\n\t\t * 4-port mode or 2-port mode we need to turn of master-enable\n\t\t * for everyone, after that, turn it back on for self.\n\t\t * so, we disregard multi-function or not, and always disable\n\t\t * for all functions on the given path, this means 0,2,4,6 for\n\t\t * path 0 and 1,3,5,7 for path 1\n\t\t */\n\t\tfor (abs_func_id = BP_PATH(bp);\n\t\t     abs_func_id < E2_FUNC_MAX*2; abs_func_id += 2) {\n\t\t\tif (abs_func_id == BP_ABS_FUNC(bp)) {\n\t\t\t\tREG_WR(bp,\n\t\t\t\t    PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER,\n\t\t\t\t    1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbnx2x_pretend_func(bp, abs_func_id);\n\t\t\t/* clear pf enable */\n\t\t\tbnx2x_pf_disable(bp);\n\t\t\tbnx2x_pretend_func(bp, BP_ABS_FUNC(bp));\n\t\t}\n\t}\n\n\tbnx2x_init_block(bp, BLOCK_PXP, PHASE_COMMON);\n\tif (CHIP_IS_E1(bp)) {\n\t\t/* enable HW interrupt from PXP on USDM overflow\n\t\t   bit 16 on INT_MASK_0 */\n\t\tREG_WR(bp, PXP_REG_PXP_INT_MASK_0, 0);\n\t}\n\n\tbnx2x_init_block(bp, BLOCK_PXP2, PHASE_COMMON);\n\tbnx2x_init_pxp(bp);\n\tbnx2x_set_endianity(bp);\n\tbnx2x_ilt_init_page_size(bp, INITOP_SET);\n\n\tif (CHIP_REV_IS_FPGA(bp) && CHIP_IS_E1H(bp))\n\t\tREG_WR(bp, PXP2_REG_PGL_TAGS_LIMIT, 0x1);\n\n\t/* let the HW do it's magic ... */\n\tmsleep(100);\n\t/* finish PXP init */\n\tval = REG_RD(bp, PXP2_REG_RQ_CFG_DONE);\n\tif (val != 1) {\n\t\tBNX2X_ERR(\"PXP2 CFG failed\\n\");\n\t\treturn -EBUSY;\n\t}\n\tval = REG_RD(bp, PXP2_REG_RD_INIT_DONE);\n\tif (val != 1) {\n\t\tBNX2X_ERR(\"PXP2 RD_INIT failed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t/* Timers bug workaround E2 only. We need to set the entire ILT to\n\t * have entries with value \"0\" and valid bit on.\n\t * This needs to be done by the first PF that is loaded in a path\n\t * (i.e. common phase)\n\t */\n\tif (!CHIP_IS_E1x(bp)) {\n/* In E2 there is a bug in the timers block that can cause function 6 / 7\n * (i.e. vnic3) to start even if it is marked as \"scan-off\".\n * This occurs when a different function (func2,3) is being marked\n * as \"scan-off\". Real-life scenario for example: if a driver is being\n * load-unloaded while func6,7 are down. This will cause the timer to access\n * the ilt, translate to a logical address and send a request to read/write.\n * Since the ilt for the function that is down is not valid, this will cause\n * a translation error which is unrecoverable.\n * The Workaround is intended to make sure that when this happens nothing fatal\n * will occur. The workaround:\n *\t1.  First PF driver which loads on a path will:\n *\t\ta.  After taking the chip out of reset, by using pretend,\n *\t\t    it will write \"0\" to the following registers of\n *\t\t    the other vnics.\n *\t\t    REG_WR(pdev, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER, 0);\n *\t\t    REG_WR(pdev, CFC_REG_WEAK_ENABLE_PF,0);\n *\t\t    REG_WR(pdev, CFC_REG_STRONG_ENABLE_PF,0);\n *\t\t    And for itself it will write '1' to\n *\t\t    PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER to enable\n *\t\t    dmae-operations (writing to pram for example.)\n *\t\t    note: can be done for only function 6,7 but cleaner this\n *\t\t\t  way.\n *\t\tb.  Write zero+valid to the entire ILT.\n *\t\tc.  Init the first_timers_ilt_entry, last_timers_ilt_entry of\n *\t\t    VNIC3 (of that port). The range allocated will be the\n *\t\t    entire ILT. This is needed to prevent  ILT range error.\n *\t2.  Any PF driver load flow:\n *\t\ta.  ILT update with the physical addresses of the allocated\n *\t\t    logical pages.\n *\t\tb.  Wait 20msec. - note that this timeout is needed to make\n *\t\t    sure there are no requests in one of the PXP internal\n *\t\t    queues with \"old\" ILT addresses.\n *\t\tc.  PF enable in the PGLC.\n *\t\td.  Clear the was_error of the PF in the PGLC. (could have\n *\t\t    occurred while driver was down)\n *\t\te.  PF enable in the CFC (WEAK + STRONG)\n *\t\tf.  Timers scan enable\n *\t3.  PF driver unload flow:\n *\t\ta.  Clear the Timers scan_en.\n *\t\tb.  Polling for scan_on=0 for that PF.\n *\t\tc.  Clear the PF enable bit in the PXP.\n *\t\td.  Clear the PF enable in the CFC (WEAK + STRONG)\n *\t\te.  Write zero+valid to all ILT entries (The valid bit must\n *\t\t    stay set)\n *\t\tf.  If this is VNIC 3 of a port then also init\n *\t\t    first_timers_ilt_entry to zero and last_timers_ilt_entry\n *\t\t    to the last entry in the ILT.\n *\n *\tNotes:\n *\tCurrently the PF error in the PGLC is non recoverable.\n *\tIn the future the there will be a recovery routine for this error.\n *\tCurrently attention is masked.\n *\tHaving an MCP lock on the load/unload process does not guarantee that\n *\tthere is no Timer disable during Func6/7 enable. This is because the\n *\tTimers scan is currently being cleared by the MCP on FLR.\n *\tStep 2.d can be done only for PF6/7 and the driver can also check if\n *\tthere is error before clearing it. But the flow above is simpler and\n *\tmore general.\n *\tAll ILT entries are written by zero+valid and not just PF6/7\n *\tILT entries since in the future the ILT entries allocation for\n *\tPF-s might be dynamic.\n */\n\t\tstruct ilt_client_info ilt_cli;\n\t\tstruct bnx2x_ilt ilt;\n\t\tmemset(&ilt_cli, 0, sizeof(struct ilt_client_info));\n\t\tmemset(&ilt, 0, sizeof(struct bnx2x_ilt));\n\n\t\t/* initialize dummy TM client */\n\t\tilt_cli.start = 0;\n\t\tilt_cli.end = ILT_NUM_PAGE_ENTRIES - 1;\n\t\tilt_cli.client_num = ILT_CLIENT_TM;\n\n\t\t/* Step 1: set zeroes to all ilt page entries with valid bit on\n\t\t * Step 2: set the timers first/last ilt entry to point\n\t\t * to the entire range to prevent ILT range error for 3rd/4th\n\t\t * vnic\t(this code assumes existence of the vnic)\n\t\t *\n\t\t * both steps performed by call to bnx2x_ilt_client_init_op()\n\t\t * with dummy TM client\n\t\t *\n\t\t * we must use pretend since PXP2_REG_RQ_##blk##_FIRST_ILT\n\t\t * and his brother are split registers\n\t\t */\n\t\tbnx2x_pretend_func(bp, (BP_PATH(bp) + 6));\n\t\tbnx2x_ilt_client_init_op_ilt(bp, &ilt, &ilt_cli, INITOP_CLEAR);\n\t\tbnx2x_pretend_func(bp, BP_ABS_FUNC(bp));\n\n\t\tREG_WR(bp, PXP2_REG_RQ_DRAM_ALIGN, BNX2X_PXP_DRAM_ALIGN);\n\t\tREG_WR(bp, PXP2_REG_RQ_DRAM_ALIGN_RD, BNX2X_PXP_DRAM_ALIGN);\n\t\tREG_WR(bp, PXP2_REG_RQ_DRAM_ALIGN_SEL, 1);\n\t}\n\n\tREG_WR(bp, PXP2_REG_RQ_DISABLE_INPUTS, 0);\n\tREG_WR(bp, PXP2_REG_RD_DISABLE_INPUTS, 0);\n\n\tif (!CHIP_IS_E1x(bp)) {\n\t\tint factor = CHIP_REV_IS_EMUL(bp) ? 1000 :\n\t\t\t\t(CHIP_REV_IS_FPGA(bp) ? 400 : 0);\n\t\tbnx2x_init_block(bp, BLOCK_PGLUE_B, PHASE_COMMON);\n\n\t\tbnx2x_init_block(bp, BLOCK_ATC, PHASE_COMMON);\n\n\t\t/* let the HW do it's magic ... */\n\t\tdo {\n\t\t\tmsleep(200);\n\t\t\tval = REG_RD(bp, ATC_REG_ATC_INIT_DONE);\n\t\t} while (factor-- && (val != 1));\n\n\t\tif (val != 1) {\n\t\t\tBNX2X_ERR(\"ATC_INIT failed\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tbnx2x_init_block(bp, BLOCK_DMAE, PHASE_COMMON);\n\n\tbnx2x_iov_init_dmae(bp);\n\n\t/* clean the DMAE memory */\n\tbp->dmae_ready = 1;\n\tbnx2x_init_fill(bp, TSEM_REG_PRAM, 0, 8, 1);\n\n\tbnx2x_init_block(bp, BLOCK_TCM, PHASE_COMMON);\n\n\tbnx2x_init_block(bp, BLOCK_UCM, PHASE_COMMON);\n\n\tbnx2x_init_block(bp, BLOCK_CCM, PHASE_COMMON);\n\n\tbnx2x_init_block(bp, BLOCK_XCM, PHASE_COMMON);\n\n\tbnx2x_read_dmae(bp, XSEM_REG_PASSIVE_BUFFER, 3);\n\tbnx2x_read_dmae(bp, CSEM_REG_PASSIVE_BUFFER, 3);\n\tbnx2x_read_dmae(bp, TSEM_REG_PASSIVE_BUFFER, 3);\n\tbnx2x_read_dmae(bp, USEM_REG_PASSIVE_BUFFER, 3);\n\n\tbnx2x_init_block(bp, BLOCK_QM, PHASE_COMMON);\n\n\t/* QM queues pointers table */\n\tbnx2x_qm_init_ptr_table(bp, bp->qm_cid_count, INITOP_SET);\n\n\t/* soft reset pulse */\n\tREG_WR(bp, QM_REG_SOFT_RESET, 1);\n\tREG_WR(bp, QM_REG_SOFT_RESET, 0);\n\n\tif (CNIC_SUPPORT(bp))\n\t\tbnx2x_init_block(bp, BLOCK_TM, PHASE_COMMON);\n\n\tbnx2x_init_block(bp, BLOCK_DORQ, PHASE_COMMON);\n\n\tif (!CHIP_REV_IS_SLOW(bp))\n\t\t/* enable hw interrupt from doorbell Q */\n\t\tREG_WR(bp, DORQ_REG_DORQ_INT_MASK, 0);\n\n\tbnx2x_init_block(bp, BLOCK_BRB1, PHASE_COMMON);\n\n\tbnx2x_init_block(bp, BLOCK_PRS, PHASE_COMMON);\n\tREG_WR(bp, PRS_REG_A_PRSU_20, 0xf);\n\n\tif (!CHIP_IS_E1(bp))\n\t\tREG_WR(bp, PRS_REG_E1HOV_MODE, bp->path_has_ovlan);\n\n\tif (!CHIP_IS_E1x(bp) && !CHIP_IS_E3B0(bp)) {\n\t\tif (IS_MF_AFEX(bp)) {\n\t\t\t/* configure that VNTag and VLAN headers must be\n\t\t\t * received in afex mode\n\t\t\t */\n\t\t\tREG_WR(bp, PRS_REG_HDRS_AFTER_BASIC, 0xE);\n\t\t\tREG_WR(bp, PRS_REG_MUST_HAVE_HDRS, 0xA);\n\t\t\tREG_WR(bp, PRS_REG_HDRS_AFTER_TAG_0, 0x6);\n\t\t\tREG_WR(bp, PRS_REG_TAG_ETHERTYPE_0, 0x8926);\n\t\t\tREG_WR(bp, PRS_REG_TAG_LEN_0, 0x4);\n\t\t} else {\n\t\t\t/* Bit-map indicating which L2 hdrs may appear\n\t\t\t * after the basic Ethernet header\n\t\t\t */\n\t\t\tREG_WR(bp, PRS_REG_HDRS_AFTER_BASIC,\n\t\t\t       bp->path_has_ovlan ? 7 : 6);\n\t\t}\n\t}\n\n\tbnx2x_init_block(bp, BLOCK_TSDM, PHASE_COMMON);\n\tbnx2x_init_block(bp, BLOCK_CSDM, PHASE_COMMON);\n\tbnx2x_init_block(bp, BLOCK_USDM, PHASE_COMMON);\n\tbnx2x_init_block(bp, BLOCK_XSDM, PHASE_COMMON);\n\n\tif (!CHIP_IS_E1x(bp)) {\n\t\t/* reset VFC memories */\n\t\tREG_WR(bp, TSEM_REG_FAST_MEMORY + VFC_REG_MEMORIES_RST,\n\t\t\t   VFC_MEMORIES_RST_REG_CAM_RST |\n\t\t\t   VFC_MEMORIES_RST_REG_RAM_RST);\n\t\tREG_WR(bp, XSEM_REG_FAST_MEMORY + VFC_REG_MEMORIES_RST,\n\t\t\t   VFC_MEMORIES_RST_REG_CAM_RST |\n\t\t\t   VFC_MEMORIES_RST_REG_RAM_RST);\n\n\t\tmsleep(20);\n\t}\n\n\tbnx2x_init_block(bp, BLOCK_TSEM, PHASE_COMMON);\n\tbnx2x_init_block(bp, BLOCK_USEM, PHASE_COMMON);\n\tbnx2x_init_block(bp, BLOCK_CSEM, PHASE_COMMON);\n\tbnx2x_init_block(bp, BLOCK_XSEM, PHASE_COMMON);\n\n\t/* sync semi rtc */\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_CLEAR,\n\t       0x80000000);\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_SET,\n\t       0x80000000);\n\n\tbnx2x_init_block(bp, BLOCK_UPB, PHASE_COMMON);\n\tbnx2x_init_block(bp, BLOCK_XPB, PHASE_COMMON);\n\tbnx2x_init_block(bp, BLOCK_PBF, PHASE_COMMON);\n\n\tif (!CHIP_IS_E1x(bp)) {\n\t\tif (IS_MF_AFEX(bp)) {\n\t\t\t/* configure that VNTag and VLAN headers must be\n\t\t\t * sent in afex mode\n\t\t\t */\n\t\t\tREG_WR(bp, PBF_REG_HDRS_AFTER_BASIC, 0xE);\n\t\t\tREG_WR(bp, PBF_REG_MUST_HAVE_HDRS, 0xA);\n\t\t\tREG_WR(bp, PBF_REG_HDRS_AFTER_TAG_0, 0x6);\n\t\t\tREG_WR(bp, PBF_REG_TAG_ETHERTYPE_0, 0x8926);\n\t\t\tREG_WR(bp, PBF_REG_TAG_LEN_0, 0x4);\n\t\t} else {\n\t\t\tREG_WR(bp, PBF_REG_HDRS_AFTER_BASIC,\n\t\t\t       bp->path_has_ovlan ? 7 : 6);\n\t\t}\n\t}\n\n\tREG_WR(bp, SRC_REG_SOFT_RST, 1);\n\n\tbnx2x_init_block(bp, BLOCK_SRC, PHASE_COMMON);\n\n\tif (CNIC_SUPPORT(bp)) {\n\t\tREG_WR(bp, SRC_REG_KEYSEARCH_0, 0x63285672);\n\t\tREG_WR(bp, SRC_REG_KEYSEARCH_1, 0x24b8f2cc);\n\t\tREG_WR(bp, SRC_REG_KEYSEARCH_2, 0x223aef9b);\n\t\tREG_WR(bp, SRC_REG_KEYSEARCH_3, 0x26001e3a);\n\t\tREG_WR(bp, SRC_REG_KEYSEARCH_4, 0x7ae91116);\n\t\tREG_WR(bp, SRC_REG_KEYSEARCH_5, 0x5ce5230b);\n\t\tREG_WR(bp, SRC_REG_KEYSEARCH_6, 0x298d8adf);\n\t\tREG_WR(bp, SRC_REG_KEYSEARCH_7, 0x6eb0ff09);\n\t\tREG_WR(bp, SRC_REG_KEYSEARCH_8, 0x1830f82f);\n\t\tREG_WR(bp, SRC_REG_KEYSEARCH_9, 0x01e46be7);\n\t}\n\tREG_WR(bp, SRC_REG_SOFT_RST, 0);\n\n\tif (sizeof(union cdu_context) != 1024)\n\t\t/* we currently assume that a context is 1024 bytes */\n\t\tdev_alert(&bp->pdev->dev,\n\t\t\t  \"please adjust the size of cdu_context(%ld)\\n\",\n\t\t\t  (long)sizeof(union cdu_context));\n\n\tbnx2x_init_block(bp, BLOCK_CDU, PHASE_COMMON);\n\tval = (4 << 24) + (0 << 12) + 1024;\n\tREG_WR(bp, CDU_REG_CDU_GLOBAL_PARAMS, val);\n\n\tbnx2x_init_block(bp, BLOCK_CFC, PHASE_COMMON);\n\tREG_WR(bp, CFC_REG_INIT_REG, 0x7FF);\n\t/* enable context validation interrupt from CFC */\n\tREG_WR(bp, CFC_REG_CFC_INT_MASK, 0);\n\n\t/* set the thresholds to prevent CFC/CDU race */\n\tREG_WR(bp, CFC_REG_DEBUG0, 0x20020000);\n\n\tbnx2x_init_block(bp, BLOCK_HC, PHASE_COMMON);\n\n\tif (!CHIP_IS_E1x(bp) && BP_NOMCP(bp))\n\t\tREG_WR(bp, IGU_REG_RESET_MEMORIES, 0x36);\n\n\tbnx2x_init_block(bp, BLOCK_IGU, PHASE_COMMON);\n\tbnx2x_init_block(bp, BLOCK_MISC_AEU, PHASE_COMMON);\n\n\t/* Reset PCIE errors for debug */\n\tREG_WR(bp, 0x2814, 0xffffffff);\n\tREG_WR(bp, 0x3820, 0xffffffff);\n\n\tif (!CHIP_IS_E1x(bp)) {\n\t\tREG_WR(bp, PCICFG_OFFSET + PXPCS_TL_CONTROL_5,\n\t\t\t   (PXPCS_TL_CONTROL_5_ERR_UNSPPORT1 |\n\t\t\t\tPXPCS_TL_CONTROL_5_ERR_UNSPPORT));\n\t\tREG_WR(bp, PCICFG_OFFSET + PXPCS_TL_FUNC345_STAT,\n\t\t\t   (PXPCS_TL_FUNC345_STAT_ERR_UNSPPORT4 |\n\t\t\t\tPXPCS_TL_FUNC345_STAT_ERR_UNSPPORT3 |\n\t\t\t\tPXPCS_TL_FUNC345_STAT_ERR_UNSPPORT2));\n\t\tREG_WR(bp, PCICFG_OFFSET + PXPCS_TL_FUNC678_STAT,\n\t\t\t   (PXPCS_TL_FUNC678_STAT_ERR_UNSPPORT7 |\n\t\t\t\tPXPCS_TL_FUNC678_STAT_ERR_UNSPPORT6 |\n\t\t\t\tPXPCS_TL_FUNC678_STAT_ERR_UNSPPORT5));\n\t}\n\n\tbnx2x_init_block(bp, BLOCK_NIG, PHASE_COMMON);\n\tif (!CHIP_IS_E1(bp)) {\n\t\t/* in E3 this done in per-port section */\n\t\tif (!CHIP_IS_E3(bp))\n\t\t\tREG_WR(bp, NIG_REG_LLH_MF_MODE, IS_MF(bp));\n\t}\n\tif (CHIP_IS_E1H(bp))\n\t\t/* not applicable for E2 (and above ...) */\n\t\tREG_WR(bp, NIG_REG_LLH_E1HOV_MODE, IS_MF_SD(bp));\n\n\tif (CHIP_REV_IS_SLOW(bp))\n\t\tmsleep(200);\n\n\t/* finish CFC init */\n\tval = reg_poll(bp, CFC_REG_LL_INIT_DONE, 1, 100, 10);\n\tif (val != 1) {\n\t\tBNX2X_ERR(\"CFC LL_INIT failed\\n\");\n\t\treturn -EBUSY;\n\t}\n\tval = reg_poll(bp, CFC_REG_AC_INIT_DONE, 1, 100, 10);\n\tif (val != 1) {\n\t\tBNX2X_ERR(\"CFC AC_INIT failed\\n\");\n\t\treturn -EBUSY;\n\t}\n\tval = reg_poll(bp, CFC_REG_CAM_INIT_DONE, 1, 100, 10);\n\tif (val != 1) {\n\t\tBNX2X_ERR(\"CFC CAM_INIT failed\\n\");\n\t\treturn -EBUSY;\n\t}\n\tREG_WR(bp, CFC_REG_DEBUG0, 0);\n\n\tif (CHIP_IS_E1(bp)) {\n\t\t/* read NIG statistic\n\t\t   to see if this is our first up since powerup */\n\t\tbnx2x_read_dmae(bp, NIG_REG_STAT2_BRB_OCTET, 2);\n\t\tval = *bnx2x_sp(bp, wb_data[0]);\n\n\t\t/* do internal memory self test */\n\t\tif ((val == 0) && bnx2x_int_mem_test(bp)) {\n\t\t\tBNX2X_ERR(\"internal mem self test failed\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tbnx2x_setup_fan_failure_detection(bp);\n\n\t/* clear PXP2 attentions */\n\tREG_RD(bp, PXP2_REG_PXP2_INT_STS_CLR_0);\n\n\tbnx2x_enable_blocks_attention(bp);\n\tbnx2x_enable_blocks_parity(bp);\n\n\tif (!BP_NOMCP(bp)) {\n\t\tif (CHIP_IS_E1x(bp))\n\t\t\tbnx2x__common_init_phy(bp);\n\t} else\n\t\tBNX2X_ERR(\"Bootcode is missing - can not initialize link\\n\");\n\n\tif (SHMEM2_HAS(bp, netproc_fw_ver))\n\t\tSHMEM2_WR(bp, netproc_fw_ver, REG_RD(bp, XSEM_REG_PRAM));\n\n\treturn 0;\n}\n\n/**\n * bnx2x_init_hw_common_chip - init HW at the COMMON_CHIP phase.\n *\n * @bp:\t\tdriver handle\n */\nstatic int bnx2x_init_hw_common_chip(struct bnx2x *bp)\n{\n\tint rc = bnx2x_init_hw_common(bp);\n\n\tif (rc)\n\t\treturn rc;\n\n\t/* In E2 2-PORT mode, same ext phy is used for the two paths */\n\tif (!BP_NOMCP(bp))\n\t\tbnx2x__common_init_phy(bp);\n\n\treturn 0;\n}\n\nstatic int bnx2x_init_hw_port(struct bnx2x *bp)\n{\n\tint port = BP_PORT(bp);\n\tint init_phase = port ? PHASE_PORT1 : PHASE_PORT0;\n\tu32 low, high;\n\tu32 val, reg;\n\n\tDP(NETIF_MSG_HW, \"starting port init  port %d\\n\", port);\n\n\tREG_WR(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4, 0);\n\n\tbnx2x_init_block(bp, BLOCK_MISC, init_phase);\n\tbnx2x_init_block(bp, BLOCK_PXP, init_phase);\n\tbnx2x_init_block(bp, BLOCK_PXP2, init_phase);\n\n\t/* Timers bug workaround: disables the pf_master bit in pglue at\n\t * common phase, we need to enable it here before any dmae access are\n\t * attempted. Therefore we manually added the enable-master to the\n\t * port phase (it also happens in the function phase)\n\t */\n\tif (!CHIP_IS_E1x(bp))\n\t\tREG_WR(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER, 1);\n\n\tbnx2x_init_block(bp, BLOCK_ATC, init_phase);\n\tbnx2x_init_block(bp, BLOCK_DMAE, init_phase);\n\tbnx2x_init_block(bp, BLOCK_PGLUE_B, init_phase);\n\tbnx2x_init_block(bp, BLOCK_QM, init_phase);\n\n\tbnx2x_init_block(bp, BLOCK_TCM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_UCM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_CCM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_XCM, init_phase);\n\n\t/* QM cid (connection) count */\n\tbnx2x_qm_init_cid_count(bp, bp->qm_cid_count, INITOP_SET);\n\n\tif (CNIC_SUPPORT(bp)) {\n\t\tbnx2x_init_block(bp, BLOCK_TM, init_phase);\n\t\tREG_WR(bp, TM_REG_LIN0_SCAN_TIME + port*4, 20);\n\t\tREG_WR(bp, TM_REG_LIN0_MAX_ACTIVE_CID + port*4, 31);\n\t}\n\n\tbnx2x_init_block(bp, BLOCK_DORQ, init_phase);\n\n\tbnx2x_init_block(bp, BLOCK_BRB1, init_phase);\n\n\tif (CHIP_IS_E1(bp) || CHIP_IS_E1H(bp)) {\n\n\t\tif (IS_MF(bp))\n\t\t\tlow = ((bp->flags & ONE_PORT_FLAG) ? 160 : 246);\n\t\telse if (bp->dev->mtu > 4096) {\n\t\t\tif (bp->flags & ONE_PORT_FLAG)\n\t\t\t\tlow = 160;\n\t\t\telse {\n\t\t\t\tval = bp->dev->mtu;\n\t\t\t\t/* (24*1024 + val*4)/256 */\n\t\t\t\tlow = 96 + (val/64) +\n\t\t\t\t\t\t((val % 64) ? 1 : 0);\n\t\t\t}\n\t\t} else\n\t\t\tlow = ((bp->flags & ONE_PORT_FLAG) ? 80 : 160);\n\t\thigh = low + 56;\t/* 14*1024/256 */\n\t\tREG_WR(bp, BRB1_REG_PAUSE_LOW_THRESHOLD_0 + port*4, low);\n\t\tREG_WR(bp, BRB1_REG_PAUSE_HIGH_THRESHOLD_0 + port*4, high);\n\t}\n\n\tif (CHIP_MODE_IS_4_PORT(bp))\n\t\tREG_WR(bp, (BP_PORT(bp) ?\n\t\t\t    BRB1_REG_MAC_GUARANTIED_1 :\n\t\t\t    BRB1_REG_MAC_GUARANTIED_0), 40);\n\n\tbnx2x_init_block(bp, BLOCK_PRS, init_phase);\n\tif (CHIP_IS_E3B0(bp)) {\n\t\tif (IS_MF_AFEX(bp)) {\n\t\t\t/* configure headers for AFEX mode */\n\t\t\tREG_WR(bp, BP_PORT(bp) ?\n\t\t\t       PRS_REG_HDRS_AFTER_BASIC_PORT_1 :\n\t\t\t       PRS_REG_HDRS_AFTER_BASIC_PORT_0, 0xE);\n\t\t\tREG_WR(bp, BP_PORT(bp) ?\n\t\t\t       PRS_REG_HDRS_AFTER_TAG_0_PORT_1 :\n\t\t\t       PRS_REG_HDRS_AFTER_TAG_0_PORT_0, 0x6);\n\t\t\tREG_WR(bp, BP_PORT(bp) ?\n\t\t\t       PRS_REG_MUST_HAVE_HDRS_PORT_1 :\n\t\t\t       PRS_REG_MUST_HAVE_HDRS_PORT_0, 0xA);\n\t\t} else {\n\t\t\t/* Ovlan exists only if we are in multi-function +\n\t\t\t * switch-dependent mode, in switch-independent there\n\t\t\t * is no ovlan headers\n\t\t\t */\n\t\t\tREG_WR(bp, BP_PORT(bp) ?\n\t\t\t       PRS_REG_HDRS_AFTER_BASIC_PORT_1 :\n\t\t\t       PRS_REG_HDRS_AFTER_BASIC_PORT_0,\n\t\t\t       (bp->path_has_ovlan ? 7 : 6));\n\t\t}\n\t}\n\n\tbnx2x_init_block(bp, BLOCK_TSDM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_CSDM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_USDM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_XSDM, init_phase);\n\n\tbnx2x_init_block(bp, BLOCK_TSEM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_USEM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_CSEM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_XSEM, init_phase);\n\n\tbnx2x_init_block(bp, BLOCK_UPB, init_phase);\n\tbnx2x_init_block(bp, BLOCK_XPB, init_phase);\n\n\tbnx2x_init_block(bp, BLOCK_PBF, init_phase);\n\n\tif (CHIP_IS_E1x(bp)) {\n\t\t/* configure PBF to work without PAUSE mtu 9000 */\n\t\tREG_WR(bp, PBF_REG_P0_PAUSE_ENABLE + port*4, 0);\n\n\t\t/* update threshold */\n\t\tREG_WR(bp, PBF_REG_P0_ARB_THRSH + port*4, (9040/16));\n\t\t/* update init credit */\n\t\tREG_WR(bp, PBF_REG_P0_INIT_CRD + port*4, (9040/16) + 553 - 22);\n\n\t\t/* probe changes */\n\t\tREG_WR(bp, PBF_REG_INIT_P0 + port*4, 1);\n\t\tudelay(50);\n\t\tREG_WR(bp, PBF_REG_INIT_P0 + port*4, 0);\n\t}\n\n\tif (CNIC_SUPPORT(bp))\n\t\tbnx2x_init_block(bp, BLOCK_SRC, init_phase);\n\n\tbnx2x_init_block(bp, BLOCK_CDU, init_phase);\n\tbnx2x_init_block(bp, BLOCK_CFC, init_phase);\n\n\tif (CHIP_IS_E1(bp)) {\n\t\tREG_WR(bp, HC_REG_LEADING_EDGE_0 + port*8, 0);\n\t\tREG_WR(bp, HC_REG_TRAILING_EDGE_0 + port*8, 0);\n\t}\n\tbnx2x_init_block(bp, BLOCK_HC, init_phase);\n\n\tbnx2x_init_block(bp, BLOCK_IGU, init_phase);\n\n\tbnx2x_init_block(bp, BLOCK_MISC_AEU, init_phase);\n\t/* init aeu_mask_attn_func_0/1:\n\t *  - SF mode: bits 3-7 are masked. Only bits 0-2 are in use\n\t *  - MF mode: bit 3 is masked. Bits 0-2 are in use as in SF\n\t *             bits 4-7 are used for \"per vn group attention\" */\n\tval = IS_MF(bp) ? 0xF7 : 0x7;\n\t/* Enable DCBX attention for all but E1 */\n\tval |= CHIP_IS_E1(bp) ? 0 : 0x10;\n\tREG_WR(bp, MISC_REG_AEU_MASK_ATTN_FUNC_0 + port*4, val);\n\n\t/* SCPAD_PARITY should NOT trigger close the gates */\n\treg = port ? MISC_REG_AEU_ENABLE4_NIG_1 : MISC_REG_AEU_ENABLE4_NIG_0;\n\tREG_WR(bp, reg,\n\t       REG_RD(bp, reg) &\n\t       ~AEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY);\n\n\treg = port ? MISC_REG_AEU_ENABLE4_PXP_1 : MISC_REG_AEU_ENABLE4_PXP_0;\n\tREG_WR(bp, reg,\n\t       REG_RD(bp, reg) &\n\t       ~AEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY);\n\n\tbnx2x_init_block(bp, BLOCK_NIG, init_phase);\n\n\tif (!CHIP_IS_E1x(bp)) {\n\t\t/* Bit-map indicating which L2 hdrs may appear after the\n\t\t * basic Ethernet header\n\t\t */\n\t\tif (IS_MF_AFEX(bp))\n\t\t\tREG_WR(bp, BP_PORT(bp) ?\n\t\t\t       NIG_REG_P1_HDRS_AFTER_BASIC :\n\t\t\t       NIG_REG_P0_HDRS_AFTER_BASIC, 0xE);\n\t\telse\n\t\t\tREG_WR(bp, BP_PORT(bp) ?\n\t\t\t       NIG_REG_P1_HDRS_AFTER_BASIC :\n\t\t\t       NIG_REG_P0_HDRS_AFTER_BASIC,\n\t\t\t       IS_MF_SD(bp) ? 7 : 6);\n\n\t\tif (CHIP_IS_E3(bp))\n\t\t\tREG_WR(bp, BP_PORT(bp) ?\n\t\t\t\t   NIG_REG_LLH1_MF_MODE :\n\t\t\t\t   NIG_REG_LLH_MF_MODE, IS_MF(bp));\n\t}\n\tif (!CHIP_IS_E3(bp))\n\t\tREG_WR(bp, NIG_REG_XGXS_SERDES0_MODE_SEL + port*4, 1);\n\n\tif (!CHIP_IS_E1(bp)) {\n\t\t/* 0x2 disable mf_ov, 0x1 enable */\n\t\tREG_WR(bp, NIG_REG_LLH0_BRB1_DRV_MASK_MF + port*4,\n\t\t       (IS_MF_SD(bp) ? 0x1 : 0x2));\n\n\t\tif (!CHIP_IS_E1x(bp)) {\n\t\t\tval = 0;\n\t\t\tswitch (bp->mf_mode) {\n\t\t\tcase MULTI_FUNCTION_SD:\n\t\t\t\tval = 1;\n\t\t\t\tbreak;\n\t\t\tcase MULTI_FUNCTION_SI:\n\t\t\tcase MULTI_FUNCTION_AFEX:\n\t\t\t\tval = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tREG_WR(bp, (BP_PORT(bp) ? NIG_REG_LLH1_CLS_TYPE :\n\t\t\t\t\t\t  NIG_REG_LLH0_CLS_TYPE), val);\n\t\t}\n\t\t{\n\t\t\tREG_WR(bp, NIG_REG_LLFC_ENABLE_0 + port*4, 0);\n\t\t\tREG_WR(bp, NIG_REG_LLFC_OUT_EN_0 + port*4, 0);\n\t\t\tREG_WR(bp, NIG_REG_PAUSE_ENABLE_0 + port*4, 1);\n\t\t}\n\t}\n\n\t/* If SPIO5 is set to generate interrupts, enable it for this port */\n\tval = REG_RD(bp, MISC_REG_SPIO_EVENT_EN);\n\tif (val & MISC_SPIO_SPIO5) {\n\t\tu32 reg_addr = (port ? MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0 :\n\t\t\t\t       MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0);\n\t\tval = REG_RD(bp, reg_addr);\n\t\tval |= AEU_INPUTS_ATTN_BITS_SPIO5;\n\t\tREG_WR(bp, reg_addr, val);\n\t}\n\n\tif (CHIP_IS_E3B0(bp))\n\t\tbp->flags |= PTP_SUPPORTED;\n\n\treturn 0;\n}\n\nstatic void bnx2x_ilt_wr(struct bnx2x *bp, u32 index, dma_addr_t addr)\n{\n\tint reg;\n\tu32 wb_write[2];\n\n\tif (CHIP_IS_E1(bp))\n\t\treg = PXP2_REG_RQ_ONCHIP_AT + index*8;\n\telse\n\t\treg = PXP2_REG_RQ_ONCHIP_AT_B0 + index*8;\n\n\twb_write[0] = ONCHIP_ADDR1(addr);\n\twb_write[1] = ONCHIP_ADDR2(addr);\n\tREG_WR_DMAE(bp, reg, wb_write, 2);\n}\n\nvoid bnx2x_igu_clear_sb_gen(struct bnx2x *bp, u8 func, u8 idu_sb_id, bool is_pf)\n{\n\tu32 data, ctl, cnt = 100;\n\tu32 igu_addr_data = IGU_REG_COMMAND_REG_32LSB_DATA;\n\tu32 igu_addr_ctl = IGU_REG_COMMAND_REG_CTRL;\n\tu32 igu_addr_ack = IGU_REG_CSTORM_TYPE_0_SB_CLEANUP + (idu_sb_id/32)*4;\n\tu32 sb_bit =  1 << (idu_sb_id%32);\n\tu32 func_encode = func | (is_pf ? 1 : 0) << IGU_FID_ENCODE_IS_PF_SHIFT;\n\tu32 addr_encode = IGU_CMD_E2_PROD_UPD_BASE + idu_sb_id;\n\n\t/* Not supported in BC mode */\n\tif (CHIP_INT_MODE_IS_BC(bp))\n\t\treturn;\n\n\tdata = (IGU_USE_REGISTER_cstorm_type_0_sb_cleanup\n\t\t\t<< IGU_REGULAR_CLEANUP_TYPE_SHIFT)\t|\n\t\tIGU_REGULAR_CLEANUP_SET\t\t\t\t|\n\t\tIGU_REGULAR_BCLEANUP;\n\n\tctl = addr_encode << IGU_CTRL_REG_ADDRESS_SHIFT\t\t|\n\t      func_encode << IGU_CTRL_REG_FID_SHIFT\t\t|\n\t      IGU_CTRL_CMD_TYPE_WR << IGU_CTRL_REG_TYPE_SHIFT;\n\n\tDP(NETIF_MSG_HW, \"write 0x%08x to IGU(via GRC) addr 0x%x\\n\",\n\t\t\t data, igu_addr_data);\n\tREG_WR(bp, igu_addr_data, data);\n\tbarrier();\n\tDP(NETIF_MSG_HW, \"write 0x%08x to IGU(via GRC) addr 0x%x\\n\",\n\t\t\t  ctl, igu_addr_ctl);\n\tREG_WR(bp, igu_addr_ctl, ctl);\n\tbarrier();\n\n\t/* wait for clean up to finish */\n\twhile (!(REG_RD(bp, igu_addr_ack) & sb_bit) && --cnt)\n\t\tmsleep(20);\n\n\tif (!(REG_RD(bp, igu_addr_ack) & sb_bit)) {\n\t\tDP(NETIF_MSG_HW,\n\t\t   \"Unable to finish IGU cleanup: idu_sb_id %d offset %d bit %d (cnt %d)\\n\",\n\t\t\t  idu_sb_id, idu_sb_id/32, idu_sb_id%32, cnt);\n\t}\n}\n\nstatic void bnx2x_igu_clear_sb(struct bnx2x *bp, u8 idu_sb_id)\n{\n\tbnx2x_igu_clear_sb_gen(bp, BP_FUNC(bp), idu_sb_id, true /*PF*/);\n}\n\nstatic void bnx2x_clear_func_ilt(struct bnx2x *bp, u32 func)\n{\n\tu32 i, base = FUNC_ILT_BASE(func);\n\tfor (i = base; i < base + ILT_PER_FUNC; i++)\n\t\tbnx2x_ilt_wr(bp, i, 0);\n}\n\nstatic void bnx2x_init_searcher(struct bnx2x *bp)\n{\n\tint port = BP_PORT(bp);\n\tbnx2x_src_init_t2(bp, bp->t2, bp->t2_mapping, SRC_CONN_NUM);\n\t/* T1 hash bits value determines the T1 number of entries */\n\tREG_WR(bp, SRC_REG_NUMBER_HASH_BITS0 + port*4, SRC_HASH_BITS);\n}\n\nstatic inline int bnx2x_func_switch_update(struct bnx2x *bp, int suspend)\n{\n\tint rc;\n\tstruct bnx2x_func_state_params func_params = {NULL};\n\tstruct bnx2x_func_switch_update_params *switch_update_params =\n\t\t&func_params.params.switch_update;\n\n\t/* Prepare parameters for function state transitions */\n\t__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\n\t__set_bit(RAMROD_RETRY, &func_params.ramrod_flags);\n\n\tfunc_params.f_obj = &bp->func_obj;\n\tfunc_params.cmd = BNX2X_F_CMD_SWITCH_UPDATE;\n\n\t/* Function parameters */\n\t__set_bit(BNX2X_F_UPDATE_TX_SWITCH_SUSPEND_CHNG,\n\t\t  &switch_update_params->changes);\n\tif (suspend)\n\t\t__set_bit(BNX2X_F_UPDATE_TX_SWITCH_SUSPEND,\n\t\t\t  &switch_update_params->changes);\n\n\trc = bnx2x_func_state_change(bp, &func_params);\n\n\treturn rc;\n}\n\nstatic int bnx2x_reset_nic_mode(struct bnx2x *bp)\n{\n\tint rc, i, port = BP_PORT(bp);\n\tint vlan_en = 0, mac_en[NUM_MACS];\n\n\t/* Close input from network */\n\tif (bp->mf_mode == SINGLE_FUNCTION) {\n\t\tbnx2x_set_rx_filter(&bp->link_params, 0);\n\t} else {\n\t\tvlan_en = REG_RD(bp, port ? NIG_REG_LLH1_FUNC_EN :\n\t\t\t\t   NIG_REG_LLH0_FUNC_EN);\n\t\tREG_WR(bp, port ? NIG_REG_LLH1_FUNC_EN :\n\t\t\t  NIG_REG_LLH0_FUNC_EN, 0);\n\t\tfor (i = 0; i < NUM_MACS; i++) {\n\t\t\tmac_en[i] = REG_RD(bp, port ?\n\t\t\t\t\t     (NIG_REG_LLH1_FUNC_MEM_ENABLE +\n\t\t\t\t\t      4 * i) :\n\t\t\t\t\t     (NIG_REG_LLH0_FUNC_MEM_ENABLE +\n\t\t\t\t\t      4 * i));\n\t\t\tREG_WR(bp, port ? (NIG_REG_LLH1_FUNC_MEM_ENABLE +\n\t\t\t\t\t      4 * i) :\n\t\t\t\t  (NIG_REG_LLH0_FUNC_MEM_ENABLE + 4 * i), 0);\n\t\t}\n\t}\n\n\t/* Close BMC to host */\n\tREG_WR(bp, port ? NIG_REG_P0_TX_MNG_HOST_ENABLE :\n\t       NIG_REG_P1_TX_MNG_HOST_ENABLE, 0);\n\n\t/* Suspend Tx switching to the PF. Completion of this ramrod\n\t * further guarantees that all the packets of that PF / child\n\t * VFs in BRB were processed by the Parser, so it is safe to\n\t * change the NIC_MODE register.\n\t */\n\trc = bnx2x_func_switch_update(bp, 1);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Can't suspend tx-switching!\\n\");\n\t\treturn rc;\n\t}\n\n\t/* Change NIC_MODE register */\n\tREG_WR(bp, PRS_REG_NIC_MODE, 0);\n\n\t/* Open input from network */\n\tif (bp->mf_mode == SINGLE_FUNCTION) {\n\t\tbnx2x_set_rx_filter(&bp->link_params, 1);\n\t} else {\n\t\tREG_WR(bp, port ? NIG_REG_LLH1_FUNC_EN :\n\t\t\t  NIG_REG_LLH0_FUNC_EN, vlan_en);\n\t\tfor (i = 0; i < NUM_MACS; i++) {\n\t\t\tREG_WR(bp, port ? (NIG_REG_LLH1_FUNC_MEM_ENABLE +\n\t\t\t\t\t      4 * i) :\n\t\t\t\t  (NIG_REG_LLH0_FUNC_MEM_ENABLE + 4 * i),\n\t\t\t\t  mac_en[i]);\n\t\t}\n\t}\n\n\t/* Enable BMC to host */\n\tREG_WR(bp, port ? NIG_REG_P0_TX_MNG_HOST_ENABLE :\n\t       NIG_REG_P1_TX_MNG_HOST_ENABLE, 1);\n\n\t/* Resume Tx switching to the PF */\n\trc = bnx2x_func_switch_update(bp, 0);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Can't resume tx-switching!\\n\");\n\t\treturn rc;\n\t}\n\n\tDP(NETIF_MSG_IFUP, \"NIC MODE disabled\\n\");\n\treturn 0;\n}\n\nint bnx2x_init_hw_func_cnic(struct bnx2x *bp)\n{\n\tint rc;\n\n\tbnx2x_ilt_init_op_cnic(bp, INITOP_SET);\n\n\tif (CONFIGURE_NIC_MODE(bp)) {\n\t\t/* Configure searcher as part of function hw init */\n\t\tbnx2x_init_searcher(bp);\n\n\t\t/* Reset NIC mode */\n\t\trc = bnx2x_reset_nic_mode(bp);\n\t\tif (rc)\n\t\t\tBNX2X_ERR(\"Can't change NIC mode!\\n\");\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n/* previous driver DMAE transaction may have occurred when pre-boot stage ended\n * and boot began, or when kdump kernel was loaded. Either case would invalidate\n * the addresses of the transaction, resulting in was-error bit set in the pci\n * causing all hw-to-host pcie transactions to timeout. If this happened we want\n * to clear the interrupt which detected this from the pglueb and the was done\n * bit\n */\nstatic void bnx2x_clean_pglue_errors(struct bnx2x *bp)\n{\n\tif (!CHIP_IS_E1x(bp))\n\t\tREG_WR(bp, PGLUE_B_REG_WAS_ERROR_PF_7_0_CLR,\n\t\t       1 << BP_ABS_FUNC(bp));\n}\n\nstatic int bnx2x_init_hw_func(struct bnx2x *bp)\n{\n\tint port = BP_PORT(bp);\n\tint func = BP_FUNC(bp);\n\tint init_phase = PHASE_PF0 + func;\n\tstruct bnx2x_ilt *ilt = BP_ILT(bp);\n\tu16 cdu_ilt_start;\n\tu32 addr, val;\n\tu32 main_mem_base, main_mem_size, main_mem_prty_clr;\n\tint i, main_mem_width, rc;\n\n\tDP(NETIF_MSG_HW, \"starting func init  func %d\\n\", func);\n\n\t/* FLR cleanup - hmmm */\n\tif (!CHIP_IS_E1x(bp)) {\n\t\trc = bnx2x_pf_flr_clnup(bp);\n\t\tif (rc) {\n\t\t\tbnx2x_fw_dump(bp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* set MSI reconfigure capability */\n\tif (bp->common.int_block == INT_BLOCK_HC) {\n\t\taddr = (port ? HC_REG_CONFIG_1 : HC_REG_CONFIG_0);\n\t\tval = REG_RD(bp, addr);\n\t\tval |= HC_CONFIG_0_REG_MSI_ATTN_EN_0;\n\t\tREG_WR(bp, addr, val);\n\t}\n\n\tbnx2x_init_block(bp, BLOCK_PXP, init_phase);\n\tbnx2x_init_block(bp, BLOCK_PXP2, init_phase);\n\n\tilt = BP_ILT(bp);\n\tcdu_ilt_start = ilt->clients[ILT_CLIENT_CDU].start;\n\n\tif (IS_SRIOV(bp))\n\t\tcdu_ilt_start += BNX2X_FIRST_VF_CID/ILT_PAGE_CIDS;\n\tcdu_ilt_start = bnx2x_iov_init_ilt(bp, cdu_ilt_start);\n\n\t/* since BNX2X_FIRST_VF_CID > 0 the PF L2 cids precedes\n\t * those of the VFs, so start line should be reset\n\t */\n\tcdu_ilt_start = ilt->clients[ILT_CLIENT_CDU].start;\n\tfor (i = 0; i < L2_ILT_LINES(bp); i++) {\n\t\tilt->lines[cdu_ilt_start + i].page = bp->context[i].vcxt;\n\t\tilt->lines[cdu_ilt_start + i].page_mapping =\n\t\t\tbp->context[i].cxt_mapping;\n\t\tilt->lines[cdu_ilt_start + i].size = bp->context[i].size;\n\t}\n\n\tbnx2x_ilt_init_op(bp, INITOP_SET);\n\n\tif (!CONFIGURE_NIC_MODE(bp)) {\n\t\tbnx2x_init_searcher(bp);\n\t\tREG_WR(bp, PRS_REG_NIC_MODE, 0);\n\t\tDP(NETIF_MSG_IFUP, \"NIC MODE disabled\\n\");\n\t} else {\n\t\t/* Set NIC mode */\n\t\tREG_WR(bp, PRS_REG_NIC_MODE, 1);\n\t\tDP(NETIF_MSG_IFUP, \"NIC MODE configured\\n\");\n\t}\n\n\tif (!CHIP_IS_E1x(bp)) {\n\t\tu32 pf_conf = IGU_PF_CONF_FUNC_EN;\n\n\t\t/* Turn on a single ISR mode in IGU if driver is going to use\n\t\t * INT#x or MSI\n\t\t */\n\t\tif (!(bp->flags & USING_MSIX_FLAG))\n\t\t\tpf_conf |= IGU_PF_CONF_SINGLE_ISR_EN;\n\t\t/*\n\t\t * Timers workaround bug: function init part.\n\t\t * Need to wait 20msec after initializing ILT,\n\t\t * needed to make sure there are no requests in\n\t\t * one of the PXP internal queues with \"old\" ILT addresses\n\t\t */\n\t\tmsleep(20);\n\t\t/*\n\t\t * Master enable - Due to WB DMAE writes performed before this\n\t\t * register is re-initialized as part of the regular function\n\t\t * init\n\t\t */\n\t\tREG_WR(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER, 1);\n\t\t/* Enable the function in IGU */\n\t\tREG_WR(bp, IGU_REG_PF_CONFIGURATION, pf_conf);\n\t}\n\n\tbp->dmae_ready = 1;\n\n\tbnx2x_init_block(bp, BLOCK_PGLUE_B, init_phase);\n\n\tbnx2x_clean_pglue_errors(bp);\n\n\tbnx2x_init_block(bp, BLOCK_ATC, init_phase);\n\tbnx2x_init_block(bp, BLOCK_DMAE, init_phase);\n\tbnx2x_init_block(bp, BLOCK_NIG, init_phase);\n\tbnx2x_init_block(bp, BLOCK_SRC, init_phase);\n\tbnx2x_init_block(bp, BLOCK_MISC, init_phase);\n\tbnx2x_init_block(bp, BLOCK_TCM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_UCM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_CCM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_XCM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_TSEM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_USEM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_CSEM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_XSEM, init_phase);\n\n\tif (!CHIP_IS_E1x(bp))\n\t\tREG_WR(bp, QM_REG_PF_EN, 1);\n\n\tif (!CHIP_IS_E1x(bp)) {\n\t\tREG_WR(bp, TSEM_REG_VFPF_ERR_NUM, BNX2X_MAX_NUM_OF_VFS + func);\n\t\tREG_WR(bp, USEM_REG_VFPF_ERR_NUM, BNX2X_MAX_NUM_OF_VFS + func);\n\t\tREG_WR(bp, CSEM_REG_VFPF_ERR_NUM, BNX2X_MAX_NUM_OF_VFS + func);\n\t\tREG_WR(bp, XSEM_REG_VFPF_ERR_NUM, BNX2X_MAX_NUM_OF_VFS + func);\n\t}\n\tbnx2x_init_block(bp, BLOCK_QM, init_phase);\n\n\tbnx2x_init_block(bp, BLOCK_TM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_DORQ, init_phase);\n\tREG_WR(bp, DORQ_REG_MODE_ACT, 1); /* no dpm */\n\n\tbnx2x_iov_init_dq(bp);\n\n\tbnx2x_init_block(bp, BLOCK_BRB1, init_phase);\n\tbnx2x_init_block(bp, BLOCK_PRS, init_phase);\n\tbnx2x_init_block(bp, BLOCK_TSDM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_CSDM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_USDM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_XSDM, init_phase);\n\tbnx2x_init_block(bp, BLOCK_UPB, init_phase);\n\tbnx2x_init_block(bp, BLOCK_XPB, init_phase);\n\tbnx2x_init_block(bp, BLOCK_PBF, init_phase);\n\tif (!CHIP_IS_E1x(bp))\n\t\tREG_WR(bp, PBF_REG_DISABLE_PF, 0);\n\n\tbnx2x_init_block(bp, BLOCK_CDU, init_phase);\n\n\tbnx2x_init_block(bp, BLOCK_CFC, init_phase);\n\n\tif (!CHIP_IS_E1x(bp))\n\t\tREG_WR(bp, CFC_REG_WEAK_ENABLE_PF, 1);\n\n\tif (IS_MF(bp)) {\n\t\tif (!(IS_MF_UFP(bp) && BNX2X_IS_MF_SD_PROTOCOL_FCOE(bp))) {\n\t\t\tREG_WR(bp, NIG_REG_LLH0_FUNC_EN + port * 8, 1);\n\t\t\tREG_WR(bp, NIG_REG_LLH0_FUNC_VLAN_ID + port * 8,\n\t\t\t       bp->mf_ov);\n\t\t}\n\t}\n\n\tbnx2x_init_block(bp, BLOCK_MISC_AEU, init_phase);\n\n\t/* HC init per function */\n\tif (bp->common.int_block == INT_BLOCK_HC) {\n\t\tif (CHIP_IS_E1H(bp)) {\n\t\t\tREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_12 + func*4, 0);\n\n\t\t\tREG_WR(bp, HC_REG_LEADING_EDGE_0 + port*8, 0);\n\t\t\tREG_WR(bp, HC_REG_TRAILING_EDGE_0 + port*8, 0);\n\t\t}\n\t\tbnx2x_init_block(bp, BLOCK_HC, init_phase);\n\n\t} else {\n\t\tint num_segs, sb_idx, prod_offset;\n\n\t\tREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_12 + func*4, 0);\n\n\t\tif (!CHIP_IS_E1x(bp)) {\n\t\t\tREG_WR(bp, IGU_REG_LEADING_EDGE_LATCH, 0);\n\t\t\tREG_WR(bp, IGU_REG_TRAILING_EDGE_LATCH, 0);\n\t\t}\n\n\t\tbnx2x_init_block(bp, BLOCK_IGU, init_phase);\n\n\t\tif (!CHIP_IS_E1x(bp)) {\n\t\t\tint dsb_idx = 0;\n\t\t\t/**\n\t\t\t * Producer memory:\n\t\t\t * E2 mode: address 0-135 match to the mapping memory;\n\t\t\t * 136 - PF0 default prod; 137 - PF1 default prod;\n\t\t\t * 138 - PF2 default prod; 139 - PF3 default prod;\n\t\t\t * 140 - PF0 attn prod;    141 - PF1 attn prod;\n\t\t\t * 142 - PF2 attn prod;    143 - PF3 attn prod;\n\t\t\t * 144-147 reserved.\n\t\t\t *\n\t\t\t * E1.5 mode - In backward compatible mode;\n\t\t\t * for non default SB; each even line in the memory\n\t\t\t * holds the U producer and each odd line hold\n\t\t\t * the C producer. The first 128 producers are for\n\t\t\t * NDSB (PF0 - 0-31; PF1 - 32-63 and so on). The last 20\n\t\t\t * producers are for the DSB for each PF.\n\t\t\t * Each PF has five segments: (the order inside each\n\t\t\t * segment is PF0; PF1; PF2; PF3) - 128-131 U prods;\n\t\t\t * 132-135 C prods; 136-139 X prods; 140-143 T prods;\n\t\t\t * 144-147 attn prods;\n\t\t\t */\n\t\t\t/* non-default-status-blocks */\n\t\t\tnum_segs = CHIP_INT_MODE_IS_BC(bp) ?\n\t\t\t\tIGU_BC_NDSB_NUM_SEGS : IGU_NORM_NDSB_NUM_SEGS;\n\t\t\tfor (sb_idx = 0; sb_idx < bp->igu_sb_cnt; sb_idx++) {\n\t\t\t\tprod_offset = (bp->igu_base_sb + sb_idx) *\n\t\t\t\t\tnum_segs;\n\n\t\t\t\tfor (i = 0; i < num_segs; i++) {\n\t\t\t\t\taddr = IGU_REG_PROD_CONS_MEMORY +\n\t\t\t\t\t\t\t(prod_offset + i) * 4;\n\t\t\t\t\tREG_WR(bp, addr, 0);\n\t\t\t\t}\n\t\t\t\t/* send consumer update with value 0 */\n\t\t\t\tbnx2x_ack_sb(bp, bp->igu_base_sb + sb_idx,\n\t\t\t\t\t     USTORM_ID, 0, IGU_INT_NOP, 1);\n\t\t\t\tbnx2x_igu_clear_sb(bp,\n\t\t\t\t\t\t   bp->igu_base_sb + sb_idx);\n\t\t\t}\n\n\t\t\t/* default-status-blocks */\n\t\t\tnum_segs = CHIP_INT_MODE_IS_BC(bp) ?\n\t\t\t\tIGU_BC_DSB_NUM_SEGS : IGU_NORM_DSB_NUM_SEGS;\n\n\t\t\tif (CHIP_MODE_IS_4_PORT(bp))\n\t\t\t\tdsb_idx = BP_FUNC(bp);\n\t\t\telse\n\t\t\t\tdsb_idx = BP_VN(bp);\n\n\t\t\tprod_offset = (CHIP_INT_MODE_IS_BC(bp) ?\n\t\t\t\t       IGU_BC_BASE_DSB_PROD + dsb_idx :\n\t\t\t\t       IGU_NORM_BASE_DSB_PROD + dsb_idx);\n\n\t\t\t/*\n\t\t\t * igu prods come in chunks of E1HVN_MAX (4) -\n\t\t\t * does not matters what is the current chip mode\n\t\t\t */\n\t\t\tfor (i = 0; i < (num_segs * E1HVN_MAX);\n\t\t\t     i += E1HVN_MAX) {\n\t\t\t\taddr = IGU_REG_PROD_CONS_MEMORY +\n\t\t\t\t\t\t\t(prod_offset + i)*4;\n\t\t\t\tREG_WR(bp, addr, 0);\n\t\t\t}\n\t\t\t/* send consumer update with 0 */\n\t\t\tif (CHIP_INT_MODE_IS_BC(bp)) {\n\t\t\t\tbnx2x_ack_sb(bp, bp->igu_dsb_id,\n\t\t\t\t\t     USTORM_ID, 0, IGU_INT_NOP, 1);\n\t\t\t\tbnx2x_ack_sb(bp, bp->igu_dsb_id,\n\t\t\t\t\t     CSTORM_ID, 0, IGU_INT_NOP, 1);\n\t\t\t\tbnx2x_ack_sb(bp, bp->igu_dsb_id,\n\t\t\t\t\t     XSTORM_ID, 0, IGU_INT_NOP, 1);\n\t\t\t\tbnx2x_ack_sb(bp, bp->igu_dsb_id,\n\t\t\t\t\t     TSTORM_ID, 0, IGU_INT_NOP, 1);\n\t\t\t\tbnx2x_ack_sb(bp, bp->igu_dsb_id,\n\t\t\t\t\t     ATTENTION_ID, 0, IGU_INT_NOP, 1);\n\t\t\t} else {\n\t\t\t\tbnx2x_ack_sb(bp, bp->igu_dsb_id,\n\t\t\t\t\t     USTORM_ID, 0, IGU_INT_NOP, 1);\n\t\t\t\tbnx2x_ack_sb(bp, bp->igu_dsb_id,\n\t\t\t\t\t     ATTENTION_ID, 0, IGU_INT_NOP, 1);\n\t\t\t}\n\t\t\tbnx2x_igu_clear_sb(bp, bp->igu_dsb_id);\n\n\t\t\t/* !!! These should become driver const once\n\t\t\t   rf-tool supports split-68 const */\n\t\t\tREG_WR(bp, IGU_REG_SB_INT_BEFORE_MASK_LSB, 0);\n\t\t\tREG_WR(bp, IGU_REG_SB_INT_BEFORE_MASK_MSB, 0);\n\t\t\tREG_WR(bp, IGU_REG_SB_MASK_LSB, 0);\n\t\t\tREG_WR(bp, IGU_REG_SB_MASK_MSB, 0);\n\t\t\tREG_WR(bp, IGU_REG_PBA_STATUS_LSB, 0);\n\t\t\tREG_WR(bp, IGU_REG_PBA_STATUS_MSB, 0);\n\t\t}\n\t}\n\n\t/* Reset PCIE errors for debug */\n\tREG_WR(bp, 0x2114, 0xffffffff);\n\tREG_WR(bp, 0x2120, 0xffffffff);\n\n\tif (CHIP_IS_E1x(bp)) {\n\t\tmain_mem_size = HC_REG_MAIN_MEMORY_SIZE / 2; /*dwords*/\n\t\tmain_mem_base = HC_REG_MAIN_MEMORY +\n\t\t\t\tBP_PORT(bp) * (main_mem_size * 4);\n\t\tmain_mem_prty_clr = HC_REG_HC_PRTY_STS_CLR;\n\t\tmain_mem_width = 8;\n\n\t\tval = REG_RD(bp, main_mem_prty_clr);\n\t\tif (val)\n\t\t\tDP(NETIF_MSG_HW,\n\t\t\t   \"Hmmm... Parity errors in HC block during function init (0x%x)!\\n\",\n\t\t\t   val);\n\n\t\t/* Clear \"false\" parity errors in MSI-X table */\n\t\tfor (i = main_mem_base;\n\t\t     i < main_mem_base + main_mem_size * 4;\n\t\t     i += main_mem_width) {\n\t\t\tbnx2x_read_dmae(bp, i, main_mem_width / 4);\n\t\t\tbnx2x_write_dmae(bp, bnx2x_sp_mapping(bp, wb_data),\n\t\t\t\t\t i, main_mem_width / 4);\n\t\t}\n\t\t/* Clear HC parity attention */\n\t\tREG_RD(bp, main_mem_prty_clr);\n\t}\n\n#ifdef BNX2X_STOP_ON_ERROR\n\t/* Enable STORMs SP logging */\n\tREG_WR8(bp, BAR_USTRORM_INTMEM +\n\t       USTORM_RECORD_SLOW_PATH_OFFSET(BP_FUNC(bp)), 1);\n\tREG_WR8(bp, BAR_TSTRORM_INTMEM +\n\t       TSTORM_RECORD_SLOW_PATH_OFFSET(BP_FUNC(bp)), 1);\n\tREG_WR8(bp, BAR_CSTRORM_INTMEM +\n\t       CSTORM_RECORD_SLOW_PATH_OFFSET(BP_FUNC(bp)), 1);\n\tREG_WR8(bp, BAR_XSTRORM_INTMEM +\n\t       XSTORM_RECORD_SLOW_PATH_OFFSET(BP_FUNC(bp)), 1);\n#endif\n\n\tbnx2x_phy_probe(&bp->link_params);\n\n\treturn 0;\n}\n\nvoid bnx2x_free_mem_cnic(struct bnx2x *bp)\n{\n\tbnx2x_ilt_mem_op_cnic(bp, ILT_MEMOP_FREE);\n\n\tif (!CHIP_IS_E1x(bp))\n\t\tBNX2X_PCI_FREE(bp->cnic_sb.e2_sb, bp->cnic_sb_mapping,\n\t\t\t       sizeof(struct host_hc_status_block_e2));\n\telse\n\t\tBNX2X_PCI_FREE(bp->cnic_sb.e1x_sb, bp->cnic_sb_mapping,\n\t\t\t       sizeof(struct host_hc_status_block_e1x));\n\n\tBNX2X_PCI_FREE(bp->t2, bp->t2_mapping, SRC_T2_SZ);\n}\n\nvoid bnx2x_free_mem(struct bnx2x *bp)\n{\n\tint i;\n\n\tBNX2X_PCI_FREE(bp->fw_stats, bp->fw_stats_mapping,\n\t\t       bp->fw_stats_data_sz + bp->fw_stats_req_sz);\n\n\tif (IS_VF(bp))\n\t\treturn;\n\n\tBNX2X_PCI_FREE(bp->def_status_blk, bp->def_status_blk_mapping,\n\t\t       sizeof(struct host_sp_status_block));\n\n\tBNX2X_PCI_FREE(bp->slowpath, bp->slowpath_mapping,\n\t\t       sizeof(struct bnx2x_slowpath));\n\n\tfor (i = 0; i < L2_ILT_LINES(bp); i++)\n\t\tBNX2X_PCI_FREE(bp->context[i].vcxt, bp->context[i].cxt_mapping,\n\t\t\t       bp->context[i].size);\n\tbnx2x_ilt_mem_op(bp, ILT_MEMOP_FREE);\n\n\tBNX2X_FREE(bp->ilt->lines);\n\n\tBNX2X_PCI_FREE(bp->spq, bp->spq_mapping, BCM_PAGE_SIZE);\n\n\tBNX2X_PCI_FREE(bp->eq_ring, bp->eq_mapping,\n\t\t       BCM_PAGE_SIZE * NUM_EQ_PAGES);\n\n\tBNX2X_PCI_FREE(bp->t2, bp->t2_mapping, SRC_T2_SZ);\n\n\tbnx2x_iov_free_mem(bp);\n}\n\nint bnx2x_alloc_mem_cnic(struct bnx2x *bp)\n{\n\tif (!CHIP_IS_E1x(bp)) {\n\t\t/* size = the status block + ramrod buffers */\n\t\tbp->cnic_sb.e2_sb = BNX2X_PCI_ALLOC(&bp->cnic_sb_mapping,\n\t\t\t\t\t\t    sizeof(struct host_hc_status_block_e2));\n\t\tif (!bp->cnic_sb.e2_sb)\n\t\t\tgoto alloc_mem_err;\n\t} else {\n\t\tbp->cnic_sb.e1x_sb = BNX2X_PCI_ALLOC(&bp->cnic_sb_mapping,\n\t\t\t\t\t\t     sizeof(struct host_hc_status_block_e1x));\n\t\tif (!bp->cnic_sb.e1x_sb)\n\t\t\tgoto alloc_mem_err;\n\t}\n\n\tif (CONFIGURE_NIC_MODE(bp) && !bp->t2) {\n\t\t/* allocate searcher T2 table, as it wasn't allocated before */\n\t\tbp->t2 = BNX2X_PCI_ALLOC(&bp->t2_mapping, SRC_T2_SZ);\n\t\tif (!bp->t2)\n\t\t\tgoto alloc_mem_err;\n\t}\n\n\t/* write address to which L5 should insert its values */\n\tbp->cnic_eth_dev.addr_drv_info_to_mcp =\n\t\t&bp->slowpath->drv_info_to_mcp;\n\n\tif (bnx2x_ilt_mem_op_cnic(bp, ILT_MEMOP_ALLOC))\n\t\tgoto alloc_mem_err;\n\n\treturn 0;\n\nalloc_mem_err:\n\tbnx2x_free_mem_cnic(bp);\n\tBNX2X_ERR(\"Can't allocate memory\\n\");\n\treturn -ENOMEM;\n}\n\nint bnx2x_alloc_mem(struct bnx2x *bp)\n{\n\tint i, allocated, context_size;\n\n\tif (!CONFIGURE_NIC_MODE(bp) && !bp->t2) {\n\t\t/* allocate searcher T2 table */\n\t\tbp->t2 = BNX2X_PCI_ALLOC(&bp->t2_mapping, SRC_T2_SZ);\n\t\tif (!bp->t2)\n\t\t\tgoto alloc_mem_err;\n\t}\n\n\tbp->def_status_blk = BNX2X_PCI_ALLOC(&bp->def_status_blk_mapping,\n\t\t\t\t\t     sizeof(struct host_sp_status_block));\n\tif (!bp->def_status_blk)\n\t\tgoto alloc_mem_err;\n\n\tbp->slowpath = BNX2X_PCI_ALLOC(&bp->slowpath_mapping,\n\t\t\t\t       sizeof(struct bnx2x_slowpath));\n\tif (!bp->slowpath)\n\t\tgoto alloc_mem_err;\n\n\t/* Allocate memory for CDU context:\n\t * This memory is allocated separately and not in the generic ILT\n\t * functions because CDU differs in few aspects:\n\t * 1. There are multiple entities allocating memory for context -\n\t * 'regular' driver, CNIC and SRIOV driver. Each separately controls\n\t * its own ILT lines.\n\t * 2. Since CDU page-size is not a single 4KB page (which is the case\n\t * for the other ILT clients), to be efficient we want to support\n\t * allocation of sub-page-size in the last entry.\n\t * 3. Context pointers are used by the driver to pass to FW / update\n\t * the context (for the other ILT clients the pointers are used just to\n\t * free the memory during unload).\n\t */\n\tcontext_size = sizeof(union cdu_context) * BNX2X_L2_CID_COUNT(bp);\n\n\tfor (i = 0, allocated = 0; allocated < context_size; i++) {\n\t\tbp->context[i].size = min(CDU_ILT_PAGE_SZ,\n\t\t\t\t\t  (context_size - allocated));\n\t\tbp->context[i].vcxt = BNX2X_PCI_ALLOC(&bp->context[i].cxt_mapping,\n\t\t\t\t\t\t      bp->context[i].size);\n\t\tif (!bp->context[i].vcxt)\n\t\t\tgoto alloc_mem_err;\n\t\tallocated += bp->context[i].size;\n\t}\n\tbp->ilt->lines = kcalloc(ILT_MAX_LINES, sizeof(struct ilt_line),\n\t\t\t\t GFP_KERNEL);\n\tif (!bp->ilt->lines)\n\t\tgoto alloc_mem_err;\n\n\tif (bnx2x_ilt_mem_op(bp, ILT_MEMOP_ALLOC))\n\t\tgoto alloc_mem_err;\n\n\tif (bnx2x_iov_alloc_mem(bp))\n\t\tgoto alloc_mem_err;\n\n\t/* Slow path ring */\n\tbp->spq = BNX2X_PCI_ALLOC(&bp->spq_mapping, BCM_PAGE_SIZE);\n\tif (!bp->spq)\n\t\tgoto alloc_mem_err;\n\n\t/* EQ */\n\tbp->eq_ring = BNX2X_PCI_ALLOC(&bp->eq_mapping,\n\t\t\t\t      BCM_PAGE_SIZE * NUM_EQ_PAGES);\n\tif (!bp->eq_ring)\n\t\tgoto alloc_mem_err;\n\n\treturn 0;\n\nalloc_mem_err:\n\tbnx2x_free_mem(bp);\n\tBNX2X_ERR(\"Can't allocate memory\\n\");\n\treturn -ENOMEM;\n}\n\n/*\n * Init service functions\n */\n\nint bnx2x_set_mac_one(struct bnx2x *bp, u8 *mac,\n\t\t      struct bnx2x_vlan_mac_obj *obj, bool set,\n\t\t      int mac_type, unsigned long *ramrod_flags)\n{\n\tint rc;\n\tstruct bnx2x_vlan_mac_ramrod_params ramrod_param;\n\n\tmemset(&ramrod_param, 0, sizeof(ramrod_param));\n\n\t/* Fill general parameters */\n\tramrod_param.vlan_mac_obj = obj;\n\tramrod_param.ramrod_flags = *ramrod_flags;\n\n\t/* Fill a user request section if needed */\n\tif (!test_bit(RAMROD_CONT, ramrod_flags)) {\n\t\tmemcpy(ramrod_param.user_req.u.mac.mac, mac, ETH_ALEN);\n\n\t\t__set_bit(mac_type, &ramrod_param.user_req.vlan_mac_flags);\n\n\t\t/* Set the command: ADD or DEL */\n\t\tif (set)\n\t\t\tramrod_param.user_req.cmd = BNX2X_VLAN_MAC_ADD;\n\t\telse\n\t\t\tramrod_param.user_req.cmd = BNX2X_VLAN_MAC_DEL;\n\t}\n\n\trc = bnx2x_config_vlan_mac(bp, &ramrod_param);\n\n\tif (rc == -EEXIST) {\n\t\tDP(BNX2X_MSG_SP, \"Failed to schedule ADD operations: %d\\n\", rc);\n\t\t/* do not treat adding same MAC as error */\n\t\trc = 0;\n\t} else if (rc < 0)\n\t\tBNX2X_ERR(\"%s MAC failed\\n\", (set ? \"Set\" : \"Del\"));\n\n\treturn rc;\n}\n\nint bnx2x_set_vlan_one(struct bnx2x *bp, u16 vlan,\n\t\t       struct bnx2x_vlan_mac_obj *obj, bool set,\n\t\t       unsigned long *ramrod_flags)\n{\n\tint rc;\n\tstruct bnx2x_vlan_mac_ramrod_params ramrod_param;\n\n\tmemset(&ramrod_param, 0, sizeof(ramrod_param));\n\n\t/* Fill general parameters */\n\tramrod_param.vlan_mac_obj = obj;\n\tramrod_param.ramrod_flags = *ramrod_flags;\n\n\t/* Fill a user request section if needed */\n\tif (!test_bit(RAMROD_CONT, ramrod_flags)) {\n\t\tramrod_param.user_req.u.vlan.vlan = vlan;\n\t\t__set_bit(BNX2X_VLAN, &ramrod_param.user_req.vlan_mac_flags);\n\t\t/* Set the command: ADD or DEL */\n\t\tif (set)\n\t\t\tramrod_param.user_req.cmd = BNX2X_VLAN_MAC_ADD;\n\t\telse\n\t\t\tramrod_param.user_req.cmd = BNX2X_VLAN_MAC_DEL;\n\t}\n\n\trc = bnx2x_config_vlan_mac(bp, &ramrod_param);\n\n\tif (rc == -EEXIST) {\n\t\t/* Do not treat adding same vlan as error. */\n\t\tDP(BNX2X_MSG_SP, \"Failed to schedule ADD operations: %d\\n\", rc);\n\t\trc = 0;\n\t} else if (rc < 0) {\n\t\tBNX2X_ERR(\"%s VLAN failed\\n\", (set ? \"Set\" : \"Del\"));\n\t}\n\n\treturn rc;\n}\n\nvoid bnx2x_clear_vlan_info(struct bnx2x *bp)\n{\n\tstruct bnx2x_vlan_entry *vlan;\n\n\t/* Mark that hw forgot all entries */\n\tlist_for_each_entry(vlan, &bp->vlan_reg, link)\n\t\tvlan->hw = false;\n\n\tbp->vlan_cnt = 0;\n}\n\nstatic int bnx2x_del_all_vlans(struct bnx2x *bp)\n{\n\tstruct bnx2x_vlan_mac_obj *vlan_obj = &bp->sp_objs[0].vlan_obj;\n\tunsigned long ramrod_flags = 0, vlan_flags = 0;\n\tint rc;\n\n\t__set_bit(RAMROD_COMP_WAIT, &ramrod_flags);\n\t__set_bit(BNX2X_VLAN, &vlan_flags);\n\trc = vlan_obj->delete_all(bp, vlan_obj, &vlan_flags, &ramrod_flags);\n\tif (rc)\n\t\treturn rc;\n\n\tbnx2x_clear_vlan_info(bp);\n\n\treturn 0;\n}\n\nint bnx2x_del_all_macs(struct bnx2x *bp,\n\t\t       struct bnx2x_vlan_mac_obj *mac_obj,\n\t\t       int mac_type, bool wait_for_comp)\n{\n\tint rc;\n\tunsigned long ramrod_flags = 0, vlan_mac_flags = 0;\n\n\t/* Wait for completion of requested */\n\tif (wait_for_comp)\n\t\t__set_bit(RAMROD_COMP_WAIT, &ramrod_flags);\n\n\t/* Set the mac type of addresses we want to clear */\n\t__set_bit(mac_type, &vlan_mac_flags);\n\n\trc = mac_obj->delete_all(bp, mac_obj, &vlan_mac_flags, &ramrod_flags);\n\tif (rc < 0)\n\t\tBNX2X_ERR(\"Failed to delete MACs: %d\\n\", rc);\n\n\treturn rc;\n}\n\nint bnx2x_set_eth_mac(struct bnx2x *bp, bool set)\n{\n\tif (IS_PF(bp)) {\n\t\tunsigned long ramrod_flags = 0;\n\n\t\tDP(NETIF_MSG_IFUP, \"Adding Eth MAC\\n\");\n\t\t__set_bit(RAMROD_COMP_WAIT, &ramrod_flags);\n\t\treturn bnx2x_set_mac_one(bp, bp->dev->dev_addr,\n\t\t\t\t\t &bp->sp_objs->mac_obj, set,\n\t\t\t\t\t BNX2X_ETH_MAC, &ramrod_flags);\n\t} else { /* vf */\n\t\treturn bnx2x_vfpf_config_mac(bp, bp->dev->dev_addr,\n\t\t\t\t\t     bp->fp->index, set);\n\t}\n}\n\nint bnx2x_setup_leading(struct bnx2x *bp)\n{\n\tif (IS_PF(bp))\n\t\treturn bnx2x_setup_queue(bp, &bp->fp[0], true);\n\telse /* VF */\n\t\treturn bnx2x_vfpf_setup_q(bp, &bp->fp[0], true);\n}\n\n/**\n * bnx2x_set_int_mode - configure interrupt mode\n *\n * @bp:\t\tdriver handle\n *\n * In case of MSI-X it will also try to enable MSI-X.\n */\nint bnx2x_set_int_mode(struct bnx2x *bp)\n{\n\tint rc = 0;\n\n\tif (IS_VF(bp) && int_mode != BNX2X_INT_MODE_MSIX) {\n\t\tBNX2X_ERR(\"VF not loaded since interrupt mode not msix\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (int_mode) {\n\tcase BNX2X_INT_MODE_MSIX:\n\t\t/* attempt to enable msix */\n\t\trc = bnx2x_enable_msix(bp);\n\n\t\t/* msix attained */\n\t\tif (!rc)\n\t\t\treturn 0;\n\n\t\t/* vfs use only msix */\n\t\tif (rc && IS_VF(bp))\n\t\t\treturn rc;\n\n\t\t/* failed to enable multiple MSI-X */\n\t\tBNX2X_DEV_INFO(\"Failed to enable multiple MSI-X (%d), set number of queues to %d\\n\",\n\t\t\t       bp->num_queues,\n\t\t\t       1 + bp->num_cnic_queues);\n\n\t\tfallthrough;\n\tcase BNX2X_INT_MODE_MSI:\n\t\tbnx2x_enable_msi(bp);\n\n\t\tfallthrough;\n\tcase BNX2X_INT_MODE_INTX:\n\t\tbp->num_ethernet_queues = 1;\n\t\tbp->num_queues = bp->num_ethernet_queues + bp->num_cnic_queues;\n\t\tBNX2X_DEV_INFO(\"set number of queues to 1\\n\");\n\t\tbreak;\n\tdefault:\n\t\tBNX2X_DEV_INFO(\"unknown value in int_mode module parameter\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n/* must be called prior to any HW initializations */\nstatic inline u16 bnx2x_cid_ilt_lines(struct bnx2x *bp)\n{\n\tif (IS_SRIOV(bp))\n\t\treturn (BNX2X_FIRST_VF_CID + BNX2X_VF_CIDS)/ILT_PAGE_CIDS;\n\treturn L2_ILT_LINES(bp);\n}\n\nvoid bnx2x_ilt_set_info(struct bnx2x *bp)\n{\n\tstruct ilt_client_info *ilt_client;\n\tstruct bnx2x_ilt *ilt = BP_ILT(bp);\n\tu16 line = 0;\n\n\tilt->start_line = FUNC_ILT_BASE(BP_FUNC(bp));\n\tDP(BNX2X_MSG_SP, \"ilt starts at line %d\\n\", ilt->start_line);\n\n\t/* CDU */\n\tilt_client = &ilt->clients[ILT_CLIENT_CDU];\n\tilt_client->client_num = ILT_CLIENT_CDU;\n\tilt_client->page_size = CDU_ILT_PAGE_SZ;\n\tilt_client->flags = ILT_CLIENT_SKIP_MEM;\n\tilt_client->start = line;\n\tline += bnx2x_cid_ilt_lines(bp);\n\n\tif (CNIC_SUPPORT(bp))\n\t\tline += CNIC_ILT_LINES;\n\tilt_client->end = line - 1;\n\n\tDP(NETIF_MSG_IFUP, \"ilt client[CDU]: start %d, end %d, psz 0x%x, flags 0x%x, hw psz %d\\n\",\n\t   ilt_client->start,\n\t   ilt_client->end,\n\t   ilt_client->page_size,\n\t   ilt_client->flags,\n\t   ilog2(ilt_client->page_size >> 12));\n\n\t/* QM */\n\tif (QM_INIT(bp->qm_cid_count)) {\n\t\tilt_client = &ilt->clients[ILT_CLIENT_QM];\n\t\tilt_client->client_num = ILT_CLIENT_QM;\n\t\tilt_client->page_size = QM_ILT_PAGE_SZ;\n\t\tilt_client->flags = 0;\n\t\tilt_client->start = line;\n\n\t\t/* 4 bytes for each cid */\n\t\tline += DIV_ROUND_UP(bp->qm_cid_count * QM_QUEUES_PER_FUNC * 4,\n\t\t\t\t\t\t\t QM_ILT_PAGE_SZ);\n\n\t\tilt_client->end = line - 1;\n\n\t\tDP(NETIF_MSG_IFUP,\n\t\t   \"ilt client[QM]: start %d, end %d, psz 0x%x, flags 0x%x, hw psz %d\\n\",\n\t\t   ilt_client->start,\n\t\t   ilt_client->end,\n\t\t   ilt_client->page_size,\n\t\t   ilt_client->flags,\n\t\t   ilog2(ilt_client->page_size >> 12));\n\t}\n\n\tif (CNIC_SUPPORT(bp)) {\n\t\t/* SRC */\n\t\tilt_client = &ilt->clients[ILT_CLIENT_SRC];\n\t\tilt_client->client_num = ILT_CLIENT_SRC;\n\t\tilt_client->page_size = SRC_ILT_PAGE_SZ;\n\t\tilt_client->flags = 0;\n\t\tilt_client->start = line;\n\t\tline += SRC_ILT_LINES;\n\t\tilt_client->end = line - 1;\n\n\t\tDP(NETIF_MSG_IFUP,\n\t\t   \"ilt client[SRC]: start %d, end %d, psz 0x%x, flags 0x%x, hw psz %d\\n\",\n\t\t   ilt_client->start,\n\t\t   ilt_client->end,\n\t\t   ilt_client->page_size,\n\t\t   ilt_client->flags,\n\t\t   ilog2(ilt_client->page_size >> 12));\n\n\t\t/* TM */\n\t\tilt_client = &ilt->clients[ILT_CLIENT_TM];\n\t\tilt_client->client_num = ILT_CLIENT_TM;\n\t\tilt_client->page_size = TM_ILT_PAGE_SZ;\n\t\tilt_client->flags = 0;\n\t\tilt_client->start = line;\n\t\tline += TM_ILT_LINES;\n\t\tilt_client->end = line - 1;\n\n\t\tDP(NETIF_MSG_IFUP,\n\t\t   \"ilt client[TM]: start %d, end %d, psz 0x%x, flags 0x%x, hw psz %d\\n\",\n\t\t   ilt_client->start,\n\t\t   ilt_client->end,\n\t\t   ilt_client->page_size,\n\t\t   ilt_client->flags,\n\t\t   ilog2(ilt_client->page_size >> 12));\n\t}\n\n\tBUG_ON(line > ILT_MAX_LINES);\n}\n\n/**\n * bnx2x_pf_q_prep_init - prepare INIT transition parameters\n *\n * @bp:\t\t\tdriver handle\n * @fp:\t\t\tpointer to fastpath\n * @init_params:\tpointer to parameters structure\n *\n * parameters configured:\n *      - HC configuration\n *      - Queue's CDU context\n */\nstatic void bnx2x_pf_q_prep_init(struct bnx2x *bp,\n\tstruct bnx2x_fastpath *fp, struct bnx2x_queue_init_params *init_params)\n{\n\tu8 cos;\n\tint cxt_index, cxt_offset;\n\n\t/* FCoE Queue uses Default SB, thus has no HC capabilities */\n\tif (!IS_FCOE_FP(fp)) {\n\t\t__set_bit(BNX2X_Q_FLG_HC, &init_params->rx.flags);\n\t\t__set_bit(BNX2X_Q_FLG_HC, &init_params->tx.flags);\n\n\t\t/* If HC is supported, enable host coalescing in the transition\n\t\t * to INIT state.\n\t\t */\n\t\t__set_bit(BNX2X_Q_FLG_HC_EN, &init_params->rx.flags);\n\t\t__set_bit(BNX2X_Q_FLG_HC_EN, &init_params->tx.flags);\n\n\t\t/* HC rate */\n\t\tinit_params->rx.hc_rate = bp->rx_ticks ?\n\t\t\t(1000000 / bp->rx_ticks) : 0;\n\t\tinit_params->tx.hc_rate = bp->tx_ticks ?\n\t\t\t(1000000 / bp->tx_ticks) : 0;\n\n\t\t/* FW SB ID */\n\t\tinit_params->rx.fw_sb_id = init_params->tx.fw_sb_id =\n\t\t\tfp->fw_sb_id;\n\n\t\t/*\n\t\t * CQ index among the SB indices: FCoE clients uses the default\n\t\t * SB, therefore it's different.\n\t\t */\n\t\tinit_params->rx.sb_cq_index = HC_INDEX_ETH_RX_CQ_CONS;\n\t\tinit_params->tx.sb_cq_index = HC_INDEX_ETH_FIRST_TX_CQ_CONS;\n\t}\n\n\t/* set maximum number of COSs supported by this queue */\n\tinit_params->max_cos = fp->max_cos;\n\n\tDP(NETIF_MSG_IFUP, \"fp: %d setting queue params max cos to: %d\\n\",\n\t    fp->index, init_params->max_cos);\n\n\t/* set the context pointers queue object */\n\tfor (cos = FIRST_TX_COS_INDEX; cos < init_params->max_cos; cos++) {\n\t\tcxt_index = fp->txdata_ptr[cos]->cid / ILT_PAGE_CIDS;\n\t\tcxt_offset = fp->txdata_ptr[cos]->cid - (cxt_index *\n\t\t\t\tILT_PAGE_CIDS);\n\t\tinit_params->cxts[cos] =\n\t\t\t&bp->context[cxt_index].vcxt[cxt_offset].eth;\n\t}\n}\n\nstatic int bnx2x_setup_tx_only(struct bnx2x *bp, struct bnx2x_fastpath *fp,\n\t\t\tstruct bnx2x_queue_state_params *q_params,\n\t\t\tstruct bnx2x_queue_setup_tx_only_params *tx_only_params,\n\t\t\tint tx_index, bool leading)\n{\n\tmemset(tx_only_params, 0, sizeof(*tx_only_params));\n\n\t/* Set the command */\n\tq_params->cmd = BNX2X_Q_CMD_SETUP_TX_ONLY;\n\n\t/* Set tx-only QUEUE flags: don't zero statistics */\n\ttx_only_params->flags = bnx2x_get_common_flags(bp, fp, false);\n\n\t/* choose the index of the cid to send the slow path on */\n\ttx_only_params->cid_index = tx_index;\n\n\t/* Set general TX_ONLY_SETUP parameters */\n\tbnx2x_pf_q_prep_general(bp, fp, &tx_only_params->gen_params, tx_index);\n\n\t/* Set Tx TX_ONLY_SETUP parameters */\n\tbnx2x_pf_tx_q_prep(bp, fp, &tx_only_params->txq_params, tx_index);\n\n\tDP(NETIF_MSG_IFUP,\n\t   \"preparing to send tx-only ramrod for connection: cos %d, primary cid %d, cid %d, client id %d, sp-client id %d, flags %lx\\n\",\n\t   tx_index, q_params->q_obj->cids[FIRST_TX_COS_INDEX],\n\t   q_params->q_obj->cids[tx_index], q_params->q_obj->cl_id,\n\t   tx_only_params->gen_params.spcl_id, tx_only_params->flags);\n\n\t/* send the ramrod */\n\treturn bnx2x_queue_state_change(bp, q_params);\n}\n\n/**\n * bnx2x_setup_queue - setup queue\n *\n * @bp:\t\tdriver handle\n * @fp:\t\tpointer to fastpath\n * @leading:\tis leading\n *\n * This function performs 2 steps in a Queue state machine\n *      actually: 1) RESET->INIT 2) INIT->SETUP\n */\n\nint bnx2x_setup_queue(struct bnx2x *bp, struct bnx2x_fastpath *fp,\n\t\t       bool leading)\n{\n\tstruct bnx2x_queue_state_params q_params = {NULL};\n\tstruct bnx2x_queue_setup_params *setup_params =\n\t\t\t\t\t\t&q_params.params.setup;\n\tstruct bnx2x_queue_setup_tx_only_params *tx_only_params =\n\t\t\t\t\t\t&q_params.params.tx_only;\n\tint rc;\n\tu8 tx_index;\n\n\tDP(NETIF_MSG_IFUP, \"setting up queue %d\\n\", fp->index);\n\n\t/* reset IGU state skip FCoE L2 queue */\n\tif (!IS_FCOE_FP(fp))\n\t\tbnx2x_ack_sb(bp, fp->igu_sb_id, USTORM_ID, 0,\n\t\t\t     IGU_INT_ENABLE, 0);\n\n\tq_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\n\t/* We want to wait for completion in this context */\n\t__set_bit(RAMROD_COMP_WAIT, &q_params.ramrod_flags);\n\n\t/* Prepare the INIT parameters */\n\tbnx2x_pf_q_prep_init(bp, fp, &q_params.params.init);\n\n\t/* Set the command */\n\tq_params.cmd = BNX2X_Q_CMD_INIT;\n\n\t/* Change the state to INIT */\n\trc = bnx2x_queue_state_change(bp, &q_params);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Queue(%d) INIT failed\\n\", fp->index);\n\t\treturn rc;\n\t}\n\n\tDP(NETIF_MSG_IFUP, \"init complete\\n\");\n\n\t/* Now move the Queue to the SETUP state... */\n\tmemset(setup_params, 0, sizeof(*setup_params));\n\n\t/* Set QUEUE flags */\n\tsetup_params->flags = bnx2x_get_q_flags(bp, fp, leading);\n\n\t/* Set general SETUP parameters */\n\tbnx2x_pf_q_prep_general(bp, fp, &setup_params->gen_params,\n\t\t\t\tFIRST_TX_COS_INDEX);\n\n\tbnx2x_pf_rx_q_prep(bp, fp, &setup_params->pause_params,\n\t\t\t    &setup_params->rxq_params);\n\n\tbnx2x_pf_tx_q_prep(bp, fp, &setup_params->txq_params,\n\t\t\t   FIRST_TX_COS_INDEX);\n\n\t/* Set the command */\n\tq_params.cmd = BNX2X_Q_CMD_SETUP;\n\n\tif (IS_FCOE_FP(fp))\n\t\tbp->fcoe_init = true;\n\n\t/* Change the state to SETUP */\n\trc = bnx2x_queue_state_change(bp, &q_params);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Queue(%d) SETUP failed\\n\", fp->index);\n\t\treturn rc;\n\t}\n\n\t/* loop through the relevant tx-only indices */\n\tfor (tx_index = FIRST_TX_ONLY_COS_INDEX;\n\t      tx_index < fp->max_cos;\n\t      tx_index++) {\n\n\t\t/* prepare and send tx-only ramrod*/\n\t\trc = bnx2x_setup_tx_only(bp, fp, &q_params,\n\t\t\t\t\t  tx_only_params, tx_index, leading);\n\t\tif (rc) {\n\t\t\tBNX2X_ERR(\"Queue(%d.%d) TX_ONLY_SETUP failed\\n\",\n\t\t\t\t  fp->index, tx_index);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int bnx2x_stop_queue(struct bnx2x *bp, int index)\n{\n\tstruct bnx2x_fastpath *fp = &bp->fp[index];\n\tstruct bnx2x_fp_txdata *txdata;\n\tstruct bnx2x_queue_state_params q_params = {NULL};\n\tint rc, tx_index;\n\n\tDP(NETIF_MSG_IFDOWN, \"stopping queue %d cid %d\\n\", index, fp->cid);\n\n\tq_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\n\t/* We want to wait for completion in this context */\n\t__set_bit(RAMROD_COMP_WAIT, &q_params.ramrod_flags);\n\n\t/* close tx-only connections */\n\tfor (tx_index = FIRST_TX_ONLY_COS_INDEX;\n\t     tx_index < fp->max_cos;\n\t     tx_index++){\n\n\t\t/* ascertain this is a normal queue*/\n\t\ttxdata = fp->txdata_ptr[tx_index];\n\n\t\tDP(NETIF_MSG_IFDOWN, \"stopping tx-only queue %d\\n\",\n\t\t\t\t\t\t\ttxdata->txq_index);\n\n\t\t/* send halt terminate on tx-only connection */\n\t\tq_params.cmd = BNX2X_Q_CMD_TERMINATE;\n\t\tmemset(&q_params.params.terminate, 0,\n\t\t       sizeof(q_params.params.terminate));\n\t\tq_params.params.terminate.cid_index = tx_index;\n\n\t\trc = bnx2x_queue_state_change(bp, &q_params);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* send halt terminate on tx-only connection */\n\t\tq_params.cmd = BNX2X_Q_CMD_CFC_DEL;\n\t\tmemset(&q_params.params.cfc_del, 0,\n\t\t       sizeof(q_params.params.cfc_del));\n\t\tq_params.params.cfc_del.cid_index = tx_index;\n\t\trc = bnx2x_queue_state_change(bp, &q_params);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\t/* Stop the primary connection: */\n\t/* ...halt the connection */\n\tq_params.cmd = BNX2X_Q_CMD_HALT;\n\trc = bnx2x_queue_state_change(bp, &q_params);\n\tif (rc)\n\t\treturn rc;\n\n\t/* ...terminate the connection */\n\tq_params.cmd = BNX2X_Q_CMD_TERMINATE;\n\tmemset(&q_params.params.terminate, 0,\n\t       sizeof(q_params.params.terminate));\n\tq_params.params.terminate.cid_index = FIRST_TX_COS_INDEX;\n\trc = bnx2x_queue_state_change(bp, &q_params);\n\tif (rc)\n\t\treturn rc;\n\t/* ...delete cfc entry */\n\tq_params.cmd = BNX2X_Q_CMD_CFC_DEL;\n\tmemset(&q_params.params.cfc_del, 0,\n\t       sizeof(q_params.params.cfc_del));\n\tq_params.params.cfc_del.cid_index = FIRST_TX_COS_INDEX;\n\treturn bnx2x_queue_state_change(bp, &q_params);\n}\n\nstatic void bnx2x_reset_func(struct bnx2x *bp)\n{\n\tint port = BP_PORT(bp);\n\tint func = BP_FUNC(bp);\n\tint i;\n\n\t/* Disable the function in the FW */\n\tREG_WR8(bp, BAR_XSTRORM_INTMEM + XSTORM_FUNC_EN_OFFSET(func), 0);\n\tREG_WR8(bp, BAR_CSTRORM_INTMEM + CSTORM_FUNC_EN_OFFSET(func), 0);\n\tREG_WR8(bp, BAR_TSTRORM_INTMEM + TSTORM_FUNC_EN_OFFSET(func), 0);\n\tREG_WR8(bp, BAR_USTRORM_INTMEM + USTORM_FUNC_EN_OFFSET(func), 0);\n\n\t/* FP SBs */\n\tfor_each_eth_queue(bp, i) {\n\t\tstruct bnx2x_fastpath *fp = &bp->fp[i];\n\t\tREG_WR8(bp, BAR_CSTRORM_INTMEM +\n\t\t\t   CSTORM_STATUS_BLOCK_DATA_STATE_OFFSET(fp->fw_sb_id),\n\t\t\t   SB_DISABLED);\n\t}\n\n\tif (CNIC_LOADED(bp))\n\t\t/* CNIC SB */\n\t\tREG_WR8(bp, BAR_CSTRORM_INTMEM +\n\t\t\tCSTORM_STATUS_BLOCK_DATA_STATE_OFFSET\n\t\t\t(bnx2x_cnic_fw_sb_id(bp)), SB_DISABLED);\n\n\t/* SP SB */\n\tREG_WR8(bp, BAR_CSTRORM_INTMEM +\n\t\tCSTORM_SP_STATUS_BLOCK_DATA_STATE_OFFSET(func),\n\t\tSB_DISABLED);\n\n\tfor (i = 0; i < XSTORM_SPQ_DATA_SIZE / 4; i++)\n\t\tREG_WR(bp, BAR_XSTRORM_INTMEM + XSTORM_SPQ_DATA_OFFSET(func),\n\t\t       0);\n\n\t/* Configure IGU */\n\tif (bp->common.int_block == INT_BLOCK_HC) {\n\t\tREG_WR(bp, HC_REG_LEADING_EDGE_0 + port*8, 0);\n\t\tREG_WR(bp, HC_REG_TRAILING_EDGE_0 + port*8, 0);\n\t} else {\n\t\tREG_WR(bp, IGU_REG_LEADING_EDGE_LATCH, 0);\n\t\tREG_WR(bp, IGU_REG_TRAILING_EDGE_LATCH, 0);\n\t}\n\n\tif (CNIC_LOADED(bp)) {\n\t\t/* Disable Timer scan */\n\t\tREG_WR(bp, TM_REG_EN_LINEAR0_TIMER + port*4, 0);\n\t\t/*\n\t\t * Wait for at least 10ms and up to 2 second for the timers\n\t\t * scan to complete\n\t\t */\n\t\tfor (i = 0; i < 200; i++) {\n\t\t\tusleep_range(10000, 20000);\n\t\t\tif (!REG_RD(bp, TM_REG_LIN0_SCAN_ON + port*4))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Clear ILT */\n\tbnx2x_clear_func_ilt(bp, func);\n\n\t/* Timers workaround bug for E2: if this is vnic-3,\n\t * we need to set the entire ilt range for this timers.\n\t */\n\tif (!CHIP_IS_E1x(bp) && BP_VN(bp) == 3) {\n\t\tstruct ilt_client_info ilt_cli;\n\t\t/* use dummy TM client */\n\t\tmemset(&ilt_cli, 0, sizeof(struct ilt_client_info));\n\t\tilt_cli.start = 0;\n\t\tilt_cli.end = ILT_NUM_PAGE_ENTRIES - 1;\n\t\tilt_cli.client_num = ILT_CLIENT_TM;\n\n\t\tbnx2x_ilt_boundry_init_op(bp, &ilt_cli, 0, INITOP_CLEAR);\n\t}\n\n\t/* this assumes that reset_port() called before reset_func()*/\n\tif (!CHIP_IS_E1x(bp))\n\t\tbnx2x_pf_disable(bp);\n\n\tbp->dmae_ready = 0;\n}\n\nstatic void bnx2x_reset_port(struct bnx2x *bp)\n{\n\tint port = BP_PORT(bp);\n\tu32 val;\n\n\t/* Reset physical Link */\n\tbnx2x__link_reset(bp);\n\n\tREG_WR(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4, 0);\n\n\t/* Do not rcv packets to BRB */\n\tREG_WR(bp, NIG_REG_LLH0_BRB1_DRV_MASK + port*4, 0x0);\n\t/* Do not direct rcv packets that are not for MCP to the BRB */\n\tREG_WR(bp, (port ? NIG_REG_LLH1_BRB1_NOT_MCP :\n\t\t\t   NIG_REG_LLH0_BRB1_NOT_MCP), 0x0);\n\n\t/* Configure AEU */\n\tREG_WR(bp, MISC_REG_AEU_MASK_ATTN_FUNC_0 + port*4, 0);\n\n\tmsleep(100);\n\t/* Check for BRB port occupancy */\n\tval = REG_RD(bp, BRB1_REG_PORT_NUM_OCC_BLOCKS_0 + port*4);\n\tif (val)\n\t\tDP(NETIF_MSG_IFDOWN,\n\t\t   \"BRB1 is not empty  %d blocks are occupied\\n\", val);\n\n\t/* TODO: Close Doorbell port? */\n}\n\nstatic int bnx2x_reset_hw(struct bnx2x *bp, u32 load_code)\n{\n\tstruct bnx2x_func_state_params func_params = {NULL};\n\n\t/* Prepare parameters for function state transitions */\n\t__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\n\n\tfunc_params.f_obj = &bp->func_obj;\n\tfunc_params.cmd = BNX2X_F_CMD_HW_RESET;\n\n\tfunc_params.params.hw_init.load_phase = load_code;\n\n\treturn bnx2x_func_state_change(bp, &func_params);\n}\n\nstatic int bnx2x_func_stop(struct bnx2x *bp)\n{\n\tstruct bnx2x_func_state_params func_params = {NULL};\n\tint rc;\n\n\t/* Prepare parameters for function state transitions */\n\t__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\n\tfunc_params.f_obj = &bp->func_obj;\n\tfunc_params.cmd = BNX2X_F_CMD_STOP;\n\n\t/*\n\t * Try to stop the function the 'good way'. If fails (in case\n\t * of a parity error during bnx2x_chip_cleanup()) and we are\n\t * not in a debug mode, perform a state transaction in order to\n\t * enable further HW_RESET transaction.\n\t */\n\trc = bnx2x_func_state_change(bp, &func_params);\n\tif (rc) {\n#ifdef BNX2X_STOP_ON_ERROR\n\t\treturn rc;\n#else\n\t\tBNX2X_ERR(\"FUNC_STOP ramrod failed. Running a dry transaction\\n\");\n\t\t__set_bit(RAMROD_DRV_CLR_ONLY, &func_params.ramrod_flags);\n\t\treturn bnx2x_func_state_change(bp, &func_params);\n#endif\n\t}\n\n\treturn 0;\n}\n\n/**\n * bnx2x_send_unload_req - request unload mode from the MCP.\n *\n * @bp:\t\t\tdriver handle\n * @unload_mode:\trequested function's unload mode\n *\n * Return unload mode returned by the MCP: COMMON, PORT or FUNC.\n */\nu32 bnx2x_send_unload_req(struct bnx2x *bp, int unload_mode)\n{\n\tu32 reset_code = 0;\n\tint port = BP_PORT(bp);\n\n\t/* Select the UNLOAD request mode */\n\tif (unload_mode == UNLOAD_NORMAL)\n\t\treset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS;\n\n\telse if (bp->flags & NO_WOL_FLAG)\n\t\treset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_MCP;\n\n\telse if (bp->wol) {\n\t\tu32 emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;\n\t\tu8 *mac_addr = bp->dev->dev_addr;\n\t\tstruct pci_dev *pdev = bp->pdev;\n\t\tu32 val;\n\t\tu16 pmc;\n\n\t\t/* The mac address is written to entries 1-4 to\n\t\t * preserve entry 0 which is used by the PMF\n\t\t */\n\t\tu8 entry = (BP_VN(bp) + 1)*8;\n\n\t\tval = (mac_addr[0] << 8) | mac_addr[1];\n\t\tEMAC_WR(bp, EMAC_REG_EMAC_MAC_MATCH + entry, val);\n\n\t\tval = (mac_addr[2] << 24) | (mac_addr[3] << 16) |\n\t\t      (mac_addr[4] << 8) | mac_addr[5];\n\t\tEMAC_WR(bp, EMAC_REG_EMAC_MAC_MATCH + entry + 4, val);\n\n\t\t/* Enable the PME and clear the status */\n\t\tpci_read_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, &pmc);\n\t\tpmc |= PCI_PM_CTRL_PME_ENABLE | PCI_PM_CTRL_PME_STATUS;\n\t\tpci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, pmc);\n\n\t\treset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_EN;\n\n\t} else\n\t\treset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS;\n\n\t/* Send the request to the MCP */\n\tif (!BP_NOMCP(bp))\n\t\treset_code = bnx2x_fw_command(bp, reset_code, 0);\n\telse {\n\t\tint path = BP_PATH(bp);\n\n\t\tDP(NETIF_MSG_IFDOWN, \"NO MCP - load counts[%d]      %d, %d, %d\\n\",\n\t\t   path, bnx2x_load_count[path][0], bnx2x_load_count[path][1],\n\t\t   bnx2x_load_count[path][2]);\n\t\tbnx2x_load_count[path][0]--;\n\t\tbnx2x_load_count[path][1 + port]--;\n\t\tDP(NETIF_MSG_IFDOWN, \"NO MCP - new load counts[%d]  %d, %d, %d\\n\",\n\t\t   path, bnx2x_load_count[path][0], bnx2x_load_count[path][1],\n\t\t   bnx2x_load_count[path][2]);\n\t\tif (bnx2x_load_count[path][0] == 0)\n\t\t\treset_code = FW_MSG_CODE_DRV_UNLOAD_COMMON;\n\t\telse if (bnx2x_load_count[path][1 + port] == 0)\n\t\t\treset_code = FW_MSG_CODE_DRV_UNLOAD_PORT;\n\t\telse\n\t\t\treset_code = FW_MSG_CODE_DRV_UNLOAD_FUNCTION;\n\t}\n\n\treturn reset_code;\n}\n\n/**\n * bnx2x_send_unload_done - send UNLOAD_DONE command to the MCP.\n *\n * @bp:\t\tdriver handle\n * @keep_link:\t\ttrue iff link should be kept up\n */\nvoid bnx2x_send_unload_done(struct bnx2x *bp, bool keep_link)\n{\n\tu32 reset_param = keep_link ? DRV_MSG_CODE_UNLOAD_SKIP_LINK_RESET : 0;\n\n\t/* Report UNLOAD_DONE to MCP */\n\tif (!BP_NOMCP(bp))\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_DONE, reset_param);\n}\n\nstatic int bnx2x_func_wait_started(struct bnx2x *bp)\n{\n\tint tout = 50;\n\tint msix = (bp->flags & USING_MSIX_FLAG) ? 1 : 0;\n\n\tif (!bp->port.pmf)\n\t\treturn 0;\n\n\t/*\n\t * (assumption: No Attention from MCP at this stage)\n\t * PMF probably in the middle of TX disable/enable transaction\n\t * 1. Sync IRS for default SB\n\t * 2. Sync SP queue - this guarantees us that attention handling started\n\t * 3. Wait, that TX disable/enable transaction completes\n\t *\n\t * 1+2 guarantee that if DCBx attention was scheduled it already changed\n\t * pending bit of transaction from STARTED-->TX_STOPPED, if we already\n\t * received completion for the transaction the state is TX_STOPPED.\n\t * State will return to STARTED after completion of TX_STOPPED-->STARTED\n\t * transaction.\n\t */\n\n\t/* make sure default SB ISR is done */\n\tif (msix)\n\t\tsynchronize_irq(bp->msix_table[0].vector);\n\telse\n\t\tsynchronize_irq(bp->pdev->irq);\n\n\tflush_workqueue(bnx2x_wq);\n\tflush_workqueue(bnx2x_iov_wq);\n\n\twhile (bnx2x_func_get_state(bp, &bp->func_obj) !=\n\t\t\t\tBNX2X_F_STATE_STARTED && tout--)\n\t\tmsleep(20);\n\n\tif (bnx2x_func_get_state(bp, &bp->func_obj) !=\n\t\t\t\t\t\tBNX2X_F_STATE_STARTED) {\n#ifdef BNX2X_STOP_ON_ERROR\n\t\tBNX2X_ERR(\"Wrong function state\\n\");\n\t\treturn -EBUSY;\n#else\n\t\t/*\n\t\t * Failed to complete the transaction in a \"good way\"\n\t\t * Force both transactions with CLR bit\n\t\t */\n\t\tstruct bnx2x_func_state_params func_params = {NULL};\n\n\t\tDP(NETIF_MSG_IFDOWN,\n\t\t   \"Hmmm... Unexpected function state! Forcing STARTED-->TX_STOPPED-->STARTED\\n\");\n\n\t\tfunc_params.f_obj = &bp->func_obj;\n\t\t__set_bit(RAMROD_DRV_CLR_ONLY,\n\t\t\t\t\t&func_params.ramrod_flags);\n\n\t\t/* STARTED-->TX_ST0PPED */\n\t\tfunc_params.cmd = BNX2X_F_CMD_TX_STOP;\n\t\tbnx2x_func_state_change(bp, &func_params);\n\n\t\t/* TX_ST0PPED-->STARTED */\n\t\tfunc_params.cmd = BNX2X_F_CMD_TX_START;\n\t\treturn bnx2x_func_state_change(bp, &func_params);\n#endif\n\t}\n\n\treturn 0;\n}\n\nstatic void bnx2x_disable_ptp(struct bnx2x *bp)\n{\n\tint port = BP_PORT(bp);\n\n\t/* Disable sending PTP packets to host */\n\tREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_TO_HOST :\n\t       NIG_REG_P0_LLH_PTP_TO_HOST, 0x0);\n\n\t/* Reset PTP event detection rules */\n\tREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_PARAM_MASK :\n\t       NIG_REG_P0_LLH_PTP_PARAM_MASK, 0x7FF);\n\tREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_RULE_MASK :\n\t       NIG_REG_P0_LLH_PTP_RULE_MASK, 0x3FFF);\n\tREG_WR(bp, port ? NIG_REG_P1_TLLH_PTP_PARAM_MASK :\n\t       NIG_REG_P0_TLLH_PTP_PARAM_MASK, 0x7FF);\n\tREG_WR(bp, port ? NIG_REG_P1_TLLH_PTP_RULE_MASK :\n\t       NIG_REG_P0_TLLH_PTP_RULE_MASK, 0x3FFF);\n\n\t/* Disable the PTP feature */\n\tREG_WR(bp, port ? NIG_REG_P1_PTP_EN :\n\t       NIG_REG_P0_PTP_EN, 0x0);\n}\n\n/* Called during unload, to stop PTP-related stuff */\nstatic void bnx2x_stop_ptp(struct bnx2x *bp)\n{\n\t/* Cancel PTP work queue. Should be done after the Tx queues are\n\t * drained to prevent additional scheduling.\n\t */\n\tcancel_work_sync(&bp->ptp_task);\n\n\tif (bp->ptp_tx_skb) {\n\t\tdev_kfree_skb_any(bp->ptp_tx_skb);\n\t\tbp->ptp_tx_skb = NULL;\n\t}\n\n\t/* Disable PTP in HW */\n\tbnx2x_disable_ptp(bp);\n\n\tDP(BNX2X_MSG_PTP, \"PTP stop ended successfully\\n\");\n}\n\nvoid bnx2x_chip_cleanup(struct bnx2x *bp, int unload_mode, bool keep_link)\n{\n\tint port = BP_PORT(bp);\n\tint i, rc = 0;\n\tu8 cos;\n\tstruct bnx2x_mcast_ramrod_params rparam = {NULL};\n\tu32 reset_code;\n\n\t/* Wait until tx fastpath tasks complete */\n\tfor_each_tx_queue(bp, i) {\n\t\tstruct bnx2x_fastpath *fp = &bp->fp[i];\n\n\t\tfor_each_cos_in_tx_queue(fp, cos)\n\t\t\trc = bnx2x_clean_tx_queue(bp, fp->txdata_ptr[cos]);\n#ifdef BNX2X_STOP_ON_ERROR\n\t\tif (rc)\n\t\t\treturn;\n#endif\n\t}\n\n\t/* Give HW time to discard old tx messages */\n\tusleep_range(1000, 2000);\n\n\t/* Clean all ETH MACs */\n\trc = bnx2x_del_all_macs(bp, &bp->sp_objs[0].mac_obj, BNX2X_ETH_MAC,\n\t\t\t\tfalse);\n\tif (rc < 0)\n\t\tBNX2X_ERR(\"Failed to delete all ETH macs: %d\\n\", rc);\n\n\t/* Clean up UC list  */\n\trc = bnx2x_del_all_macs(bp, &bp->sp_objs[0].mac_obj, BNX2X_UC_LIST_MAC,\n\t\t\t\ttrue);\n\tif (rc < 0)\n\t\tBNX2X_ERR(\"Failed to schedule DEL commands for UC MACs list: %d\\n\",\n\t\t\t  rc);\n\n\t/* The whole *vlan_obj structure may be not initialized if VLAN\n\t * filtering offload is not supported by hardware. Currently this is\n\t * true for all hardware covered by CHIP_IS_E1x().\n\t */\n\tif (!CHIP_IS_E1x(bp)) {\n\t\t/* Remove all currently configured VLANs */\n\t\trc = bnx2x_del_all_vlans(bp);\n\t\tif (rc < 0)\n\t\t\tBNX2X_ERR(\"Failed to delete all VLANs\\n\");\n\t}\n\n\t/* Disable LLH */\n\tif (!CHIP_IS_E1(bp))\n\t\tREG_WR(bp, NIG_REG_LLH0_FUNC_EN + port*8, 0);\n\n\t/* Set \"drop all\" (stop Rx).\n\t * We need to take a netif_addr_lock() here in order to prevent\n\t * a race between the completion code and this code.\n\t */\n\tnetif_addr_lock_bh(bp->dev);\n\t/* Schedule the rx_mode command */\n\tif (test_bit(BNX2X_FILTER_RX_MODE_PENDING, &bp->sp_state))\n\t\tset_bit(BNX2X_FILTER_RX_MODE_SCHED, &bp->sp_state);\n\telse if (bp->slowpath)\n\t\tbnx2x_set_storm_rx_mode(bp);\n\n\t/* Cleanup multicast configuration */\n\trparam.mcast_obj = &bp->mcast_obj;\n\trc = bnx2x_config_mcast(bp, &rparam, BNX2X_MCAST_CMD_DEL);\n\tif (rc < 0)\n\t\tBNX2X_ERR(\"Failed to send DEL multicast command: %d\\n\", rc);\n\n\tnetif_addr_unlock_bh(bp->dev);\n\n\tbnx2x_iov_chip_cleanup(bp);\n\n\t/*\n\t * Send the UNLOAD_REQUEST to the MCP. This will return if\n\t * this function should perform FUNC, PORT or COMMON HW\n\t * reset.\n\t */\n\treset_code = bnx2x_send_unload_req(bp, unload_mode);\n\n\t/*\n\t * (assumption: No Attention from MCP at this stage)\n\t * PMF probably in the middle of TX disable/enable transaction\n\t */\n\trc = bnx2x_func_wait_started(bp);\n\tif (rc) {\n\t\tBNX2X_ERR(\"bnx2x_func_wait_started failed\\n\");\n#ifdef BNX2X_STOP_ON_ERROR\n\t\treturn;\n#endif\n\t}\n\n\t/* Close multi and leading connections\n\t * Completions for ramrods are collected in a synchronous way\n\t */\n\tfor_each_eth_queue(bp, i)\n\t\tif (bnx2x_stop_queue(bp, i))\n#ifdef BNX2X_STOP_ON_ERROR\n\t\t\treturn;\n#else\n\t\t\tgoto unload_error;\n#endif\n\n\tif (CNIC_LOADED(bp)) {\n\t\tfor_each_cnic_queue(bp, i)\n\t\t\tif (bnx2x_stop_queue(bp, i))\n#ifdef BNX2X_STOP_ON_ERROR\n\t\t\t\treturn;\n#else\n\t\t\t\tgoto unload_error;\n#endif\n\t}\n\n\t/* If SP settings didn't get completed so far - something\n\t * very wrong has happen.\n\t */\n\tif (!bnx2x_wait_sp_comp(bp, ~0x0UL))\n\t\tBNX2X_ERR(\"Hmmm... Common slow path ramrods got stuck!\\n\");\n\n#ifndef BNX2X_STOP_ON_ERROR\nunload_error:\n#endif\n\trc = bnx2x_func_stop(bp);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Function stop failed!\\n\");\n#ifdef BNX2X_STOP_ON_ERROR\n\t\treturn;\n#endif\n\t}\n\n\t/* stop_ptp should be after the Tx queues are drained to prevent\n\t * scheduling to the cancelled PTP work queue. It should also be after\n\t * function stop ramrod is sent, since as part of this ramrod FW access\n\t * PTP registers.\n\t */\n\tif (bp->flags & PTP_SUPPORTED) {\n\t\tbnx2x_stop_ptp(bp);\n\t\tif (bp->ptp_clock) {\n\t\t\tptp_clock_unregister(bp->ptp_clock);\n\t\t\tbp->ptp_clock = NULL;\n\t\t}\n\t}\n\n\t/* Disable HW interrupts, NAPI */\n\tbnx2x_netif_stop(bp, 1);\n\t/* Delete all NAPI objects */\n\tbnx2x_del_all_napi(bp);\n\tif (CNIC_LOADED(bp))\n\t\tbnx2x_del_all_napi_cnic(bp);\n\n\t/* Release IRQs */\n\tbnx2x_free_irq(bp);\n\n\t/* Reset the chip, unless PCI function is offline. If we reach this\n\t * point following a PCI error handling, it means device is really\n\t * in a bad state and we're about to remove it, so reset the chip\n\t * is not a good idea.\n\t */\n\tif (!pci_channel_offline(bp->pdev)) {\n\t\trc = bnx2x_reset_hw(bp, reset_code);\n\t\tif (rc)\n\t\t\tBNX2X_ERR(\"HW_RESET failed\\n\");\n\t}\n\n\t/* Report UNLOAD_DONE to MCP */\n\tbnx2x_send_unload_done(bp, keep_link);\n}\n\nvoid bnx2x_disable_close_the_gate(struct bnx2x *bp)\n{\n\tu32 val;\n\n\tDP(NETIF_MSG_IFDOWN, \"Disabling \\\"close the gates\\\"\\n\");\n\n\tif (CHIP_IS_E1(bp)) {\n\t\tint port = BP_PORT(bp);\n\t\tu32 addr = port ? MISC_REG_AEU_MASK_ATTN_FUNC_1 :\n\t\t\tMISC_REG_AEU_MASK_ATTN_FUNC_0;\n\n\t\tval = REG_RD(bp, addr);\n\t\tval &= ~(0x300);\n\t\tREG_WR(bp, addr, val);\n\t} else {\n\t\tval = REG_RD(bp, MISC_REG_AEU_GENERAL_MASK);\n\t\tval &= ~(MISC_AEU_GENERAL_MASK_REG_AEU_PXP_CLOSE_MASK |\n\t\t\t MISC_AEU_GENERAL_MASK_REG_AEU_NIG_CLOSE_MASK);\n\t\tREG_WR(bp, MISC_REG_AEU_GENERAL_MASK, val);\n\t}\n}\n\n/* Close gates #2, #3 and #4: */\nstatic void bnx2x_set_234_gates(struct bnx2x *bp, bool close)\n{\n\tu32 val;\n\n\t/* Gates #2 and #4a are closed/opened for \"not E1\" only */\n\tif (!CHIP_IS_E1(bp)) {\n\t\t/* #4 */\n\t\tREG_WR(bp, PXP_REG_HST_DISCARD_DOORBELLS, !!close);\n\t\t/* #2 */\n\t\tREG_WR(bp, PXP_REG_HST_DISCARD_INTERNAL_WRITES, !!close);\n\t}\n\n\t/* #3 */\n\tif (CHIP_IS_E1x(bp)) {\n\t\t/* Prevent interrupts from HC on both ports */\n\t\tval = REG_RD(bp, HC_REG_CONFIG_1);\n\t\tREG_WR(bp, HC_REG_CONFIG_1,\n\t\t       (!close) ? (val | HC_CONFIG_1_REG_BLOCK_DISABLE_1) :\n\t\t       (val & ~(u32)HC_CONFIG_1_REG_BLOCK_DISABLE_1));\n\n\t\tval = REG_RD(bp, HC_REG_CONFIG_0);\n\t\tREG_WR(bp, HC_REG_CONFIG_0,\n\t\t       (!close) ? (val | HC_CONFIG_0_REG_BLOCK_DISABLE_0) :\n\t\t       (val & ~(u32)HC_CONFIG_0_REG_BLOCK_DISABLE_0));\n\t} else {\n\t\t/* Prevent incoming interrupts in IGU */\n\t\tval = REG_RD(bp, IGU_REG_BLOCK_CONFIGURATION);\n\n\t\tREG_WR(bp, IGU_REG_BLOCK_CONFIGURATION,\n\t\t       (!close) ?\n\t\t       (val | IGU_BLOCK_CONFIGURATION_REG_BLOCK_ENABLE) :\n\t\t       (val & ~(u32)IGU_BLOCK_CONFIGURATION_REG_BLOCK_ENABLE));\n\t}\n\n\tDP(NETIF_MSG_HW | NETIF_MSG_IFUP, \"%s gates #2, #3 and #4\\n\",\n\t\tclose ? \"closing\" : \"opening\");\n}\n\n#define SHARED_MF_CLP_MAGIC  0x80000000 /* `magic' bit */\n\nstatic void bnx2x_clp_reset_prep(struct bnx2x *bp, u32 *magic_val)\n{\n\t/* Do some magic... */\n\tu32 val = MF_CFG_RD(bp, shared_mf_config.clp_mb);\n\t*magic_val = val & SHARED_MF_CLP_MAGIC;\n\tMF_CFG_WR(bp, shared_mf_config.clp_mb, val | SHARED_MF_CLP_MAGIC);\n}\n\n/**\n * bnx2x_clp_reset_done - restore the value of the `magic' bit.\n *\n * @bp:\t\tdriver handle\n * @magic_val:\told value of the `magic' bit.\n */\nstatic void bnx2x_clp_reset_done(struct bnx2x *bp, u32 magic_val)\n{\n\t/* Restore the `magic' bit value... */\n\tu32 val = MF_CFG_RD(bp, shared_mf_config.clp_mb);\n\tMF_CFG_WR(bp, shared_mf_config.clp_mb,\n\t\t(val & (~SHARED_MF_CLP_MAGIC)) | magic_val);\n}\n\n/**\n * bnx2x_reset_mcp_prep - prepare for MCP reset.\n *\n * @bp:\t\tdriver handle\n * @magic_val:\told value of 'magic' bit.\n *\n * Takes care of CLP configurations.\n */\nstatic void bnx2x_reset_mcp_prep(struct bnx2x *bp, u32 *magic_val)\n{\n\tu32 shmem;\n\tu32 validity_offset;\n\n\tDP(NETIF_MSG_HW | NETIF_MSG_IFUP, \"Starting\\n\");\n\n\t/* Set `magic' bit in order to save MF config */\n\tif (!CHIP_IS_E1(bp))\n\t\tbnx2x_clp_reset_prep(bp, magic_val);\n\n\t/* Get shmem offset */\n\tshmem = REG_RD(bp, MISC_REG_SHARED_MEM_ADDR);\n\tvalidity_offset =\n\t\toffsetof(struct shmem_region, validity_map[BP_PORT(bp)]);\n\n\t/* Clear validity map flags */\n\tif (shmem > 0)\n\t\tREG_WR(bp, shmem + validity_offset, 0);\n}\n\n#define MCP_TIMEOUT      5000   /* 5 seconds (in ms) */\n#define MCP_ONE_TIMEOUT  100    /* 100 ms */\n\n/**\n * bnx2x_mcp_wait_one - wait for MCP_ONE_TIMEOUT\n *\n * @bp:\tdriver handle\n */\nstatic void bnx2x_mcp_wait_one(struct bnx2x *bp)\n{\n\t/* special handling for emulation and FPGA,\n\t   wait 10 times longer */\n\tif (CHIP_REV_IS_SLOW(bp))\n\t\tmsleep(MCP_ONE_TIMEOUT*10);\n\telse\n\t\tmsleep(MCP_ONE_TIMEOUT);\n}\n\n/*\n * initializes bp->common.shmem_base and waits for validity signature to appear\n */\nstatic int bnx2x_init_shmem(struct bnx2x *bp)\n{\n\tint cnt = 0;\n\tu32 val = 0;\n\n\tdo {\n\t\tbp->common.shmem_base = REG_RD(bp, MISC_REG_SHARED_MEM_ADDR);\n\n\t\t/* If we read all 0xFFs, means we are in PCI error state and\n\t\t * should bail out to avoid crashes on adapter's FW reads.\n\t\t */\n\t\tif (bp->common.shmem_base == 0xFFFFFFFF) {\n\t\t\tbp->flags |= NO_MCP_FLAG;\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (bp->common.shmem_base) {\n\t\t\tval = SHMEM_RD(bp, validity_map[BP_PORT(bp)]);\n\t\t\tif (val & SHR_MEM_VALIDITY_MB)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tbnx2x_mcp_wait_one(bp);\n\n\t} while (cnt++ < (MCP_TIMEOUT / MCP_ONE_TIMEOUT));\n\n\tBNX2X_ERR(\"BAD MCP validity signature\\n\");\n\n\treturn -ENODEV;\n}\n\nstatic int bnx2x_reset_mcp_comp(struct bnx2x *bp, u32 magic_val)\n{\n\tint rc = bnx2x_init_shmem(bp);\n\n\t/* Restore the `magic' bit value */\n\tif (!CHIP_IS_E1(bp))\n\t\tbnx2x_clp_reset_done(bp, magic_val);\n\n\treturn rc;\n}\n\nstatic void bnx2x_pxp_prep(struct bnx2x *bp)\n{\n\tif (!CHIP_IS_E1(bp)) {\n\t\tREG_WR(bp, PXP2_REG_RD_START_INIT, 0);\n\t\tREG_WR(bp, PXP2_REG_RQ_RBC_DONE, 0);\n\t}\n}\n\n/*\n * Reset the whole chip except for:\n *      - PCIE core\n *      - PCI Glue, PSWHST, PXP/PXP2 RF (all controlled by\n *              one reset bit)\n *      - IGU\n *      - MISC (including AEU)\n *      - GRC\n *      - RBCN, RBCP\n */\nstatic void bnx2x_process_kill_chip_reset(struct bnx2x *bp, bool global)\n{\n\tu32 not_reset_mask1, reset_mask1, not_reset_mask2, reset_mask2;\n\tu32 global_bits2, stay_reset2;\n\n\t/*\n\t * Bits that have to be set in reset_mask2 if we want to reset 'global'\n\t * (per chip) blocks.\n\t */\n\tglobal_bits2 =\n\t\tMISC_REGISTERS_RESET_REG_2_RST_MCP_N_RESET_CMN_CPU |\n\t\tMISC_REGISTERS_RESET_REG_2_RST_MCP_N_RESET_CMN_CORE;\n\n\t/* Don't reset the following blocks.\n\t * Important: per port blocks (such as EMAC, BMAC, UMAC) can't be\n\t *            reset, as in 4 port device they might still be owned\n\t *            by the MCP (there is only one leader per path).\n\t */\n\tnot_reset_mask1 =\n\t\tMISC_REGISTERS_RESET_REG_1_RST_HC |\n\t\tMISC_REGISTERS_RESET_REG_1_RST_PXPV |\n\t\tMISC_REGISTERS_RESET_REG_1_RST_PXP;\n\n\tnot_reset_mask2 =\n\t\tMISC_REGISTERS_RESET_REG_2_RST_PCI_MDIO |\n\t\tMISC_REGISTERS_RESET_REG_2_RST_EMAC0_HARD_CORE |\n\t\tMISC_REGISTERS_RESET_REG_2_RST_EMAC1_HARD_CORE |\n\t\tMISC_REGISTERS_RESET_REG_2_RST_MISC_CORE |\n\t\tMISC_REGISTERS_RESET_REG_2_RST_RBCN |\n\t\tMISC_REGISTERS_RESET_REG_2_RST_GRC  |\n\t\tMISC_REGISTERS_RESET_REG_2_RST_MCP_N_RESET_REG_HARD_CORE |\n\t\tMISC_REGISTERS_RESET_REG_2_RST_MCP_N_HARD_CORE_RST_B |\n\t\tMISC_REGISTERS_RESET_REG_2_RST_ATC |\n\t\tMISC_REGISTERS_RESET_REG_2_PGLC |\n\t\tMISC_REGISTERS_RESET_REG_2_RST_BMAC0 |\n\t\tMISC_REGISTERS_RESET_REG_2_RST_BMAC1 |\n\t\tMISC_REGISTERS_RESET_REG_2_RST_EMAC0 |\n\t\tMISC_REGISTERS_RESET_REG_2_RST_EMAC1 |\n\t\tMISC_REGISTERS_RESET_REG_2_UMAC0 |\n\t\tMISC_REGISTERS_RESET_REG_2_UMAC1;\n\n\t/*\n\t * Keep the following blocks in reset:\n\t *  - all xxMACs are handled by the bnx2x_link code.\n\t */\n\tstay_reset2 =\n\t\tMISC_REGISTERS_RESET_REG_2_XMAC |\n\t\tMISC_REGISTERS_RESET_REG_2_XMAC_SOFT;\n\n\t/* Full reset masks according to the chip */\n\treset_mask1 = 0xffffffff;\n\n\tif (CHIP_IS_E1(bp))\n\t\treset_mask2 = 0xffff;\n\telse if (CHIP_IS_E1H(bp))\n\t\treset_mask2 = 0x1ffff;\n\telse if (CHIP_IS_E2(bp))\n\t\treset_mask2 = 0xfffff;\n\telse /* CHIP_IS_E3 */\n\t\treset_mask2 = 0x3ffffff;\n\n\t/* Don't reset global blocks unless we need to */\n\tif (!global)\n\t\treset_mask2 &= ~global_bits2;\n\n\t/*\n\t * In case of attention in the QM, we need to reset PXP\n\t * (MISC_REGISTERS_RESET_REG_2_RST_PXP_RQ_RD_WR) before QM\n\t * because otherwise QM reset would release 'close the gates' shortly\n\t * before resetting the PXP, then the PSWRQ would send a write\n\t * request to PGLUE. Then when PXP is reset, PGLUE would try to\n\t * read the payload data from PSWWR, but PSWWR would not\n\t * respond. The write queue in PGLUE would stuck, dmae commands\n\t * would not return. Therefore it's important to reset the second\n\t * reset register (containing the\n\t * MISC_REGISTERS_RESET_REG_2_RST_PXP_RQ_RD_WR bit) before the\n\t * first one (containing the MISC_REGISTERS_RESET_REG_1_RST_QM\n\t * bit).\n\t */\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\n\t       reset_mask2 & (~not_reset_mask2));\n\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_CLEAR,\n\t       reset_mask1 & (~not_reset_mask1));\n\n\tbarrier();\n\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,\n\t       reset_mask2 & (~stay_reset2));\n\n\tbarrier();\n\n\tREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_SET, reset_mask1);\n}\n\n/**\n * bnx2x_er_poll_igu_vq - poll for pending writes bit.\n * It should get cleared in no more than 1s.\n *\n * @bp:\tdriver handle\n *\n * It should get cleared in no more than 1s. Returns 0 if\n * pending writes bit gets cleared.\n */\nstatic int bnx2x_er_poll_igu_vq(struct bnx2x *bp)\n{\n\tu32 cnt = 1000;\n\tu32 pend_bits = 0;\n\n\tdo {\n\t\tpend_bits  = REG_RD(bp, IGU_REG_PENDING_BITS_STATUS);\n\n\t\tif (pend_bits == 0)\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 2000);\n\t} while (cnt-- > 0);\n\n\tif (cnt <= 0) {\n\t\tBNX2X_ERR(\"Still pending IGU requests pend_bits=%x!\\n\",\n\t\t\t  pend_bits);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int bnx2x_process_kill(struct bnx2x *bp, bool global)\n{\n\tint cnt = 1000;\n\tu32 val = 0;\n\tu32 sr_cnt, blk_cnt, port_is_idle_0, port_is_idle_1, pgl_exp_rom2;\n\tu32 tags_63_32 = 0;\n\n\t/* Empty the Tetris buffer, wait for 1s */\n\tdo {\n\t\tsr_cnt  = REG_RD(bp, PXP2_REG_RD_SR_CNT);\n\t\tblk_cnt = REG_RD(bp, PXP2_REG_RD_BLK_CNT);\n\t\tport_is_idle_0 = REG_RD(bp, PXP2_REG_RD_PORT_IS_IDLE_0);\n\t\tport_is_idle_1 = REG_RD(bp, PXP2_REG_RD_PORT_IS_IDLE_1);\n\t\tpgl_exp_rom2 = REG_RD(bp, PXP2_REG_PGL_EXP_ROM2);\n\t\tif (CHIP_IS_E3(bp))\n\t\t\ttags_63_32 = REG_RD(bp, PGLUE_B_REG_TAGS_63_32);\n\n\t\tif ((sr_cnt == 0x7e) && (blk_cnt == 0xa0) &&\n\t\t    ((port_is_idle_0 & 0x1) == 0x1) &&\n\t\t    ((port_is_idle_1 & 0x1) == 0x1) &&\n\t\t    (pgl_exp_rom2 == 0xffffffff) &&\n\t\t    (!CHIP_IS_E3(bp) || (tags_63_32 == 0xffffffff)))\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t} while (cnt-- > 0);\n\n\tif (cnt <= 0) {\n\t\tBNX2X_ERR(\"Tetris buffer didn't get empty or there are still outstanding read requests after 1s!\\n\");\n\t\tBNX2X_ERR(\"sr_cnt=0x%08x, blk_cnt=0x%08x, port_is_idle_0=0x%08x, port_is_idle_1=0x%08x, pgl_exp_rom2=0x%08x\\n\",\n\t\t\t  sr_cnt, blk_cnt, port_is_idle_0, port_is_idle_1,\n\t\t\t  pgl_exp_rom2);\n\t\treturn -EAGAIN;\n\t}\n\n\tbarrier();\n\n\t/* Close gates #2, #3 and #4 */\n\tbnx2x_set_234_gates(bp, true);\n\n\t/* Poll for IGU VQs for 57712 and newer chips */\n\tif (!CHIP_IS_E1x(bp) && bnx2x_er_poll_igu_vq(bp))\n\t\treturn -EAGAIN;\n\n\t/* TBD: Indicate that \"process kill\" is in progress to MCP */\n\n\t/* Clear \"unprepared\" bit */\n\tREG_WR(bp, MISC_REG_UNPREPARED, 0);\n\tbarrier();\n\n\t/* Wait for 1ms to empty GLUE and PCI-E core queues,\n\t * PSWHST, GRC and PSWRD Tetris buffer.\n\t */\n\tusleep_range(1000, 2000);\n\n\t/* Prepare to chip reset: */\n\t/* MCP */\n\tif (global)\n\t\tbnx2x_reset_mcp_prep(bp, &val);\n\n\t/* PXP */\n\tbnx2x_pxp_prep(bp);\n\tbarrier();\n\n\t/* reset the chip */\n\tbnx2x_process_kill_chip_reset(bp, global);\n\tbarrier();\n\n\t/* clear errors in PGB */\n\tif (!CHIP_IS_E1x(bp))\n\t\tREG_WR(bp, PGLUE_B_REG_LATCHED_ERRORS_CLR, 0x7f);\n\n\t/* Recover after reset: */\n\t/* MCP */\n\tif (global && bnx2x_reset_mcp_comp(bp, val))\n\t\treturn -EAGAIN;\n\n\t/* TBD: Add resetting the NO_MCP mode DB here */\n\n\t/* Open the gates #2, #3 and #4 */\n\tbnx2x_set_234_gates(bp, false);\n\n\t/* TBD: IGU/AEU preparation bring back the AEU/IGU to a\n\t * reset state, re-enable attentions. */\n\n\treturn 0;\n}\n\nstatic int bnx2x_leader_reset(struct bnx2x *bp)\n{\n\tint rc = 0;\n\tbool global = bnx2x_reset_is_global(bp);\n\tu32 load_code;\n\n\t/* if not going to reset MCP - load \"fake\" driver to reset HW while\n\t * driver is owner of the HW\n\t */\n\tif (!global && !BP_NOMCP(bp)) {\n\t\tload_code = bnx2x_fw_command(bp, DRV_MSG_CODE_LOAD_REQ,\n\t\t\t\t\t     DRV_MSG_CODE_LOAD_REQ_WITH_LFA);\n\t\tif (!load_code) {\n\t\t\tBNX2X_ERR(\"MCP response failure, aborting\\n\");\n\t\t\trc = -EAGAIN;\n\t\t\tgoto exit_leader_reset;\n\t\t}\n\t\tif ((load_code != FW_MSG_CODE_DRV_LOAD_COMMON_CHIP) &&\n\t\t    (load_code != FW_MSG_CODE_DRV_LOAD_COMMON)) {\n\t\t\tBNX2X_ERR(\"MCP unexpected resp, aborting\\n\");\n\t\t\trc = -EAGAIN;\n\t\t\tgoto exit_leader_reset2;\n\t\t}\n\t\tload_code = bnx2x_fw_command(bp, DRV_MSG_CODE_LOAD_DONE, 0);\n\t\tif (!load_code) {\n\t\t\tBNX2X_ERR(\"MCP response failure, aborting\\n\");\n\t\t\trc = -EAGAIN;\n\t\t\tgoto exit_leader_reset2;\n\t\t}\n\t}\n\n\t/* Try to recover after the failure */\n\tif (bnx2x_process_kill(bp, global)) {\n\t\tBNX2X_ERR(\"Something bad had happen on engine %d! Aii!\\n\",\n\t\t\t  BP_PATH(bp));\n\t\trc = -EAGAIN;\n\t\tgoto exit_leader_reset2;\n\t}\n\n\t/*\n\t * Clear RESET_IN_PROGRES and RESET_GLOBAL bits and update the driver\n\t * state.\n\t */\n\tbnx2x_set_reset_done(bp);\n\tif (global)\n\t\tbnx2x_clear_reset_global(bp);\n\nexit_leader_reset2:\n\t/* unload \"fake driver\" if it was loaded */\n\tif (!global && !BP_NOMCP(bp)) {\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_REQ_WOL_MCP, 0);\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_DONE, 0);\n\t}\nexit_leader_reset:\n\tbp->is_leader = 0;\n\tbnx2x_release_leader_lock(bp);\n\tsmp_mb();\n\treturn rc;\n}\n\nstatic void bnx2x_recovery_failed(struct bnx2x *bp)\n{\n\tnetdev_err(bp->dev, \"Recovery has failed. Power cycle is needed.\\n\");\n\n\t/* Disconnect this device */\n\tnetif_device_detach(bp->dev);\n\n\t/*\n\t * Block ifup for all function on this engine until \"process kill\"\n\t * or power cycle.\n\t */\n\tbnx2x_set_reset_in_progress(bp);\n\n\t/* Shut down the power */\n\tbnx2x_set_power_state(bp, PCI_D3hot);\n\n\tbp->recovery_state = BNX2X_RECOVERY_FAILED;\n\n\tsmp_mb();\n}\n\n/*\n * Assumption: runs under rtnl lock. This together with the fact\n * that it's called only from bnx2x_sp_rtnl() ensure that it\n * will never be called when netif_running(bp->dev) is false.\n */\nstatic void bnx2x_parity_recover(struct bnx2x *bp)\n{\n\tu32 error_recovered, error_unrecovered;\n\tbool is_parity, global = false;\n#ifdef CONFIG_BNX2X_SRIOV\n\tint vf_idx;\n\n\tfor (vf_idx = 0; vf_idx < bp->requested_nr_virtfn; vf_idx++) {\n\t\tstruct bnx2x_virtf *vf = BP_VF(bp, vf_idx);\n\n\t\tif (vf)\n\t\t\tvf->state = VF_LOST;\n\t}\n#endif\n\tDP(NETIF_MSG_HW, \"Handling parity\\n\");\n\twhile (1) {\n\t\tswitch (bp->recovery_state) {\n\t\tcase BNX2X_RECOVERY_INIT:\n\t\t\tDP(NETIF_MSG_HW, \"State is BNX2X_RECOVERY_INIT\\n\");\n\t\t\tis_parity = bnx2x_chk_parity_attn(bp, &global, false);\n\t\t\tWARN_ON(!is_parity);\n\n\t\t\t/* Try to get a LEADER_LOCK HW lock */\n\t\t\tif (bnx2x_trylock_leader_lock(bp)) {\n\t\t\t\tbnx2x_set_reset_in_progress(bp);\n\t\t\t\t/*\n\t\t\t\t * Check if there is a global attention and if\n\t\t\t\t * there was a global attention, set the global\n\t\t\t\t * reset bit.\n\t\t\t\t */\n\n\t\t\t\tif (global)\n\t\t\t\t\tbnx2x_set_reset_global(bp);\n\n\t\t\t\tbp->is_leader = 1;\n\t\t\t}\n\n\t\t\t/* Stop the driver */\n\t\t\t/* If interface has been removed - break */\n\t\t\tif (bnx2x_nic_unload(bp, UNLOAD_RECOVERY, false))\n\t\t\t\treturn;\n\n\t\t\tbp->recovery_state = BNX2X_RECOVERY_WAIT;\n\n\t\t\t/* Ensure \"is_leader\", MCP command sequence and\n\t\t\t * \"recovery_state\" update values are seen on other\n\t\t\t * CPUs.\n\t\t\t */\n\t\t\tsmp_mb();\n\t\t\tbreak;\n\n\t\tcase BNX2X_RECOVERY_WAIT:\n\t\t\tDP(NETIF_MSG_HW, \"State is BNX2X_RECOVERY_WAIT\\n\");\n\t\t\tif (bp->is_leader) {\n\t\t\t\tint other_engine = BP_PATH(bp) ? 0 : 1;\n\t\t\t\tbool other_load_status =\n\t\t\t\t\tbnx2x_get_load_status(bp, other_engine);\n\t\t\t\tbool load_status =\n\t\t\t\t\tbnx2x_get_load_status(bp, BP_PATH(bp));\n\t\t\t\tglobal = bnx2x_reset_is_global(bp);\n\n\t\t\t\t/*\n\t\t\t\t * In case of a parity in a global block, let\n\t\t\t\t * the first leader that performs a\n\t\t\t\t * leader_reset() reset the global blocks in\n\t\t\t\t * order to clear global attentions. Otherwise\n\t\t\t\t * the gates will remain closed for that\n\t\t\t\t * engine.\n\t\t\t\t */\n\t\t\t\tif (load_status ||\n\t\t\t\t    (global && other_load_status)) {\n\t\t\t\t\t/* Wait until all other functions get\n\t\t\t\t\t * down.\n\t\t\t\t\t */\n\t\t\t\t\tschedule_delayed_work(&bp->sp_rtnl_task,\n\t\t\t\t\t\t\t\tHZ/10);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\t/* If all other functions got down -\n\t\t\t\t\t * try to bring the chip back to\n\t\t\t\t\t * normal. In any case it's an exit\n\t\t\t\t\t * point for a leader.\n\t\t\t\t\t */\n\t\t\t\t\tif (bnx2x_leader_reset(bp)) {\n\t\t\t\t\t\tbnx2x_recovery_failed(bp);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* If we are here, means that the\n\t\t\t\t\t * leader has succeeded and doesn't\n\t\t\t\t\t * want to be a leader any more. Try\n\t\t\t\t\t * to continue as a none-leader.\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else { /* non-leader */\n\t\t\t\tif (!bnx2x_reset_is_done(bp, BP_PATH(bp))) {\n\t\t\t\t\t/* Try to get a LEADER_LOCK HW lock as\n\t\t\t\t\t * long as a former leader may have\n\t\t\t\t\t * been unloaded by the user or\n\t\t\t\t\t * released a leadership by another\n\t\t\t\t\t * reason.\n\t\t\t\t\t */\n\t\t\t\t\tif (bnx2x_trylock_leader_lock(bp)) {\n\t\t\t\t\t\t/* I'm a leader now! Restart a\n\t\t\t\t\t\t * switch case.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tbp->is_leader = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tschedule_delayed_work(&bp->sp_rtnl_task,\n\t\t\t\t\t\t\t\tHZ/10);\n\t\t\t\t\treturn;\n\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * If there was a global attention, wait\n\t\t\t\t\t * for it to be cleared.\n\t\t\t\t\t */\n\t\t\t\t\tif (bnx2x_reset_is_global(bp)) {\n\t\t\t\t\t\tschedule_delayed_work(\n\t\t\t\t\t\t\t&bp->sp_rtnl_task,\n\t\t\t\t\t\t\tHZ/10);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\terror_recovered =\n\t\t\t\t\t  bp->eth_stats.recoverable_error;\n\t\t\t\t\terror_unrecovered =\n\t\t\t\t\t  bp->eth_stats.unrecoverable_error;\n\t\t\t\t\tbp->recovery_state =\n\t\t\t\t\t\tBNX2X_RECOVERY_NIC_LOADING;\n\t\t\t\t\tif (bnx2x_nic_load(bp, LOAD_NORMAL)) {\n\t\t\t\t\t\terror_unrecovered++;\n\t\t\t\t\t\tnetdev_err(bp->dev,\n\t\t\t\t\t\t\t   \"Recovery failed. Power cycle needed\\n\");\n\t\t\t\t\t\t/* Disconnect this device */\n\t\t\t\t\t\tnetif_device_detach(bp->dev);\n\t\t\t\t\t\t/* Shut down the power */\n\t\t\t\t\t\tbnx2x_set_power_state(\n\t\t\t\t\t\t\tbp, PCI_D3hot);\n\t\t\t\t\t\tsmp_mb();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbp->recovery_state =\n\t\t\t\t\t\t\tBNX2X_RECOVERY_DONE;\n\t\t\t\t\t\terror_recovered++;\n\t\t\t\t\t\tsmp_mb();\n\t\t\t\t\t}\n\t\t\t\t\tbp->eth_stats.recoverable_error =\n\t\t\t\t\t\terror_recovered;\n\t\t\t\t\tbp->eth_stats.unrecoverable_error =\n\t\t\t\t\t\terror_unrecovered;\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int bnx2x_udp_port_update(struct bnx2x *bp)\n{\n\tstruct bnx2x_func_switch_update_params *switch_update_params;\n\tstruct bnx2x_func_state_params func_params = {NULL};\n\tu16 vxlan_port = 0, geneve_port = 0;\n\tint rc;\n\n\tswitch_update_params = &func_params.params.switch_update;\n\n\t/* Prepare parameters for function state transitions */\n\t__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\n\t__set_bit(RAMROD_RETRY, &func_params.ramrod_flags);\n\n\tfunc_params.f_obj = &bp->func_obj;\n\tfunc_params.cmd = BNX2X_F_CMD_SWITCH_UPDATE;\n\n\t/* Function parameters */\n\t__set_bit(BNX2X_F_UPDATE_TUNNEL_CFG_CHNG,\n\t\t  &switch_update_params->changes);\n\n\tif (bp->udp_tunnel_ports[BNX2X_UDP_PORT_GENEVE]) {\n\t\tgeneve_port = bp->udp_tunnel_ports[BNX2X_UDP_PORT_GENEVE];\n\t\tswitch_update_params->geneve_dst_port = geneve_port;\n\t}\n\n\tif (bp->udp_tunnel_ports[BNX2X_UDP_PORT_VXLAN]) {\n\t\tvxlan_port = bp->udp_tunnel_ports[BNX2X_UDP_PORT_VXLAN];\n\t\tswitch_update_params->vxlan_dst_port = vxlan_port;\n\t}\n\n\t/* Re-enable inner-rss for the offloaded UDP tunnels */\n\t__set_bit(BNX2X_F_UPDATE_TUNNEL_INNER_RSS,\n\t\t  &switch_update_params->changes);\n\n\trc = bnx2x_func_state_change(bp, &func_params);\n\tif (rc)\n\t\tBNX2X_ERR(\"failed to set UDP dst port to %04x %04x (rc = 0x%x)\\n\",\n\t\t\t  vxlan_port, geneve_port, rc);\n\telse\n\t\tDP(BNX2X_MSG_SP,\n\t\t   \"Configured UDP ports: Vxlan [%04x] Geneve [%04x]\\n\",\n\t\t   vxlan_port, geneve_port);\n\n\treturn rc;\n}\n\nstatic int bnx2x_udp_tunnel_sync(struct net_device *netdev, unsigned int table)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tstruct udp_tunnel_info ti;\n\n\tudp_tunnel_nic_get_port(netdev, table, 0, &ti);\n\tbp->udp_tunnel_ports[table] = be16_to_cpu(ti.port);\n\n\treturn bnx2x_udp_port_update(bp);\n}\n\nstatic const struct udp_tunnel_nic_info bnx2x_udp_tunnels = {\n\t.sync_table\t= bnx2x_udp_tunnel_sync,\n\t.flags\t\t= UDP_TUNNEL_NIC_INFO_MAY_SLEEP |\n\t\t\t  UDP_TUNNEL_NIC_INFO_OPEN_ONLY,\n\t.tables\t\t= {\n\t\t{ .n_entries = 1, .tunnel_types = UDP_TUNNEL_TYPE_VXLAN,  },\n\t\t{ .n_entries = 1, .tunnel_types = UDP_TUNNEL_TYPE_GENEVE, },\n\t},\n};\n\nstatic int bnx2x_close(struct net_device *dev);\n\n/* bnx2x_nic_unload() flushes the bnx2x_wq, thus reset task is\n * scheduled on a general queue in order to prevent a dead lock.\n */\nstatic void bnx2x_sp_rtnl_task(struct work_struct *work)\n{\n\tstruct bnx2x *bp = container_of(work, struct bnx2x, sp_rtnl_task.work);\n\n\trtnl_lock();\n\n\tif (!netif_running(bp->dev)) {\n\t\trtnl_unlock();\n\t\treturn;\n\t}\n\n\tif (unlikely(bp->recovery_state != BNX2X_RECOVERY_DONE)) {\n#ifdef BNX2X_STOP_ON_ERROR\n\t\tBNX2X_ERR(\"recovery flow called but STOP_ON_ERROR defined so reset not done to allow debug dump,\\n\"\n\t\t\t  \"you will need to reboot when done\\n\");\n\t\tgoto sp_rtnl_not_reset;\n#endif\n\t\t/*\n\t\t * Clear all pending SP commands as we are going to reset the\n\t\t * function anyway.\n\t\t */\n\t\tbp->sp_rtnl_state = 0;\n\t\tsmp_mb();\n\n\t\tbnx2x_parity_recover(bp);\n\n\t\trtnl_unlock();\n\t\treturn;\n\t}\n\n\tif (test_and_clear_bit(BNX2X_SP_RTNL_TX_TIMEOUT, &bp->sp_rtnl_state)) {\n#ifdef BNX2X_STOP_ON_ERROR\n\t\tBNX2X_ERR(\"recovery flow called but STOP_ON_ERROR defined so reset not done to allow debug dump,\\n\"\n\t\t\t  \"you will need to reboot when done\\n\");\n\t\tgoto sp_rtnl_not_reset;\n#endif\n\n\t\t/*\n\t\t * Clear all pending SP commands as we are going to reset the\n\t\t * function anyway.\n\t\t */\n\t\tbp->sp_rtnl_state = 0;\n\t\tsmp_mb();\n\n\t\t/* Immediately indicate link as down */\n\t\tbp->link_vars.link_up = 0;\n\t\tbp->force_link_down = true;\n\t\tnetif_carrier_off(bp->dev);\n\t\tBNX2X_ERR(\"Indicating link is down due to Tx-timeout\\n\");\n\n\t\tbnx2x_nic_unload(bp, UNLOAD_NORMAL, true);\n\t\t/* When ret value shows failure of allocation failure,\n\t\t * the nic is rebooted again. If open still fails, a error\n\t\t * message to notify the user.\n\t\t */\n\t\tif (bnx2x_nic_load(bp, LOAD_NORMAL) == -ENOMEM) {\n\t\t\tbnx2x_nic_unload(bp, UNLOAD_NORMAL, true);\n\t\t\tif (bnx2x_nic_load(bp, LOAD_NORMAL))\n\t\t\t\tBNX2X_ERR(\"Open the NIC fails again!\\n\");\n\t\t}\n\t\trtnl_unlock();\n\t\treturn;\n\t}\n#ifdef BNX2X_STOP_ON_ERROR\nsp_rtnl_not_reset:\n#endif\n\tif (test_and_clear_bit(BNX2X_SP_RTNL_SETUP_TC, &bp->sp_rtnl_state))\n\t\tbnx2x_setup_tc(bp->dev, bp->dcbx_port_params.ets.num_of_cos);\n\tif (test_and_clear_bit(BNX2X_SP_RTNL_AFEX_F_UPDATE, &bp->sp_rtnl_state))\n\t\tbnx2x_after_function_update(bp);\n\t/*\n\t * in case of fan failure we need to reset id if the \"stop on error\"\n\t * debug flag is set, since we trying to prevent permanent overheating\n\t * damage\n\t */\n\tif (test_and_clear_bit(BNX2X_SP_RTNL_FAN_FAILURE, &bp->sp_rtnl_state)) {\n\t\tDP(NETIF_MSG_HW, \"fan failure detected. Unloading driver\\n\");\n\t\tnetif_device_detach(bp->dev);\n\t\tbnx2x_close(bp->dev);\n\t\trtnl_unlock();\n\t\treturn;\n\t}\n\n\tif (test_and_clear_bit(BNX2X_SP_RTNL_VFPF_MCAST, &bp->sp_rtnl_state)) {\n\t\tDP(BNX2X_MSG_SP,\n\t\t   \"sending set mcast vf pf channel message from rtnl sp-task\\n\");\n\t\tbnx2x_vfpf_set_mcast(bp->dev);\n\t}\n\tif (test_and_clear_bit(BNX2X_SP_RTNL_VFPF_CHANNEL_DOWN,\n\t\t\t       &bp->sp_rtnl_state)){\n\t\tif (netif_carrier_ok(bp->dev)) {\n\t\t\tbnx2x_tx_disable(bp);\n\t\t\tBNX2X_ERR(\"PF indicated channel is not servicable anymore. This means this VF device is no longer operational\\n\");\n\t\t}\n\t}\n\n\tif (test_and_clear_bit(BNX2X_SP_RTNL_RX_MODE, &bp->sp_rtnl_state)) {\n\t\tDP(BNX2X_MSG_SP, \"Handling Rx Mode setting\\n\");\n\t\tbnx2x_set_rx_mode_inner(bp);\n\t}\n\n\tif (test_and_clear_bit(BNX2X_SP_RTNL_HYPERVISOR_VLAN,\n\t\t\t       &bp->sp_rtnl_state))\n\t\tbnx2x_pf_set_vfs_vlan(bp);\n\n\tif (test_and_clear_bit(BNX2X_SP_RTNL_TX_STOP, &bp->sp_rtnl_state)) {\n\t\tbnx2x_dcbx_stop_hw_tx(bp);\n\t\tbnx2x_dcbx_resume_hw_tx(bp);\n\t}\n\n\tif (test_and_clear_bit(BNX2X_SP_RTNL_GET_DRV_VERSION,\n\t\t\t       &bp->sp_rtnl_state))\n\t\tbnx2x_update_mng_version(bp);\n\n\tif (test_and_clear_bit(BNX2X_SP_RTNL_UPDATE_SVID, &bp->sp_rtnl_state))\n\t\tbnx2x_handle_update_svid_cmd(bp);\n\n\t/* work which needs rtnl lock not-taken (as it takes the lock itself and\n\t * can be called from other contexts as well)\n\t */\n\trtnl_unlock();\n\n\t/* enable SR-IOV if applicable */\n\tif (IS_SRIOV(bp) && test_and_clear_bit(BNX2X_SP_RTNL_ENABLE_SRIOV,\n\t\t\t\t\t       &bp->sp_rtnl_state)) {\n\t\tbnx2x_disable_sriov(bp);\n\t\tbnx2x_enable_sriov(bp);\n\t}\n}\n\nstatic void bnx2x_period_task(struct work_struct *work)\n{\n\tstruct bnx2x *bp = container_of(work, struct bnx2x, period_task.work);\n\n\tif (!netif_running(bp->dev))\n\t\tgoto period_task_exit;\n\n\tif (CHIP_REV_IS_SLOW(bp)) {\n\t\tBNX2X_ERR(\"period task called on emulation, ignoring\\n\");\n\t\tgoto period_task_exit;\n\t}\n\n\tbnx2x_acquire_phy_lock(bp);\n\t/*\n\t * The barrier is needed to ensure the ordering between the writing to\n\t * the bp->port.pmf in the bnx2x_nic_load() or bnx2x_pmf_update() and\n\t * the reading here.\n\t */\n\tsmp_mb();\n\tif (bp->port.pmf) {\n\t\tbnx2x_period_func(&bp->link_params, &bp->link_vars);\n\n\t\t/* Re-queue task in 1 sec */\n\t\tqueue_delayed_work(bnx2x_wq, &bp->period_task, 1*HZ);\n\t}\n\n\tbnx2x_release_phy_lock(bp);\nperiod_task_exit:\n\treturn;\n}\n\n/*\n * Init service functions\n */\n\nstatic u32 bnx2x_get_pretend_reg(struct bnx2x *bp)\n{\n\tu32 base = PXP2_REG_PGL_PRETEND_FUNC_F0;\n\tu32 stride = PXP2_REG_PGL_PRETEND_FUNC_F1 - base;\n\treturn base + (BP_ABS_FUNC(bp)) * stride;\n}\n\nstatic bool bnx2x_prev_unload_close_umac(struct bnx2x *bp,\n\t\t\t\t\t u8 port, u32 reset_reg,\n\t\t\t\t\t struct bnx2x_mac_vals *vals)\n{\n\tu32 mask = MISC_REGISTERS_RESET_REG_2_UMAC0 << port;\n\tu32 base_addr;\n\n\tif (!(mask & reset_reg))\n\t\treturn false;\n\n\tBNX2X_DEV_INFO(\"Disable umac Rx %02x\\n\", port);\n\tbase_addr = port ? GRCBASE_UMAC1 : GRCBASE_UMAC0;\n\tvals->umac_addr[port] = base_addr + UMAC_REG_COMMAND_CONFIG;\n\tvals->umac_val[port] = REG_RD(bp, vals->umac_addr[port]);\n\tREG_WR(bp, vals->umac_addr[port], 0);\n\n\treturn true;\n}\n\nstatic void bnx2x_prev_unload_close_mac(struct bnx2x *bp,\n\t\t\t\t\tstruct bnx2x_mac_vals *vals)\n{\n\tu32 val, base_addr, offset, mask, reset_reg;\n\tbool mac_stopped = false;\n\tu8 port = BP_PORT(bp);\n\n\t/* reset addresses as they also mark which values were changed */\n\tmemset(vals, 0, sizeof(*vals));\n\n\treset_reg = REG_RD(bp, MISC_REG_RESET_REG_2);\n\n\tif (!CHIP_IS_E3(bp)) {\n\t\tval = REG_RD(bp, NIG_REG_BMAC0_REGS_OUT_EN + port * 4);\n\t\tmask = MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port;\n\t\tif ((mask & reset_reg) && val) {\n\t\t\tu32 wb_data[2];\n\t\t\tBNX2X_DEV_INFO(\"Disable bmac Rx\\n\");\n\t\t\tbase_addr = BP_PORT(bp) ? NIG_REG_INGRESS_BMAC1_MEM\n\t\t\t\t\t\t: NIG_REG_INGRESS_BMAC0_MEM;\n\t\t\toffset = CHIP_IS_E2(bp) ? BIGMAC2_REGISTER_BMAC_CONTROL\n\t\t\t\t\t\t: BIGMAC_REGISTER_BMAC_CONTROL;\n\n\t\t\t/*\n\t\t\t * use rd/wr since we cannot use dmae. This is safe\n\t\t\t * since MCP won't access the bus due to the request\n\t\t\t * to unload, and no function on the path can be\n\t\t\t * loaded at this time.\n\t\t\t */\n\t\t\twb_data[0] = REG_RD(bp, base_addr + offset);\n\t\t\twb_data[1] = REG_RD(bp, base_addr + offset + 0x4);\n\t\t\tvals->bmac_addr = base_addr + offset;\n\t\t\tvals->bmac_val[0] = wb_data[0];\n\t\t\tvals->bmac_val[1] = wb_data[1];\n\t\t\twb_data[0] &= ~BMAC_CONTROL_RX_ENABLE;\n\t\t\tREG_WR(bp, vals->bmac_addr, wb_data[0]);\n\t\t\tREG_WR(bp, vals->bmac_addr + 0x4, wb_data[1]);\n\t\t}\n\t\tBNX2X_DEV_INFO(\"Disable emac Rx\\n\");\n\t\tvals->emac_addr = NIG_REG_NIG_EMAC0_EN + BP_PORT(bp)*4;\n\t\tvals->emac_val = REG_RD(bp, vals->emac_addr);\n\t\tREG_WR(bp, vals->emac_addr, 0);\n\t\tmac_stopped = true;\n\t} else {\n\t\tif (reset_reg & MISC_REGISTERS_RESET_REG_2_XMAC) {\n\t\t\tBNX2X_DEV_INFO(\"Disable xmac Rx\\n\");\n\t\t\tbase_addr = BP_PORT(bp) ? GRCBASE_XMAC1 : GRCBASE_XMAC0;\n\t\t\tval = REG_RD(bp, base_addr + XMAC_REG_PFC_CTRL_HI);\n\t\t\tREG_WR(bp, base_addr + XMAC_REG_PFC_CTRL_HI,\n\t\t\t       val & ~(1 << 1));\n\t\t\tREG_WR(bp, base_addr + XMAC_REG_PFC_CTRL_HI,\n\t\t\t       val | (1 << 1));\n\t\t\tvals->xmac_addr = base_addr + XMAC_REG_CTRL;\n\t\t\tvals->xmac_val = REG_RD(bp, vals->xmac_addr);\n\t\t\tREG_WR(bp, vals->xmac_addr, 0);\n\t\t\tmac_stopped = true;\n\t\t}\n\n\t\tmac_stopped |= bnx2x_prev_unload_close_umac(bp, 0,\n\t\t\t\t\t\t\t    reset_reg, vals);\n\t\tmac_stopped |= bnx2x_prev_unload_close_umac(bp, 1,\n\t\t\t\t\t\t\t    reset_reg, vals);\n\t}\n\n\tif (mac_stopped)\n\t\tmsleep(20);\n}\n\n#define BNX2X_PREV_UNDI_PROD_ADDR(p) (BAR_TSTRORM_INTMEM + 0x1508 + ((p) << 4))\n#define BNX2X_PREV_UNDI_PROD_ADDR_H(f) (BAR_TSTRORM_INTMEM + \\\n\t\t\t\t\t0x1848 + ((f) << 4))\n#define BNX2X_PREV_UNDI_RCQ(val)\t((val) & 0xffff)\n#define BNX2X_PREV_UNDI_BD(val)\t\t((val) >> 16 & 0xffff)\n#define BNX2X_PREV_UNDI_PROD(rcq, bd)\t((bd) << 16 | (rcq))\n\n#define BCM_5710_UNDI_FW_MF_MAJOR\t(0x07)\n#define BCM_5710_UNDI_FW_MF_MINOR\t(0x08)\n#define BCM_5710_UNDI_FW_MF_VERS\t(0x05)\n\nstatic bool bnx2x_prev_is_after_undi(struct bnx2x *bp)\n{\n\t/* UNDI marks its presence in DORQ -\n\t * it initializes CID offset for normal bell to 0x7\n\t */\n\tif (!(REG_RD(bp, MISC_REG_RESET_REG_1) &\n\t    MISC_REGISTERS_RESET_REG_1_RST_DORQ))\n\t\treturn false;\n\n\tif (REG_RD(bp, DORQ_REG_NORM_CID_OFST) == 0x7) {\n\t\tBNX2X_DEV_INFO(\"UNDI previously loaded\\n\");\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void bnx2x_prev_unload_undi_inc(struct bnx2x *bp, u8 inc)\n{\n\tu16 rcq, bd;\n\tu32 addr, tmp_reg;\n\n\tif (BP_FUNC(bp) < 2)\n\t\taddr = BNX2X_PREV_UNDI_PROD_ADDR(BP_PORT(bp));\n\telse\n\t\taddr = BNX2X_PREV_UNDI_PROD_ADDR_H(BP_FUNC(bp) - 2);\n\n\ttmp_reg = REG_RD(bp, addr);\n\trcq = BNX2X_PREV_UNDI_RCQ(tmp_reg) + inc;\n\tbd = BNX2X_PREV_UNDI_BD(tmp_reg) + inc;\n\n\ttmp_reg = BNX2X_PREV_UNDI_PROD(rcq, bd);\n\tREG_WR(bp, addr, tmp_reg);\n\n\tBNX2X_DEV_INFO(\"UNDI producer [%d/%d][%08x] rings bd -> 0x%04x, rcq -> 0x%04x\\n\",\n\t\t       BP_PORT(bp), BP_FUNC(bp), addr, bd, rcq);\n}\n\nstatic int bnx2x_prev_mcp_done(struct bnx2x *bp)\n{\n\tu32 rc = bnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_DONE,\n\t\t\t\t  DRV_MSG_CODE_UNLOAD_SKIP_LINK_RESET);\n\tif (!rc) {\n\t\tBNX2X_ERR(\"MCP response failure, aborting\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic struct bnx2x_prev_path_list *\n\t\tbnx2x_prev_path_get_entry(struct bnx2x *bp)\n{\n\tstruct bnx2x_prev_path_list *tmp_list;\n\n\tlist_for_each_entry(tmp_list, &bnx2x_prev_list, list)\n\t\tif (PCI_SLOT(bp->pdev->devfn) == tmp_list->slot &&\n\t\t    bp->pdev->bus->number == tmp_list->bus &&\n\t\t    BP_PATH(bp) == tmp_list->path)\n\t\t\treturn tmp_list;\n\n\treturn NULL;\n}\n\nstatic int bnx2x_prev_path_mark_eeh(struct bnx2x *bp)\n{\n\tstruct bnx2x_prev_path_list *tmp_list;\n\tint rc;\n\n\trc = down_interruptible(&bnx2x_prev_sem);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Received %d when tried to take lock\\n\", rc);\n\t\treturn rc;\n\t}\n\n\ttmp_list = bnx2x_prev_path_get_entry(bp);\n\tif (tmp_list) {\n\t\ttmp_list->aer = 1;\n\t\trc = 0;\n\t} else {\n\t\tBNX2X_ERR(\"path %d: Entry does not exist for eeh; Flow occurs before initial insmod is over ?\\n\",\n\t\t\t  BP_PATH(bp));\n\t}\n\n\tup(&bnx2x_prev_sem);\n\n\treturn rc;\n}\n\nstatic bool bnx2x_prev_is_path_marked(struct bnx2x *bp)\n{\n\tstruct bnx2x_prev_path_list *tmp_list;\n\tbool rc = false;\n\n\tif (down_trylock(&bnx2x_prev_sem))\n\t\treturn false;\n\n\ttmp_list = bnx2x_prev_path_get_entry(bp);\n\tif (tmp_list) {\n\t\tif (tmp_list->aer) {\n\t\t\tDP(NETIF_MSG_HW, \"Path %d was marked by AER\\n\",\n\t\t\t   BP_PATH(bp));\n\t\t} else {\n\t\t\trc = true;\n\t\t\tBNX2X_DEV_INFO(\"Path %d was already cleaned from previous drivers\\n\",\n\t\t\t\t       BP_PATH(bp));\n\t\t}\n\t}\n\n\tup(&bnx2x_prev_sem);\n\n\treturn rc;\n}\n\nbool bnx2x_port_after_undi(struct bnx2x *bp)\n{\n\tstruct bnx2x_prev_path_list *entry;\n\tbool val;\n\n\tdown(&bnx2x_prev_sem);\n\n\tentry = bnx2x_prev_path_get_entry(bp);\n\tval = !!(entry && (entry->undi & (1 << BP_PORT(bp))));\n\n\tup(&bnx2x_prev_sem);\n\n\treturn val;\n}\n\nstatic int bnx2x_prev_mark_path(struct bnx2x *bp, bool after_undi)\n{\n\tstruct bnx2x_prev_path_list *tmp_list;\n\tint rc;\n\n\trc = down_interruptible(&bnx2x_prev_sem);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Received %d when tried to take lock\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t/* Check whether the entry for this path already exists */\n\ttmp_list = bnx2x_prev_path_get_entry(bp);\n\tif (tmp_list) {\n\t\tif (!tmp_list->aer) {\n\t\t\tBNX2X_ERR(\"Re-Marking the path.\\n\");\n\t\t} else {\n\t\t\tDP(NETIF_MSG_HW, \"Removing AER indication from path %d\\n\",\n\t\t\t   BP_PATH(bp));\n\t\t\ttmp_list->aer = 0;\n\t\t}\n\t\tup(&bnx2x_prev_sem);\n\t\treturn 0;\n\t}\n\tup(&bnx2x_prev_sem);\n\n\t/* Create an entry for this path and add it */\n\ttmp_list = kmalloc(sizeof(struct bnx2x_prev_path_list), GFP_KERNEL);\n\tif (!tmp_list) {\n\t\tBNX2X_ERR(\"Failed to allocate 'bnx2x_prev_path_list'\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttmp_list->bus = bp->pdev->bus->number;\n\ttmp_list->slot = PCI_SLOT(bp->pdev->devfn);\n\ttmp_list->path = BP_PATH(bp);\n\ttmp_list->aer = 0;\n\ttmp_list->undi = after_undi ? (1 << BP_PORT(bp)) : 0;\n\n\trc = down_interruptible(&bnx2x_prev_sem);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Received %d when tried to take lock\\n\", rc);\n\t\tkfree(tmp_list);\n\t} else {\n\t\tDP(NETIF_MSG_HW, \"Marked path [%d] - finished previous unload\\n\",\n\t\t   BP_PATH(bp));\n\t\tlist_add(&tmp_list->list, &bnx2x_prev_list);\n\t\tup(&bnx2x_prev_sem);\n\t}\n\n\treturn rc;\n}\n\nstatic int bnx2x_do_flr(struct bnx2x *bp)\n{\n\tstruct pci_dev *dev = bp->pdev;\n\n\tif (CHIP_IS_E1x(bp)) {\n\t\tBNX2X_DEV_INFO(\"FLR not supported in E1/E1H\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* only bootcode REQ_BC_VER_4_INITIATE_FLR and onwards support flr */\n\tif (bp->common.bc_ver < REQ_BC_VER_4_INITIATE_FLR) {\n\t\tBNX2X_ERR(\"FLR not supported by BC_VER: 0x%x\\n\",\n\t\t\t  bp->common.bc_ver);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pci_wait_for_pending_transaction(dev))\n\t\tdev_err(&dev->dev, \"transaction is not cleared; proceeding with reset anyway\\n\");\n\n\tBNX2X_DEV_INFO(\"Initiating FLR\\n\");\n\tbnx2x_fw_command(bp, DRV_MSG_CODE_INITIATE_FLR, 0);\n\n\treturn 0;\n}\n\nstatic int bnx2x_prev_unload_uncommon(struct bnx2x *bp)\n{\n\tint rc;\n\n\tBNX2X_DEV_INFO(\"Uncommon unload Flow\\n\");\n\n\t/* Test if previous unload process was already finished for this path */\n\tif (bnx2x_prev_is_path_marked(bp))\n\t\treturn bnx2x_prev_mcp_done(bp);\n\n\tBNX2X_DEV_INFO(\"Path is unmarked\\n\");\n\n\t/* Cannot proceed with FLR if UNDI is loaded, since FW does not match */\n\tif (bnx2x_prev_is_after_undi(bp))\n\t\tgoto out;\n\n\t/* If function has FLR capabilities, and existing FW version matches\n\t * the one required, then FLR will be sufficient to clean any residue\n\t * left by previous driver\n\t */\n\trc = bnx2x_compare_fw_ver(bp, FW_MSG_CODE_DRV_LOAD_FUNCTION, false);\n\n\tif (!rc) {\n\t\t/* fw version is good */\n\t\tBNX2X_DEV_INFO(\"FW version matches our own. Attempting FLR\\n\");\n\t\trc = bnx2x_do_flr(bp);\n\t}\n\n\tif (!rc) {\n\t\t/* FLR was performed */\n\t\tBNX2X_DEV_INFO(\"FLR successful\\n\");\n\t\treturn 0;\n\t}\n\n\tBNX2X_DEV_INFO(\"Could not FLR\\n\");\n\nout:\n\t/* Close the MCP request, return failure*/\n\trc = bnx2x_prev_mcp_done(bp);\n\tif (!rc)\n\t\trc = BNX2X_PREV_WAIT_NEEDED;\n\n\treturn rc;\n}\n\nstatic int bnx2x_prev_unload_common(struct bnx2x *bp)\n{\n\tu32 reset_reg, tmp_reg = 0, rc;\n\tbool prev_undi = false;\n\tstruct bnx2x_mac_vals mac_vals;\n\n\t/* It is possible a previous function received 'common' answer,\n\t * but hasn't loaded yet, therefore creating a scenario of\n\t * multiple functions receiving 'common' on the same path.\n\t */\n\tBNX2X_DEV_INFO(\"Common unload Flow\\n\");\n\n\tmemset(&mac_vals, 0, sizeof(mac_vals));\n\n\tif (bnx2x_prev_is_path_marked(bp))\n\t\treturn bnx2x_prev_mcp_done(bp);\n\n\treset_reg = REG_RD(bp, MISC_REG_RESET_REG_1);\n\n\t/* Reset should be performed after BRB is emptied */\n\tif (reset_reg & MISC_REGISTERS_RESET_REG_1_RST_BRB1) {\n\t\tu32 timer_count = 1000;\n\n\t\t/* Close the MAC Rx to prevent BRB from filling up */\n\t\tbnx2x_prev_unload_close_mac(bp, &mac_vals);\n\n\t\t/* close LLH filters for both ports towards the BRB */\n\t\tbnx2x_set_rx_filter(&bp->link_params, 0);\n\t\tbp->link_params.port ^= 1;\n\t\tbnx2x_set_rx_filter(&bp->link_params, 0);\n\t\tbp->link_params.port ^= 1;\n\n\t\t/* Check if the UNDI driver was previously loaded */\n\t\tif (bnx2x_prev_is_after_undi(bp)) {\n\t\t\tprev_undi = true;\n\t\t\t/* clear the UNDI indication */\n\t\t\tREG_WR(bp, DORQ_REG_NORM_CID_OFST, 0);\n\t\t\t/* clear possible idle check errors */\n\t\t\tREG_RD(bp, NIG_REG_NIG_INT_STS_CLR_0);\n\t\t}\n\t\tif (!CHIP_IS_E1x(bp))\n\t\t\t/* block FW from writing to host */\n\t\t\tREG_WR(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER, 0);\n\n\t\t/* wait until BRB is empty */\n\t\ttmp_reg = REG_RD(bp, BRB1_REG_NUM_OF_FULL_BLOCKS);\n\t\twhile (timer_count) {\n\t\t\tu32 prev_brb = tmp_reg;\n\n\t\t\ttmp_reg = REG_RD(bp, BRB1_REG_NUM_OF_FULL_BLOCKS);\n\t\t\tif (!tmp_reg)\n\t\t\t\tbreak;\n\n\t\t\tBNX2X_DEV_INFO(\"BRB still has 0x%08x\\n\", tmp_reg);\n\n\t\t\t/* reset timer as long as BRB actually gets emptied */\n\t\t\tif (prev_brb > tmp_reg)\n\t\t\t\ttimer_count = 1000;\n\t\t\telse\n\t\t\t\ttimer_count--;\n\n\t\t\t/* If UNDI resides in memory, manually increment it */\n\t\t\tif (prev_undi)\n\t\t\t\tbnx2x_prev_unload_undi_inc(bp, 1);\n\n\t\t\tudelay(10);\n\t\t}\n\n\t\tif (!timer_count)\n\t\t\tBNX2X_ERR(\"Failed to empty BRB, hope for the best\\n\");\n\t}\n\n\t/* No packets are in the pipeline, path is ready for reset */\n\tbnx2x_reset_common(bp);\n\n\tif (mac_vals.xmac_addr)\n\t\tREG_WR(bp, mac_vals.xmac_addr, mac_vals.xmac_val);\n\tif (mac_vals.umac_addr[0])\n\t\tREG_WR(bp, mac_vals.umac_addr[0], mac_vals.umac_val[0]);\n\tif (mac_vals.umac_addr[1])\n\t\tREG_WR(bp, mac_vals.umac_addr[1], mac_vals.umac_val[1]);\n\tif (mac_vals.emac_addr)\n\t\tREG_WR(bp, mac_vals.emac_addr, mac_vals.emac_val);\n\tif (mac_vals.bmac_addr) {\n\t\tREG_WR(bp, mac_vals.bmac_addr, mac_vals.bmac_val[0]);\n\t\tREG_WR(bp, mac_vals.bmac_addr + 4, mac_vals.bmac_val[1]);\n\t}\n\n\trc = bnx2x_prev_mark_path(bp, prev_undi);\n\tif (rc) {\n\t\tbnx2x_prev_mcp_done(bp);\n\t\treturn rc;\n\t}\n\n\treturn bnx2x_prev_mcp_done(bp);\n}\n\nstatic int bnx2x_prev_unload(struct bnx2x *bp)\n{\n\tint time_counter = 10;\n\tu32 rc, fw, hw_lock_reg, hw_lock_val;\n\tBNX2X_DEV_INFO(\"Entering Previous Unload Flow\\n\");\n\n\t/* clear hw from errors which may have resulted from an interrupted\n\t * dmae transaction.\n\t */\n\tbnx2x_clean_pglue_errors(bp);\n\n\t/* Release previously held locks */\n\thw_lock_reg = (BP_FUNC(bp) <= 5) ?\n\t\t      (MISC_REG_DRIVER_CONTROL_1 + BP_FUNC(bp) * 8) :\n\t\t      (MISC_REG_DRIVER_CONTROL_7 + (BP_FUNC(bp) - 6) * 8);\n\n\thw_lock_val = REG_RD(bp, hw_lock_reg);\n\tif (hw_lock_val) {\n\t\tif (hw_lock_val & HW_LOCK_RESOURCE_NVRAM) {\n\t\t\tBNX2X_DEV_INFO(\"Release Previously held NVRAM lock\\n\");\n\t\t\tREG_WR(bp, MCP_REG_MCPR_NVM_SW_ARB,\n\t\t\t       (MCPR_NVM_SW_ARB_ARB_REQ_CLR1 << BP_PORT(bp)));\n\t\t}\n\n\t\tBNX2X_DEV_INFO(\"Release Previously held hw lock\\n\");\n\t\tREG_WR(bp, hw_lock_reg, 0xffffffff);\n\t} else\n\t\tBNX2X_DEV_INFO(\"No need to release hw/nvram locks\\n\");\n\n\tif (MCPR_ACCESS_LOCK_LOCK & REG_RD(bp, MCP_REG_MCPR_ACCESS_LOCK)) {\n\t\tBNX2X_DEV_INFO(\"Release previously held alr\\n\");\n\t\tbnx2x_release_alr(bp);\n\t}\n\n\tdo {\n\t\tint aer = 0;\n\t\t/* Lock MCP using an unload request */\n\t\tfw = bnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS, 0);\n\t\tif (!fw) {\n\t\t\tBNX2X_ERR(\"MCP response failure, aborting\\n\");\n\t\t\trc = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\trc = down_interruptible(&bnx2x_prev_sem);\n\t\tif (rc) {\n\t\t\tBNX2X_ERR(\"Cannot check for AER; Received %d when tried to take lock\\n\",\n\t\t\t\t  rc);\n\t\t} else {\n\t\t\t/* If Path is marked by EEH, ignore unload status */\n\t\t\taer = !!(bnx2x_prev_path_get_entry(bp) &&\n\t\t\t\t bnx2x_prev_path_get_entry(bp)->aer);\n\t\t\tup(&bnx2x_prev_sem);\n\t\t}\n\n\t\tif (fw == FW_MSG_CODE_DRV_UNLOAD_COMMON || aer) {\n\t\t\trc = bnx2x_prev_unload_common(bp);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* non-common reply from MCP might require looping */\n\t\trc = bnx2x_prev_unload_uncommon(bp);\n\t\tif (rc != BNX2X_PREV_WAIT_NEEDED)\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t} while (--time_counter);\n\n\tif (!time_counter || rc) {\n\t\tBNX2X_DEV_INFO(\"Unloading previous driver did not occur, Possibly due to MF UNDI\\n\");\n\t\trc = -EPROBE_DEFER;\n\t}\n\n\t/* Mark function if its port was used to boot from SAN */\n\tif (bnx2x_port_after_undi(bp))\n\t\tbp->link_params.feature_config_flags |=\n\t\t\tFEATURE_CONFIG_BOOT_FROM_SAN;\n\n\tBNX2X_DEV_INFO(\"Finished Previous Unload Flow [%d]\\n\", rc);\n\n\treturn rc;\n}\n\nstatic void bnx2x_get_common_hwinfo(struct bnx2x *bp)\n{\n\tu32 val, val2, val3, val4, id, boot_mode;\n\tu16 pmc;\n\n\t/* Get the chip revision id and number. */\n\t/* chip num:16-31, rev:12-15, metal:4-11, bond_id:0-3 */\n\tval = REG_RD(bp, MISC_REG_CHIP_NUM);\n\tid = ((val & 0xffff) << 16);\n\tval = REG_RD(bp, MISC_REG_CHIP_REV);\n\tid |= ((val & 0xf) << 12);\n\n\t/* Metal is read from PCI regs, but we can't access >=0x400 from\n\t * the configuration space (so we need to reg_rd)\n\t */\n\tval = REG_RD(bp, PCICFG_OFFSET + PCI_ID_VAL3);\n\tid |= (((val >> 24) & 0xf) << 4);\n\tval = REG_RD(bp, MISC_REG_BOND_ID);\n\tid |= (val & 0xf);\n\tbp->common.chip_id = id;\n\n\t/* force 57811 according to MISC register */\n\tif (REG_RD(bp, MISC_REG_CHIP_TYPE) & MISC_REG_CHIP_TYPE_57811_MASK) {\n\t\tif (CHIP_IS_57810(bp))\n\t\t\tbp->common.chip_id = (CHIP_NUM_57811 << 16) |\n\t\t\t\t(bp->common.chip_id & 0x0000FFFF);\n\t\telse if (CHIP_IS_57810_MF(bp))\n\t\t\tbp->common.chip_id = (CHIP_NUM_57811_MF << 16) |\n\t\t\t\t(bp->common.chip_id & 0x0000FFFF);\n\t\tbp->common.chip_id |= 0x1;\n\t}\n\n\t/* Set doorbell size */\n\tbp->db_size = (1 << BNX2X_DB_SHIFT);\n\n\tif (!CHIP_IS_E1x(bp)) {\n\t\tval = REG_RD(bp, MISC_REG_PORT4MODE_EN_OVWR);\n\t\tif ((val & 1) == 0)\n\t\t\tval = REG_RD(bp, MISC_REG_PORT4MODE_EN);\n\t\telse\n\t\t\tval = (val >> 1) & 1;\n\t\tBNX2X_DEV_INFO(\"chip is in %s\\n\", val ? \"4_PORT_MODE\" :\n\t\t\t\t\t\t       \"2_PORT_MODE\");\n\t\tbp->common.chip_port_mode = val ? CHIP_4_PORT_MODE :\n\t\t\t\t\t\t CHIP_2_PORT_MODE;\n\n\t\tif (CHIP_MODE_IS_4_PORT(bp))\n\t\t\tbp->pfid = (bp->pf_num >> 1);\t/* 0..3 */\n\t\telse\n\t\t\tbp->pfid = (bp->pf_num & 0x6);\t/* 0, 2, 4, 6 */\n\t} else {\n\t\tbp->common.chip_port_mode = CHIP_PORT_MODE_NONE; /* N/A */\n\t\tbp->pfid = bp->pf_num;\t\t\t/* 0..7 */\n\t}\n\n\tBNX2X_DEV_INFO(\"pf_id: %x\", bp->pfid);\n\n\tbp->link_params.chip_id = bp->common.chip_id;\n\tBNX2X_DEV_INFO(\"chip ID is 0x%x\\n\", id);\n\n\tval = (REG_RD(bp, 0x2874) & 0x55);\n\tif ((bp->common.chip_id & 0x1) ||\n\t    (CHIP_IS_E1(bp) && val) || (CHIP_IS_E1H(bp) && (val == 0x55))) {\n\t\tbp->flags |= ONE_PORT_FLAG;\n\t\tBNX2X_DEV_INFO(\"single port device\\n\");\n\t}\n\n\tval = REG_RD(bp, MCP_REG_MCPR_NVM_CFG4);\n\tbp->common.flash_size = (BNX2X_NVRAM_1MB_SIZE <<\n\t\t\t\t (val & MCPR_NVM_CFG4_FLASH_SIZE));\n\tBNX2X_DEV_INFO(\"flash_size 0x%x (%d)\\n\",\n\t\t       bp->common.flash_size, bp->common.flash_size);\n\n\tbnx2x_init_shmem(bp);\n\n\tbp->common.shmem2_base = REG_RD(bp, (BP_PATH(bp) ?\n\t\t\t\t\tMISC_REG_GENERIC_CR_1 :\n\t\t\t\t\tMISC_REG_GENERIC_CR_0));\n\n\tbp->link_params.shmem_base = bp->common.shmem_base;\n\tbp->link_params.shmem2_base = bp->common.shmem2_base;\n\tif (SHMEM2_RD(bp, size) >\n\t    (u32)offsetof(struct shmem2_region, lfa_host_addr[BP_PORT(bp)]))\n\t\tbp->link_params.lfa_base =\n\t\tREG_RD(bp, bp->common.shmem2_base +\n\t\t       (u32)offsetof(struct shmem2_region,\n\t\t\t\t     lfa_host_addr[BP_PORT(bp)]));\n\telse\n\t\tbp->link_params.lfa_base = 0;\n\tBNX2X_DEV_INFO(\"shmem offset 0x%x  shmem2 offset 0x%x\\n\",\n\t\t       bp->common.shmem_base, bp->common.shmem2_base);\n\n\tif (!bp->common.shmem_base) {\n\t\tBNX2X_DEV_INFO(\"MCP not active\\n\");\n\t\tbp->flags |= NO_MCP_FLAG;\n\t\treturn;\n\t}\n\n\tbp->common.hw_config = SHMEM_RD(bp, dev_info.shared_hw_config.config);\n\tBNX2X_DEV_INFO(\"hw_config 0x%08x\\n\", bp->common.hw_config);\n\n\tbp->link_params.hw_led_mode = ((bp->common.hw_config &\n\t\t\t\t\tSHARED_HW_CFG_LED_MODE_MASK) >>\n\t\t\t\t       SHARED_HW_CFG_LED_MODE_SHIFT);\n\n\tbp->link_params.feature_config_flags = 0;\n\tval = SHMEM_RD(bp, dev_info.shared_feature_config.config);\n\tif (val & SHARED_FEAT_CFG_OVERRIDE_PREEMPHASIS_CFG_ENABLED)\n\t\tbp->link_params.feature_config_flags |=\n\t\t\t\tFEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED;\n\telse\n\t\tbp->link_params.feature_config_flags &=\n\t\t\t\t~FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED;\n\n\tval = SHMEM_RD(bp, dev_info.bc_rev) >> 8;\n\tbp->common.bc_ver = val;\n\tBNX2X_DEV_INFO(\"bc_ver %X\\n\", val);\n\tif (val < BNX2X_BC_VER) {\n\t\t/* for now only warn\n\t\t * later we might need to enforce this */\n\t\tBNX2X_ERR(\"This driver needs bc_ver %X but found %X, please upgrade BC\\n\",\n\t\t\t  BNX2X_BC_VER, val);\n\t}\n\tbp->link_params.feature_config_flags |=\n\t\t\t\t(val >= REQ_BC_VER_4_VRFY_FIRST_PHY_OPT_MDL) ?\n\t\t\t\tFEATURE_CONFIG_BC_SUPPORTS_OPT_MDL_VRFY : 0;\n\n\tbp->link_params.feature_config_flags |=\n\t\t(val >= REQ_BC_VER_4_VRFY_SPECIFIC_PHY_OPT_MDL) ?\n\t\tFEATURE_CONFIG_BC_SUPPORTS_DUAL_PHY_OPT_MDL_VRFY : 0;\n\tbp->link_params.feature_config_flags |=\n\t\t(val >= REQ_BC_VER_4_VRFY_AFEX_SUPPORTED) ?\n\t\tFEATURE_CONFIG_BC_SUPPORTS_AFEX : 0;\n\tbp->link_params.feature_config_flags |=\n\t\t(val >= REQ_BC_VER_4_SFP_TX_DISABLE_SUPPORTED) ?\n\t\tFEATURE_CONFIG_BC_SUPPORTS_SFP_TX_DISABLED : 0;\n\n\tbp->link_params.feature_config_flags |=\n\t\t(val >= REQ_BC_VER_4_MT_SUPPORTED) ?\n\t\tFEATURE_CONFIG_MT_SUPPORT : 0;\n\n\tbp->flags |= (val >= REQ_BC_VER_4_PFC_STATS_SUPPORTED) ?\n\t\t\tBC_SUPPORTS_PFC_STATS : 0;\n\n\tbp->flags |= (val >= REQ_BC_VER_4_FCOE_FEATURES) ?\n\t\t\tBC_SUPPORTS_FCOE_FEATURES : 0;\n\n\tbp->flags |= (val >= REQ_BC_VER_4_DCBX_ADMIN_MSG_NON_PMF) ?\n\t\t\tBC_SUPPORTS_DCBX_MSG_NON_PMF : 0;\n\n\tbp->flags |= (val >= REQ_BC_VER_4_RMMOD_CMD) ?\n\t\t\tBC_SUPPORTS_RMMOD_CMD : 0;\n\n\tboot_mode = SHMEM_RD(bp,\n\t\t\tdev_info.port_feature_config[BP_PORT(bp)].mba_config) &\n\t\t\tPORT_FEATURE_MBA_BOOT_AGENT_TYPE_MASK;\n\tswitch (boot_mode) {\n\tcase PORT_FEATURE_MBA_BOOT_AGENT_TYPE_PXE:\n\t\tbp->common.boot_mode = FEATURE_ETH_BOOTMODE_PXE;\n\t\tbreak;\n\tcase PORT_FEATURE_MBA_BOOT_AGENT_TYPE_ISCSIB:\n\t\tbp->common.boot_mode = FEATURE_ETH_BOOTMODE_ISCSI;\n\t\tbreak;\n\tcase PORT_FEATURE_MBA_BOOT_AGENT_TYPE_FCOE_BOOT:\n\t\tbp->common.boot_mode = FEATURE_ETH_BOOTMODE_FCOE;\n\t\tbreak;\n\tcase PORT_FEATURE_MBA_BOOT_AGENT_TYPE_NONE:\n\t\tbp->common.boot_mode = FEATURE_ETH_BOOTMODE_NONE;\n\t\tbreak;\n\t}\n\n\tpci_read_config_word(bp->pdev, bp->pdev->pm_cap + PCI_PM_PMC, &pmc);\n\tbp->flags |= (pmc & PCI_PM_CAP_PME_D3cold) ? 0 : NO_WOL_FLAG;\n\n\tBNX2X_DEV_INFO(\"%sWoL capable\\n\",\n\t\t       (bp->flags & NO_WOL_FLAG) ? \"not \" : \"\");\n\n\tval = SHMEM_RD(bp, dev_info.shared_hw_config.part_num);\n\tval2 = SHMEM_RD(bp, dev_info.shared_hw_config.part_num[4]);\n\tval3 = SHMEM_RD(bp, dev_info.shared_hw_config.part_num[8]);\n\tval4 = SHMEM_RD(bp, dev_info.shared_hw_config.part_num[12]);\n\n\tdev_info(&bp->pdev->dev, \"part number %X-%X-%X-%X\\n\",\n\t\t val, val2, val3, val4);\n}\n\n#define IGU_FID(val)\tGET_FIELD((val), IGU_REG_MAPPING_MEMORY_FID)\n#define IGU_VEC(val)\tGET_FIELD((val), IGU_REG_MAPPING_MEMORY_VECTOR)\n\nstatic int bnx2x_get_igu_cam_info(struct bnx2x *bp)\n{\n\tint pfid = BP_FUNC(bp);\n\tint igu_sb_id;\n\tu32 val;\n\tu8 fid, igu_sb_cnt = 0;\n\n\tbp->igu_base_sb = 0xff;\n\tif (CHIP_INT_MODE_IS_BC(bp)) {\n\t\tint vn = BP_VN(bp);\n\t\tigu_sb_cnt = bp->igu_sb_cnt;\n\t\tbp->igu_base_sb = (CHIP_MODE_IS_4_PORT(bp) ? pfid : vn) *\n\t\t\tFP_SB_MAX_E1x;\n\n\t\tbp->igu_dsb_id =  E1HVN_MAX * FP_SB_MAX_E1x +\n\t\t\t(CHIP_MODE_IS_4_PORT(bp) ? pfid : vn);\n\n\t\treturn 0;\n\t}\n\n\t/* IGU in normal mode - read CAM */\n\tfor (igu_sb_id = 0; igu_sb_id < IGU_REG_MAPPING_MEMORY_SIZE;\n\t     igu_sb_id++) {\n\t\tval = REG_RD(bp, IGU_REG_MAPPING_MEMORY + igu_sb_id * 4);\n\t\tif (!(val & IGU_REG_MAPPING_MEMORY_VALID))\n\t\t\tcontinue;\n\t\tfid = IGU_FID(val);\n\t\tif ((fid & IGU_FID_ENCODE_IS_PF)) {\n\t\t\tif ((fid & IGU_FID_PF_NUM_MASK) != pfid)\n\t\t\t\tcontinue;\n\t\t\tif (IGU_VEC(val) == 0)\n\t\t\t\t/* default status block */\n\t\t\t\tbp->igu_dsb_id = igu_sb_id;\n\t\t\telse {\n\t\t\t\tif (bp->igu_base_sb == 0xff)\n\t\t\t\t\tbp->igu_base_sb = igu_sb_id;\n\t\t\t\tigu_sb_cnt++;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef CONFIG_PCI_MSI\n\t/* Due to new PF resource allocation by MFW T7.4 and above, it's\n\t * optional that number of CAM entries will not be equal to the value\n\t * advertised in PCI.\n\t * Driver should use the minimal value of both as the actual status\n\t * block count\n\t */\n\tbp->igu_sb_cnt = min_t(int, bp->igu_sb_cnt, igu_sb_cnt);\n#endif\n\n\tif (igu_sb_cnt == 0) {\n\t\tBNX2X_ERR(\"CAM configuration error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void bnx2x_link_settings_supported(struct bnx2x *bp, u32 switch_cfg)\n{\n\tint cfg_size = 0, idx, port = BP_PORT(bp);\n\n\t/* Aggregation of supported attributes of all external phys */\n\tbp->port.supported[0] = 0;\n\tbp->port.supported[1] = 0;\n\tswitch (bp->link_params.num_phys) {\n\tcase 1:\n\t\tbp->port.supported[0] = bp->link_params.phy[INT_PHY].supported;\n\t\tcfg_size = 1;\n\t\tbreak;\n\tcase 2:\n\t\tbp->port.supported[0] = bp->link_params.phy[EXT_PHY1].supported;\n\t\tcfg_size = 1;\n\t\tbreak;\n\tcase 3:\n\t\tif (bp->link_params.multi_phy_config &\n\t\t    PORT_HW_CFG_PHY_SWAPPED_ENABLED) {\n\t\t\tbp->port.supported[1] =\n\t\t\t\tbp->link_params.phy[EXT_PHY1].supported;\n\t\t\tbp->port.supported[0] =\n\t\t\t\tbp->link_params.phy[EXT_PHY2].supported;\n\t\t} else {\n\t\t\tbp->port.supported[0] =\n\t\t\t\tbp->link_params.phy[EXT_PHY1].supported;\n\t\t\tbp->port.supported[1] =\n\t\t\t\tbp->link_params.phy[EXT_PHY2].supported;\n\t\t}\n\t\tcfg_size = 2;\n\t\tbreak;\n\t}\n\n\tif (!(bp->port.supported[0] || bp->port.supported[1])) {\n\t\tBNX2X_ERR(\"NVRAM config error. BAD phy config. PHY1 config 0x%x, PHY2 config 0x%x\\n\",\n\t\t\t   SHMEM_RD(bp,\n\t\t\t   dev_info.port_hw_config[port].external_phy_config),\n\t\t\t   SHMEM_RD(bp,\n\t\t\t   dev_info.port_hw_config[port].external_phy_config2));\n\t\treturn;\n\t}\n\n\tif (CHIP_IS_E3(bp))\n\t\tbp->port.phy_addr = REG_RD(bp, MISC_REG_WC0_CTRL_PHY_ADDR);\n\telse {\n\t\tswitch (switch_cfg) {\n\t\tcase SWITCH_CFG_1G:\n\t\t\tbp->port.phy_addr = REG_RD(\n\t\t\t\tbp, NIG_REG_SERDES0_CTRL_PHY_ADDR + port*0x10);\n\t\t\tbreak;\n\t\tcase SWITCH_CFG_10G:\n\t\t\tbp->port.phy_addr = REG_RD(\n\t\t\t\tbp, NIG_REG_XGXS0_CTRL_PHY_ADDR + port*0x18);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBNX2X_ERR(\"BAD switch_cfg link_config 0x%x\\n\",\n\t\t\t\t  bp->port.link_config[0]);\n\t\t\treturn;\n\t\t}\n\t}\n\tBNX2X_DEV_INFO(\"phy_addr 0x%x\\n\", bp->port.phy_addr);\n\t/* mask what we support according to speed_cap_mask per configuration */\n\tfor (idx = 0; idx < cfg_size; idx++) {\n\t\tif (!(bp->link_params.speed_cap_mask[idx] &\n\t\t\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF))\n\t\t\tbp->port.supported[idx] &= ~SUPPORTED_10baseT_Half;\n\n\t\tif (!(bp->link_params.speed_cap_mask[idx] &\n\t\t\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL))\n\t\t\tbp->port.supported[idx] &= ~SUPPORTED_10baseT_Full;\n\n\t\tif (!(bp->link_params.speed_cap_mask[idx] &\n\t\t\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF))\n\t\t\tbp->port.supported[idx] &= ~SUPPORTED_100baseT_Half;\n\n\t\tif (!(bp->link_params.speed_cap_mask[idx] &\n\t\t\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL))\n\t\t\tbp->port.supported[idx] &= ~SUPPORTED_100baseT_Full;\n\n\t\tif (!(bp->link_params.speed_cap_mask[idx] &\n\t\t\t\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_1G))\n\t\t\tbp->port.supported[idx] &= ~(SUPPORTED_1000baseT_Half |\n\t\t\t\t\t\t     SUPPORTED_1000baseT_Full);\n\n\t\tif (!(bp->link_params.speed_cap_mask[idx] &\n\t\t\t\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G))\n\t\t\tbp->port.supported[idx] &= ~SUPPORTED_2500baseX_Full;\n\n\t\tif (!(bp->link_params.speed_cap_mask[idx] &\n\t\t\t\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_10G))\n\t\t\tbp->port.supported[idx] &= ~SUPPORTED_10000baseT_Full;\n\n\t\tif (!(bp->link_params.speed_cap_mask[idx] &\n\t\t\t\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_20G))\n\t\t\tbp->port.supported[idx] &= ~SUPPORTED_20000baseKR2_Full;\n\t}\n\n\tBNX2X_DEV_INFO(\"supported 0x%x 0x%x\\n\", bp->port.supported[0],\n\t\t       bp->port.supported[1]);\n}\n\nstatic void bnx2x_link_settings_requested(struct bnx2x *bp)\n{\n\tu32 link_config, idx, cfg_size = 0;\n\tbp->port.advertising[0] = 0;\n\tbp->port.advertising[1] = 0;\n\tswitch (bp->link_params.num_phys) {\n\tcase 1:\n\tcase 2:\n\t\tcfg_size = 1;\n\t\tbreak;\n\tcase 3:\n\t\tcfg_size = 2;\n\t\tbreak;\n\t}\n\tfor (idx = 0; idx < cfg_size; idx++) {\n\t\tbp->link_params.req_duplex[idx] = DUPLEX_FULL;\n\t\tlink_config = bp->port.link_config[idx];\n\t\tswitch (link_config & PORT_FEATURE_LINK_SPEED_MASK) {\n\t\tcase PORT_FEATURE_LINK_SPEED_AUTO:\n\t\t\tif (bp->port.supported[idx] & SUPPORTED_Autoneg) {\n\t\t\t\tbp->link_params.req_line_speed[idx] =\n\t\t\t\t\tSPEED_AUTO_NEG;\n\t\t\t\tbp->port.advertising[idx] |=\n\t\t\t\t\tbp->port.supported[idx];\n\t\t\t\tif (bp->link_params.phy[EXT_PHY1].type ==\n\t\t\t\t    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833)\n\t\t\t\t\tbp->port.advertising[idx] |=\n\t\t\t\t\t(SUPPORTED_100baseT_Half |\n\t\t\t\t\t SUPPORTED_100baseT_Full);\n\t\t\t} else {\n\t\t\t\t/* force 10G, no AN */\n\t\t\t\tbp->link_params.req_line_speed[idx] =\n\t\t\t\t\tSPEED_10000;\n\t\t\t\tbp->port.advertising[idx] |=\n\t\t\t\t\t(ADVERTISED_10000baseT_Full |\n\t\t\t\t\t ADVERTISED_FIBRE);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PORT_FEATURE_LINK_SPEED_10M_FULL:\n\t\t\tif (bp->port.supported[idx] & SUPPORTED_10baseT_Full) {\n\t\t\t\tbp->link_params.req_line_speed[idx] =\n\t\t\t\t\tSPEED_10;\n\t\t\t\tbp->port.advertising[idx] |=\n\t\t\t\t\t(ADVERTISED_10baseT_Full |\n\t\t\t\t\t ADVERTISED_TP);\n\t\t\t} else {\n\t\t\t\tBNX2X_ERR(\"NVRAM config error. Invalid link_config 0x%x  speed_cap_mask 0x%x\\n\",\n\t\t\t\t\t    link_config,\n\t\t\t\t    bp->link_params.speed_cap_mask[idx]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PORT_FEATURE_LINK_SPEED_10M_HALF:\n\t\t\tif (bp->port.supported[idx] & SUPPORTED_10baseT_Half) {\n\t\t\t\tbp->link_params.req_line_speed[idx] =\n\t\t\t\t\tSPEED_10;\n\t\t\t\tbp->link_params.req_duplex[idx] =\n\t\t\t\t\tDUPLEX_HALF;\n\t\t\t\tbp->port.advertising[idx] |=\n\t\t\t\t\t(ADVERTISED_10baseT_Half |\n\t\t\t\t\t ADVERTISED_TP);\n\t\t\t} else {\n\t\t\t\tBNX2X_ERR(\"NVRAM config error. Invalid link_config 0x%x  speed_cap_mask 0x%x\\n\",\n\t\t\t\t\t    link_config,\n\t\t\t\t\t  bp->link_params.speed_cap_mask[idx]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PORT_FEATURE_LINK_SPEED_100M_FULL:\n\t\t\tif (bp->port.supported[idx] &\n\t\t\t    SUPPORTED_100baseT_Full) {\n\t\t\t\tbp->link_params.req_line_speed[idx] =\n\t\t\t\t\tSPEED_100;\n\t\t\t\tbp->port.advertising[idx] |=\n\t\t\t\t\t(ADVERTISED_100baseT_Full |\n\t\t\t\t\t ADVERTISED_TP);\n\t\t\t} else {\n\t\t\t\tBNX2X_ERR(\"NVRAM config error. Invalid link_config 0x%x  speed_cap_mask 0x%x\\n\",\n\t\t\t\t\t    link_config,\n\t\t\t\t\t  bp->link_params.speed_cap_mask[idx]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PORT_FEATURE_LINK_SPEED_100M_HALF:\n\t\t\tif (bp->port.supported[idx] &\n\t\t\t    SUPPORTED_100baseT_Half) {\n\t\t\t\tbp->link_params.req_line_speed[idx] =\n\t\t\t\t\t\t\t\tSPEED_100;\n\t\t\t\tbp->link_params.req_duplex[idx] =\n\t\t\t\t\t\t\t\tDUPLEX_HALF;\n\t\t\t\tbp->port.advertising[idx] |=\n\t\t\t\t\t(ADVERTISED_100baseT_Half |\n\t\t\t\t\t ADVERTISED_TP);\n\t\t\t} else {\n\t\t\t\tBNX2X_ERR(\"NVRAM config error. Invalid link_config 0x%x  speed_cap_mask 0x%x\\n\",\n\t\t\t\t    link_config,\n\t\t\t\t    bp->link_params.speed_cap_mask[idx]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PORT_FEATURE_LINK_SPEED_1G:\n\t\t\tif (bp->port.supported[idx] &\n\t\t\t    SUPPORTED_1000baseT_Full) {\n\t\t\t\tbp->link_params.req_line_speed[idx] =\n\t\t\t\t\tSPEED_1000;\n\t\t\t\tbp->port.advertising[idx] |=\n\t\t\t\t\t(ADVERTISED_1000baseT_Full |\n\t\t\t\t\t ADVERTISED_TP);\n\t\t\t} else if (bp->port.supported[idx] &\n\t\t\t\t   SUPPORTED_1000baseKX_Full) {\n\t\t\t\tbp->link_params.req_line_speed[idx] =\n\t\t\t\t\tSPEED_1000;\n\t\t\t\tbp->port.advertising[idx] |=\n\t\t\t\t\tADVERTISED_1000baseKX_Full;\n\t\t\t} else {\n\t\t\t\tBNX2X_ERR(\"NVRAM config error. Invalid link_config 0x%x  speed_cap_mask 0x%x\\n\",\n\t\t\t\t    link_config,\n\t\t\t\t    bp->link_params.speed_cap_mask[idx]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PORT_FEATURE_LINK_SPEED_2_5G:\n\t\t\tif (bp->port.supported[idx] &\n\t\t\t    SUPPORTED_2500baseX_Full) {\n\t\t\t\tbp->link_params.req_line_speed[idx] =\n\t\t\t\t\tSPEED_2500;\n\t\t\t\tbp->port.advertising[idx] |=\n\t\t\t\t\t(ADVERTISED_2500baseX_Full |\n\t\t\t\t\t\tADVERTISED_TP);\n\t\t\t} else {\n\t\t\t\tBNX2X_ERR(\"NVRAM config error. Invalid link_config 0x%x  speed_cap_mask 0x%x\\n\",\n\t\t\t\t    link_config,\n\t\t\t\t    bp->link_params.speed_cap_mask[idx]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PORT_FEATURE_LINK_SPEED_10G_CX4:\n\t\t\tif (bp->port.supported[idx] &\n\t\t\t    SUPPORTED_10000baseT_Full) {\n\t\t\t\tbp->link_params.req_line_speed[idx] =\n\t\t\t\t\tSPEED_10000;\n\t\t\t\tbp->port.advertising[idx] |=\n\t\t\t\t\t(ADVERTISED_10000baseT_Full |\n\t\t\t\t\t\tADVERTISED_FIBRE);\n\t\t\t} else if (bp->port.supported[idx] &\n\t\t\t\t   SUPPORTED_10000baseKR_Full) {\n\t\t\t\tbp->link_params.req_line_speed[idx] =\n\t\t\t\t\tSPEED_10000;\n\t\t\t\tbp->port.advertising[idx] |=\n\t\t\t\t\t(ADVERTISED_10000baseKR_Full |\n\t\t\t\t\t\tADVERTISED_FIBRE);\n\t\t\t} else {\n\t\t\t\tBNX2X_ERR(\"NVRAM config error. Invalid link_config 0x%x  speed_cap_mask 0x%x\\n\",\n\t\t\t\t    link_config,\n\t\t\t\t    bp->link_params.speed_cap_mask[idx]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PORT_FEATURE_LINK_SPEED_20G:\n\t\t\tbp->link_params.req_line_speed[idx] = SPEED_20000;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBNX2X_ERR(\"NVRAM config error. BAD link speed link_config 0x%x\\n\",\n\t\t\t\t  link_config);\n\t\t\t\tbp->link_params.req_line_speed[idx] =\n\t\t\t\t\t\t\tSPEED_AUTO_NEG;\n\t\t\t\tbp->port.advertising[idx] =\n\t\t\t\t\t\tbp->port.supported[idx];\n\t\t\tbreak;\n\t\t}\n\n\t\tbp->link_params.req_flow_ctrl[idx] = (link_config &\n\t\t\t\t\t PORT_FEATURE_FLOW_CONTROL_MASK);\n\t\tif (bp->link_params.req_flow_ctrl[idx] ==\n\t\t    BNX2X_FLOW_CTRL_AUTO) {\n\t\t\tif (!(bp->port.supported[idx] & SUPPORTED_Autoneg))\n\t\t\t\tbp->link_params.req_flow_ctrl[idx] =\n\t\t\t\t\t\t\tBNX2X_FLOW_CTRL_NONE;\n\t\t\telse\n\t\t\t\tbnx2x_set_requested_fc(bp);\n\t\t}\n\n\t\tBNX2X_DEV_INFO(\"req_line_speed %d  req_duplex %d req_flow_ctrl 0x%x advertising 0x%x\\n\",\n\t\t\t       bp->link_params.req_line_speed[idx],\n\t\t\t       bp->link_params.req_duplex[idx],\n\t\t\t       bp->link_params.req_flow_ctrl[idx],\n\t\t\t       bp->port.advertising[idx]);\n\t}\n}\n\nstatic void bnx2x_set_mac_buf(u8 *mac_buf, u32 mac_lo, u16 mac_hi)\n{\n\t__be16 mac_hi_be = cpu_to_be16(mac_hi);\n\t__be32 mac_lo_be = cpu_to_be32(mac_lo);\n\tmemcpy(mac_buf, &mac_hi_be, sizeof(mac_hi_be));\n\tmemcpy(mac_buf + sizeof(mac_hi_be), &mac_lo_be, sizeof(mac_lo_be));\n}\n\nstatic void bnx2x_get_port_hwinfo(struct bnx2x *bp)\n{\n\tint port = BP_PORT(bp);\n\tu32 config;\n\tu32 ext_phy_type, ext_phy_config, eee_mode;\n\n\tbp->link_params.bp = bp;\n\tbp->link_params.port = port;\n\n\tbp->link_params.lane_config =\n\t\tSHMEM_RD(bp, dev_info.port_hw_config[port].lane_config);\n\n\tbp->link_params.speed_cap_mask[0] =\n\t\tSHMEM_RD(bp,\n\t\t\t dev_info.port_hw_config[port].speed_capability_mask) &\n\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_MASK;\n\tbp->link_params.speed_cap_mask[1] =\n\t\tSHMEM_RD(bp,\n\t\t\t dev_info.port_hw_config[port].speed_capability_mask2) &\n\t\tPORT_HW_CFG_SPEED_CAPABILITY_D0_MASK;\n\tbp->port.link_config[0] =\n\t\tSHMEM_RD(bp, dev_info.port_feature_config[port].link_config);\n\n\tbp->port.link_config[1] =\n\t\tSHMEM_RD(bp, dev_info.port_feature_config[port].link_config2);\n\n\tbp->link_params.multi_phy_config =\n\t\tSHMEM_RD(bp, dev_info.port_hw_config[port].multi_phy_config);\n\t/* If the device is capable of WoL, set the default state according\n\t * to the HW\n\t */\n\tconfig = SHMEM_RD(bp, dev_info.port_feature_config[port].config);\n\tbp->wol = (!(bp->flags & NO_WOL_FLAG) &&\n\t\t   (config & PORT_FEATURE_WOL_ENABLED));\n\n\tif ((config & PORT_FEAT_CFG_STORAGE_PERSONALITY_MASK) ==\n\t    PORT_FEAT_CFG_STORAGE_PERSONALITY_FCOE && !IS_MF(bp))\n\t\tbp->flags |= NO_ISCSI_FLAG;\n\tif ((config & PORT_FEAT_CFG_STORAGE_PERSONALITY_MASK) ==\n\t    PORT_FEAT_CFG_STORAGE_PERSONALITY_ISCSI && !(IS_MF(bp)))\n\t\tbp->flags |= NO_FCOE_FLAG;\n\n\tBNX2X_DEV_INFO(\"lane_config 0x%08x  speed_cap_mask0 0x%08x  link_config0 0x%08x\\n\",\n\t\t       bp->link_params.lane_config,\n\t\t       bp->link_params.speed_cap_mask[0],\n\t\t       bp->port.link_config[0]);\n\n\tbp->link_params.switch_cfg = (bp->port.link_config[0] &\n\t\t\t\t      PORT_FEATURE_CONNECTED_SWITCH_MASK);\n\tbnx2x_phy_probe(&bp->link_params);\n\tbnx2x_link_settings_supported(bp, bp->link_params.switch_cfg);\n\n\tbnx2x_link_settings_requested(bp);\n\n\t/*\n\t * If connected directly, work with the internal PHY, otherwise, work\n\t * with the external PHY\n\t */\n\text_phy_config =\n\t\tSHMEM_RD(bp,\n\t\t\t dev_info.port_hw_config[port].external_phy_config);\n\text_phy_type = XGXS_EXT_PHY_TYPE(ext_phy_config);\n\tif (ext_phy_type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT)\n\t\tbp->mdio.prtad = bp->port.phy_addr;\n\n\telse if ((ext_phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE) &&\n\t\t (ext_phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN))\n\t\tbp->mdio.prtad =\n\t\t\tXGXS_EXT_PHY_ADDR(ext_phy_config);\n\n\t/* Configure link feature according to nvram value */\n\teee_mode = (((SHMEM_RD(bp, dev_info.\n\t\t      port_feature_config[port].eee_power_mode)) &\n\t\t     PORT_FEAT_CFG_EEE_POWER_MODE_MASK) >>\n\t\t    PORT_FEAT_CFG_EEE_POWER_MODE_SHIFT);\n\tif (eee_mode != PORT_FEAT_CFG_EEE_POWER_MODE_DISABLED) {\n\t\tbp->link_params.eee_mode = EEE_MODE_ADV_LPI |\n\t\t\t\t\t   EEE_MODE_ENABLE_LPI |\n\t\t\t\t\t   EEE_MODE_OUTPUT_TIME;\n\t} else {\n\t\tbp->link_params.eee_mode = 0;\n\t}\n}\n\nvoid bnx2x_get_iscsi_info(struct bnx2x *bp)\n{\n\tu32 no_flags = NO_ISCSI_FLAG;\n\tint port = BP_PORT(bp);\n\tu32 max_iscsi_conn = FW_ENCODE_32BIT_PATTERN ^ SHMEM_RD(bp,\n\t\t\t\tdrv_lic_key[port].max_iscsi_conn);\n\n\tif (!CNIC_SUPPORT(bp)) {\n\t\tbp->flags |= no_flags;\n\t\treturn;\n\t}\n\n\t/* Get the number of maximum allowed iSCSI connections */\n\tbp->cnic_eth_dev.max_iscsi_conn =\n\t\t(max_iscsi_conn & BNX2X_MAX_ISCSI_INIT_CONN_MASK) >>\n\t\tBNX2X_MAX_ISCSI_INIT_CONN_SHIFT;\n\n\tBNX2X_DEV_INFO(\"max_iscsi_conn 0x%x\\n\",\n\t\t       bp->cnic_eth_dev.max_iscsi_conn);\n\n\t/*\n\t * If maximum allowed number of connections is zero -\n\t * disable the feature.\n\t */\n\tif (!bp->cnic_eth_dev.max_iscsi_conn)\n\t\tbp->flags |= no_flags;\n}\n\nstatic void bnx2x_get_ext_wwn_info(struct bnx2x *bp, int func)\n{\n\t/* Port info */\n\tbp->cnic_eth_dev.fcoe_wwn_port_name_hi =\n\t\tMF_CFG_RD(bp, func_ext_config[func].fcoe_wwn_port_name_upper);\n\tbp->cnic_eth_dev.fcoe_wwn_port_name_lo =\n\t\tMF_CFG_RD(bp, func_ext_config[func].fcoe_wwn_port_name_lower);\n\n\t/* Node info */\n\tbp->cnic_eth_dev.fcoe_wwn_node_name_hi =\n\t\tMF_CFG_RD(bp, func_ext_config[func].fcoe_wwn_node_name_upper);\n\tbp->cnic_eth_dev.fcoe_wwn_node_name_lo =\n\t\tMF_CFG_RD(bp, func_ext_config[func].fcoe_wwn_node_name_lower);\n}\n\nstatic int bnx2x_shared_fcoe_funcs(struct bnx2x *bp)\n{\n\tu8 count = 0;\n\n\tif (IS_MF(bp)) {\n\t\tu8 fid;\n\n\t\t/* iterate over absolute function ids for this path: */\n\t\tfor (fid = BP_PATH(bp); fid < E2_FUNC_MAX * 2; fid += 2) {\n\t\t\tif (IS_MF_SD(bp)) {\n\t\t\t\tu32 cfg = MF_CFG_RD(bp,\n\t\t\t\t\t\t    func_mf_config[fid].config);\n\n\t\t\t\tif (!(cfg & FUNC_MF_CFG_FUNC_HIDE) &&\n\t\t\t\t    ((cfg & FUNC_MF_CFG_PROTOCOL_MASK) ==\n\t\t\t\t\t    FUNC_MF_CFG_PROTOCOL_FCOE))\n\t\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\tu32 cfg = MF_CFG_RD(bp,\n\t\t\t\t\t\t    func_ext_config[fid].\n\t\t\t\t\t\t\t\t      func_cfg);\n\n\t\t\t\tif ((cfg & MACP_FUNC_CFG_FLAGS_ENABLED) &&\n\t\t\t\t    (cfg & MACP_FUNC_CFG_FLAGS_FCOE_OFFLOAD))\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t} else { /* SF */\n\t\tint port, port_cnt = CHIP_MODE_IS_4_PORT(bp) ? 2 : 1;\n\n\t\tfor (port = 0; port < port_cnt; port++) {\n\t\t\tu32 lic = SHMEM_RD(bp,\n\t\t\t\t\t   drv_lic_key[port].max_fcoe_conn) ^\n\t\t\t\t  FW_ENCODE_32BIT_PATTERN;\n\t\t\tif (lic)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n}\n\nstatic void bnx2x_get_fcoe_info(struct bnx2x *bp)\n{\n\tint port = BP_PORT(bp);\n\tint func = BP_ABS_FUNC(bp);\n\tu32 max_fcoe_conn = FW_ENCODE_32BIT_PATTERN ^ SHMEM_RD(bp,\n\t\t\t\tdrv_lic_key[port].max_fcoe_conn);\n\tu8 num_fcoe_func = bnx2x_shared_fcoe_funcs(bp);\n\n\tif (!CNIC_SUPPORT(bp)) {\n\t\tbp->flags |= NO_FCOE_FLAG;\n\t\treturn;\n\t}\n\n\t/* Get the number of maximum allowed FCoE connections */\n\tbp->cnic_eth_dev.max_fcoe_conn =\n\t\t(max_fcoe_conn & BNX2X_MAX_FCOE_INIT_CONN_MASK) >>\n\t\tBNX2X_MAX_FCOE_INIT_CONN_SHIFT;\n\n\t/* Calculate the number of maximum allowed FCoE tasks */\n\tbp->cnic_eth_dev.max_fcoe_exchanges = MAX_NUM_FCOE_TASKS_PER_ENGINE;\n\n\t/* check if FCoE resources must be shared between different functions */\n\tif (num_fcoe_func)\n\t\tbp->cnic_eth_dev.max_fcoe_exchanges /= num_fcoe_func;\n\n\t/* Read the WWN: */\n\tif (!IS_MF(bp)) {\n\t\t/* Port info */\n\t\tbp->cnic_eth_dev.fcoe_wwn_port_name_hi =\n\t\t\tSHMEM_RD(bp,\n\t\t\t\t dev_info.port_hw_config[port].\n\t\t\t\t fcoe_wwn_port_name_upper);\n\t\tbp->cnic_eth_dev.fcoe_wwn_port_name_lo =\n\t\t\tSHMEM_RD(bp,\n\t\t\t\t dev_info.port_hw_config[port].\n\t\t\t\t fcoe_wwn_port_name_lower);\n\n\t\t/* Node info */\n\t\tbp->cnic_eth_dev.fcoe_wwn_node_name_hi =\n\t\t\tSHMEM_RD(bp,\n\t\t\t\t dev_info.port_hw_config[port].\n\t\t\t\t fcoe_wwn_node_name_upper);\n\t\tbp->cnic_eth_dev.fcoe_wwn_node_name_lo =\n\t\t\tSHMEM_RD(bp,\n\t\t\t\t dev_info.port_hw_config[port].\n\t\t\t\t fcoe_wwn_node_name_lower);\n\t} else if (!IS_MF_SD(bp)) {\n\t\t/* Read the WWN info only if the FCoE feature is enabled for\n\t\t * this function.\n\t\t */\n\t\tif (BNX2X_HAS_MF_EXT_PROTOCOL_FCOE(bp))\n\t\t\tbnx2x_get_ext_wwn_info(bp, func);\n\t} else {\n\t\tif (BNX2X_IS_MF_SD_PROTOCOL_FCOE(bp) && !CHIP_IS_E1x(bp))\n\t\t\tbnx2x_get_ext_wwn_info(bp, func);\n\t}\n\n\tBNX2X_DEV_INFO(\"max_fcoe_conn 0x%x\\n\", bp->cnic_eth_dev.max_fcoe_conn);\n\n\t/*\n\t * If maximum allowed number of connections is zero -\n\t * disable the feature.\n\t */\n\tif (!bp->cnic_eth_dev.max_fcoe_conn) {\n\t\tbp->flags |= NO_FCOE_FLAG;\n\t\teth_zero_addr(bp->fip_mac);\n\t}\n}\n\nstatic void bnx2x_get_cnic_info(struct bnx2x *bp)\n{\n\t/*\n\t * iSCSI may be dynamically disabled but reading\n\t * info here we will decrease memory usage by driver\n\t * if the feature is disabled for good\n\t */\n\tbnx2x_get_iscsi_info(bp);\n\tbnx2x_get_fcoe_info(bp);\n}\n\nstatic void bnx2x_get_cnic_mac_hwinfo(struct bnx2x *bp)\n{\n\tu32 val, val2;\n\tint func = BP_ABS_FUNC(bp);\n\tint port = BP_PORT(bp);\n\tu8 *iscsi_mac = bp->cnic_eth_dev.iscsi_mac;\n\tu8 *fip_mac = bp->fip_mac;\n\n\tif (IS_MF(bp)) {\n\t\t/* iSCSI and FCoE NPAR MACs: if there is no either iSCSI or\n\t\t * FCoE MAC then the appropriate feature should be disabled.\n\t\t * In non SD mode features configuration comes from struct\n\t\t * func_ext_config.\n\t\t */\n\t\tif (!IS_MF_SD(bp)) {\n\t\t\tu32 cfg = MF_CFG_RD(bp, func_ext_config[func].func_cfg);\n\t\t\tif (cfg & MACP_FUNC_CFG_FLAGS_ISCSI_OFFLOAD) {\n\t\t\t\tval2 = MF_CFG_RD(bp, func_ext_config[func].\n\t\t\t\t\t\t iscsi_mac_addr_upper);\n\t\t\t\tval = MF_CFG_RD(bp, func_ext_config[func].\n\t\t\t\t\t\tiscsi_mac_addr_lower);\n\t\t\t\tbnx2x_set_mac_buf(iscsi_mac, val, val2);\n\t\t\t\tBNX2X_DEV_INFO\n\t\t\t\t\t(\"Read iSCSI MAC: %pM\\n\", iscsi_mac);\n\t\t\t} else {\n\t\t\t\tbp->flags |= NO_ISCSI_OOO_FLAG | NO_ISCSI_FLAG;\n\t\t\t}\n\n\t\t\tif (cfg & MACP_FUNC_CFG_FLAGS_FCOE_OFFLOAD) {\n\t\t\t\tval2 = MF_CFG_RD(bp, func_ext_config[func].\n\t\t\t\t\t\t fcoe_mac_addr_upper);\n\t\t\t\tval = MF_CFG_RD(bp, func_ext_config[func].\n\t\t\t\t\t\tfcoe_mac_addr_lower);\n\t\t\t\tbnx2x_set_mac_buf(fip_mac, val, val2);\n\t\t\t\tBNX2X_DEV_INFO\n\t\t\t\t\t(\"Read FCoE L2 MAC: %pM\\n\", fip_mac);\n\t\t\t} else {\n\t\t\t\tbp->flags |= NO_FCOE_FLAG;\n\t\t\t}\n\n\t\t\tbp->mf_ext_config = cfg;\n\n\t\t} else { /* SD MODE */\n\t\t\tif (BNX2X_IS_MF_SD_PROTOCOL_ISCSI(bp)) {\n\t\t\t\t/* use primary mac as iscsi mac */\n\t\t\t\tmemcpy(iscsi_mac, bp->dev->dev_addr, ETH_ALEN);\n\n\t\t\t\tBNX2X_DEV_INFO(\"SD ISCSI MODE\\n\");\n\t\t\t\tBNX2X_DEV_INFO\n\t\t\t\t\t(\"Read iSCSI MAC: %pM\\n\", iscsi_mac);\n\t\t\t} else if (BNX2X_IS_MF_SD_PROTOCOL_FCOE(bp)) {\n\t\t\t\t/* use primary mac as fip mac */\n\t\t\t\tmemcpy(fip_mac, bp->dev->dev_addr, ETH_ALEN);\n\t\t\t\tBNX2X_DEV_INFO(\"SD FCoE MODE\\n\");\n\t\t\t\tBNX2X_DEV_INFO\n\t\t\t\t\t(\"Read FIP MAC: %pM\\n\", fip_mac);\n\t\t\t}\n\t\t}\n\n\t\t/* If this is a storage-only interface, use SAN mac as\n\t\t * primary MAC. Notice that for SD this is already the case,\n\t\t * as the SAN mac was copied from the primary MAC.\n\t\t */\n\t\tif (IS_MF_FCOE_AFEX(bp))\n\t\t\tmemcpy(bp->dev->dev_addr, fip_mac, ETH_ALEN);\n\t} else {\n\t\tval2 = SHMEM_RD(bp, dev_info.port_hw_config[port].\n\t\t\t\tiscsi_mac_upper);\n\t\tval = SHMEM_RD(bp, dev_info.port_hw_config[port].\n\t\t\t       iscsi_mac_lower);\n\t\tbnx2x_set_mac_buf(iscsi_mac, val, val2);\n\n\t\tval2 = SHMEM_RD(bp, dev_info.port_hw_config[port].\n\t\t\t\tfcoe_fip_mac_upper);\n\t\tval = SHMEM_RD(bp, dev_info.port_hw_config[port].\n\t\t\t       fcoe_fip_mac_lower);\n\t\tbnx2x_set_mac_buf(fip_mac, val, val2);\n\t}\n\n\t/* Disable iSCSI OOO if MAC configuration is invalid. */\n\tif (!is_valid_ether_addr(iscsi_mac)) {\n\t\tbp->flags |= NO_ISCSI_OOO_FLAG | NO_ISCSI_FLAG;\n\t\teth_zero_addr(iscsi_mac);\n\t}\n\n\t/* Disable FCoE if MAC configuration is invalid. */\n\tif (!is_valid_ether_addr(fip_mac)) {\n\t\tbp->flags |= NO_FCOE_FLAG;\n\t\teth_zero_addr(bp->fip_mac);\n\t}\n}\n\nstatic void bnx2x_get_mac_hwinfo(struct bnx2x *bp)\n{\n\tu32 val, val2;\n\tint func = BP_ABS_FUNC(bp);\n\tint port = BP_PORT(bp);\n\n\t/* Zero primary MAC configuration */\n\teth_zero_addr(bp->dev->dev_addr);\n\n\tif (BP_NOMCP(bp)) {\n\t\tBNX2X_ERROR(\"warning: random MAC workaround active\\n\");\n\t\teth_hw_addr_random(bp->dev);\n\t} else if (IS_MF(bp)) {\n\t\tval2 = MF_CFG_RD(bp, func_mf_config[func].mac_upper);\n\t\tval = MF_CFG_RD(bp, func_mf_config[func].mac_lower);\n\t\tif ((val2 != FUNC_MF_CFG_UPPERMAC_DEFAULT) &&\n\t\t    (val != FUNC_MF_CFG_LOWERMAC_DEFAULT))\n\t\t\tbnx2x_set_mac_buf(bp->dev->dev_addr, val, val2);\n\n\t\tif (CNIC_SUPPORT(bp))\n\t\t\tbnx2x_get_cnic_mac_hwinfo(bp);\n\t} else {\n\t\t/* in SF read MACs from port configuration */\n\t\tval2 = SHMEM_RD(bp, dev_info.port_hw_config[port].mac_upper);\n\t\tval = SHMEM_RD(bp, dev_info.port_hw_config[port].mac_lower);\n\t\tbnx2x_set_mac_buf(bp->dev->dev_addr, val, val2);\n\n\t\tif (CNIC_SUPPORT(bp))\n\t\t\tbnx2x_get_cnic_mac_hwinfo(bp);\n\t}\n\n\tif (!BP_NOMCP(bp)) {\n\t\t/* Read physical port identifier from shmem */\n\t\tval2 = SHMEM_RD(bp, dev_info.port_hw_config[port].mac_upper);\n\t\tval = SHMEM_RD(bp, dev_info.port_hw_config[port].mac_lower);\n\t\tbnx2x_set_mac_buf(bp->phys_port_id, val, val2);\n\t\tbp->flags |= HAS_PHYS_PORT_ID;\n\t}\n\n\tmemcpy(bp->link_params.mac_addr, bp->dev->dev_addr, ETH_ALEN);\n\n\tif (!is_valid_ether_addr(bp->dev->dev_addr))\n\t\tdev_err(&bp->pdev->dev,\n\t\t\t\"bad Ethernet MAC address configuration: %pM\\n\"\n\t\t\t\"change it manually before bringing up the appropriate network interface\\n\",\n\t\t\tbp->dev->dev_addr);\n}\n\nstatic bool bnx2x_get_dropless_info(struct bnx2x *bp)\n{\n\tint tmp;\n\tu32 cfg;\n\n\tif (IS_VF(bp))\n\t\treturn false;\n\n\tif (IS_MF(bp) && !CHIP_IS_E1x(bp)) {\n\t\t/* Take function: tmp = func */\n\t\ttmp = BP_ABS_FUNC(bp);\n\t\tcfg = MF_CFG_RD(bp, func_ext_config[tmp].func_cfg);\n\t\tcfg = !!(cfg & MACP_FUNC_CFG_PAUSE_ON_HOST_RING);\n\t} else {\n\t\t/* Take port: tmp = port */\n\t\ttmp = BP_PORT(bp);\n\t\tcfg = SHMEM_RD(bp,\n\t\t\t       dev_info.port_hw_config[tmp].generic_features);\n\t\tcfg = !!(cfg & PORT_HW_CFG_PAUSE_ON_HOST_RING_ENABLED);\n\t}\n\treturn cfg;\n}\n\nstatic void validate_set_si_mode(struct bnx2x *bp)\n{\n\tu8 func = BP_ABS_FUNC(bp);\n\tu32 val;\n\n\tval = MF_CFG_RD(bp, func_mf_config[func].mac_upper);\n\n\t/* check for legal mac (upper bytes) */\n\tif (val != 0xffff) {\n\t\tbp->mf_mode = MULTI_FUNCTION_SI;\n\t\tbp->mf_config[BP_VN(bp)] =\n\t\t\tMF_CFG_RD(bp, func_mf_config[func].config);\n\t} else\n\t\tBNX2X_DEV_INFO(\"illegal MAC address for SI\\n\");\n}\n\nstatic int bnx2x_get_hwinfo(struct bnx2x *bp)\n{\n\tint /*abs*/func = BP_ABS_FUNC(bp);\n\tint vn;\n\tu32 val = 0, val2 = 0;\n\tint rc = 0;\n\n\t/* Validate that chip access is feasible */\n\tif (REG_RD(bp, MISC_REG_CHIP_NUM) == 0xffffffff) {\n\t\tdev_err(&bp->pdev->dev,\n\t\t\t\"Chip read returns all Fs. Preventing probe from continuing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbnx2x_get_common_hwinfo(bp);\n\n\t/*\n\t * initialize IGU parameters\n\t */\n\tif (CHIP_IS_E1x(bp)) {\n\t\tbp->common.int_block = INT_BLOCK_HC;\n\n\t\tbp->igu_dsb_id = DEF_SB_IGU_ID;\n\t\tbp->igu_base_sb = 0;\n\t} else {\n\t\tbp->common.int_block = INT_BLOCK_IGU;\n\n\t\t/* do not allow device reset during IGU info processing */\n\t\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RESET);\n\n\t\tval = REG_RD(bp, IGU_REG_BLOCK_CONFIGURATION);\n\n\t\tif (val & IGU_BLOCK_CONFIGURATION_REG_BACKWARD_COMP_EN) {\n\t\t\tint tout = 5000;\n\n\t\t\tBNX2X_DEV_INFO(\"FORCING Normal Mode\\n\");\n\n\t\t\tval &= ~(IGU_BLOCK_CONFIGURATION_REG_BACKWARD_COMP_EN);\n\t\t\tREG_WR(bp, IGU_REG_BLOCK_CONFIGURATION, val);\n\t\t\tREG_WR(bp, IGU_REG_RESET_MEMORIES, 0x7f);\n\n\t\t\twhile (tout && REG_RD(bp, IGU_REG_RESET_MEMORIES)) {\n\t\t\t\ttout--;\n\t\t\t\tusleep_range(1000, 2000);\n\t\t\t}\n\n\t\t\tif (REG_RD(bp, IGU_REG_RESET_MEMORIES)) {\n\t\t\t\tdev_err(&bp->pdev->dev,\n\t\t\t\t\t\"FORCING Normal Mode failed!!!\\n\");\n\t\t\t\tbnx2x_release_hw_lock(bp,\n\t\t\t\t\t\t      HW_LOCK_RESOURCE_RESET);\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t}\n\n\t\tif (val & IGU_BLOCK_CONFIGURATION_REG_BACKWARD_COMP_EN) {\n\t\t\tBNX2X_DEV_INFO(\"IGU Backward Compatible Mode\\n\");\n\t\t\tbp->common.int_block |= INT_BLOCK_MODE_BW_COMP;\n\t\t} else\n\t\t\tBNX2X_DEV_INFO(\"IGU Normal Mode\\n\");\n\n\t\trc = bnx2x_get_igu_cam_info(bp);\n\t\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RESET);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t/*\n\t * set base FW non-default (fast path) status block id, this value is\n\t * used to initialize the fw_sb_id saved on the fp/queue structure to\n\t * determine the id used by the FW.\n\t */\n\tif (CHIP_IS_E1x(bp))\n\t\tbp->base_fw_ndsb = BP_PORT(bp) * FP_SB_MAX_E1x + BP_L_ID(bp);\n\telse /*\n\t      * 57712 - we currently use one FW SB per IGU SB (Rx and Tx of\n\t      * the same queue are indicated on the same IGU SB). So we prefer\n\t      * FW and IGU SBs to be the same value.\n\t      */\n\t\tbp->base_fw_ndsb = bp->igu_base_sb;\n\n\tBNX2X_DEV_INFO(\"igu_dsb_id %d  igu_base_sb %d  igu_sb_cnt %d\\n\"\n\t\t       \"base_fw_ndsb %d\\n\", bp->igu_dsb_id, bp->igu_base_sb,\n\t\t       bp->igu_sb_cnt, bp->base_fw_ndsb);\n\n\t/*\n\t * Initialize MF configuration\n\t */\n\tbp->mf_ov = 0;\n\tbp->mf_mode = 0;\n\tbp->mf_sub_mode = 0;\n\tvn = BP_VN(bp);\n\n\tif (!CHIP_IS_E1(bp) && !BP_NOMCP(bp)) {\n\t\tBNX2X_DEV_INFO(\"shmem2base 0x%x, size %d, mfcfg offset %d\\n\",\n\t\t\t       bp->common.shmem2_base, SHMEM2_RD(bp, size),\n\t\t\t      (u32)offsetof(struct shmem2_region, mf_cfg_addr));\n\n\t\tif (SHMEM2_HAS(bp, mf_cfg_addr))\n\t\t\tbp->common.mf_cfg_base = SHMEM2_RD(bp, mf_cfg_addr);\n\t\telse\n\t\t\tbp->common.mf_cfg_base = bp->common.shmem_base +\n\t\t\t\toffsetof(struct shmem_region, func_mb) +\n\t\t\t\tE1H_FUNC_MAX * sizeof(struct drv_func_mb);\n\t\t/*\n\t\t * get mf configuration:\n\t\t * 1. Existence of MF configuration\n\t\t * 2. MAC address must be legal (check only upper bytes)\n\t\t *    for  Switch-Independent mode;\n\t\t *    OVLAN must be legal for Switch-Dependent mode\n\t\t * 3. SF_MODE configures specific MF mode\n\t\t */\n\t\tif (bp->common.mf_cfg_base != SHMEM_MF_CFG_ADDR_NONE) {\n\t\t\t/* get mf configuration */\n\t\t\tval = SHMEM_RD(bp,\n\t\t\t\t       dev_info.shared_feature_config.config);\n\t\t\tval &= SHARED_FEAT_CFG_FORCE_SF_MODE_MASK;\n\n\t\t\tswitch (val) {\n\t\t\tcase SHARED_FEAT_CFG_FORCE_SF_MODE_SWITCH_INDEPT:\n\t\t\t\tvalidate_set_si_mode(bp);\n\t\t\t\tbreak;\n\t\t\tcase SHARED_FEAT_CFG_FORCE_SF_MODE_AFEX_MODE:\n\t\t\t\tif ((!CHIP_IS_E1x(bp)) &&\n\t\t\t\t    (MF_CFG_RD(bp, func_mf_config[func].\n\t\t\t\t\t       mac_upper) != 0xffff) &&\n\t\t\t\t    (SHMEM2_HAS(bp,\n\t\t\t\t\t\tafex_driver_support))) {\n\t\t\t\t\tbp->mf_mode = MULTI_FUNCTION_AFEX;\n\t\t\t\t\tbp->mf_config[vn] = MF_CFG_RD(bp,\n\t\t\t\t\t\tfunc_mf_config[func].config);\n\t\t\t\t} else {\n\t\t\t\t\tBNX2X_DEV_INFO(\"can not configure afex mode\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SHARED_FEAT_CFG_FORCE_SF_MODE_MF_ALLOWED:\n\t\t\t\t/* get OV configuration */\n\t\t\t\tval = MF_CFG_RD(bp,\n\t\t\t\t\tfunc_mf_config[FUNC_0].e1hov_tag);\n\t\t\t\tval &= FUNC_MF_CFG_E1HOV_TAG_MASK;\n\n\t\t\t\tif (val != FUNC_MF_CFG_E1HOV_TAG_DEFAULT) {\n\t\t\t\t\tbp->mf_mode = MULTI_FUNCTION_SD;\n\t\t\t\t\tbp->mf_config[vn] = MF_CFG_RD(bp,\n\t\t\t\t\t\tfunc_mf_config[func].config);\n\t\t\t\t} else\n\t\t\t\t\tBNX2X_DEV_INFO(\"illegal OV for SD\\n\");\n\t\t\t\tbreak;\n\t\t\tcase SHARED_FEAT_CFG_FORCE_SF_MODE_BD_MODE:\n\t\t\t\tbp->mf_mode = MULTI_FUNCTION_SD;\n\t\t\t\tbp->mf_sub_mode = SUB_MF_MODE_BD;\n\t\t\t\tbp->mf_config[vn] =\n\t\t\t\t\tMF_CFG_RD(bp,\n\t\t\t\t\t\t  func_mf_config[func].config);\n\n\t\t\t\tif (SHMEM2_HAS(bp, mtu_size)) {\n\t\t\t\t\tint mtu_idx = BP_FW_MB_IDX(bp);\n\t\t\t\t\tu16 mtu_size;\n\t\t\t\t\tu32 mtu;\n\n\t\t\t\t\tmtu = SHMEM2_RD(bp, mtu_size[mtu_idx]);\n\t\t\t\t\tmtu_size = (u16)mtu;\n\t\t\t\t\tDP(NETIF_MSG_IFUP, \"Read MTU size %04x [%08x]\\n\",\n\t\t\t\t\t   mtu_size, mtu);\n\n\t\t\t\t\t/* if valid: update device mtu */\n\t\t\t\t\tif ((mtu_size >= ETH_MIN_PACKET_SIZE) &&\n\t\t\t\t\t    (mtu_size <=\n\t\t\t\t\t     ETH_MAX_JUMBO_PACKET_SIZE))\n\t\t\t\t\t\tbp->dev->mtu = mtu_size;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SHARED_FEAT_CFG_FORCE_SF_MODE_UFP_MODE:\n\t\t\t\tbp->mf_mode = MULTI_FUNCTION_SD;\n\t\t\t\tbp->mf_sub_mode = SUB_MF_MODE_UFP;\n\t\t\t\tbp->mf_config[vn] =\n\t\t\t\t\tMF_CFG_RD(bp,\n\t\t\t\t\t\t  func_mf_config[func].config);\n\t\t\t\tbreak;\n\t\t\tcase SHARED_FEAT_CFG_FORCE_SF_MODE_FORCED_SF:\n\t\t\t\tbp->mf_config[vn] = 0;\n\t\t\t\tbreak;\n\t\t\tcase SHARED_FEAT_CFG_FORCE_SF_MODE_EXTENDED_MODE:\n\t\t\t\tval2 = SHMEM_RD(bp,\n\t\t\t\t\tdev_info.shared_hw_config.config_3);\n\t\t\t\tval2 &= SHARED_HW_CFG_EXTENDED_MF_MODE_MASK;\n\t\t\t\tswitch (val2) {\n\t\t\t\tcase SHARED_HW_CFG_EXTENDED_MF_MODE_NPAR1_DOT_5:\n\t\t\t\t\tvalidate_set_si_mode(bp);\n\t\t\t\t\tbp->mf_sub_mode =\n\t\t\t\t\t\t\tSUB_MF_MODE_NPAR1_DOT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown configuration */\n\t\t\t\t\tbp->mf_config[vn] = 0;\n\t\t\t\t\tBNX2X_DEV_INFO(\"unknown extended MF mode 0x%x\\n\",\n\t\t\t\t\t\t       val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* Unknown configuration: reset mf_config */\n\t\t\t\tbp->mf_config[vn] = 0;\n\t\t\t\tBNX2X_DEV_INFO(\"unknown MF mode 0x%x\\n\", val);\n\t\t\t}\n\t\t}\n\n\t\tBNX2X_DEV_INFO(\"%s function mode\\n\",\n\t\t\t       IS_MF(bp) ? \"multi\" : \"single\");\n\n\t\tswitch (bp->mf_mode) {\n\t\tcase MULTI_FUNCTION_SD:\n\t\t\tval = MF_CFG_RD(bp, func_mf_config[func].e1hov_tag) &\n\t\t\t      FUNC_MF_CFG_E1HOV_TAG_MASK;\n\t\t\tif (val != FUNC_MF_CFG_E1HOV_TAG_DEFAULT) {\n\t\t\t\tbp->mf_ov = val;\n\t\t\t\tbp->path_has_ovlan = true;\n\n\t\t\t\tBNX2X_DEV_INFO(\"MF OV for func %d is %d (0x%04x)\\n\",\n\t\t\t\t\t       func, bp->mf_ov, bp->mf_ov);\n\t\t\t} else if ((bp->mf_sub_mode == SUB_MF_MODE_UFP) ||\n\t\t\t\t   (bp->mf_sub_mode == SUB_MF_MODE_BD)) {\n\t\t\t\tdev_err(&bp->pdev->dev,\n\t\t\t\t\t\"Unexpected - no valid MF OV for func %d in UFP/BD mode\\n\",\n\t\t\t\t\tfunc);\n\t\t\t\tbp->path_has_ovlan = true;\n\t\t\t} else {\n\t\t\t\tdev_err(&bp->pdev->dev,\n\t\t\t\t\t\"No valid MF OV for func %d, aborting\\n\",\n\t\t\t\t\tfunc);\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MULTI_FUNCTION_AFEX:\n\t\t\tBNX2X_DEV_INFO(\"func %d is in MF afex mode\\n\", func);\n\t\t\tbreak;\n\t\tcase MULTI_FUNCTION_SI:\n\t\t\tBNX2X_DEV_INFO(\"func %d is in MF switch-independent mode\\n\",\n\t\t\t\t       func);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (vn) {\n\t\t\t\tdev_err(&bp->pdev->dev,\n\t\t\t\t\t\"VN %d is in a single function mode, aborting\\n\",\n\t\t\t\t\tvn);\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check if other port on the path needs ovlan:\n\t\t * Since MF configuration is shared between ports\n\t\t * Possible mixed modes are only\n\t\t * {SF, SI} {SF, SD} {SD, SF} {SI, SF}\n\t\t */\n\t\tif (CHIP_MODE_IS_4_PORT(bp) &&\n\t\t    !bp->path_has_ovlan &&\n\t\t    !IS_MF(bp) &&\n\t\t    bp->common.mf_cfg_base != SHMEM_MF_CFG_ADDR_NONE) {\n\t\t\tu8 other_port = !BP_PORT(bp);\n\t\t\tu8 other_func = BP_PATH(bp) + 2*other_port;\n\t\t\tval = MF_CFG_RD(bp,\n\t\t\t\t\tfunc_mf_config[other_func].e1hov_tag);\n\t\t\tif (val != FUNC_MF_CFG_E1HOV_TAG_DEFAULT)\n\t\t\t\tbp->path_has_ovlan = true;\n\t\t}\n\t}\n\n\t/* adjust igu_sb_cnt to MF for E1H */\n\tif (CHIP_IS_E1H(bp) && IS_MF(bp))\n\t\tbp->igu_sb_cnt = min_t(u8, bp->igu_sb_cnt, E1H_MAX_MF_SB_COUNT);\n\n\t/* port info */\n\tbnx2x_get_port_hwinfo(bp);\n\n\t/* Get MAC addresses */\n\tbnx2x_get_mac_hwinfo(bp);\n\n\tbnx2x_get_cnic_info(bp);\n\n\treturn rc;\n}\n\nstatic void bnx2x_read_fwinfo(struct bnx2x *bp)\n{\n\tint cnt, i, block_end, rodi;\n\tchar vpd_start[BNX2X_VPD_LEN+1];\n\tchar str_id_reg[VENDOR_ID_LEN+1];\n\tchar str_id_cap[VENDOR_ID_LEN+1];\n\tchar *vpd_data;\n\tchar *vpd_extended_data = NULL;\n\tu8 len;\n\n\tcnt = pci_read_vpd(bp->pdev, 0, BNX2X_VPD_LEN, vpd_start);\n\tmemset(bp->fw_ver, 0, sizeof(bp->fw_ver));\n\n\tif (cnt < BNX2X_VPD_LEN)\n\t\tgoto out_not_found;\n\n\t/* VPD RO tag should be first tag after identifier string, hence\n\t * we should be able to find it in first BNX2X_VPD_LEN chars\n\t */\n\ti = pci_vpd_find_tag(vpd_start, 0, BNX2X_VPD_LEN,\n\t\t\t     PCI_VPD_LRDT_RO_DATA);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\tblock_end = i + PCI_VPD_LRDT_TAG_SIZE +\n\t\t    pci_vpd_lrdt_size(&vpd_start[i]);\n\n\ti += PCI_VPD_LRDT_TAG_SIZE;\n\n\tif (block_end > BNX2X_VPD_LEN) {\n\t\tvpd_extended_data = kmalloc(block_end, GFP_KERNEL);\n\t\tif (vpd_extended_data  == NULL)\n\t\t\tgoto out_not_found;\n\n\t\t/* read rest of vpd image into vpd_extended_data */\n\t\tmemcpy(vpd_extended_data, vpd_start, BNX2X_VPD_LEN);\n\t\tcnt = pci_read_vpd(bp->pdev, BNX2X_VPD_LEN,\n\t\t\t\t   block_end - BNX2X_VPD_LEN,\n\t\t\t\t   vpd_extended_data + BNX2X_VPD_LEN);\n\t\tif (cnt < (block_end - BNX2X_VPD_LEN))\n\t\t\tgoto out_not_found;\n\t\tvpd_data = vpd_extended_data;\n\t} else\n\t\tvpd_data = vpd_start;\n\n\t/* now vpd_data holds full vpd content in both cases */\n\n\trodi = pci_vpd_find_info_keyword(vpd_data, i, block_end,\n\t\t\t\t   PCI_VPD_RO_KEYWORD_MFR_ID);\n\tif (rodi < 0)\n\t\tgoto out_not_found;\n\n\tlen = pci_vpd_info_field_size(&vpd_data[rodi]);\n\n\tif (len != VENDOR_ID_LEN)\n\t\tgoto out_not_found;\n\n\trodi += PCI_VPD_INFO_FLD_HDR_SIZE;\n\n\t/* vendor specific info */\n\tsnprintf(str_id_reg, VENDOR_ID_LEN + 1, \"%04x\", PCI_VENDOR_ID_DELL);\n\tsnprintf(str_id_cap, VENDOR_ID_LEN + 1, \"%04X\", PCI_VENDOR_ID_DELL);\n\tif (!strncmp(str_id_reg, &vpd_data[rodi], VENDOR_ID_LEN) ||\n\t    !strncmp(str_id_cap, &vpd_data[rodi], VENDOR_ID_LEN)) {\n\n\t\trodi = pci_vpd_find_info_keyword(vpd_data, i, block_end,\n\t\t\t\t\t\tPCI_VPD_RO_KEYWORD_VENDOR0);\n\t\tif (rodi >= 0) {\n\t\t\tlen = pci_vpd_info_field_size(&vpd_data[rodi]);\n\n\t\t\trodi += PCI_VPD_INFO_FLD_HDR_SIZE;\n\n\t\t\tif (len < 32 && (len + rodi) <= BNX2X_VPD_LEN) {\n\t\t\t\tmemcpy(bp->fw_ver, &vpd_data[rodi], len);\n\t\t\t\tbp->fw_ver[len] = ' ';\n\t\t\t}\n\t\t}\n\t\tkfree(vpd_extended_data);\n\t\treturn;\n\t}\nout_not_found:\n\tkfree(vpd_extended_data);\n\treturn;\n}\n\nstatic void bnx2x_set_modes_bitmap(struct bnx2x *bp)\n{\n\tu32 flags = 0;\n\n\tif (CHIP_REV_IS_FPGA(bp))\n\t\tSET_FLAGS(flags, MODE_FPGA);\n\telse if (CHIP_REV_IS_EMUL(bp))\n\t\tSET_FLAGS(flags, MODE_EMUL);\n\telse\n\t\tSET_FLAGS(flags, MODE_ASIC);\n\n\tif (CHIP_MODE_IS_4_PORT(bp))\n\t\tSET_FLAGS(flags, MODE_PORT4);\n\telse\n\t\tSET_FLAGS(flags, MODE_PORT2);\n\n\tif (CHIP_IS_E2(bp))\n\t\tSET_FLAGS(flags, MODE_E2);\n\telse if (CHIP_IS_E3(bp)) {\n\t\tSET_FLAGS(flags, MODE_E3);\n\t\tif (CHIP_REV(bp) == CHIP_REV_Ax)\n\t\t\tSET_FLAGS(flags, MODE_E3_A0);\n\t\telse /*if (CHIP_REV(bp) == CHIP_REV_Bx)*/\n\t\t\tSET_FLAGS(flags, MODE_E3_B0 | MODE_COS3);\n\t}\n\n\tif (IS_MF(bp)) {\n\t\tSET_FLAGS(flags, MODE_MF);\n\t\tswitch (bp->mf_mode) {\n\t\tcase MULTI_FUNCTION_SD:\n\t\t\tSET_FLAGS(flags, MODE_MF_SD);\n\t\t\tbreak;\n\t\tcase MULTI_FUNCTION_SI:\n\t\t\tSET_FLAGS(flags, MODE_MF_SI);\n\t\t\tbreak;\n\t\tcase MULTI_FUNCTION_AFEX:\n\t\t\tSET_FLAGS(flags, MODE_MF_AFEX);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tSET_FLAGS(flags, MODE_SF);\n\n#if defined(__LITTLE_ENDIAN)\n\tSET_FLAGS(flags, MODE_LITTLE_ENDIAN);\n#else /*(__BIG_ENDIAN)*/\n\tSET_FLAGS(flags, MODE_BIG_ENDIAN);\n#endif\n\tINIT_MODE_FLAGS(bp) = flags;\n}\n\nstatic int bnx2x_init_bp(struct bnx2x *bp)\n{\n\tint func;\n\tint rc;\n\n\tmutex_init(&bp->port.phy_mutex);\n\tmutex_init(&bp->fw_mb_mutex);\n\tmutex_init(&bp->drv_info_mutex);\n\tsema_init(&bp->stats_lock, 1);\n\tbp->drv_info_mng_owner = false;\n\tINIT_LIST_HEAD(&bp->vlan_reg);\n\n\tINIT_DELAYED_WORK(&bp->sp_task, bnx2x_sp_task);\n\tINIT_DELAYED_WORK(&bp->sp_rtnl_task, bnx2x_sp_rtnl_task);\n\tINIT_DELAYED_WORK(&bp->period_task, bnx2x_period_task);\n\tINIT_DELAYED_WORK(&bp->iov_task, bnx2x_iov_task);\n\tif (IS_PF(bp)) {\n\t\trc = bnx2x_get_hwinfo(bp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\teth_zero_addr(bp->dev->dev_addr);\n\t}\n\n\tbnx2x_set_modes_bitmap(bp);\n\n\trc = bnx2x_alloc_mem_bp(bp);\n\tif (rc)\n\t\treturn rc;\n\n\tbnx2x_read_fwinfo(bp);\n\n\tfunc = BP_FUNC(bp);\n\n\t/* need to reset chip if undi was active */\n\tif (IS_PF(bp) && !BP_NOMCP(bp)) {\n\t\t/* init fw_seq */\n\t\tbp->fw_seq =\n\t\t\tSHMEM_RD(bp, func_mb[BP_FW_MB_IDX(bp)].drv_mb_header) &\n\t\t\t\t\t\t\tDRV_MSG_SEQ_NUMBER_MASK;\n\t\tBNX2X_DEV_INFO(\"fw_seq 0x%08x\\n\", bp->fw_seq);\n\n\t\trc = bnx2x_prev_unload(bp);\n\t\tif (rc) {\n\t\t\tbnx2x_free_mem_bp(bp);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (CHIP_REV_IS_FPGA(bp))\n\t\tdev_err(&bp->pdev->dev, \"FPGA detected\\n\");\n\n\tif (BP_NOMCP(bp) && (func == 0))\n\t\tdev_err(&bp->pdev->dev, \"MCP disabled, must load devices in order!\\n\");\n\n\tbp->disable_tpa = disable_tpa;\n\tbp->disable_tpa |= !!IS_MF_STORAGE_ONLY(bp);\n\t/* Reduce memory usage in kdump environment by disabling TPA */\n\tbp->disable_tpa |= is_kdump_kernel();\n\n\t/* Set TPA flags */\n\tif (bp->disable_tpa) {\n\t\tbp->dev->hw_features &= ~(NETIF_F_LRO | NETIF_F_GRO_HW);\n\t\tbp->dev->features &= ~(NETIF_F_LRO | NETIF_F_GRO_HW);\n\t}\n\n\tif (CHIP_IS_E1(bp))\n\t\tbp->dropless_fc = false;\n\telse\n\t\tbp->dropless_fc = dropless_fc | bnx2x_get_dropless_info(bp);\n\n\tbp->mrrs = mrrs;\n\n\tbp->tx_ring_size = IS_MF_STORAGE_ONLY(bp) ? 0 : MAX_TX_AVAIL;\n\tif (IS_VF(bp))\n\t\tbp->rx_ring_size = MAX_RX_AVAIL;\n\n\t/* make sure that the numbers are in the right granularity */\n\tbp->tx_ticks = (50 / BNX2X_BTR) * BNX2X_BTR;\n\tbp->rx_ticks = (25 / BNX2X_BTR) * BNX2X_BTR;\n\n\tbp->current_interval = CHIP_REV_IS_SLOW(bp) ? 5*HZ : HZ;\n\n\ttimer_setup(&bp->timer, bnx2x_timer, 0);\n\tbp->timer.expires = jiffies + bp->current_interval;\n\n\tif (SHMEM2_HAS(bp, dcbx_lldp_params_offset) &&\n\t    SHMEM2_HAS(bp, dcbx_lldp_dcbx_stat_offset) &&\n\t    SHMEM2_HAS(bp, dcbx_en) &&\n\t    SHMEM2_RD(bp, dcbx_lldp_params_offset) &&\n\t    SHMEM2_RD(bp, dcbx_lldp_dcbx_stat_offset) &&\n\t    SHMEM2_RD(bp, dcbx_en[BP_PORT(bp)])) {\n\t\tbnx2x_dcbx_set_state(bp, true, BNX2X_DCBX_ENABLED_ON_NEG_ON);\n\t\tbnx2x_dcbx_init_params(bp);\n\t} else {\n\t\tbnx2x_dcbx_set_state(bp, false, BNX2X_DCBX_ENABLED_OFF);\n\t}\n\n\tif (CHIP_IS_E1x(bp))\n\t\tbp->cnic_base_cl_id = FP_SB_MAX_E1x;\n\telse\n\t\tbp->cnic_base_cl_id = FP_SB_MAX_E2;\n\n\t/* multiple tx priority */\n\tif (IS_VF(bp))\n\t\tbp->max_cos = 1;\n\telse if (CHIP_IS_E1x(bp))\n\t\tbp->max_cos = BNX2X_MULTI_TX_COS_E1X;\n\telse if (CHIP_IS_E2(bp) || CHIP_IS_E3A0(bp))\n\t\tbp->max_cos = BNX2X_MULTI_TX_COS_E2_E3A0;\n\telse if (CHIP_IS_E3B0(bp))\n\t\tbp->max_cos = BNX2X_MULTI_TX_COS_E3B0;\n\telse\n\t\tBNX2X_ERR(\"unknown chip %x revision %x\\n\",\n\t\t\t  CHIP_NUM(bp), CHIP_REV(bp));\n\tBNX2X_DEV_INFO(\"set bp->max_cos to %d\\n\", bp->max_cos);\n\n\t/* We need at least one default status block for slow-path events,\n\t * second status block for the L2 queue, and a third status block for\n\t * CNIC if supported.\n\t */\n\tif (IS_VF(bp))\n\t\tbp->min_msix_vec_cnt = 1;\n\telse if (CNIC_SUPPORT(bp))\n\t\tbp->min_msix_vec_cnt = 3;\n\telse /* PF w/o cnic */\n\t\tbp->min_msix_vec_cnt = 2;\n\tBNX2X_DEV_INFO(\"bp->min_msix_vec_cnt %d\", bp->min_msix_vec_cnt);\n\n\tbp->dump_preset_idx = 1;\n\n\treturn rc;\n}\n\n/****************************************************************************\n* General service functions\n****************************************************************************/\n\n/*\n * net_device service functions\n */\n\n/* called with rtnl_lock */\nstatic int bnx2x_open(struct net_device *dev)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tint rc;\n\n\tbp->stats_init = true;\n\n\tnetif_carrier_off(dev);\n\n\tbnx2x_set_power_state(bp, PCI_D0);\n\n\t/* If parity had happen during the unload, then attentions\n\t * and/or RECOVERY_IN_PROGRES may still be set. In this case we\n\t * want the first function loaded on the current engine to\n\t * complete the recovery.\n\t * Parity recovery is only relevant for PF driver.\n\t */\n\tif (IS_PF(bp)) {\n\t\tint other_engine = BP_PATH(bp) ? 0 : 1;\n\t\tbool other_load_status, load_status;\n\t\tbool global = false;\n\n\t\tother_load_status = bnx2x_get_load_status(bp, other_engine);\n\t\tload_status = bnx2x_get_load_status(bp, BP_PATH(bp));\n\t\tif (!bnx2x_reset_is_done(bp, BP_PATH(bp)) ||\n\t\t    bnx2x_chk_parity_attn(bp, &global, true)) {\n\t\t\tdo {\n\t\t\t\t/* If there are attentions and they are in a\n\t\t\t\t * global blocks, set the GLOBAL_RESET bit\n\t\t\t\t * regardless whether it will be this function\n\t\t\t\t * that will complete the recovery or not.\n\t\t\t\t */\n\t\t\t\tif (global)\n\t\t\t\t\tbnx2x_set_reset_global(bp);\n\n\t\t\t\t/* Only the first function on the current\n\t\t\t\t * engine should try to recover in open. In case\n\t\t\t\t * of attentions in global blocks only the first\n\t\t\t\t * in the chip should try to recover.\n\t\t\t\t */\n\t\t\t\tif ((!load_status &&\n\t\t\t\t     (!global || !other_load_status)) &&\n\t\t\t\t      bnx2x_trylock_leader_lock(bp) &&\n\t\t\t\t      !bnx2x_leader_reset(bp)) {\n\t\t\t\t\tnetdev_info(bp->dev,\n\t\t\t\t\t\t    \"Recovered in open\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* recovery has failed... */\n\t\t\t\tbnx2x_set_power_state(bp, PCI_D3hot);\n\t\t\t\tbp->recovery_state = BNX2X_RECOVERY_FAILED;\n\n\t\t\t\tBNX2X_ERR(\"Recovery flow hasn't been properly completed yet. Try again later.\\n\"\n\t\t\t\t\t  \"If you still see this message after a few retries then power cycle is required.\\n\");\n\n\t\t\t\treturn -EAGAIN;\n\t\t\t} while (0);\n\t\t}\n\t}\n\n\tbp->recovery_state = BNX2X_RECOVERY_DONE;\n\trc = bnx2x_nic_load(bp, LOAD_OPEN);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\n/* called with rtnl_lock */\nstatic int bnx2x_close(struct net_device *dev)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\t/* Unload the driver, release IRQs */\n\tbnx2x_nic_unload(bp, UNLOAD_CLOSE, false);\n\n\treturn 0;\n}\n\nstruct bnx2x_mcast_list_elem_group\n{\n\tstruct list_head mcast_group_link;\n\tstruct bnx2x_mcast_list_elem mcast_elems[];\n};\n\n#define MCAST_ELEMS_PER_PG \\\n\t((PAGE_SIZE - sizeof(struct bnx2x_mcast_list_elem_group)) / \\\n\tsizeof(struct bnx2x_mcast_list_elem))\n\nstatic void bnx2x_free_mcast_macs_list(struct list_head *mcast_group_list)\n{\n\tstruct bnx2x_mcast_list_elem_group *current_mcast_group;\n\n\twhile (!list_empty(mcast_group_list)) {\n\t\tcurrent_mcast_group = list_first_entry(mcast_group_list,\n\t\t\t\t      struct bnx2x_mcast_list_elem_group,\n\t\t\t\t      mcast_group_link);\n\t\tlist_del(&current_mcast_group->mcast_group_link);\n\t\tfree_page((unsigned long)current_mcast_group);\n\t}\n}\n\nstatic int bnx2x_init_mcast_macs_list(struct bnx2x *bp,\n\t\t\t\t      struct bnx2x_mcast_ramrod_params *p,\n\t\t\t\t      struct list_head *mcast_group_list)\n{\n\tstruct bnx2x_mcast_list_elem *mc_mac;\n\tstruct netdev_hw_addr *ha;\n\tstruct bnx2x_mcast_list_elem_group *current_mcast_group = NULL;\n\tint mc_count = netdev_mc_count(bp->dev);\n\tint offset = 0;\n\n\tINIT_LIST_HEAD(&p->mcast_list);\n\tnetdev_for_each_mc_addr(ha, bp->dev) {\n\t\tif (!offset) {\n\t\t\tcurrent_mcast_group =\n\t\t\t\t(struct bnx2x_mcast_list_elem_group *)\n\t\t\t\t__get_free_page(GFP_ATOMIC);\n\t\t\tif (!current_mcast_group) {\n\t\t\t\tbnx2x_free_mcast_macs_list(mcast_group_list);\n\t\t\t\tBNX2X_ERR(\"Failed to allocate mc MAC list\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tlist_add(&current_mcast_group->mcast_group_link,\n\t\t\t\t mcast_group_list);\n\t\t}\n\t\tmc_mac = &current_mcast_group->mcast_elems[offset];\n\t\tmc_mac->mac = bnx2x_mc_addr(ha);\n\t\tlist_add_tail(&mc_mac->link, &p->mcast_list);\n\t\toffset++;\n\t\tif (offset == MCAST_ELEMS_PER_PG)\n\t\t\toffset = 0;\n\t}\n\tp->mcast_list_len = mc_count;\n\treturn 0;\n}\n\n/**\n * bnx2x_set_uc_list - configure a new unicast MACs list.\n *\n * @bp: driver handle\n *\n * We will use zero (0) as a MAC type for these MACs.\n */\nstatic int bnx2x_set_uc_list(struct bnx2x *bp)\n{\n\tint rc;\n\tstruct net_device *dev = bp->dev;\n\tstruct netdev_hw_addr *ha;\n\tstruct bnx2x_vlan_mac_obj *mac_obj = &bp->sp_objs->mac_obj;\n\tunsigned long ramrod_flags = 0;\n\n\t/* First schedule a cleanup up of old configuration */\n\trc = bnx2x_del_all_macs(bp, mac_obj, BNX2X_UC_LIST_MAC, false);\n\tif (rc < 0) {\n\t\tBNX2X_ERR(\"Failed to schedule DELETE operations: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tnetdev_for_each_uc_addr(ha, dev) {\n\t\trc = bnx2x_set_mac_one(bp, bnx2x_uc_addr(ha), mac_obj, true,\n\t\t\t\t       BNX2X_UC_LIST_MAC, &ramrod_flags);\n\t\tif (rc == -EEXIST) {\n\t\t\tDP(BNX2X_MSG_SP,\n\t\t\t   \"Failed to schedule ADD operations: %d\\n\", rc);\n\t\t\t/* do not treat adding same MAC as error */\n\t\t\trc = 0;\n\n\t\t} else if (rc < 0) {\n\n\t\t\tBNX2X_ERR(\"Failed to schedule ADD operations: %d\\n\",\n\t\t\t\t  rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* Execute the pending commands */\n\t__set_bit(RAMROD_CONT, &ramrod_flags);\n\treturn bnx2x_set_mac_one(bp, NULL, mac_obj, false /* don't care */,\n\t\t\t\t BNX2X_UC_LIST_MAC, &ramrod_flags);\n}\n\nstatic int bnx2x_set_mc_list_e1x(struct bnx2x *bp)\n{\n\tLIST_HEAD(mcast_group_list);\n\tstruct net_device *dev = bp->dev;\n\tstruct bnx2x_mcast_ramrod_params rparam = {NULL};\n\tint rc = 0;\n\n\trparam.mcast_obj = &bp->mcast_obj;\n\n\t/* first, clear all configured multicast MACs */\n\trc = bnx2x_config_mcast(bp, &rparam, BNX2X_MCAST_CMD_DEL);\n\tif (rc < 0) {\n\t\tBNX2X_ERR(\"Failed to clear multicast configuration: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t/* then, configure a new MACs list */\n\tif (netdev_mc_count(dev)) {\n\t\trc = bnx2x_init_mcast_macs_list(bp, &rparam, &mcast_group_list);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* Now add the new MACs */\n\t\trc = bnx2x_config_mcast(bp, &rparam,\n\t\t\t\t\tBNX2X_MCAST_CMD_ADD);\n\t\tif (rc < 0)\n\t\t\tBNX2X_ERR(\"Failed to set a new multicast configuration: %d\\n\",\n\t\t\t\t  rc);\n\n\t\tbnx2x_free_mcast_macs_list(&mcast_group_list);\n\t}\n\n\treturn rc;\n}\n\nstatic int bnx2x_set_mc_list(struct bnx2x *bp)\n{\n\tLIST_HEAD(mcast_group_list);\n\tstruct bnx2x_mcast_ramrod_params rparam = {NULL};\n\tstruct net_device *dev = bp->dev;\n\tint rc = 0;\n\n\t/* On older adapters, we need to flush and re-add filters */\n\tif (CHIP_IS_E1x(bp))\n\t\treturn bnx2x_set_mc_list_e1x(bp);\n\n\trparam.mcast_obj = &bp->mcast_obj;\n\n\tif (netdev_mc_count(dev)) {\n\t\trc = bnx2x_init_mcast_macs_list(bp, &rparam, &mcast_group_list);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* Override the curently configured set of mc filters */\n\t\trc = bnx2x_config_mcast(bp, &rparam,\n\t\t\t\t\tBNX2X_MCAST_CMD_SET);\n\t\tif (rc < 0)\n\t\t\tBNX2X_ERR(\"Failed to set a new multicast configuration: %d\\n\",\n\t\t\t\t  rc);\n\n\t\tbnx2x_free_mcast_macs_list(&mcast_group_list);\n\t} else {\n\t\t/* If no mc addresses are required, flush the configuration */\n\t\trc = bnx2x_config_mcast(bp, &rparam, BNX2X_MCAST_CMD_DEL);\n\t\tif (rc < 0)\n\t\t\tBNX2X_ERR(\"Failed to clear multicast configuration %d\\n\",\n\t\t\t\t  rc);\n\t}\n\n\treturn rc;\n}\n\n/* If bp->state is OPEN, should be called with netif_addr_lock_bh() */\nstatic void bnx2x_set_rx_mode(struct net_device *dev)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tif (bp->state != BNX2X_STATE_OPEN) {\n\t\tDP(NETIF_MSG_IFUP, \"state is %x, returning\\n\", bp->state);\n\t\treturn;\n\t} else {\n\t\t/* Schedule an SP task to handle rest of change */\n\t\tbnx2x_schedule_sp_rtnl(bp, BNX2X_SP_RTNL_RX_MODE,\n\t\t\t\t       NETIF_MSG_IFUP);\n\t}\n}\n\nvoid bnx2x_set_rx_mode_inner(struct bnx2x *bp)\n{\n\tu32 rx_mode = BNX2X_RX_MODE_NORMAL;\n\n\tDP(NETIF_MSG_IFUP, \"dev->flags = %x\\n\", bp->dev->flags);\n\n\tnetif_addr_lock_bh(bp->dev);\n\n\tif (bp->dev->flags & IFF_PROMISC) {\n\t\trx_mode = BNX2X_RX_MODE_PROMISC;\n\t} else if ((bp->dev->flags & IFF_ALLMULTI) ||\n\t\t   ((netdev_mc_count(bp->dev) > BNX2X_MAX_MULTICAST) &&\n\t\t    CHIP_IS_E1(bp))) {\n\t\trx_mode = BNX2X_RX_MODE_ALLMULTI;\n\t} else {\n\t\tif (IS_PF(bp)) {\n\t\t\t/* some multicasts */\n\t\t\tif (bnx2x_set_mc_list(bp) < 0)\n\t\t\t\trx_mode = BNX2X_RX_MODE_ALLMULTI;\n\n\t\t\t/* release bh lock, as bnx2x_set_uc_list might sleep */\n\t\t\tnetif_addr_unlock_bh(bp->dev);\n\t\t\tif (bnx2x_set_uc_list(bp) < 0)\n\t\t\t\trx_mode = BNX2X_RX_MODE_PROMISC;\n\t\t\tnetif_addr_lock_bh(bp->dev);\n\t\t} else {\n\t\t\t/* configuring mcast to a vf involves sleeping (when we\n\t\t\t * wait for the pf's response).\n\t\t\t */\n\t\t\tbnx2x_schedule_sp_rtnl(bp,\n\t\t\t\t\t       BNX2X_SP_RTNL_VFPF_MCAST, 0);\n\t\t}\n\t}\n\n\tbp->rx_mode = rx_mode;\n\t/* handle ISCSI SD mode */\n\tif (IS_MF_ISCSI_ONLY(bp))\n\t\tbp->rx_mode = BNX2X_RX_MODE_NONE;\n\n\t/* Schedule the rx_mode command */\n\tif (test_bit(BNX2X_FILTER_RX_MODE_PENDING, &bp->sp_state)) {\n\t\tset_bit(BNX2X_FILTER_RX_MODE_SCHED, &bp->sp_state);\n\t\tnetif_addr_unlock_bh(bp->dev);\n\t\treturn;\n\t}\n\n\tif (IS_PF(bp)) {\n\t\tbnx2x_set_storm_rx_mode(bp);\n\t\tnetif_addr_unlock_bh(bp->dev);\n\t} else {\n\t\t/* VF will need to request the PF to make this change, and so\n\t\t * the VF needs to release the bottom-half lock prior to the\n\t\t * request (as it will likely require sleep on the VF side)\n\t\t */\n\t\tnetif_addr_unlock_bh(bp->dev);\n\t\tbnx2x_vfpf_storm_rx_mode(bp);\n\t}\n}\n\n/* called with rtnl_lock */\nstatic int bnx2x_mdio_read(struct net_device *netdev, int prtad,\n\t\t\t   int devad, u16 addr)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tu16 value;\n\tint rc;\n\n\tDP(NETIF_MSG_LINK, \"mdio_read: prtad 0x%x, devad 0x%x, addr 0x%x\\n\",\n\t   prtad, devad, addr);\n\n\t/* The HW expects different devad if CL22 is used */\n\tdevad = (devad == MDIO_DEVAD_NONE) ? DEFAULT_PHY_DEV_ADDR : devad;\n\n\tbnx2x_acquire_phy_lock(bp);\n\trc = bnx2x_phy_read(&bp->link_params, prtad, devad, addr, &value);\n\tbnx2x_release_phy_lock(bp);\n\tDP(NETIF_MSG_LINK, \"mdio_read_val 0x%x rc = 0x%x\\n\", value, rc);\n\n\tif (!rc)\n\t\trc = value;\n\treturn rc;\n}\n\n/* called with rtnl_lock */\nstatic int bnx2x_mdio_write(struct net_device *netdev, int prtad, int devad,\n\t\t\t    u16 addr, u16 value)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\tint rc;\n\n\tDP(NETIF_MSG_LINK,\n\t   \"mdio_write: prtad 0x%x, devad 0x%x, addr 0x%x, value 0x%x\\n\",\n\t   prtad, devad, addr, value);\n\n\t/* The HW expects different devad if CL22 is used */\n\tdevad = (devad == MDIO_DEVAD_NONE) ? DEFAULT_PHY_DEV_ADDR : devad;\n\n\tbnx2x_acquire_phy_lock(bp);\n\trc = bnx2x_phy_write(&bp->link_params, prtad, devad, addr, value);\n\tbnx2x_release_phy_lock(bp);\n\treturn rc;\n}\n\n/* called with rtnl_lock */\nstatic int bnx2x_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tstruct mii_ioctl_data *mdio = if_mii(ifr);\n\n\tif (!netif_running(dev))\n\t\treturn -EAGAIN;\n\n\tswitch (cmd) {\n\tcase SIOCSHWTSTAMP:\n\t\treturn bnx2x_hwtstamp_ioctl(bp, ifr);\n\tdefault:\n\t\tDP(NETIF_MSG_LINK, \"ioctl: phy id 0x%x, reg 0x%x, val_in 0x%x\\n\",\n\t\t   mdio->phy_id, mdio->reg_num, mdio->val_in);\n\t\treturn mdio_mii_ioctl(&bp->mdio, mdio, cmd);\n\t}\n}\n\nstatic int bnx2x_validate_addr(struct net_device *dev)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\t/* query the bulletin board for mac address configured by the PF */\n\tif (IS_VF(bp))\n\t\tbnx2x_sample_bulletin(bp);\n\n\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\tBNX2X_ERR(\"Non-valid Ethernet address\\n\");\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\treturn 0;\n}\n\nstatic int bnx2x_get_phys_port_id(struct net_device *netdev,\n\t\t\t\t  struct netdev_phys_item_id *ppid)\n{\n\tstruct bnx2x *bp = netdev_priv(netdev);\n\n\tif (!(bp->flags & HAS_PHYS_PORT_ID))\n\t\treturn -EOPNOTSUPP;\n\n\tppid->id_len = sizeof(bp->phys_port_id);\n\tmemcpy(ppid->id, bp->phys_port_id, ppid->id_len);\n\n\treturn 0;\n}\n\nstatic netdev_features_t bnx2x_features_check(struct sk_buff *skb,\n\t\t\t\t\t      struct net_device *dev,\n\t\t\t\t\t      netdev_features_t features)\n{\n\t/*\n\t * A skb with gso_size + header length > 9700 will cause a\n\t * firmware panic. Drop GSO support.\n\t *\n\t * Eventually the upper layer should not pass these packets down.\n\t *\n\t * For speed, if the gso_size is <= 9000, assume there will\n\t * not be 700 bytes of headers and pass it through. Only do a\n\t * full (slow) validation if the gso_size is > 9000.\n\t *\n\t * (Due to the way SKB_BY_FRAGS works this will also do a full\n\t * validation in that case.)\n\t */\n\tif (unlikely(skb_is_gso(skb) &&\n\t\t     (skb_shinfo(skb)->gso_size > 9000) &&\n\t\t     !skb_gso_validate_mac_len(skb, 9700)))\n\t\tfeatures &= ~NETIF_F_GSO_MASK;\n\n\tfeatures = vlan_features_check(skb, features);\n\treturn vxlan_features_check(skb, features);\n}\n\nstatic int __bnx2x_vlan_configure_vid(struct bnx2x *bp, u16 vid, bool add)\n{\n\tint rc;\n\n\tif (IS_PF(bp)) {\n\t\tunsigned long ramrod_flags = 0;\n\n\t\t__set_bit(RAMROD_COMP_WAIT, &ramrod_flags);\n\t\trc = bnx2x_set_vlan_one(bp, vid, &bp->sp_objs->vlan_obj,\n\t\t\t\t\tadd, &ramrod_flags);\n\t} else {\n\t\trc = bnx2x_vfpf_update_vlan(bp, vid, bp->fp->index, add);\n\t}\n\n\treturn rc;\n}\n\nstatic int bnx2x_vlan_configure_vid_list(struct bnx2x *bp)\n{\n\tstruct bnx2x_vlan_entry *vlan;\n\tint rc = 0;\n\n\t/* Configure all non-configured entries */\n\tlist_for_each_entry(vlan, &bp->vlan_reg, link) {\n\t\tif (vlan->hw)\n\t\t\tcontinue;\n\n\t\tif (bp->vlan_cnt >= bp->vlan_credit)\n\t\t\treturn -ENOBUFS;\n\n\t\trc = __bnx2x_vlan_configure_vid(bp, vlan->vid, true);\n\t\tif (rc) {\n\t\t\tBNX2X_ERR(\"Unable to config VLAN %d\\n\", vlan->vid);\n\t\t\treturn rc;\n\t\t}\n\n\t\tDP(NETIF_MSG_IFUP, \"HW configured for VLAN %d\\n\", vlan->vid);\n\t\tvlan->hw = true;\n\t\tbp->vlan_cnt++;\n\t}\n\n\treturn 0;\n}\n\nstatic void bnx2x_vlan_configure(struct bnx2x *bp, bool set_rx_mode)\n{\n\tbool need_accept_any_vlan;\n\n\tneed_accept_any_vlan = !!bnx2x_vlan_configure_vid_list(bp);\n\n\tif (bp->accept_any_vlan != need_accept_any_vlan) {\n\t\tbp->accept_any_vlan = need_accept_any_vlan;\n\t\tDP(NETIF_MSG_IFUP, \"Accept all VLAN %s\\n\",\n\t\t   bp->accept_any_vlan ? \"raised\" : \"cleared\");\n\t\tif (set_rx_mode) {\n\t\t\tif (IS_PF(bp))\n\t\t\t\tbnx2x_set_rx_mode_inner(bp);\n\t\t\telse\n\t\t\t\tbnx2x_vfpf_storm_rx_mode(bp);\n\t\t}\n\t}\n}\n\nint bnx2x_vlan_reconfigure_vid(struct bnx2x *bp)\n{\n\t/* Don't set rx mode here. Our caller will do it. */\n\tbnx2x_vlan_configure(bp, false);\n\n\treturn 0;\n}\n\nstatic int bnx2x_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tstruct bnx2x_vlan_entry *vlan;\n\n\tDP(NETIF_MSG_IFUP, \"Adding VLAN %d\\n\", vid);\n\n\tvlan = kmalloc(sizeof(*vlan), GFP_KERNEL);\n\tif (!vlan)\n\t\treturn -ENOMEM;\n\n\tvlan->vid = vid;\n\tvlan->hw = false;\n\tlist_add_tail(&vlan->link, &bp->vlan_reg);\n\n\tif (netif_running(dev))\n\t\tbnx2x_vlan_configure(bp, true);\n\n\treturn 0;\n}\n\nstatic int bnx2x_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tstruct bnx2x_vlan_entry *vlan;\n\tbool found = false;\n\tint rc = 0;\n\n\tDP(NETIF_MSG_IFUP, \"Removing VLAN %d\\n\", vid);\n\n\tlist_for_each_entry(vlan, &bp->vlan_reg, link)\n\t\tif (vlan->vid == vid) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\tif (!found) {\n\t\tBNX2X_ERR(\"Unable to kill VLAN %d - not found\\n\", vid);\n\t\treturn -EINVAL;\n\t}\n\n\tif (netif_running(dev) && vlan->hw) {\n\t\trc = __bnx2x_vlan_configure_vid(bp, vid, false);\n\t\tDP(NETIF_MSG_IFUP, \"HW deconfigured for VLAN %d\\n\", vid);\n\t\tbp->vlan_cnt--;\n\t}\n\n\tlist_del(&vlan->link);\n\tkfree(vlan);\n\n\tif (netif_running(dev))\n\t\tbnx2x_vlan_configure(bp, true);\n\n\tDP(NETIF_MSG_IFUP, \"Removing VLAN result %d\\n\", rc);\n\n\treturn rc;\n}\n\nstatic const struct net_device_ops bnx2x_netdev_ops = {\n\t.ndo_open\t\t= bnx2x_open,\n\t.ndo_stop\t\t= bnx2x_close,\n\t.ndo_start_xmit\t\t= bnx2x_start_xmit,\n\t.ndo_select_queue\t= bnx2x_select_queue,\n\t.ndo_set_rx_mode\t= bnx2x_set_rx_mode,\n\t.ndo_set_mac_address\t= bnx2x_change_mac_addr,\n\t.ndo_validate_addr\t= bnx2x_validate_addr,\n\t.ndo_do_ioctl\t\t= bnx2x_ioctl,\n\t.ndo_change_mtu\t\t= bnx2x_change_mtu,\n\t.ndo_fix_features\t= bnx2x_fix_features,\n\t.ndo_set_features\t= bnx2x_set_features,\n\t.ndo_tx_timeout\t\t= bnx2x_tx_timeout,\n\t.ndo_vlan_rx_add_vid\t= bnx2x_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= bnx2x_vlan_rx_kill_vid,\n\t.ndo_setup_tc\t\t= __bnx2x_setup_tc,\n#ifdef CONFIG_BNX2X_SRIOV\n\t.ndo_set_vf_mac\t\t= bnx2x_set_vf_mac,\n\t.ndo_set_vf_vlan\t= bnx2x_set_vf_vlan,\n\t.ndo_get_vf_config\t= bnx2x_get_vf_config,\n\t.ndo_set_vf_spoofchk\t= bnx2x_set_vf_spoofchk,\n#endif\n#ifdef NETDEV_FCOE_WWNN\n\t.ndo_fcoe_get_wwn\t= bnx2x_fcoe_get_wwn,\n#endif\n\n\t.ndo_get_phys_port_id\t= bnx2x_get_phys_port_id,\n\t.ndo_set_vf_link_state\t= bnx2x_set_vf_link_state,\n\t.ndo_features_check\t= bnx2x_features_check,\n\t.ndo_udp_tunnel_add\t= udp_tunnel_nic_add_port,\n\t.ndo_udp_tunnel_del\t= udp_tunnel_nic_del_port,\n};\n\nstatic int bnx2x_set_coherency_mask(struct bnx2x *bp)\n{\n\tstruct device *dev = &bp->pdev->dev;\n\n\tif (dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64)) != 0 &&\n\t    dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32)) != 0) {\n\t\tdev_err(dev, \"System does not support DMA, aborting\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void bnx2x_disable_pcie_error_reporting(struct bnx2x *bp)\n{\n\tif (bp->flags & AER_ENABLED) {\n\t\tpci_disable_pcie_error_reporting(bp->pdev);\n\t\tbp->flags &= ~AER_ENABLED;\n\t}\n}\n\nstatic int bnx2x_init_dev(struct bnx2x *bp, struct pci_dev *pdev,\n\t\t\t  struct net_device *dev, unsigned long board_type)\n{\n\tint rc;\n\tu32 pci_cfg_dword;\n\tbool chip_is_e1x = (board_type == BCM57710 ||\n\t\t\t    board_type == BCM57711 ||\n\t\t\t    board_type == BCM57711E);\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tbp->dev = dev;\n\tbp->pdev = pdev;\n\n\trc = pci_enable_device(pdev);\n\tif (rc) {\n\t\tdev_err(&bp->pdev->dev,\n\t\t\t\"Cannot enable PCI device, aborting\\n\");\n\t\tgoto err_out;\n\t}\n\n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\n\t\tdev_err(&bp->pdev->dev,\n\t\t\t\"Cannot find PCI device base address, aborting\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err_out_disable;\n\t}\n\n\tif (IS_PF(bp) && !(pci_resource_flags(pdev, 2) & IORESOURCE_MEM)) {\n\t\tdev_err(&bp->pdev->dev, \"Cannot find second PCI device base address, aborting\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err_out_disable;\n\t}\n\n\tpci_read_config_dword(pdev, PCICFG_REVISION_ID_OFFSET, &pci_cfg_dword);\n\tif ((pci_cfg_dword & PCICFG_REVESION_ID_MASK) ==\n\t    PCICFG_REVESION_ID_ERROR_VAL) {\n\t\tpr_err(\"PCI device error, probably due to fan failure, aborting\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err_out_disable;\n\t}\n\n\tif (atomic_read(&pdev->enable_cnt) == 1) {\n\t\trc = pci_request_regions(pdev, DRV_MODULE_NAME);\n\t\tif (rc) {\n\t\t\tdev_err(&bp->pdev->dev,\n\t\t\t\t\"Cannot obtain PCI resources, aborting\\n\");\n\t\t\tgoto err_out_disable;\n\t\t}\n\n\t\tpci_set_master(pdev);\n\t\tpci_save_state(pdev);\n\t}\n\n\tif (IS_PF(bp)) {\n\t\tif (!pdev->pm_cap) {\n\t\t\tdev_err(&bp->pdev->dev,\n\t\t\t\t\"Cannot find power management capability, aborting\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto err_out_release;\n\t\t}\n\t}\n\n\tif (!pci_is_pcie(pdev)) {\n\t\tdev_err(&bp->pdev->dev, \"Not PCI Express, aborting\\n\");\n\t\trc = -EIO;\n\t\tgoto err_out_release;\n\t}\n\n\trc = bnx2x_set_coherency_mask(bp);\n\tif (rc)\n\t\tgoto err_out_release;\n\n\tdev->mem_start = pci_resource_start(pdev, 0);\n\tdev->base_addr = dev->mem_start;\n\tdev->mem_end = pci_resource_end(pdev, 0);\n\n\tdev->irq = pdev->irq;\n\n\tbp->regview = pci_ioremap_bar(pdev, 0);\n\tif (!bp->regview) {\n\t\tdev_err(&bp->pdev->dev,\n\t\t\t\"Cannot map register space, aborting\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_out_release;\n\t}\n\n\t/* In E1/E1H use pci device function given by kernel.\n\t * In E2/E3 read physical function from ME register since these chips\n\t * support Physical Device Assignment where kernel BDF maybe arbitrary\n\t * (depending on hypervisor).\n\t */\n\tif (chip_is_e1x) {\n\t\tbp->pf_num = PCI_FUNC(pdev->devfn);\n\t} else {\n\t\t/* chip is E2/3*/\n\t\tpci_read_config_dword(bp->pdev,\n\t\t\t\t      PCICFG_ME_REGISTER, &pci_cfg_dword);\n\t\tbp->pf_num = (u8)((pci_cfg_dword & ME_REG_ABS_PF_NUM) >>\n\t\t\t\t  ME_REG_ABS_PF_NUM_SHIFT);\n\t}\n\tBNX2X_DEV_INFO(\"me reg PF num: %d\\n\", bp->pf_num);\n\n\t/* clean indirect addresses */\n\tpci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS,\n\t\t\t       PCICFG_VENDOR_ID_OFFSET);\n\n\t/* Set PCIe reset type to fundamental for EEH recovery */\n\tpdev->needs_freset = 1;\n\n\t/* AER (Advanced Error reporting) configuration */\n\trc = pci_enable_pcie_error_reporting(pdev);\n\tif (!rc)\n\t\tbp->flags |= AER_ENABLED;\n\telse\n\t\tBNX2X_DEV_INFO(\"Failed To configure PCIe AER [%d]\\n\", rc);\n\n\t/*\n\t * Clean the following indirect addresses for all functions since it\n\t * is not used by the driver.\n\t */\n\tif (IS_PF(bp)) {\n\t\tREG_WR(bp, PXP2_REG_PGL_ADDR_88_F0, 0);\n\t\tREG_WR(bp, PXP2_REG_PGL_ADDR_8C_F0, 0);\n\t\tREG_WR(bp, PXP2_REG_PGL_ADDR_90_F0, 0);\n\t\tREG_WR(bp, PXP2_REG_PGL_ADDR_94_F0, 0);\n\n\t\tif (chip_is_e1x) {\n\t\t\tREG_WR(bp, PXP2_REG_PGL_ADDR_88_F1, 0);\n\t\t\tREG_WR(bp, PXP2_REG_PGL_ADDR_8C_F1, 0);\n\t\t\tREG_WR(bp, PXP2_REG_PGL_ADDR_90_F1, 0);\n\t\t\tREG_WR(bp, PXP2_REG_PGL_ADDR_94_F1, 0);\n\t\t}\n\n\t\t/* Enable internal target-read (in case we are probed after PF\n\t\t * FLR). Must be done prior to any BAR read access. Only for\n\t\t * 57712 and up\n\t\t */\n\t\tif (!chip_is_e1x)\n\t\t\tREG_WR(bp,\n\t\t\t       PGLUE_B_REG_INTERNAL_PFID_ENABLE_TARGET_READ, 1);\n\t}\n\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\tdev->netdev_ops = &bnx2x_netdev_ops;\n\tbnx2x_set_ethtool_ops(bp, dev);\n\n\tdev->priv_flags |= IFF_UNICAST_FLT;\n\n\tdev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\n\t\tNETIF_F_TSO | NETIF_F_TSO_ECN | NETIF_F_TSO6 |\n\t\tNETIF_F_RXCSUM | NETIF_F_LRO | NETIF_F_GRO | NETIF_F_GRO_HW |\n\t\tNETIF_F_RXHASH | NETIF_F_HW_VLAN_CTAG_TX;\n\tif (!chip_is_e1x) {\n\t\tdev->hw_features |= NETIF_F_GSO_GRE | NETIF_F_GSO_GRE_CSUM |\n\t\t\t\t    NETIF_F_GSO_IPXIP4 |\n\t\t\t\t    NETIF_F_GSO_UDP_TUNNEL |\n\t\t\t\t    NETIF_F_GSO_UDP_TUNNEL_CSUM |\n\t\t\t\t    NETIF_F_GSO_PARTIAL;\n\n\t\tdev->hw_enc_features =\n\t\t\tNETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | NETIF_F_SG |\n\t\t\tNETIF_F_TSO | NETIF_F_TSO_ECN | NETIF_F_TSO6 |\n\t\t\tNETIF_F_GSO_IPXIP4 |\n\t\t\tNETIF_F_GSO_GRE | NETIF_F_GSO_GRE_CSUM |\n\t\t\tNETIF_F_GSO_UDP_TUNNEL | NETIF_F_GSO_UDP_TUNNEL_CSUM |\n\t\t\tNETIF_F_GSO_PARTIAL;\n\n\t\tdev->gso_partial_features = NETIF_F_GSO_GRE_CSUM |\n\t\t\t\t\t    NETIF_F_GSO_UDP_TUNNEL_CSUM;\n\n\t\tif (IS_PF(bp))\n\t\t\tdev->udp_tunnel_nic_info = &bnx2x_udp_tunnels;\n\t}\n\n\tdev->vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\n\t\tNETIF_F_TSO | NETIF_F_TSO_ECN | NETIF_F_TSO6 | NETIF_F_HIGHDMA;\n\n\tif (IS_PF(bp)) {\n\t\tif (chip_is_e1x)\n\t\t\tbp->accept_any_vlan = true;\n\t\telse\n\t\t\tdev->hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n\t}\n\t/* For VF we'll know whether to enable VLAN filtering after\n\t * getting a response to CHANNEL_TLV_ACQUIRE from PF.\n\t */\n\n\tdev->features |= dev->hw_features | NETIF_F_HW_VLAN_CTAG_RX;\n\tdev->features |= NETIF_F_HIGHDMA;\n\tif (dev->features & NETIF_F_LRO)\n\t\tdev->features &= ~NETIF_F_GRO_HW;\n\n\t/* Add Loopback capability to the device */\n\tdev->hw_features |= NETIF_F_LOOPBACK;\n\n#ifdef BCM_DCBNL\n\tdev->dcbnl_ops = &bnx2x_dcbnl_ops;\n#endif\n\n\t/* MTU range, 46 - 9600 */\n\tdev->min_mtu = ETH_MIN_PACKET_SIZE;\n\tdev->max_mtu = ETH_MAX_JUMBO_PACKET_SIZE;\n\n\t/* get_port_hwinfo() will set prtad and mmds properly */\n\tbp->mdio.prtad = MDIO_PRTAD_NONE;\n\tbp->mdio.mmds = 0;\n\tbp->mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;\n\tbp->mdio.dev = dev;\n\tbp->mdio.mdio_read = bnx2x_mdio_read;\n\tbp->mdio.mdio_write = bnx2x_mdio_write;\n\n\treturn 0;\n\nerr_out_release:\n\tif (atomic_read(&pdev->enable_cnt) == 1)\n\t\tpci_release_regions(pdev);\n\nerr_out_disable:\n\tpci_disable_device(pdev);\n\nerr_out:\n\treturn rc;\n}\n\nstatic int bnx2x_check_firmware(struct bnx2x *bp)\n{\n\tconst struct firmware *firmware = bp->firmware;\n\tstruct bnx2x_fw_file_hdr *fw_hdr;\n\tstruct bnx2x_fw_file_section *sections;\n\tu32 offset, len, num_ops;\n\t__be16 *ops_offsets;\n\tint i;\n\tconst u8 *fw_ver;\n\n\tif (firmware->size < sizeof(struct bnx2x_fw_file_hdr)) {\n\t\tBNX2X_ERR(\"Wrong FW size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfw_hdr = (struct bnx2x_fw_file_hdr *)firmware->data;\n\tsections = (struct bnx2x_fw_file_section *)fw_hdr;\n\n\t/* Make sure none of the offsets and sizes make us read beyond\n\t * the end of the firmware data */\n\tfor (i = 0; i < sizeof(*fw_hdr) / sizeof(*sections); i++) {\n\t\toffset = be32_to_cpu(sections[i].offset);\n\t\tlen = be32_to_cpu(sections[i].len);\n\t\tif (offset + len > firmware->size) {\n\t\t\tBNX2X_ERR(\"Section %d length is out of bounds\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Likewise for the init_ops offsets */\n\toffset = be32_to_cpu(fw_hdr->init_ops_offsets.offset);\n\tops_offsets = (__force __be16 *)(firmware->data + offset);\n\tnum_ops = be32_to_cpu(fw_hdr->init_ops.len) / sizeof(struct raw_op);\n\n\tfor (i = 0; i < be32_to_cpu(fw_hdr->init_ops_offsets.len) / 2; i++) {\n\t\tif (be16_to_cpu(ops_offsets[i]) > num_ops) {\n\t\t\tBNX2X_ERR(\"Section offset %d is out of bounds\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Check FW version */\n\toffset = be32_to_cpu(fw_hdr->fw_version.offset);\n\tfw_ver = firmware->data + offset;\n\tif ((fw_ver[0] != BCM_5710_FW_MAJOR_VERSION) ||\n\t    (fw_ver[1] != BCM_5710_FW_MINOR_VERSION) ||\n\t    (fw_ver[2] != BCM_5710_FW_REVISION_VERSION) ||\n\t    (fw_ver[3] != BCM_5710_FW_ENGINEERING_VERSION)) {\n\t\tBNX2X_ERR(\"Bad FW version:%d.%d.%d.%d. Should be %d.%d.%d.%d\\n\",\n\t\t       fw_ver[0], fw_ver[1], fw_ver[2], fw_ver[3],\n\t\t       BCM_5710_FW_MAJOR_VERSION,\n\t\t       BCM_5710_FW_MINOR_VERSION,\n\t\t       BCM_5710_FW_REVISION_VERSION,\n\t\t       BCM_5710_FW_ENGINEERING_VERSION);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void be32_to_cpu_n(const u8 *_source, u8 *_target, u32 n)\n{\n\tconst __be32 *source = (const __be32 *)_source;\n\tu32 *target = (u32 *)_target;\n\tu32 i;\n\n\tfor (i = 0; i < n/4; i++)\n\t\ttarget[i] = be32_to_cpu(source[i]);\n}\n\n/*\n   Ops array is stored in the following format:\n   {op(8bit), offset(24bit, big endian), data(32bit, big endian)}\n */\nstatic void bnx2x_prep_ops(const u8 *_source, u8 *_target, u32 n)\n{\n\tconst __be32 *source = (const __be32 *)_source;\n\tstruct raw_op *target = (struct raw_op *)_target;\n\tu32 i, j, tmp;\n\n\tfor (i = 0, j = 0; i < n/8; i++, j += 2) {\n\t\ttmp = be32_to_cpu(source[j]);\n\t\ttarget[i].op = (tmp >> 24) & 0xff;\n\t\ttarget[i].offset = tmp & 0xffffff;\n\t\ttarget[i].raw_data = be32_to_cpu(source[j + 1]);\n\t}\n}\n\n/* IRO array is stored in the following format:\n * {base(24bit), m1(16bit), m2(16bit), m3(16bit), size(16bit) }\n */\nstatic void bnx2x_prep_iro(const u8 *_source, u8 *_target, u32 n)\n{\n\tconst __be32 *source = (const __be32 *)_source;\n\tstruct iro *target = (struct iro *)_target;\n\tu32 i, j, tmp;\n\n\tfor (i = 0, j = 0; i < n/sizeof(struct iro); i++) {\n\t\ttarget[i].base = be32_to_cpu(source[j]);\n\t\tj++;\n\t\ttmp = be32_to_cpu(source[j]);\n\t\ttarget[i].m1 = (tmp >> 16) & 0xffff;\n\t\ttarget[i].m2 = tmp & 0xffff;\n\t\tj++;\n\t\ttmp = be32_to_cpu(source[j]);\n\t\ttarget[i].m3 = (tmp >> 16) & 0xffff;\n\t\ttarget[i].size = tmp & 0xffff;\n\t\tj++;\n\t}\n}\n\nstatic void be16_to_cpu_n(const u8 *_source, u8 *_target, u32 n)\n{\n\tconst __be16 *source = (const __be16 *)_source;\n\tu16 *target = (u16 *)_target;\n\tu32 i;\n\n\tfor (i = 0; i < n/2; i++)\n\t\ttarget[i] = be16_to_cpu(source[i]);\n}\n\n#define BNX2X_ALLOC_AND_SET(arr, lbl, func)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tu32 len = be32_to_cpu(fw_hdr->arr.len);\t\t\t\t\\\n\tbp->arr = kmalloc(len, GFP_KERNEL);\t\t\t\t\\\n\tif (!bp->arr)\t\t\t\t\t\t\t\\\n\t\tgoto lbl;\t\t\t\t\t\t\\\n\tfunc(bp->firmware->data + be32_to_cpu(fw_hdr->arr.offset),\t\\\n\t     (u8 *)bp->arr, len);\t\t\t\t\t\\\n} while (0)\n\nstatic int bnx2x_init_firmware(struct bnx2x *bp)\n{\n\tconst char *fw_file_name;\n\tstruct bnx2x_fw_file_hdr *fw_hdr;\n\tint rc;\n\n\tif (bp->firmware)\n\t\treturn 0;\n\n\tif (CHIP_IS_E1(bp))\n\t\tfw_file_name = FW_FILE_NAME_E1;\n\telse if (CHIP_IS_E1H(bp))\n\t\tfw_file_name = FW_FILE_NAME_E1H;\n\telse if (!CHIP_IS_E1x(bp))\n\t\tfw_file_name = FW_FILE_NAME_E2;\n\telse {\n\t\tBNX2X_ERR(\"Unsupported chip revision\\n\");\n\t\treturn -EINVAL;\n\t}\n\tBNX2X_DEV_INFO(\"Loading %s\\n\", fw_file_name);\n\n\trc = request_firmware(&bp->firmware, fw_file_name, &bp->pdev->dev);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Can't load firmware file %s\\n\",\n\t\t\t  fw_file_name);\n\t\tgoto request_firmware_exit;\n\t}\n\n\trc = bnx2x_check_firmware(bp);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Corrupt firmware file %s\\n\", fw_file_name);\n\t\tgoto request_firmware_exit;\n\t}\n\n\tfw_hdr = (struct bnx2x_fw_file_hdr *)bp->firmware->data;\n\n\t/* Initialize the pointers to the init arrays */\n\t/* Blob */\n\trc = -ENOMEM;\n\tBNX2X_ALLOC_AND_SET(init_data, request_firmware_exit, be32_to_cpu_n);\n\n\t/* Opcodes */\n\tBNX2X_ALLOC_AND_SET(init_ops, init_ops_alloc_err, bnx2x_prep_ops);\n\n\t/* Offsets */\n\tBNX2X_ALLOC_AND_SET(init_ops_offsets, init_offsets_alloc_err,\n\t\t\t    be16_to_cpu_n);\n\n\t/* STORMs firmware */\n\tINIT_TSEM_INT_TABLE_DATA(bp) = bp->firmware->data +\n\t\t\tbe32_to_cpu(fw_hdr->tsem_int_table_data.offset);\n\tINIT_TSEM_PRAM_DATA(bp)      = bp->firmware->data +\n\t\t\tbe32_to_cpu(fw_hdr->tsem_pram_data.offset);\n\tINIT_USEM_INT_TABLE_DATA(bp) = bp->firmware->data +\n\t\t\tbe32_to_cpu(fw_hdr->usem_int_table_data.offset);\n\tINIT_USEM_PRAM_DATA(bp)      = bp->firmware->data +\n\t\t\tbe32_to_cpu(fw_hdr->usem_pram_data.offset);\n\tINIT_XSEM_INT_TABLE_DATA(bp) = bp->firmware->data +\n\t\t\tbe32_to_cpu(fw_hdr->xsem_int_table_data.offset);\n\tINIT_XSEM_PRAM_DATA(bp)      = bp->firmware->data +\n\t\t\tbe32_to_cpu(fw_hdr->xsem_pram_data.offset);\n\tINIT_CSEM_INT_TABLE_DATA(bp) = bp->firmware->data +\n\t\t\tbe32_to_cpu(fw_hdr->csem_int_table_data.offset);\n\tINIT_CSEM_PRAM_DATA(bp)      = bp->firmware->data +\n\t\t\tbe32_to_cpu(fw_hdr->csem_pram_data.offset);\n\t/* IRO */\n\tBNX2X_ALLOC_AND_SET(iro_arr, iro_alloc_err, bnx2x_prep_iro);\n\n\treturn 0;\n\niro_alloc_err:\n\tkfree(bp->init_ops_offsets);\ninit_offsets_alloc_err:\n\tkfree(bp->init_ops);\ninit_ops_alloc_err:\n\tkfree(bp->init_data);\nrequest_firmware_exit:\n\trelease_firmware(bp->firmware);\n\tbp->firmware = NULL;\n\n\treturn rc;\n}\n\nstatic void bnx2x_release_firmware(struct bnx2x *bp)\n{\n\tkfree(bp->init_ops_offsets);\n\tkfree(bp->init_ops);\n\tkfree(bp->init_data);\n\trelease_firmware(bp->firmware);\n\tbp->firmware = NULL;\n}\n\nstatic struct bnx2x_func_sp_drv_ops bnx2x_func_sp_drv = {\n\t.init_hw_cmn_chip = bnx2x_init_hw_common_chip,\n\t.init_hw_cmn      = bnx2x_init_hw_common,\n\t.init_hw_port     = bnx2x_init_hw_port,\n\t.init_hw_func     = bnx2x_init_hw_func,\n\n\t.reset_hw_cmn     = bnx2x_reset_common,\n\t.reset_hw_port    = bnx2x_reset_port,\n\t.reset_hw_func    = bnx2x_reset_func,\n\n\t.gunzip_init      = bnx2x_gunzip_init,\n\t.gunzip_end       = bnx2x_gunzip_end,\n\n\t.init_fw          = bnx2x_init_firmware,\n\t.release_fw       = bnx2x_release_firmware,\n};\n\nvoid bnx2x__init_func_obj(struct bnx2x *bp)\n{\n\t/* Prepare DMAE related driver resources */\n\tbnx2x_setup_dmae(bp);\n\n\tbnx2x_init_func_obj(bp, &bp->func_obj,\n\t\t\t    bnx2x_sp(bp, func_rdata),\n\t\t\t    bnx2x_sp_mapping(bp, func_rdata),\n\t\t\t    bnx2x_sp(bp, func_afex_rdata),\n\t\t\t    bnx2x_sp_mapping(bp, func_afex_rdata),\n\t\t\t    &bnx2x_func_sp_drv);\n}\n\n/* must be called after sriov-enable */\nstatic int bnx2x_set_qm_cid_count(struct bnx2x *bp)\n{\n\tint cid_count = BNX2X_L2_MAX_CID(bp);\n\n\tif (IS_SRIOV(bp))\n\t\tcid_count += BNX2X_VF_CIDS;\n\n\tif (CNIC_SUPPORT(bp))\n\t\tcid_count += CNIC_CID_MAX;\n\n\treturn roundup(cid_count, QM_CID_ROUND);\n}\n\n/**\n * bnx2x_get_num_none_def_sbs - return the number of none default SBs\n * @pdev: pci device\n * @cnic_cnt: count\n *\n */\nstatic int bnx2x_get_num_non_def_sbs(struct pci_dev *pdev, int cnic_cnt)\n{\n\tint index;\n\tu16 control = 0;\n\n\t/*\n\t * If MSI-X is not supported - return number of SBs needed to support\n\t * one fast path queue: one FP queue + SB for CNIC\n\t */\n\tif (!pdev->msix_cap) {\n\t\tdev_info(&pdev->dev, \"no msix capability found\\n\");\n\t\treturn 1 + cnic_cnt;\n\t}\n\tdev_info(&pdev->dev, \"msix capability found\\n\");\n\n\t/*\n\t * The value in the PCI configuration space is the index of the last\n\t * entry, namely one less than the actual size of the table, which is\n\t * exactly what we want to return from this function: number of all SBs\n\t * without the default SB.\n\t * For VFs there is no default SB, then we return (index+1).\n\t */\n\tpci_read_config_word(pdev, pdev->msix_cap + PCI_MSIX_FLAGS, &control);\n\n\tindex = control & PCI_MSIX_FLAGS_QSIZE;\n\n\treturn index;\n}\n\nstatic int set_max_cos_est(int chip_id)\n{\n\tswitch (chip_id) {\n\tcase BCM57710:\n\tcase BCM57711:\n\tcase BCM57711E:\n\t\treturn BNX2X_MULTI_TX_COS_E1X;\n\tcase BCM57712:\n\tcase BCM57712_MF:\n\t\treturn BNX2X_MULTI_TX_COS_E2_E3A0;\n\tcase BCM57800:\n\tcase BCM57800_MF:\n\tcase BCM57810:\n\tcase BCM57810_MF:\n\tcase BCM57840_4_10:\n\tcase BCM57840_2_20:\n\tcase BCM57840_O:\n\tcase BCM57840_MFO:\n\tcase BCM57840_MF:\n\tcase BCM57811:\n\tcase BCM57811_MF:\n\t\treturn BNX2X_MULTI_TX_COS_E3B0;\n\tcase BCM57712_VF:\n\tcase BCM57800_VF:\n\tcase BCM57810_VF:\n\tcase BCM57840_VF:\n\tcase BCM57811_VF:\n\t\treturn 1;\n\tdefault:\n\t\tpr_err(\"Unknown board_type (%d), aborting\\n\", chip_id);\n\t\treturn -ENODEV;\n\t}\n}\n\nstatic int set_is_vf(int chip_id)\n{\n\tswitch (chip_id) {\n\tcase BCM57712_VF:\n\tcase BCM57800_VF:\n\tcase BCM57810_VF:\n\tcase BCM57840_VF:\n\tcase BCM57811_VF:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/* nig_tsgen registers relative address */\n#define tsgen_ctrl 0x0\n#define tsgen_freecount 0x10\n#define tsgen_synctime_t0 0x20\n#define tsgen_offset_t0 0x28\n#define tsgen_drift_t0 0x30\n#define tsgen_synctime_t1 0x58\n#define tsgen_offset_t1 0x60\n#define tsgen_drift_t1 0x68\n\n/* FW workaround for setting drift */\nstatic int bnx2x_send_update_drift_ramrod(struct bnx2x *bp, int drift_dir,\n\t\t\t\t\t  int best_val, int best_period)\n{\n\tstruct bnx2x_func_state_params func_params = {NULL};\n\tstruct bnx2x_func_set_timesync_params *set_timesync_params =\n\t\t&func_params.params.set_timesync;\n\n\t/* Prepare parameters for function state transitions */\n\t__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\n\t__set_bit(RAMROD_RETRY, &func_params.ramrod_flags);\n\n\tfunc_params.f_obj = &bp->func_obj;\n\tfunc_params.cmd = BNX2X_F_CMD_SET_TIMESYNC;\n\n\t/* Function parameters */\n\tset_timesync_params->drift_adjust_cmd = TS_DRIFT_ADJUST_SET;\n\tset_timesync_params->offset_cmd = TS_OFFSET_KEEP;\n\tset_timesync_params->add_sub_drift_adjust_value =\n\t\tdrift_dir ? TS_ADD_VALUE : TS_SUB_VALUE;\n\tset_timesync_params->drift_adjust_value = best_val;\n\tset_timesync_params->drift_adjust_period = best_period;\n\n\treturn bnx2x_func_state_change(bp, &func_params);\n}\n\nstatic int bnx2x_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\n{\n\tstruct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);\n\tint rc;\n\tint drift_dir = 1;\n\tint val, period, period1, period2, dif, dif1, dif2;\n\tint best_dif = BNX2X_MAX_PHC_DRIFT, best_period = 0, best_val = 0;\n\n\tDP(BNX2X_MSG_PTP, \"PTP adjfreq called, ppb = %d\\n\", ppb);\n\n\tif (!netif_running(bp->dev)) {\n\t\tDP(BNX2X_MSG_PTP,\n\t\t   \"PTP adjfreq called while the interface is down\\n\");\n\t\treturn -ENETDOWN;\n\t}\n\n\tif (ppb < 0) {\n\t\tppb = -ppb;\n\t\tdrift_dir = 0;\n\t}\n\n\tif (ppb == 0) {\n\t\tbest_val = 1;\n\t\tbest_period = 0x1FFFFFF;\n\t} else if (ppb >= BNX2X_MAX_PHC_DRIFT) {\n\t\tbest_val = 31;\n\t\tbest_period = 1;\n\t} else {\n\t\t/* Changed not to allow val = 8, 16, 24 as these values\n\t\t * are not supported in workaround.\n\t\t */\n\t\tfor (val = 0; val <= 31; val++) {\n\t\t\tif ((val & 0x7) == 0)\n\t\t\t\tcontinue;\n\t\t\tperiod1 = val * 1000000 / ppb;\n\t\t\tperiod2 = period1 + 1;\n\t\t\tif (period1 != 0)\n\t\t\t\tdif1 = ppb - (val * 1000000 / period1);\n\t\t\telse\n\t\t\t\tdif1 = BNX2X_MAX_PHC_DRIFT;\n\t\t\tif (dif1 < 0)\n\t\t\t\tdif1 = -dif1;\n\t\t\tdif2 = ppb - (val * 1000000 / period2);\n\t\t\tif (dif2 < 0)\n\t\t\t\tdif2 = -dif2;\n\t\t\tdif = (dif1 < dif2) ? dif1 : dif2;\n\t\t\tperiod = (dif1 < dif2) ? period1 : period2;\n\t\t\tif (dif < best_dif) {\n\t\t\t\tbest_dif = dif;\n\t\t\t\tbest_val = val;\n\t\t\t\tbest_period = period;\n\t\t\t}\n\t\t}\n\t}\n\n\trc = bnx2x_send_update_drift_ramrod(bp, drift_dir, best_val,\n\t\t\t\t\t    best_period);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Failed to set drift\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tDP(BNX2X_MSG_PTP, \"Configured val = %d, period = %d\\n\", best_val,\n\t   best_period);\n\n\treturn 0;\n}\n\nstatic int bnx2x_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);\n\n\tif (!netif_running(bp->dev)) {\n\t\tDP(BNX2X_MSG_PTP,\n\t\t   \"PTP adjtime called while the interface is down\\n\");\n\t\treturn -ENETDOWN;\n\t}\n\n\tDP(BNX2X_MSG_PTP, \"PTP adjtime called, delta = %llx\\n\", delta);\n\n\ttimecounter_adjtime(&bp->timecounter, delta);\n\n\treturn 0;\n}\n\nstatic int bnx2x_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tstruct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);\n\tu64 ns;\n\n\tif (!netif_running(bp->dev)) {\n\t\tDP(BNX2X_MSG_PTP,\n\t\t   \"PTP gettime called while the interface is down\\n\");\n\t\treturn -ENETDOWN;\n\t}\n\n\tns = timecounter_read(&bp->timecounter);\n\n\tDP(BNX2X_MSG_PTP, \"PTP gettime called, ns = %llu\\n\", ns);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\nstatic int bnx2x_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t     const struct timespec64 *ts)\n{\n\tstruct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);\n\tu64 ns;\n\n\tif (!netif_running(bp->dev)) {\n\t\tDP(BNX2X_MSG_PTP,\n\t\t   \"PTP settime called while the interface is down\\n\");\n\t\treturn -ENETDOWN;\n\t}\n\n\tns = timespec64_to_ns(ts);\n\n\tDP(BNX2X_MSG_PTP, \"PTP settime called, ns = %llu\\n\", ns);\n\n\t/* Re-init the timecounter */\n\ttimecounter_init(&bp->timecounter, &bp->cyclecounter, ns);\n\n\treturn 0;\n}\n\n/* Enable (or disable) ancillary features of the phc subsystem */\nstatic int bnx2x_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t    struct ptp_clock_request *rq, int on)\n{\n\tstruct bnx2x *bp = container_of(ptp, struct bnx2x, ptp_clock_info);\n\n\tBNX2X_ERR(\"PHC ancillary features are not supported\\n\");\n\treturn -ENOTSUPP;\n}\n\nvoid bnx2x_register_phc(struct bnx2x *bp)\n{\n\t/* Fill the ptp_clock_info struct and register PTP clock*/\n\tbp->ptp_clock_info.owner = THIS_MODULE;\n\tsnprintf(bp->ptp_clock_info.name, 16, \"%s\", bp->dev->name);\n\tbp->ptp_clock_info.max_adj = BNX2X_MAX_PHC_DRIFT; /* In PPB */\n\tbp->ptp_clock_info.n_alarm = 0;\n\tbp->ptp_clock_info.n_ext_ts = 0;\n\tbp->ptp_clock_info.n_per_out = 0;\n\tbp->ptp_clock_info.pps = 0;\n\tbp->ptp_clock_info.adjfreq = bnx2x_ptp_adjfreq;\n\tbp->ptp_clock_info.adjtime = bnx2x_ptp_adjtime;\n\tbp->ptp_clock_info.gettime64 = bnx2x_ptp_gettime;\n\tbp->ptp_clock_info.settime64 = bnx2x_ptp_settime;\n\tbp->ptp_clock_info.enable = bnx2x_ptp_enable;\n\n\tbp->ptp_clock = ptp_clock_register(&bp->ptp_clock_info, &bp->pdev->dev);\n\tif (IS_ERR(bp->ptp_clock)) {\n\t\tbp->ptp_clock = NULL;\n\t\tBNX2X_ERR(\"PTP clock registration failed\\n\");\n\t}\n}\n\nstatic int bnx2x_init_one(struct pci_dev *pdev,\n\t\t\t\t    const struct pci_device_id *ent)\n{\n\tstruct net_device *dev = NULL;\n\tstruct bnx2x *bp;\n\tint rc, max_non_def_sbs;\n\tint rx_count, tx_count, rss_count, doorbell_size;\n\tint max_cos_est;\n\tbool is_vf;\n\tint cnic_cnt;\n\n\t/* Management FW 'remembers' living interfaces. Allow it some time\n\t * to forget previously living interfaces, allowing a proper re-load.\n\t */\n\tif (is_kdump_kernel()) {\n\t\tktime_t now = ktime_get_boottime();\n\t\tktime_t fw_ready_time = ktime_set(5, 0);\n\n\t\tif (ktime_before(now, fw_ready_time))\n\t\t\tmsleep(ktime_ms_delta(fw_ready_time, now));\n\t}\n\n\t/* An estimated maximum supported CoS number according to the chip\n\t * version.\n\t * We will try to roughly estimate the maximum number of CoSes this chip\n\t * may support in order to minimize the memory allocated for Tx\n\t * netdev_queue's. This number will be accurately calculated during the\n\t * initialization of bp->max_cos based on the chip versions AND chip\n\t * revision in the bnx2x_init_bp().\n\t */\n\tmax_cos_est = set_max_cos_est(ent->driver_data);\n\tif (max_cos_est < 0)\n\t\treturn max_cos_est;\n\tis_vf = set_is_vf(ent->driver_data);\n\tcnic_cnt = is_vf ? 0 : 1;\n\n\tmax_non_def_sbs = bnx2x_get_num_non_def_sbs(pdev, cnic_cnt);\n\n\t/* add another SB for VF as it has no default SB */\n\tmax_non_def_sbs += is_vf ? 1 : 0;\n\n\t/* Maximum number of RSS queues: one IGU SB goes to CNIC */\n\trss_count = max_non_def_sbs - cnic_cnt;\n\n\tif (rss_count < 1)\n\t\treturn -EINVAL;\n\n\t/* Maximum number of netdev Rx queues: RSS + FCoE L2 */\n\trx_count = rss_count + cnic_cnt;\n\n\t/* Maximum number of netdev Tx queues:\n\t * Maximum TSS queues * Maximum supported number of CoS  + FCoE L2\n\t */\n\ttx_count = rss_count * max_cos_est + cnic_cnt;\n\n\t/* dev zeroed in init_etherdev */\n\tdev = alloc_etherdev_mqs(sizeof(*bp), tx_count, rx_count);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tbp = netdev_priv(dev);\n\n\tbp->flags = 0;\n\tif (is_vf)\n\t\tbp->flags |= IS_VF_FLAG;\n\n\tbp->igu_sb_cnt = max_non_def_sbs;\n\tbp->igu_base_addr = IS_VF(bp) ? PXP_VF_ADDR_IGU_START : BAR_IGU_INTMEM;\n\tbp->msg_enable = debug;\n\tbp->cnic_support = cnic_cnt;\n\tbp->cnic_probe = bnx2x_cnic_probe;\n\n\tpci_set_drvdata(pdev, dev);\n\n\trc = bnx2x_init_dev(bp, pdev, dev, ent->driver_data);\n\tif (rc < 0) {\n\t\tfree_netdev(dev);\n\t\treturn rc;\n\t}\n\n\tBNX2X_DEV_INFO(\"This is a %s function\\n\",\n\t\t       IS_PF(bp) ? \"physical\" : \"virtual\");\n\tBNX2X_DEV_INFO(\"Cnic support is %s\\n\", CNIC_SUPPORT(bp) ? \"on\" : \"off\");\n\tBNX2X_DEV_INFO(\"Max num of status blocks %d\\n\", max_non_def_sbs);\n\tBNX2X_DEV_INFO(\"Allocated netdev with %d tx and %d rx queues\\n\",\n\t\t       tx_count, rx_count);\n\n\trc = bnx2x_init_bp(bp);\n\tif (rc)\n\t\tgoto init_one_exit;\n\n\t/* Map doorbells here as we need the real value of bp->max_cos which\n\t * is initialized in bnx2x_init_bp() to determine the number of\n\t * l2 connections.\n\t */\n\tif (IS_VF(bp)) {\n\t\tbp->doorbells = bnx2x_vf_doorbells(bp);\n\t\trc = bnx2x_vf_pci_alloc(bp);\n\t\tif (rc)\n\t\t\tgoto init_one_freemem;\n\t} else {\n\t\tdoorbell_size = BNX2X_L2_MAX_CID(bp) * (1 << BNX2X_DB_SHIFT);\n\t\tif (doorbell_size > pci_resource_len(pdev, 2)) {\n\t\t\tdev_err(&bp->pdev->dev,\n\t\t\t\t\"Cannot map doorbells, bar size too small, aborting\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto init_one_freemem;\n\t\t}\n\t\tbp->doorbells = ioremap(pci_resource_start(pdev, 2),\n\t\t\t\t\t\tdoorbell_size);\n\t}\n\tif (!bp->doorbells) {\n\t\tdev_err(&bp->pdev->dev,\n\t\t\t\"Cannot map doorbell space, aborting\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto init_one_freemem;\n\t}\n\n\tif (IS_VF(bp)) {\n\t\trc = bnx2x_vfpf_acquire(bp, tx_count, rx_count);\n\t\tif (rc)\n\t\t\tgoto init_one_freemem;\n\n#ifdef CONFIG_BNX2X_SRIOV\n\t\t/* VF with OLD Hypervisor or old PF do not support filtering */\n\t\tif (bp->acquire_resp.pfdev_info.pf_cap & PFVF_CAP_VLAN_FILTER) {\n\t\t\tdev->hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n\t\t\tdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n\t\t}\n#endif\n\t}\n\n\t/* Enable SRIOV if capability found in configuration space */\n\trc = bnx2x_iov_init_one(bp, int_mode, BNX2X_MAX_NUM_OF_VFS);\n\tif (rc)\n\t\tgoto init_one_freemem;\n\n\t/* calc qm_cid_count */\n\tbp->qm_cid_count = bnx2x_set_qm_cid_count(bp);\n\tBNX2X_DEV_INFO(\"qm_cid_count %d\\n\", bp->qm_cid_count);\n\n\t/* disable FCOE L2 queue for E1x*/\n\tif (CHIP_IS_E1x(bp))\n\t\tbp->flags |= NO_FCOE_FLAG;\n\n\t/* Set bp->num_queues for MSI-X mode*/\n\tbnx2x_set_num_queues(bp);\n\n\t/* Configure interrupt mode: try to enable MSI-X/MSI if\n\t * needed.\n\t */\n\trc = bnx2x_set_int_mode(bp);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Cannot set interrupts\\n\");\n\t\tgoto init_one_freemem;\n\t}\n\tBNX2X_DEV_INFO(\"set interrupts successfully\\n\");\n\n\t/* register the net device */\n\trc = register_netdev(dev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Cannot register net device\\n\");\n\t\tgoto init_one_freemem;\n\t}\n\tBNX2X_DEV_INFO(\"device name after netdev register %s\\n\", dev->name);\n\n\tif (!NO_FCOE(bp)) {\n\t\t/* Add storage MAC address */\n\t\trtnl_lock();\n\t\tdev_addr_add(bp->dev, bp->fip_mac, NETDEV_HW_ADDR_T_SAN);\n\t\trtnl_unlock();\n\t}\n\tBNX2X_DEV_INFO(\n\t       \"%s (%c%d) PCI-E found at mem %lx, IRQ %d, node addr %pM\\n\",\n\t       board_info[ent->driver_data].name,\n\t       (CHIP_REV(bp) >> 12) + 'A', (CHIP_METAL(bp) >> 4),\n\t       dev->base_addr, bp->pdev->irq, dev->dev_addr);\n\tpcie_print_link_status(bp->pdev);\n\n\tif (!IS_MF_SD_STORAGE_PERSONALITY_ONLY(bp))\n\t\tbnx2x_set_os_driver_state(bp, OS_DRIVER_STATE_DISABLED);\n\n\treturn 0;\n\ninit_one_freemem:\n\tbnx2x_free_mem_bp(bp);\n\ninit_one_exit:\n\tbnx2x_disable_pcie_error_reporting(bp);\n\n\tif (bp->regview)\n\t\tiounmap(bp->regview);\n\n\tif (IS_PF(bp) && bp->doorbells)\n\t\tiounmap(bp->doorbells);\n\n\tfree_netdev(dev);\n\n\tif (atomic_read(&pdev->enable_cnt) == 1)\n\t\tpci_release_regions(pdev);\n\n\tpci_disable_device(pdev);\n\n\treturn rc;\n}\n\nstatic void __bnx2x_remove(struct pci_dev *pdev,\n\t\t\t   struct net_device *dev,\n\t\t\t   struct bnx2x *bp,\n\t\t\t   bool remove_netdev)\n{\n\t/* Delete storage MAC address */\n\tif (!NO_FCOE(bp)) {\n\t\trtnl_lock();\n\t\tdev_addr_del(bp->dev, bp->fip_mac, NETDEV_HW_ADDR_T_SAN);\n\t\trtnl_unlock();\n\t}\n\n#ifdef BCM_DCBNL\n\t/* Delete app tlvs from dcbnl */\n\tbnx2x_dcbnl_update_applist(bp, true);\n#endif\n\n\tif (IS_PF(bp) &&\n\t    !BP_NOMCP(bp) &&\n\t    (bp->flags & BC_SUPPORTS_RMMOD_CMD))\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_RMMOD, 0);\n\n\t/* Close the interface - either directly or implicitly */\n\tif (remove_netdev) {\n\t\tunregister_netdev(dev);\n\t} else {\n\t\trtnl_lock();\n\t\tdev_close(dev);\n\t\trtnl_unlock();\n\t}\n\n\tbnx2x_iov_remove_one(bp);\n\n\t/* Power on: we can't let PCI layer write to us while we are in D3 */\n\tif (IS_PF(bp)) {\n\t\tbnx2x_set_power_state(bp, PCI_D0);\n\t\tbnx2x_set_os_driver_state(bp, OS_DRIVER_STATE_NOT_LOADED);\n\n\t\t/* Set endianity registers to reset values in case next driver\n\t\t * boots in different endianty environment.\n\t\t */\n\t\tbnx2x_reset_endianity(bp);\n\t}\n\n\t/* Disable MSI/MSI-X */\n\tbnx2x_disable_msi(bp);\n\n\t/* Power off */\n\tif (IS_PF(bp))\n\t\tbnx2x_set_power_state(bp, PCI_D3hot);\n\n\t/* Make sure RESET task is not scheduled before continuing */\n\tcancel_delayed_work_sync(&bp->sp_rtnl_task);\n\n\t/* send message via vfpf channel to release the resources of this vf */\n\tif (IS_VF(bp))\n\t\tbnx2x_vfpf_release(bp);\n\n\t/* Assumes no further PCIe PM changes will occur */\n\tif (system_state == SYSTEM_POWER_OFF) {\n\t\tpci_wake_from_d3(pdev, bp->wol);\n\t\tpci_set_power_state(pdev, PCI_D3hot);\n\t}\n\n\tbnx2x_disable_pcie_error_reporting(bp);\n\tif (remove_netdev) {\n\t\tif (bp->regview)\n\t\t\tiounmap(bp->regview);\n\n\t\t/* For vfs, doorbells are part of the regview and were unmapped\n\t\t * along with it. FW is only loaded by PF.\n\t\t */\n\t\tif (IS_PF(bp)) {\n\t\t\tif (bp->doorbells)\n\t\t\t\tiounmap(bp->doorbells);\n\n\t\t\tbnx2x_release_firmware(bp);\n\t\t} else {\n\t\t\tbnx2x_vf_pci_dealloc(bp);\n\t\t}\n\t\tbnx2x_free_mem_bp(bp);\n\n\t\tfree_netdev(dev);\n\n\t\tif (atomic_read(&pdev->enable_cnt) == 1)\n\t\t\tpci_release_regions(pdev);\n\n\t\tpci_disable_device(pdev);\n\t}\n}\n\nstatic void bnx2x_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct bnx2x *bp;\n\n\tif (!dev) {\n\t\tdev_err(&pdev->dev, \"BAD net device from bnx2x_init_one\\n\");\n\t\treturn;\n\t}\n\tbp = netdev_priv(dev);\n\n\t__bnx2x_remove(pdev, dev, bp, true);\n}\n\nstatic int bnx2x_eeh_nic_unload(struct bnx2x *bp)\n{\n\tbp->state = BNX2X_STATE_CLOSING_WAIT4_HALT;\n\n\tbp->rx_mode = BNX2X_RX_MODE_NONE;\n\n\tif (CNIC_LOADED(bp))\n\t\tbnx2x_cnic_notify(bp, CNIC_CTL_STOP_CMD);\n\n\t/* Stop Tx */\n\tbnx2x_tx_disable(bp);\n\t/* Delete all NAPI objects */\n\tbnx2x_del_all_napi(bp);\n\tif (CNIC_LOADED(bp))\n\t\tbnx2x_del_all_napi_cnic(bp);\n\tnetdev_reset_tc(bp->dev);\n\n\tdel_timer_sync(&bp->timer);\n\tcancel_delayed_work_sync(&bp->sp_task);\n\tcancel_delayed_work_sync(&bp->period_task);\n\n\tif (!down_timeout(&bp->stats_lock, HZ / 10)) {\n\t\tbp->stats_state = STATS_STATE_DISABLED;\n\t\tup(&bp->stats_lock);\n\t}\n\n\tbnx2x_save_statistics(bp);\n\n\tnetif_carrier_off(bp->dev);\n\n\treturn 0;\n}\n\n/**\n * bnx2x_io_error_detected - called when PCI error is detected\n * @pdev: Pointer to PCI device\n * @state: The current pci connection state\n *\n * This function is called after a PCI bus error affecting\n * this device has been detected.\n */\nstatic pci_ers_result_t bnx2x_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t\tpci_channel_state_t state)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\trtnl_lock();\n\n\tBNX2X_ERR(\"IO error detected\\n\");\n\n\tnetif_device_detach(dev);\n\n\tif (state == pci_channel_io_perm_failure) {\n\t\trtnl_unlock();\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\tif (netif_running(dev))\n\t\tbnx2x_eeh_nic_unload(bp);\n\n\tbnx2x_prev_path_mark_eeh(bp);\n\n\tpci_disable_device(pdev);\n\n\trtnl_unlock();\n\n\t/* Request a slot reset */\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n/**\n * bnx2x_io_slot_reset - called after the PCI bus has been reset\n * @pdev: Pointer to PCI device\n *\n * Restart the card from scratch, as if from a cold-boot.\n */\nstatic pci_ers_result_t bnx2x_io_slot_reset(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tint i;\n\n\trtnl_lock();\n\tBNX2X_ERR(\"IO slot reset initializing...\\n\");\n\tif (pci_enable_device(pdev)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot re-enable PCI device after reset\\n\");\n\t\trtnl_unlock();\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_restore_state(pdev);\n\tpci_save_state(pdev);\n\n\tif (netif_running(dev))\n\t\tbnx2x_set_power_state(bp, PCI_D0);\n\n\tif (netif_running(dev)) {\n\t\tBNX2X_ERR(\"IO slot reset --> driver unload\\n\");\n\n\t\t/* MCP should have been reset; Need to wait for validity */\n\t\tif (bnx2x_init_shmem(bp)) {\n\t\t\trtnl_unlock();\n\t\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t\t}\n\n\t\tif (IS_PF(bp) && SHMEM2_HAS(bp, drv_capabilities_flag)) {\n\t\t\tu32 v;\n\n\t\t\tv = SHMEM2_RD(bp,\n\t\t\t\t      drv_capabilities_flag[BP_FW_MB_IDX(bp)]);\n\t\t\tSHMEM2_WR(bp, drv_capabilities_flag[BP_FW_MB_IDX(bp)],\n\t\t\t\t  v & ~DRV_FLAGS_CAPABILITIES_LOADED_L2);\n\t\t}\n\t\tbnx2x_drain_tx_queues(bp);\n\t\tbnx2x_send_unload_req(bp, UNLOAD_RECOVERY);\n\t\tbnx2x_netif_stop(bp, 1);\n\t\tbnx2x_free_irq(bp);\n\n\t\t/* Report UNLOAD_DONE to MCP */\n\t\tbnx2x_send_unload_done(bp, true);\n\n\t\tbp->sp_state = 0;\n\t\tbp->port.pmf = 0;\n\n\t\tbnx2x_prev_unload(bp);\n\n\t\t/* We should have reseted the engine, so It's fair to\n\t\t * assume the FW will no longer write to the bnx2x driver.\n\t\t */\n\t\tbnx2x_squeeze_objects(bp);\n\t\tbnx2x_free_skbs(bp);\n\t\tfor_each_rx_queue(bp, i)\n\t\t\tbnx2x_free_rx_sge_range(bp, bp->fp + i, NUM_RX_SGE);\n\t\tbnx2x_free_fp_mem(bp);\n\t\tbnx2x_free_mem(bp);\n\n\t\tbp->state = BNX2X_STATE_CLOSED;\n\t}\n\n\trtnl_unlock();\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\n/**\n * bnx2x_io_resume - called when traffic can start flowing again\n * @pdev: Pointer to PCI device\n *\n * This callback is called when the error recovery driver tells us that\n * its OK to resume normal operation.\n */\nstatic void bnx2x_io_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct bnx2x *bp = netdev_priv(dev);\n\n\tif (bp->recovery_state != BNX2X_RECOVERY_DONE) {\n\t\tnetdev_err(bp->dev, \"Handling parity error recovery. Try again later\\n\");\n\t\treturn;\n\t}\n\n\trtnl_lock();\n\n\tbp->fw_seq = SHMEM_RD(bp, func_mb[BP_FW_MB_IDX(bp)].drv_mb_header) &\n\t\t\t\t\t\t\tDRV_MSG_SEQ_NUMBER_MASK;\n\n\tif (netif_running(dev))\n\t\tbnx2x_nic_load(bp, LOAD_NORMAL);\n\n\tnetif_device_attach(dev);\n\n\trtnl_unlock();\n}\n\nstatic const struct pci_error_handlers bnx2x_err_handler = {\n\t.error_detected = bnx2x_io_error_detected,\n\t.slot_reset     = bnx2x_io_slot_reset,\n\t.resume         = bnx2x_io_resume,\n};\n\nstatic void bnx2x_shutdown(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct bnx2x *bp;\n\n\tif (!dev)\n\t\treturn;\n\n\tbp = netdev_priv(dev);\n\tif (!bp)\n\t\treturn;\n\n\trtnl_lock();\n\tnetif_device_detach(dev);\n\trtnl_unlock();\n\n\t/* Don't remove the netdevice, as there are scenarios which will cause\n\t * the kernel to hang, e.g., when trying to remove bnx2i while the\n\t * rootfs is mounted from SAN.\n\t */\n\t__bnx2x_remove(pdev, dev, bp, false);\n}\n\nstatic struct pci_driver bnx2x_pci_driver = {\n\t.name        = DRV_MODULE_NAME,\n\t.id_table    = bnx2x_pci_tbl,\n\t.probe       = bnx2x_init_one,\n\t.remove      = bnx2x_remove_one,\n\t.driver.pm   = &bnx2x_pm_ops,\n\t.err_handler = &bnx2x_err_handler,\n#ifdef CONFIG_BNX2X_SRIOV\n\t.sriov_configure = bnx2x_sriov_configure,\n#endif\n\t.shutdown    = bnx2x_shutdown,\n};\n\nstatic int __init bnx2x_init(void)\n{\n\tint ret;\n\n\tbnx2x_wq = create_singlethread_workqueue(\"bnx2x\");\n\tif (bnx2x_wq == NULL) {\n\t\tpr_err(\"Cannot create workqueue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tbnx2x_iov_wq = create_singlethread_workqueue(\"bnx2x_iov\");\n\tif (!bnx2x_iov_wq) {\n\t\tpr_err(\"Cannot create iov workqueue\\n\");\n\t\tdestroy_workqueue(bnx2x_wq);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = pci_register_driver(&bnx2x_pci_driver);\n\tif (ret) {\n\t\tpr_err(\"Cannot register driver\\n\");\n\t\tdestroy_workqueue(bnx2x_wq);\n\t\tdestroy_workqueue(bnx2x_iov_wq);\n\t}\n\treturn ret;\n}\n\nstatic void __exit bnx2x_cleanup(void)\n{\n\tstruct list_head *pos, *q;\n\n\tpci_unregister_driver(&bnx2x_pci_driver);\n\n\tdestroy_workqueue(bnx2x_wq);\n\tdestroy_workqueue(bnx2x_iov_wq);\n\n\t/* Free globally allocated resources */\n\tlist_for_each_safe(pos, q, &bnx2x_prev_list) {\n\t\tstruct bnx2x_prev_path_list *tmp =\n\t\t\tlist_entry(pos, struct bnx2x_prev_path_list, list);\n\t\tlist_del(pos);\n\t\tkfree(tmp);\n\t}\n}\n\nvoid bnx2x_notify_link_changed(struct bnx2x *bp)\n{\n\tREG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_12 + BP_FUNC(bp)*sizeof(u32), 1);\n}\n\nmodule_init(bnx2x_init);\nmodule_exit(bnx2x_cleanup);\n\n/**\n * bnx2x_set_iscsi_eth_mac_addr - set iSCSI MAC(s).\n * @bp:\t\tdriver handle\n *\n * This function will wait until the ramrod completion returns.\n * Return 0 if success, -ENODEV if ramrod doesn't return.\n */\nstatic int bnx2x_set_iscsi_eth_mac_addr(struct bnx2x *bp)\n{\n\tunsigned long ramrod_flags = 0;\n\n\t__set_bit(RAMROD_COMP_WAIT, &ramrod_flags);\n\treturn bnx2x_set_mac_one(bp, bp->cnic_eth_dev.iscsi_mac,\n\t\t\t\t &bp->iscsi_l2_mac_obj, true,\n\t\t\t\t BNX2X_ISCSI_ETH_MAC, &ramrod_flags);\n}\n\n/* count denotes the number of new completions we have seen */\nstatic void bnx2x_cnic_sp_post(struct bnx2x *bp, int count)\n{\n\tstruct eth_spe *spe;\n\tint cxt_index, cxt_offset;\n\n#ifdef BNX2X_STOP_ON_ERROR\n\tif (unlikely(bp->panic))\n\t\treturn;\n#endif\n\n\tspin_lock_bh(&bp->spq_lock);\n\tBUG_ON(bp->cnic_spq_pending < count);\n\tbp->cnic_spq_pending -= count;\n\n\tfor (; bp->cnic_kwq_pending; bp->cnic_kwq_pending--) {\n\t\tu16 type =  (le16_to_cpu(bp->cnic_kwq_cons->hdr.type)\n\t\t\t\t& SPE_HDR_CONN_TYPE) >>\n\t\t\t\tSPE_HDR_CONN_TYPE_SHIFT;\n\t\tu8 cmd = (le32_to_cpu(bp->cnic_kwq_cons->hdr.conn_and_cmd_data)\n\t\t\t\t>> SPE_HDR_CMD_ID_SHIFT) & 0xff;\n\n\t\t/* Set validation for iSCSI L2 client before sending SETUP\n\t\t *  ramrod\n\t\t */\n\t\tif (type == ETH_CONNECTION_TYPE) {\n\t\t\tif (cmd == RAMROD_CMD_ID_ETH_CLIENT_SETUP) {\n\t\t\t\tcxt_index = BNX2X_ISCSI_ETH_CID(bp) /\n\t\t\t\t\tILT_PAGE_CIDS;\n\t\t\t\tcxt_offset = BNX2X_ISCSI_ETH_CID(bp) -\n\t\t\t\t\t(cxt_index * ILT_PAGE_CIDS);\n\t\t\t\tbnx2x_set_ctx_validation(bp,\n\t\t\t\t\t&bp->context[cxt_index].\n\t\t\t\t\t\t\t vcxt[cxt_offset].eth,\n\t\t\t\t\tBNX2X_ISCSI_ETH_CID(bp));\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * There may be not more than 8 L2, not more than 8 L5 SPEs\n\t\t * and in the air. We also check that number of outstanding\n\t\t * COMMON ramrods is not more than the EQ and SPQ can\n\t\t * accommodate.\n\t\t */\n\t\tif (type == ETH_CONNECTION_TYPE) {\n\t\t\tif (!atomic_read(&bp->cq_spq_left))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tatomic_dec(&bp->cq_spq_left);\n\t\t} else if (type == NONE_CONNECTION_TYPE) {\n\t\t\tif (!atomic_read(&bp->eq_spq_left))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tatomic_dec(&bp->eq_spq_left);\n\t\t} else if ((type == ISCSI_CONNECTION_TYPE) ||\n\t\t\t   (type == FCOE_CONNECTION_TYPE)) {\n\t\t\tif (bp->cnic_spq_pending >=\n\t\t\t    bp->cnic_eth_dev.max_kwqe_pending)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tbp->cnic_spq_pending++;\n\t\t} else {\n\t\t\tBNX2X_ERR(\"Unknown SPE type: %d\\n\", type);\n\t\t\tbnx2x_panic();\n\t\t\tbreak;\n\t\t}\n\n\t\tspe = bnx2x_sp_get_next(bp);\n\t\t*spe = *bp->cnic_kwq_cons;\n\n\t\tDP(BNX2X_MSG_SP, \"pending on SPQ %d, on KWQ %d count %d\\n\",\n\t\t   bp->cnic_spq_pending, bp->cnic_kwq_pending, count);\n\n\t\tif (bp->cnic_kwq_cons == bp->cnic_kwq_last)\n\t\t\tbp->cnic_kwq_cons = bp->cnic_kwq;\n\t\telse\n\t\t\tbp->cnic_kwq_cons++;\n\t}\n\tbnx2x_sp_prod_update(bp);\n\tspin_unlock_bh(&bp->spq_lock);\n}\n\nstatic int bnx2x_cnic_sp_queue(struct net_device *dev,\n\t\t\t       struct kwqe_16 *kwqes[], u32 count)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tint i;\n\n#ifdef BNX2X_STOP_ON_ERROR\n\tif (unlikely(bp->panic)) {\n\t\tBNX2X_ERR(\"Can't post to SP queue while panic\\n\");\n\t\treturn -EIO;\n\t}\n#endif\n\n\tif ((bp->recovery_state != BNX2X_RECOVERY_DONE) &&\n\t    (bp->recovery_state != BNX2X_RECOVERY_NIC_LOADING)) {\n\t\tBNX2X_ERR(\"Handling parity error recovery. Try again later\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tspin_lock_bh(&bp->spq_lock);\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct eth_spe *spe = (struct eth_spe *)kwqes[i];\n\n\t\tif (bp->cnic_kwq_pending == MAX_SP_DESC_CNT)\n\t\t\tbreak;\n\n\t\t*bp->cnic_kwq_prod = *spe;\n\n\t\tbp->cnic_kwq_pending++;\n\n\t\tDP(BNX2X_MSG_SP, \"L5 SPQE %x %x %x:%x pos %d\\n\",\n\t\t   spe->hdr.conn_and_cmd_data, spe->hdr.type,\n\t\t   spe->data.update_data_addr.hi,\n\t\t   spe->data.update_data_addr.lo,\n\t\t   bp->cnic_kwq_pending);\n\n\t\tif (bp->cnic_kwq_prod == bp->cnic_kwq_last)\n\t\t\tbp->cnic_kwq_prod = bp->cnic_kwq;\n\t\telse\n\t\t\tbp->cnic_kwq_prod++;\n\t}\n\n\tspin_unlock_bh(&bp->spq_lock);\n\n\tif (bp->cnic_spq_pending < bp->cnic_eth_dev.max_kwqe_pending)\n\t\tbnx2x_cnic_sp_post(bp, 0);\n\n\treturn i;\n}\n\nstatic int bnx2x_cnic_ctl_send(struct bnx2x *bp, struct cnic_ctl_info *ctl)\n{\n\tstruct cnic_ops *c_ops;\n\tint rc = 0;\n\n\tmutex_lock(&bp->cnic_mutex);\n\tc_ops = rcu_dereference_protected(bp->cnic_ops,\n\t\t\t\t\t  lockdep_is_held(&bp->cnic_mutex));\n\tif (c_ops)\n\t\trc = c_ops->cnic_ctl(bp->cnic_data, ctl);\n\tmutex_unlock(&bp->cnic_mutex);\n\n\treturn rc;\n}\n\nstatic int bnx2x_cnic_ctl_send_bh(struct bnx2x *bp, struct cnic_ctl_info *ctl)\n{\n\tstruct cnic_ops *c_ops;\n\tint rc = 0;\n\n\trcu_read_lock();\n\tc_ops = rcu_dereference(bp->cnic_ops);\n\tif (c_ops)\n\t\trc = c_ops->cnic_ctl(bp->cnic_data, ctl);\n\trcu_read_unlock();\n\n\treturn rc;\n}\n\n/*\n * for commands that have no data\n */\nint bnx2x_cnic_notify(struct bnx2x *bp, int cmd)\n{\n\tstruct cnic_ctl_info ctl = {0};\n\n\tctl.cmd = cmd;\n\n\treturn bnx2x_cnic_ctl_send(bp, &ctl);\n}\n\nstatic void bnx2x_cnic_cfc_comp(struct bnx2x *bp, int cid, u8 err)\n{\n\tstruct cnic_ctl_info ctl = {0};\n\n\t/* first we tell CNIC and only then we count this as a completion */\n\tctl.cmd = CNIC_CTL_COMPLETION_CMD;\n\tctl.data.comp.cid = cid;\n\tctl.data.comp.error = err;\n\n\tbnx2x_cnic_ctl_send_bh(bp, &ctl);\n\tbnx2x_cnic_sp_post(bp, 0);\n}\n\n/* Called with netif_addr_lock_bh() taken.\n * Sets an rx_mode config for an iSCSI ETH client.\n * Doesn't block.\n * Completion should be checked outside.\n */\nstatic void bnx2x_set_iscsi_eth_rx_mode(struct bnx2x *bp, bool start)\n{\n\tunsigned long accept_flags = 0, ramrod_flags = 0;\n\tu8 cl_id = bnx2x_cnic_eth_cl_id(bp, BNX2X_ISCSI_ETH_CL_ID_IDX);\n\tint sched_state = BNX2X_FILTER_ISCSI_ETH_STOP_SCHED;\n\n\tif (start) {\n\t\t/* Start accepting on iSCSI L2 ring. Accept all multicasts\n\t\t * because it's the only way for UIO Queue to accept\n\t\t * multicasts (in non-promiscuous mode only one Queue per\n\t\t * function will receive multicast packets (leading in our\n\t\t * case).\n\t\t */\n\t\t__set_bit(BNX2X_ACCEPT_UNICAST, &accept_flags);\n\t\t__set_bit(BNX2X_ACCEPT_ALL_MULTICAST, &accept_flags);\n\t\t__set_bit(BNX2X_ACCEPT_BROADCAST, &accept_flags);\n\t\t__set_bit(BNX2X_ACCEPT_ANY_VLAN, &accept_flags);\n\n\t\t/* Clear STOP_PENDING bit if START is requested */\n\t\tclear_bit(BNX2X_FILTER_ISCSI_ETH_STOP_SCHED, &bp->sp_state);\n\n\t\tsched_state = BNX2X_FILTER_ISCSI_ETH_START_SCHED;\n\t} else\n\t\t/* Clear START_PENDING bit if STOP is requested */\n\t\tclear_bit(BNX2X_FILTER_ISCSI_ETH_START_SCHED, &bp->sp_state);\n\n\tif (test_bit(BNX2X_FILTER_RX_MODE_PENDING, &bp->sp_state))\n\t\tset_bit(sched_state, &bp->sp_state);\n\telse {\n\t\t__set_bit(RAMROD_RX, &ramrod_flags);\n\t\tbnx2x_set_q_rx_mode(bp, cl_id, 0, accept_flags, 0,\n\t\t\t\t    ramrod_flags);\n\t}\n}\n\nstatic int bnx2x_drv_ctl(struct net_device *dev, struct drv_ctl_info *ctl)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tint rc = 0;\n\n\tswitch (ctl->cmd) {\n\tcase DRV_CTL_CTXTBL_WR_CMD: {\n\t\tu32 index = ctl->data.io.offset;\n\t\tdma_addr_t addr = ctl->data.io.dma_addr;\n\n\t\tbnx2x_ilt_wr(bp, index, addr);\n\t\tbreak;\n\t}\n\n\tcase DRV_CTL_RET_L5_SPQ_CREDIT_CMD: {\n\t\tint count = ctl->data.credit.credit_count;\n\n\t\tbnx2x_cnic_sp_post(bp, count);\n\t\tbreak;\n\t}\n\n\t/* rtnl_lock is held.  */\n\tcase DRV_CTL_START_L2_CMD: {\n\t\tstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\n\t\tunsigned long sp_bits = 0;\n\n\t\t/* Configure the iSCSI classification object */\n\t\tbnx2x_init_mac_obj(bp, &bp->iscsi_l2_mac_obj,\n\t\t\t\t   cp->iscsi_l2_client_id,\n\t\t\t\t   cp->iscsi_l2_cid, BP_FUNC(bp),\n\t\t\t\t   bnx2x_sp(bp, mac_rdata),\n\t\t\t\t   bnx2x_sp_mapping(bp, mac_rdata),\n\t\t\t\t   BNX2X_FILTER_MAC_PENDING,\n\t\t\t\t   &bp->sp_state, BNX2X_OBJ_TYPE_RX,\n\t\t\t\t   &bp->macs_pool);\n\n\t\t/* Set iSCSI MAC address */\n\t\trc = bnx2x_set_iscsi_eth_mac_addr(bp);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tbarrier();\n\n\t\t/* Start accepting on iSCSI L2 ring */\n\n\t\tnetif_addr_lock_bh(dev);\n\t\tbnx2x_set_iscsi_eth_rx_mode(bp, true);\n\t\tnetif_addr_unlock_bh(dev);\n\n\t\t/* bits to wait on */\n\t\t__set_bit(BNX2X_FILTER_RX_MODE_PENDING, &sp_bits);\n\t\t__set_bit(BNX2X_FILTER_ISCSI_ETH_START_SCHED, &sp_bits);\n\n\t\tif (!bnx2x_wait_sp_comp(bp, sp_bits))\n\t\t\tBNX2X_ERR(\"rx_mode completion timed out!\\n\");\n\n\t\tbreak;\n\t}\n\n\t/* rtnl_lock is held.  */\n\tcase DRV_CTL_STOP_L2_CMD: {\n\t\tunsigned long sp_bits = 0;\n\n\t\t/* Stop accepting on iSCSI L2 ring */\n\t\tnetif_addr_lock_bh(dev);\n\t\tbnx2x_set_iscsi_eth_rx_mode(bp, false);\n\t\tnetif_addr_unlock_bh(dev);\n\n\t\t/* bits to wait on */\n\t\t__set_bit(BNX2X_FILTER_RX_MODE_PENDING, &sp_bits);\n\t\t__set_bit(BNX2X_FILTER_ISCSI_ETH_STOP_SCHED, &sp_bits);\n\n\t\tif (!bnx2x_wait_sp_comp(bp, sp_bits))\n\t\t\tBNX2X_ERR(\"rx_mode completion timed out!\\n\");\n\n\t\tbarrier();\n\n\t\t/* Unset iSCSI L2 MAC */\n\t\trc = bnx2x_del_all_macs(bp, &bp->iscsi_l2_mac_obj,\n\t\t\t\t\tBNX2X_ISCSI_ETH_MAC, true);\n\t\tbreak;\n\t}\n\tcase DRV_CTL_RET_L2_SPQ_CREDIT_CMD: {\n\t\tint count = ctl->data.credit.credit_count;\n\n\t\tsmp_mb__before_atomic();\n\t\tatomic_add(count, &bp->cq_spq_left);\n\t\tsmp_mb__after_atomic();\n\t\tbreak;\n\t}\n\tcase DRV_CTL_ULP_REGISTER_CMD: {\n\t\tint ulp_type = ctl->data.register_data.ulp_type;\n\n\t\tif (CHIP_IS_E3(bp)) {\n\t\t\tint idx = BP_FW_MB_IDX(bp);\n\t\t\tu32 cap = SHMEM2_RD(bp, drv_capabilities_flag[idx]);\n\t\t\tint path = BP_PATH(bp);\n\t\t\tint port = BP_PORT(bp);\n\t\t\tint i;\n\t\t\tu32 scratch_offset;\n\t\t\tu32 *host_addr;\n\n\t\t\t/* first write capability to shmem2 */\n\t\t\tif (ulp_type == CNIC_ULP_ISCSI)\n\t\t\t\tcap |= DRV_FLAGS_CAPABILITIES_LOADED_ISCSI;\n\t\t\telse if (ulp_type == CNIC_ULP_FCOE)\n\t\t\t\tcap |= DRV_FLAGS_CAPABILITIES_LOADED_FCOE;\n\t\t\tSHMEM2_WR(bp, drv_capabilities_flag[idx], cap);\n\n\t\t\tif ((ulp_type != CNIC_ULP_FCOE) ||\n\t\t\t    (!SHMEM2_HAS(bp, ncsi_oem_data_addr)) ||\n\t\t\t    (!(bp->flags &  BC_SUPPORTS_FCOE_FEATURES)))\n\t\t\t\tbreak;\n\n\t\t\t/* if reached here - should write fcoe capabilities */\n\t\t\tscratch_offset = SHMEM2_RD(bp, ncsi_oem_data_addr);\n\t\t\tif (!scratch_offset)\n\t\t\t\tbreak;\n\t\t\tscratch_offset += offsetof(struct glob_ncsi_oem_data,\n\t\t\t\t\t\t   fcoe_features[path][port]);\n\t\t\thost_addr = (u32 *) &(ctl->data.register_data.\n\t\t\t\t\t      fcoe_features);\n\t\t\tfor (i = 0; i < sizeof(struct fcoe_capabilities);\n\t\t\t     i += 4)\n\t\t\t\tREG_WR(bp, scratch_offset + i,\n\t\t\t\t       *(host_addr + i/4));\n\t\t}\n\t\tbnx2x_schedule_sp_rtnl(bp, BNX2X_SP_RTNL_GET_DRV_VERSION, 0);\n\t\tbreak;\n\t}\n\n\tcase DRV_CTL_ULP_UNREGISTER_CMD: {\n\t\tint ulp_type = ctl->data.ulp_type;\n\n\t\tif (CHIP_IS_E3(bp)) {\n\t\t\tint idx = BP_FW_MB_IDX(bp);\n\t\t\tu32 cap;\n\n\t\t\tcap = SHMEM2_RD(bp, drv_capabilities_flag[idx]);\n\t\t\tif (ulp_type == CNIC_ULP_ISCSI)\n\t\t\t\tcap &= ~DRV_FLAGS_CAPABILITIES_LOADED_ISCSI;\n\t\t\telse if (ulp_type == CNIC_ULP_FCOE)\n\t\t\t\tcap &= ~DRV_FLAGS_CAPABILITIES_LOADED_FCOE;\n\t\t\tSHMEM2_WR(bp, drv_capabilities_flag[idx], cap);\n\t\t}\n\t\tbnx2x_schedule_sp_rtnl(bp, BNX2X_SP_RTNL_GET_DRV_VERSION, 0);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tBNX2X_ERR(\"unknown command %x\\n\", ctl->cmd);\n\t\trc = -EINVAL;\n\t}\n\n\t/* For storage-only interfaces, change driver state */\n\tif (IS_MF_SD_STORAGE_PERSONALITY_ONLY(bp)) {\n\t\tswitch (ctl->drv_state) {\n\t\tcase DRV_NOP:\n\t\t\tbreak;\n\t\tcase DRV_ACTIVE:\n\t\t\tbnx2x_set_os_driver_state(bp,\n\t\t\t\t\t\t  OS_DRIVER_STATE_ACTIVE);\n\t\t\tbreak;\n\t\tcase DRV_INACTIVE:\n\t\t\tbnx2x_set_os_driver_state(bp,\n\t\t\t\t\t\t  OS_DRIVER_STATE_DISABLED);\n\t\t\tbreak;\n\t\tcase DRV_UNLOADED:\n\t\t\tbnx2x_set_os_driver_state(bp,\n\t\t\t\t\t\t  OS_DRIVER_STATE_NOT_LOADED);\n\t\t\tbreak;\n\t\tdefault:\n\t\tBNX2X_ERR(\"Unknown cnic driver state: %d\\n\", ctl->drv_state);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int bnx2x_get_fc_npiv(struct net_device *dev,\n\t\t\t     struct cnic_fc_npiv_tbl *cnic_tbl)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tstruct bdn_fc_npiv_tbl *tbl = NULL;\n\tu32 offset, entries;\n\tint rc = -EINVAL;\n\tint i;\n\n\tif (!SHMEM2_HAS(bp, fc_npiv_nvram_tbl_addr[0]))\n\t\tgoto out;\n\n\tDP(BNX2X_MSG_MCP, \"About to read the FC-NPIV table\\n\");\n\n\ttbl = kmalloc(sizeof(*tbl), GFP_KERNEL);\n\tif (!tbl) {\n\t\tBNX2X_ERR(\"Failed to allocate fc_npiv table\\n\");\n\t\tgoto out;\n\t}\n\n\toffset = SHMEM2_RD(bp, fc_npiv_nvram_tbl_addr[BP_PORT(bp)]);\n\tif (!offset) {\n\t\tDP(BNX2X_MSG_MCP, \"No FC-NPIV in NVRAM\\n\");\n\t\tgoto out;\n\t}\n\tDP(BNX2X_MSG_MCP, \"Offset of FC-NPIV in NVRAM: %08x\\n\", offset);\n\n\t/* Read the table contents from nvram */\n\tif (bnx2x_nvram_read(bp, offset, (u8 *)tbl, sizeof(*tbl))) {\n\t\tBNX2X_ERR(\"Failed to read FC-NPIV table\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Since bnx2x_nvram_read() returns data in be32, we need to convert\n\t * the number of entries back to cpu endianness.\n\t */\n\tentries = tbl->fc_npiv_cfg.num_of_npiv;\n\tentries = (__force u32)be32_to_cpu((__force __be32)entries);\n\ttbl->fc_npiv_cfg.num_of_npiv = entries;\n\n\tif (!tbl->fc_npiv_cfg.num_of_npiv) {\n\t\tDP(BNX2X_MSG_MCP,\n\t\t   \"No FC-NPIV table [valid, simply not present]\\n\");\n\t\tgoto out;\n\t} else if (tbl->fc_npiv_cfg.num_of_npiv > MAX_NUMBER_NPIV) {\n\t\tBNX2X_ERR(\"FC-NPIV table with bad length 0x%08x\\n\",\n\t\t\t  tbl->fc_npiv_cfg.num_of_npiv);\n\t\tgoto out;\n\t} else {\n\t\tDP(BNX2X_MSG_MCP, \"Read 0x%08x entries from NVRAM\\n\",\n\t\t   tbl->fc_npiv_cfg.num_of_npiv);\n\t}\n\n\t/* Copy the data into cnic-provided struct */\n\tcnic_tbl->count = tbl->fc_npiv_cfg.num_of_npiv;\n\tfor (i = 0; i < cnic_tbl->count; i++) {\n\t\tmemcpy(cnic_tbl->wwpn[i], tbl->settings[i].npiv_wwpn, 8);\n\t\tmemcpy(cnic_tbl->wwnn[i], tbl->settings[i].npiv_wwnn, 8);\n\t}\n\n\trc = 0;\nout:\n\tkfree(tbl);\n\treturn rc;\n}\n\nvoid bnx2x_setup_cnic_irq_info(struct bnx2x *bp)\n{\n\tstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\n\n\tif (bp->flags & USING_MSIX_FLAG) {\n\t\tcp->drv_state |= CNIC_DRV_STATE_USING_MSIX;\n\t\tcp->irq_arr[0].irq_flags |= CNIC_IRQ_FL_MSIX;\n\t\tcp->irq_arr[0].vector = bp->msix_table[1].vector;\n\t} else {\n\t\tcp->drv_state &= ~CNIC_DRV_STATE_USING_MSIX;\n\t\tcp->irq_arr[0].irq_flags &= ~CNIC_IRQ_FL_MSIX;\n\t}\n\tif (!CHIP_IS_E1x(bp))\n\t\tcp->irq_arr[0].status_blk = (void *)bp->cnic_sb.e2_sb;\n\telse\n\t\tcp->irq_arr[0].status_blk = (void *)bp->cnic_sb.e1x_sb;\n\n\tcp->irq_arr[0].status_blk_num =  bnx2x_cnic_fw_sb_id(bp);\n\tcp->irq_arr[0].status_blk_num2 = bnx2x_cnic_igu_sb_id(bp);\n\tcp->irq_arr[1].status_blk = bp->def_status_blk;\n\tcp->irq_arr[1].status_blk_num = DEF_SB_ID;\n\tcp->irq_arr[1].status_blk_num2 = DEF_SB_IGU_ID;\n\n\tcp->num_irq = 2;\n}\n\nvoid bnx2x_setup_cnic_info(struct bnx2x *bp)\n{\n\tstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\n\n\tcp->ctx_tbl_offset = FUNC_ILT_BASE(BP_FUNC(bp)) +\n\t\t\t     bnx2x_cid_ilt_lines(bp);\n\tcp->starting_cid = bnx2x_cid_ilt_lines(bp) * ILT_PAGE_CIDS;\n\tcp->fcoe_init_cid = BNX2X_FCOE_ETH_CID(bp);\n\tcp->iscsi_l2_cid = BNX2X_ISCSI_ETH_CID(bp);\n\n\tDP(NETIF_MSG_IFUP, \"BNX2X_1st_NON_L2_ETH_CID(bp) %x, cp->starting_cid %x, cp->fcoe_init_cid %x, cp->iscsi_l2_cid %x\\n\",\n\t   BNX2X_1st_NON_L2_ETH_CID(bp), cp->starting_cid, cp->fcoe_init_cid,\n\t   cp->iscsi_l2_cid);\n\n\tif (NO_ISCSI_OOO(bp))\n\t\tcp->drv_state |= CNIC_DRV_STATE_NO_ISCSI_OOO;\n}\n\nstatic int bnx2x_register_cnic(struct net_device *dev, struct cnic_ops *ops,\n\t\t\t       void *data)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\n\tint rc;\n\n\tDP(NETIF_MSG_IFUP, \"Register_cnic called\\n\");\n\n\tif (ops == NULL) {\n\t\tBNX2X_ERR(\"NULL ops received\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!CNIC_SUPPORT(bp)) {\n\t\tBNX2X_ERR(\"Can't register CNIC when not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!CNIC_LOADED(bp)) {\n\t\trc = bnx2x_load_cnic(bp);\n\t\tif (rc) {\n\t\t\tBNX2X_ERR(\"CNIC-related load failed\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tbp->cnic_enabled = true;\n\n\tbp->cnic_kwq = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!bp->cnic_kwq)\n\t\treturn -ENOMEM;\n\n\tbp->cnic_kwq_cons = bp->cnic_kwq;\n\tbp->cnic_kwq_prod = bp->cnic_kwq;\n\tbp->cnic_kwq_last = bp->cnic_kwq + MAX_SP_DESC_CNT;\n\n\tbp->cnic_spq_pending = 0;\n\tbp->cnic_kwq_pending = 0;\n\n\tbp->cnic_data = data;\n\n\tcp->num_irq = 0;\n\tcp->drv_state |= CNIC_DRV_STATE_REGD;\n\tcp->iro_arr = bp->iro_arr;\n\n\tbnx2x_setup_cnic_irq_info(bp);\n\n\trcu_assign_pointer(bp->cnic_ops, ops);\n\n\t/* Schedule driver to read CNIC driver versions */\n\tbnx2x_schedule_sp_rtnl(bp, BNX2X_SP_RTNL_GET_DRV_VERSION, 0);\n\n\treturn 0;\n}\n\nstatic int bnx2x_unregister_cnic(struct net_device *dev)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\n\n\tmutex_lock(&bp->cnic_mutex);\n\tcp->drv_state = 0;\n\tRCU_INIT_POINTER(bp->cnic_ops, NULL);\n\tmutex_unlock(&bp->cnic_mutex);\n\tsynchronize_rcu();\n\tbp->cnic_enabled = false;\n\tkfree(bp->cnic_kwq);\n\tbp->cnic_kwq = NULL;\n\n\treturn 0;\n}\n\nstatic struct cnic_eth_dev *bnx2x_cnic_probe(struct net_device *dev)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\n\n\t/* If both iSCSI and FCoE are disabled - return NULL in\n\t * order to indicate CNIC that it should not try to work\n\t * with this device.\n\t */\n\tif (NO_ISCSI(bp) && NO_FCOE(bp))\n\t\treturn NULL;\n\n\tcp->drv_owner = THIS_MODULE;\n\tcp->chip_id = CHIP_ID(bp);\n\tcp->pdev = bp->pdev;\n\tcp->io_base = bp->regview;\n\tcp->io_base2 = bp->doorbells;\n\tcp->max_kwqe_pending = 8;\n\tcp->ctx_blk_size = CDU_ILT_PAGE_SZ;\n\tcp->ctx_tbl_offset = FUNC_ILT_BASE(BP_FUNC(bp)) +\n\t\t\t     bnx2x_cid_ilt_lines(bp);\n\tcp->ctx_tbl_len = CNIC_ILT_LINES;\n\tcp->starting_cid = bnx2x_cid_ilt_lines(bp) * ILT_PAGE_CIDS;\n\tcp->drv_submit_kwqes_16 = bnx2x_cnic_sp_queue;\n\tcp->drv_ctl = bnx2x_drv_ctl;\n\tcp->drv_get_fc_npiv_tbl = bnx2x_get_fc_npiv;\n\tcp->drv_register_cnic = bnx2x_register_cnic;\n\tcp->drv_unregister_cnic = bnx2x_unregister_cnic;\n\tcp->fcoe_init_cid = BNX2X_FCOE_ETH_CID(bp);\n\tcp->iscsi_l2_client_id =\n\t\tbnx2x_cnic_eth_cl_id(bp, BNX2X_ISCSI_ETH_CL_ID_IDX);\n\tcp->iscsi_l2_cid = BNX2X_ISCSI_ETH_CID(bp);\n\n\tif (NO_ISCSI_OOO(bp))\n\t\tcp->drv_state |= CNIC_DRV_STATE_NO_ISCSI_OOO;\n\n\tif (NO_ISCSI(bp))\n\t\tcp->drv_state |= CNIC_DRV_STATE_NO_ISCSI;\n\n\tif (NO_FCOE(bp))\n\t\tcp->drv_state |= CNIC_DRV_STATE_NO_FCOE;\n\n\tBNX2X_DEV_INFO(\n\t\t\"page_size %d, tbl_offset %d, tbl_lines %d, starting cid %d\\n\",\n\t   cp->ctx_blk_size,\n\t   cp->ctx_tbl_offset,\n\t   cp->ctx_tbl_len,\n\t   cp->starting_cid);\n\treturn cp;\n}\n\nstatic u32 bnx2x_rx_ustorm_prods_offset(struct bnx2x_fastpath *fp)\n{\n\tstruct bnx2x *bp = fp->bp;\n\tu32 offset = BAR_USTRORM_INTMEM;\n\n\tif (IS_VF(bp))\n\t\treturn bnx2x_vf_ustorm_prods_offset(bp, fp);\n\telse if (!CHIP_IS_E1x(bp))\n\t\toffset += USTORM_RX_PRODS_E2_OFFSET(fp->cl_qzone_id);\n\telse\n\t\toffset += USTORM_RX_PRODS_E1X_OFFSET(BP_PORT(bp), fp->cl_id);\n\n\treturn offset;\n}\n\n/* called only on E1H or E2.\n * When pretending to be PF, the pretend value is the function number 0...7\n * When pretending to be VF, the pretend val is the PF-num:VF-valid:ABS-VFID\n * combination\n */\nint bnx2x_pretend_func(struct bnx2x *bp, u16 pretend_func_val)\n{\n\tu32 pretend_reg;\n\n\tif (CHIP_IS_E1H(bp) && pretend_func_val >= E1H_FUNC_MAX)\n\t\treturn -1;\n\n\t/* get my own pretend register */\n\tpretend_reg = bnx2x_get_pretend_reg(bp);\n\tREG_WR(bp, pretend_reg, pretend_func_val);\n\tREG_RD(bp, pretend_reg);\n\treturn 0;\n}\n\nstatic void bnx2x_ptp_task(struct work_struct *work)\n{\n\tstruct bnx2x *bp = container_of(work, struct bnx2x, ptp_task);\n\tint port = BP_PORT(bp);\n\tu32 val_seq;\n\tu64 timestamp, ns;\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tbool bail = true;\n\tint i;\n\n\t/* FW may take a while to complete timestamping; try a bit and if it's\n\t * still not complete, may indicate an error state - bail out then.\n\t */\n\tfor (i = 0; i < 10; i++) {\n\t\t/* Read Tx timestamp registers */\n\t\tval_seq = REG_RD(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_SEQID :\n\t\t\t\t NIG_REG_P0_TLLH_PTP_BUF_SEQID);\n\t\tif (val_seq & 0x10000) {\n\t\t\tbail = false;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(1 << i);\n\t}\n\n\tif (!bail) {\n\t\t/* There is a valid timestamp value */\n\t\ttimestamp = REG_RD(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_TS_MSB :\n\t\t\t\t   NIG_REG_P0_TLLH_PTP_BUF_TS_MSB);\n\t\ttimestamp <<= 32;\n\t\ttimestamp |= REG_RD(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_TS_LSB :\n\t\t\t\t    NIG_REG_P0_TLLH_PTP_BUF_TS_LSB);\n\t\t/* Reset timestamp register to allow new timestamp */\n\t\tREG_WR(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_SEQID :\n\t\t       NIG_REG_P0_TLLH_PTP_BUF_SEQID, 0x10000);\n\t\tns = timecounter_cyc2time(&bp->timecounter, timestamp);\n\n\t\tmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\n\t\tshhwtstamps.hwtstamp = ns_to_ktime(ns);\n\t\tskb_tstamp_tx(bp->ptp_tx_skb, &shhwtstamps);\n\n\t\tDP(BNX2X_MSG_PTP, \"Tx timestamp, timestamp cycles = %llu, ns = %llu\\n\",\n\t\t   timestamp, ns);\n\t} else {\n\t\tDP(BNX2X_MSG_PTP,\n\t\t   \"Tx timestamp is not recorded (register read=%u)\\n\",\n\t\t   val_seq);\n\t\tbp->eth_stats.ptp_skip_tx_ts++;\n\t}\n\n\tdev_kfree_skb_any(bp->ptp_tx_skb);\n\tbp->ptp_tx_skb = NULL;\n}\n\nvoid bnx2x_set_rx_ts(struct bnx2x *bp, struct sk_buff *skb)\n{\n\tint port = BP_PORT(bp);\n\tu64 timestamp, ns;\n\n\ttimestamp = REG_RD(bp, port ? NIG_REG_P1_LLH_PTP_HOST_BUF_TS_MSB :\n\t\t\t    NIG_REG_P0_LLH_PTP_HOST_BUF_TS_MSB);\n\ttimestamp <<= 32;\n\ttimestamp |= REG_RD(bp, port ? NIG_REG_P1_LLH_PTP_HOST_BUF_TS_LSB :\n\t\t\t    NIG_REG_P0_LLH_PTP_HOST_BUF_TS_LSB);\n\n\t/* Reset timestamp register to allow new timestamp */\n\tREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_HOST_BUF_SEQID :\n\t       NIG_REG_P0_LLH_PTP_HOST_BUF_SEQID, 0x10000);\n\n\tns = timecounter_cyc2time(&bp->timecounter, timestamp);\n\n\tskb_hwtstamps(skb)->hwtstamp = ns_to_ktime(ns);\n\n\tDP(BNX2X_MSG_PTP, \"Rx timestamp, timestamp cycles = %llu, ns = %llu\\n\",\n\t   timestamp, ns);\n}\n\n/* Read the PHC */\nstatic u64 bnx2x_cyclecounter_read(const struct cyclecounter *cc)\n{\n\tstruct bnx2x *bp = container_of(cc, struct bnx2x, cyclecounter);\n\tint port = BP_PORT(bp);\n\tu32 wb_data[2];\n\tu64 phc_cycles;\n\n\tREG_RD_DMAE(bp, port ? NIG_REG_TIMESYNC_GEN_REG + tsgen_synctime_t1 :\n\t\t    NIG_REG_TIMESYNC_GEN_REG + tsgen_synctime_t0, wb_data, 2);\n\tphc_cycles = wb_data[1];\n\tphc_cycles = (phc_cycles << 32) + wb_data[0];\n\n\tDP(BNX2X_MSG_PTP, \"PHC read cycles = %llu\\n\", phc_cycles);\n\n\treturn phc_cycles;\n}\n\nstatic void bnx2x_init_cyclecounter(struct bnx2x *bp)\n{\n\tmemset(&bp->cyclecounter, 0, sizeof(bp->cyclecounter));\n\tbp->cyclecounter.read = bnx2x_cyclecounter_read;\n\tbp->cyclecounter.mask = CYCLECOUNTER_MASK(64);\n\tbp->cyclecounter.shift = 0;\n\tbp->cyclecounter.mult = 1;\n}\n\nstatic int bnx2x_send_reset_timesync_ramrod(struct bnx2x *bp)\n{\n\tstruct bnx2x_func_state_params func_params = {NULL};\n\tstruct bnx2x_func_set_timesync_params *set_timesync_params =\n\t\t&func_params.params.set_timesync;\n\n\t/* Prepare parameters for function state transitions */\n\t__set_bit(RAMROD_COMP_WAIT, &func_params.ramrod_flags);\n\t__set_bit(RAMROD_RETRY, &func_params.ramrod_flags);\n\n\tfunc_params.f_obj = &bp->func_obj;\n\tfunc_params.cmd = BNX2X_F_CMD_SET_TIMESYNC;\n\n\t/* Function parameters */\n\tset_timesync_params->drift_adjust_cmd = TS_DRIFT_ADJUST_RESET;\n\tset_timesync_params->offset_cmd = TS_OFFSET_KEEP;\n\n\treturn bnx2x_func_state_change(bp, &func_params);\n}\n\nstatic int bnx2x_enable_ptp_packets(struct bnx2x *bp)\n{\n\tstruct bnx2x_queue_state_params q_params;\n\tint rc, i;\n\n\t/* send queue update ramrod to enable PTP packets */\n\tmemset(&q_params, 0, sizeof(q_params));\n\t__set_bit(RAMROD_COMP_WAIT, &q_params.ramrod_flags);\n\tq_params.cmd = BNX2X_Q_CMD_UPDATE;\n\t__set_bit(BNX2X_Q_UPDATE_PTP_PKTS_CHNG,\n\t\t  &q_params.params.update.update_flags);\n\t__set_bit(BNX2X_Q_UPDATE_PTP_PKTS,\n\t\t  &q_params.params.update.update_flags);\n\n\t/* send the ramrod on all the queues of the PF */\n\tfor_each_eth_queue(bp, i) {\n\t\tstruct bnx2x_fastpath *fp = &bp->fp[i];\n\n\t\t/* Set the appropriate Queue object */\n\t\tq_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\n\n\t\t/* Update the Queue state */\n\t\trc = bnx2x_queue_state_change(bp, &q_params);\n\t\tif (rc) {\n\t\t\tBNX2X_ERR(\"Failed to enable PTP packets\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define BNX2X_P2P_DETECT_PARAM_MASK 0x5F5\n#define BNX2X_P2P_DETECT_RULE_MASK 0x3DBB\n#define BNX2X_PTP_TX_ON_PARAM_MASK (BNX2X_P2P_DETECT_PARAM_MASK & 0x6AA)\n#define BNX2X_PTP_TX_ON_RULE_MASK (BNX2X_P2P_DETECT_RULE_MASK & 0x3EEE)\n#define BNX2X_PTP_V1_L4_PARAM_MASK (BNX2X_P2P_DETECT_PARAM_MASK & 0x7EE)\n#define BNX2X_PTP_V1_L4_RULE_MASK (BNX2X_P2P_DETECT_RULE_MASK & 0x3FFE)\n#define BNX2X_PTP_V2_L4_PARAM_MASK (BNX2X_P2P_DETECT_PARAM_MASK & 0x7EA)\n#define BNX2X_PTP_V2_L4_RULE_MASK (BNX2X_P2P_DETECT_RULE_MASK & 0x3FEE)\n#define BNX2X_PTP_V2_L2_PARAM_MASK (BNX2X_P2P_DETECT_PARAM_MASK & 0x6BF)\n#define BNX2X_PTP_V2_L2_RULE_MASK (BNX2X_P2P_DETECT_RULE_MASK & 0x3EFF)\n#define BNX2X_PTP_V2_PARAM_MASK (BNX2X_P2P_DETECT_PARAM_MASK & 0x6AA)\n#define BNX2X_PTP_V2_RULE_MASK (BNX2X_P2P_DETECT_RULE_MASK & 0x3EEE)\n\nint bnx2x_configure_ptp_filters(struct bnx2x *bp)\n{\n\tint port = BP_PORT(bp);\n\tu32 param, rule;\n\tint rc;\n\n\tif (!bp->hwtstamp_ioctl_called)\n\t\treturn 0;\n\n\tparam = port ? NIG_REG_P1_TLLH_PTP_PARAM_MASK :\n\t\tNIG_REG_P0_TLLH_PTP_PARAM_MASK;\n\trule = port ? NIG_REG_P1_TLLH_PTP_RULE_MASK :\n\t\tNIG_REG_P0_TLLH_PTP_RULE_MASK;\n\tswitch (bp->tx_type) {\n\tcase HWTSTAMP_TX_ON:\n\t\tbp->flags |= TX_TIMESTAMPING_EN;\n\t\tREG_WR(bp, param, BNX2X_PTP_TX_ON_PARAM_MASK);\n\t\tREG_WR(bp, rule, BNX2X_PTP_TX_ON_RULE_MASK);\n\t\tbreak;\n\tcase HWTSTAMP_TX_ONESTEP_SYNC:\n\tcase HWTSTAMP_TX_ONESTEP_P2P:\n\t\tBNX2X_ERR(\"One-step timestamping is not supported\\n\");\n\t\treturn -ERANGE;\n\t}\n\n\tparam = port ? NIG_REG_P1_LLH_PTP_PARAM_MASK :\n\t\tNIG_REG_P0_LLH_PTP_PARAM_MASK;\n\trule = port ? NIG_REG_P1_LLH_PTP_RULE_MASK :\n\t\tNIG_REG_P0_LLH_PTP_RULE_MASK;\n\tswitch (bp->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_ALL:\n\tcase HWTSTAMP_FILTER_SOME:\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\t\tbp->rx_filter = HWTSTAMP_FILTER_NONE;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\t\tbp->rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\n\t\t/* Initialize PTP detection for UDP/IPv4 events */\n\t\tREG_WR(bp, param, BNX2X_PTP_V1_L4_PARAM_MASK);\n\t\tREG_WR(bp, rule, BNX2X_PTP_V1_L4_RULE_MASK);\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\tbp->rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_EVENT;\n\t\t/* Initialize PTP detection for UDP/IPv4 or UDP/IPv6 events */\n\t\tREG_WR(bp, param, BNX2X_PTP_V2_L4_PARAM_MASK);\n\t\tREG_WR(bp, rule, BNX2X_PTP_V2_L4_RULE_MASK);\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\t\tbp->rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_EVENT;\n\t\t/* Initialize PTP detection L2 events */\n\t\tREG_WR(bp, param, BNX2X_PTP_V2_L2_PARAM_MASK);\n\t\tREG_WR(bp, rule, BNX2X_PTP_V2_L2_RULE_MASK);\n\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\tbp->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\t/* Initialize PTP detection L2, UDP/IPv4 or UDP/IPv6 events */\n\t\tREG_WR(bp, param, BNX2X_PTP_V2_PARAM_MASK);\n\t\tREG_WR(bp, rule, BNX2X_PTP_V2_RULE_MASK);\n\t\tbreak;\n\t}\n\n\t/* Indicate to FW that this PF expects recorded PTP packets */\n\trc = bnx2x_enable_ptp_packets(bp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* Enable sending PTP packets to host */\n\tREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_TO_HOST :\n\t       NIG_REG_P0_LLH_PTP_TO_HOST, 0x1);\n\n\treturn 0;\n}\n\nstatic int bnx2x_hwtstamp_ioctl(struct bnx2x *bp, struct ifreq *ifr)\n{\n\tstruct hwtstamp_config config;\n\tint rc;\n\n\tDP(BNX2X_MSG_PTP, \"HWTSTAMP IOCTL called\\n\");\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\tDP(BNX2X_MSG_PTP, \"Requested tx_type: %d, requested rx_filters = %d\\n\",\n\t   config.tx_type, config.rx_filter);\n\n\tif (config.flags) {\n\t\tBNX2X_ERR(\"config.flags is reserved for future use\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbp->hwtstamp_ioctl_called = true;\n\tbp->tx_type = config.tx_type;\n\tbp->rx_filter = config.rx_filter;\n\n\trc = bnx2x_configure_ptp_filters(bp);\n\tif (rc)\n\t\treturn rc;\n\n\tconfig.rx_filter = bp->rx_filter;\n\n\treturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\n\t\t-EFAULT : 0;\n}\n\n/* Configures HW for PTP */\nstatic int bnx2x_configure_ptp(struct bnx2x *bp)\n{\n\tint rc, port = BP_PORT(bp);\n\tu32 wb_data[2];\n\n\t/* Reset PTP event detection rules - will be configured in the IOCTL */\n\tREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_PARAM_MASK :\n\t       NIG_REG_P0_LLH_PTP_PARAM_MASK, 0x7FF);\n\tREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_RULE_MASK :\n\t       NIG_REG_P0_LLH_PTP_RULE_MASK, 0x3FFF);\n\tREG_WR(bp, port ? NIG_REG_P1_TLLH_PTP_PARAM_MASK :\n\t       NIG_REG_P0_TLLH_PTP_PARAM_MASK, 0x7FF);\n\tREG_WR(bp, port ? NIG_REG_P1_TLLH_PTP_RULE_MASK :\n\t       NIG_REG_P0_TLLH_PTP_RULE_MASK, 0x3FFF);\n\n\t/* Disable PTP packets to host - will be configured in the IOCTL*/\n\tREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_TO_HOST :\n\t       NIG_REG_P0_LLH_PTP_TO_HOST, 0x0);\n\n\t/* Enable the PTP feature */\n\tREG_WR(bp, port ? NIG_REG_P1_PTP_EN :\n\t       NIG_REG_P0_PTP_EN, 0x3F);\n\n\t/* Enable the free-running counter */\n\twb_data[0] = 0;\n\twb_data[1] = 0;\n\tREG_WR_DMAE(bp, NIG_REG_TIMESYNC_GEN_REG + tsgen_ctrl, wb_data, 2);\n\n\t/* Reset drift register (offset register is not reset) */\n\trc = bnx2x_send_reset_timesync_ramrod(bp);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Failed to reset PHC drift register\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t/* Reset possibly old timestamps */\n\tREG_WR(bp, port ? NIG_REG_P1_LLH_PTP_HOST_BUF_SEQID :\n\t       NIG_REG_P0_LLH_PTP_HOST_BUF_SEQID, 0x10000);\n\tREG_WR(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_SEQID :\n\t       NIG_REG_P0_TLLH_PTP_BUF_SEQID, 0x10000);\n\n\treturn 0;\n}\n\n/* Called during load, to initialize PTP-related stuff */\nvoid bnx2x_init_ptp(struct bnx2x *bp)\n{\n\tint rc;\n\n\t/* Configure PTP in HW */\n\trc = bnx2x_configure_ptp(bp);\n\tif (rc) {\n\t\tBNX2X_ERR(\"Stopping PTP initialization\\n\");\n\t\treturn;\n\t}\n\n\t/* Init work queue for Tx timestamping */\n\tINIT_WORK(&bp->ptp_task, bnx2x_ptp_task);\n\n\t/* Init cyclecounter and timecounter. This is done only in the first\n\t * load. If done in every load, PTP application will fail when doing\n\t * unload / load (e.g. MTU change) while it is running.\n\t */\n\tif (!bp->timecounter_init_done) {\n\t\tbnx2x_init_cyclecounter(bp);\n\t\ttimecounter_init(&bp->timecounter, &bp->cyclecounter,\n\t\t\t\t ktime_to_ns(ktime_get_real()));\n\t\tbp->timecounter_init_done = true;\n\t}\n\n\tDP(BNX2X_MSG_PTP, \"PTP initialization ended successfully\\n\");\n}\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 3212}, "message": "parse error: turning off implications after 60 seconds"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c", "reportHash": "2892b8f7a50fca361a401c0bddde91ed", "checkerName": "smatch.smatch_implied", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 6457}, "message": "warn: potential spectre issue 'bp->fp' [r]"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c", "reportHash": "21dbe2291a4a0947b246305e635aba49", "checkerName": "smatch.check_spectre", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
