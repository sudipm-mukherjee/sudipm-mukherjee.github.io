<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c", "content": "// SPDX-License-Identifier: ISC\n/*\n * Copyright (c) 2010 Broadcom Corporation\n */\n\n/* Toplevel file. Relies on dhd_linux.c to send commands to the dongle. */\n\n#include <linux/kernel.h>\n#include <linux/etherdevice.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <net/cfg80211.h>\n#include <net/netlink.h>\n#include <uapi/linux/if_arp.h>\n\n#include <brcmu_utils.h>\n#include <defs.h>\n#include <brcmu_wifi.h>\n#include \"core.h\"\n#include \"debug.h\"\n#include \"tracepoint.h\"\n#include \"fwil_types.h\"\n#include \"p2p.h\"\n#include \"btcoex.h\"\n#include \"pno.h\"\n#include \"fwsignal.h\"\n#include \"cfg80211.h\"\n#include \"feature.h\"\n#include \"fwil.h\"\n#include \"proto.h\"\n#include \"vendor.h\"\n#include \"bus.h\"\n#include \"common.h\"\n\n#define BRCMF_SCAN_IE_LEN_MAX\t\t2048\n\n#define WPA_OUI\t\t\t\t\"\\x00\\x50\\xF2\"\t/* WPA OUI */\n#define WPA_OUI_TYPE\t\t\t1\n#define RSN_OUI\t\t\t\t\"\\x00\\x0F\\xAC\"\t/* RSN OUI */\n#define\tWME_OUI_TYPE\t\t\t2\n#define WPS_OUI_TYPE\t\t\t4\n\n#define VS_IE_FIXED_HDR_LEN\t\t6\n#define WPA_IE_VERSION_LEN\t\t2\n#define WPA_IE_MIN_OUI_LEN\t\t4\n#define WPA_IE_SUITE_COUNT_LEN\t\t2\n\n#define WPA_CIPHER_NONE\t\t\t0\t/* None */\n#define WPA_CIPHER_WEP_40\t\t1\t/* WEP (40-bit) */\n#define WPA_CIPHER_TKIP\t\t\t2\t/* TKIP: default for WPA */\n#define WPA_CIPHER_AES_CCM\t\t4\t/* AES (CCM) */\n#define WPA_CIPHER_WEP_104\t\t5\t/* WEP (104-bit) */\n\n#define RSN_AKM_NONE\t\t\t0\t/* None (IBSS) */\n#define RSN_AKM_UNSPECIFIED\t\t1\t/* Over 802.1x */\n#define RSN_AKM_PSK\t\t\t2\t/* Pre-shared Key */\n#define RSN_AKM_SHA256_1X\t\t5\t/* SHA256, 802.1X */\n#define RSN_AKM_SHA256_PSK\t\t6\t/* SHA256, Pre-shared Key */\n#define RSN_AKM_SAE\t\t\t8\t/* SAE */\n#define RSN_CAP_LEN\t\t\t2\t/* Length of RSN capabilities */\n#define RSN_CAP_PTK_REPLAY_CNTR_MASK\t(BIT(2) | BIT(3))\n#define RSN_CAP_MFPR_MASK\t\tBIT(6)\n#define RSN_CAP_MFPC_MASK\t\tBIT(7)\n#define RSN_PMKID_COUNT_LEN\t\t2\n\n#define VNDR_IE_CMD_LEN\t\t\t4\t/* length of the set command\n\t\t\t\t\t\t * string :\"add\", \"del\" (+ NUL)\n\t\t\t\t\t\t */\n#define VNDR_IE_COUNT_OFFSET\t\t4\n#define VNDR_IE_PKTFLAG_OFFSET\t\t8\n#define VNDR_IE_VSIE_OFFSET\t\t12\n#define VNDR_IE_HDR_SIZE\t\t12\n#define VNDR_IE_PARSE_LIMIT\t\t5\n\n#define\tDOT11_MGMT_HDR_LEN\t\t24\t/* d11 management header len */\n#define\tDOT11_BCN_PRB_FIXED_LEN\t\t12\t/* beacon/probe fixed length */\n\n#define BRCMF_SCAN_JOIN_ACTIVE_DWELL_TIME_MS\t320\n#define BRCMF_SCAN_JOIN_PASSIVE_DWELL_TIME_MS\t400\n#define BRCMF_SCAN_JOIN_PROBE_INTERVAL_MS\t20\n\n#define BRCMF_SCAN_CHANNEL_TIME\t\t40\n#define BRCMF_SCAN_UNASSOC_TIME\t\t40\n#define BRCMF_SCAN_PASSIVE_TIME\t\t120\n\n#define BRCMF_ND_INFO_TIMEOUT\t\tmsecs_to_jiffies(2000)\n\n#define BRCMF_PS_MAX_TIMEOUT_MS\t\t2000\n\n#define BRCMF_ASSOC_PARAMS_FIXED_SIZE \\\n\t(sizeof(struct brcmf_assoc_params_le) - sizeof(u16))\n\nstatic bool check_vif_up(struct brcmf_cfg80211_vif *vif)\n{\n\tif (!test_bit(BRCMF_VIF_STATUS_READY, &vif->sme_state)) {\n\t\tbrcmf_dbg(INFO, \"device is not ready : status (%lu)\\n\",\n\t\t\t  vif->sme_state);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n#define RATE_TO_BASE100KBPS(rate)   (((rate) * 10) / 2)\n#define RATETAB_ENT(_rateid, _flags) \\\n\t{                                                               \\\n\t\t.bitrate        = RATE_TO_BASE100KBPS(_rateid),     \\\n\t\t.hw_value       = (_rateid),                            \\\n\t\t.flags          = (_flags),                             \\\n\t}\n\nstatic struct ieee80211_rate __wl_rates[] = {\n\tRATETAB_ENT(BRCM_RATE_1M, 0),\n\tRATETAB_ENT(BRCM_RATE_2M, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(BRCM_RATE_5M5, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(BRCM_RATE_11M, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(BRCM_RATE_6M, 0),\n\tRATETAB_ENT(BRCM_RATE_9M, 0),\n\tRATETAB_ENT(BRCM_RATE_12M, 0),\n\tRATETAB_ENT(BRCM_RATE_18M, 0),\n\tRATETAB_ENT(BRCM_RATE_24M, 0),\n\tRATETAB_ENT(BRCM_RATE_36M, 0),\n\tRATETAB_ENT(BRCM_RATE_48M, 0),\n\tRATETAB_ENT(BRCM_RATE_54M, 0),\n};\n\n#define wl_g_rates\t\t(__wl_rates + 0)\n#define wl_g_rates_size\t\tARRAY_SIZE(__wl_rates)\n#define wl_a_rates\t\t(__wl_rates + 4)\n#define wl_a_rates_size\t\t(wl_g_rates_size - 4)\n\n#define CHAN2G(_channel, _freq) {\t\t\t\t\\\n\t.band\t\t\t= NL80211_BAND_2GHZ,\t\t\\\n\t.center_freq\t\t= (_freq),\t\t\t\\\n\t.hw_value\t\t= (_channel),\t\t\t\\\n\t.max_antenna_gain\t= 0,\t\t\t\t\\\n\t.max_power\t\t= 30,\t\t\t\t\\\n}\n\n#define CHAN5G(_channel) {\t\t\t\t\t\\\n\t.band\t\t\t= NL80211_BAND_5GHZ,\t\t\\\n\t.center_freq\t\t= 5000 + (5 * (_channel)),\t\\\n\t.hw_value\t\t= (_channel),\t\t\t\\\n\t.max_antenna_gain\t= 0,\t\t\t\t\\\n\t.max_power\t\t= 30,\t\t\t\t\\\n}\n\nstatic struct ieee80211_channel __wl_2ghz_channels[] = {\n\tCHAN2G(1, 2412), CHAN2G(2, 2417), CHAN2G(3, 2422), CHAN2G(4, 2427),\n\tCHAN2G(5, 2432), CHAN2G(6, 2437), CHAN2G(7, 2442), CHAN2G(8, 2447),\n\tCHAN2G(9, 2452), CHAN2G(10, 2457), CHAN2G(11, 2462), CHAN2G(12, 2467),\n\tCHAN2G(13, 2472), CHAN2G(14, 2484)\n};\n\nstatic struct ieee80211_channel __wl_5ghz_channels[] = {\n\tCHAN5G(34), CHAN5G(36), CHAN5G(38), CHAN5G(40), CHAN5G(42),\n\tCHAN5G(44), CHAN5G(46), CHAN5G(48), CHAN5G(52), CHAN5G(56),\n\tCHAN5G(60), CHAN5G(64), CHAN5G(100), CHAN5G(104), CHAN5G(108),\n\tCHAN5G(112), CHAN5G(116), CHAN5G(120), CHAN5G(124), CHAN5G(128),\n\tCHAN5G(132), CHAN5G(136), CHAN5G(140), CHAN5G(144), CHAN5G(149),\n\tCHAN5G(153), CHAN5G(157), CHAN5G(161), CHAN5G(165)\n};\n\n/* Band templates duplicated per wiphy. The channel info\n * above is added to the band during setup.\n */\nstatic const struct ieee80211_supported_band __wl_band_2ghz = {\n\t.band = NL80211_BAND_2GHZ,\n\t.bitrates = wl_g_rates,\n\t.n_bitrates = wl_g_rates_size,\n};\n\nstatic const struct ieee80211_supported_band __wl_band_5ghz = {\n\t.band = NL80211_BAND_5GHZ,\n\t.bitrates = wl_a_rates,\n\t.n_bitrates = wl_a_rates_size,\n};\n\n/* This is to override regulatory domains defined in cfg80211 module (reg.c)\n * By default world regulatory domain defined in reg.c puts the flags\n * NL80211_RRF_NO_IR for 5GHz channels (for * 36..48 and 149..165).\n * With respect to these flags, wpa_supplicant doesn't * start p2p\n * operations on 5GHz channels. All the changes in world regulatory\n * domain are to be done here.\n */\nstatic const struct ieee80211_regdomain brcmf_regdom = {\n\t.n_reg_rules = 4,\n\t.alpha2 =  \"99\",\n\t.reg_rules = {\n\t\t/* IEEE 802.11b/g, channels 1..11 */\n\t\tREG_RULE(2412-10, 2472+10, 40, 6, 20, 0),\n\t\t/* If any */\n\t\t/* IEEE 802.11 channel 14 - Only JP enables\n\t\t * this and for 802.11b only\n\t\t */\n\t\tREG_RULE(2484-10, 2484+10, 20, 6, 20, 0),\n\t\t/* IEEE 802.11a, channel 36..64 */\n\t\tREG_RULE(5150-10, 5350+10, 160, 6, 20, 0),\n\t\t/* IEEE 802.11a, channel 100..165 */\n\t\tREG_RULE(5470-10, 5850+10, 160, 6, 20, 0), }\n};\n\n/* Note: brcmf_cipher_suites is an array of int defining which cipher suites\n * are supported. A pointer to this array and the number of entries is passed\n * on to upper layers. AES_CMAC defines whether or not the driver supports MFP.\n * So the cipher suite AES_CMAC has to be the last one in the array, and when\n * device does not support MFP then the number of suites will be decreased by 1\n */\nstatic const u32 brcmf_cipher_suites[] = {\n\tWLAN_CIPHER_SUITE_WEP40,\n\tWLAN_CIPHER_SUITE_WEP104,\n\tWLAN_CIPHER_SUITE_TKIP,\n\tWLAN_CIPHER_SUITE_CCMP,\n\t/* Keep as last entry: */\n\tWLAN_CIPHER_SUITE_AES_CMAC\n};\n\n/* Vendor specific ie. id = 221, oui and type defines exact ie */\nstruct brcmf_vs_tlv {\n\tu8 id;\n\tu8 len;\n\tu8 oui[3];\n\tu8 oui_type;\n};\n\nstruct parsed_vndr_ie_info {\n\tu8 *ie_ptr;\n\tu32 ie_len;\t/* total length including id & length field */\n\tstruct brcmf_vs_tlv vndrie;\n};\n\nstruct parsed_vndr_ies {\n\tu32 count;\n\tstruct parsed_vndr_ie_info ie_info[VNDR_IE_PARSE_LIMIT];\n};\n\nstatic u8 nl80211_band_to_fwil(enum nl80211_band band)\n{\n\tswitch (band) {\n\tcase NL80211_BAND_2GHZ:\n\t\treturn WLC_BAND_2G;\n\tcase NL80211_BAND_5GHZ:\n\t\treturn WLC_BAND_5G;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic u16 chandef_to_chanspec(struct brcmu_d11inf *d11inf,\n\t\t\t       struct cfg80211_chan_def *ch)\n{\n\tstruct brcmu_chan ch_inf;\n\ts32 primary_offset;\n\n\tbrcmf_dbg(TRACE, \"chandef: control %d center %d width %d\\n\",\n\t\t  ch->chan->center_freq, ch->center_freq1, ch->width);\n\tch_inf.chnum = ieee80211_frequency_to_channel(ch->center_freq1);\n\tprimary_offset = ch->chan->center_freq - ch->center_freq1;\n\tswitch (ch->width) {\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tch_inf.bw = BRCMU_CHAN_BW_20;\n\t\tWARN_ON(primary_offset != 0);\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tch_inf.bw = BRCMU_CHAN_BW_40;\n\t\tif (primary_offset > 0)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_U;\n\t\telse\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_L;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\tch_inf.bw = BRCMU_CHAN_BW_80;\n\t\tif (primary_offset == -30)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_LL;\n\t\telse if (primary_offset == -10)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_LU;\n\t\telse if (primary_offset == 10)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_UL;\n\t\telse\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_UU;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tch_inf.bw = BRCMU_CHAN_BW_160;\n\t\tif (primary_offset == -70)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_LLL;\n\t\telse if (primary_offset == -50)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_LLU;\n\t\telse if (primary_offset == -30)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_LUL;\n\t\telse if (primary_offset == -10)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_LUU;\n\t\telse if (primary_offset == 10)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_ULL;\n\t\telse if (primary_offset == 30)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_ULU;\n\t\telse if (primary_offset == 50)\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_UUL;\n\t\telse\n\t\t\tch_inf.sb = BRCMU_CHAN_SB_UUU;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\tswitch (ch->chan->band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tch_inf.band = BRCMU_CHAN_BAND_2G;\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tch_inf.band = BRCMU_CHAN_BAND_5G;\n\t\tbreak;\n\tcase NL80211_BAND_60GHZ:\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\td11inf->encchspec(&ch_inf);\n\n\tbrcmf_dbg(TRACE, \"chanspec: 0x%x\\n\", ch_inf.chspec);\n\treturn ch_inf.chspec;\n}\n\nu16 channel_to_chanspec(struct brcmu_d11inf *d11inf,\n\t\t\tstruct ieee80211_channel *ch)\n{\n\tstruct brcmu_chan ch_inf;\n\n\tch_inf.chnum = ieee80211_frequency_to_channel(ch->center_freq);\n\tch_inf.bw = BRCMU_CHAN_BW_20;\n\td11inf->encchspec(&ch_inf);\n\n\treturn ch_inf.chspec;\n}\n\n/* Traverse a string of 1-byte tag/1-byte length/variable-length value\n * triples, returning a pointer to the substring whose first element\n * matches tag\n */\nstatic const struct brcmf_tlv *\nbrcmf_parse_tlvs(const void *buf, int buflen, uint key)\n{\n\tconst struct brcmf_tlv *elt = buf;\n\tint totlen = buflen;\n\n\t/* find tagged parameter */\n\twhile (totlen >= TLV_HDR_LEN) {\n\t\tint len = elt->len;\n\n\t\t/* validate remaining totlen */\n\t\tif ((elt->id == key) && (totlen >= (len + TLV_HDR_LEN)))\n\t\t\treturn elt;\n\n\t\telt = (struct brcmf_tlv *)((u8 *)elt + (len + TLV_HDR_LEN));\n\t\ttotlen -= (len + TLV_HDR_LEN);\n\t}\n\n\treturn NULL;\n}\n\n/* Is any of the tlvs the expected entry? If\n * not update the tlvs buffer pointer/length.\n */\nstatic bool\nbrcmf_tlv_has_ie(const u8 *ie, const u8 **tlvs, u32 *tlvs_len,\n\t\t const u8 *oui, u32 oui_len, u8 type)\n{\n\t/* If the contents match the OUI and the type */\n\tif (ie[TLV_LEN_OFF] >= oui_len + 1 &&\n\t    !memcmp(&ie[TLV_BODY_OFF], oui, oui_len) &&\n\t    type == ie[TLV_BODY_OFF + oui_len]) {\n\t\treturn true;\n\t}\n\n\tif (tlvs == NULL)\n\t\treturn false;\n\t/* point to the next ie */\n\tie += ie[TLV_LEN_OFF] + TLV_HDR_LEN;\n\t/* calculate the length of the rest of the buffer */\n\t*tlvs_len -= (int)(ie - *tlvs);\n\t/* update the pointer to the start of the buffer */\n\t*tlvs = ie;\n\n\treturn false;\n}\n\nstatic struct brcmf_vs_tlv *\nbrcmf_find_wpaie(const u8 *parse, u32 len)\n{\n\tconst struct brcmf_tlv *ie;\n\n\twhile ((ie = brcmf_parse_tlvs(parse, len, WLAN_EID_VENDOR_SPECIFIC))) {\n\t\tif (brcmf_tlv_has_ie((const u8 *)ie, &parse, &len,\n\t\t\t\t     WPA_OUI, TLV_OUI_LEN, WPA_OUI_TYPE))\n\t\t\treturn (struct brcmf_vs_tlv *)ie;\n\t}\n\treturn NULL;\n}\n\nstatic struct brcmf_vs_tlv *\nbrcmf_find_wpsie(const u8 *parse, u32 len)\n{\n\tconst struct brcmf_tlv *ie;\n\n\twhile ((ie = brcmf_parse_tlvs(parse, len, WLAN_EID_VENDOR_SPECIFIC))) {\n\t\tif (brcmf_tlv_has_ie((u8 *)ie, &parse, &len,\n\t\t\t\t     WPA_OUI, TLV_OUI_LEN, WPS_OUI_TYPE))\n\t\t\treturn (struct brcmf_vs_tlv *)ie;\n\t}\n\treturn NULL;\n}\n\nstatic int brcmf_vif_change_validate(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t     struct brcmf_cfg80211_vif *vif,\n\t\t\t\t     enum nl80211_iftype new_type)\n{\n\tstruct brcmf_cfg80211_vif *pos;\n\tbool check_combos = false;\n\tint ret = 0;\n\tstruct iface_combination_params params = {\n\t\t.num_different_channels = 1,\n\t};\n\n\tlist_for_each_entry(pos, &cfg->vif_list, list)\n\t\tif (pos == vif) {\n\t\t\tparams.iftype_num[new_type]++;\n\t\t} else {\n\t\t\t/* concurrent interfaces so need check combinations */\n\t\t\tcheck_combos = true;\n\t\t\tparams.iftype_num[pos->wdev.iftype]++;\n\t\t}\n\n\tif (check_combos)\n\t\tret = cfg80211_check_combinations(cfg->wiphy, &params);\n\n\treturn ret;\n}\n\nstatic int brcmf_vif_add_validate(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t  enum nl80211_iftype new_type)\n{\n\tstruct brcmf_cfg80211_vif *pos;\n\tstruct iface_combination_params params = {\n\t\t.num_different_channels = 1,\n\t};\n\n\tlist_for_each_entry(pos, &cfg->vif_list, list)\n\t\tparams.iftype_num[pos->wdev.iftype]++;\n\n\tparams.iftype_num[new_type]++;\n\treturn cfg80211_check_combinations(cfg->wiphy, &params);\n}\n\nstatic void convert_key_from_CPU(struct brcmf_wsec_key *key,\n\t\t\t\t struct brcmf_wsec_key_le *key_le)\n{\n\tkey_le->index = cpu_to_le32(key->index);\n\tkey_le->len = cpu_to_le32(key->len);\n\tkey_le->algo = cpu_to_le32(key->algo);\n\tkey_le->flags = cpu_to_le32(key->flags);\n\tkey_le->rxiv.hi = cpu_to_le32(key->rxiv.hi);\n\tkey_le->rxiv.lo = cpu_to_le16(key->rxiv.lo);\n\tkey_le->iv_initialized = cpu_to_le32(key->iv_initialized);\n\tmemcpy(key_le->data, key->data, sizeof(key->data));\n\tmemcpy(key_le->ea, key->ea, sizeof(key->ea));\n}\n\nstatic int\nsend_key_to_dongle(struct brcmf_if *ifp, struct brcmf_wsec_key *key)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tint err;\n\tstruct brcmf_wsec_key_le key_le;\n\n\tconvert_key_from_CPU(key, &key_le);\n\n\tbrcmf_netdev_wait_pend8021x(ifp);\n\n\terr = brcmf_fil_bsscfg_data_set(ifp, \"wsec_key\", &key_le,\n\t\t\t\t\tsizeof(key_le));\n\n\tif (err)\n\t\tbphy_err(drvr, \"wsec_key error (%d)\\n\", err);\n\treturn err;\n}\n\nstatic void\nbrcmf_cfg80211_update_proto_addr_mode(struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct brcmf_if *ifp;\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\tifp = vif->ifp;\n\n\tif ((wdev->iftype == NL80211_IFTYPE_ADHOC) ||\n\t    (wdev->iftype == NL80211_IFTYPE_AP) ||\n\t    (wdev->iftype == NL80211_IFTYPE_P2P_GO))\n\t\tbrcmf_proto_configure_addr_mode(ifp->drvr, ifp->ifidx,\n\t\t\t\t\t\tADDR_DIRECT);\n\telse\n\t\tbrcmf_proto_configure_addr_mode(ifp->drvr, ifp->ifidx,\n\t\t\t\t\t\tADDR_INDIRECT);\n}\n\nstatic int brcmf_get_first_free_bsscfgidx(struct brcmf_pub *drvr)\n{\n\tint bsscfgidx;\n\n\tfor (bsscfgidx = 0; bsscfgidx < BRCMF_MAX_IFS; bsscfgidx++) {\n\t\t/* bsscfgidx 1 is reserved for legacy P2P */\n\t\tif (bsscfgidx == 1)\n\t\t\tcontinue;\n\t\tif (!drvr->iflist[bsscfgidx])\n\t\t\treturn bsscfgidx;\n\t}\n\n\treturn -ENOMEM;\n}\n\nstatic int brcmf_cfg80211_request_ap_if(struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_mbss_ssid_le mbss_ssid_le;\n\tint bsscfgidx;\n\tint err;\n\n\tmemset(&mbss_ssid_le, 0, sizeof(mbss_ssid_le));\n\tbsscfgidx = brcmf_get_first_free_bsscfgidx(ifp->drvr);\n\tif (bsscfgidx < 0)\n\t\treturn bsscfgidx;\n\n\tmbss_ssid_le.bsscfgidx = cpu_to_le32(bsscfgidx);\n\tmbss_ssid_le.SSID_len = cpu_to_le32(5);\n\tsprintf(mbss_ssid_le.SSID, \"ssid%d\" , bsscfgidx);\n\n\terr = brcmf_fil_bsscfg_data_set(ifp, \"bsscfg:ssid\", &mbss_ssid_le,\n\t\t\t\t\tsizeof(mbss_ssid_le));\n\tif (err < 0)\n\t\tbphy_err(drvr, \"setting ssid failed %d\\n\", err);\n\n\treturn err;\n}\n\n/**\n * brcmf_ap_add_vif() - create a new AP virtual interface for multiple BSS\n *\n * @wiphy: wiphy device of new interface.\n * @name: name of the new interface.\n * @params: contains mac address for AP device.\n */\nstatic\nstruct wireless_dev *brcmf_ap_add_vif(struct wiphy *wiphy, const char *name,\n\t\t\t\t      struct vif_params *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_cfg80211_vif *vif;\n\tint err;\n\n\tif (brcmf_cfg80211_vif_event_armed(cfg))\n\t\treturn ERR_PTR(-EBUSY);\n\n\tbrcmf_dbg(INFO, \"Adding vif \\\"%s\\\"\\n\", name);\n\n\tvif = brcmf_alloc_vif(cfg, NL80211_IFTYPE_AP);\n\tif (IS_ERR(vif))\n\t\treturn (struct wireless_dev *)vif;\n\n\tbrcmf_cfg80211_arm_vif_event(cfg, vif);\n\n\terr = brcmf_cfg80211_request_ap_if(ifp);\n\tif (err) {\n\t\tbrcmf_cfg80211_arm_vif_event(cfg, NULL);\n\t\tgoto fail;\n\t}\n\n\t/* wait for firmware event */\n\terr = brcmf_cfg80211_wait_vif_event(cfg, BRCMF_E_IF_ADD,\n\t\t\t\t\t    BRCMF_VIF_EVENT_TIMEOUT);\n\tbrcmf_cfg80211_arm_vif_event(cfg, NULL);\n\tif (!err) {\n\t\tbphy_err(drvr, \"timeout occurred\\n\");\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\t/* interface created in firmware */\n\tifp = vif->ifp;\n\tif (!ifp) {\n\t\tbphy_err(drvr, \"no if pointer provided\\n\");\n\t\terr = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tstrncpy(ifp->ndev->name, name, sizeof(ifp->ndev->name) - 1);\n\terr = brcmf_net_attach(ifp, true);\n\tif (err) {\n\t\tbphy_err(drvr, \"Registering netdevice failed\\n\");\n\t\tfree_netdev(ifp->ndev);\n\t\tgoto fail;\n\t}\n\n\treturn &ifp->vif->wdev;\n\nfail:\n\tbrcmf_free_vif(vif);\n\treturn ERR_PTR(err);\n}\n\nstatic bool brcmf_is_apmode(struct brcmf_cfg80211_vif *vif)\n{\n\tenum nl80211_iftype iftype;\n\n\tiftype = vif->wdev.iftype;\n\treturn iftype == NL80211_IFTYPE_AP || iftype == NL80211_IFTYPE_P2P_GO;\n}\n\nstatic bool brcmf_is_ibssmode(struct brcmf_cfg80211_vif *vif)\n{\n\treturn vif->wdev.iftype == NL80211_IFTYPE_ADHOC;\n}\n\n/**\n * brcmf_mon_add_vif() - create monitor mode virtual interface\n *\n * @wiphy: wiphy device of new interface.\n * @name: name of the new interface.\n */\nstatic struct wireless_dev *brcmf_mon_add_vif(struct wiphy *wiphy,\n\t\t\t\t\t      const char *name)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct net_device *ndev;\n\tstruct brcmf_if *ifp;\n\tint err;\n\n\tif (cfg->pub->mon_if) {\n\t\terr = -EEXIST;\n\t\tgoto err_out;\n\t}\n\n\tvif = brcmf_alloc_vif(cfg, NL80211_IFTYPE_MONITOR);\n\tif (IS_ERR(vif)) {\n\t\terr = PTR_ERR(vif);\n\t\tgoto err_out;\n\t}\n\n\tndev = alloc_netdev(sizeof(*ifp), name, NET_NAME_UNKNOWN, ether_setup);\n\tif (!ndev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_vif;\n\t}\n\tndev->type = ARPHRD_IEEE80211_RADIOTAP;\n\tndev->ieee80211_ptr = &vif->wdev;\n\tndev->needs_free_netdev = true;\n\tndev->priv_destructor = brcmf_cfg80211_free_netdev;\n\tSET_NETDEV_DEV(ndev, wiphy_dev(cfg->wiphy));\n\n\tifp = netdev_priv(ndev);\n\tifp->vif = vif;\n\tifp->ndev = ndev;\n\tifp->drvr = cfg->pub;\n\n\tvif->ifp = ifp;\n\tvif->wdev.netdev = ndev;\n\n\terr = brcmf_net_mon_attach(ifp);\n\tif (err) {\n\t\tbrcmf_err(\"Failed to attach %s device\\n\", ndev->name);\n\t\tfree_netdev(ndev);\n\t\tgoto err_free_vif;\n\t}\n\n\tcfg->pub->mon_if = ifp;\n\n\treturn &vif->wdev;\n\nerr_free_vif:\n\tbrcmf_free_vif(vif);\nerr_out:\n\treturn ERR_PTR(err);\n}\n\nstatic int brcmf_mon_del_vif(struct wiphy *wiphy, struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = wdev->netdev;\n\n\tndev->netdev_ops->ndo_stop(ndev);\n\n\tbrcmf_net_detach(ndev, true);\n\n\tcfg->pub->mon_if = NULL;\n\n\treturn 0;\n}\n\nstatic struct wireless_dev *brcmf_cfg80211_add_iface(struct wiphy *wiphy,\n\t\t\t\t\t\t     const char *name,\n\t\t\t\t\t\t     unsigned char name_assign_type,\n\t\t\t\t\t\t     enum nl80211_iftype type,\n\t\t\t\t\t\t     struct vif_params *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct wireless_dev *wdev;\n\tint err;\n\n\tbrcmf_dbg(TRACE, \"enter: %s type %d\\n\", name, type);\n\terr = brcmf_vif_add_validate(wiphy_to_cfg(wiphy), type);\n\tif (err) {\n\t\tbphy_err(drvr, \"iface validation failed: err=%d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\tswitch (type) {\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\tcase NL80211_IFTYPE_MONITOR:\n\t\treturn brcmf_mon_add_vif(wiphy, name);\n\tcase NL80211_IFTYPE_AP:\n\t\twdev = brcmf_ap_add_vif(wiphy, name, params);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\twdev = brcmf_p2p_add_vif(wiphy, name, name_assign_type, type, params);\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (IS_ERR(wdev))\n\t\tbphy_err(drvr, \"add iface %s type %d failed: err=%d\\n\", name,\n\t\t\t type, (int)PTR_ERR(wdev));\n\telse\n\t\tbrcmf_cfg80211_update_proto_addr_mode(wdev);\n\n\treturn wdev;\n}\n\nstatic void brcmf_scan_config_mpc(struct brcmf_if *ifp, int mpc)\n{\n\tif (brcmf_feat_is_quirk_enabled(ifp, BRCMF_FEAT_QUIRK_NEED_MPC))\n\t\tbrcmf_set_mpc(ifp, mpc);\n}\n\nvoid brcmf_set_mpc(struct brcmf_if *ifp, int mpc)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts32 err = 0;\n\n\tif (check_vif_up(ifp->vif)) {\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"mpc\", mpc);\n\t\tif (err) {\n\t\t\tbphy_err(drvr, \"fail to set mpc\\n\");\n\t\t\treturn;\n\t\t}\n\t\tbrcmf_dbg(INFO, \"MPC : %d\\n\", mpc);\n\t}\n}\n\ns32 brcmf_notify_escan_complete(struct brcmf_cfg80211_info *cfg,\n\t\t\t\tstruct brcmf_if *ifp, bool aborted,\n\t\t\t\tbool fw_abort)\n{\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_scan_params_le params_le;\n\tstruct cfg80211_scan_request *scan_request;\n\tu64 reqid;\n\tu32 bucket;\n\ts32 err = 0;\n\n\tbrcmf_dbg(SCAN, \"Enter\\n\");\n\n\t/* clear scan request, because the FW abort can cause a second call */\n\t/* to this functon and might cause a double cfg80211_scan_done      */\n\tscan_request = cfg->scan_request;\n\tcfg->scan_request = NULL;\n\n\tif (timer_pending(&cfg->escan_timeout))\n\t\tdel_timer_sync(&cfg->escan_timeout);\n\n\tif (fw_abort) {\n\t\t/* Do a scan abort to stop the driver's scan engine */\n\t\tbrcmf_dbg(SCAN, \"ABORT scan in firmware\\n\");\n\t\tmemset(&params_le, 0, sizeof(params_le));\n\t\teth_broadcast_addr(params_le.bssid);\n\t\tparams_le.bss_type = DOT11_BSSTYPE_ANY;\n\t\tparams_le.scan_type = 0;\n\t\tparams_le.channel_num = cpu_to_le32(1);\n\t\tparams_le.nprobes = cpu_to_le32(1);\n\t\tparams_le.active_time = cpu_to_le32(-1);\n\t\tparams_le.passive_time = cpu_to_le32(-1);\n\t\tparams_le.home_time = cpu_to_le32(-1);\n\t\t/* Scan is aborted by setting channel_list[0] to -1 */\n\t\tparams_le.channel_list[0] = cpu_to_le16(-1);\n\t\t/* E-Scan (or anyother type) can be aborted by SCAN */\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SCAN,\n\t\t\t\t\t     &params_le, sizeof(params_le));\n\t\tif (err)\n\t\t\tbphy_err(drvr, \"Scan abort failed\\n\");\n\t}\n\n\tbrcmf_scan_config_mpc(ifp, 1);\n\n\t/*\n\t * e-scan can be initiated internally\n\t * which takes precedence.\n\t */\n\tif (cfg->int_escan_map) {\n\t\tbrcmf_dbg(SCAN, \"scheduled scan completed (%x)\\n\",\n\t\t\t  cfg->int_escan_map);\n\t\twhile (cfg->int_escan_map) {\n\t\t\tbucket = __ffs(cfg->int_escan_map);\n\t\t\tcfg->int_escan_map &= ~BIT(bucket);\n\t\t\treqid = brcmf_pno_find_reqid_by_bucket(cfg->pno,\n\t\t\t\t\t\t\t       bucket);\n\t\t\tif (!aborted) {\n\t\t\t\tbrcmf_dbg(SCAN, \"report results: reqid=%llu\\n\",\n\t\t\t\t\t  reqid);\n\t\t\t\tcfg80211_sched_scan_results(cfg_to_wiphy(cfg),\n\t\t\t\t\t\t\t    reqid);\n\t\t\t}\n\t\t}\n\t} else if (scan_request) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = aborted,\n\t\t};\n\n\t\tbrcmf_dbg(SCAN, \"ESCAN Completed scan: %s\\n\",\n\t\t\t  aborted ? \"Aborted\" : \"Done\");\n\t\tcfg80211_scan_done(scan_request, &info);\n\t}\n\tif (!test_and_clear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status))\n\t\tbrcmf_dbg(SCAN, \"Scan complete, probably P2P scan\\n\");\n\n\treturn err;\n}\n\nstatic int brcmf_cfg80211_del_ap_iface(struct wiphy *wiphy,\n\t\t\t\t       struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = wdev->netdev;\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tint ret;\n\tint err;\n\n\tbrcmf_cfg80211_arm_vif_event(cfg, ifp->vif);\n\n\terr = brcmf_fil_bsscfg_data_set(ifp, \"interface_remove\", NULL, 0);\n\tif (err) {\n\t\tbphy_err(drvr, \"interface_remove failed %d\\n\", err);\n\t\tgoto err_unarm;\n\t}\n\n\t/* wait for firmware event */\n\tret = brcmf_cfg80211_wait_vif_event(cfg, BRCMF_E_IF_DEL,\n\t\t\t\t\t    BRCMF_VIF_EVENT_TIMEOUT);\n\tif (!ret) {\n\t\tbphy_err(drvr, \"timeout occurred\\n\");\n\t\terr = -EIO;\n\t\tgoto err_unarm;\n\t}\n\n\tbrcmf_remove_interface(ifp, true);\n\nerr_unarm:\n\tbrcmf_cfg80211_arm_vif_event(cfg, NULL);\n\treturn err;\n}\n\nstatic\nint brcmf_cfg80211_del_iface(struct wiphy *wiphy, struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = wdev->netdev;\n\n\tif (ndev && ndev == cfg_to_ndev(cfg))\n\t\treturn -ENOTSUPP;\n\n\t/* vif event pending in firmware */\n\tif (brcmf_cfg80211_vif_event_armed(cfg))\n\t\treturn -EBUSY;\n\n\tif (ndev) {\n\t\tif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status) &&\n\t\t    cfg->escan_info.ifp == netdev_priv(ndev))\n\t\t\tbrcmf_notify_escan_complete(cfg, netdev_priv(ndev),\n\t\t\t\t\t\t    true, true);\n\n\t\tbrcmf_fil_iovar_int_set(netdev_priv(ndev), \"mpc\", 1);\n\t}\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\treturn -EOPNOTSUPP;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\treturn brcmf_mon_del_vif(wiphy, wdev);\n\tcase NL80211_IFTYPE_AP:\n\t\treturn brcmf_cfg80211_del_ap_iface(wiphy, wdev);\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\treturn brcmf_p2p_del_vif(wiphy, wdev);\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic s32\nbrcmf_cfg80211_change_iface(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t enum nl80211_iftype type,\n\t\t\t struct vif_params *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_vif *vif = ifp->vif;\n\tstruct brcmf_pub *drvr = cfg->pub;\n\ts32 infra = 0;\n\ts32 ap = 0;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter, bsscfgidx=%d, type=%d\\n\", ifp->bsscfgidx,\n\t\t  type);\n\n\t/* WAR: There are a number of p2p interface related problems which\n\t * need to be handled initially (before doing the validate).\n\t * wpa_supplicant tends to do iface changes on p2p device/client/go\n\t * which are not always possible/allowed. However we need to return\n\t * OK otherwise the wpa_supplicant wont start. The situation differs\n\t * on configuration and setup (p2pon=1 module param). The first check\n\t * is to see if the request is a change to station for p2p iface.\n\t */\n\tif ((type == NL80211_IFTYPE_STATION) &&\n\t    ((vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT) ||\n\t     (vif->wdev.iftype == NL80211_IFTYPE_P2P_GO) ||\n\t     (vif->wdev.iftype == NL80211_IFTYPE_P2P_DEVICE))) {\n\t\tbrcmf_dbg(TRACE, \"Ignoring cmd for p2p if\\n\");\n\t\t/* Now depending on whether module param p2pon=1 was used the\n\t\t * response needs to be either 0 or EOPNOTSUPP. The reason is\n\t\t * that if p2pon=1 is used, but a newer supplicant is used then\n\t\t * we should return an error, as this combination wont work.\n\t\t * In other situations 0 is returned and supplicant will start\n\t\t * normally. It will give a trace in cfg80211, but it is the\n\t\t * only way to get it working. Unfortunately this will result\n\t\t * in situation where we wont support new supplicant in\n\t\t * combination with module param p2pon=1, but that is the way\n\t\t * it is. If the user tries this then unloading of driver might\n\t\t * fail/lock.\n\t\t */\n\t\tif (cfg->p2p.p2pdev_dynamically)\n\t\t\treturn -EOPNOTSUPP;\n\t\telse\n\t\t\treturn 0;\n\t}\n\terr = brcmf_vif_change_validate(wiphy_to_cfg(wiphy), vif, type);\n\tif (err) {\n\t\tbphy_err(drvr, \"iface validation failed: err=%d\\n\", err);\n\t\treturn err;\n\t}\n\tswitch (type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_WDS:\n\t\tbphy_err(drvr, \"type (%d) : currently we do not support this type\\n\",\n\t\t\t type);\n\t\treturn -EOPNOTSUPP;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tinfra = 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tinfra = 1;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tap = 1;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (ap) {\n\t\tif (type == NL80211_IFTYPE_P2P_GO) {\n\t\t\tbrcmf_dbg(INFO, \"IF Type = P2P GO\\n\");\n\t\t\terr = brcmf_p2p_ifchange(cfg, BRCMF_FIL_P2P_IF_GO);\n\t\t}\n\t\tif (!err) {\n\t\t\tbrcmf_dbg(INFO, \"IF Type = AP\\n\");\n\t\t}\n\t} else {\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, infra);\n\t\tif (err) {\n\t\t\tbphy_err(drvr, \"WLC_SET_INFRA error (%d)\\n\", err);\n\t\t\terr = -EAGAIN;\n\t\t\tgoto done;\n\t\t}\n\t\tbrcmf_dbg(INFO, \"IF Type = %s\\n\", brcmf_is_ibssmode(vif) ?\n\t\t\t  \"Adhoc\" : \"Infra\");\n\t}\n\tndev->ieee80211_ptr->iftype = type;\n\n\tbrcmf_cfg80211_update_proto_addr_mode(&vif->wdev);\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\n\treturn err;\n}\n\nstatic void brcmf_escan_prep(struct brcmf_cfg80211_info *cfg,\n\t\t\t     struct brcmf_scan_params_le *params_le,\n\t\t\t     struct cfg80211_scan_request *request)\n{\n\tu32 n_ssids;\n\tu32 n_channels;\n\ts32 i;\n\ts32 offset;\n\tu16 chanspec;\n\tchar *ptr;\n\tstruct brcmf_ssid_le ssid_le;\n\n\teth_broadcast_addr(params_le->bssid);\n\tparams_le->bss_type = DOT11_BSSTYPE_ANY;\n\tparams_le->scan_type = BRCMF_SCANTYPE_ACTIVE;\n\tparams_le->channel_num = 0;\n\tparams_le->nprobes = cpu_to_le32(-1);\n\tparams_le->active_time = cpu_to_le32(-1);\n\tparams_le->passive_time = cpu_to_le32(-1);\n\tparams_le->home_time = cpu_to_le32(-1);\n\tmemset(&params_le->ssid_le, 0, sizeof(params_le->ssid_le));\n\n\tn_ssids = request->n_ssids;\n\tn_channels = request->n_channels;\n\n\t/* Copy channel array if applicable */\n\tbrcmf_dbg(SCAN, \"### List of channelspecs to scan ### %d\\n\",\n\t\t  n_channels);\n\tif (n_channels > 0) {\n\t\tfor (i = 0; i < n_channels; i++) {\n\t\t\tchanspec = channel_to_chanspec(&cfg->d11inf,\n\t\t\t\t\t\t       request->channels[i]);\n\t\t\tbrcmf_dbg(SCAN, \"Chan : %d, Channel spec: %x\\n\",\n\t\t\t\t  request->channels[i]->hw_value, chanspec);\n\t\t\tparams_le->channel_list[i] = cpu_to_le16(chanspec);\n\t\t}\n\t} else {\n\t\tbrcmf_dbg(SCAN, \"Scanning all channels\\n\");\n\t}\n\t/* Copy ssid array if applicable */\n\tbrcmf_dbg(SCAN, \"### List of SSIDs to scan ### %d\\n\", n_ssids);\n\tif (n_ssids > 0) {\n\t\toffset = offsetof(struct brcmf_scan_params_le, channel_list) +\n\t\t\t\tn_channels * sizeof(u16);\n\t\toffset = roundup(offset, sizeof(u32));\n\t\tptr = (char *)params_le + offset;\n\t\tfor (i = 0; i < n_ssids; i++) {\n\t\t\tmemset(&ssid_le, 0, sizeof(ssid_le));\n\t\t\tssid_le.SSID_len =\n\t\t\t\t\tcpu_to_le32(request->ssids[i].ssid_len);\n\t\t\tmemcpy(ssid_le.SSID, request->ssids[i].ssid,\n\t\t\t       request->ssids[i].ssid_len);\n\t\t\tif (!ssid_le.SSID_len)\n\t\t\t\tbrcmf_dbg(SCAN, \"%d: Broadcast scan\\n\", i);\n\t\t\telse\n\t\t\t\tbrcmf_dbg(SCAN, \"%d: scan for  %.32s size=%d\\n\",\n\t\t\t\t\t  i, ssid_le.SSID, ssid_le.SSID_len);\n\t\t\tmemcpy(ptr, &ssid_le, sizeof(ssid_le));\n\t\t\tptr += sizeof(ssid_le);\n\t\t}\n\t} else {\n\t\tbrcmf_dbg(SCAN, \"Performing passive scan\\n\");\n\t\tparams_le->scan_type = BRCMF_SCANTYPE_PASSIVE;\n\t}\n\t/* Adding mask to channel numbers */\n\tparams_le->channel_num =\n\t\tcpu_to_le32((n_ssids << BRCMF_SCAN_PARAMS_NSSID_SHIFT) |\n\t\t\t(n_channels & BRCMF_SCAN_PARAMS_COUNT_MASK));\n}\n\nstatic s32\nbrcmf_run_escan(struct brcmf_cfg80211_info *cfg, struct brcmf_if *ifp,\n\t\tstruct cfg80211_scan_request *request)\n{\n\tstruct brcmf_pub *drvr = cfg->pub;\n\ts32 params_size = BRCMF_SCAN_PARAMS_FIXED_SIZE +\n\t\t\t  offsetof(struct brcmf_escan_params_le, params_le);\n\tstruct brcmf_escan_params_le *params;\n\ts32 err = 0;\n\n\tbrcmf_dbg(SCAN, \"E-SCAN START\\n\");\n\n\tif (request != NULL) {\n\t\t/* Allocate space for populating ssids in struct */\n\t\tparams_size += sizeof(u32) * ((request->n_channels + 1) / 2);\n\n\t\t/* Allocate space for populating ssids in struct */\n\t\tparams_size += sizeof(struct brcmf_ssid_le) * request->n_ssids;\n\t}\n\n\tparams = kzalloc(params_size, GFP_KERNEL);\n\tif (!params) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\tBUG_ON(params_size + sizeof(\"escan\") >= BRCMF_DCMD_MEDLEN);\n\tbrcmf_escan_prep(cfg, &params->params_le, request);\n\tparams->version = cpu_to_le32(BRCMF_ESCAN_REQ_VERSION);\n\tparams->action = cpu_to_le16(WL_ESCAN_ACTION_START);\n\tparams->sync_id = cpu_to_le16(0x1234);\n\n\terr = brcmf_fil_iovar_data_set(ifp, \"escan\", params, params_size);\n\tif (err) {\n\t\tif (err == -EBUSY)\n\t\t\tbrcmf_dbg(INFO, \"system busy : escan canceled\\n\");\n\t\telse\n\t\t\tbphy_err(drvr, \"error (%d)\\n\", err);\n\t}\n\n\tkfree(params);\nexit:\n\treturn err;\n}\n\nstatic s32\nbrcmf_do_escan(struct brcmf_if *ifp, struct cfg80211_scan_request *request)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\ts32 err;\n\tstruct brcmf_scan_results *results;\n\tstruct escan_info *escan = &cfg->escan_info;\n\n\tbrcmf_dbg(SCAN, \"Enter\\n\");\n\tescan->ifp = ifp;\n\tescan->wiphy = cfg->wiphy;\n\tescan->escan_state = WL_ESCAN_STATE_SCANNING;\n\n\tbrcmf_scan_config_mpc(ifp, 0);\n\tresults = (struct brcmf_scan_results *)cfg->escan_info.escan_buf;\n\tresults->version = 0;\n\tresults->count = 0;\n\tresults->buflen = WL_ESCAN_RESULTS_FIXED_SIZE;\n\n\terr = escan->run(cfg, ifp, request);\n\tif (err)\n\t\tbrcmf_scan_config_mpc(ifp, 1);\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_scan(struct wiphy *wiphy, struct cfg80211_scan_request *request)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_cfg80211_vif *vif;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tvif = container_of(request->wdev, struct brcmf_cfg80211_vif, wdev);\n\tif (!check_vif_up(vif))\n\t\treturn -EIO;\n\n\tif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status)) {\n\t\tbphy_err(drvr, \"Scanning already: status (%lu)\\n\",\n\t\t\t cfg->scan_status);\n\t\treturn -EAGAIN;\n\t}\n\tif (test_bit(BRCMF_SCAN_STATUS_ABORT, &cfg->scan_status)) {\n\t\tbphy_err(drvr, \"Scanning being aborted: status (%lu)\\n\",\n\t\t\t cfg->scan_status);\n\t\treturn -EAGAIN;\n\t}\n\tif (test_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status)) {\n\t\tbphy_err(drvr, \"Scanning suppressed: status (%lu)\\n\",\n\t\t\t cfg->scan_status);\n\t\treturn -EAGAIN;\n\t}\n\tif (test_bit(BRCMF_VIF_STATUS_CONNECTING, &vif->sme_state)) {\n\t\tbphy_err(drvr, \"Connecting: status (%lu)\\n\", vif->sme_state);\n\t\treturn -EAGAIN;\n\t}\n\n\t/* If scan req comes for p2p0, send it over primary I/F */\n\tif (vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif)\n\t\tvif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;\n\n\tbrcmf_dbg(SCAN, \"START ESCAN\\n\");\n\n\tcfg->scan_request = request;\n\tset_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\n\n\tcfg->escan_info.run = brcmf_run_escan;\n\terr = brcmf_p2p_scan_prep(wiphy, request, vif);\n\tif (err)\n\t\tgoto scan_out;\n\n\terr = brcmf_vif_set_mgmt_ie(vif, BRCMF_VNDR_IE_PRBREQ_FLAG,\n\t\t\t\t    request->ie, request->ie_len);\n\tif (err)\n\t\tgoto scan_out;\n\n\terr = brcmf_do_escan(vif->ifp, request);\n\tif (err)\n\t\tgoto scan_out;\n\n\t/* Arm scan timeout timer */\n\tmod_timer(&cfg->escan_timeout,\n\t\t  jiffies + msecs_to_jiffies(BRCMF_ESCAN_TIMER_INTERVAL_MS));\n\n\treturn 0;\n\nscan_out:\n\tbphy_err(drvr, \"scan error (%d)\\n\", err);\n\tclear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\n\tcfg->scan_request = NULL;\n\treturn err;\n}\n\nstatic s32 brcmf_set_rts(struct net_device *ndev, u32 rts_threshold)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts32 err = 0;\n\n\terr = brcmf_fil_iovar_int_set(ifp, \"rtsthresh\", rts_threshold);\n\tif (err)\n\t\tbphy_err(drvr, \"Error (%d)\\n\", err);\n\n\treturn err;\n}\n\nstatic s32 brcmf_set_frag(struct net_device *ndev, u32 frag_threshold)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts32 err = 0;\n\n\terr = brcmf_fil_iovar_int_set(ifp, \"fragthresh\",\n\t\t\t\t      frag_threshold);\n\tif (err)\n\t\tbphy_err(drvr, \"Error (%d)\\n\", err);\n\n\treturn err;\n}\n\nstatic s32 brcmf_set_retry(struct net_device *ndev, u32 retry, bool l)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts32 err = 0;\n\tu32 cmd = (l ? BRCMF_C_SET_LRL : BRCMF_C_SET_SRL);\n\n\terr = brcmf_fil_cmd_int_set(ifp, cmd, retry);\n\tif (err) {\n\t\tbphy_err(drvr, \"cmd (%d) , error (%d)\\n\", cmd, err);\n\t\treturn err;\n\t}\n\treturn err;\n}\n\nstatic s32 brcmf_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (changed & WIPHY_PARAM_RTS_THRESHOLD &&\n\t    (cfg->conf->rts_threshold != wiphy->rts_threshold)) {\n\t\tcfg->conf->rts_threshold = wiphy->rts_threshold;\n\t\terr = brcmf_set_rts(ndev, cfg->conf->rts_threshold);\n\t\tif (!err)\n\t\t\tgoto done;\n\t}\n\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD &&\n\t    (cfg->conf->frag_threshold != wiphy->frag_threshold)) {\n\t\tcfg->conf->frag_threshold = wiphy->frag_threshold;\n\t\terr = brcmf_set_frag(ndev, cfg->conf->frag_threshold);\n\t\tif (!err)\n\t\t\tgoto done;\n\t}\n\tif (changed & WIPHY_PARAM_RETRY_LONG\n\t    && (cfg->conf->retry_long != wiphy->retry_long)) {\n\t\tcfg->conf->retry_long = wiphy->retry_long;\n\t\terr = brcmf_set_retry(ndev, cfg->conf->retry_long, true);\n\t\tif (!err)\n\t\t\tgoto done;\n\t}\n\tif (changed & WIPHY_PARAM_RETRY_SHORT\n\t    && (cfg->conf->retry_short != wiphy->retry_short)) {\n\t\tcfg->conf->retry_short = wiphy->retry_short;\n\t\terr = brcmf_set_retry(ndev, cfg->conf->retry_short, false);\n\t\tif (!err)\n\t\t\tgoto done;\n\t}\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic void brcmf_init_prof(struct brcmf_cfg80211_profile *prof)\n{\n\tmemset(prof, 0, sizeof(*prof));\n}\n\nstatic u16 brcmf_map_fw_linkdown_reason(const struct brcmf_event_msg *e)\n{\n\tu16 reason;\n\n\tswitch (e->event_code) {\n\tcase BRCMF_E_DEAUTH:\n\tcase BRCMF_E_DEAUTH_IND:\n\tcase BRCMF_E_DISASSOC_IND:\n\t\treason = e->reason;\n\t\tbreak;\n\tcase BRCMF_E_LINK:\n\tdefault:\n\t\treason = 0;\n\t\tbreak;\n\t}\n\treturn reason;\n}\n\nstatic int brcmf_set_pmk(struct brcmf_if *ifp, const u8 *pmk_data, u16 pmk_len)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_wsec_pmk_le pmk;\n\tint i, err;\n\n\t/* convert to firmware key format */\n\tpmk.key_len = cpu_to_le16(pmk_len << 1);\n\tpmk.flags = cpu_to_le16(BRCMF_WSEC_PASSPHRASE);\n\tfor (i = 0; i < pmk_len; i++)\n\t\tsnprintf(&pmk.key[2 * i], 3, \"%02x\", pmk_data[i]);\n\n\t/* store psk in firmware */\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_WSEC_PMK,\n\t\t\t\t     &pmk, sizeof(pmk));\n\tif (err < 0)\n\t\tbphy_err(drvr, \"failed to change PSK in firmware (len=%u)\\n\",\n\t\t\t pmk_len);\n\n\treturn err;\n}\n\nstatic int brcmf_set_sae_password(struct brcmf_if *ifp, const u8 *pwd_data,\n\t\t\t\t  u16 pwd_len)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_wsec_sae_pwd_le sae_pwd;\n\tint err;\n\n\tif (pwd_len > BRCMF_WSEC_MAX_SAE_PASSWORD_LEN) {\n\t\tbphy_err(drvr, \"sae_password must be less than %d\\n\",\n\t\t\t BRCMF_WSEC_MAX_SAE_PASSWORD_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tsae_pwd.key_len = cpu_to_le16(pwd_len);\n\tmemcpy(sae_pwd.key, pwd_data, pwd_len);\n\n\terr = brcmf_fil_iovar_data_set(ifp, \"sae_password\", &sae_pwd,\n\t\t\t\t       sizeof(sae_pwd));\n\tif (err < 0)\n\t\tbphy_err(drvr, \"failed to set SAE password in firmware (len=%u)\\n\",\n\t\t\t pwd_len);\n\n\treturn err;\n}\n\nstatic void brcmf_link_down(struct brcmf_cfg80211_vif *vif, u16 reason,\n\t\t\t    bool locally_generated)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(vif->wdev.wiphy);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tbool bus_up = drvr->bus_if->state == BRCMF_BUS_UP;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (test_and_clear_bit(BRCMF_VIF_STATUS_CONNECTED, &vif->sme_state)) {\n\t\tif (bus_up) {\n\t\t\tbrcmf_dbg(INFO, \"Call WLC_DISASSOC to stop excess roaming\\n\");\n\t\t\terr = brcmf_fil_cmd_data_set(vif->ifp,\n\t\t\t\t\t\t     BRCMF_C_DISASSOC, NULL, 0);\n\t\t\tif (err)\n\t\t\t\tbphy_err(drvr, \"WLC_DISASSOC failed (%d)\\n\",\n\t\t\t\t\t err);\n\t\t}\n\n\t\tif ((vif->wdev.iftype == NL80211_IFTYPE_STATION) ||\n\t\t    (vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT))\n\t\t\tcfg80211_disconnected(vif->wdev.netdev, reason, NULL, 0,\n\t\t\t\t\t      locally_generated, GFP_KERNEL);\n\t}\n\tclear_bit(BRCMF_VIF_STATUS_CONNECTING, &vif->sme_state);\n\tclear_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status);\n\tbrcmf_btcoex_set_mode(vif, BRCMF_BTCOEX_ENABLED, 0);\n\tif (vif->profile.use_fwsup != BRCMF_PROFILE_FWSUP_NONE) {\n\t\tif (bus_up)\n\t\t\tbrcmf_set_pmk(vif->ifp, NULL, 0);\n\t\tvif->profile.use_fwsup = BRCMF_PROFILE_FWSUP_NONE;\n\t}\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n}\n\nstatic s32\nbrcmf_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *ndev,\n\t\t      struct cfg80211_ibss_params *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_join_params join_params;\n\tsize_t join_params_size = 0;\n\ts32 err = 0;\n\ts32 wsec = 0;\n\ts32 bcnprd;\n\tu16 chanspec;\n\tu32 ssid_len;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (params->ssid)\n\t\tbrcmf_dbg(CONN, \"SSID: %s\\n\", params->ssid);\n\telse {\n\t\tbrcmf_dbg(CONN, \"SSID: NULL, Not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tset_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\n\tif (params->bssid)\n\t\tbrcmf_dbg(CONN, \"BSSID: %pM\\n\", params->bssid);\n\telse\n\t\tbrcmf_dbg(CONN, \"No BSSID specified\\n\");\n\n\tif (params->chandef.chan)\n\t\tbrcmf_dbg(CONN, \"channel: %d\\n\",\n\t\t\t  params->chandef.chan->center_freq);\n\telse\n\t\tbrcmf_dbg(CONN, \"no channel specified\\n\");\n\n\tif (params->channel_fixed)\n\t\tbrcmf_dbg(CONN, \"fixed channel required\\n\");\n\telse\n\t\tbrcmf_dbg(CONN, \"no fixed channel required\\n\");\n\n\tif (params->ie && params->ie_len)\n\t\tbrcmf_dbg(CONN, \"ie len: %d\\n\", params->ie_len);\n\telse\n\t\tbrcmf_dbg(CONN, \"no ie specified\\n\");\n\n\tif (params->beacon_interval)\n\t\tbrcmf_dbg(CONN, \"beacon interval: %d\\n\",\n\t\t\t  params->beacon_interval);\n\telse\n\t\tbrcmf_dbg(CONN, \"no beacon interval specified\\n\");\n\n\tif (params->basic_rates)\n\t\tbrcmf_dbg(CONN, \"basic rates: %08X\\n\", params->basic_rates);\n\telse\n\t\tbrcmf_dbg(CONN, \"no basic rates specified\\n\");\n\n\tif (params->privacy)\n\t\tbrcmf_dbg(CONN, \"privacy required\\n\");\n\telse\n\t\tbrcmf_dbg(CONN, \"no privacy required\\n\");\n\n\t/* Configure Privacy for starter */\n\tif (params->privacy)\n\t\twsec |= WEP_ENABLED;\n\n\terr = brcmf_fil_iovar_int_set(ifp, \"wsec\", wsec);\n\tif (err) {\n\t\tbphy_err(drvr, \"wsec failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\t/* Configure Beacon Interval for starter */\n\tif (params->beacon_interval)\n\t\tbcnprd = params->beacon_interval;\n\telse\n\t\tbcnprd = 100;\n\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD, bcnprd);\n\tif (err) {\n\t\tbphy_err(drvr, \"WLC_SET_BCNPRD failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\t/* Configure required join parameter */\n\tmemset(&join_params, 0, sizeof(struct brcmf_join_params));\n\n\t/* SSID */\n\tssid_len = min_t(u32, params->ssid_len, IEEE80211_MAX_SSID_LEN);\n\tmemcpy(join_params.ssid_le.SSID, params->ssid, ssid_len);\n\tjoin_params.ssid_le.SSID_len = cpu_to_le32(ssid_len);\n\tjoin_params_size = sizeof(join_params.ssid_le);\n\n\t/* BSSID */\n\tif (params->bssid) {\n\t\tmemcpy(join_params.params_le.bssid, params->bssid, ETH_ALEN);\n\t\tjoin_params_size += BRCMF_ASSOC_PARAMS_FIXED_SIZE;\n\t\tmemcpy(profile->bssid, params->bssid, ETH_ALEN);\n\t} else {\n\t\teth_broadcast_addr(join_params.params_le.bssid);\n\t\teth_zero_addr(profile->bssid);\n\t}\n\n\t/* Channel */\n\tif (params->chandef.chan) {\n\t\tu32 target_channel;\n\n\t\tcfg->channel =\n\t\t\tieee80211_frequency_to_channel(\n\t\t\t\tparams->chandef.chan->center_freq);\n\t\tif (params->channel_fixed) {\n\t\t\t/* adding chanspec */\n\t\t\tchanspec = chandef_to_chanspec(&cfg->d11inf,\n\t\t\t\t\t\t       &params->chandef);\n\t\t\tjoin_params.params_le.chanspec_list[0] =\n\t\t\t\tcpu_to_le16(chanspec);\n\t\t\tjoin_params.params_le.chanspec_num = cpu_to_le32(1);\n\t\t\tjoin_params_size += sizeof(join_params.params_le);\n\t\t}\n\n\t\t/* set channel for starter */\n\t\ttarget_channel = cfg->channel;\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_CHANNEL,\n\t\t\t\t\t    target_channel);\n\t\tif (err) {\n\t\t\tbphy_err(drvr, \"WLC_SET_CHANNEL failed (%d)\\n\", err);\n\t\t\tgoto done;\n\t\t}\n\t} else\n\t\tcfg->channel = 0;\n\n\tcfg->ibss_starter = false;\n\n\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\n\t\t\t\t     &join_params, join_params_size);\n\tif (err) {\n\t\tbphy_err(drvr, \"WLC_SET_SSID failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\ndone:\n\tif (err)\n\t\tclear_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_leave_ibss(struct wiphy *wiphy, struct net_device *ndev)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif)) {\n\t\t/* When driver is being unloaded, it can end up here. If an\n\t\t * error is returned then later on a debug trace in the wireless\n\t\t * core module will be printed. To avoid this 0 is returned.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tbrcmf_link_down(ifp->vif, WLAN_REASON_DEAUTH_LEAVING, true);\n\tbrcmf_net_setcarrier(ifp, false);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\n\treturn 0;\n}\n\nstatic s32 brcmf_set_wpa_version(struct net_device *ndev,\n\t\t\t\t struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_cfg80211_security *sec;\n\ts32 val = 0;\n\ts32 err = 0;\n\n\tif (sme->crypto.wpa_versions & NL80211_WPA_VERSION_1)\n\t\tval = WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED;\n\telse if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)\n\t\tval = WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED;\n\telse if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_3)\n\t\tval = WPA3_AUTH_SAE_PSK;\n\telse\n\t\tval = WPA_AUTH_DISABLED;\n\tbrcmf_dbg(CONN, \"setting wpa_auth to 0x%0x\\n\", val);\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wpa_auth\", val);\n\tif (err) {\n\t\tbphy_err(drvr, \"set wpa_auth failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tsec = &profile->sec;\n\tsec->wpa_versions = sme->crypto.wpa_versions;\n\treturn err;\n}\n\nstatic s32 brcmf_set_auth_type(struct net_device *ndev,\n\t\t\t       struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_cfg80211_security *sec;\n\ts32 val = 0;\n\ts32 err = 0;\n\n\tswitch (sme->auth_type) {\n\tcase NL80211_AUTHTYPE_OPEN_SYSTEM:\n\t\tval = 0;\n\t\tbrcmf_dbg(CONN, \"open system\\n\");\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_SHARED_KEY:\n\t\tval = 1;\n\t\tbrcmf_dbg(CONN, \"shared key\\n\");\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_SAE:\n\t\tval = 3;\n\t\tbrcmf_dbg(CONN, \"SAE authentication\\n\");\n\t\tbreak;\n\tdefault:\n\t\tval = 2;\n\t\tbrcmf_dbg(CONN, \"automatic, auth type (%d)\\n\", sme->auth_type);\n\t\tbreak;\n\t}\n\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"auth\", val);\n\tif (err) {\n\t\tbphy_err(drvr, \"set auth failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tsec = &profile->sec;\n\tsec->auth_type = sme->auth_type;\n\treturn err;\n}\n\nstatic s32\nbrcmf_set_wsec_mode(struct net_device *ndev,\n\t\t    struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_cfg80211_security *sec;\n\ts32 pval = 0;\n\ts32 gval = 0;\n\ts32 wsec;\n\ts32 err = 0;\n\n\tif (sme->crypto.n_ciphers_pairwise) {\n\t\tswitch (sme->crypto.ciphers_pairwise[0]) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\tpval = WEP_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tpval = TKIP_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tpval = AES_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\t\tpval = AES_ENABLED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbphy_err(drvr, \"invalid cipher pairwise (%d)\\n\",\n\t\t\t\t sme->crypto.ciphers_pairwise[0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (sme->crypto.cipher_group) {\n\t\tswitch (sme->crypto.cipher_group) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\tgval = WEP_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tgval = TKIP_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tgval = AES_ENABLED;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\t\tgval = AES_ENABLED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbphy_err(drvr, \"invalid cipher group (%d)\\n\",\n\t\t\t\t sme->crypto.cipher_group);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tbrcmf_dbg(CONN, \"pval (%d) gval (%d)\\n\", pval, gval);\n\t/* In case of privacy, but no security and WPS then simulate */\n\t/* setting AES. WPS-2.0 allows no security                   */\n\tif (brcmf_find_wpsie(sme->ie, sme->ie_len) && !pval && !gval &&\n\t    sme->privacy)\n\t\tpval = AES_ENABLED;\n\n\twsec = pval | gval;\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wsec\", wsec);\n\tif (err) {\n\t\tbphy_err(drvr, \"error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tsec = &profile->sec;\n\tsec->cipher_pairwise = sme->crypto.ciphers_pairwise[0];\n\tsec->cipher_group = sme->crypto.cipher_group;\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_set_key_mgmt(struct net_device *ndev, struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts32 val;\n\ts32 err;\n\tconst struct brcmf_tlv *rsn_ie;\n\tconst u8 *ie;\n\tu32 ie_len;\n\tu32 offset;\n\tu16 rsn_cap;\n\tu32 mfp;\n\tu16 count;\n\n\tprofile->use_fwsup = BRCMF_PROFILE_FWSUP_NONE;\n\tprofile->is_ft = false;\n\n\tif (!sme->crypto.n_akm_suites)\n\t\treturn 0;\n\n\terr = brcmf_fil_bsscfg_int_get(netdev_priv(ndev), \"wpa_auth\", &val);\n\tif (err) {\n\t\tbphy_err(drvr, \"could not get wpa_auth (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tif (val & (WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED)) {\n\t\tswitch (sme->crypto.akm_suites[0]) {\n\t\tcase WLAN_AKM_SUITE_8021X:\n\t\t\tval = WPA_AUTH_UNSPECIFIED;\n\t\t\tif (sme->want_1x)\n\t\t\t\tprofile->use_fwsup = BRCMF_PROFILE_FWSUP_1X;\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_PSK:\n\t\t\tval = WPA_AUTH_PSK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbphy_err(drvr, \"invalid cipher group (%d)\\n\",\n\t\t\t\t sme->crypto.cipher_group);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (val & (WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED)) {\n\t\tswitch (sme->crypto.akm_suites[0]) {\n\t\tcase WLAN_AKM_SUITE_8021X:\n\t\t\tval = WPA2_AUTH_UNSPECIFIED;\n\t\t\tif (sme->want_1x)\n\t\t\t\tprofile->use_fwsup = BRCMF_PROFILE_FWSUP_1X;\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_8021X_SHA256:\n\t\t\tval = WPA2_AUTH_1X_SHA256;\n\t\t\tif (sme->want_1x)\n\t\t\t\tprofile->use_fwsup = BRCMF_PROFILE_FWSUP_1X;\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_PSK_SHA256:\n\t\t\tval = WPA2_AUTH_PSK_SHA256;\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_PSK:\n\t\t\tval = WPA2_AUTH_PSK;\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_FT_8021X:\n\t\t\tval = WPA2_AUTH_UNSPECIFIED | WPA2_AUTH_FT;\n\t\t\tprofile->is_ft = true;\n\t\t\tif (sme->want_1x)\n\t\t\t\tprofile->use_fwsup = BRCMF_PROFILE_FWSUP_1X;\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_FT_PSK:\n\t\t\tval = WPA2_AUTH_PSK | WPA2_AUTH_FT;\n\t\t\tprofile->is_ft = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbphy_err(drvr, \"invalid cipher group (%d)\\n\",\n\t\t\t\t sme->crypto.cipher_group);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (val & WPA3_AUTH_SAE_PSK) {\n\t\tswitch (sme->crypto.akm_suites[0]) {\n\t\tcase WLAN_AKM_SUITE_SAE:\n\t\t\tval = WPA3_AUTH_SAE_PSK;\n\t\t\tif (sme->crypto.sae_pwd) {\n\t\t\t\tbrcmf_dbg(INFO, \"using SAE offload\\n\");\n\t\t\t\tprofile->use_fwsup = BRCMF_PROFILE_FWSUP_SAE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbphy_err(drvr, \"invalid cipher group (%d)\\n\",\n\t\t\t\t sme->crypto.cipher_group);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (profile->use_fwsup == BRCMF_PROFILE_FWSUP_1X)\n\t\tbrcmf_dbg(INFO, \"using 1X offload\\n\");\n\n\tif (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP))\n\t\tgoto skip_mfp_config;\n\t/* The MFP mode (1 or 2) needs to be determined, parse IEs. The\n\t * IE will not be verified, just a quick search for MFP config\n\t */\n\trsn_ie = brcmf_parse_tlvs((const u8 *)sme->ie, sme->ie_len,\n\t\t\t\t  WLAN_EID_RSN);\n\tif (!rsn_ie)\n\t\tgoto skip_mfp_config;\n\tie = (const u8 *)rsn_ie;\n\tie_len = rsn_ie->len + TLV_HDR_LEN;\n\t/* Skip unicast suite */\n\toffset = TLV_HDR_LEN + WPA_IE_VERSION_LEN + WPA_IE_MIN_OUI_LEN;\n\tif (offset + WPA_IE_SUITE_COUNT_LEN >= ie_len)\n\t\tgoto skip_mfp_config;\n\t/* Skip multicast suite */\n\tcount = ie[offset] + (ie[offset + 1] << 8);\n\toffset += WPA_IE_SUITE_COUNT_LEN + (count * WPA_IE_MIN_OUI_LEN);\n\tif (offset + WPA_IE_SUITE_COUNT_LEN >= ie_len)\n\t\tgoto skip_mfp_config;\n\t/* Skip auth key management suite(s) */\n\tcount = ie[offset] + (ie[offset + 1] << 8);\n\toffset += WPA_IE_SUITE_COUNT_LEN + (count * WPA_IE_MIN_OUI_LEN);\n\tif (offset + WPA_IE_SUITE_COUNT_LEN > ie_len)\n\t\tgoto skip_mfp_config;\n\t/* Ready to read capabilities */\n\tmfp = BRCMF_MFP_NONE;\n\trsn_cap = ie[offset] + (ie[offset + 1] << 8);\n\tif (rsn_cap & RSN_CAP_MFPR_MASK)\n\t\tmfp = BRCMF_MFP_REQUIRED;\n\telse if (rsn_cap & RSN_CAP_MFPC_MASK)\n\t\tmfp = BRCMF_MFP_CAPABLE;\n\tbrcmf_fil_bsscfg_int_set(netdev_priv(ndev), \"mfp\", mfp);\n\nskip_mfp_config:\n\tbrcmf_dbg(CONN, \"setting wpa_auth to %d\\n\", val);\n\terr = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), \"wpa_auth\", val);\n\tif (err) {\n\t\tbphy_err(drvr, \"could not set wpa_auth (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_set_sharedkey(struct net_device *ndev,\n\t\t    struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);\n\tstruct brcmf_cfg80211_security *sec;\n\tstruct brcmf_wsec_key key;\n\ts32 val;\n\ts32 err = 0;\n\n\tbrcmf_dbg(CONN, \"key len (%d)\\n\", sme->key_len);\n\n\tif (sme->key_len == 0)\n\t\treturn 0;\n\n\tsec = &profile->sec;\n\tbrcmf_dbg(CONN, \"wpa_versions 0x%x cipher_pairwise 0x%x\\n\",\n\t\t  sec->wpa_versions, sec->cipher_pairwise);\n\n\tif (sec->wpa_versions & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2 |\n\t\t\t\t NL80211_WPA_VERSION_3))\n\t\treturn 0;\n\n\tif (!(sec->cipher_pairwise &\n\t    (WLAN_CIPHER_SUITE_WEP40 | WLAN_CIPHER_SUITE_WEP104)))\n\t\treturn 0;\n\n\tmemset(&key, 0, sizeof(key));\n\tkey.len = (u32) sme->key_len;\n\tkey.index = (u32) sme->key_idx;\n\tif (key.len > sizeof(key.data)) {\n\t\tbphy_err(drvr, \"Too long key length (%u)\\n\", key.len);\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(key.data, sme->key, key.len);\n\tkey.flags = BRCMF_PRIMARY_KEY;\n\tswitch (sec->cipher_pairwise) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tkey.algo = CRYPTO_ALGO_WEP1;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tkey.algo = CRYPTO_ALGO_WEP128;\n\t\tbreak;\n\tdefault:\n\t\tbphy_err(drvr, \"Invalid algorithm (%d)\\n\",\n\t\t\t sme->crypto.ciphers_pairwise[0]);\n\t\treturn -EINVAL;\n\t}\n\t/* Set the new key/index */\n\tbrcmf_dbg(CONN, \"key length (%d) key index (%d) algo (%d)\\n\",\n\t\t  key.len, key.index, key.algo);\n\tbrcmf_dbg(CONN, \"key \\\"%s\\\"\\n\", key.data);\n\terr = send_key_to_dongle(ifp, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (sec->auth_type == NL80211_AUTHTYPE_SHARED_KEY) {\n\t\tbrcmf_dbg(CONN, \"set auth_type to shared key\\n\");\n\t\tval = WL_AUTH_SHARED_KEY;\t/* shared key */\n\t\terr = brcmf_fil_bsscfg_int_set(ifp, \"auth\", val);\n\t\tif (err)\n\t\t\tbphy_err(drvr, \"set auth failed (%d)\\n\", err);\n\t}\n\treturn err;\n}\n\nstatic\nenum nl80211_auth_type brcmf_war_auth_type(struct brcmf_if *ifp,\n\t\t\t\t\t   enum nl80211_auth_type type)\n{\n\tif (type == NL80211_AUTHTYPE_AUTOMATIC &&\n\t    brcmf_feat_is_quirk_enabled(ifp, BRCMF_FEAT_QUIRK_AUTO_AUTH)) {\n\t\tbrcmf_dbg(CONN, \"WAR: use OPEN instead of AUTO\\n\");\n\t\ttype = NL80211_AUTHTYPE_OPEN_SYSTEM;\n\t}\n\treturn type;\n}\n\nstatic void brcmf_set_join_pref(struct brcmf_if *ifp,\n\t\t\t\tstruct cfg80211_bss_selection *bss_select)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_join_pref_params join_pref_params[2];\n\tenum nl80211_band band;\n\tint err, i = 0;\n\n\tjoin_pref_params[i].len = 2;\n\tjoin_pref_params[i].rssi_gain = 0;\n\n\tif (bss_select->behaviour != NL80211_BSS_SELECT_ATTR_BAND_PREF)\n\t\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_ASSOC_PREFER, WLC_BAND_AUTO);\n\n\tswitch (bss_select->behaviour) {\n\tcase __NL80211_BSS_SELECT_ATTR_INVALID:\n\t\tbrcmf_c_set_joinpref_default(ifp);\n\t\treturn;\n\tcase NL80211_BSS_SELECT_ATTR_BAND_PREF:\n\t\tjoin_pref_params[i].type = BRCMF_JOIN_PREF_BAND;\n\t\tband = bss_select->param.band_pref;\n\t\tjoin_pref_params[i].band = nl80211_band_to_fwil(band);\n\t\ti++;\n\t\tbreak;\n\tcase NL80211_BSS_SELECT_ATTR_RSSI_ADJUST:\n\t\tjoin_pref_params[i].type = BRCMF_JOIN_PREF_RSSI_DELTA;\n\t\tband = bss_select->param.adjust.band;\n\t\tjoin_pref_params[i].band = nl80211_band_to_fwil(band);\n\t\tjoin_pref_params[i].rssi_gain = bss_select->param.adjust.delta;\n\t\ti++;\n\t\tbreak;\n\tcase NL80211_BSS_SELECT_ATTR_RSSI:\n\tdefault:\n\t\tbreak;\n\t}\n\tjoin_pref_params[i].type = BRCMF_JOIN_PREF_RSSI;\n\tjoin_pref_params[i].len = 2;\n\tjoin_pref_params[i].rssi_gain = 0;\n\tjoin_pref_params[i].band = 0;\n\terr = brcmf_fil_iovar_data_set(ifp, \"join_pref\", join_pref_params,\n\t\t\t\t       sizeof(join_pref_params));\n\tif (err)\n\t\tbphy_err(drvr, \"Set join_pref error (%d)\\n\", err);\n}\n\nstatic s32\nbrcmf_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,\n\t\t       struct cfg80211_connect_params *sme)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct ieee80211_channel *chan = sme->channel;\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_join_params join_params;\n\tsize_t join_params_size;\n\tconst struct brcmf_tlv *rsn_ie;\n\tconst struct brcmf_vs_tlv *wpa_ie;\n\tconst void *ie;\n\tu32 ie_len;\n\tstruct brcmf_ext_join_params_le *ext_join_params;\n\tu16 chanspec;\n\ts32 err = 0;\n\tu32 ssid_len;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (!sme->ssid) {\n\t\tbphy_err(drvr, \"Invalid ssid\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ifp->vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif) {\n\t\t/* A normal (non P2P) connection request setup. */\n\t\tie = NULL;\n\t\tie_len = 0;\n\t\t/* find the WPA_IE */\n\t\twpa_ie = brcmf_find_wpaie((u8 *)sme->ie, sme->ie_len);\n\t\tif (wpa_ie) {\n\t\t\tie = wpa_ie;\n\t\t\tie_len = wpa_ie->len + TLV_HDR_LEN;\n\t\t} else {\n\t\t\t/* find the RSN_IE */\n\t\t\trsn_ie = brcmf_parse_tlvs((const u8 *)sme->ie,\n\t\t\t\t\t\t  sme->ie_len,\n\t\t\t\t\t\t  WLAN_EID_RSN);\n\t\t\tif (rsn_ie) {\n\t\t\t\tie = rsn_ie;\n\t\t\t\tie_len = rsn_ie->len + TLV_HDR_LEN;\n\t\t\t}\n\t\t}\n\t\tbrcmf_fil_iovar_data_set(ifp, \"wpaie\", ie, ie_len);\n\t}\n\n\terr = brcmf_vif_set_mgmt_ie(ifp->vif, BRCMF_VNDR_IE_ASSOCREQ_FLAG,\n\t\t\t\t    sme->ie, sme->ie_len);\n\tif (err)\n\t\tbphy_err(drvr, \"Set Assoc REQ IE Failed\\n\");\n\telse\n\t\tbrcmf_dbg(TRACE, \"Applied Vndr IEs for Assoc request\\n\");\n\n\tset_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\n\tif (chan) {\n\t\tcfg->channel =\n\t\t\tieee80211_frequency_to_channel(chan->center_freq);\n\t\tchanspec = channel_to_chanspec(&cfg->d11inf, chan);\n\t\tbrcmf_dbg(CONN, \"channel=%d, center_req=%d, chanspec=0x%04x\\n\",\n\t\t\t  cfg->channel, chan->center_freq, chanspec);\n\t} else {\n\t\tcfg->channel = 0;\n\t\tchanspec = 0;\n\t}\n\n\tbrcmf_dbg(INFO, \"ie (%p), ie_len (%zd)\\n\", sme->ie, sme->ie_len);\n\n\terr = brcmf_set_wpa_version(ndev, sme);\n\tif (err) {\n\t\tbphy_err(drvr, \"wl_set_wpa_version failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\tsme->auth_type = brcmf_war_auth_type(ifp, sme->auth_type);\n\terr = brcmf_set_auth_type(ndev, sme);\n\tif (err) {\n\t\tbphy_err(drvr, \"wl_set_auth_type failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\terr = brcmf_set_wsec_mode(ndev, sme);\n\tif (err) {\n\t\tbphy_err(drvr, \"wl_set_set_cipher failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\terr = brcmf_set_key_mgmt(ndev, sme);\n\tif (err) {\n\t\tbphy_err(drvr, \"wl_set_key_mgmt failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\terr = brcmf_set_sharedkey(ndev, sme);\n\tif (err) {\n\t\tbphy_err(drvr, \"brcmf_set_sharedkey failed (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\tif (sme->crypto.psk &&\n\t    profile->use_fwsup != BRCMF_PROFILE_FWSUP_SAE) {\n\t\tif (WARN_ON(profile->use_fwsup != BRCMF_PROFILE_FWSUP_NONE)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tbrcmf_dbg(INFO, \"using PSK offload\\n\");\n\t\tprofile->use_fwsup = BRCMF_PROFILE_FWSUP_PSK;\n\t}\n\n\tif (profile->use_fwsup != BRCMF_PROFILE_FWSUP_NONE) {\n\t\t/* enable firmware supplicant for this interface */\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"sup_wpa\", 1);\n\t\tif (err < 0) {\n\t\t\tbphy_err(drvr, \"failed to enable fw supplicant\\n\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (profile->use_fwsup == BRCMF_PROFILE_FWSUP_PSK)\n\t\terr = brcmf_set_pmk(ifp, sme->crypto.psk,\n\t\t\t\t    BRCMF_WSEC_MAX_PSK_LEN);\n\telse if (profile->use_fwsup == BRCMF_PROFILE_FWSUP_SAE) {\n\t\t/* clean up user-space RSNE */\n\t\terr = brcmf_fil_iovar_data_set(ifp, \"wpaie\", NULL, 0);\n\t\tif (err) {\n\t\t\tbphy_err(drvr, \"failed to clean up user-space RSNE\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\terr = brcmf_set_sae_password(ifp, sme->crypto.sae_pwd,\n\t\t\t\t\t     sme->crypto.sae_pwd_len);\n\t\tif (!err && sme->crypto.psk)\n\t\t\terr = brcmf_set_pmk(ifp, sme->crypto.psk,\n\t\t\t\t\t    BRCMF_WSEC_MAX_PSK_LEN);\n\t}\n\tif (err)\n\t\tgoto done;\n\n\t/* Join with specific BSSID and cached SSID\n\t * If SSID is zero join based on BSSID only\n\t */\n\tjoin_params_size = offsetof(struct brcmf_ext_join_params_le, assoc_le) +\n\t\toffsetof(struct brcmf_assoc_params_le, chanspec_list);\n\tif (cfg->channel)\n\t\tjoin_params_size += sizeof(u16);\n\text_join_params = kzalloc(join_params_size, GFP_KERNEL);\n\tif (ext_join_params == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\tssid_len = min_t(u32, sme->ssid_len, IEEE80211_MAX_SSID_LEN);\n\text_join_params->ssid_le.SSID_len = cpu_to_le32(ssid_len);\n\tmemcpy(&ext_join_params->ssid_le.SSID, sme->ssid, ssid_len);\n\tif (ssid_len < IEEE80211_MAX_SSID_LEN)\n\t\tbrcmf_dbg(CONN, \"SSID \\\"%s\\\", len (%d)\\n\",\n\t\t\t  ext_join_params->ssid_le.SSID, ssid_len);\n\n\t/* Set up join scan parameters */\n\text_join_params->scan_le.scan_type = -1;\n\text_join_params->scan_le.home_time = cpu_to_le32(-1);\n\n\tif (sme->bssid)\n\t\tmemcpy(&ext_join_params->assoc_le.bssid, sme->bssid, ETH_ALEN);\n\telse\n\t\teth_broadcast_addr(ext_join_params->assoc_le.bssid);\n\n\tif (cfg->channel) {\n\t\text_join_params->assoc_le.chanspec_num = cpu_to_le32(1);\n\n\t\text_join_params->assoc_le.chanspec_list[0] =\n\t\t\tcpu_to_le16(chanspec);\n\t\t/* Increase dwell time to receive probe response or detect\n\t\t * beacon from target AP at a noisy air only during connect\n\t\t * command.\n\t\t */\n\t\text_join_params->scan_le.active_time =\n\t\t\tcpu_to_le32(BRCMF_SCAN_JOIN_ACTIVE_DWELL_TIME_MS);\n\t\text_join_params->scan_le.passive_time =\n\t\t\tcpu_to_le32(BRCMF_SCAN_JOIN_PASSIVE_DWELL_TIME_MS);\n\t\t/* To sync with presence period of VSDB GO send probe request\n\t\t * more frequently. Probe request will be stopped when it gets\n\t\t * probe response from target AP/GO.\n\t\t */\n\t\text_join_params->scan_le.nprobes =\n\t\t\tcpu_to_le32(BRCMF_SCAN_JOIN_ACTIVE_DWELL_TIME_MS /\n\t\t\t\t    BRCMF_SCAN_JOIN_PROBE_INTERVAL_MS);\n\t} else {\n\t\text_join_params->scan_le.active_time = cpu_to_le32(-1);\n\t\text_join_params->scan_le.passive_time = cpu_to_le32(-1);\n\t\text_join_params->scan_le.nprobes = cpu_to_le32(-1);\n\t}\n\n\tbrcmf_set_join_pref(ifp, &sme->bss_select);\n\n\terr  = brcmf_fil_bsscfg_data_set(ifp, \"join\", ext_join_params,\n\t\t\t\t\t join_params_size);\n\tkfree(ext_join_params);\n\tif (!err)\n\t\t/* This is it. join command worked, we are done */\n\t\tgoto done;\n\n\t/* join command failed, fallback to set ssid */\n\tmemset(&join_params, 0, sizeof(join_params));\n\tjoin_params_size = sizeof(join_params.ssid_le);\n\n\tmemcpy(&join_params.ssid_le.SSID, sme->ssid, ssid_len);\n\tjoin_params.ssid_le.SSID_len = cpu_to_le32(ssid_len);\n\n\tif (sme->bssid)\n\t\tmemcpy(join_params.params_le.bssid, sme->bssid, ETH_ALEN);\n\telse\n\t\teth_broadcast_addr(join_params.params_le.bssid);\n\n\tif (cfg->channel) {\n\t\tjoin_params.params_le.chanspec_list[0] = cpu_to_le16(chanspec);\n\t\tjoin_params.params_le.chanspec_num = cpu_to_le32(1);\n\t\tjoin_params_size += sizeof(join_params.params_le);\n\t}\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\n\t\t\t\t     &join_params, join_params_size);\n\tif (err)\n\t\tbphy_err(drvr, \"BRCMF_C_SET_SSID failed (%d)\\n\", err);\n\ndone:\n\tif (err)\n\t\tclear_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *ndev,\n\t\t       u16 reason_code)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_scb_val_le scbval;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter. Reason code = %d\\n\", reason_code);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tclear_bit(BRCMF_VIF_STATUS_CONNECTED, &ifp->vif->sme_state);\n\tclear_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\n\tcfg80211_disconnected(ndev, reason_code, NULL, 0, true, GFP_KERNEL);\n\n\tmemcpy(&scbval.ea, &profile->bssid, ETH_ALEN);\n\tscbval.val = cpu_to_le32(reason_code);\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_DISASSOC,\n\t\t\t\t     &scbval, sizeof(scbval));\n\tif (err)\n\t\tbphy_err(drvr, \"error (%d)\\n\", err);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_set_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t    enum nl80211_tx_power_setting type, s32 mbm)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\ts32 err;\n\ts32 disable;\n\tu32 qdbm = 127;\n\n\tbrcmf_dbg(TRACE, \"Enter %d %d\\n\", type, mbm);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tswitch (type) {\n\tcase NL80211_TX_POWER_AUTOMATIC:\n\t\tbreak;\n\tcase NL80211_TX_POWER_LIMITED:\n\tcase NL80211_TX_POWER_FIXED:\n\t\tif (mbm < 0) {\n\t\t\tbphy_err(drvr, \"TX_POWER_FIXED - dbm is negative\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tqdbm =  MBM_TO_DBM(4 * mbm);\n\t\tif (qdbm > 127)\n\t\t\tqdbm = 127;\n\t\tqdbm |= WL_TXPWR_OVERRIDE;\n\t\tbreak;\n\tdefault:\n\t\tbphy_err(drvr, \"Unsupported type %d\\n\", type);\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\t/* Make sure radio is off or on as far as software is concerned */\n\tdisable = WL_RADIO_SW_DISABLE << 16;\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_RADIO, disable);\n\tif (err)\n\t\tbphy_err(drvr, \"WLC_SET_RADIO error (%d)\\n\", err);\n\n\terr = brcmf_fil_iovar_int_set(ifp, \"qtxpower\", qdbm);\n\tif (err)\n\t\tbphy_err(drvr, \"qtxpower error (%d)\\n\", err);\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit %d (qdbm)\\n\", qdbm & ~WL_TXPWR_OVERRIDE);\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_get_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t    s32 *dbm)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_cfg80211_vif *vif = wdev_to_vif(wdev);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\ts32 qdbm = 0;\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(vif))\n\t\treturn -EIO;\n\n\terr = brcmf_fil_iovar_int_get(vif->ifp, \"qtxpower\", &qdbm);\n\tif (err) {\n\t\tbphy_err(drvr, \"error (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\t*dbm = (qdbm & ~WL_TXPWR_OVERRIDE) / 4;\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit (0x%x %d)\\n\", qdbm, *dbm);\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_config_default_key(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t\t  u8 key_idx, bool unicast, bool multicast)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tu32 index;\n\tu32 wsec;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tbrcmf_dbg(CONN, \"key index (%d)\\n\", key_idx);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\terr = brcmf_fil_bsscfg_int_get(ifp, \"wsec\", &wsec);\n\tif (err) {\n\t\tbphy_err(drvr, \"WLC_GET_WSEC error (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\n\tif (wsec & WEP_ENABLED) {\n\t\t/* Just select a new current key */\n\t\tindex = key_idx;\n\t\terr = brcmf_fil_cmd_int_set(ifp,\n\t\t\t\t\t    BRCMF_C_SET_KEY_PRIMARY, index);\n\t\tif (err)\n\t\t\tbphy_err(drvr, \"error (%d)\\n\", err);\n\t}\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_del_key(struct wiphy *wiphy, struct net_device *ndev,\n\t\t       u8 key_idx, bool pairwise, const u8 *mac_addr)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_wsec_key *key;\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tbrcmf_dbg(CONN, \"key index (%d)\\n\", key_idx);\n\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (key_idx >= BRCMF_MAX_DEFAULT_KEYS) {\n\t\t/* we ignore this key index in this case */\n\t\treturn -EINVAL;\n\t}\n\n\tkey = &ifp->vif->profile.key[key_idx];\n\n\tif (key->algo == CRYPTO_ALGO_OFF) {\n\t\tbrcmf_dbg(CONN, \"Ignore clearing of (never configured) key\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(key, 0, sizeof(*key));\n\tkey->index = (u32)key_idx;\n\tkey->flags = BRCMF_PRIMARY_KEY;\n\n\t/* Clear the key/index */\n\terr = send_key_to_dongle(ifp, key);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_add_key(struct wiphy *wiphy, struct net_device *ndev,\n\t\t       u8 key_idx, bool pairwise, const u8 *mac_addr,\n\t\t       struct key_params *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_wsec_key *key;\n\ts32 val;\n\ts32 wsec;\n\ts32 err;\n\tu8 keybuf[8];\n\tbool ext_key;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tbrcmf_dbg(CONN, \"key index (%d)\\n\", key_idx);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (key_idx >= BRCMF_MAX_DEFAULT_KEYS) {\n\t\t/* we ignore this key index in this case */\n\t\tbphy_err(drvr, \"invalid key index (%d)\\n\", key_idx);\n\t\treturn -EINVAL;\n\t}\n\n\tif (params->key_len == 0)\n\t\treturn brcmf_cfg80211_del_key(wiphy, ndev, key_idx, pairwise,\n\t\t\t\t\t      mac_addr);\n\n\tif (params->key_len > sizeof(key->data)) {\n\t\tbphy_err(drvr, \"Too long key length (%u)\\n\", params->key_len);\n\t\treturn -EINVAL;\n\t}\n\n\text_key = false;\n\tif (mac_addr && (params->cipher != WLAN_CIPHER_SUITE_WEP40) &&\n\t    (params->cipher != WLAN_CIPHER_SUITE_WEP104)) {\n\t\tbrcmf_dbg(TRACE, \"Ext key, mac %pM\", mac_addr);\n\t\text_key = true;\n\t}\n\n\tkey = &ifp->vif->profile.key[key_idx];\n\tmemset(key, 0, sizeof(*key));\n\tif ((ext_key) && (!is_multicast_ether_addr(mac_addr)))\n\t\tmemcpy((char *)&key->ea, (void *)mac_addr, ETH_ALEN);\n\tkey->len = params->key_len;\n\tkey->index = key_idx;\n\tmemcpy(key->data, params->key, key->len);\n\tif (!ext_key)\n\t\tkey->flags = BRCMF_PRIMARY_KEY;\n\n\tif (params->seq && params->seq_len == 6) {\n\t\t/* rx iv */\n\t\tu8 *ivptr;\n\n\t\tivptr = (u8 *)params->seq;\n\t\tkey->rxiv.hi = (ivptr[5] << 24) | (ivptr[4] << 16) |\n\t\t\t(ivptr[3] << 8) | ivptr[2];\n\t\tkey->rxiv.lo = (ivptr[1] << 8) | ivptr[0];\n\t\tkey->iv_initialized = true;\n\t}\n\n\tswitch (params->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tkey->algo = CRYPTO_ALGO_WEP1;\n\t\tval = WEP_ENABLED;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_WEP40\\n\");\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tkey->algo = CRYPTO_ALGO_WEP128;\n\t\tval = WEP_ENABLED;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_WEP104\\n\");\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tif (!brcmf_is_apmode(ifp->vif)) {\n\t\t\tbrcmf_dbg(CONN, \"Swapping RX/TX MIC key\\n\");\n\t\t\tmemcpy(keybuf, &key->data[24], sizeof(keybuf));\n\t\t\tmemcpy(&key->data[24], &key->data[16], sizeof(keybuf));\n\t\t\tmemcpy(&key->data[16], keybuf, sizeof(keybuf));\n\t\t}\n\t\tkey->algo = CRYPTO_ALGO_TKIP;\n\t\tval = TKIP_ENABLED;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_TKIP\\n\");\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tkey->algo = CRYPTO_ALGO_AES_CCM;\n\t\tval = AES_ENABLED;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_AES_CMAC\\n\");\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tkey->algo = CRYPTO_ALGO_AES_CCM;\n\t\tval = AES_ENABLED;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_CCMP\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbphy_err(drvr, \"Invalid cipher (0x%x)\\n\", params->cipher);\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\terr = send_key_to_dongle(ifp, key);\n\tif (ext_key || err)\n\t\tgoto done;\n\n\terr = brcmf_fil_bsscfg_int_get(ifp, \"wsec\", &wsec);\n\tif (err) {\n\t\tbphy_err(drvr, \"get wsec error (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\twsec |= val;\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wsec\", wsec);\n\tif (err) {\n\t\tbphy_err(drvr, \"set wsec error (%d)\\n\", err);\n\t\tgoto done;\n\t}\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_get_key(struct wiphy *wiphy, struct net_device *ndev, u8 key_idx,\n\t\t       bool pairwise, const u8 *mac_addr, void *cookie,\n\t\t       void (*callback)(void *cookie,\n\t\t\t\t\tstruct key_params *params))\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct key_params params;\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_cfg80211_security *sec;\n\ts32 wsec;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tbrcmf_dbg(CONN, \"key index (%d)\\n\", key_idx);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tmemset(&params, 0, sizeof(params));\n\n\terr = brcmf_fil_bsscfg_int_get(ifp, \"wsec\", &wsec);\n\tif (err) {\n\t\tbphy_err(drvr, \"WLC_GET_WSEC error (%d)\\n\", err);\n\t\t/* Ignore this error, may happen during DISASSOC */\n\t\terr = -EAGAIN;\n\t\tgoto done;\n\t}\n\tif (wsec & WEP_ENABLED) {\n\t\tsec = &profile->sec;\n\t\tif (sec->cipher_pairwise & WLAN_CIPHER_SUITE_WEP40) {\n\t\t\tparams.cipher = WLAN_CIPHER_SUITE_WEP40;\n\t\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_WEP40\\n\");\n\t\t} else if (sec->cipher_pairwise & WLAN_CIPHER_SUITE_WEP104) {\n\t\t\tparams.cipher = WLAN_CIPHER_SUITE_WEP104;\n\t\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_WEP104\\n\");\n\t\t}\n\t} else if (wsec & TKIP_ENABLED) {\n\t\tparams.cipher = WLAN_CIPHER_SUITE_TKIP;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_TKIP\\n\");\n\t} else if (wsec & AES_ENABLED) {\n\t\tparams.cipher = WLAN_CIPHER_SUITE_AES_CMAC;\n\t\tbrcmf_dbg(CONN, \"WLAN_CIPHER_SUITE_AES_CMAC\\n\");\n\t} else  {\n\t\tbphy_err(drvr, \"Invalid algo (0x%x)\\n\", wsec);\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tcallback(cookie, &params);\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_config_default_mgmt_key(struct wiphy *wiphy,\n\t\t\t\t       struct net_device *ndev, u8 key_idx)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tbrcmf_dbg(TRACE, \"Enter key_idx %d\\n\", key_idx);\n\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP))\n\t\treturn 0;\n\n\tbrcmf_dbg(INFO, \"Not supported\\n\");\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void\nbrcmf_cfg80211_reconfigure_wep(struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts32 err;\n\tu8 key_idx;\n\tstruct brcmf_wsec_key *key;\n\ts32 wsec;\n\n\tfor (key_idx = 0; key_idx < BRCMF_MAX_DEFAULT_KEYS; key_idx++) {\n\t\tkey = &ifp->vif->profile.key[key_idx];\n\t\tif ((key->algo == CRYPTO_ALGO_WEP1) ||\n\t\t    (key->algo == CRYPTO_ALGO_WEP128))\n\t\t\tbreak;\n\t}\n\tif (key_idx == BRCMF_MAX_DEFAULT_KEYS)\n\t\treturn;\n\n\terr = send_key_to_dongle(ifp, key);\n\tif (err) {\n\t\tbphy_err(drvr, \"Setting WEP key failed (%d)\\n\", err);\n\t\treturn;\n\t}\n\terr = brcmf_fil_bsscfg_int_get(ifp, \"wsec\", &wsec);\n\tif (err) {\n\t\tbphy_err(drvr, \"get wsec error (%d)\\n\", err);\n\t\treturn;\n\t}\n\twsec |= WEP_ENABLED;\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wsec\", wsec);\n\tif (err)\n\t\tbphy_err(drvr, \"set wsec error (%d)\\n\", err);\n}\n\nstatic void brcmf_convert_sta_flags(u32 fw_sta_flags, struct station_info *si)\n{\n\tstruct nl80211_sta_flag_update *sfu;\n\n\tbrcmf_dbg(TRACE, \"flags %08x\\n\", fw_sta_flags);\n\tsi->filled |= BIT_ULL(NL80211_STA_INFO_STA_FLAGS);\n\tsfu = &si->sta_flags;\n\tsfu->mask = BIT(NL80211_STA_FLAG_WME) |\n\t\t    BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t    BIT(NL80211_STA_FLAG_ASSOCIATED) |\n\t\t    BIT(NL80211_STA_FLAG_AUTHORIZED);\n\tif (fw_sta_flags & BRCMF_STA_WME)\n\t\tsfu->set |= BIT(NL80211_STA_FLAG_WME);\n\tif (fw_sta_flags & BRCMF_STA_AUTHE)\n\t\tsfu->set |= BIT(NL80211_STA_FLAG_AUTHENTICATED);\n\tif (fw_sta_flags & BRCMF_STA_ASSOC)\n\t\tsfu->set |= BIT(NL80211_STA_FLAG_ASSOCIATED);\n\tif (fw_sta_flags & BRCMF_STA_AUTHO)\n\t\tsfu->set |= BIT(NL80211_STA_FLAG_AUTHORIZED);\n}\n\nstatic void brcmf_fill_bss_param(struct brcmf_if *ifp, struct station_info *si)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct {\n\t\t__le32 len;\n\t\tstruct brcmf_bss_info_le bss_le;\n\t} *buf;\n\tu16 capability;\n\tint err;\n\n\tbuf = kzalloc(WL_BSS_INFO_MAX, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tbuf->len = cpu_to_le32(WL_BSS_INFO_MAX);\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSS_INFO, buf,\n\t\t\t\t     WL_BSS_INFO_MAX);\n\tif (err) {\n\t\tbphy_err(drvr, \"Failed to get bss info (%d)\\n\", err);\n\t\tgoto out_kfree;\n\t}\n\tsi->filled |= BIT_ULL(NL80211_STA_INFO_BSS_PARAM);\n\tsi->bss_param.beacon_interval = le16_to_cpu(buf->bss_le.beacon_period);\n\tsi->bss_param.dtim_period = buf->bss_le.dtim_period;\n\tcapability = le16_to_cpu(buf->bss_le.capability);\n\tif (capability & IEEE80211_HT_STBC_PARAM_DUAL_CTS_PROT)\n\t\tsi->bss_param.flags |= BSS_PARAM_FLAGS_CTS_PROT;\n\tif (capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\n\t\tsi->bss_param.flags |= BSS_PARAM_FLAGS_SHORT_PREAMBLE;\n\tif (capability & WLAN_CAPABILITY_SHORT_SLOT_TIME)\n\t\tsi->bss_param.flags |= BSS_PARAM_FLAGS_SHORT_SLOT_TIME;\n\nout_kfree:\n\tkfree(buf);\n}\n\nstatic s32\nbrcmf_cfg80211_get_station_ibss(struct brcmf_if *ifp,\n\t\t\t\tstruct station_info *sinfo)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_scb_val_le scbval;\n\tstruct brcmf_pktcnt_le pktcnt;\n\ts32 err;\n\tu32 rate;\n\tu32 rssi;\n\n\t/* Get the current tx rate */\n\terr = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_RATE, &rate);\n\tif (err < 0) {\n\t\tbphy_err(drvr, \"BRCMF_C_GET_RATE error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\tsinfo->txrate.legacy = rate * 5;\n\n\tmemset(&scbval, 0, sizeof(scbval));\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_RSSI, &scbval,\n\t\t\t\t     sizeof(scbval));\n\tif (err) {\n\t\tbphy_err(drvr, \"BRCMF_C_GET_RSSI error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\trssi = le32_to_cpu(scbval.val);\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);\n\tsinfo->signal = rssi;\n\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_GET_PKTCNTS, &pktcnt,\n\t\t\t\t     sizeof(pktcnt));\n\tif (err) {\n\t\tbphy_err(drvr, \"BRCMF_C_GET_GET_PKTCNTS error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_PACKETS) |\n\t\t\t BIT_ULL(NL80211_STA_INFO_RX_DROP_MISC) |\n\t\t\t BIT_ULL(NL80211_STA_INFO_TX_PACKETS) |\n\t\t\t BIT_ULL(NL80211_STA_INFO_TX_FAILED);\n\tsinfo->rx_packets = le32_to_cpu(pktcnt.rx_good_pkt);\n\tsinfo->rx_dropped_misc = le32_to_cpu(pktcnt.rx_bad_pkt);\n\tsinfo->tx_packets = le32_to_cpu(pktcnt.tx_good_pkt);\n\tsinfo->tx_failed  = le32_to_cpu(pktcnt.tx_bad_pkt);\n\n\treturn 0;\n}\n\nstatic s32\nbrcmf_cfg80211_get_station(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t   const u8 *mac, struct station_info *sinfo)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_scb_val_le scb_val;\n\ts32 err = 0;\n\tstruct brcmf_sta_info_le sta_info_le;\n\tu32 sta_flags;\n\tu32 is_tdls_peer;\n\ts32 total_rssi;\n\ts32 count_rssi;\n\tint rssi;\n\tu32 i;\n\n\tbrcmf_dbg(TRACE, \"Enter, MAC %pM\\n\", mac);\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tif (brcmf_is_ibssmode(ifp->vif))\n\t\treturn brcmf_cfg80211_get_station_ibss(ifp, sinfo);\n\n\tmemset(&sta_info_le, 0, sizeof(sta_info_le));\n\tmemcpy(&sta_info_le, mac, ETH_ALEN);\n\terr = brcmf_fil_iovar_data_get(ifp, \"tdls_sta_info\",\n\t\t\t\t       &sta_info_le,\n\t\t\t\t       sizeof(sta_info_le));\n\tis_tdls_peer = !err;\n\tif (err) {\n\t\terr = brcmf_fil_iovar_data_get(ifp, \"sta_info\",\n\t\t\t\t\t       &sta_info_le,\n\t\t\t\t\t       sizeof(sta_info_le));\n\t\tif (err < 0) {\n\t\t\tbphy_err(drvr, \"GET STA INFO failed, %d\\n\", err);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tbrcmf_dbg(TRACE, \"version %d\\n\", le16_to_cpu(sta_info_le.ver));\n\tsinfo->filled = BIT_ULL(NL80211_STA_INFO_INACTIVE_TIME);\n\tsinfo->inactive_time = le32_to_cpu(sta_info_le.idle) * 1000;\n\tsta_flags = le32_to_cpu(sta_info_le.flags);\n\tbrcmf_convert_sta_flags(sta_flags, sinfo);\n\tsinfo->sta_flags.mask |= BIT(NL80211_STA_FLAG_TDLS_PEER);\n\tif (is_tdls_peer)\n\t\tsinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_TDLS_PEER);\n\telse\n\t\tsinfo->sta_flags.set &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\tif (sta_flags & BRCMF_STA_ASSOC) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_CONNECTED_TIME);\n\t\tsinfo->connected_time = le32_to_cpu(sta_info_le.in);\n\t\tbrcmf_fill_bss_param(ifp, sinfo);\n\t}\n\tif (sta_flags & BRCMF_STA_SCBSTATS) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);\n\t\tsinfo->tx_failed = le32_to_cpu(sta_info_le.tx_failures);\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_PACKETS);\n\t\tsinfo->tx_packets = le32_to_cpu(sta_info_le.tx_pkts);\n\t\tsinfo->tx_packets += le32_to_cpu(sta_info_le.tx_mcast_pkts);\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_PACKETS);\n\t\tsinfo->rx_packets = le32_to_cpu(sta_info_le.rx_ucast_pkts);\n\t\tsinfo->rx_packets += le32_to_cpu(sta_info_le.rx_mcast_pkts);\n\t\tif (sinfo->tx_packets) {\n\t\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\t\t\tsinfo->txrate.legacy =\n\t\t\t\tle32_to_cpu(sta_info_le.tx_rate) / 100;\n\t\t}\n\t\tif (sinfo->rx_packets) {\n\t\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BITRATE);\n\t\t\tsinfo->rxrate.legacy =\n\t\t\t\tle32_to_cpu(sta_info_le.rx_rate) / 100;\n\t\t}\n\t\tif (le16_to_cpu(sta_info_le.ver) >= 4) {\n\t\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES);\n\t\t\tsinfo->tx_bytes = le64_to_cpu(sta_info_le.tx_tot_bytes);\n\t\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BYTES);\n\t\t\tsinfo->rx_bytes = le64_to_cpu(sta_info_le.rx_tot_bytes);\n\t\t}\n\t\ttotal_rssi = 0;\n\t\tcount_rssi = 0;\n\t\tfor (i = 0; i < BRCMF_ANT_MAX; i++) {\n\t\t\tif (sta_info_le.rssi[i]) {\n\t\t\t\tsinfo->chain_signal_avg[count_rssi] =\n\t\t\t\t\tsta_info_le.rssi[i];\n\t\t\t\tsinfo->chain_signal[count_rssi] =\n\t\t\t\t\tsta_info_le.rssi[i];\n\t\t\t\ttotal_rssi += sta_info_le.rssi[i];\n\t\t\t\tcount_rssi++;\n\t\t\t}\n\t\t}\n\t\tif (count_rssi) {\n\t\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL);\n\t\t\tsinfo->chains = count_rssi;\n\n\t\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);\n\t\t\ttotal_rssi /= count_rssi;\n\t\t\tsinfo->signal = total_rssi;\n\t\t} else if (test_bit(BRCMF_VIF_STATUS_CONNECTED,\n\t\t\t&ifp->vif->sme_state)) {\n\t\t\tmemset(&scb_val, 0, sizeof(scb_val));\n\t\t\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_RSSI,\n\t\t\t\t\t\t     &scb_val, sizeof(scb_val));\n\t\t\tif (err) {\n\t\t\t\tbphy_err(drvr, \"Could not get rssi (%d)\\n\",\n\t\t\t\t\t err);\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\trssi = le32_to_cpu(scb_val.val);\n\t\t\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);\n\t\t\t\tsinfo->signal = rssi;\n\t\t\t\tbrcmf_dbg(CONN, \"RSSI %d dBm\\n\", rssi);\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic int\nbrcmf_cfg80211_dump_station(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t    int idx, u8 *mac, struct station_info *sinfo)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter, idx %d\\n\", idx);\n\n\tif (idx == 0) {\n\t\tcfg->assoclist.count = cpu_to_le32(BRCMF_MAX_ASSOCLIST);\n\t\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_ASSOCLIST,\n\t\t\t\t\t     &cfg->assoclist,\n\t\t\t\t\t     sizeof(cfg->assoclist));\n\t\tif (err) {\n\t\t\tbphy_err(drvr, \"BRCMF_C_GET_ASSOCLIST unsupported, err=%d\\n\",\n\t\t\t\t err);\n\t\t\tcfg->assoclist.count = 0;\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\tif (idx < le32_to_cpu(cfg->assoclist.count)) {\n\t\tmemcpy(mac, cfg->assoclist.mac[idx], ETH_ALEN);\n\t\treturn brcmf_cfg80211_get_station(wiphy, ndev, mac, sinfo);\n\t}\n\treturn -ENOENT;\n}\n\nstatic s32\nbrcmf_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t   bool enabled, s32 timeout)\n{\n\ts32 pm;\n\ts32 err = 0;\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\t/*\n\t * Powersave enable/disable request is coming from the\n\t * cfg80211 even before the interface is up. In that\n\t * scenario, driver will be storing the power save\n\t * preference in cfg struct to apply this to\n\t * FW later while initializing the dongle\n\t */\n\tcfg->pwr_save = enabled;\n\tif (!check_vif_up(ifp->vif)) {\n\n\t\tbrcmf_dbg(INFO, \"Device is not ready, storing the value in cfg_info struct\\n\");\n\t\tgoto done;\n\t}\n\n\tpm = enabled ? PM_FAST : PM_OFF;\n\t/* Do not enable the power save after assoc if it is a p2p interface */\n\tif (ifp->vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT) {\n\t\tbrcmf_dbg(INFO, \"Do not enable power save for P2P clients\\n\");\n\t\tpm = PM_OFF;\n\t}\n\tbrcmf_dbg(INFO, \"power save %s\\n\", (pm ? \"enabled\" : \"disabled\"));\n\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM, pm);\n\tif (err) {\n\t\tif (err == -ENODEV)\n\t\t\tbphy_err(drvr, \"net_device is not ready yet\\n\");\n\t\telse\n\t\t\tbphy_err(drvr, \"error (%d)\\n\", err);\n\t}\n\n\terr = brcmf_fil_iovar_int_set(ifp, \"pm2_sleep_ret\",\n\t\t\t\tmin_t(u32, timeout, BRCMF_PS_MAX_TIMEOUT_MS));\n\tif (err)\n\t\tbphy_err(drvr, \"Unable to set pm timeout, (%d)\\n\", err);\n\ndone:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32 brcmf_inform_single_bss(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t   struct brcmf_bss_info_le *bi)\n{\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct cfg80211_bss *bss;\n\tenum nl80211_band band;\n\tstruct brcmu_chan ch;\n\tu16 channel;\n\tu32 freq;\n\tu16 notify_capability;\n\tu16 notify_interval;\n\tu8 *notify_ie;\n\tsize_t notify_ielen;\n\tstruct cfg80211_inform_bss bss_data = {};\n\n\tif (le32_to_cpu(bi->length) > WL_BSS_INFO_MAX) {\n\t\tbphy_err(drvr, \"Bss info is larger than buffer. Discarding\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!bi->ctl_ch) {\n\t\tch.chspec = le16_to_cpu(bi->chanspec);\n\t\tcfg->d11inf.decchspec(&ch);\n\t\tbi->ctl_ch = ch.control_ch_num;\n\t}\n\tchannel = bi->ctl_ch;\n\n\tif (channel <= CH_MAX_2G_CHANNEL)\n\t\tband = NL80211_BAND_2GHZ;\n\telse\n\t\tband = NL80211_BAND_5GHZ;\n\n\tfreq = ieee80211_channel_to_frequency(channel, band);\n\tbss_data.chan = ieee80211_get_channel(wiphy, freq);\n\tbss_data.scan_width = NL80211_BSS_CHAN_WIDTH_20;\n\tbss_data.boottime_ns = ktime_to_ns(ktime_get_boottime());\n\n\tnotify_capability = le16_to_cpu(bi->capability);\n\tnotify_interval = le16_to_cpu(bi->beacon_period);\n\tnotify_ie = (u8 *)bi + le16_to_cpu(bi->ie_offset);\n\tnotify_ielen = le32_to_cpu(bi->ie_length);\n\tbss_data.signal = (s16)le16_to_cpu(bi->RSSI) * 100;\n\n\tbrcmf_dbg(CONN, \"bssid: %pM\\n\", bi->BSSID);\n\tbrcmf_dbg(CONN, \"Channel: %d(%d)\\n\", channel, freq);\n\tbrcmf_dbg(CONN, \"Capability: %X\\n\", notify_capability);\n\tbrcmf_dbg(CONN, \"Beacon interval: %d\\n\", notify_interval);\n\tbrcmf_dbg(CONN, \"Signal: %d\\n\", bss_data.signal);\n\n\tbss = cfg80211_inform_bss_data(wiphy, &bss_data,\n\t\t\t\t       CFG80211_BSS_FTYPE_UNKNOWN,\n\t\t\t\t       (const u8 *)bi->BSSID,\n\t\t\t\t       0, notify_capability,\n\t\t\t\t       notify_interval, notify_ie,\n\t\t\t\t       notify_ielen, GFP_KERNEL);\n\n\tif (!bss)\n\t\treturn -ENOMEM;\n\n\tcfg80211_put_bss(wiphy, bss);\n\n\treturn 0;\n}\n\nstatic struct brcmf_bss_info_le *\nnext_bss_le(struct brcmf_scan_results *list, struct brcmf_bss_info_le *bss)\n{\n\tif (bss == NULL)\n\t\treturn list->bss_info_le;\n\treturn (struct brcmf_bss_info_le *)((unsigned long)bss +\n\t\t\t\t\t    le32_to_cpu(bss->length));\n}\n\nstatic s32 brcmf_inform_bss(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_scan_results *bss_list;\n\tstruct brcmf_bss_info_le *bi = NULL;\t/* must be initialized */\n\ts32 err = 0;\n\tint i;\n\n\tbss_list = (struct brcmf_scan_results *)cfg->escan_info.escan_buf;\n\tif (bss_list->count != 0 &&\n\t    bss_list->version != BRCMF_BSS_INFO_VERSION) {\n\t\tbphy_err(drvr, \"Version %d != WL_BSS_INFO_VERSION\\n\",\n\t\t\t bss_list->version);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tbrcmf_dbg(SCAN, \"scanned AP count (%d)\\n\", bss_list->count);\n\tfor (i = 0; i < bss_list->count; i++) {\n\t\tbi = next_bss_le(bss_list, bi);\n\t\terr = brcmf_inform_single_bss(cfg, bi);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic s32 brcmf_inform_ibss(struct brcmf_cfg80211_info *cfg,\n\t\t\t     struct net_device *ndev, const u8 *bssid)\n{\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct ieee80211_channel *notify_channel;\n\tstruct brcmf_bss_info_le *bi = NULL;\n\tstruct ieee80211_supported_band *band;\n\tstruct cfg80211_bss *bss;\n\tstruct brcmu_chan ch;\n\tu8 *buf = NULL;\n\ts32 err = 0;\n\tu32 freq;\n\tu16 notify_capability;\n\tu16 notify_interval;\n\tu8 *notify_ie;\n\tsize_t notify_ielen;\n\ts32 notify_signal;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tbuf = kzalloc(WL_BSS_INFO_MAX, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto CleanUp;\n\t}\n\n\t*(__le32 *)buf = cpu_to_le32(WL_BSS_INFO_MAX);\n\n\terr = brcmf_fil_cmd_data_get(netdev_priv(ndev), BRCMF_C_GET_BSS_INFO,\n\t\t\t\t     buf, WL_BSS_INFO_MAX);\n\tif (err) {\n\t\tbphy_err(drvr, \"WLC_GET_BSS_INFO failed: %d\\n\", err);\n\t\tgoto CleanUp;\n\t}\n\n\tbi = (struct brcmf_bss_info_le *)(buf + 4);\n\n\tch.chspec = le16_to_cpu(bi->chanspec);\n\tcfg->d11inf.decchspec(&ch);\n\n\tif (ch.band == BRCMU_CHAN_BAND_2G)\n\t\tband = wiphy->bands[NL80211_BAND_2GHZ];\n\telse\n\t\tband = wiphy->bands[NL80211_BAND_5GHZ];\n\n\tfreq = ieee80211_channel_to_frequency(ch.control_ch_num, band->band);\n\tcfg->channel = freq;\n\tnotify_channel = ieee80211_get_channel(wiphy, freq);\n\n\tnotify_capability = le16_to_cpu(bi->capability);\n\tnotify_interval = le16_to_cpu(bi->beacon_period);\n\tnotify_ie = (u8 *)bi + le16_to_cpu(bi->ie_offset);\n\tnotify_ielen = le32_to_cpu(bi->ie_length);\n\tnotify_signal = (s16)le16_to_cpu(bi->RSSI) * 100;\n\n\tbrcmf_dbg(CONN, \"channel: %d(%d)\\n\", ch.control_ch_num, freq);\n\tbrcmf_dbg(CONN, \"capability: %X\\n\", notify_capability);\n\tbrcmf_dbg(CONN, \"beacon interval: %d\\n\", notify_interval);\n\tbrcmf_dbg(CONN, \"signal: %d\\n\", notify_signal);\n\n\tbss = cfg80211_inform_bss(wiphy, notify_channel,\n\t\t\t\t  CFG80211_BSS_FTYPE_UNKNOWN, bssid, 0,\n\t\t\t\t  notify_capability, notify_interval,\n\t\t\t\t  notify_ie, notify_ielen, notify_signal,\n\t\t\t\t  GFP_KERNEL);\n\n\tif (!bss) {\n\t\terr = -ENOMEM;\n\t\tgoto CleanUp;\n\t}\n\n\tcfg80211_put_bss(wiphy, bss);\n\nCleanUp:\n\n\tkfree(buf);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\n\treturn err;\n}\n\nstatic s32 brcmf_update_bss_info(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_bss_info_le *bi;\n\tconst struct brcmf_tlv *tim;\n\tsize_t ie_len;\n\tu8 *ie;\n\ts32 err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (brcmf_is_ibssmode(ifp->vif))\n\t\treturn err;\n\n\t*(__le32 *)cfg->extra_buf = cpu_to_le32(WL_EXTRA_BUF_MAX);\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSS_INFO,\n\t\t\t\t     cfg->extra_buf, WL_EXTRA_BUF_MAX);\n\tif (err) {\n\t\tbphy_err(drvr, \"Could not get bss info %d\\n\", err);\n\t\tgoto update_bss_info_out;\n\t}\n\n\tbi = (struct brcmf_bss_info_le *)(cfg->extra_buf + 4);\n\terr = brcmf_inform_single_bss(cfg, bi);\n\tif (err)\n\t\tgoto update_bss_info_out;\n\n\tie = ((u8 *)bi) + le16_to_cpu(bi->ie_offset);\n\tie_len = le32_to_cpu(bi->ie_length);\n\n\ttim = brcmf_parse_tlvs(ie, ie_len, WLAN_EID_TIM);\n\tif (!tim) {\n\t\t/*\n\t\t* active scan was done so we could not get dtim\n\t\t* information out of probe response.\n\t\t* so we speficially query dtim information to dongle.\n\t\t*/\n\t\tu32 var;\n\t\terr = brcmf_fil_iovar_int_get(ifp, \"dtim_assoc\", &var);\n\t\tif (err) {\n\t\t\tbphy_err(drvr, \"wl dtim_assoc failed (%d)\\n\", err);\n\t\t\tgoto update_bss_info_out;\n\t\t}\n\t}\n\nupdate_bss_info_out:\n\tbrcmf_dbg(TRACE, \"Exit\");\n\treturn err;\n}\n\nvoid brcmf_abort_scanning(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct escan_info *escan = &cfg->escan_info;\n\n\tset_bit(BRCMF_SCAN_STATUS_ABORT, &cfg->scan_status);\n\tif (cfg->int_escan_map || cfg->scan_request) {\n\t\tescan->escan_state = WL_ESCAN_STATE_IDLE;\n\t\tbrcmf_notify_escan_complete(cfg, escan->ifp, true, true);\n\t}\n\tclear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\n\tclear_bit(BRCMF_SCAN_STATUS_ABORT, &cfg->scan_status);\n}\n\nstatic void brcmf_cfg80211_escan_timeout_worker(struct work_struct *work)\n{\n\tstruct brcmf_cfg80211_info *cfg =\n\t\t\tcontainer_of(work, struct brcmf_cfg80211_info,\n\t\t\t\t     escan_timeout_work);\n\n\tbrcmf_inform_bss(cfg);\n\tbrcmf_notify_escan_complete(cfg, cfg->escan_info.ifp, true, true);\n}\n\nstatic void brcmf_escan_timeout(struct timer_list *t)\n{\n\tstruct brcmf_cfg80211_info *cfg =\n\t\t\tfrom_timer(cfg, t, escan_timeout);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\n\tif (cfg->int_escan_map || cfg->scan_request) {\n\t\tbphy_err(drvr, \"timer expired\\n\");\n\t\tschedule_work(&cfg->escan_timeout_work);\n\t}\n}\n\nstatic s32\nbrcmf_compare_update_same_bss(struct brcmf_cfg80211_info *cfg,\n\t\t\t      struct brcmf_bss_info_le *bss,\n\t\t\t      struct brcmf_bss_info_le *bss_info_le)\n{\n\tstruct brcmu_chan ch_bss, ch_bss_info_le;\n\n\tch_bss.chspec = le16_to_cpu(bss->chanspec);\n\tcfg->d11inf.decchspec(&ch_bss);\n\tch_bss_info_le.chspec = le16_to_cpu(bss_info_le->chanspec);\n\tcfg->d11inf.decchspec(&ch_bss_info_le);\n\n\tif (!memcmp(&bss_info_le->BSSID, &bss->BSSID, ETH_ALEN) &&\n\t\tch_bss.band == ch_bss_info_le.band &&\n\t\tbss_info_le->SSID_len == bss->SSID_len &&\n\t\t!memcmp(bss_info_le->SSID, bss->SSID, bss_info_le->SSID_len)) {\n\t\tif ((bss->flags & BRCMF_BSS_RSSI_ON_CHANNEL) ==\n\t\t\t(bss_info_le->flags & BRCMF_BSS_RSSI_ON_CHANNEL)) {\n\t\t\ts16 bss_rssi = le16_to_cpu(bss->RSSI);\n\t\t\ts16 bss_info_rssi = le16_to_cpu(bss_info_le->RSSI);\n\n\t\t\t/* preserve max RSSI if the measurements are\n\t\t\t* both on-channel or both off-channel\n\t\t\t*/\n\t\t\tif (bss_info_rssi > bss_rssi)\n\t\t\t\tbss->RSSI = bss_info_le->RSSI;\n\t\t} else if ((bss->flags & BRCMF_BSS_RSSI_ON_CHANNEL) &&\n\t\t\t(bss_info_le->flags & BRCMF_BSS_RSSI_ON_CHANNEL) == 0) {\n\t\t\t/* preserve the on-channel rssi measurement\n\t\t\t* if the new measurement is off channel\n\t\t\t*/\n\t\t\tbss->RSSI = bss_info_le->RSSI;\n\t\t\tbss->flags |= BRCMF_BSS_RSSI_ON_CHANNEL;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic s32\nbrcmf_cfg80211_escan_handler(struct brcmf_if *ifp,\n\t\t\t     const struct brcmf_event_msg *e, void *data)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_cfg80211_info *cfg = drvr->config;\n\ts32 status;\n\tstruct brcmf_escan_result_le *escan_result_le;\n\tu32 escan_buflen;\n\tstruct brcmf_bss_info_le *bss_info_le;\n\tstruct brcmf_bss_info_le *bss = NULL;\n\tu32 bi_length;\n\tstruct brcmf_scan_results *list;\n\tu32 i;\n\tbool aborted;\n\n\tstatus = e->status;\n\n\tif (status == BRCMF_E_STATUS_ABORT)\n\t\tgoto exit;\n\n\tif (!test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status)) {\n\t\tbphy_err(drvr, \"scan not ready, bsscfgidx=%d\\n\",\n\t\t\t ifp->bsscfgidx);\n\t\treturn -EPERM;\n\t}\n\n\tif (status == BRCMF_E_STATUS_PARTIAL) {\n\t\tbrcmf_dbg(SCAN, \"ESCAN Partial result\\n\");\n\t\tif (e->datalen < sizeof(*escan_result_le)) {\n\t\t\tbphy_err(drvr, \"invalid event data length\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tescan_result_le = (struct brcmf_escan_result_le *) data;\n\t\tif (!escan_result_le) {\n\t\t\tbphy_err(drvr, \"Invalid escan result (NULL pointer)\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tescan_buflen = le32_to_cpu(escan_result_le->buflen);\n\t\tif (escan_buflen > BRCMF_ESCAN_BUF_SIZE ||\n\t\t    escan_buflen > e->datalen ||\n\t\t    escan_buflen < sizeof(*escan_result_le)) {\n\t\t\tbphy_err(drvr, \"Invalid escan buffer length: %d\\n\",\n\t\t\t\t escan_buflen);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (le16_to_cpu(escan_result_le->bss_count) != 1) {\n\t\t\tbphy_err(drvr, \"Invalid bss_count %d: ignoring\\n\",\n\t\t\t\t escan_result_le->bss_count);\n\t\t\tgoto exit;\n\t\t}\n\t\tbss_info_le = &escan_result_le->bss_info_le;\n\n\t\tif (brcmf_p2p_scan_finding_common_channel(cfg, bss_info_le))\n\t\t\tgoto exit;\n\n\t\tif (!cfg->int_escan_map && !cfg->scan_request) {\n\t\t\tbrcmf_dbg(SCAN, \"result without cfg80211 request\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tbi_length = le32_to_cpu(bss_info_le->length);\n\t\tif (bi_length != escan_buflen -\tWL_ESCAN_RESULTS_FIXED_SIZE) {\n\t\t\tbphy_err(drvr, \"Ignoring invalid bss_info length: %d\\n\",\n\t\t\t\t bi_length);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (!(cfg_to_wiphy(cfg)->interface_modes &\n\t\t\t\t\tBIT(NL80211_IFTYPE_ADHOC))) {\n\t\t\tif (le16_to_cpu(bss_info_le->capability) &\n\t\t\t\t\t\tWLAN_CAPABILITY_IBSS) {\n\t\t\t\tbphy_err(drvr, \"Ignoring IBSS result\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tlist = (struct brcmf_scan_results *)\n\t\t\t\tcfg->escan_info.escan_buf;\n\t\tif (bi_length > BRCMF_ESCAN_BUF_SIZE - list->buflen) {\n\t\t\tbphy_err(drvr, \"Buffer is too small: ignoring\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tfor (i = 0; i < list->count; i++) {\n\t\t\tbss = bss ? (struct brcmf_bss_info_le *)\n\t\t\t\t((unsigned char *)bss +\n\t\t\t\tle32_to_cpu(bss->length)) : list->bss_info_le;\n\t\t\tif (brcmf_compare_update_same_bss(cfg, bss,\n\t\t\t\t\t\t\t  bss_info_le))\n\t\t\t\tgoto exit;\n\t\t}\n\t\tmemcpy(&cfg->escan_info.escan_buf[list->buflen], bss_info_le,\n\t\t       bi_length);\n\t\tlist->version = le32_to_cpu(bss_info_le->version);\n\t\tlist->buflen += bi_length;\n\t\tlist->count++;\n\t} else {\n\t\tcfg->escan_info.escan_state = WL_ESCAN_STATE_IDLE;\n\t\tif (brcmf_p2p_scan_finding_common_channel(cfg, NULL))\n\t\t\tgoto exit;\n\t\tif (cfg->int_escan_map || cfg->scan_request) {\n\t\t\tbrcmf_inform_bss(cfg);\n\t\t\taborted = status != BRCMF_E_STATUS_SUCCESS;\n\t\t\tbrcmf_notify_escan_complete(cfg, ifp, aborted, false);\n\t\t} else\n\t\t\tbrcmf_dbg(SCAN, \"Ignored scan complete result 0x%x\\n\",\n\t\t\t\t  status);\n\t}\nexit:\n\treturn 0;\n}\n\nstatic void brcmf_init_escan(struct brcmf_cfg80211_info *cfg)\n{\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ESCAN_RESULT,\n\t\t\t    brcmf_cfg80211_escan_handler);\n\tcfg->escan_info.escan_state = WL_ESCAN_STATE_IDLE;\n\t/* Init scan_timeout timer */\n\ttimer_setup(&cfg->escan_timeout, brcmf_escan_timeout, 0);\n\tINIT_WORK(&cfg->escan_timeout_work,\n\t\t  brcmf_cfg80211_escan_timeout_worker);\n}\n\nstatic struct cfg80211_scan_request *\nbrcmf_alloc_internal_escan_request(struct wiphy *wiphy, u32 n_netinfo) {\n\tstruct cfg80211_scan_request *req;\n\tsize_t req_size;\n\n\treq_size = sizeof(*req) +\n\t\t   n_netinfo * sizeof(req->channels[0]) +\n\t\t   n_netinfo * sizeof(*req->ssids);\n\n\treq = kzalloc(req_size, GFP_KERNEL);\n\tif (req) {\n\t\treq->wiphy = wiphy;\n\t\treq->ssids = (void *)(&req->channels[0]) +\n\t\t\t     n_netinfo * sizeof(req->channels[0]);\n\t}\n\treturn req;\n}\n\nstatic int brcmf_internal_escan_add_info(struct cfg80211_scan_request *req,\n\t\t\t\t\t u8 *ssid, u8 ssid_len, u8 channel)\n{\n\tstruct ieee80211_channel *chan;\n\tenum nl80211_band band;\n\tint freq, i;\n\n\tif (channel <= CH_MAX_2G_CHANNEL)\n\t\tband = NL80211_BAND_2GHZ;\n\telse\n\t\tband = NL80211_BAND_5GHZ;\n\n\tfreq = ieee80211_channel_to_frequency(channel, band);\n\tif (!freq)\n\t\treturn -EINVAL;\n\n\tchan = ieee80211_get_channel(req->wiphy, freq);\n\tif (!chan)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < req->n_channels; i++) {\n\t\tif (req->channels[i] == chan)\n\t\t\tbreak;\n\t}\n\tif (i == req->n_channels)\n\t\treq->channels[req->n_channels++] = chan;\n\n\tfor (i = 0; i < req->n_ssids; i++) {\n\t\tif (req->ssids[i].ssid_len == ssid_len &&\n\t\t    !memcmp(req->ssids[i].ssid, ssid, ssid_len))\n\t\t\tbreak;\n\t}\n\tif (i == req->n_ssids) {\n\t\tmemcpy(req->ssids[req->n_ssids].ssid, ssid, ssid_len);\n\t\treq->ssids[req->n_ssids++].ssid_len = ssid_len;\n\t}\n\treturn 0;\n}\n\nstatic int brcmf_start_internal_escan(struct brcmf_if *ifp, u32 fwmap,\n\t\t\t\t      struct cfg80211_scan_request *request)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tint err;\n\n\tif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status)) {\n\t\tif (cfg->int_escan_map)\n\t\t\tbrcmf_dbg(SCAN, \"aborting internal scan: map=%u\\n\",\n\t\t\t\t  cfg->int_escan_map);\n\t\t/* Abort any on-going scan */\n\t\tbrcmf_abort_scanning(cfg);\n\t}\n\n\tbrcmf_dbg(SCAN, \"start internal scan: map=%u\\n\", fwmap);\n\tset_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\n\tcfg->escan_info.run = brcmf_run_escan;\n\terr = brcmf_do_escan(ifp, request);\n\tif (err) {\n\t\tclear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\n\t\treturn err;\n\t}\n\tcfg->int_escan_map = fwmap;\n\treturn 0;\n}\n\nstatic struct brcmf_pno_net_info_le *\nbrcmf_get_netinfo_array(struct brcmf_pno_scanresults_le *pfn_v1)\n{\n\tstruct brcmf_pno_scanresults_v2_le *pfn_v2;\n\tstruct brcmf_pno_net_info_le *netinfo;\n\n\tswitch (pfn_v1->version) {\n\tdefault:\n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tcase cpu_to_le32(1):\n\t\tnetinfo = (struct brcmf_pno_net_info_le *)(pfn_v1 + 1);\n\t\tbreak;\n\tcase cpu_to_le32(2):\n\t\tpfn_v2 = (struct brcmf_pno_scanresults_v2_le *)pfn_v1;\n\t\tnetinfo = (struct brcmf_pno_net_info_le *)(pfn_v2 + 1);\n\t\tbreak;\n\t}\n\n\treturn netinfo;\n}\n\n/* PFN result doesn't have all the info which are required by the supplicant\n * (For e.g IEs) Do a target Escan so that sched scan results are reported\n * via wl_inform_single_bss in the required format. Escan does require the\n * scan request in the form of cfg80211_scan_request. For timebeing, create\n * cfg80211_scan_request one out of the received PNO event.\n */\nstatic s32\nbrcmf_notify_sched_scan_results(struct brcmf_if *ifp,\n\t\t\t\tconst struct brcmf_event_msg *e, void *data)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_cfg80211_info *cfg = drvr->config;\n\tstruct brcmf_pno_net_info_le *netinfo, *netinfo_start;\n\tstruct cfg80211_scan_request *request = NULL;\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tint i, err = 0;\n\tstruct brcmf_pno_scanresults_le *pfn_result;\n\tu32 bucket_map;\n\tu32 result_count;\n\tu32 status;\n\tu32 datalen;\n\n\tbrcmf_dbg(SCAN, \"Enter\\n\");\n\n\tif (e->datalen < (sizeof(*pfn_result) + sizeof(*netinfo))) {\n\t\tbrcmf_dbg(SCAN, \"Event data to small. Ignore\\n\");\n\t\treturn 0;\n\t}\n\n\tif (e->event_code == BRCMF_E_PFN_NET_LOST) {\n\t\tbrcmf_dbg(SCAN, \"PFN NET LOST event. Do Nothing\\n\");\n\t\treturn 0;\n\t}\n\n\tpfn_result = (struct brcmf_pno_scanresults_le *)data;\n\tresult_count = le32_to_cpu(pfn_result->count);\n\tstatus = le32_to_cpu(pfn_result->status);\n\n\t/* PFN event is limited to fit 512 bytes so we may get\n\t * multiple NET_FOUND events. For now place a warning here.\n\t */\n\tWARN_ON(status != BRCMF_PNO_SCAN_COMPLETE);\n\tbrcmf_dbg(SCAN, \"PFN NET FOUND event. count: %d\\n\", result_count);\n\tif (!result_count) {\n\t\tbphy_err(drvr, \"FALSE PNO Event. (pfn_count == 0)\\n\");\n\t\tgoto out_err;\n\t}\n\n\tnetinfo_start = brcmf_get_netinfo_array(pfn_result);\n\tdatalen = e->datalen - ((void *)netinfo_start - (void *)pfn_result);\n\tif (datalen < result_count * sizeof(*netinfo)) {\n\t\tbphy_err(drvr, \"insufficient event data\\n\");\n\t\tgoto out_err;\n\t}\n\n\trequest = brcmf_alloc_internal_escan_request(wiphy,\n\t\t\t\t\t\t     result_count);\n\tif (!request) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tbucket_map = 0;\n\tfor (i = 0; i < result_count; i++) {\n\t\tnetinfo = &netinfo_start[i];\n\n\t\tif (netinfo->SSID_len > IEEE80211_MAX_SSID_LEN)\n\t\t\tnetinfo->SSID_len = IEEE80211_MAX_SSID_LEN;\n\t\tbrcmf_dbg(SCAN, \"SSID:%.32s Channel:%d\\n\",\n\t\t\t  netinfo->SSID, netinfo->channel);\n\t\tbucket_map |= brcmf_pno_get_bucket_map(cfg->pno, netinfo);\n\t\terr = brcmf_internal_escan_add_info(request,\n\t\t\t\t\t\t    netinfo->SSID,\n\t\t\t\t\t\t    netinfo->SSID_len,\n\t\t\t\t\t\t    netinfo->channel);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\tif (!bucket_map)\n\t\tgoto free_req;\n\n\terr = brcmf_start_internal_escan(ifp, bucket_map, request);\n\tif (!err)\n\t\tgoto free_req;\n\nout_err:\n\tcfg80211_sched_scan_stopped(wiphy, 0);\nfree_req:\n\tkfree(request);\n\treturn err;\n}\n\nstatic int\nbrcmf_cfg80211_sched_scan_start(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *ndev,\n\t\t\t\tstruct cfg80211_sched_scan_request *req)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\n\tbrcmf_dbg(SCAN, \"Enter: n_match_sets=%d n_ssids=%d\\n\",\n\t\t  req->n_match_sets, req->n_ssids);\n\n\tif (test_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status)) {\n\t\tbphy_err(drvr, \"Scanning suppressed: status=%lu\\n\",\n\t\t\t cfg->scan_status);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (req->n_match_sets <= 0) {\n\t\tbrcmf_dbg(SCAN, \"invalid number of matchsets specified: %d\\n\",\n\t\t\t  req->n_match_sets);\n\t\treturn -EINVAL;\n\t}\n\n\treturn brcmf_pno_start_sched_scan(ifp, req);\n}\n\nstatic int brcmf_cfg80211_sched_scan_stop(struct wiphy *wiphy,\n\t\t\t\t\t  struct net_device *ndev, u64 reqid)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tbrcmf_dbg(SCAN, \"enter\\n\");\n\tbrcmf_pno_stop_sched_scan(ifp, reqid);\n\tif (cfg->int_escan_map)\n\t\tbrcmf_notify_escan_complete(cfg, ifp, true, true);\n\treturn 0;\n}\n\nstatic __always_inline void brcmf_delay(u32 ms)\n{\n\tif (ms < 1000 / HZ) {\n\t\tcond_resched();\n\t\tmdelay(ms);\n\t} else {\n\t\tmsleep(ms);\n\t}\n}\n\nstatic s32 brcmf_config_wowl_pattern(struct brcmf_if *ifp, u8 cmd[4],\n\t\t\t\t     u8 *pattern, u32 patternsize, u8 *mask,\n\t\t\t\t     u32 packet_offset)\n{\n\tstruct brcmf_fil_wowl_pattern_le *filter;\n\tu32 masksize;\n\tu32 patternoffset;\n\tu8 *buf;\n\tu32 bufsize;\n\ts32 ret;\n\n\tmasksize = (patternsize + 7) / 8;\n\tpatternoffset = sizeof(*filter) - sizeof(filter->cmd) + masksize;\n\n\tbufsize = sizeof(*filter) + patternsize + masksize;\n\tbuf = kzalloc(bufsize, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tfilter = (struct brcmf_fil_wowl_pattern_le *)buf;\n\n\tmemcpy(filter->cmd, cmd, 4);\n\tfilter->masksize = cpu_to_le32(masksize);\n\tfilter->offset = cpu_to_le32(packet_offset);\n\tfilter->patternoffset = cpu_to_le32(patternoffset);\n\tfilter->patternsize = cpu_to_le32(patternsize);\n\tfilter->type = cpu_to_le32(BRCMF_WOWL_PATTERN_TYPE_BITMAP);\n\n\tif ((mask) && (masksize))\n\t\tmemcpy(buf + sizeof(*filter), mask, masksize);\n\tif ((pattern) && (patternsize))\n\t\tmemcpy(buf + sizeof(*filter) + masksize, pattern, patternsize);\n\n\tret = brcmf_fil_iovar_data_set(ifp, \"wowl_pattern\", buf, bufsize);\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic s32\nbrcmf_wowl_nd_results(struct brcmf_if *ifp, const struct brcmf_event_msg *e,\n\t\t      void *data)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tstruct brcmf_cfg80211_info *cfg = drvr->config;\n\tstruct brcmf_pno_scanresults_le *pfn_result;\n\tstruct brcmf_pno_net_info_le *netinfo;\n\n\tbrcmf_dbg(SCAN, \"Enter\\n\");\n\n\tif (e->datalen < (sizeof(*pfn_result) + sizeof(*netinfo))) {\n\t\tbrcmf_dbg(SCAN, \"Event data to small. Ignore\\n\");\n\t\treturn 0;\n\t}\n\n\tpfn_result = (struct brcmf_pno_scanresults_le *)data;\n\n\tif (e->event_code == BRCMF_E_PFN_NET_LOST) {\n\t\tbrcmf_dbg(SCAN, \"PFN NET LOST event. Ignore\\n\");\n\t\treturn 0;\n\t}\n\n\tif (le32_to_cpu(pfn_result->count) < 1) {\n\t\tbphy_err(drvr, \"Invalid result count, expected 1 (%d)\\n\",\n\t\t\t le32_to_cpu(pfn_result->count));\n\t\treturn -EINVAL;\n\t}\n\n\tnetinfo = brcmf_get_netinfo_array(pfn_result);\n\tif (netinfo->SSID_len > IEEE80211_MAX_SSID_LEN)\n\t\tnetinfo->SSID_len = IEEE80211_MAX_SSID_LEN;\n\tmemcpy(cfg->wowl.nd->ssid.ssid, netinfo->SSID, netinfo->SSID_len);\n\tcfg->wowl.nd->ssid.ssid_len = netinfo->SSID_len;\n\tcfg->wowl.nd->n_channels = 1;\n\tcfg->wowl.nd->channels[0] =\n\t\tieee80211_channel_to_frequency(netinfo->channel,\n\t\t\tnetinfo->channel <= CH_MAX_2G_CHANNEL ?\n\t\t\t\t\tNL80211_BAND_2GHZ : NL80211_BAND_5GHZ);\n\tcfg->wowl.nd_info->n_matches = 1;\n\tcfg->wowl.nd_info->matches[0] = cfg->wowl.nd;\n\n\t/* Inform (the resume task) that the net detect information was recvd */\n\tcfg->wowl.nd_data_completed = true;\n\twake_up(&cfg->wowl.nd_data_wait);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n\nstatic void brcmf_report_wowl_wakeind(struct wiphy *wiphy, struct brcmf_if *ifp)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_wowl_wakeind_le wake_ind_le;\n\tstruct cfg80211_wowlan_wakeup wakeup_data;\n\tstruct cfg80211_wowlan_wakeup *wakeup;\n\tu32 wakeind;\n\ts32 err;\n\tint timeout;\n\n\terr = brcmf_fil_iovar_data_get(ifp, \"wowl_wakeind\", &wake_ind_le,\n\t\t\t\t       sizeof(wake_ind_le));\n\tif (err) {\n\t\tbphy_err(drvr, \"Get wowl_wakeind failed, err = %d\\n\", err);\n\t\treturn;\n\t}\n\n\twakeind = le32_to_cpu(wake_ind_le.ucode_wakeind);\n\tif (wakeind & (BRCMF_WOWL_MAGIC | BRCMF_WOWL_DIS | BRCMF_WOWL_BCN |\n\t\t       BRCMF_WOWL_RETR | BRCMF_WOWL_NET |\n\t\t       BRCMF_WOWL_PFN_FOUND)) {\n\t\twakeup = &wakeup_data;\n\t\tmemset(&wakeup_data, 0, sizeof(wakeup_data));\n\t\twakeup_data.pattern_idx = -1;\n\n\t\tif (wakeind & BRCMF_WOWL_MAGIC) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_MAGIC\\n\");\n\t\t\twakeup_data.magic_pkt = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_DIS) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_DIS\\n\");\n\t\t\twakeup_data.disconnect = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_BCN) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_BCN\\n\");\n\t\t\twakeup_data.disconnect = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_RETR) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_RETR\\n\");\n\t\t\twakeup_data.disconnect = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_NET) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_NET\\n\");\n\t\t\t/* For now always map to pattern 0, no API to get\n\t\t\t * correct information available at the moment.\n\t\t\t */\n\t\t\twakeup_data.pattern_idx = 0;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_PFN_FOUND) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_PFN_FOUND\\n\");\n\t\t\ttimeout = wait_event_timeout(cfg->wowl.nd_data_wait,\n\t\t\t\tcfg->wowl.nd_data_completed,\n\t\t\t\tBRCMF_ND_INFO_TIMEOUT);\n\t\t\tif (!timeout)\n\t\t\t\tbphy_err(drvr, \"No result for wowl net detect\\n\");\n\t\t\telse\n\t\t\t\twakeup_data.net_detect = cfg->wowl.nd_info;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_GTK_FAILURE) {\n\t\t\tbrcmf_dbg(INFO, \"WOWL Wake indicator: BRCMF_WOWL_GTK_FAILURE\\n\");\n\t\t\twakeup_data.gtk_rekey_failure = true;\n\t\t}\n\t} else {\n\t\twakeup = NULL;\n\t}\n\tcfg80211_report_wowlan_wakeup(&ifp->vif->wdev, wakeup, GFP_KERNEL);\n}\n\n#else\n\nstatic void brcmf_report_wowl_wakeind(struct wiphy *wiphy, struct brcmf_if *ifp)\n{\n}\n\n#endif /* CONFIG_PM */\n\nstatic s32 brcmf_cfg80211_resume(struct wiphy *wiphy)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (cfg->wowl.active) {\n\t\tbrcmf_report_wowl_wakeind(wiphy, ifp);\n\t\tbrcmf_fil_iovar_int_set(ifp, \"wowl_clear\", 0);\n\t\tbrcmf_config_wowl_pattern(ifp, \"clr\", NULL, 0, NULL, 0);\n\t\tif (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_ARP_ND))\n\t\t\tbrcmf_configure_arp_nd_offload(ifp, true);\n\t\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM,\n\t\t\t\t      cfg->wowl.pre_pmmode);\n\t\tcfg->wowl.active = false;\n\t\tif (cfg->wowl.nd_enabled) {\n\t\t\tbrcmf_cfg80211_sched_scan_stop(cfg->wiphy, ifp->ndev, 0);\n\t\t\tbrcmf_fweh_unregister(cfg->pub, BRCMF_E_PFN_NET_FOUND);\n\t\t\tbrcmf_fweh_register(cfg->pub, BRCMF_E_PFN_NET_FOUND,\n\t\t\t\t\t    brcmf_notify_sched_scan_results);\n\t\t\tcfg->wowl.nd_enabled = false;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void brcmf_configure_wowl(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t struct brcmf_if *ifp,\n\t\t\t\t struct cfg80211_wowlan *wowl)\n{\n\tu32 wowl_config;\n\tstruct brcmf_wowl_wakeind_le wowl_wakeind;\n\tu32 i;\n\n\tbrcmf_dbg(TRACE, \"Suspend, wowl config.\\n\");\n\n\tif (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_ARP_ND))\n\t\tbrcmf_configure_arp_nd_offload(ifp, false);\n\tbrcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_PM, &cfg->wowl.pre_pmmode);\n\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM, PM_MAX);\n\n\twowl_config = 0;\n\tif (wowl->disconnect)\n\t\twowl_config = BRCMF_WOWL_DIS | BRCMF_WOWL_BCN | BRCMF_WOWL_RETR;\n\tif (wowl->magic_pkt)\n\t\twowl_config |= BRCMF_WOWL_MAGIC;\n\tif ((wowl->patterns) && (wowl->n_patterns)) {\n\t\twowl_config |= BRCMF_WOWL_NET;\n\t\tfor (i = 0; i < wowl->n_patterns; i++) {\n\t\t\tbrcmf_config_wowl_pattern(ifp, \"add\",\n\t\t\t\t(u8 *)wowl->patterns[i].pattern,\n\t\t\t\twowl->patterns[i].pattern_len,\n\t\t\t\t(u8 *)wowl->patterns[i].mask,\n\t\t\t\twowl->patterns[i].pkt_offset);\n\t\t}\n\t}\n\tif (wowl->nd_config) {\n\t\tbrcmf_cfg80211_sched_scan_start(cfg->wiphy, ifp->ndev,\n\t\t\t\t\t\twowl->nd_config);\n\t\twowl_config |= BRCMF_WOWL_PFN_FOUND;\n\n\t\tcfg->wowl.nd_data_completed = false;\n\t\tcfg->wowl.nd_enabled = true;\n\t\t/* Now reroute the event for PFN to the wowl function. */\n\t\tbrcmf_fweh_unregister(cfg->pub, BRCMF_E_PFN_NET_FOUND);\n\t\tbrcmf_fweh_register(cfg->pub, BRCMF_E_PFN_NET_FOUND,\n\t\t\t\t    brcmf_wowl_nd_results);\n\t}\n\tif (wowl->gtk_rekey_failure)\n\t\twowl_config |= BRCMF_WOWL_GTK_FAILURE;\n\tif (!test_bit(BRCMF_VIF_STATUS_CONNECTED, &ifp->vif->sme_state))\n\t\twowl_config |= BRCMF_WOWL_UNASSOC;\n\n\tmemcpy(&wowl_wakeind, \"clear\", 6);\n\tbrcmf_fil_iovar_data_set(ifp, \"wowl_wakeind\", &wowl_wakeind,\n\t\t\t\t sizeof(wowl_wakeind));\n\tbrcmf_fil_iovar_int_set(ifp, \"wowl\", wowl_config);\n\tbrcmf_fil_iovar_int_set(ifp, \"wowl_activate\", 1);\n\tbrcmf_bus_wowl_config(cfg->pub->bus_if, true);\n\tcfg->wowl.active = true;\n}\n\nstatic s32 brcmf_cfg80211_suspend(struct wiphy *wiphy,\n\t\t\t\t  struct cfg80211_wowlan *wowl)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\t/* if the primary net_device is not READY there is nothing\n\t * we can do but pray resume goes smoothly.\n\t */\n\tif (!check_vif_up(ifp->vif))\n\t\tgoto exit;\n\n\t/* Stop scheduled scan */\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_PNO))\n\t\tbrcmf_cfg80211_sched_scan_stop(wiphy, ndev, 0);\n\n\t/* end any scanning */\n\tif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status))\n\t\tbrcmf_abort_scanning(cfg);\n\n\tif (wowl == NULL) {\n\t\tbrcmf_bus_wowl_config(cfg->pub->bus_if, false);\n\t\tlist_for_each_entry(vif, &cfg->vif_list, list) {\n\t\t\tif (!test_bit(BRCMF_VIF_STATUS_READY, &vif->sme_state))\n\t\t\t\tcontinue;\n\t\t\t/* While going to suspend if associated with AP\n\t\t\t * disassociate from AP to save power while system is\n\t\t\t * in suspended state\n\t\t\t */\n\t\t\tbrcmf_link_down(vif, WLAN_REASON_UNSPECIFIED, true);\n\t\t\t/* Make sure WPA_Supplicant receives all the event\n\t\t\t * generated due to DISASSOC call to the fw to keep\n\t\t\t * the state fw and WPA_Supplicant state consistent\n\t\t\t */\n\t\t\tbrcmf_delay(500);\n\t\t}\n\t\t/* Configure MPC */\n\t\tbrcmf_set_mpc(ifp, 1);\n\n\t} else {\n\t\t/* Configure WOWL paramaters */\n\t\tbrcmf_configure_wowl(cfg, ifp, wowl);\n\t}\n\nexit:\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\t/* clear any scanning activity */\n\tcfg->scan_status = 0;\n\treturn 0;\n}\n\nstatic __used s32\nbrcmf_update_pmklist(struct brcmf_cfg80211_info *cfg, struct brcmf_if *ifp)\n{\n\tstruct brcmf_pmk_list_le *pmk_list;\n\tint i;\n\tu32 npmk;\n\ts32 err;\n\n\tpmk_list = &cfg->pmk_list;\n\tnpmk = le32_to_cpu(pmk_list->npmk);\n\n\tbrcmf_dbg(CONN, \"No of elements %d\\n\", npmk);\n\tfor (i = 0; i < npmk; i++)\n\t\tbrcmf_dbg(CONN, \"PMK[%d]: %pM\\n\", i, &pmk_list->pmk[i].bssid);\n\n\terr = brcmf_fil_iovar_data_set(ifp, \"pmkid_info\", pmk_list,\n\t\t\t\t       sizeof(*pmk_list));\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_set_pmksa(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t struct cfg80211_pmksa *pmksa)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pmksa *pmk = &cfg->pmk_list.pmk[0];\n\tstruct brcmf_pub *drvr = cfg->pub;\n\ts32 err;\n\tu32 npmk, i;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tnpmk = le32_to_cpu(cfg->pmk_list.npmk);\n\tfor (i = 0; i < npmk; i++)\n\t\tif (!memcmp(pmksa->bssid, pmk[i].bssid, ETH_ALEN))\n\t\t\tbreak;\n\tif (i < BRCMF_MAXPMKID) {\n\t\tmemcpy(pmk[i].bssid, pmksa->bssid, ETH_ALEN);\n\t\tmemcpy(pmk[i].pmkid, pmksa->pmkid, WLAN_PMKID_LEN);\n\t\tif (i == npmk) {\n\t\t\tnpmk++;\n\t\t\tcfg->pmk_list.npmk = cpu_to_le32(npmk);\n\t\t}\n\t} else {\n\t\tbphy_err(drvr, \"Too many PMKSA entries cached %d\\n\", npmk);\n\t\treturn -EINVAL;\n\t}\n\n\tbrcmf_dbg(CONN, \"set_pmksa - PMK bssid: %pM =\\n\", pmk[npmk].bssid);\n\tbrcmf_dbg(CONN, \"%*ph\\n\", WLAN_PMKID_LEN, pmk[npmk].pmkid);\n\n\terr = brcmf_update_pmklist(cfg, ifp);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t struct cfg80211_pmksa *pmksa)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pmksa *pmk = &cfg->pmk_list.pmk[0];\n\tstruct brcmf_pub *drvr = cfg->pub;\n\ts32 err;\n\tu32 npmk, i;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tbrcmf_dbg(CONN, \"del_pmksa - PMK bssid = %pM\\n\", pmksa->bssid);\n\n\tnpmk = le32_to_cpu(cfg->pmk_list.npmk);\n\tfor (i = 0; i < npmk; i++)\n\t\tif (!memcmp(pmksa->bssid, pmk[i].bssid, ETH_ALEN))\n\t\t\tbreak;\n\n\tif ((npmk > 0) && (i < npmk)) {\n\t\tfor (; i < (npmk - 1); i++) {\n\t\t\tmemcpy(&pmk[i].bssid, &pmk[i + 1].bssid, ETH_ALEN);\n\t\t\tmemcpy(&pmk[i].pmkid, &pmk[i + 1].pmkid,\n\t\t\t       WLAN_PMKID_LEN);\n\t\t}\n\t\tmemset(&pmk[i], 0, sizeof(*pmk));\n\t\tcfg->pmk_list.npmk = cpu_to_le32(npmk - 1);\n\t} else {\n\t\tbphy_err(drvr, \"Cache entry not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = brcmf_update_pmklist(cfg, ifp);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n\n}\n\nstatic s32\nbrcmf_cfg80211_flush_pmksa(struct wiphy *wiphy, struct net_device *ndev)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tmemset(&cfg->pmk_list, 0, sizeof(cfg->pmk_list));\n\terr = brcmf_update_pmklist(cfg, ifp);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n\n}\n\nstatic s32 brcmf_configure_opensecurity(struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts32 err;\n\ts32 wpa_val;\n\n\t/* set auth */\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"auth\", 0);\n\tif (err < 0) {\n\t\tbphy_err(drvr, \"auth error %d\\n\", err);\n\t\treturn err;\n\t}\n\t/* set wsec */\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wsec\", 0);\n\tif (err < 0) {\n\t\tbphy_err(drvr, \"wsec error %d\\n\", err);\n\t\treturn err;\n\t}\n\t/* set upper-layer auth */\n\tif (brcmf_is_ibssmode(ifp->vif))\n\t\twpa_val = WPA_AUTH_NONE;\n\telse\n\t\twpa_val = WPA_AUTH_DISABLED;\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wpa_auth\", wpa_val);\n\tif (err < 0) {\n\t\tbphy_err(drvr, \"wpa_auth error %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic bool brcmf_valid_wpa_oui(u8 *oui, bool is_rsn_ie)\n{\n\tif (is_rsn_ie)\n\t\treturn (memcmp(oui, RSN_OUI, TLV_OUI_LEN) == 0);\n\n\treturn (memcmp(oui, WPA_OUI, TLV_OUI_LEN) == 0);\n}\n\nstatic s32\nbrcmf_configure_wpaie(struct brcmf_if *ifp,\n\t\t      const struct brcmf_vs_tlv *wpa_ie,\n\t\t      bool is_rsn_ie)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tu32 auth = 0; /* d11 open authentication */\n\tu16 count;\n\ts32 err = 0;\n\ts32 len;\n\tu32 i;\n\tu32 wsec;\n\tu32 pval = 0;\n\tu32 gval = 0;\n\tu32 wpa_auth = 0;\n\tu32 offset;\n\tu8 *data;\n\tu16 rsn_cap;\n\tu32 wme_bss_disable;\n\tu32 mfp;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\tif (wpa_ie == NULL)\n\t\tgoto exit;\n\n\tlen = wpa_ie->len + TLV_HDR_LEN;\n\tdata = (u8 *)wpa_ie;\n\toffset = TLV_HDR_LEN;\n\tif (!is_rsn_ie)\n\t\toffset += VS_IE_FIXED_HDR_LEN;\n\telse\n\t\toffset += WPA_IE_VERSION_LEN;\n\n\t/* check for multicast cipher suite */\n\tif (offset + WPA_IE_MIN_OUI_LEN > len) {\n\t\terr = -EINVAL;\n\t\tbphy_err(drvr, \"no multicast cipher suite\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {\n\t\terr = -EINVAL;\n\t\tbphy_err(drvr, \"ivalid OUI\\n\");\n\t\tgoto exit;\n\t}\n\toffset += TLV_OUI_LEN;\n\n\t/* pick up multicast cipher */\n\tswitch (data[offset]) {\n\tcase WPA_CIPHER_NONE:\n\t\tgval = 0;\n\t\tbreak;\n\tcase WPA_CIPHER_WEP_40:\n\tcase WPA_CIPHER_WEP_104:\n\t\tgval = WEP_ENABLED;\n\t\tbreak;\n\tcase WPA_CIPHER_TKIP:\n\t\tgval = TKIP_ENABLED;\n\t\tbreak;\n\tcase WPA_CIPHER_AES_CCM:\n\t\tgval = AES_ENABLED;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbphy_err(drvr, \"Invalid multi cast cipher info\\n\");\n\t\tgoto exit;\n\t}\n\n\toffset++;\n\t/* walk thru unicast cipher list and pick up what we recognize */\n\tcount = data[offset] + (data[offset + 1] << 8);\n\toffset += WPA_IE_SUITE_COUNT_LEN;\n\t/* Check for unicast suite(s) */\n\tif (offset + (WPA_IE_MIN_OUI_LEN * count) > len) {\n\t\terr = -EINVAL;\n\t\tbphy_err(drvr, \"no unicast cipher suite\\n\");\n\t\tgoto exit;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tif (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {\n\t\t\terr = -EINVAL;\n\t\t\tbphy_err(drvr, \"ivalid OUI\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\toffset += TLV_OUI_LEN;\n\t\tswitch (data[offset]) {\n\t\tcase WPA_CIPHER_NONE:\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_WEP_40:\n\t\tcase WPA_CIPHER_WEP_104:\n\t\t\tpval |= WEP_ENABLED;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_TKIP:\n\t\t\tpval |= TKIP_ENABLED;\n\t\t\tbreak;\n\t\tcase WPA_CIPHER_AES_CCM:\n\t\t\tpval |= AES_ENABLED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbphy_err(drvr, \"Invalid unicast security info\\n\");\n\t\t}\n\t\toffset++;\n\t}\n\t/* walk thru auth management suite list and pick up what we recognize */\n\tcount = data[offset] + (data[offset + 1] << 8);\n\toffset += WPA_IE_SUITE_COUNT_LEN;\n\t/* Check for auth key management suite(s) */\n\tif (offset + (WPA_IE_MIN_OUI_LEN * count) > len) {\n\t\terr = -EINVAL;\n\t\tbphy_err(drvr, \"no auth key mgmt suite\\n\");\n\t\tgoto exit;\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tif (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {\n\t\t\terr = -EINVAL;\n\t\t\tbphy_err(drvr, \"ivalid OUI\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\toffset += TLV_OUI_LEN;\n\t\tswitch (data[offset]) {\n\t\tcase RSN_AKM_NONE:\n\t\t\tbrcmf_dbg(TRACE, \"RSN_AKM_NONE\\n\");\n\t\t\twpa_auth |= WPA_AUTH_NONE;\n\t\t\tbreak;\n\t\tcase RSN_AKM_UNSPECIFIED:\n\t\t\tbrcmf_dbg(TRACE, \"RSN_AKM_UNSPECIFIED\\n\");\n\t\t\tis_rsn_ie ? (wpa_auth |= WPA2_AUTH_UNSPECIFIED) :\n\t\t\t\t    (wpa_auth |= WPA_AUTH_UNSPECIFIED);\n\t\t\tbreak;\n\t\tcase RSN_AKM_PSK:\n\t\t\tbrcmf_dbg(TRACE, \"RSN_AKM_PSK\\n\");\n\t\t\tis_rsn_ie ? (wpa_auth |= WPA2_AUTH_PSK) :\n\t\t\t\t    (wpa_auth |= WPA_AUTH_PSK);\n\t\t\tbreak;\n\t\tcase RSN_AKM_SHA256_PSK:\n\t\t\tbrcmf_dbg(TRACE, \"RSN_AKM_MFP_PSK\\n\");\n\t\t\twpa_auth |= WPA2_AUTH_PSK_SHA256;\n\t\t\tbreak;\n\t\tcase RSN_AKM_SHA256_1X:\n\t\t\tbrcmf_dbg(TRACE, \"RSN_AKM_MFP_1X\\n\");\n\t\t\twpa_auth |= WPA2_AUTH_1X_SHA256;\n\t\t\tbreak;\n\t\tcase RSN_AKM_SAE:\n\t\t\tbrcmf_dbg(TRACE, \"RSN_AKM_SAE\\n\");\n\t\t\twpa_auth |= WPA3_AUTH_SAE_PSK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbphy_err(drvr, \"Invalid key mgmt info\\n\");\n\t\t}\n\t\toffset++;\n\t}\n\n\tmfp = BRCMF_MFP_NONE;\n\tif (is_rsn_ie) {\n\t\twme_bss_disable = 1;\n\t\tif ((offset + RSN_CAP_LEN) <= len) {\n\t\t\trsn_cap = data[offset] + (data[offset + 1] << 8);\n\t\t\tif (rsn_cap & RSN_CAP_PTK_REPLAY_CNTR_MASK)\n\t\t\t\twme_bss_disable = 0;\n\t\t\tif (rsn_cap & RSN_CAP_MFPR_MASK) {\n\t\t\t\tbrcmf_dbg(TRACE, \"MFP Required\\n\");\n\t\t\t\tmfp = BRCMF_MFP_REQUIRED;\n\t\t\t\t/* Firmware only supports mfp required in\n\t\t\t\t * combination with WPA2_AUTH_PSK_SHA256,\n\t\t\t\t * WPA2_AUTH_1X_SHA256, or WPA3_AUTH_SAE_PSK.\n\t\t\t\t */\n\t\t\t\tif (!(wpa_auth & (WPA2_AUTH_PSK_SHA256 |\n\t\t\t\t\t\t  WPA2_AUTH_1X_SHA256 |\n\t\t\t\t\t\t  WPA3_AUTH_SAE_PSK))) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\t/* Firmware has requirement that WPA2_AUTH_PSK/\n\t\t\t\t * WPA2_AUTH_UNSPECIFIED be set, if SHA256 OUI\n\t\t\t\t * is to be included in the rsn ie.\n\t\t\t\t */\n\t\t\t\tif (wpa_auth & WPA2_AUTH_PSK_SHA256)\n\t\t\t\t\twpa_auth |= WPA2_AUTH_PSK;\n\t\t\t\telse if (wpa_auth & WPA2_AUTH_1X_SHA256)\n\t\t\t\t\twpa_auth |= WPA2_AUTH_UNSPECIFIED;\n\t\t\t} else if (rsn_cap & RSN_CAP_MFPC_MASK) {\n\t\t\t\tbrcmf_dbg(TRACE, \"MFP Capable\\n\");\n\t\t\t\tmfp = BRCMF_MFP_CAPABLE;\n\t\t\t}\n\t\t}\n\t\toffset += RSN_CAP_LEN;\n\t\t/* set wme_bss_disable to sync RSN Capabilities */\n\t\terr = brcmf_fil_bsscfg_int_set(ifp, \"wme_bss_disable\",\n\t\t\t\t\t       wme_bss_disable);\n\t\tif (err < 0) {\n\t\t\tbphy_err(drvr, \"wme_bss_disable error %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* Skip PMKID cnt as it is know to be 0 for AP. */\n\t\toffset += RSN_PMKID_COUNT_LEN;\n\n\t\t/* See if there is BIP wpa suite left for MFP */\n\t\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP) &&\n\t\t    ((offset + WPA_IE_MIN_OUI_LEN) <= len)) {\n\t\t\terr = brcmf_fil_bsscfg_data_set(ifp, \"bip\",\n\t\t\t\t\t\t\t&data[offset],\n\t\t\t\t\t\t\tWPA_IE_MIN_OUI_LEN);\n\t\t\tif (err < 0) {\n\t\t\t\tbphy_err(drvr, \"bip error %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\t/* FOR WPS , set SES_OW_ENABLED */\n\twsec = (pval | gval | SES_OW_ENABLED);\n\n\t/* set auth */\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"auth\", auth);\n\tif (err < 0) {\n\t\tbphy_err(drvr, \"auth error %d\\n\", err);\n\t\tgoto exit;\n\t}\n\t/* set wsec */\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wsec\", wsec);\n\tif (err < 0) {\n\t\tbphy_err(drvr, \"wsec error %d\\n\", err);\n\t\tgoto exit;\n\t}\n\t/* Configure MFP, this needs to go after wsec otherwise the wsec command\n\t * will overwrite the values set by MFP\n\t */\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP)) {\n\t\terr = brcmf_fil_bsscfg_int_set(ifp, \"mfp\", mfp);\n\t\tif (err < 0) {\n\t\t\tbphy_err(drvr, \"mfp error %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\t/* set upper-layer auth */\n\terr = brcmf_fil_bsscfg_int_set(ifp, \"wpa_auth\", wpa_auth);\n\tif (err < 0) {\n\t\tbphy_err(drvr, \"wpa_auth error %d\\n\", err);\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn err;\n}\n\nstatic s32\nbrcmf_parse_vndr_ies(const u8 *vndr_ie_buf, u32 vndr_ie_len,\n\t\t     struct parsed_vndr_ies *vndr_ies)\n{\n\tstruct brcmf_vs_tlv *vndrie;\n\tstruct brcmf_tlv *ie;\n\tstruct parsed_vndr_ie_info *parsed_info;\n\ts32 remaining_len;\n\n\tremaining_len = (s32)vndr_ie_len;\n\tmemset(vndr_ies, 0, sizeof(*vndr_ies));\n\n\tie = (struct brcmf_tlv *)vndr_ie_buf;\n\twhile (ie) {\n\t\tif (ie->id != WLAN_EID_VENDOR_SPECIFIC)\n\t\t\tgoto next;\n\t\tvndrie = (struct brcmf_vs_tlv *)ie;\n\t\t/* len should be bigger than OUI length + one */\n\t\tif (vndrie->len < (VS_IE_FIXED_HDR_LEN - TLV_HDR_LEN + 1)) {\n\t\t\tbrcmf_err(\"invalid vndr ie. length is too small %d\\n\",\n\t\t\t\t  vndrie->len);\n\t\t\tgoto next;\n\t\t}\n\t\t/* if wpa or wme ie, do not add ie */\n\t\tif (!memcmp(vndrie->oui, (u8 *)WPA_OUI, TLV_OUI_LEN) &&\n\t\t    ((vndrie->oui_type == WPA_OUI_TYPE) ||\n\t\t    (vndrie->oui_type == WME_OUI_TYPE))) {\n\t\t\tbrcmf_dbg(TRACE, \"Found WPA/WME oui. Do not add it\\n\");\n\t\t\tgoto next;\n\t\t}\n\n\t\tparsed_info = &vndr_ies->ie_info[vndr_ies->count];\n\n\t\t/* save vndr ie information */\n\t\tparsed_info->ie_ptr = (char *)vndrie;\n\t\tparsed_info->ie_len = vndrie->len + TLV_HDR_LEN;\n\t\tmemcpy(&parsed_info->vndrie, vndrie, sizeof(*vndrie));\n\n\t\tvndr_ies->count++;\n\n\t\tbrcmf_dbg(TRACE, \"** OUI %3ph, type 0x%02x\\n\",\n\t\t\t  parsed_info->vndrie.oui,\n\t\t\t  parsed_info->vndrie.oui_type);\n\n\t\tif (vndr_ies->count >= VNDR_IE_PARSE_LIMIT)\n\t\t\tbreak;\nnext:\n\t\tremaining_len -= (ie->len + TLV_HDR_LEN);\n\t\tif (remaining_len <= TLV_HDR_LEN)\n\t\t\tie = NULL;\n\t\telse\n\t\t\tie = (struct brcmf_tlv *)(((u8 *)ie) + ie->len +\n\t\t\t\tTLV_HDR_LEN);\n\t}\n\treturn 0;\n}\n\nstatic u32\nbrcmf_vndr_ie(u8 *iebuf, s32 pktflag, u8 *ie_ptr, u32 ie_len, s8 *add_del_cmd)\n{\n\tstrscpy(iebuf, add_del_cmd, VNDR_IE_CMD_LEN);\n\n\tput_unaligned_le32(1, &iebuf[VNDR_IE_COUNT_OFFSET]);\n\n\tput_unaligned_le32(pktflag, &iebuf[VNDR_IE_PKTFLAG_OFFSET]);\n\n\tmemcpy(&iebuf[VNDR_IE_VSIE_OFFSET], ie_ptr, ie_len);\n\n\treturn ie_len + VNDR_IE_HDR_SIZE;\n}\n\ns32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32 pktflag,\n\t\t\t  const u8 *vndr_ie_buf, u32 vndr_ie_len)\n{\n\tstruct brcmf_pub *drvr;\n\tstruct brcmf_if *ifp;\n\tstruct vif_saved_ie *saved_ie;\n\ts32 err = 0;\n\tu8  *iovar_ie_buf;\n\tu8  *curr_ie_buf;\n\tu8  *mgmt_ie_buf = NULL;\n\tint mgmt_ie_buf_len;\n\tu32 *mgmt_ie_len;\n\tu32 del_add_ie_buf_len = 0;\n\tu32 total_ie_buf_len = 0;\n\tu32 parsed_ie_buf_len = 0;\n\tstruct parsed_vndr_ies old_vndr_ies;\n\tstruct parsed_vndr_ies new_vndr_ies;\n\tstruct parsed_vndr_ie_info *vndrie_info;\n\ts32 i;\n\tu8 *ptr;\n\tint remained_buf_len;\n\n\tif (!vif)\n\t\treturn -ENODEV;\n\tifp = vif->ifp;\n\tdrvr = ifp->drvr;\n\tsaved_ie = &vif->saved_ie;\n\n\tbrcmf_dbg(TRACE, \"bsscfgidx %d, pktflag : 0x%02X\\n\", ifp->bsscfgidx,\n\t\t  pktflag);\n\tiovar_ie_buf = kzalloc(WL_EXTRA_BUF_MAX, GFP_KERNEL);\n\tif (!iovar_ie_buf)\n\t\treturn -ENOMEM;\n\tcurr_ie_buf = iovar_ie_buf;\n\tswitch (pktflag) {\n\tcase BRCMF_VNDR_IE_PRBREQ_FLAG:\n\t\tmgmt_ie_buf = saved_ie->probe_req_ie;\n\t\tmgmt_ie_len = &saved_ie->probe_req_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->probe_req_ie);\n\t\tbreak;\n\tcase BRCMF_VNDR_IE_PRBRSP_FLAG:\n\t\tmgmt_ie_buf = saved_ie->probe_res_ie;\n\t\tmgmt_ie_len = &saved_ie->probe_res_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->probe_res_ie);\n\t\tbreak;\n\tcase BRCMF_VNDR_IE_BEACON_FLAG:\n\t\tmgmt_ie_buf = saved_ie->beacon_ie;\n\t\tmgmt_ie_len = &saved_ie->beacon_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->beacon_ie);\n\t\tbreak;\n\tcase BRCMF_VNDR_IE_ASSOCREQ_FLAG:\n\t\tmgmt_ie_buf = saved_ie->assoc_req_ie;\n\t\tmgmt_ie_len = &saved_ie->assoc_req_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->assoc_req_ie);\n\t\tbreak;\n\tcase BRCMF_VNDR_IE_ASSOCRSP_FLAG:\n\t\tmgmt_ie_buf = saved_ie->assoc_res_ie;\n\t\tmgmt_ie_len = &saved_ie->assoc_res_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->assoc_res_ie);\n\t\tbreak;\n\tdefault:\n\t\terr = -EPERM;\n\t\tbphy_err(drvr, \"not suitable type\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (vndr_ie_len > mgmt_ie_buf_len) {\n\t\terr = -ENOMEM;\n\t\tbphy_err(drvr, \"extra IE size too big\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* parse and save new vndr_ie in curr_ie_buff before comparing it */\n\tif (vndr_ie_buf && vndr_ie_len && curr_ie_buf) {\n\t\tptr = curr_ie_buf;\n\t\tbrcmf_parse_vndr_ies(vndr_ie_buf, vndr_ie_len, &new_vndr_ies);\n\t\tfor (i = 0; i < new_vndr_ies.count; i++) {\n\t\t\tvndrie_info = &new_vndr_ies.ie_info[i];\n\t\t\tmemcpy(ptr + parsed_ie_buf_len, vndrie_info->ie_ptr,\n\t\t\t       vndrie_info->ie_len);\n\t\t\tparsed_ie_buf_len += vndrie_info->ie_len;\n\t\t}\n\t}\n\n\tif (mgmt_ie_buf && *mgmt_ie_len) {\n\t\tif (parsed_ie_buf_len && (parsed_ie_buf_len == *mgmt_ie_len) &&\n\t\t    (memcmp(mgmt_ie_buf, curr_ie_buf,\n\t\t\t    parsed_ie_buf_len) == 0)) {\n\t\t\tbrcmf_dbg(TRACE, \"Previous mgmt IE equals to current IE\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* parse old vndr_ie */\n\t\tbrcmf_parse_vndr_ies(mgmt_ie_buf, *mgmt_ie_len, &old_vndr_ies);\n\n\t\t/* make a command to delete old ie */\n\t\tfor (i = 0; i < old_vndr_ies.count; i++) {\n\t\t\tvndrie_info = &old_vndr_ies.ie_info[i];\n\n\t\t\tbrcmf_dbg(TRACE, \"DEL ID : %d, Len: %d , OUI:%3ph\\n\",\n\t\t\t\t  vndrie_info->vndrie.id,\n\t\t\t\t  vndrie_info->vndrie.len,\n\t\t\t\t  vndrie_info->vndrie.oui);\n\n\t\t\tdel_add_ie_buf_len = brcmf_vndr_ie(curr_ie_buf, pktflag,\n\t\t\t\t\t\t\t   vndrie_info->ie_ptr,\n\t\t\t\t\t\t\t   vndrie_info->ie_len,\n\t\t\t\t\t\t\t   \"del\");\n\t\t\tcurr_ie_buf += del_add_ie_buf_len;\n\t\t\ttotal_ie_buf_len += del_add_ie_buf_len;\n\t\t}\n\t}\n\n\t*mgmt_ie_len = 0;\n\t/* Add if there is any extra IE */\n\tif (mgmt_ie_buf && parsed_ie_buf_len) {\n\t\tptr = mgmt_ie_buf;\n\n\t\tremained_buf_len = mgmt_ie_buf_len;\n\n\t\t/* make a command to add new ie */\n\t\tfor (i = 0; i < new_vndr_ies.count; i++) {\n\t\t\tvndrie_info = &new_vndr_ies.ie_info[i];\n\n\t\t\t/* verify remained buf size before copy data */\n\t\t\tif (remained_buf_len < (vndrie_info->vndrie.len +\n\t\t\t\t\t\t\tVNDR_IE_VSIE_OFFSET)) {\n\t\t\t\tbphy_err(drvr, \"no space in mgmt_ie_buf: len left %d\",\n\t\t\t\t\t remained_buf_len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tremained_buf_len -= (vndrie_info->ie_len +\n\t\t\t\t\t     VNDR_IE_VSIE_OFFSET);\n\n\t\t\tbrcmf_dbg(TRACE, \"ADDED ID : %d, Len: %d, OUI:%3ph\\n\",\n\t\t\t\t  vndrie_info->vndrie.id,\n\t\t\t\t  vndrie_info->vndrie.len,\n\t\t\t\t  vndrie_info->vndrie.oui);\n\n\t\t\tdel_add_ie_buf_len = brcmf_vndr_ie(curr_ie_buf, pktflag,\n\t\t\t\t\t\t\t   vndrie_info->ie_ptr,\n\t\t\t\t\t\t\t   vndrie_info->ie_len,\n\t\t\t\t\t\t\t   \"add\");\n\n\t\t\t/* save the parsed IE in wl struct */\n\t\t\tmemcpy(ptr + (*mgmt_ie_len), vndrie_info->ie_ptr,\n\t\t\t       vndrie_info->ie_len);\n\t\t\t*mgmt_ie_len += vndrie_info->ie_len;\n\n\t\t\tcurr_ie_buf += del_add_ie_buf_len;\n\t\t\ttotal_ie_buf_len += del_add_ie_buf_len;\n\t\t}\n\t}\n\tif (total_ie_buf_len) {\n\t\terr  = brcmf_fil_bsscfg_data_set(ifp, \"vndr_ie\", iovar_ie_buf,\n\t\t\t\t\t\t total_ie_buf_len);\n\t\tif (err)\n\t\t\tbphy_err(drvr, \"vndr ie set error : %d\\n\", err);\n\t}\n\nexit:\n\tkfree(iovar_ie_buf);\n\treturn err;\n}\n\ns32 brcmf_vif_clear_mgmt_ies(struct brcmf_cfg80211_vif *vif)\n{\n\ts32 pktflags[] = {\n\t\tBRCMF_VNDR_IE_PRBREQ_FLAG,\n\t\tBRCMF_VNDR_IE_PRBRSP_FLAG,\n\t\tBRCMF_VNDR_IE_BEACON_FLAG\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pktflags); i++)\n\t\tbrcmf_vif_set_mgmt_ie(vif, pktflags[i], NULL, 0);\n\n\tmemset(&vif->saved_ie, 0, sizeof(vif->saved_ie));\n\treturn 0;\n}\n\nstatic s32\nbrcmf_config_ap_mgmt_ie(struct brcmf_cfg80211_vif *vif,\n\t\t\tstruct cfg80211_beacon_data *beacon)\n{\n\tstruct brcmf_pub *drvr = vif->ifp->drvr;\n\ts32 err;\n\n\t/* Set Beacon IEs to FW */\n\terr = brcmf_vif_set_mgmt_ie(vif, BRCMF_VNDR_IE_BEACON_FLAG,\n\t\t\t\t    beacon->tail, beacon->tail_len);\n\tif (err) {\n\t\tbphy_err(drvr, \"Set Beacon IE Failed\\n\");\n\t\treturn err;\n\t}\n\tbrcmf_dbg(TRACE, \"Applied Vndr IEs for Beacon\\n\");\n\n\t/* Set Probe Response IEs to FW */\n\terr = brcmf_vif_set_mgmt_ie(vif, BRCMF_VNDR_IE_PRBRSP_FLAG,\n\t\t\t\t    beacon->proberesp_ies,\n\t\t\t\t    beacon->proberesp_ies_len);\n\tif (err)\n\t\tbphy_err(drvr, \"Set Probe Resp IE Failed\\n\");\n\telse\n\t\tbrcmf_dbg(TRACE, \"Applied Vndr IEs for Probe Resp\\n\");\n\n\t/* Set Assoc Response IEs to FW */\n\terr = brcmf_vif_set_mgmt_ie(vif, BRCMF_VNDR_IE_ASSOCRSP_FLAG,\n\t\t\t\t    beacon->assocresp_ies,\n\t\t\t\t    beacon->assocresp_ies_len);\n\tif (err)\n\t\tbrcmf_err(\"Set Assoc Resp IE Failed\\n\");\n\telse\n\t\tbrcmf_dbg(TRACE, \"Applied Vndr IEs for Assoc Resp\\n\");\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_parse_configure_security(struct brcmf_if *ifp,\n\t\t\t       struct cfg80211_ap_settings *settings,\n\t\t\t       enum nl80211_iftype dev_role)\n{\n\tconst struct brcmf_tlv *rsn_ie;\n\tconst struct brcmf_vs_tlv *wpa_ie;\n\ts32 err = 0;\n\n\t/* find the RSN_IE */\n\trsn_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail,\n\t\t\t\t  settings->beacon.tail_len, WLAN_EID_RSN);\n\n\t/* find the WPA_IE */\n\twpa_ie = brcmf_find_wpaie((u8 *)settings->beacon.tail,\n\t\t\t\t  settings->beacon.tail_len);\n\n\tif (wpa_ie || rsn_ie) {\n\t\tbrcmf_dbg(TRACE, \"WPA(2) IE is found\\n\");\n\t\tif (wpa_ie) {\n\t\t\t/* WPA IE */\n\t\t\terr = brcmf_configure_wpaie(ifp, wpa_ie, false);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tstruct brcmf_vs_tlv *tmp_ie;\n\n\t\t\ttmp_ie = (struct brcmf_vs_tlv *)rsn_ie;\n\n\t\t\t/* RSN IE */\n\t\t\terr = brcmf_configure_wpaie(ifp, tmp_ie, true);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tbrcmf_dbg(TRACE, \"No WPA(2) IEs found\\n\");\n\t\tbrcmf_configure_opensecurity(ifp);\n\t}\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\tstruct cfg80211_ap_settings *settings)\n{\n\ts32 ie_offset;\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct cfg80211_crypto_settings *crypto = &settings->crypto;\n\tconst struct brcmf_tlv *ssid_ie;\n\tconst struct brcmf_tlv *country_ie;\n\tstruct brcmf_ssid_le ssid_le;\n\ts32 err = -EPERM;\n\tstruct brcmf_join_params join_params;\n\tenum nl80211_iftype dev_role;\n\tstruct brcmf_fil_bss_enable_le bss_enable;\n\tu16 chanspec = chandef_to_chanspec(&cfg->d11inf, &settings->chandef);\n\tbool mbss;\n\tint is_11d;\n\tbool supports_11d;\n\n\tbrcmf_dbg(TRACE, \"ctrlchn=%d, center=%d, bw=%d, beacon_interval=%d, dtim_period=%d,\\n\",\n\t\t  settings->chandef.chan->hw_value,\n\t\t  settings->chandef.center_freq1, settings->chandef.width,\n\t\t  settings->beacon_interval, settings->dtim_period);\n\tbrcmf_dbg(TRACE, \"ssid=%s(%zu), auth_type=%d, inactivity_timeout=%d\\n\",\n\t\t  settings->ssid, settings->ssid_len, settings->auth_type,\n\t\t  settings->inactivity_timeout);\n\tdev_role = ifp->vif->wdev.iftype;\n\tmbss = ifp->vif->mbss;\n\n\t/* store current 11d setting */\n\tif (brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_REGULATORY,\n\t\t\t\t  &ifp->vif->is_11d)) {\n\t\tis_11d = supports_11d = false;\n\t} else {\n\t\tcountry_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail,\n\t\t\t\t\t      settings->beacon.tail_len,\n\t\t\t\t\t      WLAN_EID_COUNTRY);\n\t\tis_11d = country_ie ? 1 : 0;\n\t\tsupports_11d = true;\n\t}\n\n\tmemset(&ssid_le, 0, sizeof(ssid_le));\n\tif (settings->ssid == NULL || settings->ssid_len == 0) {\n\t\tie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;\n\t\tssid_ie = brcmf_parse_tlvs(\n\t\t\t\t(u8 *)&settings->beacon.head[ie_offset],\n\t\t\t\tsettings->beacon.head_len - ie_offset,\n\t\t\t\tWLAN_EID_SSID);\n\t\tif (!ssid_ie || ssid_ie->len > IEEE80211_MAX_SSID_LEN)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len);\n\t\tssid_le.SSID_len = cpu_to_le32(ssid_ie->len);\n\t\tbrcmf_dbg(TRACE, \"SSID is (%s) in Head\\n\", ssid_le.SSID);\n\t} else {\n\t\tmemcpy(ssid_le.SSID, settings->ssid, settings->ssid_len);\n\t\tssid_le.SSID_len = cpu_to_le32((u32)settings->ssid_len);\n\t}\n\n\tif (!mbss) {\n\t\tbrcmf_set_mpc(ifp, 0);\n\t\tbrcmf_configure_arp_nd_offload(ifp, false);\n\t}\n\n\t/* Parameters shared by all radio interfaces */\n\tif (!mbss) {\n\t\tif ((supports_11d) && (is_11d != ifp->vif->is_11d)) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,\n\t\t\t\t\t\t    is_11d);\n\t\t\tif (err < 0) {\n\t\t\t\tbphy_err(drvr, \"Regulatory Set Error, %d\\n\",\n\t\t\t\t\t err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tif (settings->beacon_interval) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD,\n\t\t\t\t\t\t    settings->beacon_interval);\n\t\t\tif (err < 0) {\n\t\t\t\tbphy_err(drvr, \"Beacon Interval Set Error, %d\\n\",\n\t\t\t\t\t err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tif (settings->dtim_period) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_DTIMPRD,\n\t\t\t\t\t\t    settings->dtim_period);\n\t\t\tif (err < 0) {\n\t\t\t\tbphy_err(drvr, \"DTIM Interval Set Error, %d\\n\",\n\t\t\t\t\t err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tif ((dev_role == NL80211_IFTYPE_AP) &&\n\t\t    ((ifp->ifidx == 0) ||\n\t\t     (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB) &&\n\t\t      !brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MCHAN)))) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);\n\t\t\tif (err < 0) {\n\t\t\t\tbphy_err(drvr, \"BRCMF_C_DOWN error %d\\n\",\n\t\t\t\t\t err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"apsta\", 0);\n\t\t}\n\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, 1);\n\t\tif (err < 0) {\n\t\t\tbphy_err(drvr, \"SET INFRA error %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t} else if (WARN_ON(supports_11d && (is_11d != ifp->vif->is_11d))) {\n\t\t/* Multiple-BSS should use same 11d configuration */\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t/* Interface specific setup */\n\tif (dev_role == NL80211_IFTYPE_AP) {\n\t\tif ((brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS)) && (!mbss))\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"mbss\", 1);\n\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 1);\n\t\tif (err < 0) {\n\t\t\tbphy_err(drvr, \"setting AP mode failed %d\\n\",\n\t\t\t\t err);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (!mbss) {\n\t\t\t/* Firmware 10.x requires setting channel after enabling\n\t\t\t * AP and before bringing interface up.\n\t\t\t */\n\t\t\terr = brcmf_fil_iovar_int_set(ifp, \"chanspec\", chanspec);\n\t\t\tif (err < 0) {\n\t\t\t\tbphy_err(drvr, \"Set Channel failed: chspec=%d, %d\\n\",\n\t\t\t\t\t chanspec, err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);\n\t\tif (err < 0) {\n\t\t\tbphy_err(drvr, \"BRCMF_C_UP error (%d)\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (crypto->psk) {\n\t\t\tbrcmf_dbg(INFO, \"using PSK offload\\n\");\n\t\t\tprofile->use_fwauth |= BIT(BRCMF_PROFILE_FWAUTH_PSK);\n\t\t\terr = brcmf_set_pmk(ifp, crypto->psk,\n\t\t\t\t\t    BRCMF_WSEC_MAX_PSK_LEN);\n\t\t\tif (err < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tif (crypto->sae_pwd) {\n\t\t\tbrcmf_dbg(INFO, \"using SAE offload\\n\");\n\t\t\tprofile->use_fwauth |= BIT(BRCMF_PROFILE_FWAUTH_SAE);\n\t\t\terr = brcmf_set_sae_password(ifp, crypto->sae_pwd,\n\t\t\t\t\t\t     crypto->sae_pwd_len);\n\t\t\tif (err < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tif (profile->use_fwauth == 0)\n\t\t\tprofile->use_fwauth = BIT(BRCMF_PROFILE_FWAUTH_NONE);\n\n\t\terr = brcmf_parse_configure_security(ifp, settings,\n\t\t\t\t\t\t     NL80211_IFTYPE_AP);\n\t\tif (err < 0) {\n\t\t\tbphy_err(drvr, \"brcmf_parse_configure_security error\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* On DOWN the firmware removes the WEP keys, reconfigure\n\t\t * them if they were set.\n\t\t */\n\t\tbrcmf_cfg80211_reconfigure_wep(ifp);\n\n\t\tmemset(&join_params, 0, sizeof(join_params));\n\t\t/* join parameters starts with ssid */\n\t\tmemcpy(&join_params.ssid_le, &ssid_le, sizeof(ssid_le));\n\t\t/* create softap */\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\n\t\t\t\t\t     &join_params, sizeof(join_params));\n\t\tif (err < 0) {\n\t\t\tbphy_err(drvr, \"SET SSID error (%d)\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"closednet\",\n\t\t\t\t\t      settings->hidden_ssid);\n\t\tif (err) {\n\t\t\tbphy_err(drvr, \"%s closednet error (%d)\\n\",\n\t\t\t\t settings->hidden_ssid ?\n\t\t\t\t \"enabled\" : \"disabled\",\n\t\t\t\t err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tbrcmf_dbg(TRACE, \"AP mode configuration complete\\n\");\n\t} else if (dev_role == NL80211_IFTYPE_P2P_GO) {\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"chanspec\", chanspec);\n\t\tif (err < 0) {\n\t\t\tbphy_err(drvr, \"Set Channel failed: chspec=%d, %d\\n\",\n\t\t\t\t chanspec, err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\terr = brcmf_parse_configure_security(ifp, settings,\n\t\t\t\t\t\t     NL80211_IFTYPE_P2P_GO);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"brcmf_parse_configure_security error\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\terr = brcmf_fil_bsscfg_data_set(ifp, \"ssid\", &ssid_le,\n\t\t\t\t\t\tsizeof(ssid_le));\n\t\tif (err < 0) {\n\t\t\tbphy_err(drvr, \"setting ssid failed %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\tbss_enable.bsscfgidx = cpu_to_le32(ifp->bsscfgidx);\n\t\tbss_enable.enable = cpu_to_le32(1);\n\t\terr = brcmf_fil_iovar_data_set(ifp, \"bss\", &bss_enable,\n\t\t\t\t\t       sizeof(bss_enable));\n\t\tif (err < 0) {\n\t\t\tbphy_err(drvr, \"bss_enable config failed %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tbrcmf_dbg(TRACE, \"GO mode configuration complete\\n\");\n\t} else {\n\t\tWARN_ON(1);\n\t}\n\n\tbrcmf_config_ap_mgmt_ie(ifp->vif, &settings->beacon);\n\tset_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state);\n\tbrcmf_net_setcarrier(ifp, true);\n\nexit:\n\tif ((err) && (!mbss)) {\n\t\tbrcmf_set_mpc(ifp, 1);\n\t\tbrcmf_configure_arp_nd_offload(ifp, true);\n\t}\n\treturn err;\n}\n\nstatic int brcmf_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *ndev)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\ts32 err;\n\tstruct brcmf_fil_bss_enable_le bss_enable;\n\tstruct brcmf_join_params join_params;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (ifp->vif->wdev.iftype == NL80211_IFTYPE_AP) {\n\t\t/* Due to most likely deauths outstanding we sleep */\n\t\t/* first to make sure they get processed by fw. */\n\t\tmsleep(400);\n\n\t\tif (profile->use_fwauth != BIT(BRCMF_PROFILE_FWAUTH_NONE)) {\n\t\t\tif (profile->use_fwauth & BIT(BRCMF_PROFILE_FWAUTH_PSK))\n\t\t\t\tbrcmf_set_pmk(ifp, NULL, 0);\n\t\t\tif (profile->use_fwauth & BIT(BRCMF_PROFILE_FWAUTH_SAE))\n\t\t\t\tbrcmf_set_sae_password(ifp, NULL, 0);\n\t\t\tprofile->use_fwauth = BIT(BRCMF_PROFILE_FWAUTH_NONE);\n\t\t}\n\n\t\tif (ifp->vif->mbss) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);\n\t\t\treturn err;\n\t\t}\n\n\t\t/* First BSS doesn't get a full reset */\n\t\tif (ifp->bsscfgidx == 0)\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"closednet\", 0);\n\n\t\tmemset(&join_params, 0, sizeof(join_params));\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\n\t\t\t\t\t     &join_params, sizeof(join_params));\n\t\tif (err < 0)\n\t\t\tbphy_err(drvr, \"SET SSID error (%d)\\n\", err);\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);\n\t\tif (err < 0)\n\t\t\tbphy_err(drvr, \"BRCMF_C_DOWN error %d\\n\", err);\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 0);\n\t\tif (err < 0)\n\t\t\tbphy_err(drvr, \"setting AP mode failed %d\\n\", err);\n\t\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS))\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"mbss\", 0);\n\t\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,\n\t\t\t\t      ifp->vif->is_11d);\n\t\t/* Bring device back up so it can be used again */\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);\n\t\tif (err < 0)\n\t\t\tbphy_err(drvr, \"BRCMF_C_UP error %d\\n\", err);\n\n\t\tbrcmf_vif_clear_mgmt_ies(ifp->vif);\n\t} else {\n\t\tbss_enable.bsscfgidx = cpu_to_le32(ifp->bsscfgidx);\n\t\tbss_enable.enable = cpu_to_le32(0);\n\t\terr = brcmf_fil_iovar_data_set(ifp, \"bss\", &bss_enable,\n\t\t\t\t\t       sizeof(bss_enable));\n\t\tif (err < 0)\n\t\t\tbphy_err(drvr, \"bss_enable config failed %d\\n\", err);\n\t}\n\tbrcmf_set_mpc(ifp, 1);\n\tbrcmf_configure_arp_nd_offload(ifp, true);\n\tclear_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state);\n\tbrcmf_net_setcarrier(ifp, false);\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t     struct cfg80211_beacon_data *info)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\terr = brcmf_config_ap_mgmt_ie(ifp->vif, info);\n\n\treturn err;\n}\n\nstatic int\nbrcmf_cfg80211_del_station(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t   struct station_del_parameters *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_scb_val_le scbval;\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\n\tif (!params->mac)\n\t\treturn -EFAULT;\n\n\tbrcmf_dbg(TRACE, \"Enter %pM\\n\", params->mac);\n\n\tif (ifp->vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif)\n\t\tifp = cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->ifp;\n\tif (!check_vif_up(ifp->vif))\n\t\treturn -EIO;\n\n\tmemcpy(&scbval.ea, params->mac, ETH_ALEN);\n\tscbval.val = cpu_to_le32(params->reason_code);\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SCB_DEAUTHENTICATE_FOR_REASON,\n\t\t\t\t     &scbval, sizeof(scbval));\n\tif (err)\n\t\tbphy_err(drvr, \"SCB_DEAUTHENTICATE_FOR_REASON failed %d\\n\",\n\t\t\t err);\n\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic int\nbrcmf_cfg80211_change_station(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t      const u8 *mac, struct station_parameters *params)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\ts32 err;\n\n\tbrcmf_dbg(TRACE, \"Enter, MAC %pM, mask 0x%04x set 0x%04x\\n\", mac,\n\t\t  params->sta_flags_mask, params->sta_flags_set);\n\n\t/* Ignore all 00 MAC */\n\tif (is_zero_ether_addr(mac))\n\t\treturn 0;\n\n\tif (!(params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)))\n\t\treturn 0;\n\n\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_AUTHORIZED))\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SCB_AUTHORIZE,\n\t\t\t\t\t     (void *)mac, ETH_ALEN);\n\telse\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SCB_DEAUTHORIZE,\n\t\t\t\t\t     (void *)mac, ETH_ALEN);\n\tif (err < 0)\n\t\tbphy_err(drvr, \"Setting SCB (de-)authorize failed, %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void\nbrcmf_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t       struct wireless_dev *wdev,\n\t\t\t\t\t       struct mgmt_frame_regs *upd)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\n\tvif->mgmt_rx_reg = upd->interface_stypes;\n}\n\n\nstatic int\nbrcmf_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t       struct cfg80211_mgmt_tx_params *params, u64 *cookie)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct ieee80211_channel *chan = params->chan;\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tconst u8 *buf = params->buf;\n\tsize_t len = params->len;\n\tconst struct ieee80211_mgmt *mgmt;\n\tstruct brcmf_cfg80211_vif *vif;\n\ts32 err = 0;\n\ts32 ie_offset;\n\ts32 ie_len;\n\tstruct brcmf_fil_action_frame_le *action_frame;\n\tstruct brcmf_fil_af_params_le *af_params;\n\tbool ack;\n\ts32 chan_nr;\n\tu32 freq;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\t*cookie = 0;\n\n\tmgmt = (const struct ieee80211_mgmt *)buf;\n\n\tif (!ieee80211_is_mgmt(mgmt->frame_control)) {\n\t\tbphy_err(drvr, \"Driver only allows MGMT packet type\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\n\tif (ieee80211_is_probe_resp(mgmt->frame_control)) {\n\t\t/* Right now the only reason to get a probe response */\n\t\t/* is for p2p listen response or for p2p GO from     */\n\t\t/* wpa_supplicant. Unfortunately the probe is send   */\n\t\t/* on primary ndev, while dongle wants it on the p2p */\n\t\t/* vif. Since this is only reason for a probe        */\n\t\t/* response to be sent, the vif is taken from cfg.   */\n\t\t/* If ever desired to send proberesp for non p2p     */\n\t\t/* response then data should be checked for          */\n\t\t/* \"DIRECT-\". Note in future supplicant will take    */\n\t\t/* dedicated p2p wdev to do this and then this 'hack'*/\n\t\t/* is not needed anymore.                            */\n\t\tie_offset =  DOT11_MGMT_HDR_LEN +\n\t\t\t     DOT11_BCN_PRB_FIXED_LEN;\n\t\tie_len = len - ie_offset;\n\t\tif (vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif)\n\t\t\tvif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\n\t\terr = brcmf_vif_set_mgmt_ie(vif,\n\t\t\t\t\t    BRCMF_VNDR_IE_PRBRSP_FLAG,\n\t\t\t\t\t    &buf[ie_offset],\n\t\t\t\t\t    ie_len);\n\t\tcfg80211_mgmt_tx_status(wdev, *cookie, buf, len, true,\n\t\t\t\t\tGFP_KERNEL);\n\t} else if (ieee80211_is_action(mgmt->frame_control)) {\n\t\tif (len > BRCMF_FIL_ACTION_FRAME_SIZE + DOT11_MGMT_HDR_LEN) {\n\t\t\tbphy_err(drvr, \"invalid action frame length\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\t\taf_params = kzalloc(sizeof(*af_params), GFP_KERNEL);\n\t\tif (af_params == NULL) {\n\t\t\tbphy_err(drvr, \"unable to allocate frame\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\taction_frame = &af_params->action_frame;\n\t\t/* Add the packet Id */\n\t\taction_frame->packet_id = cpu_to_le32(*cookie);\n\t\t/* Add BSSID */\n\t\tmemcpy(&action_frame->da[0], &mgmt->da[0], ETH_ALEN);\n\t\tmemcpy(&af_params->bssid[0], &mgmt->bssid[0], ETH_ALEN);\n\t\t/* Add the length exepted for 802.11 header  */\n\t\taction_frame->len = cpu_to_le16(len - DOT11_MGMT_HDR_LEN);\n\t\t/* Add the channel. Use the one specified as parameter if any or\n\t\t * the current one (got from the firmware) otherwise\n\t\t */\n\t\tif (chan)\n\t\t\tfreq = chan->center_freq;\n\t\telse\n\t\t\tbrcmf_fil_cmd_int_get(vif->ifp, BRCMF_C_GET_CHANNEL,\n\t\t\t\t\t      &freq);\n\t\tchan_nr = ieee80211_frequency_to_channel(freq);\n\t\taf_params->channel = cpu_to_le32(chan_nr);\n\t\taf_params->dwell_time = cpu_to_le32(params->wait);\n\t\tmemcpy(action_frame->data, &buf[DOT11_MGMT_HDR_LEN],\n\t\t       le16_to_cpu(action_frame->len));\n\n\t\tbrcmf_dbg(TRACE, \"Action frame, cookie=%lld, len=%d, freq=%d\\n\",\n\t\t\t  *cookie, le16_to_cpu(action_frame->len), freq);\n\n\t\tack = brcmf_p2p_send_action_frame(cfg, cfg_to_ndev(cfg),\n\t\t\t\t\t\t  af_params);\n\n\t\tcfg80211_mgmt_tx_status(wdev, *cookie, buf, len, ack,\n\t\t\t\t\tGFP_KERNEL);\n\t\tkfree(af_params);\n\t} else {\n\t\tbrcmf_dbg(TRACE, \"Unhandled, fc=%04x!!\\n\", mgmt->frame_control);\n\t\tbrcmf_dbg_hex_dump(true, buf, len, \"payload, len=%zu\\n\", len);\n\t}\n\nexit:\n\treturn err;\n}\n\n\nstatic int\nbrcmf_cfg80211_cancel_remain_on_channel(struct wiphy *wiphy,\n\t\t\t\t\tstruct wireless_dev *wdev,\n\t\t\t\t\tu64 cookie)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_cfg80211_vif *vif;\n\tint err = 0;\n\n\tbrcmf_dbg(TRACE, \"Enter p2p listen cancel\\n\");\n\n\tvif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\n\tif (vif == NULL) {\n\t\tbphy_err(drvr, \"No p2p device available for probe response\\n\");\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\tbrcmf_p2p_cancel_remain_on_channel(vif->ifp);\nexit:\n\treturn err;\n}\n\nstatic int brcmf_cfg80211_get_channel(struct wiphy *wiphy,\n\t\t\t\t      struct wireless_dev *wdev,\n\t\t\t\t      struct cfg80211_chan_def *chandef)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = wdev->netdev;\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmu_chan ch;\n\tenum nl80211_band band = 0;\n\tenum nl80211_chan_width width = 0;\n\tu32 chanspec;\n\tint freq, err;\n\n\tif (!ndev || drvr->bus_if->state != BRCMF_BUS_UP)\n\t\treturn -ENODEV;\n\n\terr = brcmf_fil_iovar_int_get(netdev_priv(ndev), \"chanspec\", &chanspec);\n\tif (err) {\n\t\tbphy_err(drvr, \"chanspec failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tch.chspec = chanspec;\n\tcfg->d11inf.decchspec(&ch);\n\n\tswitch (ch.band) {\n\tcase BRCMU_CHAN_BAND_2G:\n\t\tband = NL80211_BAND_2GHZ;\n\t\tbreak;\n\tcase BRCMU_CHAN_BAND_5G:\n\t\tband = NL80211_BAND_5GHZ;\n\t\tbreak;\n\t}\n\n\tswitch (ch.bw) {\n\tcase BRCMU_CHAN_BW_80:\n\t\twidth = NL80211_CHAN_WIDTH_80;\n\t\tbreak;\n\tcase BRCMU_CHAN_BW_40:\n\t\twidth = NL80211_CHAN_WIDTH_40;\n\t\tbreak;\n\tcase BRCMU_CHAN_BW_20:\n\t\twidth = NL80211_CHAN_WIDTH_20;\n\t\tbreak;\n\tcase BRCMU_CHAN_BW_80P80:\n\t\twidth = NL80211_CHAN_WIDTH_80P80;\n\t\tbreak;\n\tcase BRCMU_CHAN_BW_160:\n\t\twidth = NL80211_CHAN_WIDTH_160;\n\t\tbreak;\n\t}\n\n\tfreq = ieee80211_channel_to_frequency(ch.control_ch_num, band);\n\tchandef->chan = ieee80211_get_channel(wiphy, freq);\n\tchandef->width = width;\n\tchandef->center_freq1 = ieee80211_channel_to_frequency(ch.chnum, band);\n\tchandef->center_freq2 = 0;\n\n\treturn 0;\n}\n\nstatic int brcmf_cfg80211_crit_proto_start(struct wiphy *wiphy,\n\t\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t\t   enum nl80211_crit_proto_id proto,\n\t\t\t\t\t   u16 duration)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\n\t/* only DHCP support for now */\n\tif (proto != NL80211_CRIT_PROTO_DHCP)\n\t\treturn -EINVAL;\n\n\t/* suppress and abort scanning */\n\tset_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status);\n\tbrcmf_abort_scanning(cfg);\n\n\treturn brcmf_btcoex_set_mode(vif, BRCMF_BTCOEX_DISABLED, duration);\n}\n\nstatic void brcmf_cfg80211_crit_proto_stop(struct wiphy *wiphy,\n\t\t\t\t\t   struct wireless_dev *wdev)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\n\tbrcmf_btcoex_set_mode(vif, BRCMF_BTCOEX_ENABLED, 0);\n\tclear_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status);\n}\n\nstatic s32\nbrcmf_notify_tdls_peer_event(struct brcmf_if *ifp,\n\t\t\t     const struct brcmf_event_msg *e, void *data)\n{\n\tswitch (e->reason) {\n\tcase BRCMF_E_REASON_TDLS_PEER_DISCOVERED:\n\t\tbrcmf_dbg(TRACE, \"TDLS Peer Discovered\\n\");\n\t\tbreak;\n\tcase BRCMF_E_REASON_TDLS_PEER_CONNECTED:\n\t\tbrcmf_dbg(TRACE, \"TDLS Peer Connected\\n\");\n\t\tbrcmf_proto_add_tdls_peer(ifp->drvr, ifp->ifidx, (u8 *)e->addr);\n\t\tbreak;\n\tcase BRCMF_E_REASON_TDLS_PEER_DISCONNECTED:\n\t\tbrcmf_dbg(TRACE, \"TDLS Peer Disconnected\\n\");\n\t\tbrcmf_proto_delete_peer(ifp->drvr, ifp->ifidx, (u8 *)e->addr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int brcmf_convert_nl80211_tdls_oper(enum nl80211_tdls_operation oper)\n{\n\tint ret;\n\n\tswitch (oper) {\n\tcase NL80211_TDLS_DISCOVERY_REQ:\n\t\tret = BRCMF_TDLS_MANUAL_EP_DISCOVERY;\n\t\tbreak;\n\tcase NL80211_TDLS_SETUP:\n\t\tret = BRCMF_TDLS_MANUAL_EP_CREATE;\n\t\tbreak;\n\tcase NL80211_TDLS_TEARDOWN:\n\t\tret = BRCMF_TDLS_MANUAL_EP_DELETE;\n\t\tbreak;\n\tdefault:\n\t\tbrcmf_err(\"unsupported operation: %d\\n\", oper);\n\t\tret = -EOPNOTSUPP;\n\t}\n\treturn ret;\n}\n\nstatic int brcmf_cfg80211_tdls_oper(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *ndev, const u8 *peer,\n\t\t\t\t    enum nl80211_tdls_operation oper)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_if *ifp;\n\tstruct brcmf_tdls_iovar_le info;\n\tint ret = 0;\n\n\tret = brcmf_convert_nl80211_tdls_oper(oper);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tifp = netdev_priv(ndev);\n\tmemset(&info, 0, sizeof(info));\n\tinfo.mode = (u8)ret;\n\tif (peer)\n\t\tmemcpy(info.ea, peer, ETH_ALEN);\n\n\tret = brcmf_fil_iovar_data_set(ifp, \"tdls_endpoint\",\n\t\t\t\t       &info, sizeof(info));\n\tif (ret < 0)\n\t\tbphy_err(drvr, \"tdls_endpoint iovar failed: ret=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int\nbrcmf_cfg80211_update_conn_params(struct wiphy *wiphy,\n\t\t\t\t  struct net_device *ndev,\n\t\t\t\t  struct cfg80211_connect_params *sme,\n\t\t\t\t  u32 changed)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_if *ifp;\n\tint err;\n\n\tif (!(changed & UPDATE_ASSOC_IES))\n\t\treturn 0;\n\n\tifp = netdev_priv(ndev);\n\terr = brcmf_vif_set_mgmt_ie(ifp->vif, BRCMF_VNDR_IE_ASSOCREQ_FLAG,\n\t\t\t\t    sme->ie, sme->ie_len);\n\tif (err)\n\t\tbphy_err(drvr, \"Set Assoc REQ IE Failed\\n\");\n\telse\n\t\tbrcmf_dbg(TRACE, \"Applied Vndr IEs for Assoc request\\n\");\n\n\treturn err;\n}\n\n#ifdef CONFIG_PM\nstatic int\nbrcmf_cfg80211_set_rekey_data(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t      struct cfg80211_gtk_rekey_data *gtk)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_gtk_keyinfo_le gtk_le;\n\tint ret;\n\n\tbrcmf_dbg(TRACE, \"Enter, bssidx=%d\\n\", ifp->bsscfgidx);\n\n\tmemcpy(gtk_le.kck, gtk->kck, sizeof(gtk_le.kck));\n\tmemcpy(gtk_le.kek, gtk->kek, sizeof(gtk_le.kek));\n\tmemcpy(gtk_le.replay_counter, gtk->replay_ctr,\n\t       sizeof(gtk_le.replay_counter));\n\n\tret = brcmf_fil_iovar_data_set(ifp, \"gtk_key_info\", &gtk_le,\n\t\t\t\t       sizeof(gtk_le));\n\tif (ret < 0)\n\t\tbphy_err(drvr, \"gtk_key_info iovar failed: ret=%d\\n\", ret);\n\n\treturn ret;\n}\n#endif\n\nstatic int brcmf_cfg80211_set_pmk(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  const struct cfg80211_pmk_conf *conf)\n{\n\tstruct brcmf_if *ifp;\n\n\tbrcmf_dbg(TRACE, \"enter\\n\");\n\n\t/* expect using firmware supplicant for 1X */\n\tifp = netdev_priv(dev);\n\tif (WARN_ON(ifp->vif->profile.use_fwsup != BRCMF_PROFILE_FWSUP_1X))\n\t\treturn -EINVAL;\n\n\tif (conf->pmk_len > BRCMF_WSEC_MAX_PSK_LEN)\n\t\treturn -ERANGE;\n\n\treturn brcmf_set_pmk(ifp, conf->pmk, conf->pmk_len);\n}\n\nstatic int brcmf_cfg80211_del_pmk(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  const u8 *aa)\n{\n\tstruct brcmf_if *ifp;\n\n\tbrcmf_dbg(TRACE, \"enter\\n\");\n\tifp = netdev_priv(dev);\n\tif (WARN_ON(ifp->vif->profile.use_fwsup != BRCMF_PROFILE_FWSUP_1X))\n\t\treturn -EINVAL;\n\n\treturn brcmf_set_pmk(ifp, NULL, 0);\n}\n\nstatic struct cfg80211_ops brcmf_cfg80211_ops = {\n\t.add_virtual_intf = brcmf_cfg80211_add_iface,\n\t.del_virtual_intf = brcmf_cfg80211_del_iface,\n\t.change_virtual_intf = brcmf_cfg80211_change_iface,\n\t.scan = brcmf_cfg80211_scan,\n\t.set_wiphy_params = brcmf_cfg80211_set_wiphy_params,\n\t.join_ibss = brcmf_cfg80211_join_ibss,\n\t.leave_ibss = brcmf_cfg80211_leave_ibss,\n\t.get_station = brcmf_cfg80211_get_station,\n\t.dump_station = brcmf_cfg80211_dump_station,\n\t.set_tx_power = brcmf_cfg80211_set_tx_power,\n\t.get_tx_power = brcmf_cfg80211_get_tx_power,\n\t.add_key = brcmf_cfg80211_add_key,\n\t.del_key = brcmf_cfg80211_del_key,\n\t.get_key = brcmf_cfg80211_get_key,\n\t.set_default_key = brcmf_cfg80211_config_default_key,\n\t.set_default_mgmt_key = brcmf_cfg80211_config_default_mgmt_key,\n\t.set_power_mgmt = brcmf_cfg80211_set_power_mgmt,\n\t.connect = brcmf_cfg80211_connect,\n\t.disconnect = brcmf_cfg80211_disconnect,\n\t.suspend = brcmf_cfg80211_suspend,\n\t.resume = brcmf_cfg80211_resume,\n\t.set_pmksa = brcmf_cfg80211_set_pmksa,\n\t.del_pmksa = brcmf_cfg80211_del_pmksa,\n\t.flush_pmksa = brcmf_cfg80211_flush_pmksa,\n\t.start_ap = brcmf_cfg80211_start_ap,\n\t.stop_ap = brcmf_cfg80211_stop_ap,\n\t.change_beacon = brcmf_cfg80211_change_beacon,\n\t.del_station = brcmf_cfg80211_del_station,\n\t.change_station = brcmf_cfg80211_change_station,\n\t.sched_scan_start = brcmf_cfg80211_sched_scan_start,\n\t.sched_scan_stop = brcmf_cfg80211_sched_scan_stop,\n\t.update_mgmt_frame_registrations =\n\t\tbrcmf_cfg80211_update_mgmt_frame_registrations,\n\t.mgmt_tx = brcmf_cfg80211_mgmt_tx,\n\t.remain_on_channel = brcmf_p2p_remain_on_channel,\n\t.cancel_remain_on_channel = brcmf_cfg80211_cancel_remain_on_channel,\n\t.get_channel = brcmf_cfg80211_get_channel,\n\t.start_p2p_device = brcmf_p2p_start_device,\n\t.stop_p2p_device = brcmf_p2p_stop_device,\n\t.crit_proto_start = brcmf_cfg80211_crit_proto_start,\n\t.crit_proto_stop = brcmf_cfg80211_crit_proto_stop,\n\t.tdls_oper = brcmf_cfg80211_tdls_oper,\n\t.update_connect_params = brcmf_cfg80211_update_conn_params,\n\t.set_pmk = brcmf_cfg80211_set_pmk,\n\t.del_pmk = brcmf_cfg80211_del_pmk,\n};\n\nstruct cfg80211_ops *brcmf_cfg80211_get_ops(struct brcmf_mp_device *settings)\n{\n\tstruct cfg80211_ops *ops;\n\n\tops = kmemdup(&brcmf_cfg80211_ops, sizeof(brcmf_cfg80211_ops),\n\t\t       GFP_KERNEL);\n\n\tif (ops && settings->roamoff)\n\t\tops->update_connect_params = NULL;\n\n\treturn ops;\n}\n\nstruct brcmf_cfg80211_vif *brcmf_alloc_vif(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t\t   enum nl80211_iftype type)\n{\n\tstruct brcmf_cfg80211_vif *vif_walk;\n\tstruct brcmf_cfg80211_vif *vif;\n\tbool mbss;\n\tstruct brcmf_if *ifp = brcmf_get_ifp(cfg->pub, 0);\n\n\tbrcmf_dbg(TRACE, \"allocating virtual interface (size=%zu)\\n\",\n\t\t  sizeof(*vif));\n\tvif = kzalloc(sizeof(*vif), GFP_KERNEL);\n\tif (!vif)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvif->wdev.wiphy = cfg->wiphy;\n\tvif->wdev.iftype = type;\n\n\tbrcmf_init_prof(&vif->profile);\n\n\tif (type == NL80211_IFTYPE_AP &&\n\t    brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS)) {\n\t\tmbss = false;\n\t\tlist_for_each_entry(vif_walk, &cfg->vif_list, list) {\n\t\t\tif (vif_walk->wdev.iftype == NL80211_IFTYPE_AP) {\n\t\t\t\tmbss = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvif->mbss = mbss;\n\t}\n\n\tlist_add_tail(&vif->list, &cfg->vif_list);\n\treturn vif;\n}\n\nvoid brcmf_free_vif(struct brcmf_cfg80211_vif *vif)\n{\n\tlist_del(&vif->list);\n\tkfree(vif);\n}\n\nvoid brcmf_cfg80211_free_netdev(struct net_device *ndev)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct brcmf_if *ifp;\n\n\tifp = netdev_priv(ndev);\n\tvif = ifp->vif;\n\n\tif (vif)\n\t\tbrcmf_free_vif(vif);\n}\n\nstatic bool brcmf_is_linkup(struct brcmf_cfg80211_vif *vif,\n\t\t\t    const struct brcmf_event_msg *e)\n{\n\tu32 event = e->event_code;\n\tu32 status = e->status;\n\n\tif ((vif->profile.use_fwsup == BRCMF_PROFILE_FWSUP_PSK ||\n\t     vif->profile.use_fwsup == BRCMF_PROFILE_FWSUP_SAE) &&\n\t    event == BRCMF_E_PSK_SUP &&\n\t    status == BRCMF_E_STATUS_FWSUP_COMPLETED)\n\t\tset_bit(BRCMF_VIF_STATUS_EAP_SUCCESS, &vif->sme_state);\n\tif (event == BRCMF_E_SET_SSID && status == BRCMF_E_STATUS_SUCCESS) {\n\t\tbrcmf_dbg(CONN, \"Processing set ssid\\n\");\n\t\tmemcpy(vif->profile.bssid, e->addr, ETH_ALEN);\n\t\tif (vif->profile.use_fwsup != BRCMF_PROFILE_FWSUP_PSK &&\n\t\t    vif->profile.use_fwsup != BRCMF_PROFILE_FWSUP_SAE)\n\t\t\treturn true;\n\n\t\tset_bit(BRCMF_VIF_STATUS_ASSOC_SUCCESS, &vif->sme_state);\n\t}\n\n\tif (test_bit(BRCMF_VIF_STATUS_EAP_SUCCESS, &vif->sme_state) &&\n\t    test_bit(BRCMF_VIF_STATUS_ASSOC_SUCCESS, &vif->sme_state)) {\n\t\tclear_bit(BRCMF_VIF_STATUS_EAP_SUCCESS, &vif->sme_state);\n\t\tclear_bit(BRCMF_VIF_STATUS_ASSOC_SUCCESS, &vif->sme_state);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool brcmf_is_linkdown(const struct brcmf_event_msg *e)\n{\n\tu32 event = e->event_code;\n\tu16 flags = e->flags;\n\n\tif ((event == BRCMF_E_DEAUTH) || (event == BRCMF_E_DEAUTH_IND) ||\n\t    (event == BRCMF_E_DISASSOC_IND) ||\n\t    ((event == BRCMF_E_LINK) && (!(flags & BRCMF_EVENT_MSG_LINK)))) {\n\t\tbrcmf_dbg(CONN, \"Processing link down\\n\");\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool brcmf_is_nonetwork(struct brcmf_cfg80211_info *cfg,\n\t\t\t       const struct brcmf_event_msg *e)\n{\n\tu32 event = e->event_code;\n\tu32 status = e->status;\n\n\tif (event == BRCMF_E_LINK && status == BRCMF_E_STATUS_NO_NETWORKS) {\n\t\tbrcmf_dbg(CONN, \"Processing Link %s & no network found\\n\",\n\t\t\t  e->flags & BRCMF_EVENT_MSG_LINK ? \"up\" : \"down\");\n\t\treturn true;\n\t}\n\n\tif (event == BRCMF_E_SET_SSID && status != BRCMF_E_STATUS_SUCCESS) {\n\t\tbrcmf_dbg(CONN, \"Processing connecting & no network found\\n\");\n\t\treturn true;\n\t}\n\n\tif (event == BRCMF_E_PSK_SUP &&\n\t    status != BRCMF_E_STATUS_FWSUP_COMPLETED) {\n\t\tbrcmf_dbg(CONN, \"Processing failed supplicant state: %u\\n\",\n\t\t\t  status);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void brcmf_clear_assoc_ies(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);\n\n\tkfree(conn_info->req_ie);\n\tconn_info->req_ie = NULL;\n\tconn_info->req_ie_len = 0;\n\tkfree(conn_info->resp_ie);\n\tconn_info->resp_ie = NULL;\n\tconn_info->resp_ie_len = 0;\n}\n\nu8 brcmf_map_prio_to_prec(void *config, u8 prio)\n{\n\tstruct brcmf_cfg80211_info *cfg = (struct brcmf_cfg80211_info *)config;\n\n\tif (!cfg)\n\t\treturn (prio == PRIO_8021D_NONE || prio == PRIO_8021D_BE) ?\n\t\t       (prio ^ 2) : prio;\n\n\t/* For those AC(s) with ACM flag set to 1, convert its 4-level priority\n\t * to an 8-level precedence which is the same as BE's\n\t */\n\tif (prio > PRIO_8021D_EE &&\n\t    cfg->ac_priority[prio] == cfg->ac_priority[PRIO_8021D_BE])\n\t\treturn cfg->ac_priority[prio] * 2;\n\n\t/* Conversion of 4-level priority to 8-level precedence */\n\tif (prio == PRIO_8021D_BE || prio == PRIO_8021D_BK ||\n\t    prio == PRIO_8021D_CL || prio == PRIO_8021D_VO)\n\t\treturn cfg->ac_priority[prio] * 2;\n\telse\n\t\treturn cfg->ac_priority[prio] * 2 + 1;\n}\n\nu8 brcmf_map_prio_to_aci(void *config, u8 prio)\n{\n\t/* Prio here refers to the 802.1d priority in range of 0 to 7.\n\t * ACI here refers to the WLAN AC Index in range of 0 to 3.\n\t * This function will return ACI corresponding to input prio.\n\t */\n\tstruct brcmf_cfg80211_info *cfg = (struct brcmf_cfg80211_info *)config;\n\n\tif (cfg)\n\t\treturn cfg->ac_priority[prio];\n\n\treturn prio;\n}\n\nstatic void brcmf_init_wmm_prio(u8 *priority)\n{\n\t/* Initialize AC priority array to default\n\t * 802.1d priority as per following table:\n\t * 802.1d prio 0,3 maps to BE\n\t * 802.1d prio 1,2 maps to BK\n\t * 802.1d prio 4,5 maps to VI\n\t * 802.1d prio 6,7 maps to VO\n\t */\n\tpriority[0] = BRCMF_FWS_FIFO_AC_BE;\n\tpriority[3] = BRCMF_FWS_FIFO_AC_BE;\n\tpriority[1] = BRCMF_FWS_FIFO_AC_BK;\n\tpriority[2] = BRCMF_FWS_FIFO_AC_BK;\n\tpriority[4] = BRCMF_FWS_FIFO_AC_VI;\n\tpriority[5] = BRCMF_FWS_FIFO_AC_VI;\n\tpriority[6] = BRCMF_FWS_FIFO_AC_VO;\n\tpriority[7] = BRCMF_FWS_FIFO_AC_VO;\n}\n\nstatic void brcmf_wifi_prioritize_acparams(const\n\tstruct brcmf_cfg80211_edcf_acparam *acp, u8 *priority)\n{\n\tu8 aci;\n\tu8 aifsn;\n\tu8 ecwmin;\n\tu8 ecwmax;\n\tu8 acm;\n\tu8 ranking_basis[EDCF_AC_COUNT];\n\tu8 aci_prio[EDCF_AC_COUNT]; /* AC_BE, AC_BK, AC_VI, AC_VO */\n\tu8 index;\n\n\tfor (aci = 0; aci < EDCF_AC_COUNT; aci++, acp++) {\n\t\taifsn  = acp->ACI & EDCF_AIFSN_MASK;\n\t\tacm = (acp->ACI & EDCF_ACM_MASK) ? 1 : 0;\n\t\tecwmin = acp->ECW & EDCF_ECWMIN_MASK;\n\t\tecwmax = (acp->ECW & EDCF_ECWMAX_MASK) >> EDCF_ECWMAX_SHIFT;\n\t\tbrcmf_dbg(CONN, \"ACI %d aifsn %d acm %d ecwmin %d ecwmax %d\\n\",\n\t\t\t  aci, aifsn, acm, ecwmin, ecwmax);\n\t\t/* Default AC_VO will be the lowest ranking value */\n\t\tranking_basis[aci] = aifsn + ecwmin + ecwmax;\n\t\t/* Initialise priority starting at 0 (AC_BE) */\n\t\taci_prio[aci] = 0;\n\n\t\t/* If ACM is set, STA can't use this AC as per 802.11.\n\t\t * Change the ranking to BE\n\t\t */\n\t\tif (aci != AC_BE && aci != AC_BK && acm == 1)\n\t\t\tranking_basis[aci] = ranking_basis[AC_BE];\n\t}\n\n\t/* Ranking method which works for AC priority\n\t * swapping when values for cwmin, cwmax and aifsn are varied\n\t * Compare each aci_prio against each other aci_prio\n\t */\n\tfor (aci = 0; aci < EDCF_AC_COUNT; aci++) {\n\t\tfor (index = 0; index < EDCF_AC_COUNT; index++) {\n\t\t\tif (index != aci) {\n\t\t\t\t/* Smaller ranking value has higher priority,\n\t\t\t\t * so increment priority for each ACI which has\n\t\t\t\t * a higher ranking value\n\t\t\t\t */\n\t\t\t\tif (ranking_basis[aci] < ranking_basis[index])\n\t\t\t\t\taci_prio[aci]++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* By now, aci_prio[] will be in range of 0 to 3.\n\t * Use ACI prio to get the new priority value for\n\t * each 802.1d traffic type, in this range.\n\t */\n\tif (!(aci_prio[AC_BE] == aci_prio[AC_BK] &&\n\t      aci_prio[AC_BK] == aci_prio[AC_VI] &&\n\t      aci_prio[AC_VI] == aci_prio[AC_VO])) {\n\t\t/* 802.1d 0,3 maps to BE */\n\t\tpriority[0] = aci_prio[AC_BE];\n\t\tpriority[3] = aci_prio[AC_BE];\n\n\t\t/* 802.1d 1,2 maps to BK */\n\t\tpriority[1] = aci_prio[AC_BK];\n\t\tpriority[2] = aci_prio[AC_BK];\n\n\t\t/* 802.1d 4,5 maps to VO */\n\t\tpriority[4] = aci_prio[AC_VI];\n\t\tpriority[5] = aci_prio[AC_VI];\n\n\t\t/* 802.1d 6,7 maps to VO */\n\t\tpriority[6] = aci_prio[AC_VO];\n\t\tpriority[7] = aci_prio[AC_VO];\n\t} else {\n\t\t/* Initialize to default priority */\n\t\tbrcmf_init_wmm_prio(priority);\n\t}\n\n\tbrcmf_dbg(CONN, \"Adj prio BE 0->%d, BK 1->%d, BK 2->%d, BE 3->%d\\n\",\n\t\t  priority[0], priority[1], priority[2], priority[3]);\n\n\tbrcmf_dbg(CONN, \"Adj prio VI 4->%d, VI 5->%d, VO 6->%d, VO 7->%d\\n\",\n\t\t  priority[4], priority[5], priority[6], priority[7]);\n}\n\nstatic s32 brcmf_get_assoc_ies(struct brcmf_cfg80211_info *cfg,\n\t\t\t       struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_cfg80211_assoc_ielen_le *assoc_info;\n\tstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);\n\tstruct brcmf_cfg80211_edcf_acparam edcf_acparam_info[EDCF_AC_COUNT];\n\tu32 req_len;\n\tu32 resp_len;\n\ts32 err = 0;\n\n\tbrcmf_clear_assoc_ies(cfg);\n\n\terr = brcmf_fil_iovar_data_get(ifp, \"assoc_info\",\n\t\t\t\t       cfg->extra_buf, WL_ASSOC_INFO_MAX);\n\tif (err) {\n\t\tbphy_err(drvr, \"could not get assoc info (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tassoc_info =\n\t\t(struct brcmf_cfg80211_assoc_ielen_le *)cfg->extra_buf;\n\treq_len = le32_to_cpu(assoc_info->req_len);\n\tresp_len = le32_to_cpu(assoc_info->resp_len);\n\tif (req_len) {\n\t\terr = brcmf_fil_iovar_data_get(ifp, \"assoc_req_ies\",\n\t\t\t\t\t       cfg->extra_buf,\n\t\t\t\t\t       WL_ASSOC_INFO_MAX);\n\t\tif (err) {\n\t\t\tbphy_err(drvr, \"could not get assoc req (%d)\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tconn_info->req_ie_len = req_len;\n\t\tconn_info->req_ie =\n\t\t    kmemdup(cfg->extra_buf, conn_info->req_ie_len,\n\t\t\t    GFP_KERNEL);\n\t\tif (!conn_info->req_ie)\n\t\t\tconn_info->req_ie_len = 0;\n\t} else {\n\t\tconn_info->req_ie_len = 0;\n\t\tconn_info->req_ie = NULL;\n\t}\n\tif (resp_len) {\n\t\terr = brcmf_fil_iovar_data_get(ifp, \"assoc_resp_ies\",\n\t\t\t\t\t       cfg->extra_buf,\n\t\t\t\t\t       WL_ASSOC_INFO_MAX);\n\t\tif (err) {\n\t\t\tbphy_err(drvr, \"could not get assoc resp (%d)\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tconn_info->resp_ie_len = resp_len;\n\t\tconn_info->resp_ie =\n\t\t    kmemdup(cfg->extra_buf, conn_info->resp_ie_len,\n\t\t\t    GFP_KERNEL);\n\t\tif (!conn_info->resp_ie)\n\t\t\tconn_info->resp_ie_len = 0;\n\n\t\terr = brcmf_fil_iovar_data_get(ifp, \"wme_ac_sta\",\n\t\t\t\t\t       edcf_acparam_info,\n\t\t\t\t\t       sizeof(edcf_acparam_info));\n\t\tif (err) {\n\t\t\tbrcmf_err(\"could not get wme_ac_sta (%d)\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\tbrcmf_wifi_prioritize_acparams(edcf_acparam_info,\n\t\t\t\t\t       cfg->ac_priority);\n\t} else {\n\t\tconn_info->resp_ie_len = 0;\n\t\tconn_info->resp_ie = NULL;\n\t}\n\tbrcmf_dbg(CONN, \"req len (%d) resp len (%d)\\n\",\n\t\t  conn_info->req_ie_len, conn_info->resp_ie_len);\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_bss_roaming_done(struct brcmf_cfg80211_info *cfg,\n\t\t       struct net_device *ndev,\n\t\t       const struct brcmf_event_msg *e)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tstruct ieee80211_channel *notify_channel = NULL;\n\tstruct ieee80211_supported_band *band;\n\tstruct brcmf_bss_info_le *bi;\n\tstruct brcmu_chan ch;\n\tstruct cfg80211_roam_info roam_info = {};\n\tu32 freq;\n\ts32 err = 0;\n\tu8 *buf;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tbrcmf_get_assoc_ies(cfg, ifp);\n\tmemcpy(profile->bssid, e->addr, ETH_ALEN);\n\tbrcmf_update_bss_info(cfg, ifp);\n\n\tbuf = kzalloc(WL_BSS_INFO_MAX, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t/* data sent to dongle has to be little endian */\n\t*(__le32 *)buf = cpu_to_le32(WL_BSS_INFO_MAX);\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSS_INFO,\n\t\t\t\t     buf, WL_BSS_INFO_MAX);\n\n\tif (err)\n\t\tgoto done;\n\n\tbi = (struct brcmf_bss_info_le *)(buf + 4);\n\tch.chspec = le16_to_cpu(bi->chanspec);\n\tcfg->d11inf.decchspec(&ch);\n\n\tif (ch.band == BRCMU_CHAN_BAND_2G)\n\t\tband = wiphy->bands[NL80211_BAND_2GHZ];\n\telse\n\t\tband = wiphy->bands[NL80211_BAND_5GHZ];\n\n\tfreq = ieee80211_channel_to_frequency(ch.control_ch_num, band->band);\n\tnotify_channel = ieee80211_get_channel(wiphy, freq);\n\ndone:\n\tkfree(buf);\n\n\troam_info.channel = notify_channel;\n\troam_info.bssid = profile->bssid;\n\troam_info.req_ie = conn_info->req_ie;\n\troam_info.req_ie_len = conn_info->req_ie_len;\n\troam_info.resp_ie = conn_info->resp_ie;\n\troam_info.resp_ie_len = conn_info->resp_ie_len;\n\n\tcfg80211_roamed(ndev, &roam_info, GFP_KERNEL);\n\tbrcmf_dbg(CONN, \"Report roaming result\\n\");\n\n\tif (profile->use_fwsup == BRCMF_PROFILE_FWSUP_1X && profile->is_ft) {\n\t\tcfg80211_port_authorized(ndev, profile->bssid, GFP_KERNEL);\n\t\tbrcmf_dbg(CONN, \"Report port authorized\\n\");\n\t}\n\n\tset_bit(BRCMF_VIF_STATUS_CONNECTED, &ifp->vif->sme_state);\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn err;\n}\n\nstatic s32\nbrcmf_bss_connect_done(struct brcmf_cfg80211_info *cfg,\n\t\t       struct net_device *ndev, const struct brcmf_event_msg *e,\n\t\t       bool completed)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);\n\tstruct cfg80211_connect_resp_params conn_params;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (test_and_clear_bit(BRCMF_VIF_STATUS_CONNECTING,\n\t\t\t       &ifp->vif->sme_state)) {\n\t\tmemset(&conn_params, 0, sizeof(conn_params));\n\t\tif (completed) {\n\t\t\tbrcmf_get_assoc_ies(cfg, ifp);\n\t\t\tbrcmf_update_bss_info(cfg, ifp);\n\t\t\tset_bit(BRCMF_VIF_STATUS_CONNECTED,\n\t\t\t\t&ifp->vif->sme_state);\n\t\t\tconn_params.status = WLAN_STATUS_SUCCESS;\n\t\t} else {\n\t\t\tconn_params.status = WLAN_STATUS_AUTH_TIMEOUT;\n\t\t}\n\t\tconn_params.bssid = profile->bssid;\n\t\tconn_params.req_ie = conn_info->req_ie;\n\t\tconn_params.req_ie_len = conn_info->req_ie_len;\n\t\tconn_params.resp_ie = conn_info->resp_ie;\n\t\tconn_params.resp_ie_len = conn_info->resp_ie_len;\n\t\tcfg80211_connect_done(ndev, &conn_params, GFP_KERNEL);\n\t\tbrcmf_dbg(CONN, \"Report connect result - connection %s\\n\",\n\t\t\t  completed ? \"succeeded\" : \"failed\");\n\t}\n\tbrcmf_dbg(TRACE, \"Exit\\n\");\n\treturn 0;\n}\n\nstatic s32\nbrcmf_notify_connect_status_ap(struct brcmf_cfg80211_info *cfg,\n\t\t\t       struct net_device *ndev,\n\t\t\t       const struct brcmf_event_msg *e, void *data)\n{\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstatic int generation;\n\tu32 event = e->event_code;\n\tu32 reason = e->reason;\n\tstruct station_info *sinfo;\n\n\tbrcmf_dbg(CONN, \"event %s (%u), reason %d\\n\",\n\t\t  brcmf_fweh_event_name(event), event, reason);\n\tif (event == BRCMF_E_LINK && reason == BRCMF_E_REASON_LINK_BSSCFG_DIS &&\n\t    ndev != cfg_to_ndev(cfg)) {\n\t\tbrcmf_dbg(CONN, \"AP mode link down\\n\");\n\t\tcomplete(&cfg->vif_disabled);\n\t\treturn 0;\n\t}\n\n\tif (((event == BRCMF_E_ASSOC_IND) || (event == BRCMF_E_REASSOC_IND)) &&\n\t    (reason == BRCMF_E_STATUS_SUCCESS)) {\n\t\tif (!data) {\n\t\t\tbphy_err(drvr, \"No IEs present in ASSOC/REASSOC_IND\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsinfo = kzalloc(sizeof(*sinfo), GFP_KERNEL);\n\t\tif (!sinfo)\n\t\t\treturn -ENOMEM;\n\n\t\tsinfo->assoc_req_ies = data;\n\t\tsinfo->assoc_req_ies_len = e->datalen;\n\t\tgeneration++;\n\t\tsinfo->generation = generation;\n\t\tcfg80211_new_sta(ndev, e->addr, sinfo, GFP_KERNEL);\n\n\t\tkfree(sinfo);\n\t} else if ((event == BRCMF_E_DISASSOC_IND) ||\n\t\t   (event == BRCMF_E_DEAUTH_IND) ||\n\t\t   (event == BRCMF_E_DEAUTH)) {\n\t\tcfg80211_del_sta(ndev, e->addr, GFP_KERNEL);\n\t}\n\treturn 0;\n}\n\nstatic s32\nbrcmf_notify_connect_status(struct brcmf_if *ifp,\n\t\t\t    const struct brcmf_event_msg *e, void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tstruct net_device *ndev = ifp->ndev;\n\tstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\n\tstruct ieee80211_channel *chan;\n\ts32 err = 0;\n\n\tif ((e->event_code == BRCMF_E_DEAUTH) ||\n\t    (e->event_code == BRCMF_E_DEAUTH_IND) ||\n\t    (e->event_code == BRCMF_E_DISASSOC_IND) ||\n\t    ((e->event_code == BRCMF_E_LINK) && (!e->flags))) {\n\t\tbrcmf_proto_delete_peer(ifp->drvr, ifp->ifidx, (u8 *)e->addr);\n\t}\n\n\tif (brcmf_is_apmode(ifp->vif)) {\n\t\terr = brcmf_notify_connect_status_ap(cfg, ndev, e, data);\n\t} else if (brcmf_is_linkup(ifp->vif, e)) {\n\t\tbrcmf_dbg(CONN, \"Linkup\\n\");\n\t\tif (brcmf_is_ibssmode(ifp->vif)) {\n\t\t\tbrcmf_inform_ibss(cfg, ndev, e->addr);\n\t\t\tchan = ieee80211_get_channel(cfg->wiphy, cfg->channel);\n\t\t\tmemcpy(profile->bssid, e->addr, ETH_ALEN);\n\t\t\tcfg80211_ibss_joined(ndev, e->addr, chan, GFP_KERNEL);\n\t\t\tclear_bit(BRCMF_VIF_STATUS_CONNECTING,\n\t\t\t\t  &ifp->vif->sme_state);\n\t\t\tset_bit(BRCMF_VIF_STATUS_CONNECTED,\n\t\t\t\t&ifp->vif->sme_state);\n\t\t} else\n\t\t\tbrcmf_bss_connect_done(cfg, ndev, e, true);\n\t\tbrcmf_net_setcarrier(ifp, true);\n\t} else if (brcmf_is_linkdown(e)) {\n\t\tbrcmf_dbg(CONN, \"Linkdown\\n\");\n\t\tif (!brcmf_is_ibssmode(ifp->vif) &&\n\t\t    test_bit(BRCMF_VIF_STATUS_CONNECTED,\n\t\t\t     &ifp->vif->sme_state)) {\n\t\t\tif (memcmp(profile->bssid, e->addr, ETH_ALEN))\n\t\t\t\treturn err;\n\n\t\t\tbrcmf_bss_connect_done(cfg, ndev, e, false);\n\t\t\tbrcmf_link_down(ifp->vif,\n\t\t\t\t\tbrcmf_map_fw_linkdown_reason(e),\n\t\t\t\t\te->event_code &\n\t\t\t\t\t(BRCMF_E_DEAUTH_IND |\n\t\t\t\t\tBRCMF_E_DISASSOC_IND)\n\t\t\t\t\t? false : true);\n\t\t\tbrcmf_init_prof(ndev_to_prof(ndev));\n\t\t\tif (ndev != cfg_to_ndev(cfg))\n\t\t\t\tcomplete(&cfg->vif_disabled);\n\t\t\tbrcmf_net_setcarrier(ifp, false);\n\t\t}\n\t} else if (brcmf_is_nonetwork(cfg, e)) {\n\t\tif (brcmf_is_ibssmode(ifp->vif))\n\t\t\tclear_bit(BRCMF_VIF_STATUS_CONNECTING,\n\t\t\t\t  &ifp->vif->sme_state);\n\t\telse\n\t\t\tbrcmf_bss_connect_done(cfg, ndev, e, false);\n\t}\n\n\treturn err;\n}\n\nstatic s32\nbrcmf_notify_roaming_status(struct brcmf_if *ifp,\n\t\t\t    const struct brcmf_event_msg *e, void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tu32 event = e->event_code;\n\tu32 status = e->status;\n\n\tif (event == BRCMF_E_ROAM && status == BRCMF_E_STATUS_SUCCESS) {\n\t\tif (test_bit(BRCMF_VIF_STATUS_CONNECTED,\n\t\t\t     &ifp->vif->sme_state)) {\n\t\t\tbrcmf_bss_roaming_done(cfg, ifp->ndev, e);\n\t\t} else {\n\t\t\tbrcmf_bss_connect_done(cfg, ifp->ndev, e, true);\n\t\t\tbrcmf_net_setcarrier(ifp, true);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic s32\nbrcmf_notify_mic_status(struct brcmf_if *ifp,\n\t\t\tconst struct brcmf_event_msg *e, void *data)\n{\n\tu16 flags = e->flags;\n\tenum nl80211_key_type key_type;\n\n\tif (flags & BRCMF_EVENT_MSG_GROUP)\n\t\tkey_type = NL80211_KEYTYPE_GROUP;\n\telse\n\t\tkey_type = NL80211_KEYTYPE_PAIRWISE;\n\n\tcfg80211_michael_mic_failure(ifp->ndev, (u8 *)&e->addr, key_type, -1,\n\t\t\t\t     NULL, GFP_KERNEL);\n\n\treturn 0;\n}\n\nstatic s32 brcmf_notify_vif_event(struct brcmf_if *ifp,\n\t\t\t\t  const struct brcmf_event_msg *e, void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tstruct brcmf_if_event *ifevent = (struct brcmf_if_event *)data;\n\tstruct brcmf_cfg80211_vif_event *event = &cfg->vif_event;\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tbrcmf_dbg(TRACE, \"Enter: action %u flags %u ifidx %u bsscfgidx %u\\n\",\n\t\t  ifevent->action, ifevent->flags, ifevent->ifidx,\n\t\t  ifevent->bsscfgidx);\n\n\tspin_lock(&event->vif_event_lock);\n\tevent->action = ifevent->action;\n\tvif = event->vif;\n\n\tswitch (ifevent->action) {\n\tcase BRCMF_E_IF_ADD:\n\t\t/* waiting process may have timed out */\n\t\tif (!cfg->vif_event.vif) {\n\t\t\tspin_unlock(&event->vif_event_lock);\n\t\t\treturn -EBADF;\n\t\t}\n\n\t\tifp->vif = vif;\n\t\tvif->ifp = ifp;\n\t\tif (ifp->ndev) {\n\t\t\tvif->wdev.netdev = ifp->ndev;\n\t\t\tifp->ndev->ieee80211_ptr = &vif->wdev;\n\t\t\tSET_NETDEV_DEV(ifp->ndev, wiphy_dev(cfg->wiphy));\n\t\t}\n\t\tspin_unlock(&event->vif_event_lock);\n\t\twake_up(&event->vif_wq);\n\t\treturn 0;\n\n\tcase BRCMF_E_IF_DEL:\n\t\tspin_unlock(&event->vif_event_lock);\n\t\t/* event may not be upon user request */\n\t\tif (brcmf_cfg80211_vif_event_armed(cfg))\n\t\t\twake_up(&event->vif_wq);\n\t\treturn 0;\n\n\tcase BRCMF_E_IF_CHANGE:\n\t\tspin_unlock(&event->vif_event_lock);\n\t\twake_up(&event->vif_wq);\n\t\treturn 0;\n\n\tdefault:\n\t\tspin_unlock(&event->vif_event_lock);\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic void brcmf_init_conf(struct brcmf_cfg80211_conf *conf)\n{\n\tconf->frag_threshold = (u32)-1;\n\tconf->rts_threshold = (u32)-1;\n\tconf->retry_short = (u32)-1;\n\tconf->retry_long = (u32)-1;\n}\n\nstatic void brcmf_register_event_handlers(struct brcmf_cfg80211_info *cfg)\n{\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_LINK,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_DEAUTH_IND,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_DEAUTH,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_DISASSOC_IND,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ASSOC_IND,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_REASSOC_IND,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ROAM,\n\t\t\t    brcmf_notify_roaming_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_MIC_ERROR,\n\t\t\t    brcmf_notify_mic_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_SET_SSID,\n\t\t\t    brcmf_notify_connect_status);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_PFN_NET_FOUND,\n\t\t\t    brcmf_notify_sched_scan_results);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_IF,\n\t\t\t    brcmf_notify_vif_event);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_P2P_PROBEREQ_MSG,\n\t\t\t    brcmf_p2p_notify_rx_mgmt_p2p_probereq);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_P2P_DISC_LISTEN_COMPLETE,\n\t\t\t    brcmf_p2p_notify_listen_complete);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ACTION_FRAME_RX,\n\t\t\t    brcmf_p2p_notify_action_frame_rx);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ACTION_FRAME_COMPLETE,\n\t\t\t    brcmf_p2p_notify_action_tx_complete);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_ACTION_FRAME_OFF_CHAN_COMPLETE,\n\t\t\t    brcmf_p2p_notify_action_tx_complete);\n\tbrcmf_fweh_register(cfg->pub, BRCMF_E_PSK_SUP,\n\t\t\t    brcmf_notify_connect_status);\n}\n\nstatic void brcmf_deinit_priv_mem(struct brcmf_cfg80211_info *cfg)\n{\n\tkfree(cfg->conf);\n\tcfg->conf = NULL;\n\tkfree(cfg->extra_buf);\n\tcfg->extra_buf = NULL;\n\tkfree(cfg->wowl.nd);\n\tcfg->wowl.nd = NULL;\n\tkfree(cfg->wowl.nd_info);\n\tcfg->wowl.nd_info = NULL;\n\tkfree(cfg->escan_info.escan_buf);\n\tcfg->escan_info.escan_buf = NULL;\n}\n\nstatic s32 brcmf_init_priv_mem(struct brcmf_cfg80211_info *cfg)\n{\n\tcfg->conf = kzalloc(sizeof(*cfg->conf), GFP_KERNEL);\n\tif (!cfg->conf)\n\t\tgoto init_priv_mem_out;\n\tcfg->extra_buf = kzalloc(WL_EXTRA_BUF_MAX, GFP_KERNEL);\n\tif (!cfg->extra_buf)\n\t\tgoto init_priv_mem_out;\n\tcfg->wowl.nd = kzalloc(sizeof(*cfg->wowl.nd) + sizeof(u32), GFP_KERNEL);\n\tif (!cfg->wowl.nd)\n\t\tgoto init_priv_mem_out;\n\tcfg->wowl.nd_info = kzalloc(sizeof(*cfg->wowl.nd_info) +\n\t\t\t\t    sizeof(struct cfg80211_wowlan_nd_match *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!cfg->wowl.nd_info)\n\t\tgoto init_priv_mem_out;\n\tcfg->escan_info.escan_buf = kzalloc(BRCMF_ESCAN_BUF_SIZE, GFP_KERNEL);\n\tif (!cfg->escan_info.escan_buf)\n\t\tgoto init_priv_mem_out;\n\n\treturn 0;\n\ninit_priv_mem_out:\n\tbrcmf_deinit_priv_mem(cfg);\n\n\treturn -ENOMEM;\n}\n\nstatic s32 wl_init_priv(struct brcmf_cfg80211_info *cfg)\n{\n\ts32 err = 0;\n\n\tcfg->scan_request = NULL;\n\tcfg->pwr_save = true;\n\tcfg->dongle_up = false;\t\t/* dongle is not up yet */\n\terr = brcmf_init_priv_mem(cfg);\n\tif (err)\n\t\treturn err;\n\tbrcmf_register_event_handlers(cfg);\n\tmutex_init(&cfg->usr_sync);\n\tbrcmf_init_escan(cfg);\n\tbrcmf_init_conf(cfg->conf);\n\tbrcmf_init_wmm_prio(cfg->ac_priority);\n\tinit_completion(&cfg->vif_disabled);\n\treturn err;\n}\n\nstatic void wl_deinit_priv(struct brcmf_cfg80211_info *cfg)\n{\n\tcfg->dongle_up = false;\t/* dongle down */\n\tbrcmf_abort_scanning(cfg);\n\tbrcmf_deinit_priv_mem(cfg);\n}\n\nstatic void init_vif_event(struct brcmf_cfg80211_vif_event *event)\n{\n\tinit_waitqueue_head(&event->vif_wq);\n\tspin_lock_init(&event->vif_event_lock);\n}\n\nstatic s32 brcmf_dongle_roam(struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts32 err;\n\tu32 bcn_timeout;\n\t__le32 roamtrigger[2];\n\t__le32 roam_delta[2];\n\n\t/* Configure beacon timeout value based upon roaming setting */\n\tif (ifp->drvr->settings->roamoff)\n\t\tbcn_timeout = BRCMF_DEFAULT_BCN_TIMEOUT_ROAM_OFF;\n\telse\n\t\tbcn_timeout = BRCMF_DEFAULT_BCN_TIMEOUT_ROAM_ON;\n\terr = brcmf_fil_iovar_int_set(ifp, \"bcn_timeout\", bcn_timeout);\n\tif (err) {\n\t\tbphy_err(drvr, \"bcn_timeout error (%d)\\n\", err);\n\t\tgoto roam_setup_done;\n\t}\n\n\t/* Enable/Disable built-in roaming to allow supplicant to take care of\n\t * roaming.\n\t */\n\tbrcmf_dbg(INFO, \"Internal Roaming = %s\\n\",\n\t\t  ifp->drvr->settings->roamoff ? \"Off\" : \"On\");\n\terr = brcmf_fil_iovar_int_set(ifp, \"roam_off\",\n\t\t\t\t      ifp->drvr->settings->roamoff);\n\tif (err) {\n\t\tbphy_err(drvr, \"roam_off error (%d)\\n\", err);\n\t\tgoto roam_setup_done;\n\t}\n\n\troamtrigger[0] = cpu_to_le32(WL_ROAM_TRIGGER_LEVEL);\n\troamtrigger[1] = cpu_to_le32(BRCM_BAND_ALL);\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_ROAM_TRIGGER,\n\t\t\t\t     (void *)roamtrigger, sizeof(roamtrigger));\n\tif (err)\n\t\tbphy_err(drvr, \"WLC_SET_ROAM_TRIGGER error (%d)\\n\", err);\n\n\troam_delta[0] = cpu_to_le32(WL_ROAM_DELTA);\n\troam_delta[1] = cpu_to_le32(BRCM_BAND_ALL);\n\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_ROAM_DELTA,\n\t\t\t\t     (void *)roam_delta, sizeof(roam_delta));\n\tif (err)\n\t\tbphy_err(drvr, \"WLC_SET_ROAM_DELTA error (%d)\\n\", err);\n\n\treturn 0;\n\nroam_setup_done:\n\treturn err;\n}\n\nstatic s32\nbrcmf_dongle_scantime(struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\ts32 err = 0;\n\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_CHANNEL_TIME,\n\t\t\t\t    BRCMF_SCAN_CHANNEL_TIME);\n\tif (err) {\n\t\tbphy_err(drvr, \"Scan assoc time error (%d)\\n\", err);\n\t\tgoto dongle_scantime_out;\n\t}\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_UNASSOC_TIME,\n\t\t\t\t    BRCMF_SCAN_UNASSOC_TIME);\n\tif (err) {\n\t\tbphy_err(drvr, \"Scan unassoc time error (%d)\\n\", err);\n\t\tgoto dongle_scantime_out;\n\t}\n\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_PASSIVE_TIME,\n\t\t\t\t    BRCMF_SCAN_PASSIVE_TIME);\n\tif (err) {\n\t\tbphy_err(drvr, \"Scan passive time error (%d)\\n\", err);\n\t\tgoto dongle_scantime_out;\n\t}\n\ndongle_scantime_out:\n\treturn err;\n}\n\nstatic void brcmf_update_bw40_channel_flag(struct ieee80211_channel *channel,\n\t\t\t\t\t   struct brcmu_chan *ch)\n{\n\tu32 ht40_flag;\n\n\tht40_flag = channel->flags & IEEE80211_CHAN_NO_HT40;\n\tif (ch->sb == BRCMU_CHAN_SB_U) {\n\t\tif (ht40_flag == IEEE80211_CHAN_NO_HT40)\n\t\t\tchannel->flags &= ~IEEE80211_CHAN_NO_HT40;\n\t\tchannel->flags |= IEEE80211_CHAN_NO_HT40PLUS;\n\t} else {\n\t\t/* It should be one of\n\t\t * IEEE80211_CHAN_NO_HT40 or\n\t\t * IEEE80211_CHAN_NO_HT40PLUS\n\t\t */\n\t\tchannel->flags &= ~IEEE80211_CHAN_NO_HT40;\n\t\tif (ht40_flag == IEEE80211_CHAN_NO_HT40)\n\t\t\tchannel->flags |= IEEE80211_CHAN_NO_HT40MINUS;\n\t}\n}\n\nstatic int brcmf_construct_chaninfo(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t    u32 bw_cap[])\n{\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_if *ifp = brcmf_get_ifp(drvr, 0);\n\tstruct ieee80211_supported_band *band;\n\tstruct ieee80211_channel *channel;\n\tstruct brcmf_chanspec_list *list;\n\tstruct brcmu_chan ch;\n\tint err;\n\tu8 *pbuf;\n\tu32 i, j;\n\tu32 total;\n\tu32 chaninfo;\n\n\tpbuf = kzalloc(BRCMF_DCMD_MEDLEN, GFP_KERNEL);\n\n\tif (pbuf == NULL)\n\t\treturn -ENOMEM;\n\n\tlist = (struct brcmf_chanspec_list *)pbuf;\n\n\terr = brcmf_fil_iovar_data_get(ifp, \"chanspecs\", pbuf,\n\t\t\t\t       BRCMF_DCMD_MEDLEN);\n\tif (err) {\n\t\tbphy_err(drvr, \"get chanspecs error (%d)\\n\", err);\n\t\tgoto fail_pbuf;\n\t}\n\n\tband = wiphy->bands[NL80211_BAND_2GHZ];\n\tif (band)\n\t\tfor (i = 0; i < band->n_channels; i++)\n\t\t\tband->channels[i].flags = IEEE80211_CHAN_DISABLED;\n\tband = wiphy->bands[NL80211_BAND_5GHZ];\n\tif (band)\n\t\tfor (i = 0; i < band->n_channels; i++)\n\t\t\tband->channels[i].flags = IEEE80211_CHAN_DISABLED;\n\n\ttotal = le32_to_cpu(list->count);\n\tfor (i = 0; i < total; i++) {\n\t\tch.chspec = (u16)le32_to_cpu(list->element[i]);\n\t\tcfg->d11inf.decchspec(&ch);\n\n\t\tif (ch.band == BRCMU_CHAN_BAND_2G) {\n\t\t\tband = wiphy->bands[NL80211_BAND_2GHZ];\n\t\t} else if (ch.band == BRCMU_CHAN_BAND_5G) {\n\t\t\tband = wiphy->bands[NL80211_BAND_5GHZ];\n\t\t} else {\n\t\t\tbphy_err(drvr, \"Invalid channel Spec. 0x%x.\\n\",\n\t\t\t\t ch.chspec);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!band)\n\t\t\tcontinue;\n\t\tif (!(bw_cap[band->band] & WLC_BW_40MHZ_BIT) &&\n\t\t    ch.bw == BRCMU_CHAN_BW_40)\n\t\t\tcontinue;\n\t\tif (!(bw_cap[band->band] & WLC_BW_80MHZ_BIT) &&\n\t\t    ch.bw == BRCMU_CHAN_BW_80)\n\t\t\tcontinue;\n\n\t\tchannel = NULL;\n\t\tfor (j = 0; j < band->n_channels; j++) {\n\t\t\tif (band->channels[j].hw_value == ch.control_ch_num) {\n\t\t\t\tchannel = &band->channels[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!channel) {\n\t\t\t/* It seems firmware supports some channel we never\n\t\t\t * considered. Something new in IEEE standard?\n\t\t\t */\n\t\t\tbphy_err(drvr, \"Ignoring unexpected firmware channel %d\\n\",\n\t\t\t\t ch.control_ch_num);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (channel->orig_flags & IEEE80211_CHAN_DISABLED)\n\t\t\tcontinue;\n\n\t\t/* assuming the chanspecs order is HT20,\n\t\t * HT40 upper, HT40 lower, and VHT80.\n\t\t */\n\t\tswitch (ch.bw) {\n\t\tcase BRCMU_CHAN_BW_160:\n\t\t\tchannel->flags &= ~IEEE80211_CHAN_NO_160MHZ;\n\t\t\tbreak;\n\t\tcase BRCMU_CHAN_BW_80:\n\t\t\tchannel->flags &= ~IEEE80211_CHAN_NO_80MHZ;\n\t\t\tbreak;\n\t\tcase BRCMU_CHAN_BW_40:\n\t\t\tbrcmf_update_bw40_channel_flag(channel, &ch);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twiphy_warn(wiphy, \"Firmware reported unsupported bandwidth %d\\n\",\n\t\t\t\t   ch.bw);\n\t\t\tfallthrough;\n\t\tcase BRCMU_CHAN_BW_20:\n\t\t\t/* enable the channel and disable other bandwidths\n\t\t\t * for now as mentioned order assure they are enabled\n\t\t\t * for subsequent chanspecs.\n\t\t\t */\n\t\t\tchannel->flags = IEEE80211_CHAN_NO_HT40 |\n\t\t\t\t\t IEEE80211_CHAN_NO_80MHZ |\n\t\t\t\t\t IEEE80211_CHAN_NO_160MHZ;\n\t\t\tch.bw = BRCMU_CHAN_BW_20;\n\t\t\tcfg->d11inf.encchspec(&ch);\n\t\t\tchaninfo = ch.chspec;\n\t\t\terr = brcmf_fil_bsscfg_int_get(ifp, \"per_chan_info\",\n\t\t\t\t\t\t       &chaninfo);\n\t\t\tif (!err) {\n\t\t\t\tif (chaninfo & WL_CHAN_RADAR)\n\t\t\t\t\tchannel->flags |=\n\t\t\t\t\t\t(IEEE80211_CHAN_RADAR |\n\t\t\t\t\t\t IEEE80211_CHAN_NO_IR);\n\t\t\t\tif (chaninfo & WL_CHAN_PASSIVE)\n\t\t\t\t\tchannel->flags |=\n\t\t\t\t\t\tIEEE80211_CHAN_NO_IR;\n\t\t\t}\n\t\t}\n\t}\n\nfail_pbuf:\n\tkfree(pbuf);\n\treturn err;\n}\n\nstatic int brcmf_enable_bw40_2g(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_if *ifp = brcmf_get_ifp(drvr, 0);\n\tstruct ieee80211_supported_band *band;\n\tstruct brcmf_fil_bwcap_le band_bwcap;\n\tstruct brcmf_chanspec_list *list;\n\tu8 *pbuf;\n\tu32 val;\n\tint err;\n\tstruct brcmu_chan ch;\n\tu32 num_chan;\n\tint i, j;\n\n\t/* verify support for bw_cap command */\n\tval = WLC_BAND_5G;\n\terr = brcmf_fil_iovar_int_get(ifp, \"bw_cap\", &val);\n\n\tif (!err) {\n\t\t/* only set 2G bandwidth using bw_cap command */\n\t\tband_bwcap.band = cpu_to_le32(WLC_BAND_2G);\n\t\tband_bwcap.bw_cap = cpu_to_le32(WLC_BW_CAP_40MHZ);\n\t\terr = brcmf_fil_iovar_data_set(ifp, \"bw_cap\", &band_bwcap,\n\t\t\t\t\t       sizeof(band_bwcap));\n\t} else {\n\t\tbrcmf_dbg(INFO, \"fallback to mimo_bw_cap\\n\");\n\t\tval = WLC_N_BW_40ALL;\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"mimo_bw_cap\", val);\n\t}\n\n\tif (!err) {\n\t\t/* update channel info in 2G band */\n\t\tpbuf = kzalloc(BRCMF_DCMD_MEDLEN, GFP_KERNEL);\n\n\t\tif (pbuf == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tch.band = BRCMU_CHAN_BAND_2G;\n\t\tch.bw = BRCMU_CHAN_BW_40;\n\t\tch.sb = BRCMU_CHAN_SB_NONE;\n\t\tch.chnum = 0;\n\t\tcfg->d11inf.encchspec(&ch);\n\n\t\t/* pass encoded chanspec in query */\n\t\t*(__le16 *)pbuf = cpu_to_le16(ch.chspec);\n\n\t\terr = brcmf_fil_iovar_data_get(ifp, \"chanspecs\", pbuf,\n\t\t\t\t\t       BRCMF_DCMD_MEDLEN);\n\t\tif (err) {\n\t\t\tbphy_err(drvr, \"get chanspecs error (%d)\\n\", err);\n\t\t\tkfree(pbuf);\n\t\t\treturn err;\n\t\t}\n\n\t\tband = cfg_to_wiphy(cfg)->bands[NL80211_BAND_2GHZ];\n\t\tlist = (struct brcmf_chanspec_list *)pbuf;\n\t\tnum_chan = le32_to_cpu(list->count);\n\t\tfor (i = 0; i < num_chan; i++) {\n\t\t\tch.chspec = (u16)le32_to_cpu(list->element[i]);\n\t\t\tcfg->d11inf.decchspec(&ch);\n\t\t\tif (WARN_ON(ch.band != BRCMU_CHAN_BAND_2G))\n\t\t\t\tcontinue;\n\t\t\tif (WARN_ON(ch.bw != BRCMU_CHAN_BW_40))\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < band->n_channels; j++) {\n\t\t\t\tif (band->channels[j].hw_value == ch.control_ch_num)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (WARN_ON(j == band->n_channels))\n\t\t\t\tcontinue;\n\n\t\t\tbrcmf_update_bw40_channel_flag(&band->channels[j], &ch);\n\t\t}\n\t\tkfree(pbuf);\n\t}\n\treturn err;\n}\n\nstatic void brcmf_get_bwcap(struct brcmf_if *ifp, u32 bw_cap[])\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tu32 band, mimo_bwcap;\n\tint err;\n\n\tband = WLC_BAND_2G;\n\terr = brcmf_fil_iovar_int_get(ifp, \"bw_cap\", &band);\n\tif (!err) {\n\t\tbw_cap[NL80211_BAND_2GHZ] = band;\n\t\tband = WLC_BAND_5G;\n\t\terr = brcmf_fil_iovar_int_get(ifp, \"bw_cap\", &band);\n\t\tif (!err) {\n\t\t\tbw_cap[NL80211_BAND_5GHZ] = band;\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tbrcmf_dbg(INFO, \"fallback to mimo_bw_cap info\\n\");\n\tmimo_bwcap = 0;\n\terr = brcmf_fil_iovar_int_get(ifp, \"mimo_bw_cap\", &mimo_bwcap);\n\tif (err)\n\t\t/* assume 20MHz if firmware does not give a clue */\n\t\tmimo_bwcap = WLC_N_BW_20ALL;\n\n\tswitch (mimo_bwcap) {\n\tcase WLC_N_BW_40ALL:\n\t\tbw_cap[NL80211_BAND_2GHZ] |= WLC_BW_40MHZ_BIT;\n\t\tfallthrough;\n\tcase WLC_N_BW_20IN2G_40IN5G:\n\t\tbw_cap[NL80211_BAND_5GHZ] |= WLC_BW_40MHZ_BIT;\n\t\tfallthrough;\n\tcase WLC_N_BW_20ALL:\n\t\tbw_cap[NL80211_BAND_2GHZ] |= WLC_BW_20MHZ_BIT;\n\t\tbw_cap[NL80211_BAND_5GHZ] |= WLC_BW_20MHZ_BIT;\n\t\tbreak;\n\tdefault:\n\t\tbphy_err(drvr, \"invalid mimo_bw_cap value\\n\");\n\t}\n}\n\nstatic void brcmf_update_ht_cap(struct ieee80211_supported_band *band,\n\t\t\t\tu32 bw_cap[2], u32 nchain)\n{\n\tband->ht_cap.ht_supported = true;\n\tif (bw_cap[band->band] & WLC_BW_40MHZ_BIT) {\n\t\tband->ht_cap.cap |= IEEE80211_HT_CAP_SGI_40;\n\t\tband->ht_cap.cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t}\n\tband->ht_cap.cap |= IEEE80211_HT_CAP_SGI_20;\n\tband->ht_cap.cap |= IEEE80211_HT_CAP_DSSSCCK40;\n\tband->ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\tband->ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16;\n\tmemset(band->ht_cap.mcs.rx_mask, 0xff, nchain);\n\tband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n}\n\nstatic __le16 brcmf_get_mcs_map(u32 nchain, enum ieee80211_vht_mcs_support supp)\n{\n\tu16 mcs_map;\n\tint i;\n\n\tfor (i = 0, mcs_map = 0xFFFF; i < nchain; i++)\n\t\tmcs_map = (mcs_map << 2) | supp;\n\n\treturn cpu_to_le16(mcs_map);\n}\n\nstatic void brcmf_update_vht_cap(struct ieee80211_supported_band *band,\n\t\t\t\t u32 bw_cap[2], u32 nchain, u32 txstreams,\n\t\t\t\t u32 txbf_bfe_cap, u32 txbf_bfr_cap)\n{\n\t__le16 mcs_map;\n\n\t/* not allowed in 2.4G band */\n\tif (band->band == NL80211_BAND_2GHZ)\n\t\treturn;\n\n\tband->vht_cap.vht_supported = true;\n\t/* 80MHz is mandatory */\n\tband->vht_cap.cap |= IEEE80211_VHT_CAP_SHORT_GI_80;\n\tif (bw_cap[band->band] & WLC_BW_160MHZ_BIT) {\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_SHORT_GI_160;\n\t}\n\t/* all support 256-QAM */\n\tmcs_map = brcmf_get_mcs_map(nchain, IEEE80211_VHT_MCS_SUPPORT_0_9);\n\tband->vht_cap.vht_mcs.rx_mcs_map = mcs_map;\n\tband->vht_cap.vht_mcs.tx_mcs_map = mcs_map;\n\n\t/* Beamforming support information */\n\tif (txbf_bfe_cap & BRCMF_TXBF_SU_BFE_CAP)\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE;\n\tif (txbf_bfe_cap & BRCMF_TXBF_MU_BFE_CAP)\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE;\n\tif (txbf_bfr_cap & BRCMF_TXBF_SU_BFR_CAP)\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE;\n\tif (txbf_bfr_cap & BRCMF_TXBF_MU_BFR_CAP)\n\t\tband->vht_cap.cap |= IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE;\n\n\tif ((txbf_bfe_cap || txbf_bfr_cap) && (txstreams > 1)) {\n\t\tband->vht_cap.cap |=\n\t\t\t(2 << IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT);\n\t\tband->vht_cap.cap |= ((txstreams - 1) <<\n\t\t\t\tIEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT);\n\t\tband->vht_cap.cap |=\n\t\t\tIEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_MRQ_MFB;\n\t}\n}\n\nstatic int brcmf_setup_wiphybands(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_if *ifp = brcmf_get_ifp(drvr, 0);\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tu32 nmode = 0;\n\tu32 vhtmode = 0;\n\tu32 bw_cap[2] = { WLC_BW_20MHZ_BIT, WLC_BW_20MHZ_BIT };\n\tu32 rxchain;\n\tu32 nchain;\n\tint err;\n\ts32 i;\n\tstruct ieee80211_supported_band *band;\n\tu32 txstreams = 0;\n\tu32 txbf_bfe_cap = 0;\n\tu32 txbf_bfr_cap = 0;\n\n\t(void)brcmf_fil_iovar_int_get(ifp, \"vhtmode\", &vhtmode);\n\terr = brcmf_fil_iovar_int_get(ifp, \"nmode\", &nmode);\n\tif (err) {\n\t\tbphy_err(drvr, \"nmode error (%d)\\n\", err);\n\t} else {\n\t\tbrcmf_get_bwcap(ifp, bw_cap);\n\t}\n\tbrcmf_dbg(INFO, \"nmode=%d, vhtmode=%d, bw_cap=(%d, %d)\\n\",\n\t\t  nmode, vhtmode, bw_cap[NL80211_BAND_2GHZ],\n\t\t  bw_cap[NL80211_BAND_5GHZ]);\n\n\terr = brcmf_fil_iovar_int_get(ifp, \"rxchain\", &rxchain);\n\tif (err) {\n\t\tbphy_err(drvr, \"rxchain error (%d)\\n\", err);\n\t\tnchain = 1;\n\t} else {\n\t\tfor (nchain = 0; rxchain; nchain++)\n\t\t\trxchain = rxchain & (rxchain - 1);\n\t}\n\tbrcmf_dbg(INFO, \"nchain=%d\\n\", nchain);\n\n\terr = brcmf_construct_chaninfo(cfg, bw_cap);\n\tif (err) {\n\t\tbphy_err(drvr, \"brcmf_construct_chaninfo failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (vhtmode) {\n\t\t(void)brcmf_fil_iovar_int_get(ifp, \"txstreams\", &txstreams);\n\t\t(void)brcmf_fil_iovar_int_get(ifp, \"txbf_bfe_cap\",\n\t\t\t\t\t      &txbf_bfe_cap);\n\t\t(void)brcmf_fil_iovar_int_get(ifp, \"txbf_bfr_cap\",\n\t\t\t\t\t      &txbf_bfr_cap);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(wiphy->bands); i++) {\n\t\tband = wiphy->bands[i];\n\t\tif (band == NULL)\n\t\t\tcontinue;\n\n\t\tif (nmode)\n\t\t\tbrcmf_update_ht_cap(band, bw_cap, nchain);\n\t\tif (vhtmode)\n\t\t\tbrcmf_update_vht_cap(band, bw_cap, nchain, txstreams,\n\t\t\t\t\t     txbf_bfe_cap, txbf_bfr_cap);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ieee80211_txrx_stypes\nbrcmf_txrx_stypes[NUM_NL80211_IFTYPES] = {\n\t[NL80211_IFTYPE_STATION] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_CLIENT] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_GO] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |\n\t\t      BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\t      BIT(IEEE80211_STYPE_DISASSOC >> 4) |\n\t\t      BIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\t      BIT(IEEE80211_STYPE_DEAUTH >> 4) |\n\t\t      BIT(IEEE80211_STYPE_ACTION >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_DEVICE] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t},\n\t[NL80211_IFTYPE_AP] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |\n\t\t      BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |\n\t\t      BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\t      BIT(IEEE80211_STYPE_DISASSOC >> 4) |\n\t\t      BIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\t      BIT(IEEE80211_STYPE_DEAUTH >> 4) |\n\t\t      BIT(IEEE80211_STYPE_ACTION >> 4)\n\t}\n};\n\n/**\n * brcmf_setup_ifmodes() - determine interface modes and combinations.\n *\n * @wiphy: wiphy object.\n * @ifp: interface object needed for feat module api.\n *\n * The interface modes and combinations are determined dynamically here\n * based on firmware functionality.\n *\n * no p2p and no mbss:\n *\n *\t#STA <= 1, #AP <= 1, channels = 1, 2 total\n *\n * no p2p and mbss:\n *\n *\t#STA <= 1, #AP <= 1, channels = 1, 2 total\n *\t#AP <= 4, matching BI, channels = 1, 4 total\n *\n * no p2p and rsdb:\n *\t#STA <= 1, #AP <= 2, channels = 2, 4 total\n *\n * p2p, no mchan, and mbss:\n *\n *\t#STA <= 1, #P2P-DEV <= 1, #{P2P-CL, P2P-GO} <= 1, channels = 1, 3 total\n *\t#STA <= 1, #P2P-DEV <= 1, #AP <= 1, #P2P-CL <= 1, channels = 1, 4 total\n *\t#AP <= 4, matching BI, channels = 1, 4 total\n *\n * p2p, mchan, and mbss:\n *\n *\t#STA <= 1, #P2P-DEV <= 1, #{P2P-CL, P2P-GO} <= 1, channels = 2, 3 total\n *\t#STA <= 1, #P2P-DEV <= 1, #AP <= 1, #P2P-CL <= 1, channels = 1, 4 total\n *\t#AP <= 4, matching BI, channels = 1, 4 total\n *\n * p2p, rsdb, and no mbss:\n *\t#STA <= 1, #P2P-DEV <= 1, #{P2P-CL, P2P-GO} <= 2, AP <= 2,\n *\t channels = 2, 4 total\n */\nstatic int brcmf_setup_ifmodes(struct wiphy *wiphy, struct brcmf_if *ifp)\n{\n\tstruct ieee80211_iface_combination *combo = NULL;\n\tstruct ieee80211_iface_limit *c0_limits = NULL;\n\tstruct ieee80211_iface_limit *p2p_limits = NULL;\n\tstruct ieee80211_iface_limit *mbss_limits = NULL;\n\tbool mon_flag, mbss, p2p, rsdb, mchan;\n\tint i, c, n_combos, n_limits;\n\n\tmon_flag = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MONITOR_FLAG);\n\tmbss = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS);\n\tp2p = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_P2P);\n\trsdb = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB);\n\tmchan = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MCHAN);\n\n\tn_combos = 1 + !!(p2p && !rsdb) + !!mbss;\n\tcombo = kcalloc(n_combos, sizeof(*combo), GFP_KERNEL);\n\tif (!combo)\n\t\tgoto err;\n\n\twiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t BIT(NL80211_IFTYPE_ADHOC) |\n\t\t\t\t BIT(NL80211_IFTYPE_AP);\n\tif (mon_flag)\n\t\twiphy->interface_modes |= BIT(NL80211_IFTYPE_MONITOR);\n\tif (p2p)\n\t\twiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t\t\t  BIT(NL80211_IFTYPE_P2P_GO) |\n\t\t\t\t\t  BIT(NL80211_IFTYPE_P2P_DEVICE);\n\n\tc = 0;\n\ti = 0;\n\tn_limits = 1 + mon_flag + (p2p ? 2 : 0) + (rsdb || !p2p);\n\tc0_limits = kcalloc(n_limits, sizeof(*c0_limits), GFP_KERNEL);\n\tif (!c0_limits)\n\t\tgoto err;\n\n\tcombo[c].num_different_channels = 1 + (rsdb || (p2p && mchan));\n\tc0_limits[i].max = 1;\n\tc0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);\n\tif (mon_flag) {\n\t\tc0_limits[i].max = 1;\n\t\tc0_limits[i++].types = BIT(NL80211_IFTYPE_MONITOR);\n\t}\n\tif (p2p) {\n\t\tc0_limits[i].max = 1;\n\t\tc0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_DEVICE);\n\t\tc0_limits[i].max = 1 + rsdb;\n\t\tc0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t\t       BIT(NL80211_IFTYPE_P2P_GO);\n\t}\n\tif (p2p && rsdb) {\n\t\tc0_limits[i].max = 2;\n\t\tc0_limits[i++].types = BIT(NL80211_IFTYPE_AP);\n\t\tcombo[c].max_interfaces = 4;\n\t} else if (p2p) {\n\t\tcombo[c].max_interfaces = i;\n\t} else if (rsdb) {\n\t\tc0_limits[i].max = 2;\n\t\tc0_limits[i++].types = BIT(NL80211_IFTYPE_AP);\n\t\tcombo[c].max_interfaces = 3;\n\t} else {\n\t\tc0_limits[i].max = 1;\n\t\tc0_limits[i++].types = BIT(NL80211_IFTYPE_AP);\n\t\tcombo[c].max_interfaces = i;\n\t}\n\tcombo[c].n_limits = i;\n\tcombo[c].limits = c0_limits;\n\n\tif (p2p && !rsdb) {\n\t\tc++;\n\t\ti = 0;\n\t\tp2p_limits = kcalloc(4, sizeof(*p2p_limits), GFP_KERNEL);\n\t\tif (!p2p_limits)\n\t\t\tgoto err;\n\t\tp2p_limits[i].max = 1;\n\t\tp2p_limits[i++].types = BIT(NL80211_IFTYPE_STATION);\n\t\tp2p_limits[i].max = 1;\n\t\tp2p_limits[i++].types = BIT(NL80211_IFTYPE_AP);\n\t\tp2p_limits[i].max = 1;\n\t\tp2p_limits[i++].types = BIT(NL80211_IFTYPE_P2P_CLIENT);\n\t\tp2p_limits[i].max = 1;\n\t\tp2p_limits[i++].types = BIT(NL80211_IFTYPE_P2P_DEVICE);\n\t\tcombo[c].num_different_channels = 1;\n\t\tcombo[c].max_interfaces = i;\n\t\tcombo[c].n_limits = i;\n\t\tcombo[c].limits = p2p_limits;\n\t}\n\n\tif (mbss) {\n\t\tc++;\n\t\ti = 0;\n\t\tn_limits = 1 + mon_flag;\n\t\tmbss_limits = kcalloc(n_limits, sizeof(*mbss_limits),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!mbss_limits)\n\t\t\tgoto err;\n\t\tmbss_limits[i].max = 4;\n\t\tmbss_limits[i++].types = BIT(NL80211_IFTYPE_AP);\n\t\tif (mon_flag) {\n\t\t\tmbss_limits[i].max = 1;\n\t\t\tmbss_limits[i++].types = BIT(NL80211_IFTYPE_MONITOR);\n\t\t}\n\t\tcombo[c].beacon_int_infra_match = true;\n\t\tcombo[c].num_different_channels = 1;\n\t\tcombo[c].max_interfaces = 4 + mon_flag;\n\t\tcombo[c].n_limits = i;\n\t\tcombo[c].limits = mbss_limits;\n\t}\n\n\twiphy->n_iface_combinations = n_combos;\n\twiphy->iface_combinations = combo;\n\treturn 0;\n\nerr:\n\tkfree(c0_limits);\n\tkfree(p2p_limits);\n\tkfree(mbss_limits);\n\tkfree(combo);\n\treturn -ENOMEM;\n}\n\n#ifdef CONFIG_PM\nstatic const struct wiphy_wowlan_support brcmf_wowlan_support = {\n\t.flags = WIPHY_WOWLAN_MAGIC_PKT | WIPHY_WOWLAN_DISCONNECT,\n\t.n_patterns = BRCMF_WOWL_MAXPATTERNS,\n\t.pattern_max_len = BRCMF_WOWL_MAXPATTERNSIZE,\n\t.pattern_min_len = 1,\n\t.max_pkt_offset = 1500,\n};\n#endif\n\nstatic void brcmf_wiphy_wowl_params(struct wiphy *wiphy, struct brcmf_if *ifp)\n{\n#ifdef CONFIG_PM\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct wiphy_wowlan_support *wowl;\n\n\twowl = kmemdup(&brcmf_wowlan_support, sizeof(brcmf_wowlan_support),\n\t\t       GFP_KERNEL);\n\tif (!wowl) {\n\t\tbphy_err(drvr, \"only support basic wowlan features\\n\");\n\t\twiphy->wowlan = &brcmf_wowlan_support;\n\t\treturn;\n\t}\n\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_PNO)) {\n\t\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_ND)) {\n\t\t\twowl->flags |= WIPHY_WOWLAN_NET_DETECT;\n\t\t\twowl->max_nd_match_sets = BRCMF_PNO_MAX_PFN_COUNT;\n\t\t\tinit_waitqueue_head(&cfg->wowl.nd_data_wait);\n\t\t}\n\t}\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_GTK)) {\n\t\twowl->flags |= WIPHY_WOWLAN_SUPPORTS_GTK_REKEY;\n\t\twowl->flags |= WIPHY_WOWLAN_GTK_REKEY_FAILURE;\n\t}\n\n\twiphy->wowlan = wowl;\n#endif\n}\n\nstatic int brcmf_setup_wiphy(struct wiphy *wiphy, struct brcmf_if *ifp)\n{\n\tstruct brcmf_pub *drvr = ifp->drvr;\n\tconst struct ieee80211_iface_combination *combo;\n\tstruct ieee80211_supported_band *band;\n\tu16 max_interfaces = 0;\n\tbool gscan;\n\t__le32 bandlist[3];\n\tu32 n_bands;\n\tint err, i;\n\n\twiphy->max_scan_ssids = WL_NUM_SCAN_MAX;\n\twiphy->max_scan_ie_len = BRCMF_SCAN_IE_LEN_MAX;\n\twiphy->max_num_pmkids = BRCMF_MAXPMKID;\n\n\terr = brcmf_setup_ifmodes(wiphy, ifp);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0, combo = wiphy->iface_combinations;\n\t     i < wiphy->n_iface_combinations; i++, combo++) {\n\t\tmax_interfaces = max(max_interfaces, combo->max_interfaces);\n\t}\n\n\tfor (i = 0; i < max_interfaces && i < ARRAY_SIZE(drvr->addresses);\n\t     i++) {\n\t\tu8 *addr = drvr->addresses[i].addr;\n\n\t\tmemcpy(addr, drvr->mac, ETH_ALEN);\n\t\tif (i) {\n\t\t\taddr[0] |= BIT(1);\n\t\t\taddr[ETH_ALEN - 1] ^= i;\n\t\t}\n\t}\n\twiphy->addresses = drvr->addresses;\n\twiphy->n_addresses = i;\n\n\twiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\n\twiphy->cipher_suites = brcmf_cipher_suites;\n\twiphy->n_cipher_suites = ARRAY_SIZE(brcmf_cipher_suites);\n\tif (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP))\n\t\twiphy->n_cipher_suites--;\n\twiphy->bss_select_support = BIT(NL80211_BSS_SELECT_ATTR_RSSI) |\n\t\t\t\t    BIT(NL80211_BSS_SELECT_ATTR_BAND_PREF) |\n\t\t\t\t    BIT(NL80211_BSS_SELECT_ATTR_RSSI_ADJUST);\n\n\twiphy->flags |= WIPHY_FLAG_NETNS_OK |\n\t\t\tWIPHY_FLAG_PS_ON_BY_DEFAULT |\n\t\t\tWIPHY_FLAG_HAVE_AP_SME |\n\t\t\tWIPHY_FLAG_OFFCHAN_TX |\n\t\t\tWIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_TDLS))\n\t\twiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;\n\tif (!ifp->drvr->settings->roamoff)\n\t\twiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM;\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_FWSUP)) {\n\t\twiphy_ext_feature_set(wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK);\n\t\twiphy_ext_feature_set(wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X);\n\t\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_SAE))\n\t\t\twiphy_ext_feature_set(wiphy,\n\t\t\t\t\t      NL80211_EXT_FEATURE_SAE_OFFLOAD);\n\t}\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_FWAUTH)) {\n\t\twiphy_ext_feature_set(wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK);\n\t\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_SAE))\n\t\t\twiphy_ext_feature_set(wiphy,\n\t\t\t\t\t      NL80211_EXT_FEATURE_SAE_OFFLOAD_AP);\n\t}\n\twiphy->mgmt_stypes = brcmf_txrx_stypes;\n\twiphy->max_remain_on_channel_duration = 5000;\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_PNO)) {\n\t\tgscan = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_GSCAN);\n\t\tbrcmf_pno_wiphy_params(wiphy, gscan);\n\t}\n\t/* vendor commands/events support */\n\twiphy->vendor_commands = brcmf_vendor_cmds;\n\twiphy->n_vendor_commands = BRCMF_VNDR_CMDS_LAST - 1;\n\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL))\n\t\tbrcmf_wiphy_wowl_params(wiphy, ifp);\n\terr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BANDLIST, &bandlist,\n\t\t\t\t     sizeof(bandlist));\n\tif (err) {\n\t\tbphy_err(drvr, \"could not obtain band info: err=%d\\n\", err);\n\t\treturn err;\n\t}\n\t/* first entry in bandlist is number of bands */\n\tn_bands = le32_to_cpu(bandlist[0]);\n\tfor (i = 1; i <= n_bands && i < ARRAY_SIZE(bandlist); i++) {\n\t\tif (bandlist[i] == cpu_to_le32(WLC_BAND_2G)) {\n\t\t\tband = kmemdup(&__wl_band_2ghz, sizeof(__wl_band_2ghz),\n\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!band)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tband->channels = kmemdup(&__wl_2ghz_channels,\n\t\t\t\t\t\t sizeof(__wl_2ghz_channels),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!band->channels) {\n\t\t\t\tkfree(band);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tband->n_channels = ARRAY_SIZE(__wl_2ghz_channels);\n\t\t\twiphy->bands[NL80211_BAND_2GHZ] = band;\n\t\t}\n\t\tif (bandlist[i] == cpu_to_le32(WLC_BAND_5G)) {\n\t\t\tband = kmemdup(&__wl_band_5ghz, sizeof(__wl_band_5ghz),\n\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!band)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tband->channels = kmemdup(&__wl_5ghz_channels,\n\t\t\t\t\t\t sizeof(__wl_5ghz_channels),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!band->channels) {\n\t\t\t\tkfree(band);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tband->n_channels = ARRAY_SIZE(__wl_5ghz_channels);\n\t\t\twiphy->bands[NL80211_BAND_5GHZ] = band;\n\t\t}\n\t}\n\n\tif (wiphy->bands[NL80211_BAND_5GHZ] &&\n\t    brcmf_feat_is_enabled(ifp, BRCMF_FEAT_DOT11H))\n\t\twiphy_ext_feature_set(wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_DFS_OFFLOAD);\n\n\twiphy_read_of_freq_limits(wiphy);\n\n\treturn 0;\n}\n\nstatic s32 brcmf_config_dongle(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct net_device *ndev;\n\tstruct wireless_dev *wdev;\n\tstruct brcmf_if *ifp;\n\ts32 power_mode;\n\ts32 err = 0;\n\n\tif (cfg->dongle_up)\n\t\treturn err;\n\n\tndev = cfg_to_ndev(cfg);\n\twdev = ndev->ieee80211_ptr;\n\tifp = netdev_priv(ndev);\n\n\t/* make sure RF is ready for work */\n\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 0);\n\n\tbrcmf_dongle_scantime(ifp);\n\n\tpower_mode = cfg->pwr_save ? PM_FAST : PM_OFF;\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM, power_mode);\n\tif (err)\n\t\tgoto default_conf_out;\n\tbrcmf_dbg(INFO, \"power save set to %s\\n\",\n\t\t  (power_mode ? \"enabled\" : \"disabled\"));\n\n\terr = brcmf_dongle_roam(ifp);\n\tif (err)\n\t\tgoto default_conf_out;\n\terr = brcmf_cfg80211_change_iface(wdev->wiphy, ndev, wdev->iftype,\n\t\t\t\t\t  NULL);\n\tif (err)\n\t\tgoto default_conf_out;\n\n\tbrcmf_configure_arp_nd_offload(ifp, true);\n\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_FAKEFRAG, 1);\n\tif (err) {\n\t\tbphy_err(drvr, \"failed to set frameburst mode\\n\");\n\t\tgoto default_conf_out;\n\t}\n\n\tcfg->dongle_up = true;\ndefault_conf_out:\n\n\treturn err;\n\n}\n\nstatic s32 __brcmf_cfg80211_up(struct brcmf_if *ifp)\n{\n\tset_bit(BRCMF_VIF_STATUS_READY, &ifp->vif->sme_state);\n\n\treturn brcmf_config_dongle(ifp->drvr->config);\n}\n\nstatic s32 __brcmf_cfg80211_down(struct brcmf_if *ifp)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\n\t/*\n\t * While going down, if associated with AP disassociate\n\t * from AP to save power\n\t */\n\tif (check_vif_up(ifp->vif)) {\n\t\tbrcmf_link_down(ifp->vif, WLAN_REASON_UNSPECIFIED, true);\n\n\t\t/* Make sure WPA_Supplicant receives all the event\n\t\t   generated due to DISASSOC call to the fw to keep\n\t\t   the state fw and WPA_Supplicant state consistent\n\t\t */\n\t\tbrcmf_delay(500);\n\t}\n\n\tbrcmf_abort_scanning(cfg);\n\tclear_bit(BRCMF_VIF_STATUS_READY, &ifp->vif->sme_state);\n\n\treturn 0;\n}\n\ns32 brcmf_cfg80211_up(struct net_device *ndev)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\ts32 err = 0;\n\n\tmutex_lock(&cfg->usr_sync);\n\terr = __brcmf_cfg80211_up(ifp);\n\tmutex_unlock(&cfg->usr_sync);\n\n\treturn err;\n}\n\ns32 brcmf_cfg80211_down(struct net_device *ndev)\n{\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\ts32 err = 0;\n\n\tmutex_lock(&cfg->usr_sync);\n\terr = __brcmf_cfg80211_down(ifp);\n\tmutex_unlock(&cfg->usr_sync);\n\n\treturn err;\n}\n\nenum nl80211_iftype brcmf_cfg80211_get_iftype(struct brcmf_if *ifp)\n{\n\tstruct wireless_dev *wdev = &ifp->vif->wdev;\n\n\treturn wdev->iftype;\n}\n\nbool brcmf_get_vif_state_any(struct brcmf_cfg80211_info *cfg,\n\t\t\t     unsigned long state)\n{\n\tstruct brcmf_cfg80211_vif *vif;\n\n\tlist_for_each_entry(vif, &cfg->vif_list, list) {\n\t\tif (test_bit(state, &vif->sme_state))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline bool vif_event_equals(struct brcmf_cfg80211_vif_event *event,\n\t\t\t\t    u8 action)\n{\n\tu8 evt_action;\n\n\tspin_lock(&event->vif_event_lock);\n\tevt_action = event->action;\n\tspin_unlock(&event->vif_event_lock);\n\treturn evt_action == action;\n}\n\nvoid brcmf_cfg80211_arm_vif_event(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t  struct brcmf_cfg80211_vif *vif)\n{\n\tstruct brcmf_cfg80211_vif_event *event = &cfg->vif_event;\n\n\tspin_lock(&event->vif_event_lock);\n\tevent->vif = vif;\n\tevent->action = 0;\n\tspin_unlock(&event->vif_event_lock);\n}\n\nbool brcmf_cfg80211_vif_event_armed(struct brcmf_cfg80211_info *cfg)\n{\n\tstruct brcmf_cfg80211_vif_event *event = &cfg->vif_event;\n\tbool armed;\n\n\tspin_lock(&event->vif_event_lock);\n\tarmed = event->vif != NULL;\n\tspin_unlock(&event->vif_event_lock);\n\n\treturn armed;\n}\n\nint brcmf_cfg80211_wait_vif_event(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t  u8 action, ulong timeout)\n{\n\tstruct brcmf_cfg80211_vif_event *event = &cfg->vif_event;\n\n\treturn wait_event_timeout(event->vif_wq,\n\t\t\t\t  vif_event_equals(event, action), timeout);\n}\n\nstatic s32 brcmf_translate_country_code(struct brcmf_pub *drvr, char alpha2[2],\n\t\t\t\t\tstruct brcmf_fil_country_le *ccreq)\n{\n\tstruct brcmfmac_pd_cc *country_codes;\n\tstruct brcmfmac_pd_cc_entry *cc;\n\ts32 found_index;\n\tint i;\n\n\tcountry_codes = drvr->settings->country_codes;\n\tif (!country_codes) {\n\t\tbrcmf_dbg(TRACE, \"No country codes configured for device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((alpha2[0] == ccreq->country_abbrev[0]) &&\n\t    (alpha2[1] == ccreq->country_abbrev[1])) {\n\t\tbrcmf_dbg(TRACE, \"Country code already set\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tfound_index = -1;\n\tfor (i = 0; i < country_codes->table_size; i++) {\n\t\tcc = &country_codes->table[i];\n\t\tif ((cc->iso3166[0] == '\\0') && (found_index == -1))\n\t\t\tfound_index = i;\n\t\tif ((cc->iso3166[0] == alpha2[0]) &&\n\t\t    (cc->iso3166[1] == alpha2[1])) {\n\t\t\tfound_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found_index == -1) {\n\t\tbrcmf_dbg(TRACE, \"No country code match found\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmemset(ccreq, 0, sizeof(*ccreq));\n\tccreq->rev = cpu_to_le32(country_codes->table[found_index].rev);\n\tmemcpy(ccreq->ccode, country_codes->table[found_index].cc,\n\t       BRCMF_COUNTRY_BUF_SZ);\n\tccreq->country_abbrev[0] = alpha2[0];\n\tccreq->country_abbrev[1] = alpha2[1];\n\tccreq->country_abbrev[2] = 0;\n\n\treturn 0;\n}\n\nstatic void brcmf_cfg80211_reg_notifier(struct wiphy *wiphy,\n\t\t\t\t\tstruct regulatory_request *req)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = brcmf_get_ifp(cfg->pub, 0);\n\tstruct brcmf_pub *drvr = cfg->pub;\n\tstruct brcmf_fil_country_le ccreq;\n\ts32 err;\n\tint i;\n\n\t/* The country code gets set to \"00\" by default at boot, ignore */\n\tif (req->alpha2[0] == '0' && req->alpha2[1] == '0')\n\t\treturn;\n\n\t/* ignore non-ISO3166 country codes */\n\tfor (i = 0; i < 2; i++)\n\t\tif (req->alpha2[i] < 'A' || req->alpha2[i] > 'Z') {\n\t\t\tbphy_err(drvr, \"not an ISO3166 code (0x%02x 0x%02x)\\n\",\n\t\t\t\t req->alpha2[0], req->alpha2[1]);\n\t\t\treturn;\n\t\t}\n\n\tbrcmf_dbg(TRACE, \"Enter: initiator=%d, alpha=%c%c\\n\", req->initiator,\n\t\t  req->alpha2[0], req->alpha2[1]);\n\n\terr = brcmf_fil_iovar_data_get(ifp, \"country\", &ccreq, sizeof(ccreq));\n\tif (err) {\n\t\tbphy_err(drvr, \"Country code iovar returned err = %d\\n\", err);\n\t\treturn;\n\t}\n\n\terr = brcmf_translate_country_code(ifp->drvr, req->alpha2, &ccreq);\n\tif (err)\n\t\treturn;\n\n\terr = brcmf_fil_iovar_data_set(ifp, \"country\", &ccreq, sizeof(ccreq));\n\tif (err) {\n\t\tbphy_err(drvr, \"Firmware rejected country setting\\n\");\n\t\treturn;\n\t}\n\tbrcmf_setup_wiphybands(cfg);\n}\n\nstatic void brcmf_free_wiphy(struct wiphy *wiphy)\n{\n\tint i;\n\n\tif (!wiphy)\n\t\treturn;\n\n\tif (wiphy->iface_combinations) {\n\t\tfor (i = 0; i < wiphy->n_iface_combinations; i++)\n\t\t\tkfree(wiphy->iface_combinations[i].limits);\n\t}\n\tkfree(wiphy->iface_combinations);\n\tif (wiphy->bands[NL80211_BAND_2GHZ]) {\n\t\tkfree(wiphy->bands[NL80211_BAND_2GHZ]->channels);\n\t\tkfree(wiphy->bands[NL80211_BAND_2GHZ]);\n\t}\n\tif (wiphy->bands[NL80211_BAND_5GHZ]) {\n\t\tkfree(wiphy->bands[NL80211_BAND_5GHZ]->channels);\n\t\tkfree(wiphy->bands[NL80211_BAND_5GHZ]);\n\t}\n#if IS_ENABLED(CONFIG_PM)\n\tif (wiphy->wowlan != &brcmf_wowlan_support)\n\t\tkfree(wiphy->wowlan);\n#endif\n}\n\nstruct brcmf_cfg80211_info *brcmf_cfg80211_attach(struct brcmf_pub *drvr,\n\t\t\t\t\t\t  struct cfg80211_ops *ops,\n\t\t\t\t\t\t  bool p2pdev_forced)\n{\n\tstruct wiphy *wiphy = drvr->wiphy;\n\tstruct net_device *ndev = brcmf_get_ifp(drvr, 0)->ndev;\n\tstruct brcmf_cfg80211_info *cfg;\n\tstruct brcmf_cfg80211_vif *vif;\n\tstruct brcmf_if *ifp;\n\ts32 err = 0;\n\ts32 io_type;\n\tu16 *cap = NULL;\n\n\tif (!ndev) {\n\t\tbphy_err(drvr, \"ndev is invalid\\n\");\n\t\treturn NULL;\n\t}\n\n\tcfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg) {\n\t\tbphy_err(drvr, \"Could not allocate wiphy device\\n\");\n\t\treturn NULL;\n\t}\n\n\tcfg->wiphy = wiphy;\n\tcfg->pub = drvr;\n\tinit_vif_event(&cfg->vif_event);\n\tINIT_LIST_HEAD(&cfg->vif_list);\n\n\tvif = brcmf_alloc_vif(cfg, NL80211_IFTYPE_STATION);\n\tif (IS_ERR(vif))\n\t\tgoto wiphy_out;\n\n\tifp = netdev_priv(ndev);\n\tvif->ifp = ifp;\n\tvif->wdev.netdev = ndev;\n\tndev->ieee80211_ptr = &vif->wdev;\n\tSET_NETDEV_DEV(ndev, wiphy_dev(cfg->wiphy));\n\n\terr = wl_init_priv(cfg);\n\tif (err) {\n\t\tbphy_err(drvr, \"Failed to init iwm_priv (%d)\\n\", err);\n\t\tbrcmf_free_vif(vif);\n\t\tgoto wiphy_out;\n\t}\n\tifp->vif = vif;\n\n\t/* determine d11 io type before wiphy setup */\n\terr = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_VERSION, &io_type);\n\tif (err) {\n\t\tbphy_err(drvr, \"Failed to get D11 version (%d)\\n\", err);\n\t\tgoto priv_out;\n\t}\n\tcfg->d11inf.io_type = (u8)io_type;\n\tbrcmu_d11_attach(&cfg->d11inf);\n\n\t/* regulatory notifer below needs access to cfg so\n\t * assign it now.\n\t */\n\tdrvr->config = cfg;\n\n\terr = brcmf_setup_wiphy(wiphy, ifp);\n\tif (err < 0)\n\t\tgoto priv_out;\n\n\tbrcmf_dbg(INFO, \"Registering custom regulatory\\n\");\n\twiphy->reg_notifier = brcmf_cfg80211_reg_notifier;\n\twiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;\n\twiphy_apply_custom_regulatory(wiphy, &brcmf_regdom);\n\n\t/* firmware defaults to 40MHz disabled in 2G band. We signal\n\t * cfg80211 here that we do and have it decide we can enable\n\t * it. But first check if device does support 2G operation.\n\t */\n\tif (wiphy->bands[NL80211_BAND_2GHZ]) {\n\t\tcap = &wiphy->bands[NL80211_BAND_2GHZ]->ht_cap.cap;\n\t\t*cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t}\n#ifdef CONFIG_PM\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_GTK))\n\t\tops->set_rekey_data = brcmf_cfg80211_set_rekey_data;\n#endif\n\terr = wiphy_register(wiphy);\n\tif (err < 0) {\n\t\tbphy_err(drvr, \"Could not register wiphy device (%d)\\n\", err);\n\t\tgoto priv_out;\n\t}\n\n\terr = brcmf_setup_wiphybands(cfg);\n\tif (err) {\n\t\tbphy_err(drvr, \"Setting wiphy bands failed (%d)\\n\", err);\n\t\tgoto wiphy_unreg_out;\n\t}\n\n\t/* If cfg80211 didn't disable 40MHz HT CAP in wiphy_register(),\n\t * setup 40MHz in 2GHz band and enable OBSS scanning.\n\t */\n\tif (cap && (*cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40)) {\n\t\terr = brcmf_enable_bw40_2g(cfg);\n\t\tif (!err)\n\t\t\terr = brcmf_fil_iovar_int_set(ifp, \"obss_coex\",\n\t\t\t\t\t\t      BRCMF_OBSS_COEX_AUTO);\n\t\telse\n\t\t\t*cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t}\n\n\terr = brcmf_fweh_activate_events(ifp);\n\tif (err) {\n\t\tbphy_err(drvr, \"FWEH activation failed (%d)\\n\", err);\n\t\tgoto wiphy_unreg_out;\n\t}\n\n\terr = brcmf_p2p_attach(cfg, p2pdev_forced);\n\tif (err) {\n\t\tbphy_err(drvr, \"P2P initialisation failed (%d)\\n\", err);\n\t\tgoto wiphy_unreg_out;\n\t}\n\terr = brcmf_btcoex_attach(cfg);\n\tif (err) {\n\t\tbphy_err(drvr, \"BT-coex initialisation failed (%d)\\n\", err);\n\t\tbrcmf_p2p_detach(&cfg->p2p);\n\t\tgoto wiphy_unreg_out;\n\t}\n\terr = brcmf_pno_attach(cfg);\n\tif (err) {\n\t\tbphy_err(drvr, \"PNO initialisation failed (%d)\\n\", err);\n\t\tbrcmf_btcoex_detach(cfg);\n\t\tbrcmf_p2p_detach(&cfg->p2p);\n\t\tgoto wiphy_unreg_out;\n\t}\n\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_TDLS)) {\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"tdls_enable\", 1);\n\t\tif (err) {\n\t\t\tbrcmf_dbg(INFO, \"TDLS not enabled (%d)\\n\", err);\n\t\t\twiphy->flags &= ~WIPHY_FLAG_SUPPORTS_TDLS;\n\t\t} else {\n\t\t\tbrcmf_fweh_register(cfg->pub, BRCMF_E_TDLS_PEER_EVENT,\n\t\t\t\t\t    brcmf_notify_tdls_peer_event);\n\t\t}\n\t}\n\n\t/* (re-) activate FWEH event handling */\n\terr = brcmf_fweh_activate_events(ifp);\n\tif (err) {\n\t\tbphy_err(drvr, \"FWEH activation failed (%d)\\n\", err);\n\t\tgoto detach;\n\t}\n\n\t/* Fill in some of the advertised nl80211 supported features */\n\tif (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_SCAN_RANDOM_MAC)) {\n\t\twiphy->features |= NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR;\n#ifdef CONFIG_PM\n\t\tif (wiphy->wowlan &&\n\t\t    wiphy->wowlan->flags & WIPHY_WOWLAN_NET_DETECT)\n\t\t\twiphy->features |= NL80211_FEATURE_ND_RANDOM_MAC_ADDR;\n#endif\n\t}\n\n\treturn cfg;\n\ndetach:\n\tbrcmf_pno_detach(cfg);\n\tbrcmf_btcoex_detach(cfg);\n\tbrcmf_p2p_detach(&cfg->p2p);\nwiphy_unreg_out:\n\twiphy_unregister(cfg->wiphy);\npriv_out:\n\twl_deinit_priv(cfg);\n\tbrcmf_free_vif(vif);\n\tifp->vif = NULL;\nwiphy_out:\n\tbrcmf_free_wiphy(wiphy);\n\tkfree(cfg);\n\treturn NULL;\n}\n\nvoid brcmf_cfg80211_detach(struct brcmf_cfg80211_info *cfg)\n{\n\tif (!cfg)\n\t\treturn;\n\n\tbrcmf_pno_detach(cfg);\n\tbrcmf_btcoex_detach(cfg);\n\twiphy_unregister(cfg->wiphy);\n\twl_deinit_priv(cfg);\n\tbrcmf_free_wiphy(cfg->wiphy);\n\tkfree(cfg);\n}\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 2136}, "message": "error: we previously assumed 'sme->crypto.psk' could be null (see line 2116)"}], "macros": [], "notes": [], "path": "/src/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c", "reportHash": "0bb124e6cb4ac654641d7d479fab6491", "checkerName": "smatch.check_check_deref", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
