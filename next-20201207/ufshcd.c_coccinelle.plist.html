<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/scsi/ufs/ufshcd.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Universal Flash Storage Host controller driver Core\n * Copyright (C) 2011-2013 Samsung India Software Operations\n * Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.\n *\n * Authors:\n *\tSantosh Yaraganavi <santosh.sy@samsung.com>\n *\tVinayak Holikatti <h.vinayak@samsung.com>\n */\n\n#include <linux/async.h>\n#include <linux/devfreq.h>\n#include <linux/nls.h>\n#include <linux/of.h>\n#include <linux/bitfield.h>\n#include <linux/blk-pm.h>\n#include <linux/blkdev.h>\n#include \"ufshcd.h\"\n#include \"ufs_quirks.h\"\n#include \"unipro.h\"\n#include \"ufs-sysfs.h\"\n#include \"ufs_bsg.h\"\n#include \"ufshcd-crypto.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/ufs.h>\n\n#define UFSHCD_ENABLE_INTRS\t(UTP_TRANSFER_REQ_COMPL |\\\n\t\t\t\t UTP_TASK_REQ_COMPL |\\\n\t\t\t\t UFSHCD_ERROR_MASK)\n/* UIC command timeout, unit: ms */\n#define UIC_CMD_TIMEOUT\t500\n\n/* NOP OUT retries waiting for NOP IN response */\n#define NOP_OUT_RETRIES    10\n/* Timeout after 50 msecs if NOP OUT hangs without response */\n#define NOP_OUT_TIMEOUT    50 /* msecs */\n\n/* Query request retries */\n#define QUERY_REQ_RETRIES 3\n/* Query request timeout */\n#define QUERY_REQ_TIMEOUT 1500 /* 1.5 seconds */\n\n/* Task management command timeout */\n#define TM_CMD_TIMEOUT\t100 /* msecs */\n\n/* maximum number of retries for a general UIC command  */\n#define UFS_UIC_COMMAND_RETRIES 3\n\n/* maximum number of link-startup retries */\n#define DME_LINKSTARTUP_RETRIES 3\n\n/* Maximum retries for Hibern8 enter */\n#define UIC_HIBERN8_ENTER_RETRIES 3\n\n/* maximum number of reset retries before giving up */\n#define MAX_HOST_RESET_RETRIES 5\n\n/* Expose the flag value from utp_upiu_query.value */\n#define MASK_QUERY_UPIU_FLAG_LOC 0xFF\n\n/* Interrupt aggregation default timeout, unit: 40us */\n#define INT_AGGR_DEF_TO\t0x02\n\n/* default delay of autosuspend: 2000 ms */\n#define RPM_AUTOSUSPEND_DELAY_MS 2000\n\n/* Default delay of RPM device flush delayed work */\n#define RPM_DEV_FLUSH_RECHECK_WORK_DELAY_MS 5000\n\n/* Default value of wait time before gating device ref clock */\n#define UFSHCD_REF_CLK_GATING_WAIT_US 0xFF /* microsecs */\n\n/* Polling time to wait for fDeviceInit */\n#define FDEVICEINIT_COMPL_TIMEOUT 1500 /* millisecs */\n\n#define ufshcd_toggle_vreg(_dev, _vreg, _on)\t\t\t\t\\\n\t({                                                              \\\n\t\tint _ret;                                               \\\n\t\tif (_on)                                                \\\n\t\t\t_ret = ufshcd_enable_vreg(_dev, _vreg);         \\\n\t\telse                                                    \\\n\t\t\t_ret = ufshcd_disable_vreg(_dev, _vreg);        \\\n\t\t_ret;                                                   \\\n\t})\n\n#define ufshcd_hex_dump(prefix_str, buf, len) do {                       \\\n\tsize_t __len = (len);                                            \\\n\tprint_hex_dump(KERN_ERR, prefix_str,                             \\\n\t\t       __len > 4 ? DUMP_PREFIX_OFFSET : DUMP_PREFIX_NONE,\\\n\t\t       16, 4, buf, __len, false);                        \\\n} while (0)\n\nint ufshcd_dump_regs(struct ufs_hba *hba, size_t offset, size_t len,\n\t\t     const char *prefix)\n{\n\tu32 *regs;\n\tsize_t pos;\n\n\tif (offset % 4 != 0 || len % 4 != 0) /* keep readl happy */\n\t\treturn -EINVAL;\n\n\tregs = kzalloc(len, GFP_ATOMIC);\n\tif (!regs)\n\t\treturn -ENOMEM;\n\n\tfor (pos = 0; pos < len; pos += 4)\n\t\tregs[pos / 4] = ufshcd_readl(hba, offset + pos);\n\n\tufshcd_hex_dump(prefix, regs, len);\n\tkfree(regs);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ufshcd_dump_regs);\n\nenum {\n\tUFSHCD_MAX_CHANNEL\t= 0,\n\tUFSHCD_MAX_ID\t\t= 1,\n\tUFSHCD_CMD_PER_LUN\t= 32,\n\tUFSHCD_CAN_QUEUE\t= 32,\n};\n\n/* UFSHCD states */\nenum {\n\tUFSHCD_STATE_RESET,\n\tUFSHCD_STATE_ERROR,\n\tUFSHCD_STATE_OPERATIONAL,\n\tUFSHCD_STATE_EH_SCHEDULED_FATAL,\n\tUFSHCD_STATE_EH_SCHEDULED_NON_FATAL,\n};\n\n/* UFSHCD error handling flags */\nenum {\n\tUFSHCD_EH_IN_PROGRESS = (1 << 0),\n};\n\n/* UFSHCD UIC layer error flags */\nenum {\n\tUFSHCD_UIC_DL_PA_INIT_ERROR = (1 << 0), /* Data link layer error */\n\tUFSHCD_UIC_DL_NAC_RECEIVED_ERROR = (1 << 1), /* Data link layer error */\n\tUFSHCD_UIC_DL_TCx_REPLAY_ERROR = (1 << 2), /* Data link layer error */\n\tUFSHCD_UIC_NL_ERROR = (1 << 3), /* Network layer error */\n\tUFSHCD_UIC_TL_ERROR = (1 << 4), /* Transport Layer error */\n\tUFSHCD_UIC_DME_ERROR = (1 << 5), /* DME error */\n\tUFSHCD_UIC_PA_GENERIC_ERROR = (1 << 6), /* Generic PA error */\n};\n\n#define ufshcd_set_eh_in_progress(h) \\\n\t((h)->eh_flags |= UFSHCD_EH_IN_PROGRESS)\n#define ufshcd_eh_in_progress(h) \\\n\t((h)->eh_flags & UFSHCD_EH_IN_PROGRESS)\n#define ufshcd_clear_eh_in_progress(h) \\\n\t((h)->eh_flags &= ~UFSHCD_EH_IN_PROGRESS)\n\nstruct ufs_pm_lvl_states ufs_pm_lvl_states[] = {\n\t{UFS_ACTIVE_PWR_MODE, UIC_LINK_ACTIVE_STATE},\n\t{UFS_ACTIVE_PWR_MODE, UIC_LINK_HIBERN8_STATE},\n\t{UFS_SLEEP_PWR_MODE, UIC_LINK_ACTIVE_STATE},\n\t{UFS_SLEEP_PWR_MODE, UIC_LINK_HIBERN8_STATE},\n\t{UFS_POWERDOWN_PWR_MODE, UIC_LINK_HIBERN8_STATE},\n\t{UFS_POWERDOWN_PWR_MODE, UIC_LINK_OFF_STATE},\n\t/*\n\t * For DeepSleep, the link is first put in hibern8 and then off.\n\t * Leaving the link in hibern8 is not supported.\n\t */\n\t{UFS_DEEPSLEEP_PWR_MODE, UIC_LINK_OFF_STATE},\n};\n\nstatic inline enum ufs_dev_pwr_mode\nufs_get_pm_lvl_to_dev_pwr_mode(enum ufs_pm_level lvl)\n{\n\treturn ufs_pm_lvl_states[lvl].dev_state;\n}\n\nstatic inline enum uic_link_state\nufs_get_pm_lvl_to_link_pwr_state(enum ufs_pm_level lvl)\n{\n\treturn ufs_pm_lvl_states[lvl].link_state;\n}\n\nstatic inline enum ufs_pm_level\nufs_get_desired_pm_lvl_for_dev_link_state(enum ufs_dev_pwr_mode dev_state,\n\t\t\t\t\tenum uic_link_state link_state)\n{\n\tenum ufs_pm_level lvl;\n\n\tfor (lvl = UFS_PM_LVL_0; lvl < UFS_PM_LVL_MAX; lvl++) {\n\t\tif ((ufs_pm_lvl_states[lvl].dev_state == dev_state) &&\n\t\t\t(ufs_pm_lvl_states[lvl].link_state == link_state))\n\t\t\treturn lvl;\n\t}\n\n\t/* if no match found, return the level 0 */\n\treturn UFS_PM_LVL_0;\n}\n\nstatic struct ufs_dev_fix ufs_fixups[] = {\n\t/* UFS cards deviations table */\n\tUFS_FIX(UFS_VENDOR_MICRON, UFS_ANY_MODEL,\n\t\tUFS_DEVICE_QUIRK_DELAY_BEFORE_LPM),\n\tUFS_FIX(UFS_VENDOR_SAMSUNG, UFS_ANY_MODEL,\n\t\tUFS_DEVICE_QUIRK_DELAY_BEFORE_LPM |\n\t\tUFS_DEVICE_QUIRK_HOST_PA_TACTIVATE |\n\t\tUFS_DEVICE_QUIRK_RECOVERY_FROM_DL_NAC_ERRORS),\n\tUFS_FIX(UFS_VENDOR_SKHYNIX, UFS_ANY_MODEL,\n\t\tUFS_DEVICE_QUIRK_HOST_PA_SAVECONFIGTIME),\n\tUFS_FIX(UFS_VENDOR_SKHYNIX, \"hB8aL1\" /*H28U62301AMR*/,\n\t\tUFS_DEVICE_QUIRK_HOST_VS_DEBUGSAVECONFIGTIME),\n\tUFS_FIX(UFS_VENDOR_TOSHIBA, UFS_ANY_MODEL,\n\t\tUFS_DEVICE_QUIRK_DELAY_BEFORE_LPM),\n\tUFS_FIX(UFS_VENDOR_TOSHIBA, \"THGLF2G9C8KBADG\",\n\t\tUFS_DEVICE_QUIRK_PA_TACTIVATE),\n\tUFS_FIX(UFS_VENDOR_TOSHIBA, \"THGLF2G9D8KBADG\",\n\t\tUFS_DEVICE_QUIRK_PA_TACTIVATE),\n\tEND_FIX\n};\n\nstatic irqreturn_t ufshcd_tmc_handler(struct ufs_hba *hba);\nstatic void ufshcd_async_scan(void *data, async_cookie_t cookie);\nstatic int ufshcd_reset_and_restore(struct ufs_hba *hba);\nstatic int ufshcd_eh_host_reset_handler(struct scsi_cmnd *cmd);\nstatic int ufshcd_clear_tm_cmd(struct ufs_hba *hba, int tag);\nstatic void ufshcd_hba_exit(struct ufs_hba *hba);\nstatic int ufshcd_probe_hba(struct ufs_hba *hba, bool async);\nstatic int ufshcd_setup_clocks(struct ufs_hba *hba, bool on);\nstatic int ufshcd_uic_hibern8_enter(struct ufs_hba *hba);\nstatic inline void ufshcd_add_delay_before_dme_cmd(struct ufs_hba *hba);\nstatic int ufshcd_host_reset_and_restore(struct ufs_hba *hba);\nstatic void ufshcd_resume_clkscaling(struct ufs_hba *hba);\nstatic void ufshcd_suspend_clkscaling(struct ufs_hba *hba);\nstatic void __ufshcd_suspend_clkscaling(struct ufs_hba *hba);\nstatic int ufshcd_scale_clks(struct ufs_hba *hba, bool scale_up);\nstatic irqreturn_t ufshcd_intr(int irq, void *__hba);\nstatic int ufshcd_change_power_mode(struct ufs_hba *hba,\n\t\t\t     struct ufs_pa_layer_attr *pwr_mode);\nstatic void ufshcd_schedule_eh_work(struct ufs_hba *hba);\nstatic int ufshcd_setup_hba_vreg(struct ufs_hba *hba, bool on);\nstatic int ufshcd_setup_vreg(struct ufs_hba *hba, bool on);\nstatic inline int ufshcd_config_vreg_hpm(struct ufs_hba *hba,\n\t\t\t\t\t struct ufs_vreg *vreg);\nstatic int ufshcd_try_to_abort_task(struct ufs_hba *hba, int tag);\nstatic int ufshcd_wb_buf_flush_enable(struct ufs_hba *hba);\nstatic int ufshcd_wb_buf_flush_disable(struct ufs_hba *hba);\nstatic int ufshcd_wb_ctrl(struct ufs_hba *hba, bool enable);\nstatic int ufshcd_wb_toggle_flush_during_h8(struct ufs_hba *hba, bool set);\nstatic inline void ufshcd_wb_toggle_flush(struct ufs_hba *hba, bool enable);\nstatic void ufshcd_hba_vreg_set_lpm(struct ufs_hba *hba);\nstatic void ufshcd_hba_vreg_set_hpm(struct ufs_hba *hba);\n\nstatic inline bool ufshcd_valid_tag(struct ufs_hba *hba, int tag)\n{\n\treturn tag >= 0 && tag < hba->nutrs;\n}\n\nstatic inline void ufshcd_enable_irq(struct ufs_hba *hba)\n{\n\tif (!hba->is_irq_enabled) {\n\t\tenable_irq(hba->irq);\n\t\thba->is_irq_enabled = true;\n\t}\n}\n\nstatic inline void ufshcd_disable_irq(struct ufs_hba *hba)\n{\n\tif (hba->is_irq_enabled) {\n\t\tdisable_irq(hba->irq);\n\t\thba->is_irq_enabled = false;\n\t}\n}\n\nstatic inline void ufshcd_wb_config(struct ufs_hba *hba)\n{\n\tint ret;\n\n\tif (!ufshcd_is_wb_allowed(hba))\n\t\treturn;\n\n\tret = ufshcd_wb_ctrl(hba, true);\n\tif (ret)\n\t\tdev_err(hba->dev, \"%s: Enable WB failed: %d\\n\", __func__, ret);\n\telse\n\t\tdev_info(hba->dev, \"%s: Write Booster Configured\\n\", __func__);\n\tret = ufshcd_wb_toggle_flush_during_h8(hba, true);\n\tif (ret)\n\t\tdev_err(hba->dev, \"%s: En WB flush during H8: failed: %d\\n\",\n\t\t\t__func__, ret);\n\tufshcd_wb_toggle_flush(hba, true);\n}\n\nstatic void ufshcd_scsi_unblock_requests(struct ufs_hba *hba)\n{\n\tif (atomic_dec_and_test(&hba->scsi_block_reqs_cnt))\n\t\tscsi_unblock_requests(hba->host);\n}\n\nstatic void ufshcd_scsi_block_requests(struct ufs_hba *hba)\n{\n\tif (atomic_inc_return(&hba->scsi_block_reqs_cnt) == 1)\n\t\tscsi_block_requests(hba->host);\n}\n\nstatic void ufshcd_add_cmd_upiu_trace(struct ufs_hba *hba, unsigned int tag,\n\t\tconst char *str)\n{\n\tstruct utp_upiu_req *rq = hba->lrb[tag].ucd_req_ptr;\n\n\ttrace_ufshcd_upiu(dev_name(hba->dev), str, &rq->header, &rq->sc.cdb);\n}\n\nstatic void ufshcd_add_query_upiu_trace(struct ufs_hba *hba, unsigned int tag,\n\t\tconst char *str)\n{\n\tstruct utp_upiu_req *rq = hba->lrb[tag].ucd_req_ptr;\n\n\ttrace_ufshcd_upiu(dev_name(hba->dev), str, &rq->header, &rq->qr);\n}\n\nstatic void ufshcd_add_tm_upiu_trace(struct ufs_hba *hba, unsigned int tag,\n\t\tconst char *str)\n{\n\tint off = (int)tag - hba->nutrs;\n\tstruct utp_task_req_desc *descp = &hba->utmrdl_base_addr[off];\n\n\ttrace_ufshcd_upiu(dev_name(hba->dev), str, &descp->req_header,\n\t\t\t&descp->input_param1);\n}\n\nstatic void ufshcd_add_uic_command_trace(struct ufs_hba *hba,\n\t\t\t\t\t struct uic_command *ucmd,\n\t\t\t\t\t const char *str)\n{\n\tu32 cmd;\n\n\tif (!trace_ufshcd_uic_command_enabled())\n\t\treturn;\n\n\tif (!strcmp(str, \"send\"))\n\t\tcmd = ucmd->command;\n\telse\n\t\tcmd = ufshcd_readl(hba, REG_UIC_COMMAND);\n\n\ttrace_ufshcd_uic_command(dev_name(hba->dev), str, cmd,\n\t\t\t\t ufshcd_readl(hba, REG_UIC_COMMAND_ARG_1),\n\t\t\t\t ufshcd_readl(hba, REG_UIC_COMMAND_ARG_2),\n\t\t\t\t ufshcd_readl(hba, REG_UIC_COMMAND_ARG_3));\n}\n\nstatic void ufshcd_add_command_trace(struct ufs_hba *hba,\n\t\tunsigned int tag, const char *str)\n{\n\tsector_t lba = -1;\n\tu8 opcode = 0, group_id = 0;\n\tu32 intr, doorbell;\n\tstruct ufshcd_lrb *lrbp = &hba->lrb[tag];\n\tstruct scsi_cmnd *cmd = lrbp->cmd;\n\tint transfer_len = -1;\n\n\tif (!trace_ufshcd_command_enabled()) {\n\t\t/* trace UPIU W/O tracing command */\n\t\tif (cmd)\n\t\t\tufshcd_add_cmd_upiu_trace(hba, tag, str);\n\t\treturn;\n\t}\n\n\tif (cmd) { /* data phase exists */\n\t\t/* trace UPIU also */\n\t\tufshcd_add_cmd_upiu_trace(hba, tag, str);\n\t\topcode = cmd->cmnd[0];\n\t\tif ((opcode == READ_10) || (opcode == WRITE_10)) {\n\t\t\t/*\n\t\t\t * Currently we only fully trace read(10) and write(10)\n\t\t\t * commands\n\t\t\t */\n\t\t\tif (cmd->request && cmd->request->bio)\n\t\t\t\tlba = cmd->request->bio->bi_iter.bi_sector;\n\t\t\ttransfer_len = be32_to_cpu(\n\t\t\t\tlrbp->ucd_req_ptr->sc.exp_data_transfer_len);\n\t\t\tif (opcode == WRITE_10)\n\t\t\t\tgroup_id = lrbp->cmd->cmnd[6];\n\t\t} else if (opcode == UNMAP) {\n\t\t\tif (cmd->request) {\n\t\t\t\tlba = scsi_get_lba(cmd);\n\t\t\t\ttransfer_len = blk_rq_bytes(cmd->request);\n\t\t\t}\n\t\t}\n\t}\n\n\tintr = ufshcd_readl(hba, REG_INTERRUPT_STATUS);\n\tdoorbell = ufshcd_readl(hba, REG_UTP_TRANSFER_REQ_DOOR_BELL);\n\ttrace_ufshcd_command(dev_name(hba->dev), str, tag,\n\t\t\tdoorbell, transfer_len, intr, lba, opcode, group_id);\n}\n\nstatic void ufshcd_print_clk_freqs(struct ufs_hba *hba)\n{\n\tstruct ufs_clk_info *clki;\n\tstruct list_head *head = &hba->clk_list_head;\n\n\tif (list_empty(head))\n\t\treturn;\n\n\tlist_for_each_entry(clki, head, list) {\n\t\tif (!IS_ERR_OR_NULL(clki->clk) && clki->min_freq &&\n\t\t\t\tclki->max_freq)\n\t\t\tdev_err(hba->dev, \"clk: %s, rate: %u\\n\",\n\t\t\t\t\tclki->name, clki->curr_freq);\n\t}\n}\n\nstatic void ufshcd_print_err_hist(struct ufs_hba *hba,\n\t\t\t\t  struct ufs_err_reg_hist *err_hist,\n\t\t\t\t  char *err_name)\n{\n\tint i;\n\tbool found = false;\n\n\tfor (i = 0; i < UFS_ERR_REG_HIST_LENGTH; i++) {\n\t\tint p = (i + err_hist->pos) % UFS_ERR_REG_HIST_LENGTH;\n\n\t\tif (err_hist->tstamp[p] == 0)\n\t\t\tcontinue;\n\t\tdev_err(hba->dev, \"%s[%d] = 0x%x at %lld us\\n\", err_name, p,\n\t\t\terr_hist->reg[p], ktime_to_us(err_hist->tstamp[p]));\n\t\tfound = true;\n\t}\n\n\tif (!found)\n\t\tdev_err(hba->dev, \"No record of %s\\n\", err_name);\n}\n\nstatic void ufshcd_print_host_regs(struct ufs_hba *hba)\n{\n\tufshcd_dump_regs(hba, 0, UFSHCI_REG_SPACE_SIZE, \"host_regs: \");\n\n\tufshcd_print_err_hist(hba, &hba->ufs_stats.pa_err, \"pa_err\");\n\tufshcd_print_err_hist(hba, &hba->ufs_stats.dl_err, \"dl_err\");\n\tufshcd_print_err_hist(hba, &hba->ufs_stats.nl_err, \"nl_err\");\n\tufshcd_print_err_hist(hba, &hba->ufs_stats.tl_err, \"tl_err\");\n\tufshcd_print_err_hist(hba, &hba->ufs_stats.dme_err, \"dme_err\");\n\tufshcd_print_err_hist(hba, &hba->ufs_stats.auto_hibern8_err,\n\t\t\t      \"auto_hibern8_err\");\n\tufshcd_print_err_hist(hba, &hba->ufs_stats.fatal_err, \"fatal_err\");\n\tufshcd_print_err_hist(hba, &hba->ufs_stats.link_startup_err,\n\t\t\t      \"link_startup_fail\");\n\tufshcd_print_err_hist(hba, &hba->ufs_stats.resume_err, \"resume_fail\");\n\tufshcd_print_err_hist(hba, &hba->ufs_stats.suspend_err,\n\t\t\t      \"suspend_fail\");\n\tufshcd_print_err_hist(hba, &hba->ufs_stats.dev_reset, \"dev_reset\");\n\tufshcd_print_err_hist(hba, &hba->ufs_stats.host_reset, \"host_reset\");\n\tufshcd_print_err_hist(hba, &hba->ufs_stats.task_abort, \"task_abort\");\n\n\tufshcd_vops_dbg_register_dump(hba);\n}\n\nstatic\nvoid ufshcd_print_trs(struct ufs_hba *hba, unsigned long bitmap, bool pr_prdt)\n{\n\tstruct ufshcd_lrb *lrbp;\n\tint prdt_length;\n\tint tag;\n\n\tfor_each_set_bit(tag, &bitmap, hba->nutrs) {\n\t\tlrbp = &hba->lrb[tag];\n\n\t\tdev_err(hba->dev, \"UPIU[%d] - issue time %lld us\\n\",\n\t\t\t\ttag, ktime_to_us(lrbp->issue_time_stamp));\n\t\tdev_err(hba->dev, \"UPIU[%d] - complete time %lld us\\n\",\n\t\t\t\ttag, ktime_to_us(lrbp->compl_time_stamp));\n\t\tdev_err(hba->dev,\n\t\t\t\"UPIU[%d] - Transfer Request Descriptor phys@0x%llx\\n\",\n\t\t\ttag, (u64)lrbp->utrd_dma_addr);\n\n\t\tufshcd_hex_dump(\"UPIU TRD: \", lrbp->utr_descriptor_ptr,\n\t\t\t\tsizeof(struct utp_transfer_req_desc));\n\t\tdev_err(hba->dev, \"UPIU[%d] - Request UPIU phys@0x%llx\\n\", tag,\n\t\t\t(u64)lrbp->ucd_req_dma_addr);\n\t\tufshcd_hex_dump(\"UPIU REQ: \", lrbp->ucd_req_ptr,\n\t\t\t\tsizeof(struct utp_upiu_req));\n\t\tdev_err(hba->dev, \"UPIU[%d] - Response UPIU phys@0x%llx\\n\", tag,\n\t\t\t(u64)lrbp->ucd_rsp_dma_addr);\n\t\tufshcd_hex_dump(\"UPIU RSP: \", lrbp->ucd_rsp_ptr,\n\t\t\t\tsizeof(struct utp_upiu_rsp));\n\n\t\tprdt_length = le16_to_cpu(\n\t\t\tlrbp->utr_descriptor_ptr->prd_table_length);\n\t\tif (hba->quirks & UFSHCD_QUIRK_PRDT_BYTE_GRAN)\n\t\t\tprdt_length /= sizeof(struct ufshcd_sg_entry);\n\n\t\tdev_err(hba->dev,\n\t\t\t\"UPIU[%d] - PRDT - %d entries  phys@0x%llx\\n\",\n\t\t\ttag, prdt_length,\n\t\t\t(u64)lrbp->ucd_prdt_dma_addr);\n\n\t\tif (pr_prdt)\n\t\t\tufshcd_hex_dump(\"UPIU PRDT: \", lrbp->ucd_prdt_ptr,\n\t\t\t\tsizeof(struct ufshcd_sg_entry) * prdt_length);\n\t}\n}\n\nstatic void ufshcd_print_tmrs(struct ufs_hba *hba, unsigned long bitmap)\n{\n\tint tag;\n\n\tfor_each_set_bit(tag, &bitmap, hba->nutmrs) {\n\t\tstruct utp_task_req_desc *tmrdp = &hba->utmrdl_base_addr[tag];\n\n\t\tdev_err(hba->dev, \"TM[%d] - Task Management Header\\n\", tag);\n\t\tufshcd_hex_dump(\"\", tmrdp, sizeof(*tmrdp));\n\t}\n}\n\nstatic void ufshcd_print_host_state(struct ufs_hba *hba)\n{\n\tstruct scsi_device *sdev_ufs = hba->sdev_ufs_device;\n\n\tdev_err(hba->dev, \"UFS Host state=%d\\n\", hba->ufshcd_state);\n\tdev_err(hba->dev, \"outstanding reqs=0x%lx tasks=0x%lx\\n\",\n\t\thba->outstanding_reqs, hba->outstanding_tasks);\n\tdev_err(hba->dev, \"saved_err=0x%x, saved_uic_err=0x%x\\n\",\n\t\thba->saved_err, hba->saved_uic_err);\n\tdev_err(hba->dev, \"Device power mode=%d, UIC link state=%d\\n\",\n\t\thba->curr_dev_pwr_mode, hba->uic_link_state);\n\tdev_err(hba->dev, \"PM in progress=%d, sys. suspended=%d\\n\",\n\t\thba->pm_op_in_progress, hba->is_sys_suspended);\n\tdev_err(hba->dev, \"Auto BKOPS=%d, Host self-block=%d\\n\",\n\t\thba->auto_bkops_enabled, hba->host->host_self_blocked);\n\tdev_err(hba->dev, \"Clk gate=%d\\n\", hba->clk_gating.state);\n\tdev_err(hba->dev,\n\t\t\"last_hibern8_exit_tstamp at %lld us, hibern8_exit_cnt=%d\\n\",\n\t\tktime_to_us(hba->ufs_stats.last_hibern8_exit_tstamp),\n\t\thba->ufs_stats.hibern8_exit_cnt);\n\tdev_err(hba->dev, \"last intr at %lld us, last intr status=0x%x\\n\",\n\t\tktime_to_us(hba->ufs_stats.last_intr_ts),\n\t\thba->ufs_stats.last_intr_status);\n\tdev_err(hba->dev, \"error handling flags=0x%x, req. abort count=%d\\n\",\n\t\thba->eh_flags, hba->req_abort_count);\n\tdev_err(hba->dev, \"hba->ufs_version=0x%x, Host capabilities=0x%x, caps=0x%x\\n\",\n\t\thba->ufs_version, hba->capabilities, hba->caps);\n\tdev_err(hba->dev, \"quirks=0x%x, dev. quirks=0x%x\\n\", hba->quirks,\n\t\thba->dev_quirks);\n\tif (sdev_ufs)\n\t\tdev_err(hba->dev, \"UFS dev info: %.8s %.16s rev %.4s\\n\",\n\t\t\tsdev_ufs->vendor, sdev_ufs->model, sdev_ufs->rev);\n\n\tufshcd_print_clk_freqs(hba);\n}\n\n/**\n * ufshcd_print_pwr_info - print power params as saved in hba\n * power info\n * @hba: per-adapter instance\n */\nstatic void ufshcd_print_pwr_info(struct ufs_hba *hba)\n{\n\tstatic const char * const names[] = {\n\t\t\"INVALID MODE\",\n\t\t\"FAST MODE\",\n\t\t\"SLOW_MODE\",\n\t\t\"INVALID MODE\",\n\t\t\"FASTAUTO_MODE\",\n\t\t\"SLOWAUTO_MODE\",\n\t\t\"INVALID MODE\",\n\t};\n\n\tdev_err(hba->dev, \"%s:[RX, TX]: gear=[%d, %d], lane[%d, %d], pwr[%s, %s], rate = %d\\n\",\n\t\t __func__,\n\t\t hba->pwr_info.gear_rx, hba->pwr_info.gear_tx,\n\t\t hba->pwr_info.lane_rx, hba->pwr_info.lane_tx,\n\t\t names[hba->pwr_info.pwr_rx],\n\t\t names[hba->pwr_info.pwr_tx],\n\t\t hba->pwr_info.hs_rate);\n}\n\nvoid ufshcd_delay_us(unsigned long us, unsigned long tolerance)\n{\n\tif (!us)\n\t\treturn;\n\n\tif (us < 10)\n\t\tudelay(us);\n\telse\n\t\tusleep_range(us, us + tolerance);\n}\nEXPORT_SYMBOL_GPL(ufshcd_delay_us);\n\n/**\n * ufshcd_wait_for_register - wait for register value to change\n * @hba: per-adapter interface\n * @reg: mmio register offset\n * @mask: mask to apply to the read register value\n * @val: value to wait for\n * @interval_us: polling interval in microseconds\n * @timeout_ms: timeout in milliseconds\n *\n * Return:\n * -ETIMEDOUT on error, zero on success.\n */\nint ufshcd_wait_for_register(struct ufs_hba *hba, u32 reg, u32 mask,\n\t\t\t\tu32 val, unsigned long interval_us,\n\t\t\t\tunsigned long timeout_ms)\n{\n\tint err = 0;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(timeout_ms);\n\n\t/* ignore bits that we don't intend to wait on */\n\tval = val & mask;\n\n\twhile ((ufshcd_readl(hba, reg) & mask) != val) {\n\t\tusleep_range(interval_us, interval_us + 50);\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tif ((ufshcd_readl(hba, reg) & mask) != val)\n\t\t\t\terr = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n/**\n * ufshcd_get_intr_mask - Get the interrupt bit mask\n * @hba: Pointer to adapter instance\n *\n * Returns interrupt bit mask per version\n */\nstatic inline u32 ufshcd_get_intr_mask(struct ufs_hba *hba)\n{\n\tu32 intr_mask = 0;\n\n\tswitch (hba->ufs_version) {\n\tcase UFSHCI_VERSION_10:\n\t\tintr_mask = INTERRUPT_MASK_ALL_VER_10;\n\t\tbreak;\n\tcase UFSHCI_VERSION_11:\n\tcase UFSHCI_VERSION_20:\n\t\tintr_mask = INTERRUPT_MASK_ALL_VER_11;\n\t\tbreak;\n\tcase UFSHCI_VERSION_21:\n\tdefault:\n\t\tintr_mask = INTERRUPT_MASK_ALL_VER_21;\n\t\tbreak;\n\t}\n\n\treturn intr_mask;\n}\n\n/**\n * ufshcd_get_ufs_version - Get the UFS version supported by the HBA\n * @hba: Pointer to adapter instance\n *\n * Returns UFSHCI version supported by the controller\n */\nstatic inline u32 ufshcd_get_ufs_version(struct ufs_hba *hba)\n{\n\tif (hba->quirks & UFSHCD_QUIRK_BROKEN_UFS_HCI_VERSION)\n\t\treturn ufshcd_vops_get_ufs_hci_version(hba);\n\n\treturn ufshcd_readl(hba, REG_UFS_VERSION);\n}\n\n/**\n * ufshcd_is_device_present - Check if any device connected to\n *\t\t\t      the host controller\n * @hba: pointer to adapter instance\n *\n * Returns true if device present, false if no device detected\n */\nstatic inline bool ufshcd_is_device_present(struct ufs_hba *hba)\n{\n\treturn (ufshcd_readl(hba, REG_CONTROLLER_STATUS) &\n\t\t\t\t\t\tDEVICE_PRESENT) ? true : false;\n}\n\n/**\n * ufshcd_get_tr_ocs - Get the UTRD Overall Command Status\n * @lrbp: pointer to local command reference block\n *\n * This function is used to get the OCS field from UTRD\n * Returns the OCS field in the UTRD\n */\nstatic inline int ufshcd_get_tr_ocs(struct ufshcd_lrb *lrbp)\n{\n\treturn le32_to_cpu(lrbp->utr_descriptor_ptr->header.dword_2) & MASK_OCS;\n}\n\n/**\n * ufshcd_utrl_clear - Clear a bit in UTRLCLR register\n * @hba: per adapter instance\n * @pos: position of the bit to be cleared\n */\nstatic inline void ufshcd_utrl_clear(struct ufs_hba *hba, u32 pos)\n{\n\tif (hba->quirks & UFSHCI_QUIRK_BROKEN_REQ_LIST_CLR)\n\t\tufshcd_writel(hba, (1 << pos), REG_UTP_TRANSFER_REQ_LIST_CLEAR);\n\telse\n\t\tufshcd_writel(hba, ~(1 << pos),\n\t\t\t\tREG_UTP_TRANSFER_REQ_LIST_CLEAR);\n}\n\n/**\n * ufshcd_utmrl_clear - Clear a bit in UTRMLCLR register\n * @hba: per adapter instance\n * @pos: position of the bit to be cleared\n */\nstatic inline void ufshcd_utmrl_clear(struct ufs_hba *hba, u32 pos)\n{\n\tif (hba->quirks & UFSHCI_QUIRK_BROKEN_REQ_LIST_CLR)\n\t\tufshcd_writel(hba, (1 << pos), REG_UTP_TASK_REQ_LIST_CLEAR);\n\telse\n\t\tufshcd_writel(hba, ~(1 << pos), REG_UTP_TASK_REQ_LIST_CLEAR);\n}\n\n/**\n * ufshcd_outstanding_req_clear - Clear a bit in outstanding request field\n * @hba: per adapter instance\n * @tag: position of the bit to be cleared\n */\nstatic inline void ufshcd_outstanding_req_clear(struct ufs_hba *hba, int tag)\n{\n\t__clear_bit(tag, &hba->outstanding_reqs);\n}\n\n/**\n * ufshcd_get_lists_status - Check UCRDY, UTRLRDY and UTMRLRDY\n * @reg: Register value of host controller status\n *\n * Returns integer, 0 on Success and positive value if failed\n */\nstatic inline int ufshcd_get_lists_status(u32 reg)\n{\n\treturn !((reg & UFSHCD_STATUS_READY) == UFSHCD_STATUS_READY);\n}\n\n/**\n * ufshcd_get_uic_cmd_result - Get the UIC command result\n * @hba: Pointer to adapter instance\n *\n * This function gets the result of UIC command completion\n * Returns 0 on success, non zero value on error\n */\nstatic inline int ufshcd_get_uic_cmd_result(struct ufs_hba *hba)\n{\n\treturn ufshcd_readl(hba, REG_UIC_COMMAND_ARG_2) &\n\t       MASK_UIC_COMMAND_RESULT;\n}\n\n/**\n * ufshcd_get_dme_attr_val - Get the value of attribute returned by UIC command\n * @hba: Pointer to adapter instance\n *\n * This function gets UIC command argument3\n * Returns 0 on success, non zero value on error\n */\nstatic inline u32 ufshcd_get_dme_attr_val(struct ufs_hba *hba)\n{\n\treturn ufshcd_readl(hba, REG_UIC_COMMAND_ARG_3);\n}\n\n/**\n * ufshcd_get_req_rsp - returns the TR response transaction type\n * @ucd_rsp_ptr: pointer to response UPIU\n */\nstatic inline int\nufshcd_get_req_rsp(struct utp_upiu_rsp *ucd_rsp_ptr)\n{\n\treturn be32_to_cpu(ucd_rsp_ptr->header.dword_0) >> 24;\n}\n\n/**\n * ufshcd_get_rsp_upiu_result - Get the result from response UPIU\n * @ucd_rsp_ptr: pointer to response UPIU\n *\n * This function gets the response status and scsi_status from response UPIU\n * Returns the response result code.\n */\nstatic inline int\nufshcd_get_rsp_upiu_result(struct utp_upiu_rsp *ucd_rsp_ptr)\n{\n\treturn be32_to_cpu(ucd_rsp_ptr->header.dword_1) & MASK_RSP_UPIU_RESULT;\n}\n\n/*\n * ufshcd_get_rsp_upiu_data_seg_len - Get the data segment length\n *\t\t\t\tfrom response UPIU\n * @ucd_rsp_ptr: pointer to response UPIU\n *\n * Return the data segment length.\n */\nstatic inline unsigned int\nufshcd_get_rsp_upiu_data_seg_len(struct utp_upiu_rsp *ucd_rsp_ptr)\n{\n\treturn be32_to_cpu(ucd_rsp_ptr->header.dword_2) &\n\t\tMASK_RSP_UPIU_DATA_SEG_LEN;\n}\n\n/**\n * ufshcd_is_exception_event - Check if the device raised an exception event\n * @ucd_rsp_ptr: pointer to response UPIU\n *\n * The function checks if the device raised an exception event indicated in\n * the Device Information field of response UPIU.\n *\n * Returns true if exception is raised, false otherwise.\n */\nstatic inline bool ufshcd_is_exception_event(struct utp_upiu_rsp *ucd_rsp_ptr)\n{\n\treturn be32_to_cpu(ucd_rsp_ptr->header.dword_2) &\n\t\t\tMASK_RSP_EXCEPTION_EVENT ? true : false;\n}\n\n/**\n * ufshcd_reset_intr_aggr - Reset interrupt aggregation values.\n * @hba: per adapter instance\n */\nstatic inline void\nufshcd_reset_intr_aggr(struct ufs_hba *hba)\n{\n\tufshcd_writel(hba, INT_AGGR_ENABLE |\n\t\t      INT_AGGR_COUNTER_AND_TIMER_RESET,\n\t\t      REG_UTP_TRANSFER_REQ_INT_AGG_CONTROL);\n}\n\n/**\n * ufshcd_config_intr_aggr - Configure interrupt aggregation values.\n * @hba: per adapter instance\n * @cnt: Interrupt aggregation counter threshold\n * @tmout: Interrupt aggregation timeout value\n */\nstatic inline void\nufshcd_config_intr_aggr(struct ufs_hba *hba, u8 cnt, u8 tmout)\n{\n\tufshcd_writel(hba, INT_AGGR_ENABLE | INT_AGGR_PARAM_WRITE |\n\t\t      INT_AGGR_COUNTER_THLD_VAL(cnt) |\n\t\t      INT_AGGR_TIMEOUT_VAL(tmout),\n\t\t      REG_UTP_TRANSFER_REQ_INT_AGG_CONTROL);\n}\n\n/**\n * ufshcd_disable_intr_aggr - Disables interrupt aggregation.\n * @hba: per adapter instance\n */\nstatic inline void ufshcd_disable_intr_aggr(struct ufs_hba *hba)\n{\n\tufshcd_writel(hba, 0, REG_UTP_TRANSFER_REQ_INT_AGG_CONTROL);\n}\n\n/**\n * ufshcd_enable_run_stop_reg - Enable run-stop registers,\n *\t\t\tWhen run-stop registers are set to 1, it indicates the\n *\t\t\thost controller that it can process the requests\n * @hba: per adapter instance\n */\nstatic void ufshcd_enable_run_stop_reg(struct ufs_hba *hba)\n{\n\tufshcd_writel(hba, UTP_TASK_REQ_LIST_RUN_STOP_BIT,\n\t\t      REG_UTP_TASK_REQ_LIST_RUN_STOP);\n\tufshcd_writel(hba, UTP_TRANSFER_REQ_LIST_RUN_STOP_BIT,\n\t\t      REG_UTP_TRANSFER_REQ_LIST_RUN_STOP);\n}\n\n/**\n * ufshcd_hba_start - Start controller initialization sequence\n * @hba: per adapter instance\n */\nstatic inline void ufshcd_hba_start(struct ufs_hba *hba)\n{\n\tu32 val = CONTROLLER_ENABLE;\n\n\tif (ufshcd_crypto_enable(hba))\n\t\tval |= CRYPTO_GENERAL_ENABLE;\n\n\tufshcd_writel(hba, val, REG_CONTROLLER_ENABLE);\n}\n\n/**\n * ufshcd_is_hba_active - Get controller state\n * @hba: per adapter instance\n *\n * Returns false if controller is active, true otherwise\n */\nstatic inline bool ufshcd_is_hba_active(struct ufs_hba *hba)\n{\n\treturn (ufshcd_readl(hba, REG_CONTROLLER_ENABLE) & CONTROLLER_ENABLE)\n\t\t? false : true;\n}\n\nu32 ufshcd_get_local_unipro_ver(struct ufs_hba *hba)\n{\n\t/* HCI version 1.0 and 1.1 supports UniPro 1.41 */\n\tif ((hba->ufs_version == UFSHCI_VERSION_10) ||\n\t    (hba->ufs_version == UFSHCI_VERSION_11))\n\t\treturn UFS_UNIPRO_VER_1_41;\n\telse\n\t\treturn UFS_UNIPRO_VER_1_6;\n}\nEXPORT_SYMBOL(ufshcd_get_local_unipro_ver);\n\nstatic bool ufshcd_is_unipro_pa_params_tuning_req(struct ufs_hba *hba)\n{\n\t/*\n\t * If both host and device support UniPro ver1.6 or later, PA layer\n\t * parameters tuning happens during link startup itself.\n\t *\n\t * We can manually tune PA layer parameters if either host or device\n\t * doesn't support UniPro ver 1.6 or later. But to keep manual tuning\n\t * logic simple, we will only do manual tuning if local unipro version\n\t * doesn't support ver1.6 or later.\n\t */\n\tif (ufshcd_get_local_unipro_ver(hba) < UFS_UNIPRO_VER_1_6)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n/**\n * ufshcd_set_clk_freq - set UFS controller clock frequencies\n * @hba: per adapter instance\n * @scale_up: If True, set max possible frequency othewise set low frequency\n *\n * Returns 0 if successful\n * Returns < 0 for any other errors\n */\nstatic int ufshcd_set_clk_freq(struct ufs_hba *hba, bool scale_up)\n{\n\tint ret = 0;\n\tstruct ufs_clk_info *clki;\n\tstruct list_head *head = &hba->clk_list_head;\n\n\tif (list_empty(head))\n\t\tgoto out;\n\n\tlist_for_each_entry(clki, head, list) {\n\t\tif (!IS_ERR_OR_NULL(clki->clk)) {\n\t\t\tif (scale_up && clki->max_freq) {\n\t\t\t\tif (clki->curr_freq == clki->max_freq)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tret = clk_set_rate(clki->clk, clki->max_freq);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(hba->dev, \"%s: %s clk set rate(%dHz) failed, %d\\n\",\n\t\t\t\t\t\t__func__, clki->name,\n\t\t\t\t\t\tclki->max_freq, ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttrace_ufshcd_clk_scaling(dev_name(hba->dev),\n\t\t\t\t\t\t\"scaled up\", clki->name,\n\t\t\t\t\t\tclki->curr_freq,\n\t\t\t\t\t\tclki->max_freq);\n\n\t\t\t\tclki->curr_freq = clki->max_freq;\n\n\t\t\t} else if (!scale_up && clki->min_freq) {\n\t\t\t\tif (clki->curr_freq == clki->min_freq)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tret = clk_set_rate(clki->clk, clki->min_freq);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(hba->dev, \"%s: %s clk set rate(%dHz) failed, %d\\n\",\n\t\t\t\t\t\t__func__, clki->name,\n\t\t\t\t\t\tclki->min_freq, ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttrace_ufshcd_clk_scaling(dev_name(hba->dev),\n\t\t\t\t\t\t\"scaled down\", clki->name,\n\t\t\t\t\t\tclki->curr_freq,\n\t\t\t\t\t\tclki->min_freq);\n\t\t\t\tclki->curr_freq = clki->min_freq;\n\t\t\t}\n\t\t}\n\t\tdev_dbg(hba->dev, \"%s: clk: %s, rate: %lu\\n\", __func__,\n\t\t\t\tclki->name, clk_get_rate(clki->clk));\n\t}\n\nout:\n\treturn ret;\n}\n\n/**\n * ufshcd_scale_clks - scale up or scale down UFS controller clocks\n * @hba: per adapter instance\n * @scale_up: True if scaling up and false if scaling down\n *\n * Returns 0 if successful\n * Returns < 0 for any other errors\n */\nstatic int ufshcd_scale_clks(struct ufs_hba *hba, bool scale_up)\n{\n\tint ret = 0;\n\tktime_t start = ktime_get();\n\n\tret = ufshcd_vops_clk_scale_notify(hba, scale_up, PRE_CHANGE);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ufshcd_set_clk_freq(hba, scale_up);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ufshcd_vops_clk_scale_notify(hba, scale_up, POST_CHANGE);\n\tif (ret)\n\t\tufshcd_set_clk_freq(hba, !scale_up);\n\nout:\n\ttrace_ufshcd_profile_clk_scaling(dev_name(hba->dev),\n\t\t\t(scale_up ? \"up\" : \"down\"),\n\t\t\tktime_to_us(ktime_sub(ktime_get(), start)), ret);\n\treturn ret;\n}\n\n/**\n * ufshcd_is_devfreq_scaling_required - check if scaling is required or not\n * @hba: per adapter instance\n * @scale_up: True if scaling up and false if scaling down\n *\n * Returns true if scaling is required, false otherwise.\n */\nstatic bool ufshcd_is_devfreq_scaling_required(struct ufs_hba *hba,\n\t\t\t\t\t       bool scale_up)\n{\n\tstruct ufs_clk_info *clki;\n\tstruct list_head *head = &hba->clk_list_head;\n\n\tif (list_empty(head))\n\t\treturn false;\n\n\tlist_for_each_entry(clki, head, list) {\n\t\tif (!IS_ERR_OR_NULL(clki->clk)) {\n\t\t\tif (scale_up && clki->max_freq) {\n\t\t\t\tif (clki->curr_freq == clki->max_freq)\n\t\t\t\t\tcontinue;\n\t\t\t\treturn true;\n\t\t\t} else if (!scale_up && clki->min_freq) {\n\t\t\t\tif (clki->curr_freq == clki->min_freq)\n\t\t\t\t\tcontinue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int ufshcd_wait_for_doorbell_clr(struct ufs_hba *hba,\n\t\t\t\t\tu64 wait_timeout_us)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\tu32 tm_doorbell;\n\tu32 tr_doorbell;\n\tbool timeout = false, do_last_check = false;\n\tktime_t start;\n\n\tufshcd_hold(hba, false);\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t/*\n\t * Wait for all the outstanding tasks/transfer requests.\n\t * Verify by checking the doorbell registers are clear.\n\t */\n\tstart = ktime_get();\n\tdo {\n\t\tif (hba->ufshcd_state != UFSHCD_STATE_OPERATIONAL) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttm_doorbell = ufshcd_readl(hba, REG_UTP_TASK_REQ_DOOR_BELL);\n\t\ttr_doorbell = ufshcd_readl(hba, REG_UTP_TRANSFER_REQ_DOOR_BELL);\n\t\tif (!tm_doorbell && !tr_doorbell) {\n\t\t\ttimeout = false;\n\t\t\tbreak;\n\t\t} else if (do_last_check) {\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\tschedule();\n\t\tif (ktime_to_us(ktime_sub(ktime_get(), start)) >\n\t\t    wait_timeout_us) {\n\t\t\ttimeout = true;\n\t\t\t/*\n\t\t\t * We might have scheduled out for long time so make\n\t\t\t * sure to check if doorbells are cleared by this time\n\t\t\t * or not.\n\t\t\t */\n\t\t\tdo_last_check = true;\n\t\t}\n\t\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t} while (tm_doorbell || tr_doorbell);\n\n\tif (timeout) {\n\t\tdev_err(hba->dev,\n\t\t\t\"%s: timedout waiting for doorbell to clear (tm=0x%x, tr=0x%x)\\n\",\n\t\t\t__func__, tm_doorbell, tr_doorbell);\n\t\tret = -EBUSY;\n\t}\nout:\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\tufshcd_release(hba);\n\treturn ret;\n}\n\n/**\n * ufshcd_scale_gear - scale up/down UFS gear\n * @hba: per adapter instance\n * @scale_up: True for scaling up gear and false for scaling down\n *\n * Returns 0 for success,\n * Returns -EBUSY if scaling can't happen at this time\n * Returns non-zero for any other errors\n */\nstatic int ufshcd_scale_gear(struct ufs_hba *hba, bool scale_up)\n{\n\tint ret = 0;\n\tstruct ufs_pa_layer_attr new_pwr_info;\n\n\tif (scale_up) {\n\t\tmemcpy(&new_pwr_info, &hba->clk_scaling.saved_pwr_info.info,\n\t\t       sizeof(struct ufs_pa_layer_attr));\n\t} else {\n\t\tmemcpy(&new_pwr_info, &hba->pwr_info,\n\t\t       sizeof(struct ufs_pa_layer_attr));\n\n\t\tif (hba->pwr_info.gear_tx > hba->clk_scaling.min_gear ||\n\t\t    hba->pwr_info.gear_rx > hba->clk_scaling.min_gear) {\n\t\t\t/* save the current power mode */\n\t\t\tmemcpy(&hba->clk_scaling.saved_pwr_info.info,\n\t\t\t\t&hba->pwr_info,\n\t\t\t\tsizeof(struct ufs_pa_layer_attr));\n\n\t\t\t/* scale down gear */\n\t\t\tnew_pwr_info.gear_tx = hba->clk_scaling.min_gear;\n\t\t\tnew_pwr_info.gear_rx = hba->clk_scaling.min_gear;\n\t\t}\n\t}\n\n\t/* check if the power mode needs to be changed or not? */\n\tret = ufshcd_config_pwr_mode(hba, &new_pwr_info);\n\tif (ret)\n\t\tdev_err(hba->dev, \"%s: failed err %d, old gear: (tx %d rx %d), new gear: (tx %d rx %d)\",\n\t\t\t__func__, ret,\n\t\t\thba->pwr_info.gear_tx, hba->pwr_info.gear_rx,\n\t\t\tnew_pwr_info.gear_tx, new_pwr_info.gear_rx);\n\n\treturn ret;\n}\n\nstatic int ufshcd_clock_scaling_prepare(struct ufs_hba *hba)\n{\n\t#define DOORBELL_CLR_TOUT_US\t\t(1000 * 1000) /* 1 sec */\n\tint ret = 0;\n\t/*\n\t * make sure that there are no outstanding requests when\n\t * clock scaling is in progress\n\t */\n\tufshcd_scsi_block_requests(hba);\n\tdown_write(&hba->clk_scaling_lock);\n\tif (ufshcd_wait_for_doorbell_clr(hba, DOORBELL_CLR_TOUT_US)) {\n\t\tret = -EBUSY;\n\t\tup_write(&hba->clk_scaling_lock);\n\t\tufshcd_scsi_unblock_requests(hba);\n\t}\n\n\treturn ret;\n}\n\nstatic void ufshcd_clock_scaling_unprepare(struct ufs_hba *hba)\n{\n\tup_write(&hba->clk_scaling_lock);\n\tufshcd_scsi_unblock_requests(hba);\n}\n\n/**\n * ufshcd_devfreq_scale - scale up/down UFS clocks and gear\n * @hba: per adapter instance\n * @scale_up: True for scaling up and false for scalin down\n *\n * Returns 0 for success,\n * Returns -EBUSY if scaling can't happen at this time\n * Returns non-zero for any other errors\n */\nstatic int ufshcd_devfreq_scale(struct ufs_hba *hba, bool scale_up)\n{\n\tint ret = 0;\n\n\t/* let's not get into low power until clock scaling is completed */\n\tufshcd_hold(hba, false);\n\n\tret = ufshcd_clock_scaling_prepare(hba);\n\tif (ret)\n\t\tgoto out;\n\n\t/* scale down the gear before scaling down clocks */\n\tif (!scale_up) {\n\t\tret = ufshcd_scale_gear(hba, false);\n\t\tif (ret)\n\t\t\tgoto out_unprepare;\n\t}\n\n\tret = ufshcd_scale_clks(hba, scale_up);\n\tif (ret) {\n\t\tif (!scale_up)\n\t\t\tufshcd_scale_gear(hba, true);\n\t\tgoto out_unprepare;\n\t}\n\n\t/* scale up the gear after scaling up clocks */\n\tif (scale_up) {\n\t\tret = ufshcd_scale_gear(hba, true);\n\t\tif (ret) {\n\t\t\tufshcd_scale_clks(hba, false);\n\t\t\tgoto out_unprepare;\n\t\t}\n\t}\n\n\t/* Enable Write Booster if we have scaled up else disable it */\n\tup_write(&hba->clk_scaling_lock);\n\tufshcd_wb_ctrl(hba, scale_up);\n\tdown_write(&hba->clk_scaling_lock);\n\nout_unprepare:\n\tufshcd_clock_scaling_unprepare(hba);\nout:\n\tufshcd_release(hba);\n\treturn ret;\n}\n\nstatic void ufshcd_clk_scaling_suspend_work(struct work_struct *work)\n{\n\tstruct ufs_hba *hba = container_of(work, struct ufs_hba,\n\t\t\t\t\t   clk_scaling.suspend_work);\n\tunsigned long irq_flags;\n\n\tspin_lock_irqsave(hba->host->host_lock, irq_flags);\n\tif (hba->clk_scaling.active_reqs || hba->clk_scaling.is_suspended) {\n\t\tspin_unlock_irqrestore(hba->host->host_lock, irq_flags);\n\t\treturn;\n\t}\n\thba->clk_scaling.is_suspended = true;\n\tspin_unlock_irqrestore(hba->host->host_lock, irq_flags);\n\n\t__ufshcd_suspend_clkscaling(hba);\n}\n\nstatic void ufshcd_clk_scaling_resume_work(struct work_struct *work)\n{\n\tstruct ufs_hba *hba = container_of(work, struct ufs_hba,\n\t\t\t\t\t   clk_scaling.resume_work);\n\tunsigned long irq_flags;\n\n\tspin_lock_irqsave(hba->host->host_lock, irq_flags);\n\tif (!hba->clk_scaling.is_suspended) {\n\t\tspin_unlock_irqrestore(hba->host->host_lock, irq_flags);\n\t\treturn;\n\t}\n\thba->clk_scaling.is_suspended = false;\n\tspin_unlock_irqrestore(hba->host->host_lock, irq_flags);\n\n\tdevfreq_resume_device(hba->devfreq);\n}\n\nstatic int ufshcd_devfreq_target(struct device *dev,\n\t\t\t\tunsigned long *freq, u32 flags)\n{\n\tint ret = 0;\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\tktime_t start;\n\tbool scale_up, sched_clk_scaling_suspend_work = false;\n\tstruct list_head *clk_list = &hba->clk_list_head;\n\tstruct ufs_clk_info *clki;\n\tunsigned long irq_flags;\n\n\tif (!ufshcd_is_clkscaling_supported(hba))\n\t\treturn -EINVAL;\n\n\tclki = list_first_entry(&hba->clk_list_head, struct ufs_clk_info, list);\n\t/* Override with the closest supported frequency */\n\t*freq = (unsigned long) clk_round_rate(clki->clk, *freq);\n\tspin_lock_irqsave(hba->host->host_lock, irq_flags);\n\tif (ufshcd_eh_in_progress(hba)) {\n\t\tspin_unlock_irqrestore(hba->host->host_lock, irq_flags);\n\t\treturn 0;\n\t}\n\n\tif (!hba->clk_scaling.active_reqs)\n\t\tsched_clk_scaling_suspend_work = true;\n\n\tif (list_empty(clk_list)) {\n\t\tspin_unlock_irqrestore(hba->host->host_lock, irq_flags);\n\t\tgoto out;\n\t}\n\n\t/* Decide based on the rounded-off frequency and update */\n\tscale_up = (*freq == clki->max_freq) ? true : false;\n\tif (!scale_up)\n\t\t*freq = clki->min_freq;\n\t/* Update the frequency */\n\tif (!ufshcd_is_devfreq_scaling_required(hba, scale_up)) {\n\t\tspin_unlock_irqrestore(hba->host->host_lock, irq_flags);\n\t\tret = 0;\n\t\tgoto out; /* no state change required */\n\t}\n\tspin_unlock_irqrestore(hba->host->host_lock, irq_flags);\n\n\tpm_runtime_get_noresume(hba->dev);\n\tif (!pm_runtime_active(hba->dev)) {\n\t\tpm_runtime_put_noidle(hba->dev);\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\tstart = ktime_get();\n\tret = ufshcd_devfreq_scale(hba, scale_up);\n\tpm_runtime_put(hba->dev);\n\n\ttrace_ufshcd_profile_clk_scaling(dev_name(hba->dev),\n\t\t(scale_up ? \"up\" : \"down\"),\n\t\tktime_to_us(ktime_sub(ktime_get(), start)), ret);\n\nout:\n\tif (sched_clk_scaling_suspend_work)\n\t\tqueue_work(hba->clk_scaling.workq,\n\t\t\t   &hba->clk_scaling.suspend_work);\n\n\treturn ret;\n}\n\nstatic bool ufshcd_is_busy(struct request *req, void *priv, bool reserved)\n{\n\tint *busy = priv;\n\n\tWARN_ON_ONCE(reserved);\n\t(*busy)++;\n\treturn false;\n}\n\n/* Whether or not any tag is in use by a request that is in progress. */\nstatic bool ufshcd_any_tag_in_use(struct ufs_hba *hba)\n{\n\tstruct request_queue *q = hba->cmd_queue;\n\tint busy = 0;\n\n\tblk_mq_tagset_busy_iter(q->tag_set, ufshcd_is_busy, &busy);\n\treturn busy;\n}\n\nstatic int ufshcd_devfreq_get_dev_status(struct device *dev,\n\t\tstruct devfreq_dev_status *stat)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\tstruct ufs_clk_scaling *scaling = &hba->clk_scaling;\n\tunsigned long flags;\n\tstruct list_head *clk_list = &hba->clk_list_head;\n\tstruct ufs_clk_info *clki;\n\tktime_t curr_t;\n\n\tif (!ufshcd_is_clkscaling_supported(hba))\n\t\treturn -EINVAL;\n\n\tmemset(stat, 0, sizeof(*stat));\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tcurr_t = ktime_get();\n\tif (!scaling->window_start_t)\n\t\tgoto start_window;\n\n\tclki = list_first_entry(clk_list, struct ufs_clk_info, list);\n\t/*\n\t * If current frequency is 0, then the ondemand governor considers\n\t * there's no initial frequency set. And it always requests to set\n\t * to max. frequency.\n\t */\n\tstat->current_frequency = clki->curr_freq;\n\tif (scaling->is_busy_started)\n\t\tscaling->tot_busy_t += ktime_us_delta(curr_t,\n\t\t\t\tscaling->busy_start_t);\n\n\tstat->total_time = ktime_us_delta(curr_t, scaling->window_start_t);\n\tstat->busy_time = scaling->tot_busy_t;\nstart_window:\n\tscaling->window_start_t = curr_t;\n\tscaling->tot_busy_t = 0;\n\n\tif (hba->outstanding_reqs) {\n\t\tscaling->busy_start_t = curr_t;\n\t\tscaling->is_busy_started = true;\n\t} else {\n\t\tscaling->busy_start_t = 0;\n\t\tscaling->is_busy_started = false;\n\t}\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\treturn 0;\n}\n\nstatic int ufshcd_devfreq_init(struct ufs_hba *hba)\n{\n\tstruct list_head *clk_list = &hba->clk_list_head;\n\tstruct ufs_clk_info *clki;\n\tstruct devfreq *devfreq;\n\tint ret;\n\n\t/* Skip devfreq if we don't have any clocks in the list */\n\tif (list_empty(clk_list))\n\t\treturn 0;\n\n\tclki = list_first_entry(clk_list, struct ufs_clk_info, list);\n\tdev_pm_opp_add(hba->dev, clki->min_freq, 0);\n\tdev_pm_opp_add(hba->dev, clki->max_freq, 0);\n\n\tufshcd_vops_config_scaling_param(hba, &hba->vps->devfreq_profile,\n\t\t\t\t\t &hba->vps->ondemand_data);\n\tdevfreq = devfreq_add_device(hba->dev,\n\t\t\t&hba->vps->devfreq_profile,\n\t\t\tDEVFREQ_GOV_SIMPLE_ONDEMAND,\n\t\t\t&hba->vps->ondemand_data);\n\tif (IS_ERR(devfreq)) {\n\t\tret = PTR_ERR(devfreq);\n\t\tdev_err(hba->dev, \"Unable to register with devfreq %d\\n\", ret);\n\n\t\tdev_pm_opp_remove(hba->dev, clki->min_freq);\n\t\tdev_pm_opp_remove(hba->dev, clki->max_freq);\n\t\treturn ret;\n\t}\n\n\thba->devfreq = devfreq;\n\n\treturn 0;\n}\n\nstatic void ufshcd_devfreq_remove(struct ufs_hba *hba)\n{\n\tstruct list_head *clk_list = &hba->clk_list_head;\n\tstruct ufs_clk_info *clki;\n\n\tif (!hba->devfreq)\n\t\treturn;\n\n\tdevfreq_remove_device(hba->devfreq);\n\thba->devfreq = NULL;\n\n\tclki = list_first_entry(clk_list, struct ufs_clk_info, list);\n\tdev_pm_opp_remove(hba->dev, clki->min_freq);\n\tdev_pm_opp_remove(hba->dev, clki->max_freq);\n}\n\nstatic void __ufshcd_suspend_clkscaling(struct ufs_hba *hba)\n{\n\tunsigned long flags;\n\n\tdevfreq_suspend_device(hba->devfreq);\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\thba->clk_scaling.window_start_t = 0;\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n}\n\nstatic void ufshcd_suspend_clkscaling(struct ufs_hba *hba)\n{\n\tunsigned long flags;\n\tbool suspend = false;\n\n\tif (!ufshcd_is_clkscaling_supported(hba))\n\t\treturn;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tif (!hba->clk_scaling.is_suspended) {\n\t\tsuspend = true;\n\t\thba->clk_scaling.is_suspended = true;\n\t}\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\tif (suspend)\n\t\t__ufshcd_suspend_clkscaling(hba);\n}\n\nstatic void ufshcd_resume_clkscaling(struct ufs_hba *hba)\n{\n\tunsigned long flags;\n\tbool resume = false;\n\n\tif (!ufshcd_is_clkscaling_supported(hba))\n\t\treturn;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tif (hba->clk_scaling.is_suspended) {\n\t\tresume = true;\n\t\thba->clk_scaling.is_suspended = false;\n\t}\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\tif (resume)\n\t\tdevfreq_resume_device(hba->devfreq);\n}\n\nstatic ssize_t ufshcd_clkscale_enable_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", hba->clk_scaling.is_allowed);\n}\n\nstatic ssize_t ufshcd_clkscale_enable_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\tu32 value;\n\tint err;\n\n\tif (kstrtou32(buf, 0, &value))\n\t\treturn -EINVAL;\n\n\tvalue = !!value;\n\tif (value == hba->clk_scaling.is_allowed)\n\t\tgoto out;\n\n\tpm_runtime_get_sync(hba->dev);\n\tufshcd_hold(hba, false);\n\n\tcancel_work_sync(&hba->clk_scaling.suspend_work);\n\tcancel_work_sync(&hba->clk_scaling.resume_work);\n\n\thba->clk_scaling.is_allowed = value;\n\n\tif (value) {\n\t\tufshcd_resume_clkscaling(hba);\n\t} else {\n\t\tufshcd_suspend_clkscaling(hba);\n\t\terr = ufshcd_devfreq_scale(hba, true);\n\t\tif (err)\n\t\t\tdev_err(hba->dev, \"%s: failed to scale clocks up %d\\n\",\n\t\t\t\t\t__func__, err);\n\t}\n\n\tufshcd_release(hba);\n\tpm_runtime_put_sync(hba->dev);\nout:\n\treturn count;\n}\n\nstatic void ufshcd_clkscaling_init_sysfs(struct ufs_hba *hba)\n{\n\thba->clk_scaling.enable_attr.show = ufshcd_clkscale_enable_show;\n\thba->clk_scaling.enable_attr.store = ufshcd_clkscale_enable_store;\n\tsysfs_attr_init(&hba->clk_scaling.enable_attr.attr);\n\thba->clk_scaling.enable_attr.attr.name = \"clkscale_enable\";\n\thba->clk_scaling.enable_attr.attr.mode = 0644;\n\tif (device_create_file(hba->dev, &hba->clk_scaling.enable_attr))\n\t\tdev_err(hba->dev, \"Failed to create sysfs for clkscale_enable\\n\");\n}\n\nstatic void ufshcd_ungate_work(struct work_struct *work)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct ufs_hba *hba = container_of(work, struct ufs_hba,\n\t\t\tclk_gating.ungate_work);\n\n\tcancel_delayed_work_sync(&hba->clk_gating.gate_work);\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tif (hba->clk_gating.state == CLKS_ON) {\n\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\tgoto unblock_reqs;\n\t}\n\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\tufshcd_hba_vreg_set_hpm(hba);\n\tufshcd_setup_clocks(hba, true);\n\n\tufshcd_enable_irq(hba);\n\n\t/* Exit from hibern8 */\n\tif (ufshcd_can_hibern8_during_gating(hba)) {\n\t\t/* Prevent gating in this path */\n\t\thba->clk_gating.is_suspended = true;\n\t\tif (ufshcd_is_link_hibern8(hba)) {\n\t\t\tret = ufshcd_uic_hibern8_exit(hba);\n\t\t\tif (ret)\n\t\t\t\tdev_err(hba->dev, \"%s: hibern8 exit failed %d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\telse\n\t\t\t\tufshcd_set_link_active(hba);\n\t\t}\n\t\thba->clk_gating.is_suspended = false;\n\t}\nunblock_reqs:\n\tufshcd_scsi_unblock_requests(hba);\n}\n\n/**\n * ufshcd_hold - Enable clocks that were gated earlier due to ufshcd_release.\n * Also, exit from hibern8 mode and set the link as active.\n * @hba: per adapter instance\n * @async: This indicates whether caller should ungate clocks asynchronously.\n */\nint ufshcd_hold(struct ufs_hba *hba, bool async)\n{\n\tint rc = 0;\n\tbool flush_result;\n\tunsigned long flags;\n\n\tif (!ufshcd_is_clkgating_allowed(hba))\n\t\tgoto out;\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\thba->clk_gating.active_reqs++;\n\nstart:\n\tswitch (hba->clk_gating.state) {\n\tcase CLKS_ON:\n\t\t/*\n\t\t * Wait for the ungate work to complete if in progress.\n\t\t * Though the clocks may be in ON state, the link could\n\t\t * still be in hibner8 state if hibern8 is allowed\n\t\t * during clock gating.\n\t\t * Make sure we exit hibern8 state also in addition to\n\t\t * clocks being ON.\n\t\t */\n\t\tif (ufshcd_can_hibern8_during_gating(hba) &&\n\t\t    ufshcd_is_link_hibern8(hba)) {\n\t\t\tif (async) {\n\t\t\t\trc = -EAGAIN;\n\t\t\t\thba->clk_gating.active_reqs--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\t\tflush_result = flush_work(&hba->clk_gating.ungate_work);\n\t\t\tif (hba->clk_gating.is_suspended && !flush_result)\n\t\t\t\tgoto out;\n\t\t\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t\t\tgoto start;\n\t\t}\n\t\tbreak;\n\tcase REQ_CLKS_OFF:\n\t\tif (cancel_delayed_work(&hba->clk_gating.gate_work)) {\n\t\t\thba->clk_gating.state = CLKS_ON;\n\t\t\ttrace_ufshcd_clk_gating(dev_name(hba->dev),\n\t\t\t\t\t\thba->clk_gating.state);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If we are here, it means gating work is either done or\n\t\t * currently running. Hence, fall through to cancel gating\n\t\t * work and to enable clocks.\n\t\t */\n\t\tfallthrough;\n\tcase CLKS_OFF:\n\t\thba->clk_gating.state = REQ_CLKS_ON;\n\t\ttrace_ufshcd_clk_gating(dev_name(hba->dev),\n\t\t\t\t\thba->clk_gating.state);\n\t\tif (queue_work(hba->clk_gating.clk_gating_workq,\n\t\t\t       &hba->clk_gating.ungate_work))\n\t\t\tufshcd_scsi_block_requests(hba);\n\t\t/*\n\t\t * fall through to check if we should wait for this\n\t\t * work to be done or not.\n\t\t */\n\t\tfallthrough;\n\tcase REQ_CLKS_ON:\n\t\tif (async) {\n\t\t\trc = -EAGAIN;\n\t\t\thba->clk_gating.active_reqs--;\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\tflush_work(&hba->clk_gating.ungate_work);\n\t\t/* Make sure state is CLKS_ON before returning */\n\t\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t\tgoto start;\n\tdefault:\n\t\tdev_err(hba->dev, \"%s: clk gating is in invalid state %d\\n\",\n\t\t\t\t__func__, hba->clk_gating.state);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\nout:\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ufshcd_hold);\n\nstatic void ufshcd_gate_work(struct work_struct *work)\n{\n\tstruct ufs_hba *hba = container_of(work, struct ufs_hba,\n\t\t\tclk_gating.gate_work.work);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t/*\n\t * In case you are here to cancel this work the gating state\n\t * would be marked as REQ_CLKS_ON. In this case save time by\n\t * skipping the gating work and exit after changing the clock\n\t * state to CLKS_ON.\n\t */\n\tif (hba->clk_gating.is_suspended ||\n\t\t(hba->clk_gating.state != REQ_CLKS_OFF)) {\n\t\thba->clk_gating.state = CLKS_ON;\n\t\ttrace_ufshcd_clk_gating(dev_name(hba->dev),\n\t\t\t\t\thba->clk_gating.state);\n\t\tgoto rel_lock;\n\t}\n\n\tif (hba->clk_gating.active_reqs\n\t\t|| hba->ufshcd_state != UFSHCD_STATE_OPERATIONAL\n\t\t|| ufshcd_any_tag_in_use(hba) || hba->outstanding_tasks\n\t\t|| hba->active_uic_cmd || hba->uic_async_done)\n\t\tgoto rel_lock;\n\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\t/* put the link into hibern8 mode before turning off clocks */\n\tif (ufshcd_can_hibern8_during_gating(hba)) {\n\t\tret = ufshcd_uic_hibern8_enter(hba);\n\t\tif (ret) {\n\t\t\thba->clk_gating.state = CLKS_ON;\n\t\t\tdev_err(hba->dev, \"%s: hibern8 enter failed %d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\ttrace_ufshcd_clk_gating(dev_name(hba->dev),\n\t\t\t\t\t\thba->clk_gating.state);\n\t\t\tgoto out;\n\t\t}\n\t\tufshcd_set_link_hibern8(hba);\n\t}\n\n\tufshcd_disable_irq(hba);\n\n\tufshcd_setup_clocks(hba, false);\n\n\t/* Put the host controller in low power mode if possible */\n\tufshcd_hba_vreg_set_lpm(hba);\n\t/*\n\t * In case you are here to cancel this work the gating state\n\t * would be marked as REQ_CLKS_ON. In this case keep the state\n\t * as REQ_CLKS_ON which would anyway imply that clocks are off\n\t * and a request to turn them on is pending. By doing this way,\n\t * we keep the state machine in tact and this would ultimately\n\t * prevent from doing cancel work multiple times when there are\n\t * new requests arriving before the current cancel work is done.\n\t */\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tif (hba->clk_gating.state == REQ_CLKS_OFF) {\n\t\thba->clk_gating.state = CLKS_OFF;\n\t\ttrace_ufshcd_clk_gating(dev_name(hba->dev),\n\t\t\t\t\thba->clk_gating.state);\n\t}\nrel_lock:\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\nout:\n\treturn;\n}\n\n/* host lock must be held before calling this variant */\nstatic void __ufshcd_release(struct ufs_hba *hba)\n{\n\tif (!ufshcd_is_clkgating_allowed(hba))\n\t\treturn;\n\n\thba->clk_gating.active_reqs--;\n\n\tif (hba->clk_gating.active_reqs || hba->clk_gating.is_suspended ||\n\t    hba->ufshcd_state != UFSHCD_STATE_OPERATIONAL ||\n\t    hba->outstanding_tasks ||\n\t    hba->active_uic_cmd || hba->uic_async_done ||\n\t    hba->clk_gating.state == CLKS_OFF)\n\t\treturn;\n\n\thba->clk_gating.state = REQ_CLKS_OFF;\n\ttrace_ufshcd_clk_gating(dev_name(hba->dev), hba->clk_gating.state);\n\tqueue_delayed_work(hba->clk_gating.clk_gating_workq,\n\t\t\t   &hba->clk_gating.gate_work,\n\t\t\t   msecs_to_jiffies(hba->clk_gating.delay_ms));\n}\n\nvoid ufshcd_release(struct ufs_hba *hba)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t__ufshcd_release(hba);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n}\nEXPORT_SYMBOL_GPL(ufshcd_release);\n\nstatic ssize_t ufshcd_clkgate_delay_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%lu\\n\", hba->clk_gating.delay_ms);\n}\n\nstatic ssize_t ufshcd_clkgate_delay_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\tunsigned long flags, value;\n\n\tif (kstrtoul(buf, 0, &value))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\thba->clk_gating.delay_ms = value;\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\treturn count;\n}\n\nstatic ssize_t ufshcd_clkgate_enable_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", hba->clk_gating.is_enabled);\n}\n\nstatic ssize_t ufshcd_clkgate_enable_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct ufs_hba *hba = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tu32 value;\n\n\tif (kstrtou32(buf, 0, &value))\n\t\treturn -EINVAL;\n\n\tvalue = !!value;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tif (value == hba->clk_gating.is_enabled)\n\t\tgoto out;\n\n\tif (value)\n\t\t__ufshcd_release(hba);\n\telse\n\t\thba->clk_gating.active_reqs++;\n\n\thba->clk_gating.is_enabled = value;\nout:\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\treturn count;\n}\n\nstatic void ufshcd_init_clk_scaling(struct ufs_hba *hba)\n{\n\tchar wq_name[sizeof(\"ufs_clkscaling_00\")];\n\n\tif (!ufshcd_is_clkscaling_supported(hba))\n\t\treturn;\n\n\tif (!hba->clk_scaling.min_gear)\n\t\thba->clk_scaling.min_gear = UFS_HS_G1;\n\n\tINIT_WORK(&hba->clk_scaling.suspend_work,\n\t\t  ufshcd_clk_scaling_suspend_work);\n\tINIT_WORK(&hba->clk_scaling.resume_work,\n\t\t  ufshcd_clk_scaling_resume_work);\n\n\tsnprintf(wq_name, sizeof(wq_name), \"ufs_clkscaling_%d\",\n\t\t hba->host->host_no);\n\thba->clk_scaling.workq = create_singlethread_workqueue(wq_name);\n\n\tufshcd_clkscaling_init_sysfs(hba);\n}\n\nstatic void ufshcd_exit_clk_scaling(struct ufs_hba *hba)\n{\n\tif (!ufshcd_is_clkscaling_supported(hba))\n\t\treturn;\n\n\tdestroy_workqueue(hba->clk_scaling.workq);\n\tufshcd_devfreq_remove(hba);\n}\n\nstatic void ufshcd_init_clk_gating(struct ufs_hba *hba)\n{\n\tchar wq_name[sizeof(\"ufs_clk_gating_00\")];\n\n\tif (!ufshcd_is_clkgating_allowed(hba))\n\t\treturn;\n\n\thba->clk_gating.state = CLKS_ON;\n\n\thba->clk_gating.delay_ms = 150;\n\tINIT_DELAYED_WORK(&hba->clk_gating.gate_work, ufshcd_gate_work);\n\tINIT_WORK(&hba->clk_gating.ungate_work, ufshcd_ungate_work);\n\n\tsnprintf(wq_name, ARRAY_SIZE(wq_name), \"ufs_clk_gating_%d\",\n\t\t hba->host->host_no);\n\thba->clk_gating.clk_gating_workq = alloc_ordered_workqueue(wq_name,\n\t\t\t\t\tWQ_MEM_RECLAIM | WQ_HIGHPRI);\n\n\thba->clk_gating.is_enabled = true;\n\n\thba->clk_gating.delay_attr.show = ufshcd_clkgate_delay_show;\n\thba->clk_gating.delay_attr.store = ufshcd_clkgate_delay_store;\n\tsysfs_attr_init(&hba->clk_gating.delay_attr.attr);\n\thba->clk_gating.delay_attr.attr.name = \"clkgate_delay_ms\";\n\thba->clk_gating.delay_attr.attr.mode = 0644;\n\tif (device_create_file(hba->dev, &hba->clk_gating.delay_attr))\n\t\tdev_err(hba->dev, \"Failed to create sysfs for clkgate_delay\\n\");\n\n\thba->clk_gating.enable_attr.show = ufshcd_clkgate_enable_show;\n\thba->clk_gating.enable_attr.store = ufshcd_clkgate_enable_store;\n\tsysfs_attr_init(&hba->clk_gating.enable_attr.attr);\n\thba->clk_gating.enable_attr.attr.name = \"clkgate_enable\";\n\thba->clk_gating.enable_attr.attr.mode = 0644;\n\tif (device_create_file(hba->dev, &hba->clk_gating.enable_attr))\n\t\tdev_err(hba->dev, \"Failed to create sysfs for clkgate_enable\\n\");\n}\n\nstatic void ufshcd_exit_clk_gating(struct ufs_hba *hba)\n{\n\tif (!ufshcd_is_clkgating_allowed(hba))\n\t\treturn;\n\tdevice_remove_file(hba->dev, &hba->clk_gating.delay_attr);\n\tdevice_remove_file(hba->dev, &hba->clk_gating.enable_attr);\n\tcancel_work_sync(&hba->clk_gating.ungate_work);\n\tcancel_delayed_work_sync(&hba->clk_gating.gate_work);\n\tdestroy_workqueue(hba->clk_gating.clk_gating_workq);\n}\n\n/* Must be called with host lock acquired */\nstatic void ufshcd_clk_scaling_start_busy(struct ufs_hba *hba)\n{\n\tbool queue_resume_work = false;\n\tktime_t curr_t = ktime_get();\n\n\tif (!ufshcd_is_clkscaling_supported(hba))\n\t\treturn;\n\n\tif (!hba->clk_scaling.active_reqs++)\n\t\tqueue_resume_work = true;\n\n\tif (!hba->clk_scaling.is_allowed || hba->pm_op_in_progress)\n\t\treturn;\n\n\tif (queue_resume_work)\n\t\tqueue_work(hba->clk_scaling.workq,\n\t\t\t   &hba->clk_scaling.resume_work);\n\n\tif (!hba->clk_scaling.window_start_t) {\n\t\thba->clk_scaling.window_start_t = curr_t;\n\t\thba->clk_scaling.tot_busy_t = 0;\n\t\thba->clk_scaling.is_busy_started = false;\n\t}\n\n\tif (!hba->clk_scaling.is_busy_started) {\n\t\thba->clk_scaling.busy_start_t = curr_t;\n\t\thba->clk_scaling.is_busy_started = true;\n\t}\n}\n\nstatic void ufshcd_clk_scaling_update_busy(struct ufs_hba *hba)\n{\n\tstruct ufs_clk_scaling *scaling = &hba->clk_scaling;\n\n\tif (!ufshcd_is_clkscaling_supported(hba))\n\t\treturn;\n\n\tif (!hba->outstanding_reqs && scaling->is_busy_started) {\n\t\tscaling->tot_busy_t += ktime_to_us(ktime_sub(ktime_get(),\n\t\t\t\t\tscaling->busy_start_t));\n\t\tscaling->busy_start_t = 0;\n\t\tscaling->is_busy_started = false;\n\t}\n}\n/**\n * ufshcd_send_command - Send SCSI or device management commands\n * @hba: per adapter instance\n * @task_tag: Task tag of the command\n */\nstatic inline\nvoid ufshcd_send_command(struct ufs_hba *hba, unsigned int task_tag)\n{\n\tstruct ufshcd_lrb *lrbp = &hba->lrb[task_tag];\n\n\tlrbp->issue_time_stamp = ktime_get();\n\tlrbp->compl_time_stamp = ktime_set(0, 0);\n\tufshcd_vops_setup_xfer_req(hba, task_tag, (lrbp->cmd ? true : false));\n\tufshcd_add_command_trace(hba, task_tag, \"send\");\n\tufshcd_clk_scaling_start_busy(hba);\n\t__set_bit(task_tag, &hba->outstanding_reqs);\n\tufshcd_writel(hba, 1 << task_tag, REG_UTP_TRANSFER_REQ_DOOR_BELL);\n\t/* Make sure that doorbell is committed immediately */\n\twmb();\n}\n\n/**\n * ufshcd_copy_sense_data - Copy sense data in case of check condition\n * @lrbp: pointer to local reference block\n */\nstatic inline void ufshcd_copy_sense_data(struct ufshcd_lrb *lrbp)\n{\n\tint len;\n\tif (lrbp->sense_buffer &&\n\t    ufshcd_get_rsp_upiu_data_seg_len(lrbp->ucd_rsp_ptr)) {\n\t\tint len_to_copy;\n\n\t\tlen = be16_to_cpu(lrbp->ucd_rsp_ptr->sr.sense_data_len);\n\t\tlen_to_copy = min_t(int, UFS_SENSE_SIZE, len);\n\n\t\tmemcpy(lrbp->sense_buffer, lrbp->ucd_rsp_ptr->sr.sense_data,\n\t\t       len_to_copy);\n\t}\n}\n\n/**\n * ufshcd_copy_query_response() - Copy the Query Response and the data\n * descriptor\n * @hba: per adapter instance\n * @lrbp: pointer to local reference block\n */\nstatic\nint ufshcd_copy_query_response(struct ufs_hba *hba, struct ufshcd_lrb *lrbp)\n{\n\tstruct ufs_query_res *query_res = &hba->dev_cmd.query.response;\n\n\tmemcpy(&query_res->upiu_res, &lrbp->ucd_rsp_ptr->qr, QUERY_OSF_SIZE);\n\n\t/* Get the descriptor */\n\tif (hba->dev_cmd.query.descriptor &&\n\t    lrbp->ucd_rsp_ptr->qr.opcode == UPIU_QUERY_OPCODE_READ_DESC) {\n\t\tu8 *descp = (u8 *)lrbp->ucd_rsp_ptr +\n\t\t\t\tGENERAL_UPIU_REQUEST_SIZE;\n\t\tu16 resp_len;\n\t\tu16 buf_len;\n\n\t\t/* data segment length */\n\t\tresp_len = be32_to_cpu(lrbp->ucd_rsp_ptr->header.dword_2) &\n\t\t\t\t\t\tMASK_QUERY_DATA_SEG_LEN;\n\t\tbuf_len = be16_to_cpu(\n\t\t\t\thba->dev_cmd.query.request.upiu_req.length);\n\t\tif (likely(buf_len >= resp_len)) {\n\t\t\tmemcpy(hba->dev_cmd.query.descriptor, descp, resp_len);\n\t\t} else {\n\t\t\tdev_warn(hba->dev,\n\t\t\t\t \"%s: rsp size %d is bigger than buffer size %d\",\n\t\t\t\t __func__, resp_len, buf_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * ufshcd_hba_capabilities - Read controller capabilities\n * @hba: per adapter instance\n *\n * Return: 0 on success, negative on error.\n */\nstatic inline int ufshcd_hba_capabilities(struct ufs_hba *hba)\n{\n\tint err;\n\n\thba->capabilities = ufshcd_readl(hba, REG_CONTROLLER_CAPABILITIES);\n\n\t/* nutrs and nutmrs are 0 based values */\n\thba->nutrs = (hba->capabilities & MASK_TRANSFER_REQUESTS_SLOTS) + 1;\n\thba->nutmrs =\n\t((hba->capabilities & MASK_TASK_MANAGEMENT_REQUEST_SLOTS) >> 16) + 1;\n\n\t/* Read crypto capabilities */\n\terr = ufshcd_hba_init_crypto_capabilities(hba);\n\tif (err)\n\t\tdev_err(hba->dev, \"crypto setup failed\\n\");\n\n\treturn err;\n}\n\n/**\n * ufshcd_ready_for_uic_cmd - Check if controller is ready\n *                            to accept UIC commands\n * @hba: per adapter instance\n * Return true on success, else false\n */\nstatic inline bool ufshcd_ready_for_uic_cmd(struct ufs_hba *hba)\n{\n\tif (ufshcd_readl(hba, REG_CONTROLLER_STATUS) & UIC_COMMAND_READY)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n/**\n * ufshcd_get_upmcrs - Get the power mode change request status\n * @hba: Pointer to adapter instance\n *\n * This function gets the UPMCRS field of HCS register\n * Returns value of UPMCRS field\n */\nstatic inline u8 ufshcd_get_upmcrs(struct ufs_hba *hba)\n{\n\treturn (ufshcd_readl(hba, REG_CONTROLLER_STATUS) >> 8) & 0x7;\n}\n\n/**\n * ufshcd_dispatch_uic_cmd - Dispatch UIC commands to unipro layers\n * @hba: per adapter instance\n * @uic_cmd: UIC command\n *\n * Mutex must be held.\n */\nstatic inline void\nufshcd_dispatch_uic_cmd(struct ufs_hba *hba, struct uic_command *uic_cmd)\n{\n\tWARN_ON(hba->active_uic_cmd);\n\n\thba->active_uic_cmd = uic_cmd;\n\n\t/* Write Args */\n\tufshcd_writel(hba, uic_cmd->argument1, REG_UIC_COMMAND_ARG_1);\n\tufshcd_writel(hba, uic_cmd->argument2, REG_UIC_COMMAND_ARG_2);\n\tufshcd_writel(hba, uic_cmd->argument3, REG_UIC_COMMAND_ARG_3);\n\n\tufshcd_add_uic_command_trace(hba, uic_cmd, \"send\");\n\n\t/* Write UIC Cmd */\n\tufshcd_writel(hba, uic_cmd->command & COMMAND_OPCODE_MASK,\n\t\t      REG_UIC_COMMAND);\n}\n\n/**\n * ufshcd_wait_for_uic_cmd - Wait complectioin of UIC command\n * @hba: per adapter instance\n * @uic_cmd: UIC command\n *\n * Must be called with mutex held.\n * Returns 0 only if success.\n */\nstatic int\nufshcd_wait_for_uic_cmd(struct ufs_hba *hba, struct uic_command *uic_cmd)\n{\n\tint ret;\n\tunsigned long flags;\n\n\tif (wait_for_completion_timeout(&uic_cmd->done,\n\t\t\t\t\tmsecs_to_jiffies(UIC_CMD_TIMEOUT))) {\n\t\tret = uic_cmd->argument2 & MASK_UIC_COMMAND_RESULT;\n\t} else {\n\t\tret = -ETIMEDOUT;\n\t\tdev_err(hba->dev,\n\t\t\t\"uic cmd 0x%x with arg3 0x%x completion timeout\\n\",\n\t\t\tuic_cmd->command, uic_cmd->argument3);\n\n\t\tif (!uic_cmd->cmd_active) {\n\t\t\tdev_err(hba->dev, \"%s: UIC cmd has been completed, return the result\\n\",\n\t\t\t\t__func__);\n\t\t\tret = uic_cmd->argument2 & MASK_UIC_COMMAND_RESULT;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\thba->active_uic_cmd = NULL;\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\treturn ret;\n}\n\n/**\n * __ufshcd_send_uic_cmd - Send UIC commands and retrieve the result\n * @hba: per adapter instance\n * @uic_cmd: UIC command\n * @completion: initialize the completion only if this is set to true\n *\n * Identical to ufshcd_send_uic_cmd() expect mutex. Must be called\n * with mutex held and host_lock locked.\n * Returns 0 only if success.\n */\nstatic int\n__ufshcd_send_uic_cmd(struct ufs_hba *hba, struct uic_command *uic_cmd,\n\t\t      bool completion)\n{\n\tif (!ufshcd_ready_for_uic_cmd(hba)) {\n\t\tdev_err(hba->dev,\n\t\t\t\"Controller not ready to accept UIC commands\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (completion)\n\t\tinit_completion(&uic_cmd->done);\n\n\tuic_cmd->cmd_active = 1;\n\tufshcd_dispatch_uic_cmd(hba, uic_cmd);\n\n\treturn 0;\n}\n\n/**\n * ufshcd_send_uic_cmd - Send UIC commands and retrieve the result\n * @hba: per adapter instance\n * @uic_cmd: UIC command\n *\n * Returns 0 only if success.\n */\nint ufshcd_send_uic_cmd(struct ufs_hba *hba, struct uic_command *uic_cmd)\n{\n\tint ret;\n\tunsigned long flags;\n\n\tufshcd_hold(hba, false);\n\tmutex_lock(&hba->uic_cmd_mutex);\n\tufshcd_add_delay_before_dme_cmd(hba);\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tret = __ufshcd_send_uic_cmd(hba, uic_cmd, true);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\tif (!ret)\n\t\tret = ufshcd_wait_for_uic_cmd(hba, uic_cmd);\n\n\tmutex_unlock(&hba->uic_cmd_mutex);\n\n\tufshcd_release(hba);\n\treturn ret;\n}\n\n/**\n * ufshcd_map_sg - Map scatter-gather list to prdt\n * @hba: per adapter instance\n * @lrbp: pointer to local reference block\n *\n * Returns 0 in case of success, non-zero value in case of failure\n */\nstatic int ufshcd_map_sg(struct ufs_hba *hba, struct ufshcd_lrb *lrbp)\n{\n\tstruct ufshcd_sg_entry *prd_table;\n\tstruct scatterlist *sg;\n\tstruct scsi_cmnd *cmd;\n\tint sg_segments;\n\tint i;\n\n\tcmd = lrbp->cmd;\n\tsg_segments = scsi_dma_map(cmd);\n\tif (sg_segments < 0)\n\t\treturn sg_segments;\n\n\tif (sg_segments) {\n\n\t\tif (hba->quirks & UFSHCD_QUIRK_PRDT_BYTE_GRAN)\n\t\t\tlrbp->utr_descriptor_ptr->prd_table_length =\n\t\t\t\tcpu_to_le16((sg_segments *\n\t\t\t\t\tsizeof(struct ufshcd_sg_entry)));\n\t\telse\n\t\t\tlrbp->utr_descriptor_ptr->prd_table_length =\n\t\t\t\tcpu_to_le16((u16) (sg_segments));\n\n\t\tprd_table = (struct ufshcd_sg_entry *)lrbp->ucd_prdt_ptr;\n\n\t\tscsi_for_each_sg(cmd, sg, sg_segments, i) {\n\t\t\tprd_table[i].size  =\n\t\t\t\tcpu_to_le32(((u32) sg_dma_len(sg))-1);\n\t\t\tprd_table[i].base_addr =\n\t\t\t\tcpu_to_le32(lower_32_bits(sg->dma_address));\n\t\t\tprd_table[i].upper_addr =\n\t\t\t\tcpu_to_le32(upper_32_bits(sg->dma_address));\n\t\t\tprd_table[i].reserved = 0;\n\t\t}\n\t} else {\n\t\tlrbp->utr_descriptor_ptr->prd_table_length = 0;\n\t}\n\n\treturn 0;\n}\n\n/**\n * ufshcd_enable_intr - enable interrupts\n * @hba: per adapter instance\n * @intrs: interrupt bits\n */\nstatic void ufshcd_enable_intr(struct ufs_hba *hba, u32 intrs)\n{\n\tu32 set = ufshcd_readl(hba, REG_INTERRUPT_ENABLE);\n\n\tif (hba->ufs_version == UFSHCI_VERSION_10) {\n\t\tu32 rw;\n\t\trw = set & INTERRUPT_MASK_RW_VER_10;\n\t\tset = rw | ((set ^ intrs) & intrs);\n\t} else {\n\t\tset |= intrs;\n\t}\n\n\tufshcd_writel(hba, set, REG_INTERRUPT_ENABLE);\n}\n\n/**\n * ufshcd_disable_intr - disable interrupts\n * @hba: per adapter instance\n * @intrs: interrupt bits\n */\nstatic void ufshcd_disable_intr(struct ufs_hba *hba, u32 intrs)\n{\n\tu32 set = ufshcd_readl(hba, REG_INTERRUPT_ENABLE);\n\n\tif (hba->ufs_version == UFSHCI_VERSION_10) {\n\t\tu32 rw;\n\t\trw = (set & INTERRUPT_MASK_RW_VER_10) &\n\t\t\t~(intrs & INTERRUPT_MASK_RW_VER_10);\n\t\tset = rw | ((set & intrs) & ~INTERRUPT_MASK_RW_VER_10);\n\n\t} else {\n\t\tset &= ~intrs;\n\t}\n\n\tufshcd_writel(hba, set, REG_INTERRUPT_ENABLE);\n}\n\n/**\n * ufshcd_prepare_req_desc_hdr() - Fills the requests header\n * descriptor according to request\n * @lrbp: pointer to local reference block\n * @upiu_flags: flags required in the header\n * @cmd_dir: requests data direction\n */\nstatic void ufshcd_prepare_req_desc_hdr(struct ufshcd_lrb *lrbp,\n\t\t\tu8 *upiu_flags, enum dma_data_direction cmd_dir)\n{\n\tstruct utp_transfer_req_desc *req_desc = lrbp->utr_descriptor_ptr;\n\tu32 data_direction;\n\tu32 dword_0;\n\tu32 dword_1 = 0;\n\tu32 dword_3 = 0;\n\n\tif (cmd_dir == DMA_FROM_DEVICE) {\n\t\tdata_direction = UTP_DEVICE_TO_HOST;\n\t\t*upiu_flags = UPIU_CMD_FLAGS_READ;\n\t} else if (cmd_dir == DMA_TO_DEVICE) {\n\t\tdata_direction = UTP_HOST_TO_DEVICE;\n\t\t*upiu_flags = UPIU_CMD_FLAGS_WRITE;\n\t} else {\n\t\tdata_direction = UTP_NO_DATA_TRANSFER;\n\t\t*upiu_flags = UPIU_CMD_FLAGS_NONE;\n\t}\n\n\tdword_0 = data_direction | (lrbp->command_type\n\t\t\t\t<< UPIU_COMMAND_TYPE_OFFSET);\n\tif (lrbp->intr_cmd)\n\t\tdword_0 |= UTP_REQ_DESC_INT_CMD;\n\n\t/* Prepare crypto related dwords */\n\tufshcd_prepare_req_desc_hdr_crypto(lrbp, &dword_0, &dword_1, &dword_3);\n\n\t/* Transfer request descriptor header fields */\n\treq_desc->header.dword_0 = cpu_to_le32(dword_0);\n\treq_desc->header.dword_1 = cpu_to_le32(dword_1);\n\t/*\n\t * assigning invalid value for command status. Controller\n\t * updates OCS on command completion, with the command\n\t * status\n\t */\n\treq_desc->header.dword_2 =\n\t\tcpu_to_le32(OCS_INVALID_COMMAND_STATUS);\n\treq_desc->header.dword_3 = cpu_to_le32(dword_3);\n\n\treq_desc->prd_table_length = 0;\n}\n\n/**\n * ufshcd_prepare_utp_scsi_cmd_upiu() - fills the utp_transfer_req_desc,\n * for scsi commands\n * @lrbp: local reference block pointer\n * @upiu_flags: flags\n */\nstatic\nvoid ufshcd_prepare_utp_scsi_cmd_upiu(struct ufshcd_lrb *lrbp, u8 upiu_flags)\n{\n\tstruct scsi_cmnd *cmd = lrbp->cmd;\n\tstruct utp_upiu_req *ucd_req_ptr = lrbp->ucd_req_ptr;\n\tunsigned short cdb_len;\n\n\t/* command descriptor fields */\n\tucd_req_ptr->header.dword_0 = UPIU_HEADER_DWORD(\n\t\t\t\tUPIU_TRANSACTION_COMMAND, upiu_flags,\n\t\t\t\tlrbp->lun, lrbp->task_tag);\n\tucd_req_ptr->header.dword_1 = UPIU_HEADER_DWORD(\n\t\t\t\tUPIU_COMMAND_SET_TYPE_SCSI, 0, 0, 0);\n\n\t/* Total EHS length and Data segment length will be zero */\n\tucd_req_ptr->header.dword_2 = 0;\n\n\tucd_req_ptr->sc.exp_data_transfer_len = cpu_to_be32(cmd->sdb.length);\n\n\tcdb_len = min_t(unsigned short, cmd->cmd_len, UFS_CDB_SIZE);\n\tmemset(ucd_req_ptr->sc.cdb, 0, UFS_CDB_SIZE);\n\tmemcpy(ucd_req_ptr->sc.cdb, cmd->cmnd, cdb_len);\n\n\tmemset(lrbp->ucd_rsp_ptr, 0, sizeof(struct utp_upiu_rsp));\n}\n\n/**\n * ufshcd_prepare_utp_query_req_upiu() - fills the utp_transfer_req_desc,\n * for query requsts\n * @hba: UFS hba\n * @lrbp: local reference block pointer\n * @upiu_flags: flags\n */\nstatic void ufshcd_prepare_utp_query_req_upiu(struct ufs_hba *hba,\n\t\t\t\tstruct ufshcd_lrb *lrbp, u8 upiu_flags)\n{\n\tstruct utp_upiu_req *ucd_req_ptr = lrbp->ucd_req_ptr;\n\tstruct ufs_query *query = &hba->dev_cmd.query;\n\tu16 len = be16_to_cpu(query->request.upiu_req.length);\n\n\t/* Query request header */\n\tucd_req_ptr->header.dword_0 = UPIU_HEADER_DWORD(\n\t\t\tUPIU_TRANSACTION_QUERY_REQ, upiu_flags,\n\t\t\tlrbp->lun, lrbp->task_tag);\n\tucd_req_ptr->header.dword_1 = UPIU_HEADER_DWORD(\n\t\t\t0, query->request.query_func, 0, 0);\n\n\t/* Data segment length only need for WRITE_DESC */\n\tif (query->request.upiu_req.opcode == UPIU_QUERY_OPCODE_WRITE_DESC)\n\t\tucd_req_ptr->header.dword_2 =\n\t\t\tUPIU_HEADER_DWORD(0, 0, (len >> 8), (u8)len);\n\telse\n\t\tucd_req_ptr->header.dword_2 = 0;\n\n\t/* Copy the Query Request buffer as is */\n\tmemcpy(&ucd_req_ptr->qr, &query->request.upiu_req,\n\t\t\tQUERY_OSF_SIZE);\n\n\t/* Copy the Descriptor */\n\tif (query->request.upiu_req.opcode == UPIU_QUERY_OPCODE_WRITE_DESC)\n\t\tmemcpy(ucd_req_ptr + 1, query->descriptor, len);\n\n\tmemset(lrbp->ucd_rsp_ptr, 0, sizeof(struct utp_upiu_rsp));\n}\n\nstatic inline void ufshcd_prepare_utp_nop_upiu(struct ufshcd_lrb *lrbp)\n{\n\tstruct utp_upiu_req *ucd_req_ptr = lrbp->ucd_req_ptr;\n\n\tmemset(ucd_req_ptr, 0, sizeof(struct utp_upiu_req));\n\n\t/* command descriptor fields */\n\tucd_req_ptr->header.dword_0 =\n\t\tUPIU_HEADER_DWORD(\n\t\t\tUPIU_TRANSACTION_NOP_OUT, 0, 0, lrbp->task_tag);\n\t/* clear rest of the fields of basic header */\n\tucd_req_ptr->header.dword_1 = 0;\n\tucd_req_ptr->header.dword_2 = 0;\n\n\tmemset(lrbp->ucd_rsp_ptr, 0, sizeof(struct utp_upiu_rsp));\n}\n\n/**\n * ufshcd_compose_devman_upiu - UFS Protocol Information Unit(UPIU)\n *\t\t\t     for Device Management Purposes\n * @hba: per adapter instance\n * @lrbp: pointer to local reference block\n */\nstatic int ufshcd_compose_devman_upiu(struct ufs_hba *hba,\n\t\t\t\t      struct ufshcd_lrb *lrbp)\n{\n\tu8 upiu_flags;\n\tint ret = 0;\n\n\tif ((hba->ufs_version == UFSHCI_VERSION_10) ||\n\t    (hba->ufs_version == UFSHCI_VERSION_11))\n\t\tlrbp->command_type = UTP_CMD_TYPE_DEV_MANAGE;\n\telse\n\t\tlrbp->command_type = UTP_CMD_TYPE_UFS_STORAGE;\n\n\tufshcd_prepare_req_desc_hdr(lrbp, &upiu_flags, DMA_NONE);\n\tif (hba->dev_cmd.type == DEV_CMD_TYPE_QUERY)\n\t\tufshcd_prepare_utp_query_req_upiu(hba, lrbp, upiu_flags);\n\telse if (hba->dev_cmd.type == DEV_CMD_TYPE_NOP)\n\t\tufshcd_prepare_utp_nop_upiu(lrbp);\n\telse\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\n/**\n * ufshcd_comp_scsi_upiu - UFS Protocol Information Unit(UPIU)\n *\t\t\t   for SCSI Purposes\n * @hba: per adapter instance\n * @lrbp: pointer to local reference block\n */\nstatic int ufshcd_comp_scsi_upiu(struct ufs_hba *hba, struct ufshcd_lrb *lrbp)\n{\n\tu8 upiu_flags;\n\tint ret = 0;\n\n\tif ((hba->ufs_version == UFSHCI_VERSION_10) ||\n\t    (hba->ufs_version == UFSHCI_VERSION_11))\n\t\tlrbp->command_type = UTP_CMD_TYPE_SCSI;\n\telse\n\t\tlrbp->command_type = UTP_CMD_TYPE_UFS_STORAGE;\n\n\tif (likely(lrbp->cmd)) {\n\t\tufshcd_prepare_req_desc_hdr(lrbp, &upiu_flags,\n\t\t\t\t\t\tlrbp->cmd->sc_data_direction);\n\t\tufshcd_prepare_utp_scsi_cmd_upiu(lrbp, upiu_flags);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n/**\n * ufshcd_upiu_wlun_to_scsi_wlun - maps UPIU W-LUN id to SCSI W-LUN ID\n * @upiu_wlun_id: UPIU W-LUN id\n *\n * Returns SCSI W-LUN id\n */\nstatic inline u16 ufshcd_upiu_wlun_to_scsi_wlun(u8 upiu_wlun_id)\n{\n\treturn (upiu_wlun_id & ~UFS_UPIU_WLUN_ID) | SCSI_W_LUN_BASE;\n}\n\nstatic void ufshcd_init_lrb(struct ufs_hba *hba, struct ufshcd_lrb *lrb, int i)\n{\n\tstruct utp_transfer_cmd_desc *cmd_descp = hba->ucdl_base_addr;\n\tstruct utp_transfer_req_desc *utrdlp = hba->utrdl_base_addr;\n\tdma_addr_t cmd_desc_element_addr = hba->ucdl_dma_addr +\n\t\ti * sizeof(struct utp_transfer_cmd_desc);\n\tu16 response_offset = offsetof(struct utp_transfer_cmd_desc,\n\t\t\t\t       response_upiu);\n\tu16 prdt_offset = offsetof(struct utp_transfer_cmd_desc, prd_table);\n\n\tlrb->utr_descriptor_ptr = utrdlp + i;\n\tlrb->utrd_dma_addr = hba->utrdl_dma_addr +\n\t\ti * sizeof(struct utp_transfer_req_desc);\n\tlrb->ucd_req_ptr = (struct utp_upiu_req *)(cmd_descp + i);\n\tlrb->ucd_req_dma_addr = cmd_desc_element_addr;\n\tlrb->ucd_rsp_ptr = (struct utp_upiu_rsp *)cmd_descp[i].response_upiu;\n\tlrb->ucd_rsp_dma_addr = cmd_desc_element_addr + response_offset;\n\tlrb->ucd_prdt_ptr = (struct ufshcd_sg_entry *)cmd_descp[i].prd_table;\n\tlrb->ucd_prdt_dma_addr = cmd_desc_element_addr + prdt_offset;\n}\n\n/**\n * ufshcd_queuecommand - main entry point for SCSI requests\n * @host: SCSI host pointer\n * @cmd: command from SCSI Midlayer\n *\n * Returns 0 for success, non-zero in case of failure\n */\nstatic int ufshcd_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd)\n{\n\tstruct ufshcd_lrb *lrbp;\n\tstruct ufs_hba *hba;\n\tunsigned long flags;\n\tint tag;\n\tint err = 0;\n\n\thba = shost_priv(host);\n\n\ttag = cmd->request->tag;\n\tif (!ufshcd_valid_tag(hba, tag)) {\n\t\tdev_err(hba->dev,\n\t\t\t\"%s: invalid command tag %d: cmd=0x%p, cmd->request=0x%p\",\n\t\t\t__func__, tag, cmd, cmd->request);\n\t\tBUG();\n\t}\n\n\tif (!down_read_trylock(&hba->clk_scaling_lock))\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\thba->req_abort_count = 0;\n\n\terr = ufshcd_hold(hba, true);\n\tif (err) {\n\t\terr = SCSI_MLQUEUE_HOST_BUSY;\n\t\tgoto out;\n\t}\n\tWARN_ON(ufshcd_is_clkgating_allowed(hba) &&\n\t\t(hba->clk_gating.state != CLKS_ON));\n\n\tlrbp = &hba->lrb[tag];\n\n\tWARN_ON(lrbp->cmd);\n\tlrbp->cmd = cmd;\n\tlrbp->sense_bufflen = UFS_SENSE_SIZE;\n\tlrbp->sense_buffer = cmd->sense_buffer;\n\tlrbp->task_tag = tag;\n\tlrbp->lun = ufshcd_scsi_to_upiu_lun(cmd->device->lun);\n\tlrbp->intr_cmd = !ufshcd_is_intr_aggr_allowed(hba) ? true : false;\n\n\tufshcd_prepare_lrbp_crypto(cmd->request, lrbp);\n\n\tlrbp->req_abort_skip = false;\n\n\tufshcd_comp_scsi_upiu(hba, lrbp);\n\n\terr = ufshcd_map_sg(hba, lrbp);\n\tif (err) {\n\t\tlrbp->cmd = NULL;\n\t\tufshcd_release(hba);\n\t\tgoto out;\n\t}\n\t/* Make sure descriptors are ready before ringing the doorbell */\n\twmb();\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tswitch (hba->ufshcd_state) {\n\tcase UFSHCD_STATE_OPERATIONAL:\n\tcase UFSHCD_STATE_EH_SCHEDULED_NON_FATAL:\n\t\tbreak;\n\tcase UFSHCD_STATE_EH_SCHEDULED_FATAL:\n\t\t/*\n\t\t * pm_runtime_get_sync() is used at error handling preparation\n\t\t * stage. If a scsi cmd, e.g. the SSU cmd, is sent from hba's\n\t\t * PM ops, it can never be finished if we let SCSI layer keep\n\t\t * retrying it, which gets err handler stuck forever. Neither\n\t\t * can we let the scsi cmd pass through, because UFS is in bad\n\t\t * state, the scsi cmd may eventually time out, which will get\n\t\t * err handler blocked for too long. So, just fail the scsi cmd\n\t\t * sent from PM ops, err handler can recover PM error anyways.\n\t\t */\n\t\tif (hba->pm_op_in_progress) {\n\t\t\thba->force_reset = true;\n\t\t\tset_host_byte(cmd, DID_BAD_TARGET);\n\t\t\tgoto out_compl_cmd;\n\t\t}\n\t\tfallthrough;\n\tcase UFSHCD_STATE_RESET:\n\t\terr = SCSI_MLQUEUE_HOST_BUSY;\n\t\tgoto out_compl_cmd;\n\tcase UFSHCD_STATE_ERROR:\n\t\tset_host_byte(cmd, DID_ERROR);\n\t\tgoto out_compl_cmd;\n\tdefault:\n\t\tdev_WARN_ONCE(hba->dev, 1, \"%s: invalid state %d\\n\",\n\t\t\t\t__func__, hba->ufshcd_state);\n\t\tset_host_byte(cmd, DID_BAD_TARGET);\n\t\tgoto out_compl_cmd;\n\t}\n\tufshcd_send_command(hba, tag);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\tgoto out;\n\nout_compl_cmd:\n\tscsi_dma_unmap(lrbp->cmd);\n\tlrbp->cmd = NULL;\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\tufshcd_release(hba);\n\tif (!err)\n\t\tcmd->scsi_done(cmd);\nout:\n\tup_read(&hba->clk_scaling_lock);\n\treturn err;\n}\n\nstatic int ufshcd_compose_dev_cmd(struct ufs_hba *hba,\n\t\tstruct ufshcd_lrb *lrbp, enum dev_cmd_type cmd_type, int tag)\n{\n\tlrbp->cmd = NULL;\n\tlrbp->sense_bufflen = 0;\n\tlrbp->sense_buffer = NULL;\n\tlrbp->task_tag = tag;\n\tlrbp->lun = 0; /* device management cmd is not specific to any LUN */\n\tlrbp->intr_cmd = true; /* No interrupt aggregation */\n\tufshcd_prepare_lrbp_crypto(NULL, lrbp);\n\thba->dev_cmd.type = cmd_type;\n\n\treturn ufshcd_compose_devman_upiu(hba, lrbp);\n}\n\nstatic int\nufshcd_clear_cmd(struct ufs_hba *hba, int tag)\n{\n\tint err = 0;\n\tunsigned long flags;\n\tu32 mask = 1 << tag;\n\n\t/* clear outstanding transaction before retry */\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tufshcd_utrl_clear(hba, tag);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\t/*\n\t * wait for for h/w to clear corresponding bit in door-bell.\n\t * max. wait is 1 sec.\n\t */\n\terr = ufshcd_wait_for_register(hba,\n\t\t\tREG_UTP_TRANSFER_REQ_DOOR_BELL,\n\t\t\tmask, ~mask, 1000, 1000);\n\n\treturn err;\n}\n\nstatic int\nufshcd_check_query_response(struct ufs_hba *hba, struct ufshcd_lrb *lrbp)\n{\n\tstruct ufs_query_res *query_res = &hba->dev_cmd.query.response;\n\n\t/* Get the UPIU response */\n\tquery_res->response = ufshcd_get_rsp_upiu_result(lrbp->ucd_rsp_ptr) >>\n\t\t\t\tUPIU_RSP_CODE_OFFSET;\n\treturn query_res->response;\n}\n\n/**\n * ufshcd_dev_cmd_completion() - handles device management command responses\n * @hba: per adapter instance\n * @lrbp: pointer to local reference block\n */\nstatic int\nufshcd_dev_cmd_completion(struct ufs_hba *hba, struct ufshcd_lrb *lrbp)\n{\n\tint resp;\n\tint err = 0;\n\n\thba->ufs_stats.last_hibern8_exit_tstamp = ktime_set(0, 0);\n\tresp = ufshcd_get_req_rsp(lrbp->ucd_rsp_ptr);\n\n\tswitch (resp) {\n\tcase UPIU_TRANSACTION_NOP_IN:\n\t\tif (hba->dev_cmd.type != DEV_CMD_TYPE_NOP) {\n\t\t\terr = -EINVAL;\n\t\t\tdev_err(hba->dev, \"%s: unexpected response %x\\n\",\n\t\t\t\t\t__func__, resp);\n\t\t}\n\t\tbreak;\n\tcase UPIU_TRANSACTION_QUERY_RSP:\n\t\terr = ufshcd_check_query_response(hba, lrbp);\n\t\tif (!err)\n\t\t\terr = ufshcd_copy_query_response(hba, lrbp);\n\t\tbreak;\n\tcase UPIU_TRANSACTION_REJECT_UPIU:\n\t\t/* TODO: handle Reject UPIU Response */\n\t\terr = -EPERM;\n\t\tdev_err(hba->dev, \"%s: Reject UPIU not fully implemented\\n\",\n\t\t\t\t__func__);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tdev_err(hba->dev, \"%s: Invalid device management cmd response: %x\\n\",\n\t\t\t\t__func__, resp);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int ufshcd_wait_for_dev_cmd(struct ufs_hba *hba,\n\t\tstruct ufshcd_lrb *lrbp, int max_timeout)\n{\n\tint err = 0;\n\tunsigned long time_left;\n\tunsigned long flags;\n\n\ttime_left = wait_for_completion_timeout(hba->dev_cmd.complete,\n\t\t\tmsecs_to_jiffies(max_timeout));\n\n\t/* Make sure descriptors are ready before ringing the doorbell */\n\twmb();\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\thba->dev_cmd.complete = NULL;\n\tif (likely(time_left)) {\n\t\terr = ufshcd_get_tr_ocs(lrbp);\n\t\tif (!err)\n\t\t\terr = ufshcd_dev_cmd_completion(hba, lrbp);\n\t}\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\tif (!time_left) {\n\t\terr = -ETIMEDOUT;\n\t\tdev_dbg(hba->dev, \"%s: dev_cmd request timedout, tag %d\\n\",\n\t\t\t__func__, lrbp->task_tag);\n\t\tif (!ufshcd_clear_cmd(hba, lrbp->task_tag))\n\t\t\t/* successfully cleared the command, retry if needed */\n\t\t\terr = -EAGAIN;\n\t\t/*\n\t\t * in case of an error, after clearing the doorbell,\n\t\t * we also need to clear the outstanding_request\n\t\t * field in hba\n\t\t */\n\t\tufshcd_outstanding_req_clear(hba, lrbp->task_tag);\n\t}\n\n\treturn err;\n}\n\n/**\n * ufshcd_exec_dev_cmd - API for sending device management requests\n * @hba: UFS hba\n * @cmd_type: specifies the type (NOP, Query...)\n * @timeout: time in seconds\n *\n * NOTE: Since there is only one available tag for device management commands,\n * it is expected you hold the hba->dev_cmd.lock mutex.\n */\nstatic int ufshcd_exec_dev_cmd(struct ufs_hba *hba,\n\t\tenum dev_cmd_type cmd_type, int timeout)\n{\n\tstruct request_queue *q = hba->cmd_queue;\n\tstruct request *req;\n\tstruct ufshcd_lrb *lrbp;\n\tint err;\n\tint tag;\n\tstruct completion wait;\n\tunsigned long flags;\n\n\tdown_read(&hba->clk_scaling_lock);\n\n\t/*\n\t * Get free slot, sleep if slots are unavailable.\n\t * Even though we use wait_event() which sleeps indefinitely,\n\t * the maximum wait time is bounded by SCSI request timeout.\n\t */\n\treq = blk_get_request(q, REQ_OP_DRV_OUT, 0);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out_unlock;\n\t}\n\ttag = req->tag;\n\tWARN_ON_ONCE(!ufshcd_valid_tag(hba, tag));\n\n\tinit_completion(&wait);\n\tlrbp = &hba->lrb[tag];\n\tWARN_ON(lrbp->cmd);\n\terr = ufshcd_compose_dev_cmd(hba, lrbp, cmd_type, tag);\n\tif (unlikely(err))\n\t\tgoto out_put_tag;\n\n\thba->dev_cmd.complete = &wait;\n\n\tufshcd_add_query_upiu_trace(hba, tag, \"query_send\");\n\t/* Make sure descriptors are ready before ringing the doorbell */\n\twmb();\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tufshcd_send_command(hba, tag);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\terr = ufshcd_wait_for_dev_cmd(hba, lrbp, timeout);\n\n\tufshcd_add_query_upiu_trace(hba, tag,\n\t\t\terr ? \"query_complete_err\" : \"query_complete\");\n\nout_put_tag:\n\tblk_put_request(req);\nout_unlock:\n\tup_read(&hba->clk_scaling_lock);\n\treturn err;\n}\n\n/**\n * ufshcd_init_query() - init the query response and request parameters\n * @hba: per-adapter instance\n * @request: address of the request pointer to be initialized\n * @response: address of the response pointer to be initialized\n * @opcode: operation to perform\n * @idn: flag idn to access\n * @index: LU number to access\n * @selector: query/flag/descriptor further identification\n */\nstatic inline void ufshcd_init_query(struct ufs_hba *hba,\n\t\tstruct ufs_query_req **request, struct ufs_query_res **response,\n\t\tenum query_opcode opcode, u8 idn, u8 index, u8 selector)\n{\n\t*request = &hba->dev_cmd.query.request;\n\t*response = &hba->dev_cmd.query.response;\n\tmemset(*request, 0, sizeof(struct ufs_query_req));\n\tmemset(*response, 0, sizeof(struct ufs_query_res));\n\t(*request)->upiu_req.opcode = opcode;\n\t(*request)->upiu_req.idn = idn;\n\t(*request)->upiu_req.index = index;\n\t(*request)->upiu_req.selector = selector;\n}\n\nstatic int ufshcd_query_flag_retry(struct ufs_hba *hba,\n\tenum query_opcode opcode, enum flag_idn idn, u8 index, bool *flag_res)\n{\n\tint ret;\n\tint retries;\n\n\tfor (retries = 0; retries < QUERY_REQ_RETRIES; retries++) {\n\t\tret = ufshcd_query_flag(hba, opcode, idn, index, flag_res);\n\t\tif (ret)\n\t\t\tdev_dbg(hba->dev,\n\t\t\t\t\"%s: failed with error %d, retries %d\\n\",\n\t\t\t\t__func__, ret, retries);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tdev_err(hba->dev,\n\t\t\t\"%s: query attribute, opcode %d, idn %d, failed with error %d after %d retires\\n\",\n\t\t\t__func__, opcode, idn, ret, retries);\n\treturn ret;\n}\n\n/**\n * ufshcd_query_flag() - API function for sending flag query requests\n * @hba: per-adapter instance\n * @opcode: flag query to perform\n * @idn: flag idn to access\n * @index: flag index to access\n * @flag_res: the flag value after the query request completes\n *\n * Returns 0 for success, non-zero in case of failure\n */\nint ufshcd_query_flag(struct ufs_hba *hba, enum query_opcode opcode,\n\t\t\tenum flag_idn idn, u8 index, bool *flag_res)\n{\n\tstruct ufs_query_req *request = NULL;\n\tstruct ufs_query_res *response = NULL;\n\tint err, selector = 0;\n\tint timeout = QUERY_REQ_TIMEOUT;\n\n\tBUG_ON(!hba);\n\n\tufshcd_hold(hba, false);\n\tmutex_lock(&hba->dev_cmd.lock);\n\tufshcd_init_query(hba, &request, &response, opcode, idn, index,\n\t\t\tselector);\n\n\tswitch (opcode) {\n\tcase UPIU_QUERY_OPCODE_SET_FLAG:\n\tcase UPIU_QUERY_OPCODE_CLEAR_FLAG:\n\tcase UPIU_QUERY_OPCODE_TOGGLE_FLAG:\n\t\trequest->query_func = UPIU_QUERY_FUNC_STANDARD_WRITE_REQUEST;\n\t\tbreak;\n\tcase UPIU_QUERY_OPCODE_READ_FLAG:\n\t\trequest->query_func = UPIU_QUERY_FUNC_STANDARD_READ_REQUEST;\n\t\tif (!flag_res) {\n\t\t\t/* No dummy reads */\n\t\t\tdev_err(hba->dev, \"%s: Invalid argument for read request\\n\",\n\t\t\t\t\t__func__);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hba->dev,\n\t\t\t\"%s: Expected query flag opcode but got = %d\\n\",\n\t\t\t__func__, opcode);\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\terr = ufshcd_exec_dev_cmd(hba, DEV_CMD_TYPE_QUERY, timeout);\n\n\tif (err) {\n\t\tdev_err(hba->dev,\n\t\t\t\"%s: Sending flag query for idn %d failed, err = %d\\n\",\n\t\t\t__func__, idn, err);\n\t\tgoto out_unlock;\n\t}\n\n\tif (flag_res)\n\t\t*flag_res = (be32_to_cpu(response->upiu_res.value) &\n\t\t\t\tMASK_QUERY_UPIU_FLAG_LOC) & 0x1;\n\nout_unlock:\n\tmutex_unlock(&hba->dev_cmd.lock);\n\tufshcd_release(hba);\n\treturn err;\n}\n\n/**\n * ufshcd_query_attr - API function for sending attribute requests\n * @hba: per-adapter instance\n * @opcode: attribute opcode\n * @idn: attribute idn to access\n * @index: index field\n * @selector: selector field\n * @attr_val: the attribute value after the query request completes\n *\n * Returns 0 for success, non-zero in case of failure\n*/\nint ufshcd_query_attr(struct ufs_hba *hba, enum query_opcode opcode,\n\t\t      enum attr_idn idn, u8 index, u8 selector, u32 *attr_val)\n{\n\tstruct ufs_query_req *request = NULL;\n\tstruct ufs_query_res *response = NULL;\n\tint err;\n\n\tBUG_ON(!hba);\n\n\tufshcd_hold(hba, false);\n\tif (!attr_val) {\n\t\tdev_err(hba->dev, \"%s: attribute value required for opcode 0x%x\\n\",\n\t\t\t\t__func__, opcode);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&hba->dev_cmd.lock);\n\tufshcd_init_query(hba, &request, &response, opcode, idn, index,\n\t\t\tselector);\n\n\tswitch (opcode) {\n\tcase UPIU_QUERY_OPCODE_WRITE_ATTR:\n\t\trequest->query_func = UPIU_QUERY_FUNC_STANDARD_WRITE_REQUEST;\n\t\trequest->upiu_req.value = cpu_to_be32(*attr_val);\n\t\tbreak;\n\tcase UPIU_QUERY_OPCODE_READ_ATTR:\n\t\trequest->query_func = UPIU_QUERY_FUNC_STANDARD_READ_REQUEST;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hba->dev, \"%s: Expected query attr opcode but got = 0x%.2x\\n\",\n\t\t\t\t__func__, opcode);\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\terr = ufshcd_exec_dev_cmd(hba, DEV_CMD_TYPE_QUERY, QUERY_REQ_TIMEOUT);\n\n\tif (err) {\n\t\tdev_err(hba->dev, \"%s: opcode 0x%.2x for idn %d failed, index %d, err = %d\\n\",\n\t\t\t\t__func__, opcode, idn, index, err);\n\t\tgoto out_unlock;\n\t}\n\n\t*attr_val = be32_to_cpu(response->upiu_res.value);\n\nout_unlock:\n\tmutex_unlock(&hba->dev_cmd.lock);\nout:\n\tufshcd_release(hba);\n\treturn err;\n}\n\n/**\n * ufshcd_query_attr_retry() - API function for sending query\n * attribute with retries\n * @hba: per-adapter instance\n * @opcode: attribute opcode\n * @idn: attribute idn to access\n * @index: index field\n * @selector: selector field\n * @attr_val: the attribute value after the query request\n * completes\n *\n * Returns 0 for success, non-zero in case of failure\n*/\nstatic int ufshcd_query_attr_retry(struct ufs_hba *hba,\n\tenum query_opcode opcode, enum attr_idn idn, u8 index, u8 selector,\n\tu32 *attr_val)\n{\n\tint ret = 0;\n\tu32 retries;\n\n\tfor (retries = QUERY_REQ_RETRIES; retries > 0; retries--) {\n\t\tret = ufshcd_query_attr(hba, opcode, idn, index,\n\t\t\t\t\t\tselector, attr_val);\n\t\tif (ret)\n\t\t\tdev_dbg(hba->dev, \"%s: failed with error %d, retries %d\\n\",\n\t\t\t\t__func__, ret, retries);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tdev_err(hba->dev,\n\t\t\t\"%s: query attribute, idn %d, failed with error %d after %d retires\\n\",\n\t\t\t__func__, idn, ret, QUERY_REQ_RETRIES);\n\treturn ret;\n}\n\nstatic int __ufshcd_query_descriptor(struct ufs_hba *hba,\n\t\t\tenum query_opcode opcode, enum desc_idn idn, u8 index,\n\t\t\tu8 selector, u8 *desc_buf, int *buf_len)\n{\n\tstruct ufs_query_req *request = NULL;\n\tstruct ufs_query_res *response = NULL;\n\tint err;\n\n\tBUG_ON(!hba);\n\n\tufshcd_hold(hba, false);\n\tif (!desc_buf) {\n\t\tdev_err(hba->dev, \"%s: descriptor buffer required for opcode 0x%x\\n\",\n\t\t\t\t__func__, opcode);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (*buf_len < QUERY_DESC_MIN_SIZE || *buf_len > QUERY_DESC_MAX_SIZE) {\n\t\tdev_err(hba->dev, \"%s: descriptor buffer size (%d) is out of range\\n\",\n\t\t\t\t__func__, *buf_len);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&hba->dev_cmd.lock);\n\tufshcd_init_query(hba, &request, &response, opcode, idn, index,\n\t\t\tselector);\n\thba->dev_cmd.query.descriptor = desc_buf;\n\trequest->upiu_req.length = cpu_to_be16(*buf_len);\n\n\tswitch (opcode) {\n\tcase UPIU_QUERY_OPCODE_WRITE_DESC:\n\t\trequest->query_func = UPIU_QUERY_FUNC_STANDARD_WRITE_REQUEST;\n\t\tbreak;\n\tcase UPIU_QUERY_OPCODE_READ_DESC:\n\t\trequest->query_func = UPIU_QUERY_FUNC_STANDARD_READ_REQUEST;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hba->dev,\n\t\t\t\t\"%s: Expected query descriptor opcode but got = 0x%.2x\\n\",\n\t\t\t\t__func__, opcode);\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\terr = ufshcd_exec_dev_cmd(hba, DEV_CMD_TYPE_QUERY, QUERY_REQ_TIMEOUT);\n\n\tif (err) {\n\t\tdev_err(hba->dev, \"%s: opcode 0x%.2x for idn %d failed, index %d, err = %d\\n\",\n\t\t\t\t__func__, opcode, idn, index, err);\n\t\tgoto out_unlock;\n\t}\n\n\t*buf_len = be16_to_cpu(response->upiu_res.length);\n\nout_unlock:\n\thba->dev_cmd.query.descriptor = NULL;\n\tmutex_unlock(&hba->dev_cmd.lock);\nout:\n\tufshcd_release(hba);\n\treturn err;\n}\n\n/**\n * ufshcd_query_descriptor_retry - API function for sending descriptor requests\n * @hba: per-adapter instance\n * @opcode: attribute opcode\n * @idn: attribute idn to access\n * @index: index field\n * @selector: selector field\n * @desc_buf: the buffer that contains the descriptor\n * @buf_len: length parameter passed to the device\n *\n * Returns 0 for success, non-zero in case of failure.\n * The buf_len parameter will contain, on return, the length parameter\n * received on the response.\n */\nint ufshcd_query_descriptor_retry(struct ufs_hba *hba,\n\t\t\t\t  enum query_opcode opcode,\n\t\t\t\t  enum desc_idn idn, u8 index,\n\t\t\t\t  u8 selector,\n\t\t\t\t  u8 *desc_buf, int *buf_len)\n{\n\tint err;\n\tint retries;\n\n\tfor (retries = QUERY_REQ_RETRIES; retries > 0; retries--) {\n\t\terr = __ufshcd_query_descriptor(hba, opcode, idn, index,\n\t\t\t\t\t\tselector, desc_buf, buf_len);\n\t\tif (!err || err == -EINVAL)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n/**\n * ufshcd_map_desc_id_to_length - map descriptor IDN to its length\n * @hba: Pointer to adapter instance\n * @desc_id: descriptor idn value\n * @desc_len: mapped desc length (out)\n */\nvoid ufshcd_map_desc_id_to_length(struct ufs_hba *hba, enum desc_idn desc_id,\n\t\t\t\t  int *desc_len)\n{\n\tif (desc_id >= QUERY_DESC_IDN_MAX || desc_id == QUERY_DESC_IDN_RFU_0 ||\n\t    desc_id == QUERY_DESC_IDN_RFU_1)\n\t\t*desc_len = 0;\n\telse\n\t\t*desc_len = hba->desc_size[desc_id];\n}\nEXPORT_SYMBOL(ufshcd_map_desc_id_to_length);\n\nstatic void ufshcd_update_desc_length(struct ufs_hba *hba,\n\t\t\t\t      enum desc_idn desc_id, int desc_index,\n\t\t\t\t      unsigned char desc_len)\n{\n\tif (hba->desc_size[desc_id] == QUERY_DESC_MAX_SIZE &&\n\t    desc_id != QUERY_DESC_IDN_STRING && desc_index != UFS_RPMB_UNIT)\n\t\t/* For UFS 3.1, the normal unit descriptor is 10 bytes larger\n\t\t * than the RPMB unit, however, both descriptors share the same\n\t\t * desc_idn, to cover both unit descriptors with one length, we\n\t\t * choose the normal unit descriptor length by desc_index.\n\t\t */\n\t\thba->desc_size[desc_id] = desc_len;\n}\n\n/**\n * ufshcd_read_desc_param - read the specified descriptor parameter\n * @hba: Pointer to adapter instance\n * @desc_id: descriptor idn value\n * @desc_index: descriptor index\n * @param_offset: offset of the parameter to read\n * @param_read_buf: pointer to buffer where parameter would be read\n * @param_size: sizeof(param_read_buf)\n *\n * Return 0 in case of success, non-zero otherwise\n */\nint ufshcd_read_desc_param(struct ufs_hba *hba,\n\t\t\t   enum desc_idn desc_id,\n\t\t\t   int desc_index,\n\t\t\t   u8 param_offset,\n\t\t\t   u8 *param_read_buf,\n\t\t\t   u8 param_size)\n{\n\tint ret;\n\tu8 *desc_buf;\n\tint buff_len;\n\tbool is_kmalloc = true;\n\n\t/* Safety check */\n\tif (desc_id >= QUERY_DESC_IDN_MAX || !param_size)\n\t\treturn -EINVAL;\n\n\t/* Get the length of descriptor */\n\tufshcd_map_desc_id_to_length(hba, desc_id, &buff_len);\n\tif (!buff_len) {\n\t\tdev_err(hba->dev, \"%s: Failed to get desc length\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param_offset >= buff_len) {\n\t\tdev_err(hba->dev, \"%s: Invalid offset 0x%x in descriptor IDN 0x%x, length 0x%x\\n\",\n\t\t\t__func__, param_offset, desc_id, buff_len);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check whether we need temp memory */\n\tif (param_offset != 0 || param_size < buff_len) {\n\t\tdesc_buf = kzalloc(buff_len, GFP_KERNEL);\n\t\tif (!desc_buf)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tdesc_buf = param_read_buf;\n\t\tis_kmalloc = false;\n\t}\n\n\t/* Request for full descriptor */\n\tret = ufshcd_query_descriptor_retry(hba, UPIU_QUERY_OPCODE_READ_DESC,\n\t\t\t\t\tdesc_id, desc_index, 0,\n\t\t\t\t\tdesc_buf, &buff_len);\n\n\tif (ret) {\n\t\tdev_err(hba->dev, \"%s: Failed reading descriptor. desc_id %d, desc_index %d, param_offset %d, ret %d\\n\",\n\t\t\t__func__, desc_id, desc_index, param_offset, ret);\n\t\tgoto out;\n\t}\n\n\t/* Sanity check */\n\tif (desc_buf[QUERY_DESC_DESC_TYPE_OFFSET] != desc_id) {\n\t\tdev_err(hba->dev, \"%s: invalid desc_id %d in descriptor header\\n\",\n\t\t\t__func__, desc_buf[QUERY_DESC_DESC_TYPE_OFFSET]);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Update descriptor length */\n\tbuff_len = desc_buf[QUERY_DESC_LENGTH_OFFSET];\n\tufshcd_update_desc_length(hba, desc_id, desc_index, buff_len);\n\n\tif (is_kmalloc) {\n\t\t/* Make sure we don't copy more data than available */\n\t\tif (param_offset + param_size > buff_len)\n\t\t\tparam_size = buff_len - param_offset;\n\t\tmemcpy(param_read_buf, &desc_buf[param_offset], param_size);\n\t}\nout:\n\tif (is_kmalloc)\n\t\tkfree(desc_buf);\n\treturn ret;\n}\n\n/**\n * struct uc_string_id - unicode string\n *\n * @len: size of this descriptor inclusive\n * @type: descriptor type\n * @uc: unicode string character\n */\nstruct uc_string_id {\n\tu8 len;\n\tu8 type;\n\twchar_t uc[];\n} __packed;\n\n/* replace non-printable or non-ASCII characters with spaces */\nstatic inline char ufshcd_remove_non_printable(u8 ch)\n{\n\treturn (ch >= 0x20 && ch <= 0x7e) ? ch : ' ';\n}\n\n/**\n * ufshcd_read_string_desc - read string descriptor\n * @hba: pointer to adapter instance\n * @desc_index: descriptor index\n * @buf: pointer to buffer where descriptor would be read,\n *       the caller should free the memory.\n * @ascii: if true convert from unicode to ascii characters\n *         null terminated string.\n *\n * Return:\n * *      string size on success.\n * *      -ENOMEM: on allocation failure\n * *      -EINVAL: on a wrong parameter\n */\nint ufshcd_read_string_desc(struct ufs_hba *hba, u8 desc_index,\n\t\t\t    u8 **buf, bool ascii)\n{\n\tstruct uc_string_id *uc_str;\n\tu8 *str;\n\tint ret;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tuc_str = kzalloc(QUERY_DESC_MAX_SIZE, GFP_KERNEL);\n\tif (!uc_str)\n\t\treturn -ENOMEM;\n\n\tret = ufshcd_read_desc_param(hba, QUERY_DESC_IDN_STRING, desc_index, 0,\n\t\t\t\t     (u8 *)uc_str, QUERY_DESC_MAX_SIZE);\n\tif (ret < 0) {\n\t\tdev_err(hba->dev, \"Reading String Desc failed after %d retries. err = %d\\n\",\n\t\t\tQUERY_REQ_RETRIES, ret);\n\t\tstr = NULL;\n\t\tgoto out;\n\t}\n\n\tif (uc_str->len <= QUERY_DESC_HDR_SIZE) {\n\t\tdev_dbg(hba->dev, \"String Desc is of zero length\\n\");\n\t\tstr = NULL;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (ascii) {\n\t\tssize_t ascii_len;\n\t\tint i;\n\t\t/* remove header and divide by 2 to move from UTF16 to UTF8 */\n\t\tascii_len = (uc_str->len - QUERY_DESC_HDR_SIZE) / 2 + 1;\n\t\tstr = kzalloc(ascii_len, GFP_KERNEL);\n\t\tif (!str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * the descriptor contains string in UTF16 format\n\t\t * we need to convert to utf-8 so it can be displayed\n\t\t */\n\t\tret = utf16s_to_utf8s(uc_str->uc,\n\t\t\t\t      uc_str->len - QUERY_DESC_HDR_SIZE,\n\t\t\t\t      UTF16_BIG_ENDIAN, str, ascii_len);\n\n\t\t/* replace non-printable or non-ASCII characters with spaces */\n\t\tfor (i = 0; i < ret; i++)\n\t\t\tstr[i] = ufshcd_remove_non_printable(str[i]);\n\n\t\tstr[ret++] = '\\0';\n\n\t} else {\n\t\tstr = kmemdup(uc_str, uc_str->len, GFP_KERNEL);\n\t\tif (!str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = uc_str->len;\n\t}\nout:\n\t*buf = str;\n\tkfree(uc_str);\n\treturn ret;\n}\n\n/**\n * ufshcd_read_unit_desc_param - read the specified unit descriptor parameter\n * @hba: Pointer to adapter instance\n * @lun: lun id\n * @param_offset: offset of the parameter to read\n * @param_read_buf: pointer to buffer where parameter would be read\n * @param_size: sizeof(param_read_buf)\n *\n * Return 0 in case of success, non-zero otherwise\n */\nstatic inline int ufshcd_read_unit_desc_param(struct ufs_hba *hba,\n\t\t\t\t\t      int lun,\n\t\t\t\t\t      enum unit_desc_param param_offset,\n\t\t\t\t\t      u8 *param_read_buf,\n\t\t\t\t\t      u32 param_size)\n{\n\t/*\n\t * Unit descriptors are only available for general purpose LUs (LUN id\n\t * from 0 to 7) and RPMB Well known LU.\n\t */\n\tif (!ufs_is_valid_unit_desc_lun(&hba->dev_info, lun))\n\t\treturn -EOPNOTSUPP;\n\n\treturn ufshcd_read_desc_param(hba, QUERY_DESC_IDN_UNIT, lun,\n\t\t\t\t      param_offset, param_read_buf, param_size);\n}\n\nstatic int ufshcd_get_ref_clk_gating_wait(struct ufs_hba *hba)\n{\n\tint err = 0;\n\tu32 gating_wait = UFSHCD_REF_CLK_GATING_WAIT_US;\n\n\tif (hba->dev_info.wspecversion >= 0x300) {\n\t\terr = ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_READ_ATTR,\n\t\t\t\tQUERY_ATTR_IDN_REF_CLK_GATING_WAIT_TIME, 0, 0,\n\t\t\t\t&gating_wait);\n\t\tif (err)\n\t\t\tdev_err(hba->dev, \"Failed reading bRefClkGatingWait. err = %d, use default %uus\\n\",\n\t\t\t\t\t err, gating_wait);\n\n\t\tif (gating_wait == 0) {\n\t\t\tgating_wait = UFSHCD_REF_CLK_GATING_WAIT_US;\n\t\t\tdev_err(hba->dev, \"Undefined ref clk gating wait time, use default %uus\\n\",\n\t\t\t\t\t gating_wait);\n\t\t}\n\n\t\thba->dev_info.clk_gating_wait_us = gating_wait;\n\t}\n\n\treturn err;\n}\n\n/**\n * ufshcd_memory_alloc - allocate memory for host memory space data structures\n * @hba: per adapter instance\n *\n * 1. Allocate DMA memory for Command Descriptor array\n *\tEach command descriptor consist of Command UPIU, Response UPIU and PRDT\n * 2. Allocate DMA memory for UTP Transfer Request Descriptor List (UTRDL).\n * 3. Allocate DMA memory for UTP Task Management Request Descriptor List\n *\t(UTMRDL)\n * 4. Allocate memory for local reference block(lrb).\n *\n * Returns 0 for success, non-zero in case of failure\n */\nstatic int ufshcd_memory_alloc(struct ufs_hba *hba)\n{\n\tsize_t utmrdl_size, utrdl_size, ucdl_size;\n\n\t/* Allocate memory for UTP command descriptors */\n\tucdl_size = (sizeof(struct utp_transfer_cmd_desc) * hba->nutrs);\n\thba->ucdl_base_addr = dmam_alloc_coherent(hba->dev,\n\t\t\t\t\t\t  ucdl_size,\n\t\t\t\t\t\t  &hba->ucdl_dma_addr,\n\t\t\t\t\t\t  GFP_KERNEL);\n\n\t/*\n\t * UFSHCI requires UTP command descriptor to be 128 byte aligned.\n\t * make sure hba->ucdl_dma_addr is aligned to PAGE_SIZE\n\t * if hba->ucdl_dma_addr is aligned to PAGE_SIZE, then it will\n\t * be aligned to 128 bytes as well\n\t */\n\tif (!hba->ucdl_base_addr ||\n\t    WARN_ON(hba->ucdl_dma_addr & (PAGE_SIZE - 1))) {\n\t\tdev_err(hba->dev,\n\t\t\t\"Command Descriptor Memory allocation failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Allocate memory for UTP Transfer descriptors\n\t * UFSHCI requires 1024 byte alignment of UTRD\n\t */\n\tutrdl_size = (sizeof(struct utp_transfer_req_desc) * hba->nutrs);\n\thba->utrdl_base_addr = dmam_alloc_coherent(hba->dev,\n\t\t\t\t\t\t   utrdl_size,\n\t\t\t\t\t\t   &hba->utrdl_dma_addr,\n\t\t\t\t\t\t   GFP_KERNEL);\n\tif (!hba->utrdl_base_addr ||\n\t    WARN_ON(hba->utrdl_dma_addr & (PAGE_SIZE - 1))) {\n\t\tdev_err(hba->dev,\n\t\t\t\"Transfer Descriptor Memory allocation failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Allocate memory for UTP Task Management descriptors\n\t * UFSHCI requires 1024 byte alignment of UTMRD\n\t */\n\tutmrdl_size = sizeof(struct utp_task_req_desc) * hba->nutmrs;\n\thba->utmrdl_base_addr = dmam_alloc_coherent(hba->dev,\n\t\t\t\t\t\t    utmrdl_size,\n\t\t\t\t\t\t    &hba->utmrdl_dma_addr,\n\t\t\t\t\t\t    GFP_KERNEL);\n\tif (!hba->utmrdl_base_addr ||\n\t    WARN_ON(hba->utmrdl_dma_addr & (PAGE_SIZE - 1))) {\n\t\tdev_err(hba->dev,\n\t\t\"Task Management Descriptor Memory allocation failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Allocate memory for local reference block */\n\thba->lrb = devm_kcalloc(hba->dev,\n\t\t\t\thba->nutrs, sizeof(struct ufshcd_lrb),\n\t\t\t\tGFP_KERNEL);\n\tif (!hba->lrb) {\n\t\tdev_err(hba->dev, \"LRB Memory allocation failed\\n\");\n\t\tgoto out;\n\t}\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}\n\n/**\n * ufshcd_host_memory_configure - configure local reference block with\n *\t\t\t\tmemory offsets\n * @hba: per adapter instance\n *\n * Configure Host memory space\n * 1. Update Corresponding UTRD.UCDBA and UTRD.UCDBAU with UCD DMA\n * address.\n * 2. Update each UTRD with Response UPIU offset, Response UPIU length\n * and PRDT offset.\n * 3. Save the corresponding addresses of UTRD, UCD.CMD, UCD.RSP and UCD.PRDT\n * into local reference block.\n */\nstatic void ufshcd_host_memory_configure(struct ufs_hba *hba)\n{\n\tstruct utp_transfer_req_desc *utrdlp;\n\tdma_addr_t cmd_desc_dma_addr;\n\tdma_addr_t cmd_desc_element_addr;\n\tu16 response_offset;\n\tu16 prdt_offset;\n\tint cmd_desc_size;\n\tint i;\n\n\tutrdlp = hba->utrdl_base_addr;\n\n\tresponse_offset =\n\t\toffsetof(struct utp_transfer_cmd_desc, response_upiu);\n\tprdt_offset =\n\t\toffsetof(struct utp_transfer_cmd_desc, prd_table);\n\n\tcmd_desc_size = sizeof(struct utp_transfer_cmd_desc);\n\tcmd_desc_dma_addr = hba->ucdl_dma_addr;\n\n\tfor (i = 0; i < hba->nutrs; i++) {\n\t\t/* Configure UTRD with command descriptor base address */\n\t\tcmd_desc_element_addr =\n\t\t\t\t(cmd_desc_dma_addr + (cmd_desc_size * i));\n\t\tutrdlp[i].command_desc_base_addr_lo =\n\t\t\t\tcpu_to_le32(lower_32_bits(cmd_desc_element_addr));\n\t\tutrdlp[i].command_desc_base_addr_hi =\n\t\t\t\tcpu_to_le32(upper_32_bits(cmd_desc_element_addr));\n\n\t\t/* Response upiu and prdt offset should be in double words */\n\t\tif (hba->quirks & UFSHCD_QUIRK_PRDT_BYTE_GRAN) {\n\t\t\tutrdlp[i].response_upiu_offset =\n\t\t\t\tcpu_to_le16(response_offset);\n\t\t\tutrdlp[i].prd_table_offset =\n\t\t\t\tcpu_to_le16(prdt_offset);\n\t\t\tutrdlp[i].response_upiu_length =\n\t\t\t\tcpu_to_le16(ALIGNED_UPIU_SIZE);\n\t\t} else {\n\t\t\tutrdlp[i].response_upiu_offset =\n\t\t\t\tcpu_to_le16(response_offset >> 2);\n\t\t\tutrdlp[i].prd_table_offset =\n\t\t\t\tcpu_to_le16(prdt_offset >> 2);\n\t\t\tutrdlp[i].response_upiu_length =\n\t\t\t\tcpu_to_le16(ALIGNED_UPIU_SIZE >> 2);\n\t\t}\n\n\t\tufshcd_init_lrb(hba, &hba->lrb[i], i);\n\t}\n}\n\n/**\n * ufshcd_dme_link_startup - Notify Unipro to perform link startup\n * @hba: per adapter instance\n *\n * UIC_CMD_DME_LINK_STARTUP command must be issued to Unipro layer,\n * in order to initialize the Unipro link startup procedure.\n * Once the Unipro links are up, the device connected to the controller\n * is detected.\n *\n * Returns 0 on success, non-zero value on failure\n */\nstatic int ufshcd_dme_link_startup(struct ufs_hba *hba)\n{\n\tstruct uic_command uic_cmd = {0};\n\tint ret;\n\n\tuic_cmd.command = UIC_CMD_DME_LINK_STARTUP;\n\n\tret = ufshcd_send_uic_cmd(hba, &uic_cmd);\n\tif (ret)\n\t\tdev_dbg(hba->dev,\n\t\t\t\"dme-link-startup: error code %d\\n\", ret);\n\treturn ret;\n}\n/**\n * ufshcd_dme_reset - UIC command for DME_RESET\n * @hba: per adapter instance\n *\n * DME_RESET command is issued in order to reset UniPro stack.\n * This function now deals with cold reset.\n *\n * Returns 0 on success, non-zero value on failure\n */\nstatic int ufshcd_dme_reset(struct ufs_hba *hba)\n{\n\tstruct uic_command uic_cmd = {0};\n\tint ret;\n\n\tuic_cmd.command = UIC_CMD_DME_RESET;\n\n\tret = ufshcd_send_uic_cmd(hba, &uic_cmd);\n\tif (ret)\n\t\tdev_err(hba->dev,\n\t\t\t\"dme-reset: error code %d\\n\", ret);\n\n\treturn ret;\n}\n\nint ufshcd_dme_configure_adapt(struct ufs_hba *hba,\n\t\t\t       int agreed_gear,\n\t\t\t       int adapt_val)\n{\n\tint ret;\n\n\tif (agreed_gear != UFS_HS_G4)\n\t\tadapt_val = PA_NO_ADAPT;\n\n\tret = ufshcd_dme_set(hba,\n\t\t\t     UIC_ARG_MIB(PA_TXHSADAPTTYPE),\n\t\t\t     adapt_val);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ufshcd_dme_configure_adapt);\n\n/**\n * ufshcd_dme_enable - UIC command for DME_ENABLE\n * @hba: per adapter instance\n *\n * DME_ENABLE command is issued in order to enable UniPro stack.\n *\n * Returns 0 on success, non-zero value on failure\n */\nstatic int ufshcd_dme_enable(struct ufs_hba *hba)\n{\n\tstruct uic_command uic_cmd = {0};\n\tint ret;\n\n\tuic_cmd.command = UIC_CMD_DME_ENABLE;\n\n\tret = ufshcd_send_uic_cmd(hba, &uic_cmd);\n\tif (ret)\n\t\tdev_err(hba->dev,\n\t\t\t\"dme-reset: error code %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic inline void ufshcd_add_delay_before_dme_cmd(struct ufs_hba *hba)\n{\n\t#define MIN_DELAY_BEFORE_DME_CMDS_US\t1000\n\tunsigned long min_sleep_time_us;\n\n\tif (!(hba->quirks & UFSHCD_QUIRK_DELAY_BEFORE_DME_CMDS))\n\t\treturn;\n\n\t/*\n\t * last_dme_cmd_tstamp will be 0 only for 1st call to\n\t * this function\n\t */\n\tif (unlikely(!ktime_to_us(hba->last_dme_cmd_tstamp))) {\n\t\tmin_sleep_time_us = MIN_DELAY_BEFORE_DME_CMDS_US;\n\t} else {\n\t\tunsigned long delta =\n\t\t\t(unsigned long) ktime_to_us(\n\t\t\t\tktime_sub(ktime_get(),\n\t\t\t\thba->last_dme_cmd_tstamp));\n\n\t\tif (delta < MIN_DELAY_BEFORE_DME_CMDS_US)\n\t\t\tmin_sleep_time_us =\n\t\t\t\tMIN_DELAY_BEFORE_DME_CMDS_US - delta;\n\t\telse\n\t\t\treturn; /* no more delay required */\n\t}\n\n\t/* allow sleep for extra 50us if needed */\n\tusleep_range(min_sleep_time_us, min_sleep_time_us + 50);\n}\n\n/**\n * ufshcd_dme_set_attr - UIC command for DME_SET, DME_PEER_SET\n * @hba: per adapter instance\n * @attr_sel: uic command argument1\n * @attr_set: attribute set type as uic command argument2\n * @mib_val: setting value as uic command argument3\n * @peer: indicate whether peer or local\n *\n * Returns 0 on success, non-zero value on failure\n */\nint ufshcd_dme_set_attr(struct ufs_hba *hba, u32 attr_sel,\n\t\t\tu8 attr_set, u32 mib_val, u8 peer)\n{\n\tstruct uic_command uic_cmd = {0};\n\tstatic const char *const action[] = {\n\t\t\"dme-set\",\n\t\t\"dme-peer-set\"\n\t};\n\tconst char *set = action[!!peer];\n\tint ret;\n\tint retries = UFS_UIC_COMMAND_RETRIES;\n\n\tuic_cmd.command = peer ?\n\t\tUIC_CMD_DME_PEER_SET : UIC_CMD_DME_SET;\n\tuic_cmd.argument1 = attr_sel;\n\tuic_cmd.argument2 = UIC_ARG_ATTR_TYPE(attr_set);\n\tuic_cmd.argument3 = mib_val;\n\n\tdo {\n\t\t/* for peer attributes we retry upon failure */\n\t\tret = ufshcd_send_uic_cmd(hba, &uic_cmd);\n\t\tif (ret)\n\t\t\tdev_dbg(hba->dev, \"%s: attr-id 0x%x val 0x%x error code %d\\n\",\n\t\t\t\tset, UIC_GET_ATTR_ID(attr_sel), mib_val, ret);\n\t} while (ret && peer && --retries);\n\n\tif (ret)\n\t\tdev_err(hba->dev, \"%s: attr-id 0x%x val 0x%x failed %d retries\\n\",\n\t\t\tset, UIC_GET_ATTR_ID(attr_sel), mib_val,\n\t\t\tUFS_UIC_COMMAND_RETRIES - retries);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ufshcd_dme_set_attr);\n\n/**\n * ufshcd_dme_get_attr - UIC command for DME_GET, DME_PEER_GET\n * @hba: per adapter instance\n * @attr_sel: uic command argument1\n * @mib_val: the value of the attribute as returned by the UIC command\n * @peer: indicate whether peer or local\n *\n * Returns 0 on success, non-zero value on failure\n */\nint ufshcd_dme_get_attr(struct ufs_hba *hba, u32 attr_sel,\n\t\t\tu32 *mib_val, u8 peer)\n{\n\tstruct uic_command uic_cmd = {0};\n\tstatic const char *const action[] = {\n\t\t\"dme-get\",\n\t\t\"dme-peer-get\"\n\t};\n\tconst char *get = action[!!peer];\n\tint ret;\n\tint retries = UFS_UIC_COMMAND_RETRIES;\n\tstruct ufs_pa_layer_attr orig_pwr_info;\n\tstruct ufs_pa_layer_attr temp_pwr_info;\n\tbool pwr_mode_change = false;\n\n\tif (peer && (hba->quirks & UFSHCD_QUIRK_DME_PEER_ACCESS_AUTO_MODE)) {\n\t\torig_pwr_info = hba->pwr_info;\n\t\ttemp_pwr_info = orig_pwr_info;\n\n\t\tif (orig_pwr_info.pwr_tx == FAST_MODE ||\n\t\t    orig_pwr_info.pwr_rx == FAST_MODE) {\n\t\t\ttemp_pwr_info.pwr_tx = FASTAUTO_MODE;\n\t\t\ttemp_pwr_info.pwr_rx = FASTAUTO_MODE;\n\t\t\tpwr_mode_change = true;\n\t\t} else if (orig_pwr_info.pwr_tx == SLOW_MODE ||\n\t\t    orig_pwr_info.pwr_rx == SLOW_MODE) {\n\t\t\ttemp_pwr_info.pwr_tx = SLOWAUTO_MODE;\n\t\t\ttemp_pwr_info.pwr_rx = SLOWAUTO_MODE;\n\t\t\tpwr_mode_change = true;\n\t\t}\n\t\tif (pwr_mode_change) {\n\t\t\tret = ufshcd_change_power_mode(hba, &temp_pwr_info);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tuic_cmd.command = peer ?\n\t\tUIC_CMD_DME_PEER_GET : UIC_CMD_DME_GET;\n\tuic_cmd.argument1 = attr_sel;\n\n\tdo {\n\t\t/* for peer attributes we retry upon failure */\n\t\tret = ufshcd_send_uic_cmd(hba, &uic_cmd);\n\t\tif (ret)\n\t\t\tdev_dbg(hba->dev, \"%s: attr-id 0x%x error code %d\\n\",\n\t\t\t\tget, UIC_GET_ATTR_ID(attr_sel), ret);\n\t} while (ret && peer && --retries);\n\n\tif (ret)\n\t\tdev_err(hba->dev, \"%s: attr-id 0x%x failed %d retries\\n\",\n\t\t\tget, UIC_GET_ATTR_ID(attr_sel),\n\t\t\tUFS_UIC_COMMAND_RETRIES - retries);\n\n\tif (mib_val && !ret)\n\t\t*mib_val = uic_cmd.argument3;\n\n\tif (peer && (hba->quirks & UFSHCD_QUIRK_DME_PEER_ACCESS_AUTO_MODE)\n\t    && pwr_mode_change)\n\t\tufshcd_change_power_mode(hba, &orig_pwr_info);\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ufshcd_dme_get_attr);\n\n/**\n * ufshcd_uic_pwr_ctrl - executes UIC commands (which affects the link power\n * state) and waits for it to take effect.\n *\n * @hba: per adapter instance\n * @cmd: UIC command to execute\n *\n * DME operations like DME_SET(PA_PWRMODE), DME_HIBERNATE_ENTER &\n * DME_HIBERNATE_EXIT commands take some time to take its effect on both host\n * and device UniPro link and hence it's final completion would be indicated by\n * dedicated status bits in Interrupt Status register (UPMS, UHES, UHXS) in\n * addition to normal UIC command completion Status (UCCS). This function only\n * returns after the relevant status bits indicate the completion.\n *\n * Returns 0 on success, non-zero value on failure\n */\nstatic int ufshcd_uic_pwr_ctrl(struct ufs_hba *hba, struct uic_command *cmd)\n{\n\tstruct completion uic_async_done;\n\tunsigned long flags;\n\tu8 status;\n\tint ret;\n\tbool reenable_intr = false;\n\n\tmutex_lock(&hba->uic_cmd_mutex);\n\tinit_completion(&uic_async_done);\n\tufshcd_add_delay_before_dme_cmd(hba);\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tif (ufshcd_is_link_broken(hba)) {\n\t\tret = -ENOLINK;\n\t\tgoto out_unlock;\n\t}\n\thba->uic_async_done = &uic_async_done;\n\tif (ufshcd_readl(hba, REG_INTERRUPT_ENABLE) & UIC_COMMAND_COMPL) {\n\t\tufshcd_disable_intr(hba, UIC_COMMAND_COMPL);\n\t\t/*\n\t\t * Make sure UIC command completion interrupt is disabled before\n\t\t * issuing UIC command.\n\t\t */\n\t\twmb();\n\t\treenable_intr = true;\n\t}\n\tret = __ufshcd_send_uic_cmd(hba, cmd, false);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\tif (ret) {\n\t\tdev_err(hba->dev,\n\t\t\t\"pwr ctrl cmd 0x%x with mode 0x%x uic error %d\\n\",\n\t\t\tcmd->command, cmd->argument3, ret);\n\t\tgoto out;\n\t}\n\n\tif (!wait_for_completion_timeout(hba->uic_async_done,\n\t\t\t\t\t msecs_to_jiffies(UIC_CMD_TIMEOUT))) {\n\t\tdev_err(hba->dev,\n\t\t\t\"pwr ctrl cmd 0x%x with mode 0x%x completion timeout\\n\",\n\t\t\tcmd->command, cmd->argument3);\n\n\t\tif (!cmd->cmd_active) {\n\t\t\tdev_err(hba->dev, \"%s: Power Mode Change operation has been completed, go check UPMCRS\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto check_upmcrs;\n\t\t}\n\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\ncheck_upmcrs:\n\tstatus = ufshcd_get_upmcrs(hba);\n\tif (status != PWR_LOCAL) {\n\t\tdev_err(hba->dev,\n\t\t\t\"pwr ctrl cmd 0x%x failed, host upmcrs:0x%x\\n\",\n\t\t\tcmd->command, status);\n\t\tret = (status != PWR_OK) ? status : -1;\n\t}\nout:\n\tif (ret) {\n\t\tufshcd_print_host_state(hba);\n\t\tufshcd_print_pwr_info(hba);\n\t\tufshcd_print_host_regs(hba);\n\t}\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\thba->active_uic_cmd = NULL;\n\thba->uic_async_done = NULL;\n\tif (reenable_intr)\n\t\tufshcd_enable_intr(hba, UIC_COMMAND_COMPL);\n\tif (ret) {\n\t\tufshcd_set_link_broken(hba);\n\t\tufshcd_schedule_eh_work(hba);\n\t}\nout_unlock:\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\tmutex_unlock(&hba->uic_cmd_mutex);\n\n\treturn ret;\n}\n\n/**\n * ufshcd_uic_change_pwr_mode - Perform the UIC power mode chage\n *\t\t\t\tusing DME_SET primitives.\n * @hba: per adapter instance\n * @mode: powr mode value\n *\n * Returns 0 on success, non-zero value on failure\n */\nstatic int ufshcd_uic_change_pwr_mode(struct ufs_hba *hba, u8 mode)\n{\n\tstruct uic_command uic_cmd = {0};\n\tint ret;\n\n\tif (hba->quirks & UFSHCD_QUIRK_BROKEN_PA_RXHSUNTERMCAP) {\n\t\tret = ufshcd_dme_set(hba,\n\t\t\t\tUIC_ARG_MIB_SEL(PA_RXHSUNTERMCAP, 0), 1);\n\t\tif (ret) {\n\t\t\tdev_err(hba->dev, \"%s: failed to enable PA_RXHSUNTERMCAP ret %d\\n\",\n\t\t\t\t\t\t__func__, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tuic_cmd.command = UIC_CMD_DME_SET;\n\tuic_cmd.argument1 = UIC_ARG_MIB(PA_PWRMODE);\n\tuic_cmd.argument3 = mode;\n\tufshcd_hold(hba, false);\n\tret = ufshcd_uic_pwr_ctrl(hba, &uic_cmd);\n\tufshcd_release(hba);\n\nout:\n\treturn ret;\n}\n\nint ufshcd_link_recovery(struct ufs_hba *hba)\n{\n\tint ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\thba->ufshcd_state = UFSHCD_STATE_RESET;\n\tufshcd_set_eh_in_progress(hba);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\t/* Reset the attached device */\n\tufshcd_vops_device_reset(hba);\n\n\tret = ufshcd_host_reset_and_restore(hba);\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tif (ret)\n\t\thba->ufshcd_state = UFSHCD_STATE_ERROR;\n\tufshcd_clear_eh_in_progress(hba);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\tif (ret)\n\t\tdev_err(hba->dev, \"%s: link recovery failed, err %d\",\n\t\t\t__func__, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ufshcd_link_recovery);\n\nstatic int ufshcd_uic_hibern8_enter(struct ufs_hba *hba)\n{\n\tint ret;\n\tstruct uic_command uic_cmd = {0};\n\tktime_t start = ktime_get();\n\n\tufshcd_vops_hibern8_notify(hba, UIC_CMD_DME_HIBER_ENTER, PRE_CHANGE);\n\n\tuic_cmd.command = UIC_CMD_DME_HIBER_ENTER;\n\tret = ufshcd_uic_pwr_ctrl(hba, &uic_cmd);\n\ttrace_ufshcd_profile_hibern8(dev_name(hba->dev), \"enter\",\n\t\t\t     ktime_to_us(ktime_sub(ktime_get(), start)), ret);\n\n\tif (ret)\n\t\tdev_err(hba->dev, \"%s: hibern8 enter failed. ret = %d\\n\",\n\t\t\t__func__, ret);\n\telse\n\t\tufshcd_vops_hibern8_notify(hba, UIC_CMD_DME_HIBER_ENTER,\n\t\t\t\t\t\t\t\tPOST_CHANGE);\n\n\treturn ret;\n}\n\nint ufshcd_uic_hibern8_exit(struct ufs_hba *hba)\n{\n\tstruct uic_command uic_cmd = {0};\n\tint ret;\n\tktime_t start = ktime_get();\n\n\tufshcd_vops_hibern8_notify(hba, UIC_CMD_DME_HIBER_EXIT, PRE_CHANGE);\n\n\tuic_cmd.command = UIC_CMD_DME_HIBER_EXIT;\n\tret = ufshcd_uic_pwr_ctrl(hba, &uic_cmd);\n\ttrace_ufshcd_profile_hibern8(dev_name(hba->dev), \"exit\",\n\t\t\t     ktime_to_us(ktime_sub(ktime_get(), start)), ret);\n\n\tif (ret) {\n\t\tdev_err(hba->dev, \"%s: hibern8 exit failed. ret = %d\\n\",\n\t\t\t__func__, ret);\n\t} else {\n\t\tufshcd_vops_hibern8_notify(hba, UIC_CMD_DME_HIBER_EXIT,\n\t\t\t\t\t\t\t\tPOST_CHANGE);\n\t\thba->ufs_stats.last_hibern8_exit_tstamp = ktime_get();\n\t\thba->ufs_stats.hibern8_exit_cnt++;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ufshcd_uic_hibern8_exit);\n\nvoid ufshcd_auto_hibern8_update(struct ufs_hba *hba, u32 ahit)\n{\n\tunsigned long flags;\n\tbool update = false;\n\n\tif (!ufshcd_is_auto_hibern8_supported(hba))\n\t\treturn;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tif (hba->ahit != ahit) {\n\t\thba->ahit = ahit;\n\t\tupdate = true;\n\t}\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\tif (update && !pm_runtime_suspended(hba->dev)) {\n\t\tpm_runtime_get_sync(hba->dev);\n\t\tufshcd_hold(hba, false);\n\t\tufshcd_auto_hibern8_enable(hba);\n\t\tufshcd_release(hba);\n\t\tpm_runtime_put(hba->dev);\n\t}\n}\nEXPORT_SYMBOL_GPL(ufshcd_auto_hibern8_update);\n\nvoid ufshcd_auto_hibern8_enable(struct ufs_hba *hba)\n{\n\tunsigned long flags;\n\n\tif (!ufshcd_is_auto_hibern8_supported(hba))\n\t\treturn;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tufshcd_writel(hba, hba->ahit, REG_AUTO_HIBERNATE_IDLE_TIMER);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n}\n\n /**\n * ufshcd_init_pwr_info - setting the POR (power on reset)\n * values in hba power info\n * @hba: per-adapter instance\n */\nstatic void ufshcd_init_pwr_info(struct ufs_hba *hba)\n{\n\thba->pwr_info.gear_rx = UFS_PWM_G1;\n\thba->pwr_info.gear_tx = UFS_PWM_G1;\n\thba->pwr_info.lane_rx = 1;\n\thba->pwr_info.lane_tx = 1;\n\thba->pwr_info.pwr_rx = SLOWAUTO_MODE;\n\thba->pwr_info.pwr_tx = SLOWAUTO_MODE;\n\thba->pwr_info.hs_rate = 0;\n}\n\n/**\n * ufshcd_get_max_pwr_mode - reads the max power mode negotiated with device\n * @hba: per-adapter instance\n */\nstatic int ufshcd_get_max_pwr_mode(struct ufs_hba *hba)\n{\n\tstruct ufs_pa_layer_attr *pwr_info = &hba->max_pwr_info.info;\n\n\tif (hba->max_pwr_info.is_valid)\n\t\treturn 0;\n\n\tpwr_info->pwr_tx = FAST_MODE;\n\tpwr_info->pwr_rx = FAST_MODE;\n\tpwr_info->hs_rate = PA_HS_MODE_B;\n\n\t/* Get the connected lane count */\n\tufshcd_dme_get(hba, UIC_ARG_MIB(PA_CONNECTEDRXDATALANES),\n\t\t\t&pwr_info->lane_rx);\n\tufshcd_dme_get(hba, UIC_ARG_MIB(PA_CONNECTEDTXDATALANES),\n\t\t\t&pwr_info->lane_tx);\n\n\tif (!pwr_info->lane_rx || !pwr_info->lane_tx) {\n\t\tdev_err(hba->dev, \"%s: invalid connected lanes value. rx=%d, tx=%d\\n\",\n\t\t\t\t__func__,\n\t\t\t\tpwr_info->lane_rx,\n\t\t\t\tpwr_info->lane_tx);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * First, get the maximum gears of HS speed.\n\t * If a zero value, it means there is no HSGEAR capability.\n\t * Then, get the maximum gears of PWM speed.\n\t */\n\tufshcd_dme_get(hba, UIC_ARG_MIB(PA_MAXRXHSGEAR), &pwr_info->gear_rx);\n\tif (!pwr_info->gear_rx) {\n\t\tufshcd_dme_get(hba, UIC_ARG_MIB(PA_MAXRXPWMGEAR),\n\t\t\t\t&pwr_info->gear_rx);\n\t\tif (!pwr_info->gear_rx) {\n\t\t\tdev_err(hba->dev, \"%s: invalid max pwm rx gear read = %d\\n\",\n\t\t\t\t__func__, pwr_info->gear_rx);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpwr_info->pwr_rx = SLOW_MODE;\n\t}\n\n\tufshcd_dme_peer_get(hba, UIC_ARG_MIB(PA_MAXRXHSGEAR),\n\t\t\t&pwr_info->gear_tx);\n\tif (!pwr_info->gear_tx) {\n\t\tufshcd_dme_peer_get(hba, UIC_ARG_MIB(PA_MAXRXPWMGEAR),\n\t\t\t\t&pwr_info->gear_tx);\n\t\tif (!pwr_info->gear_tx) {\n\t\t\tdev_err(hba->dev, \"%s: invalid max pwm tx gear read = %d\\n\",\n\t\t\t\t__func__, pwr_info->gear_tx);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpwr_info->pwr_tx = SLOW_MODE;\n\t}\n\n\thba->max_pwr_info.is_valid = true;\n\treturn 0;\n}\n\nstatic int ufshcd_change_power_mode(struct ufs_hba *hba,\n\t\t\t     struct ufs_pa_layer_attr *pwr_mode)\n{\n\tint ret;\n\n\t/* if already configured to the requested pwr_mode */\n\tif (!hba->force_pmc &&\n\t    pwr_mode->gear_rx == hba->pwr_info.gear_rx &&\n\t    pwr_mode->gear_tx == hba->pwr_info.gear_tx &&\n\t    pwr_mode->lane_rx == hba->pwr_info.lane_rx &&\n\t    pwr_mode->lane_tx == hba->pwr_info.lane_tx &&\n\t    pwr_mode->pwr_rx == hba->pwr_info.pwr_rx &&\n\t    pwr_mode->pwr_tx == hba->pwr_info.pwr_tx &&\n\t    pwr_mode->hs_rate == hba->pwr_info.hs_rate) {\n\t\tdev_dbg(hba->dev, \"%s: power already configured\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Configure attributes for power mode change with below.\n\t * - PA_RXGEAR, PA_ACTIVERXDATALANES, PA_RXTERMINATION,\n\t * - PA_TXGEAR, PA_ACTIVETXDATALANES, PA_TXTERMINATION,\n\t * - PA_HSSERIES\n\t */\n\tufshcd_dme_set(hba, UIC_ARG_MIB(PA_RXGEAR), pwr_mode->gear_rx);\n\tufshcd_dme_set(hba, UIC_ARG_MIB(PA_ACTIVERXDATALANES),\n\t\t\tpwr_mode->lane_rx);\n\tif (pwr_mode->pwr_rx == FASTAUTO_MODE ||\n\t\t\tpwr_mode->pwr_rx == FAST_MODE)\n\t\tufshcd_dme_set(hba, UIC_ARG_MIB(PA_RXTERMINATION), TRUE);\n\telse\n\t\tufshcd_dme_set(hba, UIC_ARG_MIB(PA_RXTERMINATION), FALSE);\n\n\tufshcd_dme_set(hba, UIC_ARG_MIB(PA_TXGEAR), pwr_mode->gear_tx);\n\tufshcd_dme_set(hba, UIC_ARG_MIB(PA_ACTIVETXDATALANES),\n\t\t\tpwr_mode->lane_tx);\n\tif (pwr_mode->pwr_tx == FASTAUTO_MODE ||\n\t\t\tpwr_mode->pwr_tx == FAST_MODE)\n\t\tufshcd_dme_set(hba, UIC_ARG_MIB(PA_TXTERMINATION), TRUE);\n\telse\n\t\tufshcd_dme_set(hba, UIC_ARG_MIB(PA_TXTERMINATION), FALSE);\n\n\tif (pwr_mode->pwr_rx == FASTAUTO_MODE ||\n\t    pwr_mode->pwr_tx == FASTAUTO_MODE ||\n\t    pwr_mode->pwr_rx == FAST_MODE ||\n\t    pwr_mode->pwr_tx == FAST_MODE)\n\t\tufshcd_dme_set(hba, UIC_ARG_MIB(PA_HSSERIES),\n\t\t\t\t\t\tpwr_mode->hs_rate);\n\n\tufshcd_dme_set(hba, UIC_ARG_MIB(PA_PWRMODEUSERDATA0),\n\t\t\tDL_FC0ProtectionTimeOutVal_Default);\n\tufshcd_dme_set(hba, UIC_ARG_MIB(PA_PWRMODEUSERDATA1),\n\t\t\tDL_TC0ReplayTimeOutVal_Default);\n\tufshcd_dme_set(hba, UIC_ARG_MIB(PA_PWRMODEUSERDATA2),\n\t\t\tDL_AFC0ReqTimeOutVal_Default);\n\tufshcd_dme_set(hba, UIC_ARG_MIB(PA_PWRMODEUSERDATA3),\n\t\t\tDL_FC1ProtectionTimeOutVal_Default);\n\tufshcd_dme_set(hba, UIC_ARG_MIB(PA_PWRMODEUSERDATA4),\n\t\t\tDL_TC1ReplayTimeOutVal_Default);\n\tufshcd_dme_set(hba, UIC_ARG_MIB(PA_PWRMODEUSERDATA5),\n\t\t\tDL_AFC1ReqTimeOutVal_Default);\n\n\tufshcd_dme_set(hba, UIC_ARG_MIB(DME_LocalFC0ProtectionTimeOutVal),\n\t\t\tDL_FC0ProtectionTimeOutVal_Default);\n\tufshcd_dme_set(hba, UIC_ARG_MIB(DME_LocalTC0ReplayTimeOutVal),\n\t\t\tDL_TC0ReplayTimeOutVal_Default);\n\tufshcd_dme_set(hba, UIC_ARG_MIB(DME_LocalAFC0ReqTimeOutVal),\n\t\t\tDL_AFC0ReqTimeOutVal_Default);\n\n\tret = ufshcd_uic_change_pwr_mode(hba, pwr_mode->pwr_rx << 4\n\t\t\t| pwr_mode->pwr_tx);\n\n\tif (ret) {\n\t\tdev_err(hba->dev,\n\t\t\t\"%s: power mode change failed %d\\n\", __func__, ret);\n\t} else {\n\t\tufshcd_vops_pwr_change_notify(hba, POST_CHANGE, NULL,\n\t\t\t\t\t\t\t\tpwr_mode);\n\n\t\tmemcpy(&hba->pwr_info, pwr_mode,\n\t\t\tsizeof(struct ufs_pa_layer_attr));\n\t}\n\n\treturn ret;\n}\n\n/**\n * ufshcd_config_pwr_mode - configure a new power mode\n * @hba: per-adapter instance\n * @desired_pwr_mode: desired power configuration\n */\nint ufshcd_config_pwr_mode(struct ufs_hba *hba,\n\t\tstruct ufs_pa_layer_attr *desired_pwr_mode)\n{\n\tstruct ufs_pa_layer_attr final_params = { 0 };\n\tint ret;\n\n\tret = ufshcd_vops_pwr_change_notify(hba, PRE_CHANGE,\n\t\t\t\t\tdesired_pwr_mode, &final_params);\n\n\tif (ret)\n\t\tmemcpy(&final_params, desired_pwr_mode, sizeof(final_params));\n\n\tret = ufshcd_change_power_mode(hba, &final_params);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ufshcd_config_pwr_mode);\n\n/**\n * ufshcd_complete_dev_init() - checks device readiness\n * @hba: per-adapter instance\n *\n * Set fDeviceInit flag and poll until device toggles it.\n */\nstatic int ufshcd_complete_dev_init(struct ufs_hba *hba)\n{\n\tint err;\n\tbool flag_res = true;\n\tktime_t timeout;\n\n\terr = ufshcd_query_flag_retry(hba, UPIU_QUERY_OPCODE_SET_FLAG,\n\t\tQUERY_FLAG_IDN_FDEVICEINIT, 0, NULL);\n\tif (err) {\n\t\tdev_err(hba->dev,\n\t\t\t\"%s setting fDeviceInit flag failed with error %d\\n\",\n\t\t\t__func__, err);\n\t\tgoto out;\n\t}\n\n\t/* Poll fDeviceInit flag to be cleared */\n\ttimeout = ktime_add_ms(ktime_get(), FDEVICEINIT_COMPL_TIMEOUT);\n\tdo {\n\t\terr = ufshcd_query_flag(hba, UPIU_QUERY_OPCODE_READ_FLAG,\n\t\t\t\t\tQUERY_FLAG_IDN_FDEVICEINIT, 0, &flag_res);\n\t\tif (!flag_res)\n\t\t\tbreak;\n\t\tusleep_range(5000, 10000);\n\t} while (ktime_before(ktime_get(), timeout));\n\n\tif (err) {\n\t\tdev_err(hba->dev,\n\t\t\t\t\"%s reading fDeviceInit flag failed with error %d\\n\",\n\t\t\t\t__func__, err);\n\t} else if (flag_res) {\n\t\tdev_err(hba->dev,\n\t\t\t\t\"%s fDeviceInit was not cleared by the device\\n\",\n\t\t\t\t__func__);\n\t\terr = -EBUSY;\n\t}\nout:\n\treturn err;\n}\n\n/**\n * ufshcd_make_hba_operational - Make UFS controller operational\n * @hba: per adapter instance\n *\n * To bring UFS host controller to operational state,\n * 1. Enable required interrupts\n * 2. Configure interrupt aggregation\n * 3. Program UTRL and UTMRL base address\n * 4. Configure run-stop-registers\n *\n * Returns 0 on success, non-zero value on failure\n */\nint ufshcd_make_hba_operational(struct ufs_hba *hba)\n{\n\tint err = 0;\n\tu32 reg;\n\n\t/* Enable required interrupts */\n\tufshcd_enable_intr(hba, UFSHCD_ENABLE_INTRS);\n\n\t/* Configure interrupt aggregation */\n\tif (ufshcd_is_intr_aggr_allowed(hba))\n\t\tufshcd_config_intr_aggr(hba, hba->nutrs - 1, INT_AGGR_DEF_TO);\n\telse\n\t\tufshcd_disable_intr_aggr(hba);\n\n\t/* Configure UTRL and UTMRL base address registers */\n\tufshcd_writel(hba, lower_32_bits(hba->utrdl_dma_addr),\n\t\t\tREG_UTP_TRANSFER_REQ_LIST_BASE_L);\n\tufshcd_writel(hba, upper_32_bits(hba->utrdl_dma_addr),\n\t\t\tREG_UTP_TRANSFER_REQ_LIST_BASE_H);\n\tufshcd_writel(hba, lower_32_bits(hba->utmrdl_dma_addr),\n\t\t\tREG_UTP_TASK_REQ_LIST_BASE_L);\n\tufshcd_writel(hba, upper_32_bits(hba->utmrdl_dma_addr),\n\t\t\tREG_UTP_TASK_REQ_LIST_BASE_H);\n\n\t/*\n\t * Make sure base address and interrupt setup are updated before\n\t * enabling the run/stop registers below.\n\t */\n\twmb();\n\n\t/*\n\t * UCRDY, UTMRLDY and UTRLRDY bits must be 1\n\t */\n\treg = ufshcd_readl(hba, REG_CONTROLLER_STATUS);\n\tif (!(ufshcd_get_lists_status(reg))) {\n\t\tufshcd_enable_run_stop_reg(hba);\n\t} else {\n\t\tdev_err(hba->dev,\n\t\t\t\"Host controller not ready to process requests\");\n\t\terr = -EIO;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ufshcd_make_hba_operational);\n\n/**\n * ufshcd_hba_stop - Send controller to reset state\n * @hba: per adapter instance\n */\nstatic inline void ufshcd_hba_stop(struct ufs_hba *hba)\n{\n\tunsigned long flags;\n\tint err;\n\n\t/*\n\t * Obtain the host lock to prevent that the controller is disabled\n\t * while the UFS interrupt handler is active on another CPU.\n\t */\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tufshcd_writel(hba, CONTROLLER_DISABLE,  REG_CONTROLLER_ENABLE);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\terr = ufshcd_wait_for_register(hba, REG_CONTROLLER_ENABLE,\n\t\t\t\t\tCONTROLLER_ENABLE, CONTROLLER_DISABLE,\n\t\t\t\t\t10, 1);\n\tif (err)\n\t\tdev_err(hba->dev, \"%s: Controller disable failed\\n\", __func__);\n}\n\n/**\n * ufshcd_hba_execute_hce - initialize the controller\n * @hba: per adapter instance\n *\n * The controller resets itself and controller firmware initialization\n * sequence kicks off. When controller is ready it will set\n * the Host Controller Enable bit to 1.\n *\n * Returns 0 on success, non-zero value on failure\n */\nstatic int ufshcd_hba_execute_hce(struct ufs_hba *hba)\n{\n\tint retry_outer = 3;\n\tint retry_inner;\n\nstart:\n\tif (!ufshcd_is_hba_active(hba))\n\t\t/* change controller state to \"reset state\" */\n\t\tufshcd_hba_stop(hba);\n\n\t/* UniPro link is disabled at this point */\n\tufshcd_set_link_off(hba);\n\n\tufshcd_vops_hce_enable_notify(hba, PRE_CHANGE);\n\n\t/* start controller initialization sequence */\n\tufshcd_hba_start(hba);\n\n\t/*\n\t * To initialize a UFS host controller HCE bit must be set to 1.\n\t * During initialization the HCE bit value changes from 1->0->1.\n\t * When the host controller completes initialization sequence\n\t * it sets the value of HCE bit to 1. The same HCE bit is read back\n\t * to check if the controller has completed initialization sequence.\n\t * So without this delay the value HCE = 1, set in the previous\n\t * instruction might be read back.\n\t * This delay can be changed based on the controller.\n\t */\n\tufshcd_delay_us(hba->vps->hba_enable_delay_us, 100);\n\n\t/* wait for the host controller to complete initialization */\n\tretry_inner = 50;\n\twhile (ufshcd_is_hba_active(hba)) {\n\t\tif (retry_inner) {\n\t\t\tretry_inner--;\n\t\t} else {\n\t\t\tdev_err(hba->dev,\n\t\t\t\t\"Controller enable failed\\n\");\n\t\t\tif (retry_outer) {\n\t\t\t\tretry_outer--;\n\t\t\t\tgoto start;\n\t\t\t}\n\t\t\treturn -EIO;\n\t\t}\n\t\tusleep_range(1000, 1100);\n\t}\n\n\t/* enable UIC related interrupts */\n\tufshcd_enable_intr(hba, UFSHCD_UIC_MASK);\n\n\tufshcd_vops_hce_enable_notify(hba, POST_CHANGE);\n\n\treturn 0;\n}\n\nint ufshcd_hba_enable(struct ufs_hba *hba)\n{\n\tint ret;\n\n\tif (hba->quirks & UFSHCI_QUIRK_BROKEN_HCE) {\n\t\tufshcd_set_link_off(hba);\n\t\tufshcd_vops_hce_enable_notify(hba, PRE_CHANGE);\n\n\t\t/* enable UIC related interrupts */\n\t\tufshcd_enable_intr(hba, UFSHCD_UIC_MASK);\n\t\tret = ufshcd_dme_reset(hba);\n\t\tif (!ret) {\n\t\t\tret = ufshcd_dme_enable(hba);\n\t\t\tif (!ret)\n\t\t\t\tufshcd_vops_hce_enable_notify(hba, POST_CHANGE);\n\t\t\tif (ret)\n\t\t\t\tdev_err(hba->dev,\n\t\t\t\t\t\"Host controller enable failed with non-hce\\n\");\n\t\t}\n\t} else {\n\t\tret = ufshcd_hba_execute_hce(hba);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ufshcd_hba_enable);\n\nstatic int ufshcd_disable_tx_lcc(struct ufs_hba *hba, bool peer)\n{\n\tint tx_lanes = 0, i, err = 0;\n\n\tif (!peer)\n\t\tufshcd_dme_get(hba, UIC_ARG_MIB(PA_CONNECTEDTXDATALANES),\n\t\t\t       &tx_lanes);\n\telse\n\t\tufshcd_dme_peer_get(hba, UIC_ARG_MIB(PA_CONNECTEDTXDATALANES),\n\t\t\t\t    &tx_lanes);\n\tfor (i = 0; i < tx_lanes; i++) {\n\t\tif (!peer)\n\t\t\terr = ufshcd_dme_set(hba,\n\t\t\t\tUIC_ARG_MIB_SEL(TX_LCC_ENABLE,\n\t\t\t\t\tUIC_ARG_MPHY_TX_GEN_SEL_INDEX(i)),\n\t\t\t\t\t0);\n\t\telse\n\t\t\terr = ufshcd_dme_peer_set(hba,\n\t\t\t\tUIC_ARG_MIB_SEL(TX_LCC_ENABLE,\n\t\t\t\t\tUIC_ARG_MPHY_TX_GEN_SEL_INDEX(i)),\n\t\t\t\t\t0);\n\t\tif (err) {\n\t\t\tdev_err(hba->dev, \"%s: TX LCC Disable failed, peer = %d, lane = %d, err = %d\",\n\t\t\t\t__func__, peer, i, err);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic inline int ufshcd_disable_device_tx_lcc(struct ufs_hba *hba)\n{\n\treturn ufshcd_disable_tx_lcc(hba, true);\n}\n\nvoid ufshcd_update_reg_hist(struct ufs_err_reg_hist *reg_hist,\n\t\t\t    u32 reg)\n{\n\treg_hist->reg[reg_hist->pos] = reg;\n\treg_hist->tstamp[reg_hist->pos] = ktime_get();\n\treg_hist->pos = (reg_hist->pos + 1) % UFS_ERR_REG_HIST_LENGTH;\n}\nEXPORT_SYMBOL_GPL(ufshcd_update_reg_hist);\n\n/**\n * ufshcd_link_startup - Initialize unipro link startup\n * @hba: per adapter instance\n *\n * Returns 0 for success, non-zero in case of failure\n */\nstatic int ufshcd_link_startup(struct ufs_hba *hba)\n{\n\tint ret;\n\tint retries = DME_LINKSTARTUP_RETRIES;\n\tbool link_startup_again = false;\n\n\t/*\n\t * If UFS device isn't active then we will have to issue link startup\n\t * 2 times to make sure the device state move to active.\n\t */\n\tif (!ufshcd_is_ufs_dev_active(hba))\n\t\tlink_startup_again = true;\n\nlink_startup:\n\tdo {\n\t\tufshcd_vops_link_startup_notify(hba, PRE_CHANGE);\n\n\t\tret = ufshcd_dme_link_startup(hba);\n\n\t\t/* check if device is detected by inter-connect layer */\n\t\tif (!ret && !ufshcd_is_device_present(hba)) {\n\t\t\tufshcd_update_reg_hist(&hba->ufs_stats.link_startup_err,\n\t\t\t\t\t       0);\n\t\t\tdev_err(hba->dev, \"%s: Device not present\\n\", __func__);\n\t\t\tret = -ENXIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * DME link lost indication is only received when link is up,\n\t\t * but we can't be sure if the link is up until link startup\n\t\t * succeeds. So reset the local Uni-Pro and try again.\n\t\t */\n\t\tif (ret && ufshcd_hba_enable(hba)) {\n\t\t\tufshcd_update_reg_hist(&hba->ufs_stats.link_startup_err,\n\t\t\t\t\t       (u32)ret);\n\t\t\tgoto out;\n\t\t}\n\t} while (ret && retries--);\n\n\tif (ret) {\n\t\t/* failed to get the link up... retire */\n\t\tufshcd_update_reg_hist(&hba->ufs_stats.link_startup_err,\n\t\t\t\t       (u32)ret);\n\t\tgoto out;\n\t}\n\n\tif (link_startup_again) {\n\t\tlink_startup_again = false;\n\t\tretries = DME_LINKSTARTUP_RETRIES;\n\t\tgoto link_startup;\n\t}\n\n\t/* Mark that link is up in PWM-G1, 1-lane, SLOW-AUTO mode */\n\tufshcd_init_pwr_info(hba);\n\tufshcd_print_pwr_info(hba);\n\n\tif (hba->quirks & UFSHCD_QUIRK_BROKEN_LCC) {\n\t\tret = ufshcd_disable_device_tx_lcc(hba);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/* Include any host controller configuration via UIC commands */\n\tret = ufshcd_vops_link_startup_notify(hba, POST_CHANGE);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Clear UECPA once due to LINERESET has happened during LINK_STARTUP */\n\tufshcd_readl(hba, REG_UIC_ERROR_CODE_PHY_ADAPTER_LAYER);\n\tret = ufshcd_make_hba_operational(hba);\nout:\n\tif (ret) {\n\t\tdev_err(hba->dev, \"link startup failed %d\\n\", ret);\n\t\tufshcd_print_host_state(hba);\n\t\tufshcd_print_pwr_info(hba);\n\t\tufshcd_print_host_regs(hba);\n\t}\n\treturn ret;\n}\n\n/**\n * ufshcd_verify_dev_init() - Verify device initialization\n * @hba: per-adapter instance\n *\n * Send NOP OUT UPIU and wait for NOP IN response to check whether the\n * device Transport Protocol (UTP) layer is ready after a reset.\n * If the UTP layer at the device side is not initialized, it may\n * not respond with NOP IN UPIU within timeout of %NOP_OUT_TIMEOUT\n * and we retry sending NOP OUT for %NOP_OUT_RETRIES iterations.\n */\nstatic int ufshcd_verify_dev_init(struct ufs_hba *hba)\n{\n\tint err = 0;\n\tint retries;\n\n\tufshcd_hold(hba, false);\n\tmutex_lock(&hba->dev_cmd.lock);\n\tfor (retries = NOP_OUT_RETRIES; retries > 0; retries--) {\n\t\terr = ufshcd_exec_dev_cmd(hba, DEV_CMD_TYPE_NOP,\n\t\t\t\t\t       NOP_OUT_TIMEOUT);\n\n\t\tif (!err || err == -ETIMEDOUT)\n\t\t\tbreak;\n\n\t\tdev_dbg(hba->dev, \"%s: error %d retrying\\n\", __func__, err);\n\t}\n\tmutex_unlock(&hba->dev_cmd.lock);\n\tufshcd_release(hba);\n\n\tif (err)\n\t\tdev_err(hba->dev, \"%s: NOP OUT failed %d\\n\", __func__, err);\n\treturn err;\n}\n\n/**\n * ufshcd_set_queue_depth - set lun queue depth\n * @sdev: pointer to SCSI device\n *\n * Read bLUQueueDepth value and activate scsi tagged command\n * queueing. For WLUN, queue depth is set to 1. For best-effort\n * cases (bLUQueueDepth = 0) the queue depth is set to a maximum\n * value that host can queue.\n */\nstatic void ufshcd_set_queue_depth(struct scsi_device *sdev)\n{\n\tint ret = 0;\n\tu8 lun_qdepth;\n\tstruct ufs_hba *hba;\n\n\thba = shost_priv(sdev->host);\n\n\tlun_qdepth = hba->nutrs;\n\tret = ufshcd_read_unit_desc_param(hba,\n\t\t\t\t\t  ufshcd_scsi_to_upiu_lun(sdev->lun),\n\t\t\t\t\t  UNIT_DESC_PARAM_LU_Q_DEPTH,\n\t\t\t\t\t  &lun_qdepth,\n\t\t\t\t\t  sizeof(lun_qdepth));\n\n\t/* Some WLUN doesn't support unit descriptor */\n\tif (ret == -EOPNOTSUPP)\n\t\tlun_qdepth = 1;\n\telse if (!lun_qdepth)\n\t\t/* eventually, we can figure out the real queue depth */\n\t\tlun_qdepth = hba->nutrs;\n\telse\n\t\tlun_qdepth = min_t(int, lun_qdepth, hba->nutrs);\n\n\tdev_dbg(hba->dev, \"%s: activate tcq with queue depth %d\\n\",\n\t\t\t__func__, lun_qdepth);\n\tscsi_change_queue_depth(sdev, lun_qdepth);\n}\n\n/*\n * ufshcd_get_lu_wp - returns the \"b_lu_write_protect\" from UNIT DESCRIPTOR\n * @hba: per-adapter instance\n * @lun: UFS device lun id\n * @b_lu_write_protect: pointer to buffer to hold the LU's write protect info\n *\n * Returns 0 in case of success and b_lu_write_protect status would be returned\n * @b_lu_write_protect parameter.\n * Returns -ENOTSUPP if reading b_lu_write_protect is not supported.\n * Returns -EINVAL in case of invalid parameters passed to this function.\n */\nstatic int ufshcd_get_lu_wp(struct ufs_hba *hba,\n\t\t\t    u8 lun,\n\t\t\t    u8 *b_lu_write_protect)\n{\n\tint ret;\n\n\tif (!b_lu_write_protect)\n\t\tret = -EINVAL;\n\t/*\n\t * According to UFS device spec, RPMB LU can't be write\n\t * protected so skip reading bLUWriteProtect parameter for\n\t * it. For other W-LUs, UNIT DESCRIPTOR is not available.\n\t */\n\telse if (lun >= hba->dev_info.max_lu_supported)\n\t\tret = -ENOTSUPP;\n\telse\n\t\tret = ufshcd_read_unit_desc_param(hba,\n\t\t\t\t\t  lun,\n\t\t\t\t\t  UNIT_DESC_PARAM_LU_WR_PROTECT,\n\t\t\t\t\t  b_lu_write_protect,\n\t\t\t\t\t  sizeof(*b_lu_write_protect));\n\treturn ret;\n}\n\n/**\n * ufshcd_get_lu_power_on_wp_status - get LU's power on write protect\n * status\n * @hba: per-adapter instance\n * @sdev: pointer to SCSI device\n *\n */\nstatic inline void ufshcd_get_lu_power_on_wp_status(struct ufs_hba *hba,\n\t\t\t\t\t\t    struct scsi_device *sdev)\n{\n\tif (hba->dev_info.f_power_on_wp_en &&\n\t    !hba->dev_info.is_lu_power_on_wp) {\n\t\tu8 b_lu_write_protect;\n\n\t\tif (!ufshcd_get_lu_wp(hba, ufshcd_scsi_to_upiu_lun(sdev->lun),\n\t\t\t\t      &b_lu_write_protect) &&\n\t\t    (b_lu_write_protect == UFS_LU_POWER_ON_WP))\n\t\t\thba->dev_info.is_lu_power_on_wp = true;\n\t}\n}\n\n/**\n * ufshcd_slave_alloc - handle initial SCSI device configurations\n * @sdev: pointer to SCSI device\n *\n * Returns success\n */\nstatic int ufshcd_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct ufs_hba *hba;\n\n\thba = shost_priv(sdev->host);\n\n\t/* Mode sense(6) is not supported by UFS, so use Mode sense(10) */\n\tsdev->use_10_for_ms = 1;\n\n\t/* DBD field should be set to 1 in mode sense(10) */\n\tsdev->set_dbd_for_ms = 1;\n\n\t/* allow SCSI layer to restart the device in case of errors */\n\tsdev->allow_restart = 1;\n\n\t/* REPORT SUPPORTED OPERATION CODES is not supported */\n\tsdev->no_report_opcodes = 1;\n\n\t/* WRITE_SAME command is not supported */\n\tsdev->no_write_same = 1;\n\n\tufshcd_set_queue_depth(sdev);\n\n\tufshcd_get_lu_power_on_wp_status(hba, sdev);\n\n\treturn 0;\n}\n\n/**\n * ufshcd_change_queue_depth - change queue depth\n * @sdev: pointer to SCSI device\n * @depth: required depth to set\n *\n * Change queue depth and make sure the max. limits are not crossed.\n */\nstatic int ufshcd_change_queue_depth(struct scsi_device *sdev, int depth)\n{\n\tstruct ufs_hba *hba = shost_priv(sdev->host);\n\n\tif (depth > hba->nutrs)\n\t\tdepth = hba->nutrs;\n\treturn scsi_change_queue_depth(sdev, depth);\n}\n\n/**\n * ufshcd_slave_configure - adjust SCSI device configurations\n * @sdev: pointer to SCSI device\n */\nstatic int ufshcd_slave_configure(struct scsi_device *sdev)\n{\n\tstruct ufs_hba *hba = shost_priv(sdev->host);\n\tstruct request_queue *q = sdev->request_queue;\n\n\tblk_queue_update_dma_pad(q, PRDT_DATA_BYTE_COUNT_PAD - 1);\n\n\tif (ufshcd_is_rpm_autosuspend_allowed(hba))\n\t\tsdev->rpm_autosuspend = 1;\n\n\tufshcd_crypto_setup_rq_keyslot_manager(hba, q);\n\n\treturn 0;\n}\n\n/**\n * ufshcd_slave_destroy - remove SCSI device configurations\n * @sdev: pointer to SCSI device\n */\nstatic void ufshcd_slave_destroy(struct scsi_device *sdev)\n{\n\tstruct ufs_hba *hba;\n\n\thba = shost_priv(sdev->host);\n\t/* Drop the reference as it won't be needed anymore */\n\tif (ufshcd_scsi_to_upiu_lun(sdev->lun) == UFS_UPIU_UFS_DEVICE_WLUN) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t\thba->sdev_ufs_device = NULL;\n\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t}\n}\n\n/**\n * ufshcd_scsi_cmd_status - Update SCSI command result based on SCSI status\n * @lrbp: pointer to local reference block of completed command\n * @scsi_status: SCSI command status\n *\n * Returns value base on SCSI command status\n */\nstatic inline int\nufshcd_scsi_cmd_status(struct ufshcd_lrb *lrbp, int scsi_status)\n{\n\tint result = 0;\n\n\tswitch (scsi_status) {\n\tcase SAM_STAT_CHECK_CONDITION:\n\t\tufshcd_copy_sense_data(lrbp);\n\t\tfallthrough;\n\tcase SAM_STAT_GOOD:\n\t\tresult |= DID_OK << 16 |\n\t\t\t  COMMAND_COMPLETE << 8 |\n\t\t\t  scsi_status;\n\t\tbreak;\n\tcase SAM_STAT_TASK_SET_FULL:\n\tcase SAM_STAT_BUSY:\n\tcase SAM_STAT_TASK_ABORTED:\n\t\tufshcd_copy_sense_data(lrbp);\n\t\tresult |= scsi_status;\n\t\tbreak;\n\tdefault:\n\t\tresult |= DID_ERROR << 16;\n\t\tbreak;\n\t} /* end of switch */\n\n\treturn result;\n}\n\n/**\n * ufshcd_transfer_rsp_status - Get overall status of the response\n * @hba: per adapter instance\n * @lrbp: pointer to local reference block of completed command\n *\n * Returns result of the command to notify SCSI midlayer\n */\nstatic inline int\nufshcd_transfer_rsp_status(struct ufs_hba *hba, struct ufshcd_lrb *lrbp)\n{\n\tint result = 0;\n\tint scsi_status;\n\tint ocs;\n\n\t/* overall command status of utrd */\n\tocs = ufshcd_get_tr_ocs(lrbp);\n\n\tif (hba->quirks & UFSHCD_QUIRK_BROKEN_OCS_FATAL_ERROR) {\n\t\tif (be32_to_cpu(lrbp->ucd_rsp_ptr->header.dword_1) &\n\t\t\t\t\tMASK_RSP_UPIU_RESULT)\n\t\t\tocs = OCS_SUCCESS;\n\t}\n\n\tswitch (ocs) {\n\tcase OCS_SUCCESS:\n\t\tresult = ufshcd_get_req_rsp(lrbp->ucd_rsp_ptr);\n\t\thba->ufs_stats.last_hibern8_exit_tstamp = ktime_set(0, 0);\n\t\tswitch (result) {\n\t\tcase UPIU_TRANSACTION_RESPONSE:\n\t\t\t/*\n\t\t\t * get the response UPIU result to extract\n\t\t\t * the SCSI command status\n\t\t\t */\n\t\t\tresult = ufshcd_get_rsp_upiu_result(lrbp->ucd_rsp_ptr);\n\n\t\t\t/*\n\t\t\t * get the result based on SCSI status response\n\t\t\t * to notify the SCSI midlayer of the command status\n\t\t\t */\n\t\t\tscsi_status = result & MASK_SCSI_STATUS;\n\t\t\tresult = ufshcd_scsi_cmd_status(lrbp, scsi_status);\n\n\t\t\t/*\n\t\t\t * Currently we are only supporting BKOPs exception\n\t\t\t * events hence we can ignore BKOPs exception event\n\t\t\t * during power management callbacks. BKOPs exception\n\t\t\t * event is not expected to be raised in runtime suspend\n\t\t\t * callback as it allows the urgent bkops.\n\t\t\t * During system suspend, we are anyway forcefully\n\t\t\t * disabling the bkops and if urgent bkops is needed\n\t\t\t * it will be enabled on system resume. Long term\n\t\t\t * solution could be to abort the system suspend if\n\t\t\t * UFS device needs urgent BKOPs.\n\t\t\t */\n\t\t\tif (!hba->pm_op_in_progress &&\n\t\t\t    ufshcd_is_exception_event(lrbp->ucd_rsp_ptr) &&\n\t\t\t    schedule_work(&hba->eeh_work)) {\n\t\t\t\t/*\n\t\t\t\t * Prevent suspend once eeh_work is scheduled\n\t\t\t\t * to avoid deadlock between ufshcd_suspend\n\t\t\t\t * and exception event handler.\n\t\t\t\t */\n\t\t\t\tpm_runtime_get_noresume(hba->dev);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UPIU_TRANSACTION_REJECT_UPIU:\n\t\t\t/* TODO: handle Reject UPIU Response */\n\t\t\tresult = DID_ERROR << 16;\n\t\t\tdev_err(hba->dev,\n\t\t\t\t\"Reject UPIU not fully implemented\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(hba->dev,\n\t\t\t\t\"Unexpected request response code = %x\\n\",\n\t\t\t\tresult);\n\t\t\tresult = DID_ERROR << 16;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase OCS_ABORTED:\n\t\tresult |= DID_ABORT << 16;\n\t\tbreak;\n\tcase OCS_INVALID_COMMAND_STATUS:\n\t\tresult |= DID_REQUEUE << 16;\n\t\tbreak;\n\tcase OCS_INVALID_CMD_TABLE_ATTR:\n\tcase OCS_INVALID_PRDT_ATTR:\n\tcase OCS_MISMATCH_DATA_BUF_SIZE:\n\tcase OCS_MISMATCH_RESP_UPIU_SIZE:\n\tcase OCS_PEER_COMM_FAILURE:\n\tcase OCS_FATAL_ERROR:\n\tcase OCS_DEVICE_FATAL_ERROR:\n\tcase OCS_INVALID_CRYPTO_CONFIG:\n\tcase OCS_GENERAL_CRYPTO_ERROR:\n\tdefault:\n\t\tresult |= DID_ERROR << 16;\n\t\tdev_err(hba->dev,\n\t\t\t\t\"OCS error from controller = %x for tag %d\\n\",\n\t\t\t\tocs, lrbp->task_tag);\n\t\tufshcd_print_host_regs(hba);\n\t\tufshcd_print_host_state(hba);\n\t\tbreak;\n\t} /* end of switch */\n\n\tif ((host_byte(result) != DID_OK) && !hba->silence_err_logs)\n\t\tufshcd_print_trs(hba, 1 << lrbp->task_tag, true);\n\treturn result;\n}\n\n/**\n * ufshcd_uic_cmd_compl - handle completion of uic command\n * @hba: per adapter instance\n * @intr_status: interrupt status generated by the controller\n *\n * Returns\n *  IRQ_HANDLED - If interrupt is valid\n *  IRQ_NONE    - If invalid interrupt\n */\nstatic irqreturn_t ufshcd_uic_cmd_compl(struct ufs_hba *hba, u32 intr_status)\n{\n\tirqreturn_t retval = IRQ_NONE;\n\n\tif ((intr_status & UIC_COMMAND_COMPL) && hba->active_uic_cmd) {\n\t\thba->active_uic_cmd->argument2 |=\n\t\t\tufshcd_get_uic_cmd_result(hba);\n\t\thba->active_uic_cmd->argument3 =\n\t\t\tufshcd_get_dme_attr_val(hba);\n\t\tif (!hba->uic_async_done)\n\t\t\thba->active_uic_cmd->cmd_active = 0;\n\t\tcomplete(&hba->active_uic_cmd->done);\n\t\tretval = IRQ_HANDLED;\n\t}\n\n\tif ((intr_status & UFSHCD_UIC_PWR_MASK) && hba->uic_async_done) {\n\t\thba->active_uic_cmd->cmd_active = 0;\n\t\tcomplete(hba->uic_async_done);\n\t\tretval = IRQ_HANDLED;\n\t}\n\n\tif (retval == IRQ_HANDLED)\n\t\tufshcd_add_uic_command_trace(hba, hba->active_uic_cmd,\n\t\t\t\t\t     \"complete\");\n\treturn retval;\n}\n\n/**\n * __ufshcd_transfer_req_compl - handle SCSI and query command completion\n * @hba: per adapter instance\n * @completed_reqs: requests to complete\n */\nstatic void __ufshcd_transfer_req_compl(struct ufs_hba *hba,\n\t\t\t\t\tunsigned long completed_reqs)\n{\n\tstruct ufshcd_lrb *lrbp;\n\tstruct scsi_cmnd *cmd;\n\tint result;\n\tint index;\n\n\tfor_each_set_bit(index, &completed_reqs, hba->nutrs) {\n\t\tlrbp = &hba->lrb[index];\n\t\tlrbp->compl_time_stamp = ktime_get();\n\t\tcmd = lrbp->cmd;\n\t\tif (cmd) {\n\t\t\tufshcd_add_command_trace(hba, index, \"complete\");\n\t\t\tresult = ufshcd_transfer_rsp_status(hba, lrbp);\n\t\t\tscsi_dma_unmap(cmd);\n\t\t\tcmd->result = result;\n\t\t\t/* Mark completed command as NULL in LRB */\n\t\t\tlrbp->cmd = NULL;\n\t\t\t/* Do not touch lrbp after scsi done */\n\t\t\tcmd->scsi_done(cmd);\n\t\t\t__ufshcd_release(hba);\n\t\t} else if (lrbp->command_type == UTP_CMD_TYPE_DEV_MANAGE ||\n\t\t\tlrbp->command_type == UTP_CMD_TYPE_UFS_STORAGE) {\n\t\t\tif (hba->dev_cmd.complete) {\n\t\t\t\tufshcd_add_command_trace(hba, index,\n\t\t\t\t\t\t\"dev_complete\");\n\t\t\t\tcomplete(hba->dev_cmd.complete);\n\t\t\t}\n\t\t}\n\t\tif (ufshcd_is_clkscaling_supported(hba))\n\t\t\thba->clk_scaling.active_reqs--;\n\t}\n\n\t/* clear corresponding bits of completed commands */\n\thba->outstanding_reqs ^= completed_reqs;\n\n\tufshcd_clk_scaling_update_busy(hba);\n}\n\n/**\n * ufshcd_transfer_req_compl - handle SCSI and query command completion\n * @hba: per adapter instance\n *\n * Returns\n *  IRQ_HANDLED - If interrupt is valid\n *  IRQ_NONE    - If invalid interrupt\n */\nstatic irqreturn_t ufshcd_transfer_req_compl(struct ufs_hba *hba)\n{\n\tunsigned long completed_reqs;\n\tu32 tr_doorbell;\n\n\t/* Resetting interrupt aggregation counters first and reading the\n\t * DOOR_BELL afterward allows us to handle all the completed requests.\n\t * In order to prevent other interrupts starvation the DB is read once\n\t * after reset. The down side of this solution is the possibility of\n\t * false interrupt if device completes another request after resetting\n\t * aggregation and before reading the DB.\n\t */\n\tif (ufshcd_is_intr_aggr_allowed(hba) &&\n\t    !(hba->quirks & UFSHCI_QUIRK_SKIP_RESET_INTR_AGGR))\n\t\tufshcd_reset_intr_aggr(hba);\n\n\ttr_doorbell = ufshcd_readl(hba, REG_UTP_TRANSFER_REQ_DOOR_BELL);\n\tcompleted_reqs = tr_doorbell ^ hba->outstanding_reqs;\n\n\tif (completed_reqs) {\n\t\t__ufshcd_transfer_req_compl(hba, completed_reqs);\n\t\treturn IRQ_HANDLED;\n\t} else {\n\t\treturn IRQ_NONE;\n\t}\n}\n\n/**\n * ufshcd_disable_ee - disable exception event\n * @hba: per-adapter instance\n * @mask: exception event to disable\n *\n * Disables exception event in the device so that the EVENT_ALERT\n * bit is not set.\n *\n * Returns zero on success, non-zero error value on failure.\n */\nstatic int ufshcd_disable_ee(struct ufs_hba *hba, u16 mask)\n{\n\tint err = 0;\n\tu32 val;\n\n\tif (!(hba->ee_ctrl_mask & mask))\n\t\tgoto out;\n\n\tval = hba->ee_ctrl_mask & ~mask;\n\tval &= MASK_EE_STATUS;\n\terr = ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_WRITE_ATTR,\n\t\t\tQUERY_ATTR_IDN_EE_CONTROL, 0, 0, &val);\n\tif (!err)\n\t\thba->ee_ctrl_mask &= ~mask;\nout:\n\treturn err;\n}\n\n/**\n * ufshcd_enable_ee - enable exception event\n * @hba: per-adapter instance\n * @mask: exception event to enable\n *\n * Enable corresponding exception event in the device to allow\n * device to alert host in critical scenarios.\n *\n * Returns zero on success, non-zero error value on failure.\n */\nstatic int ufshcd_enable_ee(struct ufs_hba *hba, u16 mask)\n{\n\tint err = 0;\n\tu32 val;\n\n\tif (hba->ee_ctrl_mask & mask)\n\t\tgoto out;\n\n\tval = hba->ee_ctrl_mask | mask;\n\tval &= MASK_EE_STATUS;\n\terr = ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_WRITE_ATTR,\n\t\t\tQUERY_ATTR_IDN_EE_CONTROL, 0, 0, &val);\n\tif (!err)\n\t\thba->ee_ctrl_mask |= mask;\nout:\n\treturn err;\n}\n\n/**\n * ufshcd_enable_auto_bkops - Allow device managed BKOPS\n * @hba: per-adapter instance\n *\n * Allow device to manage background operations on its own. Enabling\n * this might lead to inconsistent latencies during normal data transfers\n * as the device is allowed to manage its own way of handling background\n * operations.\n *\n * Returns zero on success, non-zero on failure.\n */\nstatic int ufshcd_enable_auto_bkops(struct ufs_hba *hba)\n{\n\tint err = 0;\n\n\tif (hba->auto_bkops_enabled)\n\t\tgoto out;\n\n\terr = ufshcd_query_flag_retry(hba, UPIU_QUERY_OPCODE_SET_FLAG,\n\t\t\tQUERY_FLAG_IDN_BKOPS_EN, 0, NULL);\n\tif (err) {\n\t\tdev_err(hba->dev, \"%s: failed to enable bkops %d\\n\",\n\t\t\t\t__func__, err);\n\t\tgoto out;\n\t}\n\n\thba->auto_bkops_enabled = true;\n\ttrace_ufshcd_auto_bkops_state(dev_name(hba->dev), \"Enabled\");\n\n\t/* No need of URGENT_BKOPS exception from the device */\n\terr = ufshcd_disable_ee(hba, MASK_EE_URGENT_BKOPS);\n\tif (err)\n\t\tdev_err(hba->dev, \"%s: failed to disable exception event %d\\n\",\n\t\t\t\t__func__, err);\nout:\n\treturn err;\n}\n\n/**\n * ufshcd_disable_auto_bkops - block device in doing background operations\n * @hba: per-adapter instance\n *\n * Disabling background operations improves command response latency but\n * has drawback of device moving into critical state where the device is\n * not-operable. Make sure to call ufshcd_enable_auto_bkops() whenever the\n * host is idle so that BKOPS are managed effectively without any negative\n * impacts.\n *\n * Returns zero on success, non-zero on failure.\n */\nstatic int ufshcd_disable_auto_bkops(struct ufs_hba *hba)\n{\n\tint err = 0;\n\n\tif (!hba->auto_bkops_enabled)\n\t\tgoto out;\n\n\t/*\n\t * If host assisted BKOPs is to be enabled, make sure\n\t * urgent bkops exception is allowed.\n\t */\n\terr = ufshcd_enable_ee(hba, MASK_EE_URGENT_BKOPS);\n\tif (err) {\n\t\tdev_err(hba->dev, \"%s: failed to enable exception event %d\\n\",\n\t\t\t\t__func__, err);\n\t\tgoto out;\n\t}\n\n\terr = ufshcd_query_flag_retry(hba, UPIU_QUERY_OPCODE_CLEAR_FLAG,\n\t\t\tQUERY_FLAG_IDN_BKOPS_EN, 0, NULL);\n\tif (err) {\n\t\tdev_err(hba->dev, \"%s: failed to disable bkops %d\\n\",\n\t\t\t\t__func__, err);\n\t\tufshcd_disable_ee(hba, MASK_EE_URGENT_BKOPS);\n\t\tgoto out;\n\t}\n\n\thba->auto_bkops_enabled = false;\n\ttrace_ufshcd_auto_bkops_state(dev_name(hba->dev), \"Disabled\");\n\thba->is_urgent_bkops_lvl_checked = false;\nout:\n\treturn err;\n}\n\n/**\n * ufshcd_force_reset_auto_bkops - force reset auto bkops state\n * @hba: per adapter instance\n *\n * After a device reset the device may toggle the BKOPS_EN flag\n * to default value. The s/w tracking variables should be updated\n * as well. This function would change the auto-bkops state based on\n * UFSHCD_CAP_KEEP_AUTO_BKOPS_ENABLED_EXCEPT_SUSPEND.\n */\nstatic void ufshcd_force_reset_auto_bkops(struct ufs_hba *hba)\n{\n\tif (ufshcd_keep_autobkops_enabled_except_suspend(hba)) {\n\t\thba->auto_bkops_enabled = false;\n\t\thba->ee_ctrl_mask |= MASK_EE_URGENT_BKOPS;\n\t\tufshcd_enable_auto_bkops(hba);\n\t} else {\n\t\thba->auto_bkops_enabled = true;\n\t\thba->ee_ctrl_mask &= ~MASK_EE_URGENT_BKOPS;\n\t\tufshcd_disable_auto_bkops(hba);\n\t}\n\thba->urgent_bkops_lvl = BKOPS_STATUS_PERF_IMPACT;\n\thba->is_urgent_bkops_lvl_checked = false;\n}\n\nstatic inline int ufshcd_get_bkops_status(struct ufs_hba *hba, u32 *status)\n{\n\treturn ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_READ_ATTR,\n\t\t\tQUERY_ATTR_IDN_BKOPS_STATUS, 0, 0, status);\n}\n\n/**\n * ufshcd_bkops_ctrl - control the auto bkops based on current bkops status\n * @hba: per-adapter instance\n * @status: bkops_status value\n *\n * Read the bkops_status from the UFS device and Enable fBackgroundOpsEn\n * flag in the device to permit background operations if the device\n * bkops_status is greater than or equal to \"status\" argument passed to\n * this function, disable otherwise.\n *\n * Returns 0 for success, non-zero in case of failure.\n *\n * NOTE: Caller of this function can check the \"hba->auto_bkops_enabled\" flag\n * to know whether auto bkops is enabled or disabled after this function\n * returns control to it.\n */\nstatic int ufshcd_bkops_ctrl(struct ufs_hba *hba,\n\t\t\t     enum bkops_status status)\n{\n\tint err;\n\tu32 curr_status = 0;\n\n\terr = ufshcd_get_bkops_status(hba, &curr_status);\n\tif (err) {\n\t\tdev_err(hba->dev, \"%s: failed to get BKOPS status %d\\n\",\n\t\t\t\t__func__, err);\n\t\tgoto out;\n\t} else if (curr_status > BKOPS_STATUS_MAX) {\n\t\tdev_err(hba->dev, \"%s: invalid BKOPS status %d\\n\",\n\t\t\t\t__func__, curr_status);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (curr_status >= status)\n\t\terr = ufshcd_enable_auto_bkops(hba);\n\telse\n\t\terr = ufshcd_disable_auto_bkops(hba);\nout:\n\treturn err;\n}\n\n/**\n * ufshcd_urgent_bkops - handle urgent bkops exception event\n * @hba: per-adapter instance\n *\n * Enable fBackgroundOpsEn flag in the device to permit background\n * operations.\n *\n * If BKOPs is enabled, this function returns 0, 1 if the bkops in not enabled\n * and negative error value for any other failure.\n */\nstatic int ufshcd_urgent_bkops(struct ufs_hba *hba)\n{\n\treturn ufshcd_bkops_ctrl(hba, hba->urgent_bkops_lvl);\n}\n\nstatic inline int ufshcd_get_ee_status(struct ufs_hba *hba, u32 *status)\n{\n\treturn ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_READ_ATTR,\n\t\t\tQUERY_ATTR_IDN_EE_STATUS, 0, 0, status);\n}\n\nstatic void ufshcd_bkops_exception_event_handler(struct ufs_hba *hba)\n{\n\tint err;\n\tu32 curr_status = 0;\n\n\tif (hba->is_urgent_bkops_lvl_checked)\n\t\tgoto enable_auto_bkops;\n\n\terr = ufshcd_get_bkops_status(hba, &curr_status);\n\tif (err) {\n\t\tdev_err(hba->dev, \"%s: failed to get BKOPS status %d\\n\",\n\t\t\t\t__func__, err);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We are seeing that some devices are raising the urgent bkops\n\t * exception events even when BKOPS status doesn't indicate performace\n\t * impacted or critical. Handle these device by determining their urgent\n\t * bkops status at runtime.\n\t */\n\tif (curr_status < BKOPS_STATUS_PERF_IMPACT) {\n\t\tdev_err(hba->dev, \"%s: device raised urgent BKOPS exception for bkops status %d\\n\",\n\t\t\t\t__func__, curr_status);\n\t\t/* update the current status as the urgent bkops level */\n\t\thba->urgent_bkops_lvl = curr_status;\n\t\thba->is_urgent_bkops_lvl_checked = true;\n\t}\n\nenable_auto_bkops:\n\terr = ufshcd_enable_auto_bkops(hba);\nout:\n\tif (err < 0)\n\t\tdev_err(hba->dev, \"%s: failed to handle urgent bkops %d\\n\",\n\t\t\t\t__func__, err);\n}\n\nstatic int ufshcd_wb_ctrl(struct ufs_hba *hba, bool enable)\n{\n\tint ret;\n\tu8 index;\n\tenum query_opcode opcode;\n\n\tif (!ufshcd_is_wb_allowed(hba))\n\t\treturn 0;\n\n\tif (!(enable ^ hba->wb_enabled))\n\t\treturn 0;\n\tif (enable)\n\t\topcode = UPIU_QUERY_OPCODE_SET_FLAG;\n\telse\n\t\topcode = UPIU_QUERY_OPCODE_CLEAR_FLAG;\n\n\tindex = ufshcd_wb_get_query_index(hba);\n\tret = ufshcd_query_flag_retry(hba, opcode,\n\t\t\t\t      QUERY_FLAG_IDN_WB_EN, index, NULL);\n\tif (ret) {\n\t\tdev_err(hba->dev, \"%s write booster %s failed %d\\n\",\n\t\t\t__func__, enable ? \"enable\" : \"disable\", ret);\n\t\treturn ret;\n\t}\n\n\thba->wb_enabled = enable;\n\tdev_dbg(hba->dev, \"%s write booster %s %d\\n\",\n\t\t\t__func__, enable ? \"enable\" : \"disable\", ret);\n\n\treturn ret;\n}\n\nstatic int ufshcd_wb_toggle_flush_during_h8(struct ufs_hba *hba, bool set)\n{\n\tint val;\n\tu8 index;\n\n\tif (set)\n\t\tval =  UPIU_QUERY_OPCODE_SET_FLAG;\n\telse\n\t\tval = UPIU_QUERY_OPCODE_CLEAR_FLAG;\n\n\tindex = ufshcd_wb_get_query_index(hba);\n\treturn ufshcd_query_flag_retry(hba, val,\n\t\t\t\tQUERY_FLAG_IDN_WB_BUFF_FLUSH_DURING_HIBERN8,\n\t\t\t\tindex, NULL);\n}\n\nstatic inline void ufshcd_wb_toggle_flush(struct ufs_hba *hba, bool enable)\n{\n\tif (hba->quirks & UFSHCI_QUIRK_SKIP_MANUAL_WB_FLUSH_CTRL)\n\t\treturn;\n\n\tif (enable)\n\t\tufshcd_wb_buf_flush_enable(hba);\n\telse\n\t\tufshcd_wb_buf_flush_disable(hba);\n\n}\n\nstatic int ufshcd_wb_buf_flush_enable(struct ufs_hba *hba)\n{\n\tint ret;\n\tu8 index;\n\n\tif (!ufshcd_is_wb_allowed(hba) || hba->wb_buf_flush_enabled)\n\t\treturn 0;\n\n\tindex = ufshcd_wb_get_query_index(hba);\n\tret = ufshcd_query_flag_retry(hba, UPIU_QUERY_OPCODE_SET_FLAG,\n\t\t\t\t      QUERY_FLAG_IDN_WB_BUFF_FLUSH_EN,\n\t\t\t\t      index, NULL);\n\tif (ret)\n\t\tdev_err(hba->dev, \"%s WB - buf flush enable failed %d\\n\",\n\t\t\t__func__, ret);\n\telse\n\t\thba->wb_buf_flush_enabled = true;\n\n\tdev_dbg(hba->dev, \"WB - Flush enabled: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int ufshcd_wb_buf_flush_disable(struct ufs_hba *hba)\n{\n\tint ret;\n\tu8 index;\n\n\tif (!ufshcd_is_wb_allowed(hba) || !hba->wb_buf_flush_enabled)\n\t\treturn 0;\n\n\tindex = ufshcd_wb_get_query_index(hba);\n\tret = ufshcd_query_flag_retry(hba, UPIU_QUERY_OPCODE_CLEAR_FLAG,\n\t\t\t\t      QUERY_FLAG_IDN_WB_BUFF_FLUSH_EN,\n\t\t\t\t      index, NULL);\n\tif (ret) {\n\t\tdev_warn(hba->dev, \"%s: WB - buf flush disable failed %d\\n\",\n\t\t\t __func__, ret);\n\t} else {\n\t\thba->wb_buf_flush_enabled = false;\n\t\tdev_dbg(hba->dev, \"WB - Flush disabled: %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic bool ufshcd_wb_presrv_usrspc_keep_vcc_on(struct ufs_hba *hba,\n\t\t\t\t\t\tu32 avail_buf)\n{\n\tu32 cur_buf;\n\tint ret;\n\tu8 index;\n\n\tindex = ufshcd_wb_get_query_index(hba);\n\tret = ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_READ_ATTR,\n\t\t\t\t\t      QUERY_ATTR_IDN_CURR_WB_BUFF_SIZE,\n\t\t\t\t\t      index, 0, &cur_buf);\n\tif (ret) {\n\t\tdev_err(hba->dev, \"%s dCurWriteBoosterBufferSize read failed %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn false;\n\t}\n\n\tif (!cur_buf) {\n\t\tdev_info(hba->dev, \"dCurWBBuf: %d WB disabled until free-space is available\\n\",\n\t\t\t cur_buf);\n\t\treturn false;\n\t}\n\t/* Let it continue to flush when available buffer exceeds threshold */\n\tif (avail_buf < hba->vps->wb_flush_threshold)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool ufshcd_wb_need_flush(struct ufs_hba *hba)\n{\n\tint ret;\n\tu32 avail_buf;\n\tu8 index;\n\n\tif (!ufshcd_is_wb_allowed(hba))\n\t\treturn false;\n\t/*\n\t * The ufs device needs the vcc to be ON to flush.\n\t * With user-space reduction enabled, it's enough to enable flush\n\t * by checking only the available buffer. The threshold\n\t * defined here is > 90% full.\n\t * With user-space preserved enabled, the current-buffer\n\t * should be checked too because the wb buffer size can reduce\n\t * when disk tends to be full. This info is provided by current\n\t * buffer (dCurrentWriteBoosterBufferSize). There's no point in\n\t * keeping vcc on when current buffer is empty.\n\t */\n\tindex = ufshcd_wb_get_query_index(hba);\n\tret = ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_READ_ATTR,\n\t\t\t\t      QUERY_ATTR_IDN_AVAIL_WB_BUFF_SIZE,\n\t\t\t\t      index, 0, &avail_buf);\n\tif (ret) {\n\t\tdev_warn(hba->dev, \"%s dAvailableWriteBoosterBufferSize read failed %d\\n\",\n\t\t\t __func__, ret);\n\t\treturn false;\n\t}\n\n\tif (!hba->dev_info.b_presrv_uspc_en) {\n\t\tif (avail_buf <= UFS_WB_BUF_REMAIN_PERCENT(10))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\treturn ufshcd_wb_presrv_usrspc_keep_vcc_on(hba, avail_buf);\n}\n\nstatic void ufshcd_rpm_dev_flush_recheck_work(struct work_struct *work)\n{\n\tstruct ufs_hba *hba = container_of(to_delayed_work(work),\n\t\t\t\t\t   struct ufs_hba,\n\t\t\t\t\t   rpm_dev_flush_recheck_work);\n\t/*\n\t * To prevent unnecessary VCC power drain after device finishes\n\t * WriteBooster buffer flush or Auto BKOPs, force runtime resume\n\t * after a certain delay to recheck the threshold by next runtime\n\t * suspend.\n\t */\n\tpm_runtime_get_sync(hba->dev);\n\tpm_runtime_put_sync(hba->dev);\n}\n\n/**\n * ufshcd_exception_event_handler - handle exceptions raised by device\n * @work: pointer to work data\n *\n * Read bExceptionEventStatus attribute from the device and handle the\n * exception event accordingly.\n */\nstatic void ufshcd_exception_event_handler(struct work_struct *work)\n{\n\tstruct ufs_hba *hba;\n\tint err;\n\tu32 status = 0;\n\thba = container_of(work, struct ufs_hba, eeh_work);\n\n\tpm_runtime_get_sync(hba->dev);\n\tufshcd_scsi_block_requests(hba);\n\terr = ufshcd_get_ee_status(hba, &status);\n\tif (err) {\n\t\tdev_err(hba->dev, \"%s: failed to get exception status %d\\n\",\n\t\t\t\t__func__, err);\n\t\tgoto out;\n\t}\n\n\tstatus &= hba->ee_ctrl_mask;\n\n\tif (status & MASK_EE_URGENT_BKOPS)\n\t\tufshcd_bkops_exception_event_handler(hba);\n\nout:\n\tufshcd_scsi_unblock_requests(hba);\n\t/*\n\t * pm_runtime_get_noresume is called while scheduling\n\t * eeh_work to avoid suspend racing with exception work.\n\t * Hence decrement usage counter using pm_runtime_put_noidle\n\t * to allow suspend on completion of exception event handler.\n\t */\n\tpm_runtime_put_noidle(hba->dev);\n\tpm_runtime_put(hba->dev);\n\treturn;\n}\n\n/* Complete requests that have door-bell cleared */\nstatic void ufshcd_complete_requests(struct ufs_hba *hba)\n{\n\tufshcd_transfer_req_compl(hba);\n\tufshcd_tmc_handler(hba);\n}\n\n/**\n * ufshcd_quirk_dl_nac_errors - This function checks if error handling is\n *\t\t\t\tto recover from the DL NAC errors or not.\n * @hba: per-adapter instance\n *\n * Returns true if error handling is required, false otherwise\n */\nstatic bool ufshcd_quirk_dl_nac_errors(struct ufs_hba *hba)\n{\n\tunsigned long flags;\n\tbool err_handling = true;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t/*\n\t * UFS_DEVICE_QUIRK_RECOVERY_FROM_DL_NAC_ERRORS only workaround the\n\t * device fatal error and/or DL NAC & REPLAY timeout errors.\n\t */\n\tif (hba->saved_err & (CONTROLLER_FATAL_ERROR | SYSTEM_BUS_FATAL_ERROR))\n\t\tgoto out;\n\n\tif ((hba->saved_err & DEVICE_FATAL_ERROR) ||\n\t    ((hba->saved_err & UIC_ERROR) &&\n\t     (hba->saved_uic_err & UFSHCD_UIC_DL_TCx_REPLAY_ERROR)))\n\t\tgoto out;\n\n\tif ((hba->saved_err & UIC_ERROR) &&\n\t    (hba->saved_uic_err & UFSHCD_UIC_DL_NAC_RECEIVED_ERROR)) {\n\t\tint err;\n\t\t/*\n\t\t * wait for 50ms to see if we can get any other errors or not.\n\t\t */\n\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\tmsleep(50);\n\t\tspin_lock_irqsave(hba->host->host_lock, flags);\n\n\t\t/*\n\t\t * now check if we have got any other severe errors other than\n\t\t * DL NAC error?\n\t\t */\n\t\tif ((hba->saved_err & INT_FATAL_ERRORS) ||\n\t\t    ((hba->saved_err & UIC_ERROR) &&\n\t\t    (hba->saved_uic_err & ~UFSHCD_UIC_DL_NAC_RECEIVED_ERROR)))\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * As DL NAC is the only error received so far, send out NOP\n\t\t * command to confirm if link is still active or not.\n\t\t *   - If we don't get any response then do error recovery.\n\t\t *   - If we get response then clear the DL NAC error bit.\n\t\t */\n\n\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\terr = ufshcd_verify_dev_init(hba);\n\t\tspin_lock_irqsave(hba->host->host_lock, flags);\n\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* Link seems to be alive hence ignore the DL NAC errors */\n\t\tif (hba->saved_uic_err == UFSHCD_UIC_DL_NAC_RECEIVED_ERROR)\n\t\t\thba->saved_err &= ~UIC_ERROR;\n\t\t/* clear NAC error */\n\t\thba->saved_uic_err &= ~UFSHCD_UIC_DL_NAC_RECEIVED_ERROR;\n\t\tif (!hba->saved_uic_err)\n\t\t\terr_handling = false;\n\t}\nout:\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\treturn err_handling;\n}\n\n/* host lock must be held before calling this func */\nstatic inline bool ufshcd_is_saved_err_fatal(struct ufs_hba *hba)\n{\n\treturn (hba->saved_uic_err & UFSHCD_UIC_DL_PA_INIT_ERROR) ||\n\t       (hba->saved_err & (INT_FATAL_ERRORS | UFSHCD_UIC_HIBERN8_MASK));\n}\n\n/* host lock must be held before calling this func */\nstatic inline void ufshcd_schedule_eh_work(struct ufs_hba *hba)\n{\n\t/* handle fatal errors only when link is not in error state */\n\tif (hba->ufshcd_state != UFSHCD_STATE_ERROR) {\n\t\tif (hba->force_reset || ufshcd_is_link_broken(hba) ||\n\t\t    ufshcd_is_saved_err_fatal(hba))\n\t\t\thba->ufshcd_state = UFSHCD_STATE_EH_SCHEDULED_FATAL;\n\t\telse\n\t\t\thba->ufshcd_state = UFSHCD_STATE_EH_SCHEDULED_NON_FATAL;\n\t\tqueue_work(hba->eh_wq, &hba->eh_work);\n\t}\n}\n\nstatic void ufshcd_err_handling_prepare(struct ufs_hba *hba)\n{\n\tpm_runtime_get_sync(hba->dev);\n\tif (pm_runtime_suspended(hba->dev)) {\n\t\t/*\n\t\t * Don't assume anything of pm_runtime_get_sync(), if\n\t\t * resume fails, irq and clocks can be OFF, and powers\n\t\t * can be OFF or in LPM.\n\t\t */\n\t\tufshcd_setup_hba_vreg(hba, true);\n\t\tufshcd_enable_irq(hba);\n\t\tufshcd_setup_vreg(hba, true);\n\t\tufshcd_config_vreg_hpm(hba, hba->vreg_info.vccq);\n\t\tufshcd_config_vreg_hpm(hba, hba->vreg_info.vccq2);\n\t\tufshcd_hold(hba, false);\n\t\tif (!ufshcd_is_clkgating_allowed(hba))\n\t\t\tufshcd_setup_clocks(hba, true);\n\t\tufshcd_release(hba);\n\t\tufshcd_vops_resume(hba, UFS_RUNTIME_PM);\n\t} else {\n\t\tufshcd_hold(hba, false);\n\t\tif (hba->clk_scaling.is_allowed) {\n\t\t\tcancel_work_sync(&hba->clk_scaling.suspend_work);\n\t\t\tcancel_work_sync(&hba->clk_scaling.resume_work);\n\t\t\tufshcd_suspend_clkscaling(hba);\n\t\t}\n\t}\n}\n\nstatic void ufshcd_err_handling_unprepare(struct ufs_hba *hba)\n{\n\tufshcd_release(hba);\n\tif (hba->clk_scaling.is_allowed)\n\t\tufshcd_resume_clkscaling(hba);\n\tpm_runtime_put(hba->dev);\n}\n\nstatic inline bool ufshcd_err_handling_should_stop(struct ufs_hba *hba)\n{\n\treturn (hba->ufshcd_state == UFSHCD_STATE_ERROR ||\n\t\t(!(hba->saved_err || hba->saved_uic_err || hba->force_reset ||\n\t\t\tufshcd_is_link_broken(hba))));\n}\n\n#ifdef CONFIG_PM\nstatic void ufshcd_recover_pm_error(struct ufs_hba *hba)\n{\n\tstruct Scsi_Host *shost = hba->host;\n\tstruct scsi_device *sdev;\n\tstruct request_queue *q;\n\tint ret;\n\n\t/*\n\t * Set RPM status of hba device to RPM_ACTIVE,\n\t * this also clears its runtime error.\n\t */\n\tret = pm_runtime_set_active(hba->dev);\n\t/*\n\t * If hba device had runtime error, we also need to resume those\n\t * scsi devices under hba in case any of them has failed to be\n\t * resumed due to hba runtime resume failure. This is to unblock\n\t * blk_queue_enter in case there are bios waiting inside it.\n\t */\n\tif (!ret) {\n\t\tshost_for_each_device(sdev, shost) {\n\t\t\tq = sdev->request_queue;\n\t\t\tif (q->dev && (q->rpm_status == RPM_SUSPENDED ||\n\t\t\t\t       q->rpm_status == RPM_SUSPENDING))\n\t\t\t\tpm_request_resume(q->dev);\n\t\t}\n\t}\n}\n#else\nstatic inline void ufshcd_recover_pm_error(struct ufs_hba *hba)\n{\n}\n#endif\n\nstatic bool ufshcd_is_pwr_mode_restore_needed(struct ufs_hba *hba)\n{\n\tstruct ufs_pa_layer_attr *pwr_info = &hba->pwr_info;\n\tu32 mode;\n\n\tufshcd_dme_get(hba, UIC_ARG_MIB(PA_PWRMODE), &mode);\n\n\tif (pwr_info->pwr_rx != ((mode >> PWRMODE_RX_OFFSET) & PWRMODE_MASK))\n\t\treturn true;\n\n\tif (pwr_info->pwr_tx != (mode & PWRMODE_MASK))\n\t\treturn true;\n\n\treturn false;\n}\n\n/**\n * ufshcd_err_handler - handle UFS errors that require s/w attention\n * @work: pointer to work structure\n */\nstatic void ufshcd_err_handler(struct work_struct *work)\n{\n\tstruct ufs_hba *hba;\n\tunsigned long flags;\n\tbool err_xfer = false;\n\tbool err_tm = false;\n\tint err = 0, pmc_err;\n\tint tag;\n\tbool needs_reset = false, needs_restore = false;\n\n\thba = container_of(work, struct ufs_hba, eh_work);\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tif (ufshcd_err_handling_should_stop(hba)) {\n\t\tif (hba->ufshcd_state != UFSHCD_STATE_ERROR)\n\t\t\thba->ufshcd_state = UFSHCD_STATE_OPERATIONAL;\n\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\treturn;\n\t}\n\tufshcd_set_eh_in_progress(hba);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\tufshcd_err_handling_prepare(hba);\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tufshcd_scsi_block_requests(hba);\n\t/*\n\t * A full reset and restore might have happened after preparation\n\t * is finished, double check whether we should stop.\n\t */\n\tif (ufshcd_err_handling_should_stop(hba)) {\n\t\tif (hba->ufshcd_state != UFSHCD_STATE_ERROR)\n\t\t\thba->ufshcd_state = UFSHCD_STATE_OPERATIONAL;\n\t\tgoto out;\n\t}\n\thba->ufshcd_state = UFSHCD_STATE_RESET;\n\n\t/* Complete requests that have door-bell cleared by h/w */\n\tufshcd_complete_requests(hba);\n\n\tif (hba->dev_quirks & UFS_DEVICE_QUIRK_RECOVERY_FROM_DL_NAC_ERRORS) {\n\t\tbool ret;\n\n\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\t/* release the lock as ufshcd_quirk_dl_nac_errors() may sleep */\n\t\tret = ufshcd_quirk_dl_nac_errors(hba);\n\t\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t\tif (!ret && !hba->force_reset && ufshcd_is_link_active(hba))\n\t\t\tgoto skip_err_handling;\n\t}\n\n\tif (hba->force_reset || ufshcd_is_link_broken(hba) ||\n\t    ufshcd_is_saved_err_fatal(hba) ||\n\t    ((hba->saved_err & UIC_ERROR) &&\n\t     (hba->saved_uic_err & (UFSHCD_UIC_DL_NAC_RECEIVED_ERROR |\n\t\t\t\t    UFSHCD_UIC_DL_TCx_REPLAY_ERROR))))\n\t\tneeds_reset = true;\n\n\tif ((hba->saved_err & (INT_FATAL_ERRORS | UFSHCD_UIC_HIBERN8_MASK)) ||\n\t    (hba->saved_uic_err &&\n\t     (hba->saved_uic_err != UFSHCD_UIC_PA_GENERIC_ERROR))) {\n\t\tbool pr_prdt = !!(hba->saved_err & SYSTEM_BUS_FATAL_ERROR);\n\n\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\tufshcd_print_host_state(hba);\n\t\tufshcd_print_pwr_info(hba);\n\t\tufshcd_print_host_regs(hba);\n\t\tufshcd_print_tmrs(hba, hba->outstanding_tasks);\n\t\tufshcd_print_trs(hba, hba->outstanding_reqs, pr_prdt);\n\t\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t}\n\n\t/*\n\t * if host reset is required then skip clearing the pending\n\t * transfers forcefully because they will get cleared during\n\t * host reset and restore\n\t */\n\tif (needs_reset)\n\t\tgoto do_reset;\n\n\t/*\n\t * If LINERESET was caught, UFS might have been put to PWM mode,\n\t * check if power mode restore is needed.\n\t */\n\tif (hba->saved_uic_err & UFSHCD_UIC_PA_GENERIC_ERROR) {\n\t\thba->saved_uic_err &= ~UFSHCD_UIC_PA_GENERIC_ERROR;\n\t\tif (!hba->saved_uic_err)\n\t\t\thba->saved_err &= ~UIC_ERROR;\n\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\tif (ufshcd_is_pwr_mode_restore_needed(hba))\n\t\t\tneeds_restore = true;\n\t\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t\tif (!hba->saved_err && !needs_restore)\n\t\t\tgoto skip_err_handling;\n\t}\n\n\thba->silence_err_logs = true;\n\t/* release lock as clear command might sleep */\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t/* Clear pending transfer requests */\n\tfor_each_set_bit(tag, &hba->outstanding_reqs, hba->nutrs) {\n\t\tif (ufshcd_try_to_abort_task(hba, tag)) {\n\t\t\terr_xfer = true;\n\t\t\tgoto lock_skip_pending_xfer_clear;\n\t\t}\n\t}\n\n\t/* Clear pending task management requests */\n\tfor_each_set_bit(tag, &hba->outstanding_tasks, hba->nutmrs) {\n\t\tif (ufshcd_clear_tm_cmd(hba, tag)) {\n\t\t\terr_tm = true;\n\t\t\tgoto lock_skip_pending_xfer_clear;\n\t\t}\n\t}\n\nlock_skip_pending_xfer_clear:\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\n\t/* Complete the requests that are cleared by s/w */\n\tufshcd_complete_requests(hba);\n\thba->silence_err_logs = false;\n\n\tif (err_xfer || err_tm) {\n\t\tneeds_reset = true;\n\t\tgoto do_reset;\n\t}\n\n\t/*\n\t * After all reqs and tasks are cleared from doorbell,\n\t * now it is safe to retore power mode.\n\t */\n\tif (needs_restore) {\n\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\t/*\n\t\t * Hold the scaling lock just in case dev cmds\n\t\t * are sent via bsg and/or sysfs.\n\t\t */\n\t\tdown_write(&hba->clk_scaling_lock);\n\t\thba->force_pmc = true;\n\t\tpmc_err = ufshcd_config_pwr_mode(hba, &(hba->pwr_info));\n\t\tif (pmc_err) {\n\t\t\tneeds_reset = true;\n\t\t\tdev_err(hba->dev, \"%s: Failed to restore power mode, err = %d\\n\",\n\t\t\t\t\t__func__, pmc_err);\n\t\t}\n\t\thba->force_pmc = false;\n\t\tufshcd_print_pwr_info(hba);\n\t\tup_write(&hba->clk_scaling_lock);\n\t\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t}\n\ndo_reset:\n\t/* Fatal errors need reset */\n\tif (needs_reset) {\n\t\tunsigned long max_doorbells = (1UL << hba->nutrs) - 1;\n\n\t\t/*\n\t\t * ufshcd_reset_and_restore() does the link reinitialization\n\t\t * which will need atleast one empty doorbell slot to send the\n\t\t * device management commands (NOP and query commands).\n\t\t * If there is no slot empty at this moment then free up last\n\t\t * slot forcefully.\n\t\t */\n\t\tif (hba->outstanding_reqs == max_doorbells)\n\t\t\t__ufshcd_transfer_req_compl(hba,\n\t\t\t\t\t\t    (1UL << (hba->nutrs - 1)));\n\n\t\thba->force_reset = false;\n\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\terr = ufshcd_reset_and_restore(hba);\n\t\tif (err)\n\t\t\tdev_err(hba->dev, \"%s: reset and restore failed with err %d\\n\",\n\t\t\t\t\t__func__, err);\n\t\telse\n\t\t\tufshcd_recover_pm_error(hba);\n\t\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t}\n\nskip_err_handling:\n\tif (!needs_reset) {\n\t\tif (hba->ufshcd_state == UFSHCD_STATE_RESET)\n\t\t\thba->ufshcd_state = UFSHCD_STATE_OPERATIONAL;\n\t\tif (hba->saved_err || hba->saved_uic_err)\n\t\t\tdev_err_ratelimited(hba->dev, \"%s: exit: saved_err 0x%x saved_uic_err 0x%x\",\n\t\t\t    __func__, hba->saved_err, hba->saved_uic_err);\n\t}\n\nout:\n\tufshcd_clear_eh_in_progress(hba);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\tufshcd_scsi_unblock_requests(hba);\n\tufshcd_err_handling_unprepare(hba);\n}\n\n/**\n * ufshcd_update_uic_error - check and set fatal UIC error flags.\n * @hba: per-adapter instance\n *\n * Returns\n *  IRQ_HANDLED - If interrupt is valid\n *  IRQ_NONE    - If invalid interrupt\n */\nstatic irqreturn_t ufshcd_update_uic_error(struct ufs_hba *hba)\n{\n\tu32 reg;\n\tirqreturn_t retval = IRQ_NONE;\n\n\t/* PHY layer error */\n\treg = ufshcd_readl(hba, REG_UIC_ERROR_CODE_PHY_ADAPTER_LAYER);\n\tif ((reg & UIC_PHY_ADAPTER_LAYER_ERROR) &&\n\t    (reg & UIC_PHY_ADAPTER_LAYER_ERROR_CODE_MASK)) {\n\t\tufshcd_update_reg_hist(&hba->ufs_stats.pa_err, reg);\n\t\t/*\n\t\t * To know whether this error is fatal or not, DB timeout\n\t\t * must be checked but this error is handled separately.\n\t\t */\n\t\tif (reg & UIC_PHY_ADAPTER_LAYER_LANE_ERR_MASK)\n\t\t\tdev_dbg(hba->dev, \"%s: UIC Lane error reported\\n\",\n\t\t\t\t\t__func__);\n\n\t\t/* Got a LINERESET indication. */\n\t\tif (reg & UIC_PHY_ADAPTER_LAYER_GENERIC_ERROR) {\n\t\t\tstruct uic_command *cmd = NULL;\n\n\t\t\thba->uic_error |= UFSHCD_UIC_PA_GENERIC_ERROR;\n\t\t\tif (hba->uic_async_done && hba->active_uic_cmd)\n\t\t\t\tcmd = hba->active_uic_cmd;\n\t\t\t/*\n\t\t\t * Ignore the LINERESET during power mode change\n\t\t\t * operation via DME_SET command.\n\t\t\t */\n\t\t\tif (cmd && (cmd->command == UIC_CMD_DME_SET))\n\t\t\t\thba->uic_error &= ~UFSHCD_UIC_PA_GENERIC_ERROR;\n\t\t}\n\t\tretval |= IRQ_HANDLED;\n\t}\n\n\t/* PA_INIT_ERROR is fatal and needs UIC reset */\n\treg = ufshcd_readl(hba, REG_UIC_ERROR_CODE_DATA_LINK_LAYER);\n\tif ((reg & UIC_DATA_LINK_LAYER_ERROR) &&\n\t    (reg & UIC_DATA_LINK_LAYER_ERROR_CODE_MASK)) {\n\t\tufshcd_update_reg_hist(&hba->ufs_stats.dl_err, reg);\n\n\t\tif (reg & UIC_DATA_LINK_LAYER_ERROR_PA_INIT)\n\t\t\thba->uic_error |= UFSHCD_UIC_DL_PA_INIT_ERROR;\n\t\telse if (hba->dev_quirks &\n\t\t\t\tUFS_DEVICE_QUIRK_RECOVERY_FROM_DL_NAC_ERRORS) {\n\t\t\tif (reg & UIC_DATA_LINK_LAYER_ERROR_NAC_RECEIVED)\n\t\t\t\thba->uic_error |=\n\t\t\t\t\tUFSHCD_UIC_DL_NAC_RECEIVED_ERROR;\n\t\t\telse if (reg & UIC_DATA_LINK_LAYER_ERROR_TCx_REPLAY_TIMEOUT)\n\t\t\t\thba->uic_error |= UFSHCD_UIC_DL_TCx_REPLAY_ERROR;\n\t\t}\n\t\tretval |= IRQ_HANDLED;\n\t}\n\n\t/* UIC NL/TL/DME errors needs software retry */\n\treg = ufshcd_readl(hba, REG_UIC_ERROR_CODE_NETWORK_LAYER);\n\tif ((reg & UIC_NETWORK_LAYER_ERROR) &&\n\t    (reg & UIC_NETWORK_LAYER_ERROR_CODE_MASK)) {\n\t\tufshcd_update_reg_hist(&hba->ufs_stats.nl_err, reg);\n\t\thba->uic_error |= UFSHCD_UIC_NL_ERROR;\n\t\tretval |= IRQ_HANDLED;\n\t}\n\n\treg = ufshcd_readl(hba, REG_UIC_ERROR_CODE_TRANSPORT_LAYER);\n\tif ((reg & UIC_TRANSPORT_LAYER_ERROR) &&\n\t    (reg & UIC_TRANSPORT_LAYER_ERROR_CODE_MASK)) {\n\t\tufshcd_update_reg_hist(&hba->ufs_stats.tl_err, reg);\n\t\thba->uic_error |= UFSHCD_UIC_TL_ERROR;\n\t\tretval |= IRQ_HANDLED;\n\t}\n\n\treg = ufshcd_readl(hba, REG_UIC_ERROR_CODE_DME);\n\tif ((reg & UIC_DME_ERROR) &&\n\t    (reg & UIC_DME_ERROR_CODE_MASK)) {\n\t\tufshcd_update_reg_hist(&hba->ufs_stats.dme_err, reg);\n\t\thba->uic_error |= UFSHCD_UIC_DME_ERROR;\n\t\tretval |= IRQ_HANDLED;\n\t}\n\n\tdev_dbg(hba->dev, \"%s: UIC error flags = 0x%08x\\n\",\n\t\t\t__func__, hba->uic_error);\n\treturn retval;\n}\n\nstatic bool ufshcd_is_auto_hibern8_error(struct ufs_hba *hba,\n\t\t\t\t\t u32 intr_mask)\n{\n\tif (!ufshcd_is_auto_hibern8_supported(hba) ||\n\t    !ufshcd_is_auto_hibern8_enabled(hba))\n\t\treturn false;\n\n\tif (!(intr_mask & UFSHCD_UIC_HIBERN8_MASK))\n\t\treturn false;\n\n\tif (hba->active_uic_cmd &&\n\t    (hba->active_uic_cmd->command == UIC_CMD_DME_HIBER_ENTER ||\n\t    hba->active_uic_cmd->command == UIC_CMD_DME_HIBER_EXIT))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * ufshcd_check_errors - Check for errors that need s/w attention\n * @hba: per-adapter instance\n *\n * Returns\n *  IRQ_HANDLED - If interrupt is valid\n *  IRQ_NONE    - If invalid interrupt\n */\nstatic irqreturn_t ufshcd_check_errors(struct ufs_hba *hba)\n{\n\tbool queue_eh_work = false;\n\tirqreturn_t retval = IRQ_NONE;\n\n\tif (hba->errors & INT_FATAL_ERRORS) {\n\t\tufshcd_update_reg_hist(&hba->ufs_stats.fatal_err, hba->errors);\n\t\tqueue_eh_work = true;\n\t}\n\n\tif (hba->errors & UIC_ERROR) {\n\t\thba->uic_error = 0;\n\t\tretval = ufshcd_update_uic_error(hba);\n\t\tif (hba->uic_error)\n\t\t\tqueue_eh_work = true;\n\t}\n\n\tif (hba->errors & UFSHCD_UIC_HIBERN8_MASK) {\n\t\tdev_err(hba->dev,\n\t\t\t\"%s: Auto Hibern8 %s failed - status: 0x%08x, upmcrs: 0x%08x\\n\",\n\t\t\t__func__, (hba->errors & UIC_HIBERNATE_ENTER) ?\n\t\t\t\"Enter\" : \"Exit\",\n\t\t\thba->errors, ufshcd_get_upmcrs(hba));\n\t\tufshcd_update_reg_hist(&hba->ufs_stats.auto_hibern8_err,\n\t\t\t\t       hba->errors);\n\t\tufshcd_set_link_broken(hba);\n\t\tqueue_eh_work = true;\n\t}\n\n\tif (queue_eh_work) {\n\t\t/*\n\t\t * update the transfer error masks to sticky bits, let's do this\n\t\t * irrespective of current ufshcd_state.\n\t\t */\n\t\thba->saved_err |= hba->errors;\n\t\thba->saved_uic_err |= hba->uic_error;\n\n\t\t/* dump controller state before resetting */\n\t\tif ((hba->saved_err & (INT_FATAL_ERRORS)) ||\n\t\t    (hba->saved_uic_err &&\n\t\t     (hba->saved_uic_err != UFSHCD_UIC_PA_GENERIC_ERROR))) {\n\t\t\tdev_err(hba->dev, \"%s: saved_err 0x%x saved_uic_err 0x%x\\n\",\n\t\t\t\t\t__func__, hba->saved_err,\n\t\t\t\t\thba->saved_uic_err);\n\t\t\tufshcd_dump_regs(hba, 0, UFSHCI_REG_SPACE_SIZE,\n\t\t\t\t\t \"host_regs: \");\n\t\t\tufshcd_print_pwr_info(hba);\n\t\t}\n\t\tufshcd_schedule_eh_work(hba);\n\t\tretval |= IRQ_HANDLED;\n\t}\n\t/*\n\t * if (!queue_eh_work) -\n\t * Other errors are either non-fatal where host recovers\n\t * itself without s/w intervention or errors that will be\n\t * handled by the SCSI core layer.\n\t */\n\treturn retval;\n}\n\nstruct ctm_info {\n\tstruct ufs_hba\t*hba;\n\tunsigned long\tpending;\n\tunsigned int\tncpl;\n};\n\nstatic bool ufshcd_compl_tm(struct request *req, void *priv, bool reserved)\n{\n\tstruct ctm_info *const ci = priv;\n\tstruct completion *c;\n\n\tWARN_ON_ONCE(reserved);\n\tif (test_bit(req->tag, &ci->pending))\n\t\treturn true;\n\tci->ncpl++;\n\tc = req->end_io_data;\n\tif (c)\n\t\tcomplete(c);\n\treturn true;\n}\n\n/**\n * ufshcd_tmc_handler - handle task management function completion\n * @hba: per adapter instance\n *\n * Returns\n *  IRQ_HANDLED - If interrupt is valid\n *  IRQ_NONE    - If invalid interrupt\n */\nstatic irqreturn_t ufshcd_tmc_handler(struct ufs_hba *hba)\n{\n\tstruct request_queue *q = hba->tmf_queue;\n\tstruct ctm_info ci = {\n\t\t.hba\t = hba,\n\t\t.pending = ufshcd_readl(hba, REG_UTP_TASK_REQ_DOOR_BELL),\n\t};\n\n\tblk_mq_tagset_busy_iter(q->tag_set, ufshcd_compl_tm, &ci);\n\treturn ci.ncpl ? IRQ_HANDLED : IRQ_NONE;\n}\n\n/**\n * ufshcd_sl_intr - Interrupt service routine\n * @hba: per adapter instance\n * @intr_status: contains interrupts generated by the controller\n *\n * Returns\n *  IRQ_HANDLED - If interrupt is valid\n *  IRQ_NONE    - If invalid interrupt\n */\nstatic irqreturn_t ufshcd_sl_intr(struct ufs_hba *hba, u32 intr_status)\n{\n\tirqreturn_t retval = IRQ_NONE;\n\n\thba->errors = UFSHCD_ERROR_MASK & intr_status;\n\n\tif (ufshcd_is_auto_hibern8_error(hba, intr_status))\n\t\thba->errors |= (UFSHCD_UIC_HIBERN8_MASK & intr_status);\n\n\tif (hba->errors)\n\t\tretval |= ufshcd_check_errors(hba);\n\n\tif (intr_status & UFSHCD_UIC_MASK)\n\t\tretval |= ufshcd_uic_cmd_compl(hba, intr_status);\n\n\tif (intr_status & UTP_TASK_REQ_COMPL)\n\t\tretval |= ufshcd_tmc_handler(hba);\n\n\tif (intr_status & UTP_TRANSFER_REQ_COMPL)\n\t\tretval |= ufshcd_transfer_req_compl(hba);\n\n\treturn retval;\n}\n\n/**\n * ufshcd_intr - Main interrupt service routine\n * @irq: irq number\n * @__hba: pointer to adapter instance\n *\n * Returns\n *  IRQ_HANDLED - If interrupt is valid\n *  IRQ_NONE    - If invalid interrupt\n */\nstatic irqreturn_t ufshcd_intr(int irq, void *__hba)\n{\n\tu32 intr_status, enabled_intr_status = 0;\n\tirqreturn_t retval = IRQ_NONE;\n\tstruct ufs_hba *hba = __hba;\n\tint retries = hba->nutrs;\n\n\tspin_lock(hba->host->host_lock);\n\tintr_status = ufshcd_readl(hba, REG_INTERRUPT_STATUS);\n\thba->ufs_stats.last_intr_status = intr_status;\n\thba->ufs_stats.last_intr_ts = ktime_get();\n\n\t/*\n\t * There could be max of hba->nutrs reqs in flight and in worst case\n\t * if the reqs get finished 1 by 1 after the interrupt status is\n\t * read, make sure we handle them by checking the interrupt status\n\t * again in a loop until we process all of the reqs before returning.\n\t */\n\twhile (intr_status && retries--) {\n\t\tenabled_intr_status =\n\t\t\tintr_status & ufshcd_readl(hba, REG_INTERRUPT_ENABLE);\n\t\tif (intr_status)\n\t\t\tufshcd_writel(hba, intr_status, REG_INTERRUPT_STATUS);\n\t\tif (enabled_intr_status)\n\t\t\tretval |= ufshcd_sl_intr(hba, enabled_intr_status);\n\n\t\tintr_status = ufshcd_readl(hba, REG_INTERRUPT_STATUS);\n\t}\n\n\tif (enabled_intr_status && retval == IRQ_NONE) {\n\t\tdev_err(hba->dev, \"%s: Unhandled interrupt 0x%08x\\n\",\n\t\t\t\t\t__func__, intr_status);\n\t\tufshcd_dump_regs(hba, 0, UFSHCI_REG_SPACE_SIZE, \"host_regs: \");\n\t}\n\n\tspin_unlock(hba->host->host_lock);\n\treturn retval;\n}\n\nstatic int ufshcd_clear_tm_cmd(struct ufs_hba *hba, int tag)\n{\n\tint err = 0;\n\tu32 mask = 1 << tag;\n\tunsigned long flags;\n\n\tif (!test_bit(tag, &hba->outstanding_tasks))\n\t\tgoto out;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tufshcd_utmrl_clear(hba, tag);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\t/* poll for max. 1 sec to clear door bell register by h/w */\n\terr = ufshcd_wait_for_register(hba,\n\t\t\tREG_UTP_TASK_REQ_DOOR_BELL,\n\t\t\tmask, 0, 1000, 1000);\nout:\n\treturn err;\n}\n\nstatic int __ufshcd_issue_tm_cmd(struct ufs_hba *hba,\n\t\tstruct utp_task_req_desc *treq, u8 tm_function)\n{\n\tstruct request_queue *q = hba->tmf_queue;\n\tstruct Scsi_Host *host = hba->host;\n\tDECLARE_COMPLETION_ONSTACK(wait);\n\tstruct request *req;\n\tunsigned long flags;\n\tint free_slot, task_tag, err;\n\n\t/*\n\t * Get free slot, sleep if slots are unavailable.\n\t * Even though we use wait_event() which sleeps indefinitely,\n\t * the maximum wait time is bounded by %TM_CMD_TIMEOUT.\n\t */\n\treq = blk_get_request(q, REQ_OP_DRV_OUT, BLK_MQ_REQ_RESERVED);\n\treq->end_io_data = &wait;\n\tfree_slot = req->tag;\n\tWARN_ON_ONCE(free_slot < 0 || free_slot >= hba->nutmrs);\n\tufshcd_hold(hba, false);\n\n\tspin_lock_irqsave(host->host_lock, flags);\n\ttask_tag = hba->nutrs + free_slot;\n\n\ttreq->req_header.dword_0 |= cpu_to_be32(task_tag);\n\n\tmemcpy(hba->utmrdl_base_addr + free_slot, treq, sizeof(*treq));\n\tufshcd_vops_setup_task_mgmt(hba, free_slot, tm_function);\n\n\t/* send command to the controller */\n\t__set_bit(free_slot, &hba->outstanding_tasks);\n\n\t/* Make sure descriptors are ready before ringing the task doorbell */\n\twmb();\n\n\tufshcd_writel(hba, 1 << free_slot, REG_UTP_TASK_REQ_DOOR_BELL);\n\t/* Make sure that doorbell is committed immediately */\n\twmb();\n\n\tspin_unlock_irqrestore(host->host_lock, flags);\n\n\tufshcd_add_tm_upiu_trace(hba, task_tag, \"tm_send\");\n\n\t/* wait until the task management command is completed */\n\terr = wait_for_completion_io_timeout(&wait,\n\t\t\tmsecs_to_jiffies(TM_CMD_TIMEOUT));\n\tif (!err) {\n\t\t/*\n\t\t * Make sure that ufshcd_compl_tm() does not trigger a\n\t\t * use-after-free.\n\t\t */\n\t\treq->end_io_data = NULL;\n\t\tufshcd_add_tm_upiu_trace(hba, task_tag, \"tm_complete_err\");\n\t\tdev_err(hba->dev, \"%s: task management cmd 0x%.2x timed-out\\n\",\n\t\t\t\t__func__, tm_function);\n\t\tif (ufshcd_clear_tm_cmd(hba, free_slot))\n\t\t\tdev_WARN(hba->dev, \"%s: unable clear tm cmd (slot %d) after timeout\\n\",\n\t\t\t\t\t__func__, free_slot);\n\t\terr = -ETIMEDOUT;\n\t} else {\n\t\terr = 0;\n\t\tmemcpy(treq, hba->utmrdl_base_addr + free_slot, sizeof(*treq));\n\n\t\tufshcd_add_tm_upiu_trace(hba, task_tag, \"tm_complete\");\n\t}\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t__clear_bit(free_slot, &hba->outstanding_tasks);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\tblk_put_request(req);\n\n\tufshcd_release(hba);\n\treturn err;\n}\n\n/**\n * ufshcd_issue_tm_cmd - issues task management commands to controller\n * @hba: per adapter instance\n * @lun_id: LUN ID to which TM command is sent\n * @task_id: task ID to which the TM command is applicable\n * @tm_function: task management function opcode\n * @tm_response: task management service response return value\n *\n * Returns non-zero value on error, zero on success.\n */\nstatic int ufshcd_issue_tm_cmd(struct ufs_hba *hba, int lun_id, int task_id,\n\t\tu8 tm_function, u8 *tm_response)\n{\n\tstruct utp_task_req_desc treq = { { 0 }, };\n\tint ocs_value, err;\n\n\t/* Configure task request descriptor */\n\ttreq.header.dword_0 = cpu_to_le32(UTP_REQ_DESC_INT_CMD);\n\ttreq.header.dword_2 = cpu_to_le32(OCS_INVALID_COMMAND_STATUS);\n\n\t/* Configure task request UPIU */\n\ttreq.req_header.dword_0 = cpu_to_be32(lun_id << 8) |\n\t\t\t\t  cpu_to_be32(UPIU_TRANSACTION_TASK_REQ << 24);\n\ttreq.req_header.dword_1 = cpu_to_be32(tm_function << 16);\n\n\t/*\n\t * The host shall provide the same value for LUN field in the basic\n\t * header and for Input Parameter.\n\t */\n\ttreq.input_param1 = cpu_to_be32(lun_id);\n\ttreq.input_param2 = cpu_to_be32(task_id);\n\n\terr = __ufshcd_issue_tm_cmd(hba, &treq, tm_function);\n\tif (err == -ETIMEDOUT)\n\t\treturn err;\n\n\tocs_value = le32_to_cpu(treq.header.dword_2) & MASK_OCS;\n\tif (ocs_value != OCS_SUCCESS)\n\t\tdev_err(hba->dev, \"%s: failed, ocs = 0x%x\\n\",\n\t\t\t\t__func__, ocs_value);\n\telse if (tm_response)\n\t\t*tm_response = be32_to_cpu(treq.output_param1) &\n\t\t\t\tMASK_TM_SERVICE_RESP;\n\treturn err;\n}\n\n/**\n * ufshcd_issue_devman_upiu_cmd - API for sending \"utrd\" type requests\n * @hba:\tper-adapter instance\n * @req_upiu:\tupiu request\n * @rsp_upiu:\tupiu reply\n * @desc_buff:\tpointer to descriptor buffer, NULL if NA\n * @buff_len:\tdescriptor size, 0 if NA\n * @cmd_type:\tspecifies the type (NOP, Query...)\n * @desc_op:\tdescriptor operation\n *\n * Those type of requests uses UTP Transfer Request Descriptor - utrd.\n * Therefore, it \"rides\" the device management infrastructure: uses its tag and\n * tasks work queues.\n *\n * Since there is only one available tag for device management commands,\n * the caller is expected to hold the hba->dev_cmd.lock mutex.\n */\nstatic int ufshcd_issue_devman_upiu_cmd(struct ufs_hba *hba,\n\t\t\t\t\tstruct utp_upiu_req *req_upiu,\n\t\t\t\t\tstruct utp_upiu_req *rsp_upiu,\n\t\t\t\t\tu8 *desc_buff, int *buff_len,\n\t\t\t\t\tenum dev_cmd_type cmd_type,\n\t\t\t\t\tenum query_opcode desc_op)\n{\n\tstruct request_queue *q = hba->cmd_queue;\n\tstruct request *req;\n\tstruct ufshcd_lrb *lrbp;\n\tint err = 0;\n\tint tag;\n\tstruct completion wait;\n\tunsigned long flags;\n\tu8 upiu_flags;\n\n\tdown_read(&hba->clk_scaling_lock);\n\n\treq = blk_get_request(q, REQ_OP_DRV_OUT, 0);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out_unlock;\n\t}\n\ttag = req->tag;\n\tWARN_ON_ONCE(!ufshcd_valid_tag(hba, tag));\n\n\tinit_completion(&wait);\n\tlrbp = &hba->lrb[tag];\n\tWARN_ON(lrbp->cmd);\n\n\tlrbp->cmd = NULL;\n\tlrbp->sense_bufflen = 0;\n\tlrbp->sense_buffer = NULL;\n\tlrbp->task_tag = tag;\n\tlrbp->lun = 0;\n\tlrbp->intr_cmd = true;\n\tufshcd_prepare_lrbp_crypto(NULL, lrbp);\n\thba->dev_cmd.type = cmd_type;\n\n\tswitch (hba->ufs_version) {\n\tcase UFSHCI_VERSION_10:\n\tcase UFSHCI_VERSION_11:\n\t\tlrbp->command_type = UTP_CMD_TYPE_DEV_MANAGE;\n\t\tbreak;\n\tdefault:\n\t\tlrbp->command_type = UTP_CMD_TYPE_UFS_STORAGE;\n\t\tbreak;\n\t}\n\n\t/* update the task tag in the request upiu */\n\treq_upiu->header.dword_0 |= cpu_to_be32(tag);\n\n\tufshcd_prepare_req_desc_hdr(lrbp, &upiu_flags, DMA_NONE);\n\n\t/* just copy the upiu request as it is */\n\tmemcpy(lrbp->ucd_req_ptr, req_upiu, sizeof(*lrbp->ucd_req_ptr));\n\tif (desc_buff && desc_op == UPIU_QUERY_OPCODE_WRITE_DESC) {\n\t\t/* The Data Segment Area is optional depending upon the query\n\t\t * function value. for WRITE DESCRIPTOR, the data segment\n\t\t * follows right after the tsf.\n\t\t */\n\t\tmemcpy(lrbp->ucd_req_ptr + 1, desc_buff, *buff_len);\n\t\t*buff_len = 0;\n\t}\n\n\tmemset(lrbp->ucd_rsp_ptr, 0, sizeof(struct utp_upiu_rsp));\n\n\thba->dev_cmd.complete = &wait;\n\n\t/* Make sure descriptors are ready before ringing the doorbell */\n\twmb();\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tufshcd_send_command(hba, tag);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\t/*\n\t * ignore the returning value here - ufshcd_check_query_response is\n\t * bound to fail since dev_cmd.query and dev_cmd.type were left empty.\n\t * read the response directly ignoring all errors.\n\t */\n\tufshcd_wait_for_dev_cmd(hba, lrbp, QUERY_REQ_TIMEOUT);\n\n\t/* just copy the upiu response as it is */\n\tmemcpy(rsp_upiu, lrbp->ucd_rsp_ptr, sizeof(*rsp_upiu));\n\tif (desc_buff && desc_op == UPIU_QUERY_OPCODE_READ_DESC) {\n\t\tu8 *descp = (u8 *)lrbp->ucd_rsp_ptr + sizeof(*rsp_upiu);\n\t\tu16 resp_len = be32_to_cpu(lrbp->ucd_rsp_ptr->header.dword_2) &\n\t\t\t       MASK_QUERY_DATA_SEG_LEN;\n\n\t\tif (*buff_len >= resp_len) {\n\t\t\tmemcpy(desc_buff, descp, resp_len);\n\t\t\t*buff_len = resp_len;\n\t\t} else {\n\t\t\tdev_warn(hba->dev,\n\t\t\t\t \"%s: rsp size %d is bigger than buffer size %d\",\n\t\t\t\t __func__, resp_len, *buff_len);\n\t\t\t*buff_len = 0;\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\n\tblk_put_request(req);\nout_unlock:\n\tup_read(&hba->clk_scaling_lock);\n\treturn err;\n}\n\n/**\n * ufshcd_exec_raw_upiu_cmd - API function for sending raw upiu commands\n * @hba:\tper-adapter instance\n * @req_upiu:\tupiu request\n * @rsp_upiu:\tupiu reply - only 8 DW as we do not support scsi commands\n * @msgcode:\tmessage code, one of UPIU Transaction Codes Initiator to Target\n * @desc_buff:\tpointer to descriptor buffer, NULL if NA\n * @buff_len:\tdescriptor size, 0 if NA\n * @desc_op:\tdescriptor operation\n *\n * Supports UTP Transfer requests (nop and query), and UTP Task\n * Management requests.\n * It is up to the caller to fill the upiu conent properly, as it will\n * be copied without any further input validations.\n */\nint ufshcd_exec_raw_upiu_cmd(struct ufs_hba *hba,\n\t\t\t     struct utp_upiu_req *req_upiu,\n\t\t\t     struct utp_upiu_req *rsp_upiu,\n\t\t\t     int msgcode,\n\t\t\t     u8 *desc_buff, int *buff_len,\n\t\t\t     enum query_opcode desc_op)\n{\n\tint err;\n\tenum dev_cmd_type cmd_type = DEV_CMD_TYPE_QUERY;\n\tstruct utp_task_req_desc treq = { { 0 }, };\n\tint ocs_value;\n\tu8 tm_f = be32_to_cpu(req_upiu->header.dword_1) >> 16 & MASK_TM_FUNC;\n\n\tswitch (msgcode) {\n\tcase UPIU_TRANSACTION_NOP_OUT:\n\t\tcmd_type = DEV_CMD_TYPE_NOP;\n\t\tfallthrough;\n\tcase UPIU_TRANSACTION_QUERY_REQ:\n\t\tufshcd_hold(hba, false);\n\t\tmutex_lock(&hba->dev_cmd.lock);\n\t\terr = ufshcd_issue_devman_upiu_cmd(hba, req_upiu, rsp_upiu,\n\t\t\t\t\t\t   desc_buff, buff_len,\n\t\t\t\t\t\t   cmd_type, desc_op);\n\t\tmutex_unlock(&hba->dev_cmd.lock);\n\t\tufshcd_release(hba);\n\n\t\tbreak;\n\tcase UPIU_TRANSACTION_TASK_REQ:\n\t\ttreq.header.dword_0 = cpu_to_le32(UTP_REQ_DESC_INT_CMD);\n\t\ttreq.header.dword_2 = cpu_to_le32(OCS_INVALID_COMMAND_STATUS);\n\n\t\tmemcpy(&treq.req_header, req_upiu, sizeof(*req_upiu));\n\n\t\terr = __ufshcd_issue_tm_cmd(hba, &treq, tm_f);\n\t\tif (err == -ETIMEDOUT)\n\t\t\tbreak;\n\n\t\tocs_value = le32_to_cpu(treq.header.dword_2) & MASK_OCS;\n\t\tif (ocs_value != OCS_SUCCESS) {\n\t\t\tdev_err(hba->dev, \"%s: failed, ocs = 0x%x\\n\", __func__,\n\t\t\t\tocs_value);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(rsp_upiu, &treq.rsp_header, sizeof(*rsp_upiu));\n\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n/**\n * ufshcd_eh_device_reset_handler - device reset handler registered to\n *                                    scsi layer.\n * @cmd: SCSI command pointer\n *\n * Returns SUCCESS/FAILED\n */\nstatic int ufshcd_eh_device_reset_handler(struct scsi_cmnd *cmd)\n{\n\tstruct Scsi_Host *host;\n\tstruct ufs_hba *hba;\n\tunsigned int tag;\n\tu32 pos;\n\tint err;\n\tu8 resp = 0xF;\n\tstruct ufshcd_lrb *lrbp;\n\tunsigned long flags;\n\n\thost = cmd->device->host;\n\thba = shost_priv(host);\n\ttag = cmd->request->tag;\n\n\tlrbp = &hba->lrb[tag];\n\terr = ufshcd_issue_tm_cmd(hba, lrbp->lun, 0, UFS_LOGICAL_RESET, &resp);\n\tif (err || resp != UPIU_TASK_MANAGEMENT_FUNC_COMPL) {\n\t\tif (!err)\n\t\t\terr = resp;\n\t\tgoto out;\n\t}\n\n\t/* clear the commands that were pending for corresponding LUN */\n\tfor_each_set_bit(pos, &hba->outstanding_reqs, hba->nutrs) {\n\t\tif (hba->lrb[pos].lun == lrbp->lun) {\n\t\t\terr = ufshcd_clear_cmd(hba, pos);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_lock_irqsave(host->host_lock, flags);\n\tufshcd_transfer_req_compl(hba);\n\tspin_unlock_irqrestore(host->host_lock, flags);\n\nout:\n\thba->req_abort_count = 0;\n\tufshcd_update_reg_hist(&hba->ufs_stats.dev_reset, (u32)err);\n\tif (!err) {\n\t\terr = SUCCESS;\n\t} else {\n\t\tdev_err(hba->dev, \"%s: failed with err %d\\n\", __func__, err);\n\t\terr = FAILED;\n\t}\n\treturn err;\n}\n\nstatic void ufshcd_set_req_abort_skip(struct ufs_hba *hba, unsigned long bitmap)\n{\n\tstruct ufshcd_lrb *lrbp;\n\tint tag;\n\n\tfor_each_set_bit(tag, &bitmap, hba->nutrs) {\n\t\tlrbp = &hba->lrb[tag];\n\t\tlrbp->req_abort_skip = true;\n\t}\n}\n\n/**\n * ufshcd_try_to_abort_task - abort a specific task\n * @hba: Pointer to adapter instance\n * @tag: Task tag/index to be aborted\n *\n * Abort the pending command in device by sending UFS_ABORT_TASK task management\n * command, and in host controller by clearing the door-bell register. There can\n * be race between controller sending the command to the device while abort is\n * issued. To avoid that, first issue UFS_QUERY_TASK to check if the command is\n * really issued and then try to abort it.\n *\n * Returns zero on success, non-zero on failure\n */\nstatic int ufshcd_try_to_abort_task(struct ufs_hba *hba, int tag)\n{\n\tstruct ufshcd_lrb *lrbp = &hba->lrb[tag];\n\tint err = 0;\n\tint poll_cnt;\n\tu8 resp = 0xF;\n\tu32 reg;\n\n\tfor (poll_cnt = 100; poll_cnt; poll_cnt--) {\n\t\terr = ufshcd_issue_tm_cmd(hba, lrbp->lun, lrbp->task_tag,\n\t\t\t\tUFS_QUERY_TASK, &resp);\n\t\tif (!err && resp == UPIU_TASK_MANAGEMENT_FUNC_SUCCEEDED) {\n\t\t\t/* cmd pending in the device */\n\t\t\tdev_err(hba->dev, \"%s: cmd pending in the device. tag = %d\\n\",\n\t\t\t\t__func__, tag);\n\t\t\tbreak;\n\t\t} else if (!err && resp == UPIU_TASK_MANAGEMENT_FUNC_COMPL) {\n\t\t\t/*\n\t\t\t * cmd not pending in the device, check if it is\n\t\t\t * in transition.\n\t\t\t */\n\t\t\tdev_err(hba->dev, \"%s: cmd at tag %d not pending in the device.\\n\",\n\t\t\t\t__func__, tag);\n\t\t\treg = ufshcd_readl(hba, REG_UTP_TRANSFER_REQ_DOOR_BELL);\n\t\t\tif (reg & (1 << tag)) {\n\t\t\t\t/* sleep for max. 200us to stabilize */\n\t\t\t\tusleep_range(100, 200);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* command completed already */\n\t\t\tdev_err(hba->dev, \"%s: cmd at tag %d successfully cleared from DB.\\n\",\n\t\t\t\t__func__, tag);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tdev_err(hba->dev,\n\t\t\t\t\"%s: no response from device. tag = %d, err %d\\n\",\n\t\t\t\t__func__, tag, err);\n\t\t\tif (!err)\n\t\t\t\terr = resp; /* service response error */\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!poll_cnt) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\terr = ufshcd_issue_tm_cmd(hba, lrbp->lun, lrbp->task_tag,\n\t\t\tUFS_ABORT_TASK, &resp);\n\tif (err || resp != UPIU_TASK_MANAGEMENT_FUNC_COMPL) {\n\t\tif (!err) {\n\t\t\terr = resp; /* service response error */\n\t\t\tdev_err(hba->dev, \"%s: issued. tag = %d, err %d\\n\",\n\t\t\t\t__func__, tag, err);\n\t\t}\n\t\tgoto out;\n\t}\n\n\terr = ufshcd_clear_cmd(hba, tag);\n\tif (err)\n\t\tdev_err(hba->dev, \"%s: Failed clearing cmd at tag %d, err %d\\n\",\n\t\t\t__func__, tag, err);\n\nout:\n\treturn err;\n}\n\n/**\n * ufshcd_abort - scsi host template eh_abort_handler callback\n * @cmd: SCSI command pointer\n *\n * Returns SUCCESS/FAILED\n */\nstatic int ufshcd_abort(struct scsi_cmnd *cmd)\n{\n\tstruct Scsi_Host *host;\n\tstruct ufs_hba *hba;\n\tunsigned long flags;\n\tunsigned int tag;\n\tint err = 0;\n\tstruct ufshcd_lrb *lrbp;\n\tu32 reg;\n\n\thost = cmd->device->host;\n\thba = shost_priv(host);\n\ttag = cmd->request->tag;\n\tlrbp = &hba->lrb[tag];\n\tif (!ufshcd_valid_tag(hba, tag)) {\n\t\tdev_err(hba->dev,\n\t\t\t\"%s: invalid command tag %d: cmd=0x%p, cmd->request=0x%p\",\n\t\t\t__func__, tag, cmd, cmd->request);\n\t\tBUG();\n\t}\n\n\t/*\n\t * Task abort to the device W-LUN is illegal. When this command\n\t * will fail, due to spec violation, scsi err handling next step\n\t * will be to send LU reset which, again, is a spec violation.\n\t * To avoid these unnecessary/illegal step we skip to the last error\n\t * handling stage: reset and restore.\n\t */\n\tif (lrbp->lun == UFS_UPIU_UFS_DEVICE_WLUN)\n\t\treturn ufshcd_eh_host_reset_handler(cmd);\n\n\tufshcd_hold(hba, false);\n\treg = ufshcd_readl(hba, REG_UTP_TRANSFER_REQ_DOOR_BELL);\n\t/* If command is already aborted/completed, return SUCCESS */\n\tif (!(test_bit(tag, &hba->outstanding_reqs))) {\n\t\tdev_err(hba->dev,\n\t\t\t\"%s: cmd at tag %d already completed, outstanding=0x%lx, doorbell=0x%x\\n\",\n\t\t\t__func__, tag, hba->outstanding_reqs, reg);\n\t\tgoto out;\n\t}\n\n\t/* Print Transfer Request of aborted task */\n\tdev_info(hba->dev, \"%s: Device abort task at tag %d\\n\", __func__, tag);\n\n\t/*\n\t * Print detailed info about aborted request.\n\t * As more than one request might get aborted at the same time,\n\t * print full information only for the first aborted request in order\n\t * to reduce repeated printouts. For other aborted requests only print\n\t * basic details.\n\t */\n\tscsi_print_command(hba->lrb[tag].cmd);\n\tif (!hba->req_abort_count) {\n\t\tufshcd_update_reg_hist(&hba->ufs_stats.task_abort, 0);\n\t\tufshcd_print_host_regs(hba);\n\t\tufshcd_print_host_state(hba);\n\t\tufshcd_print_pwr_info(hba);\n\t\tufshcd_print_trs(hba, 1 << tag, true);\n\t} else {\n\t\tufshcd_print_trs(hba, 1 << tag, false);\n\t}\n\thba->req_abort_count++;\n\n\tif (!(reg & (1 << tag))) {\n\t\tdev_err(hba->dev,\n\t\t\"%s: cmd was completed, but without a notifying intr, tag = %d\",\n\t\t__func__, tag);\n\t\tgoto cleanup;\n\t}\n\n\t/* Skip task abort in case previous aborts failed and report failure */\n\tif (lrbp->req_abort_skip)\n\t\terr = -EIO;\n\telse\n\t\terr = ufshcd_try_to_abort_task(hba, tag);\n\n\tif (!err) {\ncleanup:\n\t\tspin_lock_irqsave(host->host_lock, flags);\n\t\t__ufshcd_transfer_req_compl(hba, (1UL << tag));\n\t\tspin_unlock_irqrestore(host->host_lock, flags);\nout:\n\t\terr = SUCCESS;\n\t} else {\n\t\tdev_err(hba->dev, \"%s: failed with err %d\\n\", __func__, err);\n\t\tufshcd_set_req_abort_skip(hba, hba->outstanding_reqs);\n\t\terr = FAILED;\n\t}\n\n\t/*\n\t * This ufshcd_release() corresponds to the original scsi cmd that got\n\t * aborted here (as we won't get any IRQ for it).\n\t */\n\tufshcd_release(hba);\n\treturn err;\n}\n\n/**\n * ufshcd_host_reset_and_restore - reset and restore host controller\n * @hba: per-adapter instance\n *\n * Note that host controller reset may issue DME_RESET to\n * local and remote (device) Uni-Pro stack and the attributes\n * are reset to default state.\n *\n * Returns zero on success, non-zero on failure\n */\nstatic int ufshcd_host_reset_and_restore(struct ufs_hba *hba)\n{\n\tint err;\n\tunsigned long flags;\n\n\t/*\n\t * Stop the host controller and complete the requests\n\t * cleared by h/w\n\t */\n\tufshcd_hba_stop(hba);\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\thba->silence_err_logs = true;\n\tufshcd_complete_requests(hba);\n\thba->silence_err_logs = false;\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\t/* scale up clocks to max frequency before full reinitialization */\n\tufshcd_set_clk_freq(hba, true);\n\n\terr = ufshcd_hba_enable(hba);\n\tif (err)\n\t\tgoto out;\n\n\t/* Establish the link again and restore the device */\n\terr = ufshcd_probe_hba(hba, false);\n\nout:\n\tif (err)\n\t\tdev_err(hba->dev, \"%s: Host init failed %d\\n\", __func__, err);\n\tufshcd_update_reg_hist(&hba->ufs_stats.host_reset, (u32)err);\n\treturn err;\n}\n\n/**\n * ufshcd_reset_and_restore - reset and re-initialize host/device\n * @hba: per-adapter instance\n *\n * Reset and recover device, host and re-establish link. This\n * is helpful to recover the communication in fatal error conditions.\n *\n * Returns zero on success, non-zero on failure\n */\nstatic int ufshcd_reset_and_restore(struct ufs_hba *hba)\n{\n\tu32 saved_err;\n\tu32 saved_uic_err;\n\tint err = 0;\n\tunsigned long flags;\n\tint retries = MAX_HOST_RESET_RETRIES;\n\n\t/*\n\t * This is a fresh start, cache and clear saved error first,\n\t * in case new error generated during reset and restore.\n\t */\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tsaved_err = hba->saved_err;\n\tsaved_uic_err = hba->saved_uic_err;\n\thba->saved_err = 0;\n\thba->saved_uic_err = 0;\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\tdo {\n\t\t/* Reset the attached device */\n\t\tufshcd_vops_device_reset(hba);\n\n\t\terr = ufshcd_host_reset_and_restore(hba);\n\t} while (err && --retries);\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t/*\n\t * Inform scsi mid-layer that we did reset and allow to handle\n\t * Unit Attention properly.\n\t */\n\tscsi_report_bus_reset(hba->host, 0);\n\tif (err) {\n\t\thba->saved_err |= saved_err;\n\t\thba->saved_uic_err |= saved_uic_err;\n\t}\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\treturn err;\n}\n\n/**\n * ufshcd_eh_host_reset_handler - host reset handler registered to scsi layer\n * @cmd: SCSI command pointer\n *\n * Returns SUCCESS/FAILED\n */\nstatic int ufshcd_eh_host_reset_handler(struct scsi_cmnd *cmd)\n{\n\tint err = SUCCESS;\n\tunsigned long flags;\n\tstruct ufs_hba *hba;\n\n\thba = shost_priv(cmd->device->host);\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\thba->force_reset = true;\n\tufshcd_schedule_eh_work(hba);\n\tdev_err(hba->dev, \"%s: reset in progress - 1\\n\", __func__);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\tflush_work(&hba->eh_work);\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tif (hba->ufshcd_state == UFSHCD_STATE_ERROR)\n\t\terr = FAILED;\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\treturn err;\n}\n\n/**\n * ufshcd_get_max_icc_level - calculate the ICC level\n * @sup_curr_uA: max. current supported by the regulator\n * @start_scan: row at the desc table to start scan from\n * @buff: power descriptor buffer\n *\n * Returns calculated max ICC level for specific regulator\n */\nstatic u32 ufshcd_get_max_icc_level(int sup_curr_uA, u32 start_scan, char *buff)\n{\n\tint i;\n\tint curr_uA;\n\tu16 data;\n\tu16 unit;\n\n\tfor (i = start_scan; i >= 0; i--) {\n\t\tdata = be16_to_cpup((__be16 *)&buff[2 * i]);\n\t\tunit = (data & ATTR_ICC_LVL_UNIT_MASK) >>\n\t\t\t\t\t\tATTR_ICC_LVL_UNIT_OFFSET;\n\t\tcurr_uA = data & ATTR_ICC_LVL_VALUE_MASK;\n\t\tswitch (unit) {\n\t\tcase UFSHCD_NANO_AMP:\n\t\t\tcurr_uA = curr_uA / 1000;\n\t\t\tbreak;\n\t\tcase UFSHCD_MILI_AMP:\n\t\t\tcurr_uA = curr_uA * 1000;\n\t\t\tbreak;\n\t\tcase UFSHCD_AMP:\n\t\t\tcurr_uA = curr_uA * 1000 * 1000;\n\t\t\tbreak;\n\t\tcase UFSHCD_MICRO_AMP:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (sup_curr_uA >= curr_uA)\n\t\t\tbreak;\n\t}\n\tif (i < 0) {\n\t\ti = 0;\n\t\tpr_err(\"%s: Couldn't find valid icc_level = %d\", __func__, i);\n\t}\n\n\treturn (u32)i;\n}\n\n/**\n * ufshcd_calc_icc_level - calculate the max ICC level\n * In case regulators are not initialized we'll return 0\n * @hba: per-adapter instance\n * @desc_buf: power descriptor buffer to extract ICC levels from.\n * @len: length of desc_buff\n *\n * Returns calculated ICC level\n */\nstatic u32 ufshcd_find_max_sup_active_icc_level(struct ufs_hba *hba,\n\t\t\t\t\t\t\tu8 *desc_buf, int len)\n{\n\tu32 icc_level = 0;\n\n\tif (!hba->vreg_info.vcc || !hba->vreg_info.vccq ||\n\t\t\t\t\t\t!hba->vreg_info.vccq2) {\n\t\tdev_err(hba->dev,\n\t\t\t\"%s: Regulator capability was not set, actvIccLevel=%d\",\n\t\t\t\t\t\t\t__func__, icc_level);\n\t\tgoto out;\n\t}\n\n\tif (hba->vreg_info.vcc && hba->vreg_info.vcc->max_uA)\n\t\ticc_level = ufshcd_get_max_icc_level(\n\t\t\t\thba->vreg_info.vcc->max_uA,\n\t\t\t\tPOWER_DESC_MAX_ACTV_ICC_LVLS - 1,\n\t\t\t\t&desc_buf[PWR_DESC_ACTIVE_LVLS_VCC_0]);\n\n\tif (hba->vreg_info.vccq && hba->vreg_info.vccq->max_uA)\n\t\ticc_level = ufshcd_get_max_icc_level(\n\t\t\t\thba->vreg_info.vccq->max_uA,\n\t\t\t\ticc_level,\n\t\t\t\t&desc_buf[PWR_DESC_ACTIVE_LVLS_VCCQ_0]);\n\n\tif (hba->vreg_info.vccq2 && hba->vreg_info.vccq2->max_uA)\n\t\ticc_level = ufshcd_get_max_icc_level(\n\t\t\t\thba->vreg_info.vccq2->max_uA,\n\t\t\t\ticc_level,\n\t\t\t\t&desc_buf[PWR_DESC_ACTIVE_LVLS_VCCQ2_0]);\nout:\n\treturn icc_level;\n}\n\nstatic void ufshcd_set_active_icc_lvl(struct ufs_hba *hba)\n{\n\tint ret;\n\tint buff_len = hba->desc_size[QUERY_DESC_IDN_POWER];\n\tu8 *desc_buf;\n\tu32 icc_level;\n\n\tdesc_buf = kmalloc(buff_len, GFP_KERNEL);\n\tif (!desc_buf)\n\t\treturn;\n\n\tret = ufshcd_read_desc_param(hba, QUERY_DESC_IDN_POWER, 0, 0,\n\t\t\t\t     desc_buf, buff_len);\n\tif (ret) {\n\t\tdev_err(hba->dev,\n\t\t\t\"%s: Failed reading power descriptor.len = %d ret = %d\",\n\t\t\t__func__, buff_len, ret);\n\t\tgoto out;\n\t}\n\n\ticc_level = ufshcd_find_max_sup_active_icc_level(hba, desc_buf,\n\t\t\t\t\t\t\t buff_len);\n\tdev_dbg(hba->dev, \"%s: setting icc_level 0x%x\", __func__, icc_level);\n\n\tret = ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_WRITE_ATTR,\n\t\tQUERY_ATTR_IDN_ACTIVE_ICC_LVL, 0, 0, &icc_level);\n\n\tif (ret)\n\t\tdev_err(hba->dev,\n\t\t\t\"%s: Failed configuring bActiveICCLevel = %d ret = %d\",\n\t\t\t__func__, icc_level, ret);\n\nout:\n\tkfree(desc_buf);\n}\n\nstatic inline void ufshcd_blk_pm_runtime_init(struct scsi_device *sdev)\n{\n\tscsi_autopm_get_device(sdev);\n\tblk_pm_runtime_init(sdev->request_queue, &sdev->sdev_gendev);\n\tif (sdev->rpm_autosuspend)\n\t\tpm_runtime_set_autosuspend_delay(&sdev->sdev_gendev,\n\t\t\t\t\t\t RPM_AUTOSUSPEND_DELAY_MS);\n\tscsi_autopm_put_device(sdev);\n}\n\n/**\n * ufshcd_scsi_add_wlus - Adds required W-LUs\n * @hba: per-adapter instance\n *\n * UFS device specification requires the UFS devices to support 4 well known\n * logical units:\n *\t\"REPORT_LUNS\" (address: 01h)\n *\t\"UFS Device\" (address: 50h)\n *\t\"RPMB\" (address: 44h)\n *\t\"BOOT\" (address: 30h)\n * UFS device's power management needs to be controlled by \"POWER CONDITION\"\n * field of SSU (START STOP UNIT) command. But this \"power condition\" field\n * will take effect only when its sent to \"UFS device\" well known logical unit\n * hence we require the scsi_device instance to represent this logical unit in\n * order for the UFS host driver to send the SSU command for power management.\n *\n * We also require the scsi_device instance for \"RPMB\" (Replay Protected Memory\n * Block) LU so user space process can control this LU. User space may also\n * want to have access to BOOT LU.\n *\n * This function adds scsi device instances for each of all well known LUs\n * (except \"REPORT LUNS\" LU).\n *\n * Returns zero on success (all required W-LUs are added successfully),\n * non-zero error value on failure (if failed to add any of the required W-LU).\n */\nstatic int ufshcd_scsi_add_wlus(struct ufs_hba *hba)\n{\n\tint ret = 0;\n\tstruct scsi_device *sdev_boot;\n\n\thba->sdev_ufs_device = __scsi_add_device(hba->host, 0, 0,\n\t\tufshcd_upiu_wlun_to_scsi_wlun(UFS_UPIU_UFS_DEVICE_WLUN), NULL);\n\tif (IS_ERR(hba->sdev_ufs_device)) {\n\t\tret = PTR_ERR(hba->sdev_ufs_device);\n\t\thba->sdev_ufs_device = NULL;\n\t\tgoto out;\n\t}\n\tufshcd_blk_pm_runtime_init(hba->sdev_ufs_device);\n\tscsi_device_put(hba->sdev_ufs_device);\n\n\thba->sdev_rpmb = __scsi_add_device(hba->host, 0, 0,\n\t\tufshcd_upiu_wlun_to_scsi_wlun(UFS_UPIU_RPMB_WLUN), NULL);\n\tif (IS_ERR(hba->sdev_rpmb)) {\n\t\tret = PTR_ERR(hba->sdev_rpmb);\n\t\tgoto remove_sdev_ufs_device;\n\t}\n\tufshcd_blk_pm_runtime_init(hba->sdev_rpmb);\n\tscsi_device_put(hba->sdev_rpmb);\n\n\tsdev_boot = __scsi_add_device(hba->host, 0, 0,\n\t\tufshcd_upiu_wlun_to_scsi_wlun(UFS_UPIU_BOOT_WLUN), NULL);\n\tif (IS_ERR(sdev_boot)) {\n\t\tdev_err(hba->dev, \"%s: BOOT WLUN not found\\n\", __func__);\n\t} else {\n\t\tufshcd_blk_pm_runtime_init(sdev_boot);\n\t\tscsi_device_put(sdev_boot);\n\t}\n\tgoto out;\n\nremove_sdev_ufs_device:\n\tscsi_remove_device(hba->sdev_ufs_device);\nout:\n\treturn ret;\n}\n\nstatic void ufshcd_wb_probe(struct ufs_hba *hba, u8 *desc_buf)\n{\n\tstruct ufs_dev_info *dev_info = &hba->dev_info;\n\tu8 lun;\n\tu32 d_lu_wb_buf_alloc;\n\n\tif (!ufshcd_is_wb_allowed(hba))\n\t\treturn;\n\t/*\n\t * Probe WB only for UFS-2.2 and UFS-3.1 (and later) devices or\n\t * UFS devices with quirk UFS_DEVICE_QUIRK_SUPPORT_EXTENDED_FEATURES\n\t * enabled\n\t */\n\tif (!(dev_info->wspecversion >= 0x310 ||\n\t      dev_info->wspecversion == 0x220 ||\n\t     (hba->dev_quirks & UFS_DEVICE_QUIRK_SUPPORT_EXTENDED_FEATURES)))\n\t\tgoto wb_disabled;\n\n\tif (hba->desc_size[QUERY_DESC_IDN_DEVICE] <\n\t    DEVICE_DESC_PARAM_EXT_UFS_FEATURE_SUP + 4)\n\t\tgoto wb_disabled;\n\n\tdev_info->d_ext_ufs_feature_sup =\n\t\tget_unaligned_be32(desc_buf +\n\t\t\t\t   DEVICE_DESC_PARAM_EXT_UFS_FEATURE_SUP);\n\n\tif (!(dev_info->d_ext_ufs_feature_sup & UFS_DEV_WRITE_BOOSTER_SUP))\n\t\tgoto wb_disabled;\n\n\t/*\n\t * WB may be supported but not configured while provisioning.\n\t * The spec says, in dedicated wb buffer mode,\n\t * a max of 1 lun would have wb buffer configured.\n\t * Now only shared buffer mode is supported.\n\t */\n\tdev_info->b_wb_buffer_type =\n\t\tdesc_buf[DEVICE_DESC_PARAM_WB_TYPE];\n\n\tdev_info->b_presrv_uspc_en =\n\t\tdesc_buf[DEVICE_DESC_PARAM_WB_PRESRV_USRSPC_EN];\n\n\tif (dev_info->b_wb_buffer_type == WB_BUF_MODE_SHARED) {\n\t\tdev_info->d_wb_alloc_units =\n\t\tget_unaligned_be32(desc_buf +\n\t\t\t\t   DEVICE_DESC_PARAM_WB_SHARED_ALLOC_UNITS);\n\t\tif (!dev_info->d_wb_alloc_units)\n\t\t\tgoto wb_disabled;\n\t} else {\n\t\tfor (lun = 0; lun < UFS_UPIU_MAX_WB_LUN_ID; lun++) {\n\t\t\td_lu_wb_buf_alloc = 0;\n\t\t\tufshcd_read_unit_desc_param(hba,\n\t\t\t\t\tlun,\n\t\t\t\t\tUNIT_DESC_PARAM_WB_BUF_ALLOC_UNITS,\n\t\t\t\t\t(u8 *)&d_lu_wb_buf_alloc,\n\t\t\t\t\tsizeof(d_lu_wb_buf_alloc));\n\t\t\tif (d_lu_wb_buf_alloc) {\n\t\t\t\tdev_info->wb_dedicated_lu = lun;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!d_lu_wb_buf_alloc)\n\t\t\tgoto wb_disabled;\n\t}\n\treturn;\n\nwb_disabled:\n\thba->caps &= ~UFSHCD_CAP_WB_EN;\n}\n\nvoid ufshcd_fixup_dev_quirks(struct ufs_hba *hba, struct ufs_dev_fix *fixups)\n{\n\tstruct ufs_dev_fix *f;\n\tstruct ufs_dev_info *dev_info = &hba->dev_info;\n\n\tif (!fixups)\n\t\treturn;\n\n\tfor (f = fixups; f->quirk; f++) {\n\t\tif ((f->wmanufacturerid == dev_info->wmanufacturerid ||\n\t\t     f->wmanufacturerid == UFS_ANY_VENDOR) &&\n\t\t     ((dev_info->model &&\n\t\t       STR_PRFX_EQUAL(f->model, dev_info->model)) ||\n\t\t      !strcmp(f->model, UFS_ANY_MODEL)))\n\t\t\thba->dev_quirks |= f->quirk;\n\t}\n}\nEXPORT_SYMBOL_GPL(ufshcd_fixup_dev_quirks);\n\nstatic void ufs_fixup_device_setup(struct ufs_hba *hba)\n{\n\t/* fix by general quirk table */\n\tufshcd_fixup_dev_quirks(hba, ufs_fixups);\n\n\t/* allow vendors to fix quirks */\n\tufshcd_vops_fixup_dev_quirks(hba);\n}\n\nstatic int ufs_get_device_desc(struct ufs_hba *hba)\n{\n\tint err;\n\tu8 model_index;\n\tu8 *desc_buf;\n\tstruct ufs_dev_info *dev_info = &hba->dev_info;\n\n\tdesc_buf = kmalloc(QUERY_DESC_MAX_SIZE, GFP_KERNEL);\n\tif (!desc_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = ufshcd_read_desc_param(hba, QUERY_DESC_IDN_DEVICE, 0, 0, desc_buf,\n\t\t\t\t     hba->desc_size[QUERY_DESC_IDN_DEVICE]);\n\tif (err) {\n\t\tdev_err(hba->dev, \"%s: Failed reading Device Desc. err = %d\\n\",\n\t\t\t__func__, err);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * getting vendor (manufacturerID) and Bank Index in big endian\n\t * format\n\t */\n\tdev_info->wmanufacturerid = desc_buf[DEVICE_DESC_PARAM_MANF_ID] << 8 |\n\t\t\t\t     desc_buf[DEVICE_DESC_PARAM_MANF_ID + 1];\n\n\t/* getting Specification Version in big endian format */\n\tdev_info->wspecversion = desc_buf[DEVICE_DESC_PARAM_SPEC_VER] << 8 |\n\t\t\t\t      desc_buf[DEVICE_DESC_PARAM_SPEC_VER + 1];\n\n\tmodel_index = desc_buf[DEVICE_DESC_PARAM_PRDCT_NAME];\n\n\terr = ufshcd_read_string_desc(hba, model_index,\n\t\t\t\t      &dev_info->model, SD_ASCII_STD);\n\tif (err < 0) {\n\t\tdev_err(hba->dev, \"%s: Failed reading Product Name. err = %d\\n\",\n\t\t\t__func__, err);\n\t\tgoto out;\n\t}\n\n\tufs_fixup_device_setup(hba);\n\n\tufshcd_wb_probe(hba, desc_buf);\n\n\t/*\n\t * ufshcd_read_string_desc returns size of the string\n\t * reset the error value\n\t */\n\terr = 0;\n\nout:\n\tkfree(desc_buf);\n\treturn err;\n}\n\nstatic void ufs_put_device_desc(struct ufs_hba *hba)\n{\n\tstruct ufs_dev_info *dev_info = &hba->dev_info;\n\n\tkfree(dev_info->model);\n\tdev_info->model = NULL;\n}\n\n/**\n * ufshcd_tune_pa_tactivate - Tunes PA_TActivate of local UniPro\n * @hba: per-adapter instance\n *\n * PA_TActivate parameter can be tuned manually if UniPro version is less than\n * 1.61. PA_TActivate needs to be greater than or equal to peerM-PHY's\n * RX_MIN_ACTIVATETIME_CAPABILITY attribute. This optimal value can help reduce\n * the hibern8 exit latency.\n *\n * Returns zero on success, non-zero error value on failure.\n */\nstatic int ufshcd_tune_pa_tactivate(struct ufs_hba *hba)\n{\n\tint ret = 0;\n\tu32 peer_rx_min_activatetime = 0, tuned_pa_tactivate;\n\n\tret = ufshcd_dme_peer_get(hba,\n\t\t\t\t  UIC_ARG_MIB_SEL(\n\t\t\t\t\tRX_MIN_ACTIVATETIME_CAPABILITY,\n\t\t\t\t\tUIC_ARG_MPHY_RX_GEN_SEL_INDEX(0)),\n\t\t\t\t  &peer_rx_min_activatetime);\n\tif (ret)\n\t\tgoto out;\n\n\t/* make sure proper unit conversion is applied */\n\ttuned_pa_tactivate =\n\t\t((peer_rx_min_activatetime * RX_MIN_ACTIVATETIME_UNIT_US)\n\t\t / PA_TACTIVATE_TIME_UNIT_US);\n\tret = ufshcd_dme_set(hba, UIC_ARG_MIB(PA_TACTIVATE),\n\t\t\t     tuned_pa_tactivate);\n\nout:\n\treturn ret;\n}\n\n/**\n * ufshcd_tune_pa_hibern8time - Tunes PA_Hibern8Time of local UniPro\n * @hba: per-adapter instance\n *\n * PA_Hibern8Time parameter can be tuned manually if UniPro version is less than\n * 1.61. PA_Hibern8Time needs to be maximum of local M-PHY's\n * TX_HIBERN8TIME_CAPABILITY & peer M-PHY's RX_HIBERN8TIME_CAPABILITY.\n * This optimal value can help reduce the hibern8 exit latency.\n *\n * Returns zero on success, non-zero error value on failure.\n */\nstatic int ufshcd_tune_pa_hibern8time(struct ufs_hba *hba)\n{\n\tint ret = 0;\n\tu32 local_tx_hibern8_time_cap = 0, peer_rx_hibern8_time_cap = 0;\n\tu32 max_hibern8_time, tuned_pa_hibern8time;\n\n\tret = ufshcd_dme_get(hba,\n\t\t\t     UIC_ARG_MIB_SEL(TX_HIBERN8TIME_CAPABILITY,\n\t\t\t\t\tUIC_ARG_MPHY_TX_GEN_SEL_INDEX(0)),\n\t\t\t\t  &local_tx_hibern8_time_cap);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ufshcd_dme_peer_get(hba,\n\t\t\t\t  UIC_ARG_MIB_SEL(RX_HIBERN8TIME_CAPABILITY,\n\t\t\t\t\tUIC_ARG_MPHY_RX_GEN_SEL_INDEX(0)),\n\t\t\t\t  &peer_rx_hibern8_time_cap);\n\tif (ret)\n\t\tgoto out;\n\n\tmax_hibern8_time = max(local_tx_hibern8_time_cap,\n\t\t\t       peer_rx_hibern8_time_cap);\n\t/* make sure proper unit conversion is applied */\n\ttuned_pa_hibern8time = ((max_hibern8_time * HIBERN8TIME_UNIT_US)\n\t\t\t\t/ PA_HIBERN8_TIME_UNIT_US);\n\tret = ufshcd_dme_set(hba, UIC_ARG_MIB(PA_HIBERN8TIME),\n\t\t\t     tuned_pa_hibern8time);\nout:\n\treturn ret;\n}\n\n/**\n * ufshcd_quirk_tune_host_pa_tactivate - Ensures that host PA_TACTIVATE is\n * less than device PA_TACTIVATE time.\n * @hba: per-adapter instance\n *\n * Some UFS devices require host PA_TACTIVATE to be lower than device\n * PA_TACTIVATE, we need to enable UFS_DEVICE_QUIRK_HOST_PA_TACTIVATE quirk\n * for such devices.\n *\n * Returns zero on success, non-zero error value on failure.\n */\nstatic int ufshcd_quirk_tune_host_pa_tactivate(struct ufs_hba *hba)\n{\n\tint ret = 0;\n\tu32 granularity, peer_granularity;\n\tu32 pa_tactivate, peer_pa_tactivate;\n\tu32 pa_tactivate_us, peer_pa_tactivate_us;\n\tu8 gran_to_us_table[] = {1, 4, 8, 16, 32, 100};\n\n\tret = ufshcd_dme_get(hba, UIC_ARG_MIB(PA_GRANULARITY),\n\t\t\t\t  &granularity);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ufshcd_dme_peer_get(hba, UIC_ARG_MIB(PA_GRANULARITY),\n\t\t\t\t  &peer_granularity);\n\tif (ret)\n\t\tgoto out;\n\n\tif ((granularity < PA_GRANULARITY_MIN_VAL) ||\n\t    (granularity > PA_GRANULARITY_MAX_VAL)) {\n\t\tdev_err(hba->dev, \"%s: invalid host PA_GRANULARITY %d\",\n\t\t\t__func__, granularity);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((peer_granularity < PA_GRANULARITY_MIN_VAL) ||\n\t    (peer_granularity > PA_GRANULARITY_MAX_VAL)) {\n\t\tdev_err(hba->dev, \"%s: invalid device PA_GRANULARITY %d\",\n\t\t\t__func__, peer_granularity);\n\t\treturn -EINVAL;\n\t}\n\n\tret = ufshcd_dme_get(hba, UIC_ARG_MIB(PA_TACTIVATE), &pa_tactivate);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ufshcd_dme_peer_get(hba, UIC_ARG_MIB(PA_TACTIVATE),\n\t\t\t\t  &peer_pa_tactivate);\n\tif (ret)\n\t\tgoto out;\n\n\tpa_tactivate_us = pa_tactivate * gran_to_us_table[granularity - 1];\n\tpeer_pa_tactivate_us = peer_pa_tactivate *\n\t\t\t     gran_to_us_table[peer_granularity - 1];\n\n\tif (pa_tactivate_us > peer_pa_tactivate_us) {\n\t\tu32 new_peer_pa_tactivate;\n\n\t\tnew_peer_pa_tactivate = pa_tactivate_us /\n\t\t\t\t      gran_to_us_table[peer_granularity - 1];\n\t\tnew_peer_pa_tactivate++;\n\t\tret = ufshcd_dme_peer_set(hba, UIC_ARG_MIB(PA_TACTIVATE),\n\t\t\t\t\t  new_peer_pa_tactivate);\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic void ufshcd_tune_unipro_params(struct ufs_hba *hba)\n{\n\tif (ufshcd_is_unipro_pa_params_tuning_req(hba)) {\n\t\tufshcd_tune_pa_tactivate(hba);\n\t\tufshcd_tune_pa_hibern8time(hba);\n\t}\n\n\tufshcd_vops_apply_dev_quirks(hba);\n\n\tif (hba->dev_quirks & UFS_DEVICE_QUIRK_PA_TACTIVATE)\n\t\t/* set 1ms timeout for PA_TACTIVATE */\n\t\tufshcd_dme_set(hba, UIC_ARG_MIB(PA_TACTIVATE), 10);\n\n\tif (hba->dev_quirks & UFS_DEVICE_QUIRK_HOST_PA_TACTIVATE)\n\t\tufshcd_quirk_tune_host_pa_tactivate(hba);\n}\n\nstatic void ufshcd_clear_dbg_ufs_stats(struct ufs_hba *hba)\n{\n\thba->ufs_stats.hibern8_exit_cnt = 0;\n\thba->ufs_stats.last_hibern8_exit_tstamp = ktime_set(0, 0);\n\thba->req_abort_count = 0;\n}\n\nstatic int ufshcd_device_geo_params_init(struct ufs_hba *hba)\n{\n\tint err;\n\tsize_t buff_len;\n\tu8 *desc_buf;\n\n\tbuff_len = hba->desc_size[QUERY_DESC_IDN_GEOMETRY];\n\tdesc_buf = kmalloc(buff_len, GFP_KERNEL);\n\tif (!desc_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = ufshcd_read_desc_param(hba, QUERY_DESC_IDN_GEOMETRY, 0, 0,\n\t\t\t\t     desc_buf, buff_len);\n\tif (err) {\n\t\tdev_err(hba->dev, \"%s: Failed reading Geometry Desc. err = %d\\n\",\n\t\t\t\t__func__, err);\n\t\tgoto out;\n\t}\n\n\tif (desc_buf[GEOMETRY_DESC_PARAM_MAX_NUM_LUN] == 1)\n\t\thba->dev_info.max_lu_supported = 32;\n\telse if (desc_buf[GEOMETRY_DESC_PARAM_MAX_NUM_LUN] == 0)\n\t\thba->dev_info.max_lu_supported = 8;\n\nout:\n\tkfree(desc_buf);\n\treturn err;\n}\n\nstatic struct ufs_ref_clk ufs_ref_clk_freqs[] = {\n\t{19200000, REF_CLK_FREQ_19_2_MHZ},\n\t{26000000, REF_CLK_FREQ_26_MHZ},\n\t{38400000, REF_CLK_FREQ_38_4_MHZ},\n\t{52000000, REF_CLK_FREQ_52_MHZ},\n\t{0, REF_CLK_FREQ_INVAL},\n};\n\nstatic enum ufs_ref_clk_freq\nufs_get_bref_clk_from_hz(unsigned long freq)\n{\n\tint i;\n\n\tfor (i = 0; ufs_ref_clk_freqs[i].freq_hz; i++)\n\t\tif (ufs_ref_clk_freqs[i].freq_hz == freq)\n\t\t\treturn ufs_ref_clk_freqs[i].val;\n\n\treturn REF_CLK_FREQ_INVAL;\n}\n\nvoid ufshcd_parse_dev_ref_clk_freq(struct ufs_hba *hba, struct clk *refclk)\n{\n\tunsigned long freq;\n\n\tfreq = clk_get_rate(refclk);\n\n\thba->dev_ref_clk_freq =\n\t\tufs_get_bref_clk_from_hz(freq);\n\n\tif (hba->dev_ref_clk_freq == REF_CLK_FREQ_INVAL)\n\t\tdev_err(hba->dev,\n\t\t\"invalid ref_clk setting = %ld\\n\", freq);\n}\n\nstatic int ufshcd_set_dev_ref_clk(struct ufs_hba *hba)\n{\n\tint err;\n\tu32 ref_clk;\n\tu32 freq = hba->dev_ref_clk_freq;\n\n\terr = ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_READ_ATTR,\n\t\t\tQUERY_ATTR_IDN_REF_CLK_FREQ, 0, 0, &ref_clk);\n\n\tif (err) {\n\t\tdev_err(hba->dev, \"failed reading bRefClkFreq. err = %d\\n\",\n\t\t\terr);\n\t\tgoto out;\n\t}\n\n\tif (ref_clk == freq)\n\t\tgoto out; /* nothing to update */\n\n\terr = ufshcd_query_attr_retry(hba, UPIU_QUERY_OPCODE_WRITE_ATTR,\n\t\t\tQUERY_ATTR_IDN_REF_CLK_FREQ, 0, 0, &freq);\n\n\tif (err) {\n\t\tdev_err(hba->dev, \"bRefClkFreq setting to %lu Hz failed\\n\",\n\t\t\tufs_ref_clk_freqs[freq].freq_hz);\n\t\tgoto out;\n\t}\n\n\tdev_dbg(hba->dev, \"bRefClkFreq setting to %lu Hz succeeded\\n\",\n\t\t\tufs_ref_clk_freqs[freq].freq_hz);\n\nout:\n\treturn err;\n}\n\nstatic int ufshcd_device_params_init(struct ufs_hba *hba)\n{\n\tbool flag;\n\tint ret, i;\n\n\t /* Init device descriptor sizes */\n\tfor (i = 0; i < QUERY_DESC_IDN_MAX; i++)\n\t\thba->desc_size[i] = QUERY_DESC_MAX_SIZE;\n\n\t/* Init UFS geometry descriptor related parameters */\n\tret = ufshcd_device_geo_params_init(hba);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Check and apply UFS device quirks */\n\tret = ufs_get_device_desc(hba);\n\tif (ret) {\n\t\tdev_err(hba->dev, \"%s: Failed getting device info. err = %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto out;\n\t}\n\n\tufshcd_get_ref_clk_gating_wait(hba);\n\n\tif (!ufshcd_query_flag_retry(hba, UPIU_QUERY_OPCODE_READ_FLAG,\n\t\t\tQUERY_FLAG_IDN_PWR_ON_WPE, 0, &flag))\n\t\thba->dev_info.f_power_on_wp_en = flag;\n\n\t/* Probe maximum power mode co-supported by both UFS host and device */\n\tif (ufshcd_get_max_pwr_mode(hba))\n\t\tdev_err(hba->dev,\n\t\t\t\"%s: Failed getting max supported power mode\\n\",\n\t\t\t__func__);\nout:\n\treturn ret;\n}\n\n/**\n * ufshcd_add_lus - probe and add UFS logical units\n * @hba: per-adapter instance\n */\nstatic int ufshcd_add_lus(struct ufs_hba *hba)\n{\n\tint ret;\n\n\t/* Add required well known logical units to scsi mid layer */\n\tret = ufshcd_scsi_add_wlus(hba);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Initialize devfreq after UFS device is detected */\n\tif (ufshcd_is_clkscaling_supported(hba)) {\n\t\tmemcpy(&hba->clk_scaling.saved_pwr_info.info,\n\t\t\t&hba->pwr_info,\n\t\t\tsizeof(struct ufs_pa_layer_attr));\n\t\thba->clk_scaling.saved_pwr_info.is_valid = true;\n\t\tif (!hba->devfreq) {\n\t\t\tret = ufshcd_devfreq_init(hba);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\thba->clk_scaling.is_allowed = true;\n\t}\n\n\tufs_bsg_probe(hba);\n\tscsi_scan_host(hba->host);\n\tpm_runtime_put_sync(hba->dev);\n\nout:\n\treturn ret;\n}\n\nstatic int\nufshcd_send_request_sense(struct ufs_hba *hba, struct scsi_device *sdp);\n\nstatic int ufshcd_clear_ua_wlun(struct ufs_hba *hba, u8 wlun)\n{\n\tstruct scsi_device *sdp;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tif (wlun == UFS_UPIU_UFS_DEVICE_WLUN)\n\t\tsdp = hba->sdev_ufs_device;\n\telse if (wlun == UFS_UPIU_RPMB_WLUN)\n\t\tsdp = hba->sdev_rpmb;\n\telse\n\t\tBUG_ON(1);\n\tif (sdp) {\n\t\tret = scsi_device_get(sdp);\n\t\tif (!ret && !scsi_device_online(sdp)) {\n\t\t\tret = -ENODEV;\n\t\t\tscsi_device_put(sdp);\n\t\t}\n\t} else {\n\t\tret = -ENODEV;\n\t}\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\tif (ret)\n\t\tgoto out_err;\n\n\tret = ufshcd_send_request_sense(hba, sdp);\n\tscsi_device_put(sdp);\nout_err:\n\tif (ret)\n\t\tdev_err(hba->dev, \"%s: UAC clear LU=%x ret = %d\\n\",\n\t\t\t\t__func__, wlun, ret);\n\treturn ret;\n}\n\nstatic int ufshcd_clear_ua_wluns(struct ufs_hba *hba)\n{\n\tint ret = 0;\n\n\tif (!hba->wlun_dev_clr_ua)\n\t\tgoto out;\n\n\tret = ufshcd_clear_ua_wlun(hba, UFS_UPIU_UFS_DEVICE_WLUN);\n\tif (!ret)\n\t\tret = ufshcd_clear_ua_wlun(hba, UFS_UPIU_RPMB_WLUN);\n\tif (!ret)\n\t\thba->wlun_dev_clr_ua = false;\nout:\n\tif (ret)\n\t\tdev_err(hba->dev, \"%s: Failed to clear UAC WLUNS ret = %d\\n\",\n\t\t\t\t__func__, ret);\n\treturn ret;\n}\n\n/**\n * ufshcd_probe_hba - probe hba to detect device and initialize\n * @hba: per-adapter instance\n * @async: asynchronous execution or not\n *\n * Execute link-startup and verify device initialization\n */\nstatic int ufshcd_probe_hba(struct ufs_hba *hba, bool async)\n{\n\tint ret;\n\tunsigned long flags;\n\tktime_t start = ktime_get();\n\n\tret = ufshcd_link_startup(hba);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Debug counters initialization */\n\tufshcd_clear_dbg_ufs_stats(hba);\n\n\t/* UniPro link is active now */\n\tufshcd_set_link_active(hba);\n\n\t/* Verify device initialization by sending NOP OUT UPIU */\n\tret = ufshcd_verify_dev_init(hba);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Initiate UFS initialization, and waiting until completion */\n\tret = ufshcd_complete_dev_init(hba);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Initialize UFS device parameters used by driver, these\n\t * parameters are associated with UFS descriptors.\n\t */\n\tif (async) {\n\t\tret = ufshcd_device_params_init(hba);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tufshcd_tune_unipro_params(hba);\n\n\t/* UFS device is also active now */\n\tufshcd_set_ufs_dev_active(hba);\n\tufshcd_force_reset_auto_bkops(hba);\n\thba->wlun_dev_clr_ua = true;\n\n\t/* Gear up to HS gear if supported */\n\tif (hba->max_pwr_info.is_valid) {\n\t\t/*\n\t\t * Set the right value to bRefClkFreq before attempting to\n\t\t * switch to HS gears.\n\t\t */\n\t\tif (hba->dev_ref_clk_freq != REF_CLK_FREQ_INVAL)\n\t\t\tufshcd_set_dev_ref_clk(hba);\n\t\tret = ufshcd_config_pwr_mode(hba, &hba->max_pwr_info.info);\n\t\tif (ret) {\n\t\t\tdev_err(hba->dev, \"%s: Failed setting power mode, err = %d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tufshcd_print_pwr_info(hba);\n\t}\n\n\t/*\n\t * bActiveICCLevel is volatile for UFS device (as per latest v2.1 spec)\n\t * and for removable UFS card as well, hence always set the parameter.\n\t * Note: Error handler may issue the device reset hence resetting\n\t * bActiveICCLevel as well so it is always safe to set this here.\n\t */\n\tufshcd_set_active_icc_lvl(hba);\n\n\tufshcd_wb_config(hba);\n\t/* Enable Auto-Hibernate if configured */\n\tufshcd_auto_hibern8_enable(hba);\n\nout:\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tif (ret)\n\t\thba->ufshcd_state = UFSHCD_STATE_ERROR;\n\telse if (hba->ufshcd_state == UFSHCD_STATE_RESET)\n\t\thba->ufshcd_state = UFSHCD_STATE_OPERATIONAL;\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\ttrace_ufshcd_init(dev_name(hba->dev), ret,\n\t\tktime_to_us(ktime_sub(ktime_get(), start)),\n\t\thba->curr_dev_pwr_mode, hba->uic_link_state);\n\treturn ret;\n}\n\n/**\n * ufshcd_async_scan - asynchronous execution for probing hba\n * @data: data pointer to pass to this function\n * @cookie: cookie data\n */\nstatic void ufshcd_async_scan(void *data, async_cookie_t cookie)\n{\n\tstruct ufs_hba *hba = (struct ufs_hba *)data;\n\tint ret;\n\n\t/* Initialize hba, detect and initialize UFS device */\n\tret = ufshcd_probe_hba(hba, true);\n\tif (ret)\n\t\tgoto out;\n\n\t/* Probe and add UFS logical units  */\n\tret = ufshcd_add_lus(hba);\nout:\n\t/*\n\t * If we failed to initialize the device or the device is not\n\t * present, turn off the power/clocks etc.\n\t */\n\tif (ret) {\n\t\tpm_runtime_put_sync(hba->dev);\n\t\tufshcd_exit_clk_scaling(hba);\n\t\tufshcd_hba_exit(hba);\n\t} else {\n\t\tufshcd_clear_ua_wluns(hba);\n\t}\n}\n\nstatic const struct attribute_group *ufshcd_driver_groups[] = {\n\t&ufs_sysfs_unit_descriptor_group,\n\t&ufs_sysfs_lun_attributes_group,\n\tNULL,\n};\n\nstatic struct ufs_hba_variant_params ufs_hba_vps = {\n\t.hba_enable_delay_us\t\t= 1000,\n\t.wb_flush_threshold\t\t= UFS_WB_BUF_REMAIN_PERCENT(40),\n\t.devfreq_profile.polling_ms\t= 100,\n\t.devfreq_profile.target\t\t= ufshcd_devfreq_target,\n\t.devfreq_profile.get_dev_status\t= ufshcd_devfreq_get_dev_status,\n\t.ondemand_data.upthreshold\t= 70,\n\t.ondemand_data.downdifferential\t= 5,\n};\n\nstatic struct scsi_host_template ufshcd_driver_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= UFSHCD,\n\t.proc_name\t\t= UFSHCD,\n\t.queuecommand\t\t= ufshcd_queuecommand,\n\t.slave_alloc\t\t= ufshcd_slave_alloc,\n\t.slave_configure\t= ufshcd_slave_configure,\n\t.slave_destroy\t\t= ufshcd_slave_destroy,\n\t.change_queue_depth\t= ufshcd_change_queue_depth,\n\t.eh_abort_handler\t= ufshcd_abort,\n\t.eh_device_reset_handler = ufshcd_eh_device_reset_handler,\n\t.eh_host_reset_handler   = ufshcd_eh_host_reset_handler,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.cmd_per_lun\t\t= UFSHCD_CMD_PER_LUN,\n\t.can_queue\t\t= UFSHCD_CAN_QUEUE,\n\t.max_segment_size\t= PRDT_DATA_BYTE_COUNT_MAX,\n\t.max_host_blocked\t= 1,\n\t.track_queue_depth\t= 1,\n\t.sdev_groups\t\t= ufshcd_driver_groups,\n\t.dma_boundary\t\t= PAGE_SIZE - 1,\n\t.rpm_autosuspend_delay\t= RPM_AUTOSUSPEND_DELAY_MS,\n};\n\nstatic int ufshcd_config_vreg_load(struct device *dev, struct ufs_vreg *vreg,\n\t\t\t\t   int ua)\n{\n\tint ret;\n\n\tif (!vreg)\n\t\treturn 0;\n\n\t/*\n\t * \"set_load\" operation shall be required on those regulators\n\t * which specifically configured current limitation. Otherwise\n\t * zero max_uA may cause unexpected behavior when regulator is\n\t * enabled or set as high power mode.\n\t */\n\tif (!vreg->max_uA)\n\t\treturn 0;\n\n\tret = regulator_set_load(vreg->reg, ua);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: %s set load (ua=%d) failed, err=%d\\n\",\n\t\t\t\t__func__, vreg->name, ua, ret);\n\t}\n\n\treturn ret;\n}\n\nstatic inline int ufshcd_config_vreg_lpm(struct ufs_hba *hba,\n\t\t\t\t\t struct ufs_vreg *vreg)\n{\n\treturn ufshcd_config_vreg_load(hba->dev, vreg, UFS_VREG_LPM_LOAD_UA);\n}\n\nstatic inline int ufshcd_config_vreg_hpm(struct ufs_hba *hba,\n\t\t\t\t\t struct ufs_vreg *vreg)\n{\n\tif (!vreg)\n\t\treturn 0;\n\n\treturn ufshcd_config_vreg_load(hba->dev, vreg, vreg->max_uA);\n}\n\nstatic int ufshcd_config_vreg(struct device *dev,\n\t\tstruct ufs_vreg *vreg, bool on)\n{\n\tint ret = 0;\n\tstruct regulator *reg;\n\tconst char *name;\n\tint min_uV, uA_load;\n\n\tBUG_ON(!vreg);\n\n\treg = vreg->reg;\n\tname = vreg->name;\n\n\tif (regulator_count_voltages(reg) > 0) {\n\t\tuA_load = on ? vreg->max_uA : 0;\n\t\tret = ufshcd_config_vreg_load(dev, vreg, uA_load);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (vreg->min_uV && vreg->max_uV) {\n\t\t\tmin_uV = on ? vreg->min_uV : 0;\n\t\t\tret = regulator_set_voltage(reg, min_uV, vreg->max_uV);\n\t\t\tif (ret)\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"%s: %s set voltage failed, err=%d\\n\",\n\t\t\t\t\t__func__, name, ret);\n\t\t}\n\t}\nout:\n\treturn ret;\n}\n\nstatic int ufshcd_enable_vreg(struct device *dev, struct ufs_vreg *vreg)\n{\n\tint ret = 0;\n\n\tif (!vreg || vreg->enabled)\n\t\tgoto out;\n\n\tret = ufshcd_config_vreg(dev, vreg, true);\n\tif (!ret)\n\t\tret = regulator_enable(vreg->reg);\n\n\tif (!ret)\n\t\tvreg->enabled = true;\n\telse\n\t\tdev_err(dev, \"%s: %s enable failed, err=%d\\n\",\n\t\t\t\t__func__, vreg->name, ret);\nout:\n\treturn ret;\n}\n\nstatic int ufshcd_disable_vreg(struct device *dev, struct ufs_vreg *vreg)\n{\n\tint ret = 0;\n\n\tif (!vreg || !vreg->enabled)\n\t\tgoto out;\n\n\tret = regulator_disable(vreg->reg);\n\n\tif (!ret) {\n\t\t/* ignore errors on applying disable config */\n\t\tufshcd_config_vreg(dev, vreg, false);\n\t\tvreg->enabled = false;\n\t} else {\n\t\tdev_err(dev, \"%s: %s disable failed, err=%d\\n\",\n\t\t\t\t__func__, vreg->name, ret);\n\t}\nout:\n\treturn ret;\n}\n\nstatic int ufshcd_setup_vreg(struct ufs_hba *hba, bool on)\n{\n\tint ret = 0;\n\tstruct device *dev = hba->dev;\n\tstruct ufs_vreg_info *info = &hba->vreg_info;\n\n\tret = ufshcd_toggle_vreg(dev, info->vcc, on);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ufshcd_toggle_vreg(dev, info->vccq, on);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ufshcd_toggle_vreg(dev, info->vccq2, on);\n\nout:\n\tif (ret) {\n\t\tufshcd_toggle_vreg(dev, info->vccq2, false);\n\t\tufshcd_toggle_vreg(dev, info->vccq, false);\n\t\tufshcd_toggle_vreg(dev, info->vcc, false);\n\t}\n\treturn ret;\n}\n\nstatic int ufshcd_setup_hba_vreg(struct ufs_hba *hba, bool on)\n{\n\tstruct ufs_vreg_info *info = &hba->vreg_info;\n\n\treturn ufshcd_toggle_vreg(hba->dev, info->vdd_hba, on);\n}\n\nstatic int ufshcd_get_vreg(struct device *dev, struct ufs_vreg *vreg)\n{\n\tint ret = 0;\n\n\tif (!vreg)\n\t\tgoto out;\n\n\tvreg->reg = devm_regulator_get(dev, vreg->name);\n\tif (IS_ERR(vreg->reg)) {\n\t\tret = PTR_ERR(vreg->reg);\n\t\tdev_err(dev, \"%s: %s get failed, err=%d\\n\",\n\t\t\t\t__func__, vreg->name, ret);\n\t}\nout:\n\treturn ret;\n}\n\nstatic int ufshcd_init_vreg(struct ufs_hba *hba)\n{\n\tint ret = 0;\n\tstruct device *dev = hba->dev;\n\tstruct ufs_vreg_info *info = &hba->vreg_info;\n\n\tret = ufshcd_get_vreg(dev, info->vcc);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ufshcd_get_vreg(dev, info->vccq);\n\tif (!ret)\n\t\tret = ufshcd_get_vreg(dev, info->vccq2);\nout:\n\treturn ret;\n}\n\nstatic int ufshcd_init_hba_vreg(struct ufs_hba *hba)\n{\n\tstruct ufs_vreg_info *info = &hba->vreg_info;\n\n\tif (info)\n\t\treturn ufshcd_get_vreg(hba->dev, info->vdd_hba);\n\n\treturn 0;\n}\n\nstatic int ufshcd_setup_clocks(struct ufs_hba *hba, bool on)\n{\n\tint ret = 0;\n\tstruct ufs_clk_info *clki;\n\tstruct list_head *head = &hba->clk_list_head;\n\tunsigned long flags;\n\tktime_t start = ktime_get();\n\tbool clk_state_changed = false;\n\n\tif (list_empty(head))\n\t\tgoto out;\n\n\tret = ufshcd_vops_setup_clocks(hba, on, PRE_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\n\tlist_for_each_entry(clki, head, list) {\n\t\tif (!IS_ERR_OR_NULL(clki->clk)) {\n\t\t\t/*\n\t\t\t * Don't disable clocks which are needed\n\t\t\t * to keep the link active.\n\t\t\t */\n\t\t\tif (ufshcd_is_link_active(hba) &&\n\t\t\t    clki->keep_link_active)\n\t\t\t\tcontinue;\n\n\t\t\tclk_state_changed = on ^ clki->enabled;\n\t\t\tif (on && !clki->enabled) {\n\t\t\t\tret = clk_prepare_enable(clki->clk);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(hba->dev, \"%s: %s prepare enable failed, %d\\n\",\n\t\t\t\t\t\t__func__, clki->name, ret);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else if (!on && clki->enabled) {\n\t\t\t\tclk_disable_unprepare(clki->clk);\n\t\t\t}\n\t\t\tclki->enabled = on;\n\t\t\tdev_dbg(hba->dev, \"%s: clk: %s %sabled\\n\", __func__,\n\t\t\t\t\tclki->name, on ? \"en\" : \"dis\");\n\t\t}\n\t}\n\n\tret = ufshcd_vops_setup_clocks(hba, on, POST_CHANGE);\n\tif (ret)\n\t\treturn ret;\n\nout:\n\tif (ret) {\n\t\tlist_for_each_entry(clki, head, list) {\n\t\t\tif (!IS_ERR_OR_NULL(clki->clk) && clki->enabled)\n\t\t\t\tclk_disable_unprepare(clki->clk);\n\t\t}\n\t} else if (!ret && on) {\n\t\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t\thba->clk_gating.state = CLKS_ON;\n\t\ttrace_ufshcd_clk_gating(dev_name(hba->dev),\n\t\t\t\t\thba->clk_gating.state);\n\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t}\n\n\tif (clk_state_changed)\n\t\ttrace_ufshcd_profile_clk_gating(dev_name(hba->dev),\n\t\t\t(on ? \"on\" : \"off\"),\n\t\t\tktime_to_us(ktime_sub(ktime_get(), start)), ret);\n\treturn ret;\n}\n\nstatic int ufshcd_init_clocks(struct ufs_hba *hba)\n{\n\tint ret = 0;\n\tstruct ufs_clk_info *clki;\n\tstruct device *dev = hba->dev;\n\tstruct list_head *head = &hba->clk_list_head;\n\n\tif (list_empty(head))\n\t\tgoto out;\n\n\tlist_for_each_entry(clki, head, list) {\n\t\tif (!clki->name)\n\t\t\tcontinue;\n\n\t\tclki->clk = devm_clk_get(dev, clki->name);\n\t\tif (IS_ERR(clki->clk)) {\n\t\t\tret = PTR_ERR(clki->clk);\n\t\t\tdev_err(dev, \"%s: %s clk get failed, %d\\n\",\n\t\t\t\t\t__func__, clki->name, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Parse device ref clk freq as per device tree \"ref_clk\".\n\t\t * Default dev_ref_clk_freq is set to REF_CLK_FREQ_INVAL\n\t\t * in ufshcd_alloc_host().\n\t\t */\n\t\tif (!strcmp(clki->name, \"ref_clk\"))\n\t\t\tufshcd_parse_dev_ref_clk_freq(hba, clki->clk);\n\n\t\tif (clki->max_freq) {\n\t\t\tret = clk_set_rate(clki->clk, clki->max_freq);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(hba->dev, \"%s: %s clk set rate(%dHz) failed, %d\\n\",\n\t\t\t\t\t__func__, clki->name,\n\t\t\t\t\tclki->max_freq, ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tclki->curr_freq = clki->max_freq;\n\t\t}\n\t\tdev_dbg(dev, \"%s: clk: %s, rate: %lu\\n\", __func__,\n\t\t\t\tclki->name, clk_get_rate(clki->clk));\n\t}\nout:\n\treturn ret;\n}\n\nstatic int ufshcd_variant_hba_init(struct ufs_hba *hba)\n{\n\tint err = 0;\n\n\tif (!hba->vops)\n\t\tgoto out;\n\n\terr = ufshcd_vops_init(hba);\n\tif (err)\n\t\tgoto out;\n\n\terr = ufshcd_vops_setup_regulators(hba, true);\n\tif (err)\n\t\tufshcd_vops_exit(hba);\nout:\n\tif (err)\n\t\tdev_err(hba->dev, \"%s: variant %s init failed err %d\\n\",\n\t\t\t__func__, ufshcd_get_var_name(hba), err);\n\treturn err;\n}\n\nstatic void ufshcd_variant_hba_exit(struct ufs_hba *hba)\n{\n\tif (!hba->vops)\n\t\treturn;\n\n\tufshcd_vops_setup_regulators(hba, false);\n\n\tufshcd_vops_exit(hba);\n}\n\nstatic int ufshcd_hba_init(struct ufs_hba *hba)\n{\n\tint err;\n\n\t/*\n\t * Handle host controller power separately from the UFS device power\n\t * rails as it will help controlling the UFS host controller power\n\t * collapse easily which is different than UFS device power collapse.\n\t * Also, enable the host controller power before we go ahead with rest\n\t * of the initialization here.\n\t */\n\terr = ufshcd_init_hba_vreg(hba);\n\tif (err)\n\t\tgoto out;\n\n\terr = ufshcd_setup_hba_vreg(hba, true);\n\tif (err)\n\t\tgoto out;\n\n\terr = ufshcd_init_clocks(hba);\n\tif (err)\n\t\tgoto out_disable_hba_vreg;\n\n\terr = ufshcd_setup_clocks(hba, true);\n\tif (err)\n\t\tgoto out_disable_hba_vreg;\n\n\terr = ufshcd_init_vreg(hba);\n\tif (err)\n\t\tgoto out_disable_clks;\n\n\terr = ufshcd_setup_vreg(hba, true);\n\tif (err)\n\t\tgoto out_disable_clks;\n\n\terr = ufshcd_variant_hba_init(hba);\n\tif (err)\n\t\tgoto out_disable_vreg;\n\n\thba->is_powered = true;\n\tgoto out;\n\nout_disable_vreg:\n\tufshcd_setup_vreg(hba, false);\nout_disable_clks:\n\tufshcd_setup_clocks(hba, false);\nout_disable_hba_vreg:\n\tufshcd_setup_hba_vreg(hba, false);\nout:\n\treturn err;\n}\n\nstatic void ufshcd_hba_exit(struct ufs_hba *hba)\n{\n\tif (hba->is_powered) {\n\t\tufshcd_variant_hba_exit(hba);\n\t\tufshcd_setup_vreg(hba, false);\n\t\tufshcd_suspend_clkscaling(hba);\n\t\tif (ufshcd_is_clkscaling_supported(hba))\n\t\t\tif (hba->devfreq)\n\t\t\t\tufshcd_suspend_clkscaling(hba);\n\t\tufshcd_setup_clocks(hba, false);\n\t\tufshcd_setup_hba_vreg(hba, false);\n\t\thba->is_powered = false;\n\t\tufs_put_device_desc(hba);\n\t}\n}\n\nstatic int\nufshcd_send_request_sense(struct ufs_hba *hba, struct scsi_device *sdp)\n{\n\tunsigned char cmd[6] = {REQUEST_SENSE,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tUFS_SENSE_SIZE,\n\t\t\t\t0};\n\tchar *buffer;\n\tint ret;\n\n\tbuffer = kzalloc(UFS_SENSE_SIZE, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = scsi_execute(sdp, cmd, DMA_FROM_DEVICE, buffer,\n\t\t\tUFS_SENSE_SIZE, NULL, NULL,\n\t\t\tmsecs_to_jiffies(1000), 3, 0, RQF_PM, NULL);\n\tif (ret)\n\t\tpr_err(\"%s: failed with err %d\\n\", __func__, ret);\n\n\tkfree(buffer);\nout:\n\treturn ret;\n}\n\n/**\n * ufshcd_set_dev_pwr_mode - sends START STOP UNIT command to set device\n *\t\t\t     power mode\n * @hba: per adapter instance\n * @pwr_mode: device power mode to set\n *\n * Returns 0 if requested power mode is set successfully\n * Returns non-zero if failed to set the requested power mode\n */\nstatic int ufshcd_set_dev_pwr_mode(struct ufs_hba *hba,\n\t\t\t\t     enum ufs_dev_pwr_mode pwr_mode)\n{\n\tunsigned char cmd[6] = { START_STOP };\n\tstruct scsi_sense_hdr sshdr;\n\tstruct scsi_device *sdp;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tsdp = hba->sdev_ufs_device;\n\tif (sdp) {\n\t\tret = scsi_device_get(sdp);\n\t\tif (!ret && !scsi_device_online(sdp)) {\n\t\t\tret = -ENODEV;\n\t\t\tscsi_device_put(sdp);\n\t\t}\n\t} else {\n\t\tret = -ENODEV;\n\t}\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If scsi commands fail, the scsi mid-layer schedules scsi error-\n\t * handling, which would wait for host to be resumed. Since we know\n\t * we are functional while we are here, skip host resume in error\n\t * handling context.\n\t */\n\thba->host->eh_noresume = 1;\n\tif (hba->wlun_dev_clr_ua) {\n\t\tret = ufshcd_send_request_sense(hba, sdp);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/* Unit attention condition is cleared now */\n\t\thba->wlun_dev_clr_ua = false;\n\t}\n\n\tcmd[4] = pwr_mode << 4;\n\n\t/*\n\t * Current function would be generally called from the power management\n\t * callbacks hence set the RQF_PM flag so that it doesn't resume the\n\t * already suspended childs.\n\t */\n\tret = scsi_execute(sdp, cmd, DMA_NONE, NULL, 0, NULL, &sshdr,\n\t\t\tSTART_STOP_TIMEOUT, 0, 0, RQF_PM, NULL);\n\tif (ret) {\n\t\tsdev_printk(KERN_WARNING, sdp,\n\t\t\t    \"START_STOP failed for power mode: %d, result %x\\n\",\n\t\t\t    pwr_mode, ret);\n\t\tif (driver_byte(ret) == DRIVER_SENSE)\n\t\t\tscsi_print_sense_hdr(sdp, NULL, &sshdr);\n\t}\n\n\tif (!ret)\n\t\thba->curr_dev_pwr_mode = pwr_mode;\nout:\n\tscsi_device_put(sdp);\n\thba->host->eh_noresume = 0;\n\treturn ret;\n}\n\nstatic int ufshcd_link_state_transition(struct ufs_hba *hba,\n\t\t\t\t\tenum uic_link_state req_link_state,\n\t\t\t\t\tint check_for_bkops)\n{\n\tint ret = 0;\n\n\tif (req_link_state == hba->uic_link_state)\n\t\treturn 0;\n\n\tif (req_link_state == UIC_LINK_HIBERN8_STATE) {\n\t\tret = ufshcd_uic_hibern8_enter(hba);\n\t\tif (!ret) {\n\t\t\tufshcd_set_link_hibern8(hba);\n\t\t} else {\n\t\t\tdev_err(hba->dev, \"%s: hibern8 enter failed %d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/*\n\t * If autobkops is enabled, link can't be turned off because\n\t * turning off the link would also turn off the device, except in the\n\t * case of DeepSleep where the device is expected to remain powered.\n\t */\n\telse if ((req_link_state == UIC_LINK_OFF_STATE) &&\n\t\t (!check_for_bkops || !hba->auto_bkops_enabled)) {\n\t\t/*\n\t\t * Let's make sure that link is in low power mode, we are doing\n\t\t * this currently by putting the link in Hibern8. Otherway to\n\t\t * put the link in low power mode is to send the DME end point\n\t\t * to device and then send the DME reset command to local\n\t\t * unipro. But putting the link in hibern8 is much faster.\n\t\t *\n\t\t * Note also that putting the link in Hibern8 is a requirement\n\t\t * for entering DeepSleep.\n\t\t */\n\t\tret = ufshcd_uic_hibern8_enter(hba);\n\t\tif (ret) {\n\t\t\tdev_err(hba->dev, \"%s: hibern8 enter failed %d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * Change controller state to \"reset state\" which\n\t\t * should also put the link in off/reset state\n\t\t */\n\t\tufshcd_hba_stop(hba);\n\t\t/*\n\t\t * TODO: Check if we need any delay to make sure that\n\t\t * controller is reset\n\t\t */\n\t\tufshcd_set_link_off(hba);\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic void ufshcd_vreg_set_lpm(struct ufs_hba *hba)\n{\n\tbool vcc_off = false;\n\n\t/*\n\t * It seems some UFS devices may keep drawing more than sleep current\n\t * (atleast for 500us) from UFS rails (especially from VCCQ rail).\n\t * To avoid this situation, add 2ms delay before putting these UFS\n\t * rails in LPM mode.\n\t */\n\tif (!ufshcd_is_link_active(hba) &&\n\t    hba->dev_quirks & UFS_DEVICE_QUIRK_DELAY_BEFORE_LPM)\n\t\tusleep_range(2000, 2100);\n\n\t/*\n\t * If UFS device is either in UFS_Sleep turn off VCC rail to save some\n\t * power.\n\t *\n\t * If UFS device and link is in OFF state, all power supplies (VCC,\n\t * VCCQ, VCCQ2) can be turned off if power on write protect is not\n\t * required. If UFS link is inactive (Hibern8 or OFF state) and device\n\t * is in sleep state, put VCCQ & VCCQ2 rails in LPM mode.\n\t *\n\t * Ignore the error returned by ufshcd_toggle_vreg() as device is anyway\n\t * in low power state which would save some power.\n\t *\n\t * If Write Booster is enabled and the device needs to flush the WB\n\t * buffer OR if bkops status is urgent for WB, keep Vcc on.\n\t */\n\tif (ufshcd_is_ufs_dev_poweroff(hba) && ufshcd_is_link_off(hba) &&\n\t    !hba->dev_info.is_lu_power_on_wp) {\n\t\tufshcd_setup_vreg(hba, false);\n\t\tvcc_off = true;\n\t} else if (!ufshcd_is_ufs_dev_active(hba)) {\n\t\tufshcd_toggle_vreg(hba->dev, hba->vreg_info.vcc, false);\n\t\tvcc_off = true;\n\t\tif (!ufshcd_is_link_active(hba)) {\n\t\t\tufshcd_config_vreg_lpm(hba, hba->vreg_info.vccq);\n\t\t\tufshcd_config_vreg_lpm(hba, hba->vreg_info.vccq2);\n\t\t}\n\t}\n\n\t/*\n\t * Some UFS devices require delay after VCC power rail is turned-off.\n\t */\n\tif (vcc_off && hba->vreg_info.vcc &&\n\t\thba->dev_quirks & UFS_DEVICE_QUIRK_DELAY_AFTER_LPM)\n\t\tusleep_range(5000, 5100);\n}\n\nstatic int ufshcd_vreg_set_hpm(struct ufs_hba *hba)\n{\n\tint ret = 0;\n\n\tif (ufshcd_is_ufs_dev_poweroff(hba) && ufshcd_is_link_off(hba) &&\n\t    !hba->dev_info.is_lu_power_on_wp) {\n\t\tret = ufshcd_setup_vreg(hba, true);\n\t} else if (!ufshcd_is_ufs_dev_active(hba)) {\n\t\tif (!ret && !ufshcd_is_link_active(hba)) {\n\t\t\tret = ufshcd_config_vreg_hpm(hba, hba->vreg_info.vccq);\n\t\t\tif (ret)\n\t\t\t\tgoto vcc_disable;\n\t\t\tret = ufshcd_config_vreg_hpm(hba, hba->vreg_info.vccq2);\n\t\t\tif (ret)\n\t\t\t\tgoto vccq_lpm;\n\t\t}\n\t\tret = ufshcd_toggle_vreg(hba->dev, hba->vreg_info.vcc, true);\n\t}\n\tgoto out;\n\nvccq_lpm:\n\tufshcd_config_vreg_lpm(hba, hba->vreg_info.vccq);\nvcc_disable:\n\tufshcd_toggle_vreg(hba->dev, hba->vreg_info.vcc, false);\nout:\n\treturn ret;\n}\n\nstatic void ufshcd_hba_vreg_set_lpm(struct ufs_hba *hba)\n{\n\tif (ufshcd_is_link_off(hba) || ufshcd_can_aggressive_pc(hba))\n\t\tufshcd_setup_hba_vreg(hba, false);\n}\n\nstatic void ufshcd_hba_vreg_set_hpm(struct ufs_hba *hba)\n{\n\tif (ufshcd_is_link_off(hba) || ufshcd_can_aggressive_pc(hba))\n\t\tufshcd_setup_hba_vreg(hba, true);\n}\n\n/**\n * ufshcd_suspend - helper function for suspend operations\n * @hba: per adapter instance\n * @pm_op: desired low power operation type\n *\n * This function will try to put the UFS device and link into low power\n * mode based on the \"rpm_lvl\" (Runtime PM level) or \"spm_lvl\"\n * (System PM level).\n *\n * If this function is called during shutdown, it will make sure that\n * both UFS device and UFS link is powered off.\n *\n * NOTE: UFS device & link must be active before we enter in this function.\n *\n * Returns 0 for success and non-zero for failure\n */\nstatic int ufshcd_suspend(struct ufs_hba *hba, enum ufs_pm_op pm_op)\n{\n\tint ret = 0;\n\tint check_for_bkops;\n\tenum ufs_pm_level pm_lvl;\n\tenum ufs_dev_pwr_mode req_dev_pwr_mode;\n\tenum uic_link_state req_link_state;\n\n\thba->pm_op_in_progress = 1;\n\tif (!ufshcd_is_shutdown_pm(pm_op)) {\n\t\tpm_lvl = ufshcd_is_runtime_pm(pm_op) ?\n\t\t\t hba->rpm_lvl : hba->spm_lvl;\n\t\treq_dev_pwr_mode = ufs_get_pm_lvl_to_dev_pwr_mode(pm_lvl);\n\t\treq_link_state = ufs_get_pm_lvl_to_link_pwr_state(pm_lvl);\n\t} else {\n\t\treq_dev_pwr_mode = UFS_POWERDOWN_PWR_MODE;\n\t\treq_link_state = UIC_LINK_OFF_STATE;\n\t}\n\n\t/*\n\t * If we can't transition into any of the low power modes\n\t * just gate the clocks.\n\t */\n\tufshcd_hold(hba, false);\n\thba->clk_gating.is_suspended = true;\n\n\tif (hba->clk_scaling.is_allowed) {\n\t\tcancel_work_sync(&hba->clk_scaling.suspend_work);\n\t\tcancel_work_sync(&hba->clk_scaling.resume_work);\n\t\tufshcd_suspend_clkscaling(hba);\n\t}\n\n\tif (req_dev_pwr_mode == UFS_ACTIVE_PWR_MODE &&\n\t\t\treq_link_state == UIC_LINK_ACTIVE_STATE) {\n\t\tgoto disable_clks;\n\t}\n\n\tif ((req_dev_pwr_mode == hba->curr_dev_pwr_mode) &&\n\t    (req_link_state == hba->uic_link_state))\n\t\tgoto enable_gating;\n\n\t/* UFS device & link must be active before we enter in this function */\n\tif (!ufshcd_is_ufs_dev_active(hba) || !ufshcd_is_link_active(hba)) {\n\t\tret = -EINVAL;\n\t\tgoto enable_gating;\n\t}\n\n\tif (ufshcd_is_runtime_pm(pm_op)) {\n\t\tif (ufshcd_can_autobkops_during_suspend(hba)) {\n\t\t\t/*\n\t\t\t * The device is idle with no requests in the queue,\n\t\t\t * allow background operations if bkops status shows\n\t\t\t * that performance might be impacted.\n\t\t\t */\n\t\t\tret = ufshcd_urgent_bkops(hba);\n\t\t\tif (ret)\n\t\t\t\tgoto enable_gating;\n\t\t} else {\n\t\t\t/* make sure that auto bkops is disabled */\n\t\t\tufshcd_disable_auto_bkops(hba);\n\t\t}\n\t\t/*\n\t\t * If device needs to do BKOP or WB buffer flush during\n\t\t * Hibern8, keep device power mode as \"active power mode\"\n\t\t * and VCC supply.\n\t\t */\n\t\thba->dev_info.b_rpm_dev_flush_capable =\n\t\t\thba->auto_bkops_enabled ||\n\t\t\t(((req_link_state == UIC_LINK_HIBERN8_STATE) ||\n\t\t\t((req_link_state == UIC_LINK_ACTIVE_STATE) &&\n\t\t\tufshcd_is_auto_hibern8_enabled(hba))) &&\n\t\t\tufshcd_wb_need_flush(hba));\n\t}\n\n\tif (req_dev_pwr_mode != hba->curr_dev_pwr_mode) {\n\t\tif (!ufshcd_is_runtime_pm(pm_op))\n\t\t\t/* ensure that bkops is disabled */\n\t\t\tufshcd_disable_auto_bkops(hba);\n\n\t\tif (!hba->dev_info.b_rpm_dev_flush_capable) {\n\t\t\tret = ufshcd_set_dev_pwr_mode(hba, req_dev_pwr_mode);\n\t\t\tif (ret)\n\t\t\t\tgoto enable_gating;\n\t\t}\n\t}\n\n\tflush_work(&hba->eeh_work);\n\n\t/*\n\t * In the case of DeepSleep, the device is expected to remain powered\n\t * with the link off, so do not check for bkops.\n\t */\n\tcheck_for_bkops = !ufshcd_is_ufs_dev_deepsleep(hba);\n\tret = ufshcd_link_state_transition(hba, req_link_state, check_for_bkops);\n\tif (ret)\n\t\tgoto set_dev_active;\n\n\tufshcd_vreg_set_lpm(hba);\n\ndisable_clks:\n\t/*\n\t * Call vendor specific suspend callback. As these callbacks may access\n\t * vendor specific host controller register space call them before the\n\t * host clocks are ON.\n\t */\n\tret = ufshcd_vops_suspend(hba, pm_op);\n\tif (ret)\n\t\tgoto set_link_active;\n\t/*\n\t * Disable the host irq as host controller as there won't be any\n\t * host controller transaction expected till resume.\n\t */\n\tufshcd_disable_irq(hba);\n\n\tufshcd_setup_clocks(hba, false);\n\n\tif (ufshcd_is_clkgating_allowed(hba)) {\n\t\thba->clk_gating.state = CLKS_OFF;\n\t\ttrace_ufshcd_clk_gating(dev_name(hba->dev),\n\t\t\t\t\thba->clk_gating.state);\n\t}\n\n\t/* Put the host controller in low power mode if possible */\n\tufshcd_hba_vreg_set_lpm(hba);\n\tgoto out;\n\nset_link_active:\n\tif (hba->clk_scaling.is_allowed)\n\t\tufshcd_resume_clkscaling(hba);\n\tufshcd_vreg_set_hpm(hba);\n\t/*\n\t * Device hardware reset is required to exit DeepSleep. Also, for\n\t * DeepSleep, the link is off so host reset and restore will be done\n\t * further below.\n\t */\n\tif (ufshcd_is_ufs_dev_deepsleep(hba)) {\n\t\tufshcd_vops_device_reset(hba);\n\t\tWARN_ON(!ufshcd_is_link_off(hba));\n\t}\n\tif (ufshcd_is_link_hibern8(hba) && !ufshcd_uic_hibern8_exit(hba))\n\t\tufshcd_set_link_active(hba);\n\telse if (ufshcd_is_link_off(hba))\n\t\tufshcd_host_reset_and_restore(hba);\nset_dev_active:\n\t/* Can also get here needing to exit DeepSleep */\n\tif (ufshcd_is_ufs_dev_deepsleep(hba)) {\n\t\tufshcd_vops_device_reset(hba);\n\t\tufshcd_host_reset_and_restore(hba);\n\t}\n\tif (!ufshcd_set_dev_pwr_mode(hba, UFS_ACTIVE_PWR_MODE))\n\t\tufshcd_disable_auto_bkops(hba);\nenable_gating:\n\tif (hba->clk_scaling.is_allowed)\n\t\tufshcd_resume_clkscaling(hba);\n\thba->clk_gating.is_suspended = false;\n\thba->dev_info.b_rpm_dev_flush_capable = false;\n\tufshcd_release(hba);\nout:\n\tif (hba->dev_info.b_rpm_dev_flush_capable) {\n\t\tschedule_delayed_work(&hba->rpm_dev_flush_recheck_work,\n\t\t\tmsecs_to_jiffies(RPM_DEV_FLUSH_RECHECK_WORK_DELAY_MS));\n\t}\n\n\thba->pm_op_in_progress = 0;\n\n\tif (ret)\n\t\tufshcd_update_reg_hist(&hba->ufs_stats.suspend_err, (u32)ret);\n\treturn ret;\n}\n\n/**\n * ufshcd_resume - helper function for resume operations\n * @hba: per adapter instance\n * @pm_op: runtime PM or system PM\n *\n * This function basically brings the UFS device, UniPro link and controller\n * to active state.\n *\n * Returns 0 for success and non-zero for failure\n */\nstatic int ufshcd_resume(struct ufs_hba *hba, enum ufs_pm_op pm_op)\n{\n\tint ret;\n\tenum uic_link_state old_link_state;\n\n\thba->pm_op_in_progress = 1;\n\told_link_state = hba->uic_link_state;\n\n\tufshcd_hba_vreg_set_hpm(hba);\n\t/* Make sure clocks are enabled before accessing controller */\n\tret = ufshcd_setup_clocks(hba, true);\n\tif (ret)\n\t\tgoto out;\n\n\t/* enable the host irq as host controller would be active soon */\n\tufshcd_enable_irq(hba);\n\n\tret = ufshcd_vreg_set_hpm(hba);\n\tif (ret)\n\t\tgoto disable_irq_and_vops_clks;\n\n\t/*\n\t * Call vendor specific resume callback. As these callbacks may access\n\t * vendor specific host controller register space call them when the\n\t * host clocks are ON.\n\t */\n\tret = ufshcd_vops_resume(hba, pm_op);\n\tif (ret)\n\t\tgoto disable_vreg;\n\n\t/* For DeepSleep, the only supported option is to have the link off */\n\tWARN_ON(ufshcd_is_ufs_dev_deepsleep(hba) && !ufshcd_is_link_off(hba));\n\n\tif (ufshcd_is_link_hibern8(hba)) {\n\t\tret = ufshcd_uic_hibern8_exit(hba);\n\t\tif (!ret) {\n\t\t\tufshcd_set_link_active(hba);\n\t\t} else {\n\t\t\tdev_err(hba->dev, \"%s: hibern8 exit failed %d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\tgoto vendor_suspend;\n\t\t}\n\t} else if (ufshcd_is_link_off(hba)) {\n\t\t/*\n\t\t * A full initialization of the host and the device is\n\t\t * required since the link was put to off during suspend.\n\t\t * Note, in the case of DeepSleep, the device will exit\n\t\t * DeepSleep due to device reset.\n\t\t */\n\t\tret = ufshcd_reset_and_restore(hba);\n\t\t/*\n\t\t * ufshcd_reset_and_restore() should have already\n\t\t * set the link state as active\n\t\t */\n\t\tif (ret || !ufshcd_is_link_active(hba))\n\t\t\tgoto vendor_suspend;\n\t}\n\n\tif (!ufshcd_is_ufs_dev_active(hba)) {\n\t\tret = ufshcd_set_dev_pwr_mode(hba, UFS_ACTIVE_PWR_MODE);\n\t\tif (ret)\n\t\t\tgoto set_old_link_state;\n\t}\n\n\tif (ufshcd_keep_autobkops_enabled_except_suspend(hba))\n\t\tufshcd_enable_auto_bkops(hba);\n\telse\n\t\t/*\n\t\t * If BKOPs operations are urgently needed at this moment then\n\t\t * keep auto-bkops enabled or else disable it.\n\t\t */\n\t\tufshcd_urgent_bkops(hba);\n\n\thba->clk_gating.is_suspended = false;\n\n\tif (hba->clk_scaling.is_allowed)\n\t\tufshcd_resume_clkscaling(hba);\n\n\t/* Enable Auto-Hibernate if configured */\n\tufshcd_auto_hibern8_enable(hba);\n\n\tif (hba->dev_info.b_rpm_dev_flush_capable) {\n\t\thba->dev_info.b_rpm_dev_flush_capable = false;\n\t\tcancel_delayed_work(&hba->rpm_dev_flush_recheck_work);\n\t}\n\n\t/* Schedule clock gating in case of no access to UFS device yet */\n\tufshcd_release(hba);\n\n\tgoto out;\n\nset_old_link_state:\n\tufshcd_link_state_transition(hba, old_link_state, 0);\nvendor_suspend:\n\tufshcd_vops_suspend(hba, pm_op);\ndisable_vreg:\n\tufshcd_vreg_set_lpm(hba);\ndisable_irq_and_vops_clks:\n\tufshcd_disable_irq(hba);\n\tif (hba->clk_scaling.is_allowed)\n\t\tufshcd_suspend_clkscaling(hba);\n\tufshcd_setup_clocks(hba, false);\n\tif (ufshcd_is_clkgating_allowed(hba)) {\n\t\thba->clk_gating.state = CLKS_OFF;\n\t\ttrace_ufshcd_clk_gating(dev_name(hba->dev),\n\t\t\t\t\thba->clk_gating.state);\n\t}\nout:\n\thba->pm_op_in_progress = 0;\n\tif (ret)\n\t\tufshcd_update_reg_hist(&hba->ufs_stats.resume_err, (u32)ret);\n\treturn ret;\n}\n\n/**\n * ufshcd_system_suspend - system suspend routine\n * @hba: per adapter instance\n *\n * Check the description of ufshcd_suspend() function for more details.\n *\n * Returns 0 for success and non-zero for failure\n */\nint ufshcd_system_suspend(struct ufs_hba *hba)\n{\n\tint ret = 0;\n\tktime_t start = ktime_get();\n\n\tif (!hba || !hba->is_powered)\n\t\treturn 0;\n\n\tif ((ufs_get_pm_lvl_to_dev_pwr_mode(hba->spm_lvl) ==\n\t     hba->curr_dev_pwr_mode) &&\n\t    (ufs_get_pm_lvl_to_link_pwr_state(hba->spm_lvl) ==\n\t     hba->uic_link_state))\n\t\tgoto out;\n\n\tif (pm_runtime_suspended(hba->dev)) {\n\t\t/*\n\t\t * UFS device and/or UFS link low power states during runtime\n\t\t * suspend seems to be different than what is expected during\n\t\t * system suspend. Hence runtime resume the devic & link and\n\t\t * let the system suspend low power states to take effect.\n\t\t * TODO: If resume takes longer time, we might have optimize\n\t\t * it in future by not resuming everything if possible.\n\t\t */\n\t\tret = ufshcd_runtime_resume(hba);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = ufshcd_suspend(hba, UFS_SYSTEM_PM);\nout:\n\ttrace_ufshcd_system_suspend(dev_name(hba->dev), ret,\n\t\tktime_to_us(ktime_sub(ktime_get(), start)),\n\t\thba->curr_dev_pwr_mode, hba->uic_link_state);\n\tif (!ret)\n\t\thba->is_sys_suspended = true;\n\treturn ret;\n}\nEXPORT_SYMBOL(ufshcd_system_suspend);\n\n/**\n * ufshcd_system_resume - system resume routine\n * @hba: per adapter instance\n *\n * Returns 0 for success and non-zero for failure\n */\n\nint ufshcd_system_resume(struct ufs_hba *hba)\n{\n\tint ret = 0;\n\tktime_t start = ktime_get();\n\n\tif (!hba)\n\t\treturn -EINVAL;\n\n\tif (!hba->is_powered || pm_runtime_suspended(hba->dev))\n\t\t/*\n\t\t * Let the runtime resume take care of resuming\n\t\t * if runtime suspended.\n\t\t */\n\t\tgoto out;\n\telse\n\t\tret = ufshcd_resume(hba, UFS_SYSTEM_PM);\nout:\n\ttrace_ufshcd_system_resume(dev_name(hba->dev), ret,\n\t\tktime_to_us(ktime_sub(ktime_get(), start)),\n\t\thba->curr_dev_pwr_mode, hba->uic_link_state);\n\tif (!ret)\n\t\thba->is_sys_suspended = false;\n\treturn ret;\n}\nEXPORT_SYMBOL(ufshcd_system_resume);\n\n/**\n * ufshcd_runtime_suspend - runtime suspend routine\n * @hba: per adapter instance\n *\n * Check the description of ufshcd_suspend() function for more details.\n *\n * Returns 0 for success and non-zero for failure\n */\nint ufshcd_runtime_suspend(struct ufs_hba *hba)\n{\n\tint ret = 0;\n\tktime_t start = ktime_get();\n\n\tif (!hba)\n\t\treturn -EINVAL;\n\n\tif (!hba->is_powered)\n\t\tgoto out;\n\telse\n\t\tret = ufshcd_suspend(hba, UFS_RUNTIME_PM);\nout:\n\ttrace_ufshcd_runtime_suspend(dev_name(hba->dev), ret,\n\t\tktime_to_us(ktime_sub(ktime_get(), start)),\n\t\thba->curr_dev_pwr_mode, hba->uic_link_state);\n\treturn ret;\n}\nEXPORT_SYMBOL(ufshcd_runtime_suspend);\n\n/**\n * ufshcd_runtime_resume - runtime resume routine\n * @hba: per adapter instance\n *\n * This function basically brings the UFS device, UniPro link and controller\n * to active state. Following operations are done in this function:\n *\n * 1. Turn on all the controller related clocks\n * 2. Bring the UniPro link out of Hibernate state\n * 3. If UFS device is in sleep state, turn ON VCC rail and bring the UFS device\n *    to active state.\n * 4. If auto-bkops is enabled on the device, disable it.\n *\n * So following would be the possible power state after this function return\n * successfully:\n *\tS1: UFS device in Active state with VCC rail ON\n *\t    UniPro link in Active state\n *\t    All the UFS/UniPro controller clocks are ON\n *\n * Returns 0 for success and non-zero for failure\n */\nint ufshcd_runtime_resume(struct ufs_hba *hba)\n{\n\tint ret = 0;\n\tktime_t start = ktime_get();\n\n\tif (!hba)\n\t\treturn -EINVAL;\n\n\tif (!hba->is_powered)\n\t\tgoto out;\n\telse\n\t\tret = ufshcd_resume(hba, UFS_RUNTIME_PM);\nout:\n\ttrace_ufshcd_runtime_resume(dev_name(hba->dev), ret,\n\t\tktime_to_us(ktime_sub(ktime_get(), start)),\n\t\thba->curr_dev_pwr_mode, hba->uic_link_state);\n\treturn ret;\n}\nEXPORT_SYMBOL(ufshcd_runtime_resume);\n\nint ufshcd_runtime_idle(struct ufs_hba *hba)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL(ufshcd_runtime_idle);\n\n/**\n * ufshcd_shutdown - shutdown routine\n * @hba: per adapter instance\n *\n * This function would power off both UFS device and UFS link.\n *\n * Returns 0 always to allow force shutdown even in case of errors.\n */\nint ufshcd_shutdown(struct ufs_hba *hba)\n{\n\tint ret = 0;\n\n\tif (!hba->is_powered)\n\t\tgoto out;\n\n\tif (ufshcd_is_ufs_dev_poweroff(hba) && ufshcd_is_link_off(hba))\n\t\tgoto out;\n\n\tpm_runtime_get_sync(hba->dev);\n\n\tret = ufshcd_suspend(hba, UFS_SHUTDOWN_PM);\nout:\n\tif (ret)\n\t\tdev_err(hba->dev, \"%s failed, err %d\\n\", __func__, ret);\n\t/* allow force shutdown even in case of errors */\n\treturn 0;\n}\nEXPORT_SYMBOL(ufshcd_shutdown);\n\n/**\n * ufshcd_remove - de-allocate SCSI host and host memory space\n *\t\tdata structure memory\n * @hba: per adapter instance\n */\nvoid ufshcd_remove(struct ufs_hba *hba)\n{\n\tufs_bsg_remove(hba);\n\tufs_sysfs_remove_nodes(hba->dev);\n\tblk_cleanup_queue(hba->tmf_queue);\n\tblk_mq_free_tag_set(&hba->tmf_tag_set);\n\tblk_cleanup_queue(hba->cmd_queue);\n\tscsi_remove_host(hba->host);\n\tdestroy_workqueue(hba->eh_wq);\n\t/* disable interrupts */\n\tufshcd_disable_intr(hba, hba->intr_mask);\n\tufshcd_hba_stop(hba);\n\n\tufshcd_exit_clk_scaling(hba);\n\tufshcd_exit_clk_gating(hba);\n\tif (ufshcd_is_clkscaling_supported(hba))\n\t\tdevice_remove_file(hba->dev, &hba->clk_scaling.enable_attr);\n\tufshcd_hba_exit(hba);\n}\nEXPORT_SYMBOL_GPL(ufshcd_remove);\n\n/**\n * ufshcd_dealloc_host - deallocate Host Bus Adapter (HBA)\n * @hba: pointer to Host Bus Adapter (HBA)\n */\nvoid ufshcd_dealloc_host(struct ufs_hba *hba)\n{\n\tufshcd_crypto_destroy_keyslot_manager(hba);\n\tscsi_host_put(hba->host);\n}\nEXPORT_SYMBOL_GPL(ufshcd_dealloc_host);\n\n/**\n * ufshcd_set_dma_mask - Set dma mask based on the controller\n *\t\t\t addressing capability\n * @hba: per adapter instance\n *\n * Returns 0 for success, non-zero for failure\n */\nstatic int ufshcd_set_dma_mask(struct ufs_hba *hba)\n{\n\tif (hba->capabilities & MASK_64_ADDRESSING_SUPPORT) {\n\t\tif (!dma_set_mask_and_coherent(hba->dev, DMA_BIT_MASK(64)))\n\t\t\treturn 0;\n\t}\n\treturn dma_set_mask_and_coherent(hba->dev, DMA_BIT_MASK(32));\n}\n\n/**\n * ufshcd_alloc_host - allocate Host Bus Adapter (HBA)\n * @dev: pointer to device handle\n * @hba_handle: driver private handle\n * Returns 0 on success, non-zero value on failure\n */\nint ufshcd_alloc_host(struct device *dev, struct ufs_hba **hba_handle)\n{\n\tstruct Scsi_Host *host;\n\tstruct ufs_hba *hba;\n\tint err = 0;\n\n\tif (!dev) {\n\t\tdev_err(dev,\n\t\t\"Invalid memory reference for dev is NULL\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out_error;\n\t}\n\n\thost = scsi_host_alloc(&ufshcd_driver_template,\n\t\t\t\tsizeof(struct ufs_hba));\n\tif (!host) {\n\t\tdev_err(dev, \"scsi_host_alloc failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_error;\n\t}\n\thba = shost_priv(host);\n\thba->host = host;\n\thba->dev = dev;\n\t*hba_handle = hba;\n\thba->dev_ref_clk_freq = REF_CLK_FREQ_INVAL;\n\n\tINIT_LIST_HEAD(&hba->clk_list_head);\n\nout_error:\n\treturn err;\n}\nEXPORT_SYMBOL(ufshcd_alloc_host);\n\n/* This function exists because blk_mq_alloc_tag_set() requires this. */\nstatic blk_status_t ufshcd_queue_tmf(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t     const struct blk_mq_queue_data *qd)\n{\n\tWARN_ON_ONCE(true);\n\treturn BLK_STS_NOTSUPP;\n}\n\nstatic const struct blk_mq_ops ufshcd_tmf_ops = {\n\t.queue_rq = ufshcd_queue_tmf,\n};\n\n/**\n * ufshcd_init - Driver initialization routine\n * @hba: per-adapter instance\n * @mmio_base: base register address\n * @irq: Interrupt line of device\n * Returns 0 on success, non-zero value on failure\n */\nint ufshcd_init(struct ufs_hba *hba, void __iomem *mmio_base, unsigned int irq)\n{\n\tint err;\n\tstruct Scsi_Host *host = hba->host;\n\tstruct device *dev = hba->dev;\n\tchar eh_wq_name[sizeof(\"ufs_eh_wq_00\")];\n\n\tif (!mmio_base) {\n\t\tdev_err(hba->dev,\n\t\t\"Invalid memory reference for mmio_base is NULL\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out_error;\n\t}\n\n\thba->mmio_base = mmio_base;\n\thba->irq = irq;\n\thba->vps = &ufs_hba_vps;\n\n\terr = ufshcd_hba_init(hba);\n\tif (err)\n\t\tgoto out_error;\n\n\t/* Read capabilities registers */\n\terr = ufshcd_hba_capabilities(hba);\n\tif (err)\n\t\tgoto out_disable;\n\n\t/* Get UFS version supported by the controller */\n\thba->ufs_version = ufshcd_get_ufs_version(hba);\n\n\tif ((hba->ufs_version != UFSHCI_VERSION_10) &&\n\t    (hba->ufs_version != UFSHCI_VERSION_11) &&\n\t    (hba->ufs_version != UFSHCI_VERSION_20) &&\n\t    (hba->ufs_version != UFSHCI_VERSION_21))\n\t\tdev_err(hba->dev, \"invalid UFS version 0x%x\\n\",\n\t\t\thba->ufs_version);\n\n\t/* Get Interrupt bit mask per version */\n\thba->intr_mask = ufshcd_get_intr_mask(hba);\n\n\terr = ufshcd_set_dma_mask(hba);\n\tif (err) {\n\t\tdev_err(hba->dev, \"set dma mask failed\\n\");\n\t\tgoto out_disable;\n\t}\n\n\t/* Allocate memory for host memory space */\n\terr = ufshcd_memory_alloc(hba);\n\tif (err) {\n\t\tdev_err(hba->dev, \"Memory allocation failed\\n\");\n\t\tgoto out_disable;\n\t}\n\n\t/* Configure LRB */\n\tufshcd_host_memory_configure(hba);\n\n\thost->can_queue = hba->nutrs;\n\thost->cmd_per_lun = hba->nutrs;\n\thost->max_id = UFSHCD_MAX_ID;\n\thost->max_lun = UFS_MAX_LUNS;\n\thost->max_channel = UFSHCD_MAX_CHANNEL;\n\thost->unique_id = host->host_no;\n\thost->max_cmd_len = UFS_CDB_SIZE;\n\n\thba->max_pwr_info.is_valid = false;\n\n\t/* Initialize work queues */\n\tsnprintf(eh_wq_name, sizeof(eh_wq_name), \"ufs_eh_wq_%d\",\n\t\t hba->host->host_no);\n\thba->eh_wq = create_singlethread_workqueue(eh_wq_name);\n\tif (!hba->eh_wq) {\n\t\tdev_err(hba->dev, \"%s: failed to create eh workqueue\\n\",\n\t\t\t\t__func__);\n\t\terr = -ENOMEM;\n\t\tgoto out_disable;\n\t}\n\tINIT_WORK(&hba->eh_work, ufshcd_err_handler);\n\tINIT_WORK(&hba->eeh_work, ufshcd_exception_event_handler);\n\n\t/* Initialize UIC command mutex */\n\tmutex_init(&hba->uic_cmd_mutex);\n\n\t/* Initialize mutex for device management commands */\n\tmutex_init(&hba->dev_cmd.lock);\n\n\tinit_rwsem(&hba->clk_scaling_lock);\n\n\tufshcd_init_clk_gating(hba);\n\n\tufshcd_init_clk_scaling(hba);\n\n\t/*\n\t * In order to avoid any spurious interrupt immediately after\n\t * registering UFS controller interrupt handler, clear any pending UFS\n\t * interrupt status and disable all the UFS interrupts.\n\t */\n\tufshcd_writel(hba, ufshcd_readl(hba, REG_INTERRUPT_STATUS),\n\t\t      REG_INTERRUPT_STATUS);\n\tufshcd_writel(hba, 0, REG_INTERRUPT_ENABLE);\n\t/*\n\t * Make sure that UFS interrupts are disabled and any pending interrupt\n\t * status is cleared before registering UFS interrupt handler.\n\t */\n\tmb();\n\n\t/* IRQ registration */\n\terr = devm_request_irq(dev, irq, ufshcd_intr, IRQF_SHARED, UFSHCD, hba);\n\tif (err) {\n\t\tdev_err(hba->dev, \"request irq failed\\n\");\n\t\tgoto exit_gating;\n\t} else {\n\t\thba->is_irq_enabled = true;\n\t}\n\n\terr = scsi_add_host(host, hba->dev);\n\tif (err) {\n\t\tdev_err(hba->dev, \"scsi_add_host failed\\n\");\n\t\tgoto exit_gating;\n\t}\n\n\thba->cmd_queue = blk_mq_init_queue(&hba->host->tag_set);\n\tif (IS_ERR(hba->cmd_queue)) {\n\t\terr = PTR_ERR(hba->cmd_queue);\n\t\tgoto out_remove_scsi_host;\n\t}\n\n\thba->tmf_tag_set = (struct blk_mq_tag_set) {\n\t\t.nr_hw_queues\t= 1,\n\t\t.queue_depth\t= hba->nutmrs,\n\t\t.ops\t\t= &ufshcd_tmf_ops,\n\t\t.flags\t\t= BLK_MQ_F_NO_SCHED,\n\t};\n\terr = blk_mq_alloc_tag_set(&hba->tmf_tag_set);\n\tif (err < 0)\n\t\tgoto free_cmd_queue;\n\thba->tmf_queue = blk_mq_init_queue(&hba->tmf_tag_set);\n\tif (IS_ERR(hba->tmf_queue)) {\n\t\terr = PTR_ERR(hba->tmf_queue);\n\t\tgoto free_tmf_tag_set;\n\t}\n\n\t/* Reset the attached device */\n\tufshcd_vops_device_reset(hba);\n\n\tufshcd_init_crypto(hba);\n\n\t/* Host controller enable */\n\terr = ufshcd_hba_enable(hba);\n\tif (err) {\n\t\tdev_err(hba->dev, \"Host controller enable failed\\n\");\n\t\tufshcd_print_host_regs(hba);\n\t\tufshcd_print_host_state(hba);\n\t\tgoto free_tmf_queue;\n\t}\n\n\t/*\n\t * Set the default power management level for runtime and system PM.\n\t * Default power saving mode is to keep UFS link in Hibern8 state\n\t * and UFS device in sleep state.\n\t */\n\thba->rpm_lvl = ufs_get_desired_pm_lvl_for_dev_link_state(\n\t\t\t\t\t\tUFS_SLEEP_PWR_MODE,\n\t\t\t\t\t\tUIC_LINK_HIBERN8_STATE);\n\thba->spm_lvl = ufs_get_desired_pm_lvl_for_dev_link_state(\n\t\t\t\t\t\tUFS_SLEEP_PWR_MODE,\n\t\t\t\t\t\tUIC_LINK_HIBERN8_STATE);\n\n\tINIT_DELAYED_WORK(&hba->rpm_dev_flush_recheck_work,\n\t\t\t  ufshcd_rpm_dev_flush_recheck_work);\n\n\t/* Set the default auto-hiberate idle timer value to 150 ms */\n\tif (ufshcd_is_auto_hibern8_supported(hba) && !hba->ahit) {\n\t\thba->ahit = FIELD_PREP(UFSHCI_AHIBERN8_TIMER_MASK, 150) |\n\t\t\t    FIELD_PREP(UFSHCI_AHIBERN8_SCALE_MASK, 3);\n\t}\n\n\t/* Hold auto suspend until async scan completes */\n\tpm_runtime_get_sync(dev);\n\tatomic_set(&hba->scsi_block_reqs_cnt, 0);\n\t/*\n\t * We are assuming that device wasn't put in sleep/power-down\n\t * state exclusively during the boot stage before kernel.\n\t * This assumption helps avoid doing link startup twice during\n\t * ufshcd_probe_hba().\n\t */\n\tufshcd_set_ufs_dev_active(hba);\n\n\tasync_schedule(ufshcd_async_scan, hba);\n\tufs_sysfs_add_nodes(hba->dev);\n\n\treturn 0;\n\nfree_tmf_queue:\n\tblk_cleanup_queue(hba->tmf_queue);\nfree_tmf_tag_set:\n\tblk_mq_free_tag_set(&hba->tmf_tag_set);\nfree_cmd_queue:\n\tblk_cleanup_queue(hba->cmd_queue);\nout_remove_scsi_host:\n\tscsi_remove_host(hba->host);\nexit_gating:\n\tufshcd_exit_clk_scaling(hba);\n\tufshcd_exit_clk_gating(hba);\n\tdestroy_workqueue(hba->eh_wq);\nout_disable:\n\thba->is_irq_enabled = false;\n\tufshcd_hba_exit(hba);\nout_error:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ufshcd_init);\n\nMODULE_AUTHOR(\"Santosh Yaragnavi <santosh.sy@samsung.com>\");\nMODULE_AUTHOR(\"Vinayak Holikatti <h.vinayak@samsung.com>\");\nMODULE_DESCRIPTION(\"Generic UFS host controller driver Core\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(UFSHCD_DRIVER_VERSION);\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 0, "line": 1791}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/ufs/ufshcd.c", "reportHash": "05ca1e63cf84389ffcd4ea764462e5da", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1814}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/ufs/ufshcd.c", "reportHash": "1328dfae34aeb6364ff7e56116cd0647", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1501}, "message": "WARNING: use scnprintf or sprintf"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/ufs/ufshcd.c", "reportHash": "947c78029af37394c44493e784188e02", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
