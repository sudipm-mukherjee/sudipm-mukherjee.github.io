<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/gpu/drm/i915/display/intel_dp.c", "content": "/*\n * Copyright \u00a9 2008 Intel Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n * Authors:\n *    Keith Packard <keithp@keithp.com>\n *\n */\n\n#include <linux/export.h>\n#include <linux/i2c.h>\n#include <linux/notifier.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <asm/byteorder.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_dp_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"i915_debugfs.h\"\n#include \"i915_drv.h\"\n#include \"i915_trace.h\"\n#include \"intel_atomic.h\"\n#include \"intel_audio.h\"\n#include \"intel_connector.h\"\n#include \"intel_ddi.h\"\n#include \"intel_display_types.h\"\n#include \"intel_dp.h\"\n#include \"intel_dp_link_training.h\"\n#include \"intel_dp_mst.h\"\n#include \"intel_dpio_phy.h\"\n#include \"intel_fifo_underrun.h\"\n#include \"intel_hdcp.h\"\n#include \"intel_hdmi.h\"\n#include \"intel_hotplug.h\"\n#include \"intel_lspcon.h\"\n#include \"intel_lvds.h\"\n#include \"intel_panel.h\"\n#include \"intel_psr.h\"\n#include \"intel_sideband.h\"\n#include \"intel_tc.h\"\n#include \"intel_vdsc.h\"\n\n#define DP_DPRX_ESI_LEN 14\n\n/* DP DSC throughput values used for slice count calculations KPixels/s */\n#define DP_DSC_PEAK_PIXEL_RATE\t\t\t2720000\n#define DP_DSC_MAX_ENC_THROUGHPUT_0\t\t340000\n#define DP_DSC_MAX_ENC_THROUGHPUT_1\t\t400000\n\n/* DP DSC FEC Overhead factor = 1/(0.972261) */\n#define DP_DSC_FEC_OVERHEAD_FACTOR\t\t972261\n\n/* Compliance test status bits  */\n#define INTEL_DP_RESOLUTION_SHIFT_MASK\t0\n#define INTEL_DP_RESOLUTION_PREFERRED\t(1 << INTEL_DP_RESOLUTION_SHIFT_MASK)\n#define INTEL_DP_RESOLUTION_STANDARD\t(2 << INTEL_DP_RESOLUTION_SHIFT_MASK)\n#define INTEL_DP_RESOLUTION_FAILSAFE\t(3 << INTEL_DP_RESOLUTION_SHIFT_MASK)\n\nstruct dp_link_dpll {\n\tint clock;\n\tstruct dpll dpll;\n};\n\nstatic const struct dp_link_dpll g4x_dpll[] = {\n\t{ 162000,\n\t\t{ .p1 = 2, .p2 = 10, .n = 2, .m1 = 23, .m2 = 8 } },\n\t{ 270000,\n\t\t{ .p1 = 1, .p2 = 10, .n = 1, .m1 = 14, .m2 = 2 } }\n};\n\nstatic const struct dp_link_dpll pch_dpll[] = {\n\t{ 162000,\n\t\t{ .p1 = 2, .p2 = 10, .n = 1, .m1 = 12, .m2 = 9 } },\n\t{ 270000,\n\t\t{ .p1 = 1, .p2 = 10, .n = 2, .m1 = 14, .m2 = 8 } }\n};\n\nstatic const struct dp_link_dpll vlv_dpll[] = {\n\t{ 162000,\n\t\t{ .p1 = 3, .p2 = 2, .n = 5, .m1 = 3, .m2 = 81 } },\n\t{ 270000,\n\t\t{ .p1 = 2, .p2 = 2, .n = 1, .m1 = 2, .m2 = 27 } }\n};\n\n/*\n * CHV supports eDP 1.4 that have  more link rates.\n * Below only provides the fixed rate but exclude variable rate.\n */\nstatic const struct dp_link_dpll chv_dpll[] = {\n\t/*\n\t * CHV requires to program fractional division for m2.\n\t * m2 is stored in fixed point format using formula below\n\t * (m2_int << 22) | m2_fraction\n\t */\n\t{ 162000,\t/* m2_int = 32, m2_fraction = 1677722 */\n\t\t{ .p1 = 4, .p2 = 2, .n = 1, .m1 = 2, .m2 = 0x819999a } },\n\t{ 270000,\t/* m2_int = 27, m2_fraction = 0 */\n\t\t{ .p1 = 4, .p2 = 1, .n = 1, .m1 = 2, .m2 = 0x6c00000 } },\n};\n\n/* Constants for DP DSC configurations */\nstatic const u8 valid_dsc_bpp[] = {6, 8, 10, 12, 15};\n\n/* With Single pipe configuration, HW is capable of supporting maximum\n * of 4 slices per line.\n */\nstatic const u8 valid_dsc_slicecount[] = {1, 2, 4};\n\n/**\n * intel_dp_is_edp - is the given port attached to an eDP panel (either CPU or PCH)\n * @intel_dp: DP struct\n *\n * If a CPU or PCH DP output is attached to an eDP panel, this function\n * will return true, and false otherwise.\n */\nbool intel_dp_is_edp(struct intel_dp *intel_dp)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\n\treturn dig_port->base.type == INTEL_OUTPUT_EDP;\n}\n\nstatic void intel_dp_link_down(struct intel_encoder *encoder,\n\t\t\t       const struct intel_crtc_state *old_crtc_state);\nstatic bool edp_panel_vdd_on(struct intel_dp *intel_dp);\nstatic void edp_panel_vdd_off(struct intel_dp *intel_dp, bool sync);\nstatic void vlv_init_panel_power_sequencer(struct intel_encoder *encoder,\n\t\t\t\t\t   const struct intel_crtc_state *crtc_state);\nstatic void vlv_steal_power_sequencer(struct drm_i915_private *dev_priv,\n\t\t\t\t      enum pipe pipe);\nstatic void intel_dp_unset_edid(struct intel_dp *intel_dp);\n\n/* update sink rates from dpcd */\nstatic void intel_dp_set_sink_rates(struct intel_dp *intel_dp)\n{\n\tstatic const int dp_rates[] = {\n\t\t162000, 270000, 540000, 810000\n\t};\n\tint i, max_rate;\n\tint max_lttpr_rate;\n\n\tif (drm_dp_has_quirk(&intel_dp->desc, 0,\n\t\t\t     DP_DPCD_QUIRK_CAN_DO_MAX_LINK_RATE_3_24_GBPS)) {\n\t\t/* Needed, e.g., for Apple MBP 2017, 15 inch eDP Retina panel */\n\t\tstatic const int quirk_rates[] = { 162000, 270000, 324000 };\n\n\t\tmemcpy(intel_dp->sink_rates, quirk_rates, sizeof(quirk_rates));\n\t\tintel_dp->num_sink_rates = ARRAY_SIZE(quirk_rates);\n\n\t\treturn;\n\t}\n\n\tmax_rate = drm_dp_bw_code_to_link_rate(intel_dp->dpcd[DP_MAX_LINK_RATE]);\n\tmax_lttpr_rate = drm_dp_lttpr_max_link_rate(intel_dp->lttpr_common_caps);\n\tif (max_lttpr_rate)\n\t\tmax_rate = min(max_rate, max_lttpr_rate);\n\n\tfor (i = 0; i < ARRAY_SIZE(dp_rates); i++) {\n\t\tif (dp_rates[i] > max_rate)\n\t\t\tbreak;\n\t\tintel_dp->sink_rates[i] = dp_rates[i];\n\t}\n\n\tintel_dp->num_sink_rates = i;\n}\n\n/* Get length of rates array potentially limited by max_rate. */\nstatic int intel_dp_rate_limit_len(const int *rates, int len, int max_rate)\n{\n\tint i;\n\n\t/* Limit results by potentially reduced max rate */\n\tfor (i = 0; i < len; i++) {\n\t\tif (rates[len - i - 1] <= max_rate)\n\t\t\treturn len - i;\n\t}\n\n\treturn 0;\n}\n\n/* Get length of common rates array potentially limited by max_rate. */\nstatic int intel_dp_common_len_rate_limit(const struct intel_dp *intel_dp,\n\t\t\t\t\t  int max_rate)\n{\n\treturn intel_dp_rate_limit_len(intel_dp->common_rates,\n\t\t\t\t       intel_dp->num_common_rates, max_rate);\n}\n\n/* Theoretical max between source and sink */\nstatic int intel_dp_max_common_rate(struct intel_dp *intel_dp)\n{\n\treturn intel_dp->common_rates[intel_dp->num_common_rates - 1];\n}\n\n/* Theoretical max between source and sink */\nstatic int intel_dp_max_common_lane_count(struct intel_dp *intel_dp)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tint source_max = dig_port->max_lanes;\n\tint sink_max = drm_dp_max_lane_count(intel_dp->dpcd);\n\tint fia_max = intel_tc_port_fia_max_lane_count(dig_port);\n\tint lttpr_max = drm_dp_lttpr_max_lane_count(intel_dp->lttpr_common_caps);\n\n\tif (lttpr_max)\n\t\tsink_max = min(sink_max, lttpr_max);\n\n\treturn min3(source_max, sink_max, fia_max);\n}\n\nint intel_dp_max_lane_count(struct intel_dp *intel_dp)\n{\n\treturn intel_dp->max_link_lane_count;\n}\n\nint\nintel_dp_link_required(int pixel_clock, int bpp)\n{\n\t/* pixel_clock is in kHz, divide bpp by 8 for bit to Byte conversion */\n\treturn DIV_ROUND_UP(pixel_clock * bpp, 8);\n}\n\nint\nintel_dp_max_data_rate(int max_link_clock, int max_lanes)\n{\n\t/* max_link_clock is the link symbol clock (LS_Clk) in kHz and not the\n\t * link rate that is generally expressed in Gbps. Since, 8 bits of data\n\t * is transmitted every LS_Clk per lane, there is no need to account for\n\t * the channel encoding that is done in the PHY layer here.\n\t */\n\n\treturn max_link_clock * max_lanes;\n}\n\nbool intel_dp_can_bigjoiner(struct intel_dp *intel_dp)\n{\n\tstruct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);\n\tstruct intel_encoder *encoder = &intel_dig_port->base;\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\treturn INTEL_GEN(dev_priv) >= 12 ||\n\t\t(INTEL_GEN(dev_priv) == 11 &&\n\t\t encoder->port != PORT_A);\n}\n\nstatic int cnl_max_source_rate(struct intel_dp *intel_dp)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\tenum port port = dig_port->base.port;\n\n\tu32 voltage = intel_de_read(dev_priv, CNL_PORT_COMP_DW3) & VOLTAGE_INFO_MASK;\n\n\t/* Low voltage SKUs are limited to max of 5.4G */\n\tif (voltage == VOLTAGE_INFO_0_85V)\n\t\treturn 540000;\n\n\t/* For this SKU 8.1G is supported in all ports */\n\tif (IS_CNL_WITH_PORT_F(dev_priv))\n\t\treturn 810000;\n\n\t/* For other SKUs, max rate on ports A and D is 5.4G */\n\tif (port == PORT_A || port == PORT_D)\n\t\treturn 540000;\n\n\treturn 810000;\n}\n\nstatic int icl_max_source_rate(struct intel_dp *intel_dp)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\tenum phy phy = intel_port_to_phy(dev_priv, dig_port->base.port);\n\n\tif (intel_phy_is_combo(dev_priv, phy) &&\n\t    !intel_dp_is_edp(intel_dp))\n\t\treturn 540000;\n\n\treturn 810000;\n}\n\nstatic int ehl_max_source_rate(struct intel_dp *intel_dp)\n{\n\tif (intel_dp_is_edp(intel_dp))\n\t\treturn 540000;\n\n\treturn 810000;\n}\n\nstatic void\nintel_dp_set_source_rates(struct intel_dp *intel_dp)\n{\n\t/* The values must be in increasing order */\n\tstatic const int cnl_rates[] = {\n\t\t162000, 216000, 270000, 324000, 432000, 540000, 648000, 810000\n\t};\n\tstatic const int bxt_rates[] = {\n\t\t162000, 216000, 243000, 270000, 324000, 432000, 540000\n\t};\n\tstatic const int skl_rates[] = {\n\t\t162000, 216000, 270000, 324000, 432000, 540000\n\t};\n\tstatic const int hsw_rates[] = {\n\t\t162000, 270000, 540000\n\t};\n\tstatic const int g4x_rates[] = {\n\t\t162000, 270000\n\t};\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct intel_encoder *encoder = &dig_port->base;\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\tconst int *source_rates;\n\tint size, max_rate = 0, vbt_max_rate;\n\n\t/* This should only be done once */\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    intel_dp->source_rates || intel_dp->num_source_rates);\n\n\tif (INTEL_GEN(dev_priv) >= 10) {\n\t\tsource_rates = cnl_rates;\n\t\tsize = ARRAY_SIZE(cnl_rates);\n\t\tif (IS_GEN(dev_priv, 10))\n\t\t\tmax_rate = cnl_max_source_rate(intel_dp);\n\t\telse if (IS_JSL_EHL(dev_priv))\n\t\t\tmax_rate = ehl_max_source_rate(intel_dp);\n\t\telse\n\t\t\tmax_rate = icl_max_source_rate(intel_dp);\n\t} else if (IS_GEN9_LP(dev_priv)) {\n\t\tsource_rates = bxt_rates;\n\t\tsize = ARRAY_SIZE(bxt_rates);\n\t} else if (IS_GEN9_BC(dev_priv)) {\n\t\tsource_rates = skl_rates;\n\t\tsize = ARRAY_SIZE(skl_rates);\n\t} else if ((IS_HASWELL(dev_priv) && !IS_HSW_ULX(dev_priv)) ||\n\t\t   IS_BROADWELL(dev_priv)) {\n\t\tsource_rates = hsw_rates;\n\t\tsize = ARRAY_SIZE(hsw_rates);\n\t} else {\n\t\tsource_rates = g4x_rates;\n\t\tsize = ARRAY_SIZE(g4x_rates);\n\t}\n\n\tvbt_max_rate = intel_bios_dp_max_link_rate(encoder);\n\tif (max_rate && vbt_max_rate)\n\t\tmax_rate = min(max_rate, vbt_max_rate);\n\telse if (vbt_max_rate)\n\t\tmax_rate = vbt_max_rate;\n\n\tif (max_rate)\n\t\tsize = intel_dp_rate_limit_len(source_rates, size, max_rate);\n\n\tintel_dp->source_rates = source_rates;\n\tintel_dp->num_source_rates = size;\n}\n\nstatic int intersect_rates(const int *source_rates, int source_len,\n\t\t\t   const int *sink_rates, int sink_len,\n\t\t\t   int *common_rates)\n{\n\tint i = 0, j = 0, k = 0;\n\n\twhile (i < source_len && j < sink_len) {\n\t\tif (source_rates[i] == sink_rates[j]) {\n\t\t\tif (WARN_ON(k >= DP_MAX_SUPPORTED_RATES))\n\t\t\t\treturn k;\n\t\t\tcommon_rates[k] = source_rates[i];\n\t\t\t++k;\n\t\t\t++i;\n\t\t\t++j;\n\t\t} else if (source_rates[i] < sink_rates[j]) {\n\t\t\t++i;\n\t\t} else {\n\t\t\t++j;\n\t\t}\n\t}\n\treturn k;\n}\n\n/* return index of rate in rates array, or -1 if not found */\nstatic int intel_dp_rate_index(const int *rates, int len, int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (rate == rates[i])\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nstatic void intel_dp_set_common_rates(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tdrm_WARN_ON(&i915->drm,\n\t\t    !intel_dp->num_source_rates || !intel_dp->num_sink_rates);\n\n\tintel_dp->num_common_rates = intersect_rates(intel_dp->source_rates,\n\t\t\t\t\t\t     intel_dp->num_source_rates,\n\t\t\t\t\t\t     intel_dp->sink_rates,\n\t\t\t\t\t\t     intel_dp->num_sink_rates,\n\t\t\t\t\t\t     intel_dp->common_rates);\n\n\t/* Paranoia, there should always be something in common. */\n\tif (drm_WARN_ON(&i915->drm, intel_dp->num_common_rates == 0)) {\n\t\tintel_dp->common_rates[0] = 162000;\n\t\tintel_dp->num_common_rates = 1;\n\t}\n}\n\nstatic bool intel_dp_link_params_valid(struct intel_dp *intel_dp, int link_rate,\n\t\t\t\t       u8 lane_count)\n{\n\t/*\n\t * FIXME: we need to synchronize the current link parameters with\n\t * hardware readout. Currently fast link training doesn't work on\n\t * boot-up.\n\t */\n\tif (link_rate == 0 ||\n\t    link_rate > intel_dp->max_link_rate)\n\t\treturn false;\n\n\tif (lane_count == 0 ||\n\t    lane_count > intel_dp_max_lane_count(intel_dp))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool intel_dp_can_link_train_fallback_for_edp(struct intel_dp *intel_dp,\n\t\t\t\t\t\t     int link_rate,\n\t\t\t\t\t\t     u8 lane_count)\n{\n\tconst struct drm_display_mode *fixed_mode =\n\t\tintel_dp->attached_connector->panel.fixed_mode;\n\tint mode_rate, max_rate;\n\n\tmode_rate = intel_dp_link_required(fixed_mode->clock, 18);\n\tmax_rate = intel_dp_max_data_rate(link_rate, lane_count);\n\tif (mode_rate > max_rate)\n\t\treturn false;\n\n\treturn true;\n}\n\nint intel_dp_get_link_train_fallback_values(struct intel_dp *intel_dp,\n\t\t\t\t\t    int link_rate, u8 lane_count)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tint index;\n\n\t/*\n\t * TODO: Enable fallback on MST links once MST link compute can handle\n\t * the fallback params.\n\t */\n\tif (intel_dp->is_mst) {\n\t\tdrm_err(&i915->drm, \"Link Training Unsuccessful\\n\");\n\t\treturn -1;\n\t}\n\n\tindex = intel_dp_rate_index(intel_dp->common_rates,\n\t\t\t\t    intel_dp->num_common_rates,\n\t\t\t\t    link_rate);\n\tif (index > 0) {\n\t\tif (intel_dp_is_edp(intel_dp) &&\n\t\t    !intel_dp_can_link_train_fallback_for_edp(intel_dp,\n\t\t\t\t\t\t\t      intel_dp->common_rates[index - 1],\n\t\t\t\t\t\t\t      lane_count)) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"Retrying Link training for eDP with same parameters\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tintel_dp->max_link_rate = intel_dp->common_rates[index - 1];\n\t\tintel_dp->max_link_lane_count = lane_count;\n\t} else if (lane_count > 1) {\n\t\tif (intel_dp_is_edp(intel_dp) &&\n\t\t    !intel_dp_can_link_train_fallback_for_edp(intel_dp,\n\t\t\t\t\t\t\t      intel_dp_max_common_rate(intel_dp),\n\t\t\t\t\t\t\t      lane_count >> 1)) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"Retrying Link training for eDP with same parameters\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tintel_dp->max_link_rate = intel_dp_max_common_rate(intel_dp);\n\t\tintel_dp->max_link_lane_count = lane_count >> 1;\n\t} else {\n\t\tdrm_err(&i915->drm, \"Link Training Unsuccessful\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nu32 intel_dp_mode_to_fec_clock(u32 mode_clock)\n{\n\treturn div_u64(mul_u32_u32(mode_clock, 1000000U),\n\t\t       DP_DSC_FEC_OVERHEAD_FACTOR);\n}\n\nstatic int\nsmall_joiner_ram_size_bits(struct drm_i915_private *i915)\n{\n\tif (INTEL_GEN(i915) >= 11)\n\t\treturn 7680 * 8;\n\telse\n\t\treturn 6144 * 8;\n}\n\nstatic u16 intel_dp_dsc_get_output_bpp(struct drm_i915_private *i915,\n\t\t\t\t       u32 link_clock, u32 lane_count,\n\t\t\t\t       u32 mode_clock, u32 mode_hdisplay,\n\t\t\t\t       bool bigjoiner)\n{\n\tu32 bits_per_pixel, max_bpp_small_joiner_ram;\n\tint i;\n\n\t/*\n\t * Available Link Bandwidth(Kbits/sec) = (NumberOfLanes)*\n\t * (LinkSymbolClock)* 8 * (TimeSlotsPerMTP)\n\t * for SST -> TimeSlotsPerMTP is 1,\n\t * for MST -> TimeSlotsPerMTP has to be calculated\n\t */\n\tbits_per_pixel = (link_clock * lane_count * 8) /\n\t\t\t intel_dp_mode_to_fec_clock(mode_clock);\n\tdrm_dbg_kms(&i915->drm, \"Max link bpp: %u\\n\", bits_per_pixel);\n\n\t/* Small Joiner Check: output bpp <= joiner RAM (bits) / Horiz. width */\n\tmax_bpp_small_joiner_ram = small_joiner_ram_size_bits(i915) /\n\t\tmode_hdisplay;\n\n\tif (bigjoiner)\n\t\tmax_bpp_small_joiner_ram *= 2;\n\n\tdrm_dbg_kms(&i915->drm, \"Max small joiner bpp: %u\\n\",\n\t\t    max_bpp_small_joiner_ram);\n\n\t/*\n\t * Greatest allowed DSC BPP = MIN (output BPP from available Link BW\n\t * check, output bpp from small joiner RAM check)\n\t */\n\tbits_per_pixel = min(bits_per_pixel, max_bpp_small_joiner_ram);\n\n\tif (bigjoiner) {\n\t\tu32 max_bpp_bigjoiner =\n\t\t\ti915->max_cdclk_freq * 48 /\n\t\t\tintel_dp_mode_to_fec_clock(mode_clock);\n\n\t\tDRM_DEBUG_KMS(\"Max big joiner bpp: %u\\n\", max_bpp_bigjoiner);\n\t\tbits_per_pixel = min(bits_per_pixel, max_bpp_bigjoiner);\n\t}\n\n\t/* Error out if the max bpp is less than smallest allowed valid bpp */\n\tif (bits_per_pixel < valid_dsc_bpp[0]) {\n\t\tdrm_dbg_kms(&i915->drm, \"Unsupported BPP %u, min %u\\n\",\n\t\t\t    bits_per_pixel, valid_dsc_bpp[0]);\n\t\treturn 0;\n\t}\n\n\t/* Find the nearest match in the array of known BPPs from VESA */\n\tfor (i = 0; i < ARRAY_SIZE(valid_dsc_bpp) - 1; i++) {\n\t\tif (bits_per_pixel < valid_dsc_bpp[i + 1])\n\t\t\tbreak;\n\t}\n\tbits_per_pixel = valid_dsc_bpp[i];\n\n\t/*\n\t * Compressed BPP in U6.4 format so multiply by 16, for Gen 11,\n\t * fractional part is 0\n\t */\n\treturn bits_per_pixel << 4;\n}\n\nstatic u8 intel_dp_dsc_get_slice_count(struct intel_dp *intel_dp,\n\t\t\t\t       int mode_clock, int mode_hdisplay,\n\t\t\t\t       bool bigjoiner)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 min_slice_count, i;\n\tint max_slice_width;\n\n\tif (mode_clock <= DP_DSC_PEAK_PIXEL_RATE)\n\t\tmin_slice_count = DIV_ROUND_UP(mode_clock,\n\t\t\t\t\t       DP_DSC_MAX_ENC_THROUGHPUT_0);\n\telse\n\t\tmin_slice_count = DIV_ROUND_UP(mode_clock,\n\t\t\t\t\t       DP_DSC_MAX_ENC_THROUGHPUT_1);\n\n\tmax_slice_width = drm_dp_dsc_sink_max_slice_width(intel_dp->dsc_dpcd);\n\tif (max_slice_width < DP_DSC_MIN_SLICE_WIDTH_VALUE) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Unsupported slice width %d by DP DSC Sink device\\n\",\n\t\t\t    max_slice_width);\n\t\treturn 0;\n\t}\n\t/* Also take into account max slice width */\n\tmin_slice_count = min_t(u8, min_slice_count,\n\t\t\t\tDIV_ROUND_UP(mode_hdisplay,\n\t\t\t\t\t     max_slice_width));\n\n\t/* Find the closest match to the valid slice count values */\n\tfor (i = 0; i < ARRAY_SIZE(valid_dsc_slicecount); i++) {\n\t\tu8 test_slice_count = valid_dsc_slicecount[i] << bigjoiner;\n\n\t\tif (test_slice_count >\n\t\t    drm_dp_dsc_sink_max_slice_count(intel_dp->dsc_dpcd, false))\n\t\t\tbreak;\n\n\t\t/* big joiner needs small joiner to be enabled */\n\t\tif (bigjoiner && test_slice_count < 4)\n\t\t\tcontinue;\n\n\t\tif (min_slice_count <= test_slice_count)\n\t\t\treturn test_slice_count;\n\t}\n\n\tdrm_dbg_kms(&i915->drm, \"Unsupported Slice Count %d\\n\",\n\t\t    min_slice_count);\n\treturn 0;\n}\n\nstatic enum intel_output_format\nintel_dp_output_format(struct drm_connector *connector,\n\t\t       const struct drm_display_mode *mode)\n{\n\tstruct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));\n\tconst struct drm_display_info *info = &connector->display_info;\n\n\tif (!connector->ycbcr_420_allowed ||\n\t    !drm_mode_is_420_only(info, mode))\n\t\treturn INTEL_OUTPUT_FORMAT_RGB;\n\n\tif (intel_dp->dfp.ycbcr_444_to_420)\n\t\treturn INTEL_OUTPUT_FORMAT_YCBCR444;\n\telse\n\t\treturn INTEL_OUTPUT_FORMAT_YCBCR420;\n}\n\nint intel_dp_min_bpp(enum intel_output_format output_format)\n{\n\tif (output_format == INTEL_OUTPUT_FORMAT_RGB)\n\t\treturn 6 * 3;\n\telse\n\t\treturn 8 * 3;\n}\n\nstatic int intel_dp_output_bpp(enum intel_output_format output_format, int bpp)\n{\n\t/*\n\t * bpp value was assumed to RGB format. And YCbCr 4:2:0 output\n\t * format of the number of bytes per pixel will be half the number\n\t * of bytes of RGB pixel.\n\t */\n\tif (output_format == INTEL_OUTPUT_FORMAT_YCBCR420)\n\t\tbpp /= 2;\n\n\treturn bpp;\n}\n\nstatic int\nintel_dp_mode_min_output_bpp(struct drm_connector *connector,\n\t\t\t     const struct drm_display_mode *mode)\n{\n\tenum intel_output_format output_format =\n\t\tintel_dp_output_format(connector, mode);\n\n\treturn intel_dp_output_bpp(output_format, intel_dp_min_bpp(output_format));\n}\n\nstatic bool intel_dp_hdisplay_bad(struct drm_i915_private *dev_priv,\n\t\t\t\t  int hdisplay)\n{\n\t/*\n\t * Older platforms don't like hdisplay==4096 with DP.\n\t *\n\t * On ILK/SNB/IVB the pipe seems to be somewhat running (scanline\n\t * and frame counter increment), but we don't get vblank interrupts,\n\t * and the pipe underruns immediately. The link also doesn't seem\n\t * to get trained properly.\n\t *\n\t * On CHV the vblank interrupts don't seem to disappear but\n\t * otherwise the symptoms are similar.\n\t *\n\t * TODO: confirm the behaviour on HSW+\n\t */\n\treturn hdisplay == 4096 && !HAS_DDI(dev_priv);\n}\n\nstatic enum drm_mode_status\nintel_dp_mode_valid_downstream(struct intel_connector *connector,\n\t\t\t       const struct drm_display_mode *mode,\n\t\t\t       int target_clock)\n{\n\tstruct intel_dp *intel_dp = intel_attached_dp(connector);\n\tconst struct drm_display_info *info = &connector->base.display_info;\n\tint tmds_clock;\n\n\tif (intel_dp->dfp.max_dotclock &&\n\t    target_clock > intel_dp->dfp.max_dotclock)\n\t\treturn MODE_CLOCK_HIGH;\n\n\t/* Assume 8bpc for the DP++/HDMI/DVI TMDS clock check */\n\ttmds_clock = target_clock;\n\tif (drm_mode_is_420_only(info, mode))\n\t\ttmds_clock /= 2;\n\n\tif (intel_dp->dfp.min_tmds_clock &&\n\t    tmds_clock < intel_dp->dfp.min_tmds_clock)\n\t\treturn MODE_CLOCK_LOW;\n\tif (intel_dp->dfp.max_tmds_clock &&\n\t    tmds_clock > intel_dp->dfp.max_tmds_clock)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic enum drm_mode_status\nintel_dp_mode_valid(struct drm_connector *connector,\n\t\t    struct drm_display_mode *mode)\n{\n\tstruct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));\n\tstruct intel_connector *intel_connector = to_intel_connector(connector);\n\tstruct drm_display_mode *fixed_mode = intel_connector->panel.fixed_mode;\n\tstruct drm_i915_private *dev_priv = to_i915(connector->dev);\n\tint target_clock = mode->clock;\n\tint max_rate, mode_rate, max_lanes, max_link_clock;\n\tint max_dotclk = dev_priv->max_dotclk_freq;\n\tu16 dsc_max_output_bpp = 0;\n\tu8 dsc_slice_count = 0;\n\tenum drm_mode_status status;\n\tbool dsc = false, bigjoiner = false;\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn MODE_NO_DBLESCAN;\n\n\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\treturn MODE_H_ILLEGAL;\n\n\tif (intel_dp_is_edp(intel_dp) && fixed_mode) {\n\t\tif (mode->hdisplay > fixed_mode->hdisplay)\n\t\t\treturn MODE_PANEL;\n\n\t\tif (mode->vdisplay > fixed_mode->vdisplay)\n\t\t\treturn MODE_PANEL;\n\n\t\ttarget_clock = fixed_mode->clock;\n\t}\n\n\tif (mode->clock < 10000)\n\t\treturn MODE_CLOCK_LOW;\n\n\tif ((target_clock > max_dotclk || mode->hdisplay > 5120) &&\n\t    intel_dp_can_bigjoiner(intel_dp)) {\n\t\tbigjoiner = true;\n\t\tmax_dotclk *= 2;\n\t}\n\tif (target_clock > max_dotclk)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tmax_link_clock = intel_dp_max_link_rate(intel_dp);\n\tmax_lanes = intel_dp_max_lane_count(intel_dp);\n\n\tmax_rate = intel_dp_max_data_rate(max_link_clock, max_lanes);\n\tmode_rate = intel_dp_link_required(target_clock,\n\t\t\t\t\t   intel_dp_mode_min_output_bpp(connector, mode));\n\n\tif (intel_dp_hdisplay_bad(dev_priv, mode->hdisplay))\n\t\treturn MODE_H_ILLEGAL;\n\n\t/*\n\t * Output bpp is stored in 6.4 format so right shift by 4 to get the\n\t * integer value since we support only integer values of bpp.\n\t */\n\tif ((INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv)) &&\n\t    drm_dp_sink_supports_dsc(intel_dp->dsc_dpcd)) {\n\t\tif (intel_dp_is_edp(intel_dp)) {\n\t\t\tdsc_max_output_bpp =\n\t\t\t\tdrm_edp_dsc_sink_output_bpp(intel_dp->dsc_dpcd) >> 4;\n\t\t\tdsc_slice_count =\n\t\t\t\tdrm_dp_dsc_sink_max_slice_count(intel_dp->dsc_dpcd,\n\t\t\t\t\t\t\t\ttrue);\n\t\t} else if (drm_dp_sink_supports_fec(intel_dp->fec_capable)) {\n\t\t\tdsc_max_output_bpp =\n\t\t\t\tintel_dp_dsc_get_output_bpp(dev_priv,\n\t\t\t\t\t\t\t    max_link_clock,\n\t\t\t\t\t\t\t    max_lanes,\n\t\t\t\t\t\t\t    target_clock,\n\t\t\t\t\t\t\t    mode->hdisplay,\n\t\t\t\t\t\t\t    bigjoiner) >> 4;\n\t\t\tdsc_slice_count =\n\t\t\t\tintel_dp_dsc_get_slice_count(intel_dp,\n\t\t\t\t\t\t\t     target_clock,\n\t\t\t\t\t\t\t     mode->hdisplay,\n\t\t\t\t\t\t\t     bigjoiner);\n\t\t}\n\n\t\tdsc = dsc_max_output_bpp && dsc_slice_count;\n\t}\n\n\t/* big joiner configuration needs DSC */\n\tif (bigjoiner && !dsc)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (mode_rate > max_rate && !dsc)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tstatus = intel_dp_mode_valid_downstream(intel_connector,\n\t\t\t\t\t\tmode, target_clock);\n\tif (status != MODE_OK)\n\t\treturn status;\n\n\treturn intel_mode_valid_max_plane_size(dev_priv, mode, bigjoiner);\n}\n\nu32 intel_dp_pack_aux(const u8 *src, int src_bytes)\n{\n\tint i;\n\tu32 v = 0;\n\n\tif (src_bytes > 4)\n\t\tsrc_bytes = 4;\n\tfor (i = 0; i < src_bytes; i++)\n\t\tv |= ((u32)src[i]) << ((3 - i) * 8);\n\treturn v;\n}\n\nstatic void intel_dp_unpack_aux(u32 src, u8 *dst, int dst_bytes)\n{\n\tint i;\n\tif (dst_bytes > 4)\n\t\tdst_bytes = 4;\n\tfor (i = 0; i < dst_bytes; i++)\n\t\tdst[i] = src >> ((3-i) * 8);\n}\n\nstatic void\nintel_dp_init_panel_power_sequencer(struct intel_dp *intel_dp);\nstatic void\nintel_dp_init_panel_power_sequencer_registers(struct intel_dp *intel_dp,\n\t\t\t\t\t      bool force_disable_vdd);\nstatic void\nintel_dp_pps_init(struct intel_dp *intel_dp);\n\nstatic intel_wakeref_t\npps_lock(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tintel_wakeref_t wakeref;\n\n\t/*\n\t * See intel_power_sequencer_reset() why we need\n\t * a power domain reference here.\n\t */\n\twakeref = intel_display_power_get(dev_priv,\n\t\t\t\t\t  intel_aux_power_domain(dp_to_dig_port(intel_dp)));\n\n\tmutex_lock(&dev_priv->pps_mutex);\n\n\treturn wakeref;\n}\n\nstatic intel_wakeref_t\npps_unlock(struct intel_dp *intel_dp, intel_wakeref_t wakeref)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tmutex_unlock(&dev_priv->pps_mutex);\n\tintel_display_power_put(dev_priv,\n\t\t\t\tintel_aux_power_domain(dp_to_dig_port(intel_dp)),\n\t\t\t\twakeref);\n\treturn 0;\n}\n\n#define with_pps_lock(dp, wf) \\\n\tfor ((wf) = pps_lock(dp); (wf); (wf) = pps_unlock((dp), (wf)))\n\nstatic void\nvlv_power_sequencer_kick(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum pipe pipe = intel_dp->pps_pipe;\n\tbool pll_enabled, release_cl_override = false;\n\tenum dpio_phy phy = DPIO_PHY(pipe);\n\tenum dpio_channel ch = vlv_pipe_to_channel(pipe);\n\tu32 DP;\n\n\tif (drm_WARN(&dev_priv->drm,\n\t\t     intel_de_read(dev_priv, intel_dp->output_reg) & DP_PORT_EN,\n\t\t     \"skipping pipe %c power sequencer kick due to [ENCODER:%d:%s] being active\\n\",\n\t\t     pipe_name(pipe), dig_port->base.base.base.id,\n\t\t     dig_port->base.base.name))\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"kicking pipe %c power sequencer for [ENCODER:%d:%s]\\n\",\n\t\t    pipe_name(pipe), dig_port->base.base.base.id,\n\t\t    dig_port->base.base.name);\n\n\t/* Preserve the BIOS-computed detected bit. This is\n\t * supposed to be read-only.\n\t */\n\tDP = intel_de_read(dev_priv, intel_dp->output_reg) & DP_DETECTED;\n\tDP |= DP_VOLTAGE_0_4 | DP_PRE_EMPHASIS_0;\n\tDP |= DP_PORT_WIDTH(1);\n\tDP |= DP_LINK_TRAIN_PAT_1;\n\n\tif (IS_CHERRYVIEW(dev_priv))\n\t\tDP |= DP_PIPE_SEL_CHV(pipe);\n\telse\n\t\tDP |= DP_PIPE_SEL(pipe);\n\n\tpll_enabled = intel_de_read(dev_priv, DPLL(pipe)) & DPLL_VCO_ENABLE;\n\n\t/*\n\t * The DPLL for the pipe must be enabled for this to work.\n\t * So enable temporarily it if it's not already enabled.\n\t */\n\tif (!pll_enabled) {\n\t\trelease_cl_override = IS_CHERRYVIEW(dev_priv) &&\n\t\t\t!chv_phy_powergate_ch(dev_priv, phy, ch, true);\n\n\t\tif (vlv_force_pll_on(dev_priv, pipe, IS_CHERRYVIEW(dev_priv) ?\n\t\t\t\t     &chv_dpll[0].dpll : &vlv_dpll[0].dpll)) {\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Failed to force on pll for pipe %c!\\n\",\n\t\t\t\tpipe_name(pipe));\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Similar magic as in intel_dp_enable_port().\n\t * We _must_ do this port enable + disable trick\n\t * to make this power sequencer lock onto the port.\n\t * Otherwise even VDD force bit won't work.\n\t */\n\tintel_de_write(dev_priv, intel_dp->output_reg, DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n\n\tintel_de_write(dev_priv, intel_dp->output_reg, DP | DP_PORT_EN);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n\n\tintel_de_write(dev_priv, intel_dp->output_reg, DP & ~DP_PORT_EN);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n\n\tif (!pll_enabled) {\n\t\tvlv_force_pll_off(dev_priv, pipe);\n\n\t\tif (release_cl_override)\n\t\t\tchv_phy_powergate_ch(dev_priv, phy, ch, false);\n\t}\n}\n\nstatic enum pipe vlv_find_free_pps(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\tunsigned int pipes = (1 << PIPE_A) | (1 << PIPE_B);\n\n\t/*\n\t * We don't have power sequencer currently.\n\t * Pick one that's not used by other ports.\n\t */\n\tfor_each_intel_dp(&dev_priv->drm, encoder) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\tif (encoder->type == INTEL_OUTPUT_EDP) {\n\t\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t\t    intel_dp->active_pipe != INVALID_PIPE &&\n\t\t\t\t    intel_dp->active_pipe !=\n\t\t\t\t    intel_dp->pps_pipe);\n\n\t\t\tif (intel_dp->pps_pipe != INVALID_PIPE)\n\t\t\t\tpipes &= ~(1 << intel_dp->pps_pipe);\n\t\t} else {\n\t\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t\t    intel_dp->pps_pipe != INVALID_PIPE);\n\n\t\t\tif (intel_dp->active_pipe != INVALID_PIPE)\n\t\t\t\tpipes &= ~(1 << intel_dp->active_pipe);\n\t\t}\n\t}\n\n\tif (pipes == 0)\n\t\treturn INVALID_PIPE;\n\n\treturn ffs(pipes) - 1;\n}\n\nstatic enum pipe\nvlv_power_sequencer_pipe(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum pipe pipe;\n\n\tlockdep_assert_held(&dev_priv->pps_mutex);\n\n\t/* We should never land here with regular DP ports */\n\tdrm_WARN_ON(&dev_priv->drm, !intel_dp_is_edp(intel_dp));\n\n\tdrm_WARN_ON(&dev_priv->drm, intel_dp->active_pipe != INVALID_PIPE &&\n\t\t    intel_dp->active_pipe != intel_dp->pps_pipe);\n\n\tif (intel_dp->pps_pipe != INVALID_PIPE)\n\t\treturn intel_dp->pps_pipe;\n\n\tpipe = vlv_find_free_pps(dev_priv);\n\n\t/*\n\t * Didn't find one. This should not happen since there\n\t * are two power sequencers and up to two eDP ports.\n\t */\n\tif (drm_WARN_ON(&dev_priv->drm, pipe == INVALID_PIPE))\n\t\tpipe = PIPE_A;\n\n\tvlv_steal_power_sequencer(dev_priv, pipe);\n\tintel_dp->pps_pipe = pipe;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"picked pipe %c power sequencer for [ENCODER:%d:%s]\\n\",\n\t\t    pipe_name(intel_dp->pps_pipe),\n\t\t    dig_port->base.base.base.id,\n\t\t    dig_port->base.base.name);\n\n\t/* init power sequencer on this pipe and port */\n\tintel_dp_init_panel_power_sequencer(intel_dp);\n\tintel_dp_init_panel_power_sequencer_registers(intel_dp, true);\n\n\t/*\n\t * Even vdd force doesn't work until we've made\n\t * the power sequencer lock in on the port.\n\t */\n\tvlv_power_sequencer_kick(intel_dp);\n\n\treturn intel_dp->pps_pipe;\n}\n\nstatic int\nbxt_power_sequencer_idx(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tint backlight_controller = dev_priv->vbt.backlight.controller;\n\n\tlockdep_assert_held(&dev_priv->pps_mutex);\n\n\t/* We should never land here with regular DP ports */\n\tdrm_WARN_ON(&dev_priv->drm, !intel_dp_is_edp(intel_dp));\n\n\tif (!intel_dp->pps_reset)\n\t\treturn backlight_controller;\n\n\tintel_dp->pps_reset = false;\n\n\t/*\n\t * Only the HW needs to be reprogrammed, the SW state is fixed and\n\t * has been setup during connector init.\n\t */\n\tintel_dp_init_panel_power_sequencer_registers(intel_dp, false);\n\n\treturn backlight_controller;\n}\n\ntypedef bool (*vlv_pipe_check)(struct drm_i915_private *dev_priv,\n\t\t\t       enum pipe pipe);\n\nstatic bool vlv_pipe_has_pp_on(struct drm_i915_private *dev_priv,\n\t\t\t       enum pipe pipe)\n{\n\treturn intel_de_read(dev_priv, PP_STATUS(pipe)) & PP_ON;\n}\n\nstatic bool vlv_pipe_has_vdd_on(struct drm_i915_private *dev_priv,\n\t\t\t\tenum pipe pipe)\n{\n\treturn intel_de_read(dev_priv, PP_CONTROL(pipe)) & EDP_FORCE_VDD;\n}\n\nstatic bool vlv_pipe_any(struct drm_i915_private *dev_priv,\n\t\t\t enum pipe pipe)\n{\n\treturn true;\n}\n\nstatic enum pipe\nvlv_initial_pps_pipe(struct drm_i915_private *dev_priv,\n\t\t     enum port port,\n\t\t     vlv_pipe_check pipe_check)\n{\n\tenum pipe pipe;\n\n\tfor (pipe = PIPE_A; pipe <= PIPE_B; pipe++) {\n\t\tu32 port_sel = intel_de_read(dev_priv, PP_ON_DELAYS(pipe)) &\n\t\t\tPANEL_PORT_SELECT_MASK;\n\n\t\tif (port_sel != PANEL_PORT_SELECT_VLV(port))\n\t\t\tcontinue;\n\n\t\tif (!pipe_check(dev_priv, pipe))\n\t\t\tcontinue;\n\n\t\treturn pipe;\n\t}\n\n\treturn INVALID_PIPE;\n}\n\nstatic void\nvlv_initial_power_sequencer_setup(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum port port = dig_port->base.port;\n\n\tlockdep_assert_held(&dev_priv->pps_mutex);\n\n\t/* try to find a pipe with this port selected */\n\t/* first pick one where the panel is on */\n\tintel_dp->pps_pipe = vlv_initial_pps_pipe(dev_priv, port,\n\t\t\t\t\t\t  vlv_pipe_has_pp_on);\n\t/* didn't find one? pick one where vdd is on */\n\tif (intel_dp->pps_pipe == INVALID_PIPE)\n\t\tintel_dp->pps_pipe = vlv_initial_pps_pipe(dev_priv, port,\n\t\t\t\t\t\t\t  vlv_pipe_has_vdd_on);\n\t/* didn't find one? pick one with just the correct port */\n\tif (intel_dp->pps_pipe == INVALID_PIPE)\n\t\tintel_dp->pps_pipe = vlv_initial_pps_pipe(dev_priv, port,\n\t\t\t\t\t\t\t  vlv_pipe_any);\n\n\t/* didn't find one? just let vlv_power_sequencer_pipe() pick one when needed */\n\tif (intel_dp->pps_pipe == INVALID_PIPE) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"no initial power sequencer for [ENCODER:%d:%s]\\n\",\n\t\t\t    dig_port->base.base.base.id,\n\t\t\t    dig_port->base.base.name);\n\t\treturn;\n\t}\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"initial power sequencer for [ENCODER:%d:%s]: pipe %c\\n\",\n\t\t    dig_port->base.base.base.id,\n\t\t    dig_port->base.base.name,\n\t\t    pipe_name(intel_dp->pps_pipe));\n\n\tintel_dp_init_panel_power_sequencer(intel_dp);\n\tintel_dp_init_panel_power_sequencer_registers(intel_dp, false);\n}\n\nvoid intel_power_sequencer_reset(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\n\tif (drm_WARN_ON(&dev_priv->drm,\n\t\t\t!(IS_VALLEYVIEW(dev_priv) ||\n\t\t\t  IS_CHERRYVIEW(dev_priv) ||\n\t\t\t  IS_GEN9_LP(dev_priv))))\n\t\treturn;\n\n\t/*\n\t * We can't grab pps_mutex here due to deadlock with power_domain\n\t * mutex when power_domain functions are called while holding pps_mutex.\n\t * That also means that in order to use pps_pipe the code needs to\n\t * hold both a power domain reference and pps_mutex, and the power domain\n\t * reference get/put must be done while _not_ holding pps_mutex.\n\t * pps_{lock,unlock}() do these steps in the correct order, so one\n\t * should use them always.\n\t */\n\n\tfor_each_intel_dp(&dev_priv->drm, encoder) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\tdrm_WARN_ON(&dev_priv->drm,\n\t\t\t    intel_dp->active_pipe != INVALID_PIPE);\n\n\t\tif (encoder->type != INTEL_OUTPUT_EDP)\n\t\t\tcontinue;\n\n\t\tif (IS_GEN9_LP(dev_priv))\n\t\t\tintel_dp->pps_reset = true;\n\t\telse\n\t\t\tintel_dp->pps_pipe = INVALID_PIPE;\n\t}\n}\n\nstruct pps_registers {\n\ti915_reg_t pp_ctrl;\n\ti915_reg_t pp_stat;\n\ti915_reg_t pp_on;\n\ti915_reg_t pp_off;\n\ti915_reg_t pp_div;\n};\n\nstatic void intel_pps_get_registers(struct intel_dp *intel_dp,\n\t\t\t\t    struct pps_registers *regs)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tint pps_idx = 0;\n\n\tmemset(regs, 0, sizeof(*regs));\n\n\tif (IS_GEN9_LP(dev_priv))\n\t\tpps_idx = bxt_power_sequencer_idx(intel_dp);\n\telse if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\tpps_idx = vlv_power_sequencer_pipe(intel_dp);\n\n\tregs->pp_ctrl = PP_CONTROL(pps_idx);\n\tregs->pp_stat = PP_STATUS(pps_idx);\n\tregs->pp_on = PP_ON_DELAYS(pps_idx);\n\tregs->pp_off = PP_OFF_DELAYS(pps_idx);\n\n\t/* Cycle delay moved from PP_DIVISOR to PP_CONTROL */\n\tif (IS_GEN9_LP(dev_priv) || INTEL_PCH_TYPE(dev_priv) >= PCH_CNP)\n\t\tregs->pp_div = INVALID_MMIO_REG;\n\telse\n\t\tregs->pp_div = PP_DIVISOR(pps_idx);\n}\n\nstatic i915_reg_t\n_pp_ctrl_reg(struct intel_dp *intel_dp)\n{\n\tstruct pps_registers regs;\n\n\tintel_pps_get_registers(intel_dp, &regs);\n\n\treturn regs.pp_ctrl;\n}\n\nstatic i915_reg_t\n_pp_stat_reg(struct intel_dp *intel_dp)\n{\n\tstruct pps_registers regs;\n\n\tintel_pps_get_registers(intel_dp, &regs);\n\n\treturn regs.pp_stat;\n}\n\nstatic bool edp_have_panel_power(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tlockdep_assert_held(&dev_priv->pps_mutex);\n\n\tif ((IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) &&\n\t    intel_dp->pps_pipe == INVALID_PIPE)\n\t\treturn false;\n\n\treturn (intel_de_read(dev_priv, _pp_stat_reg(intel_dp)) & PP_ON) != 0;\n}\n\nstatic bool edp_have_panel_vdd(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tlockdep_assert_held(&dev_priv->pps_mutex);\n\n\tif ((IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) &&\n\t    intel_dp->pps_pipe == INVALID_PIPE)\n\t\treturn false;\n\n\treturn intel_de_read(dev_priv, _pp_ctrl_reg(intel_dp)) & EDP_FORCE_VDD;\n}\n\nstatic void\nintel_dp_check_edp(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\tif (!edp_have_panel_power(intel_dp) && !edp_have_panel_vdd(intel_dp)) {\n\t\tdrm_WARN(&dev_priv->drm, 1,\n\t\t\t \"eDP powered off while attempting aux channel communication.\\n\");\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Status 0x%08x Control 0x%08x\\n\",\n\t\t\t    intel_de_read(dev_priv, _pp_stat_reg(intel_dp)),\n\t\t\t    intel_de_read(dev_priv, _pp_ctrl_reg(intel_dp)));\n\t}\n}\n\nstatic u32\nintel_dp_aux_wait_done(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\ti915_reg_t ch_ctl = intel_dp->aux_ch_ctl_reg(intel_dp);\n\tconst unsigned int timeout_ms = 10;\n\tu32 status;\n\tbool done;\n\n#define C (((status = intel_uncore_read_notrace(&i915->uncore, ch_ctl)) & DP_AUX_CH_CTL_SEND_BUSY) == 0)\n\tdone = wait_event_timeout(i915->gmbus_wait_queue, C,\n\t\t\t\t  msecs_to_jiffies_timeout(timeout_ms));\n\n\t/* just trace the final value */\n\ttrace_i915_reg_rw(false, ch_ctl, status, sizeof(status), true);\n\n\tif (!done)\n\t\tdrm_err(&i915->drm,\n\t\t\t\"%s: did not complete or timeout within %ums (status 0x%08x)\\n\",\n\t\t\tintel_dp->aux.name, timeout_ms, status);\n#undef C\n\n\treturn status;\n}\n\nstatic u32 g4x_get_aux_clock_divider(struct intel_dp *intel_dp, int index)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tif (index)\n\t\treturn 0;\n\n\t/*\n\t * The clock divider is based off the hrawclk, and would like to run at\n\t * 2MHz.  So, take the hrawclk value and divide by 2000 and use that\n\t */\n\treturn DIV_ROUND_CLOSEST(RUNTIME_INFO(dev_priv)->rawclk_freq, 2000);\n}\n\nstatic u32 ilk_get_aux_clock_divider(struct intel_dp *intel_dp, int index)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tu32 freq;\n\n\tif (index)\n\t\treturn 0;\n\n\t/*\n\t * The clock divider is based off the cdclk or PCH rawclk, and would\n\t * like to run at 2MHz.  So, take the cdclk or PCH rawclk value and\n\t * divide by 2000 and use that\n\t */\n\tif (dig_port->aux_ch == AUX_CH_A)\n\t\tfreq = dev_priv->cdclk.hw.cdclk;\n\telse\n\t\tfreq = RUNTIME_INFO(dev_priv)->rawclk_freq;\n\treturn DIV_ROUND_CLOSEST(freq, 2000);\n}\n\nstatic u32 hsw_get_aux_clock_divider(struct intel_dp *intel_dp, int index)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\n\tif (dig_port->aux_ch != AUX_CH_A && HAS_PCH_LPT_H(dev_priv)) {\n\t\t/* Workaround for non-ULT HSW */\n\t\tswitch (index) {\n\t\tcase 0: return 63;\n\t\tcase 1: return 72;\n\t\tdefault: return 0;\n\t\t}\n\t}\n\n\treturn ilk_get_aux_clock_divider(intel_dp, index);\n}\n\nstatic u32 skl_get_aux_clock_divider(struct intel_dp *intel_dp, int index)\n{\n\t/*\n\t * SKL doesn't need us to program the AUX clock divider (Hardware will\n\t * derive the clock from CDCLK automatically). We still implement the\n\t * get_aux_clock_divider vfunc to plug-in into the existing code.\n\t */\n\treturn index ? 0 : 1;\n}\n\nstatic u32 g4x_get_aux_send_ctl(struct intel_dp *intel_dp,\n\t\t\t\tint send_bytes,\n\t\t\t\tu32 aux_clock_divider)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv =\n\t\t\tto_i915(dig_port->base.base.dev);\n\tu32 precharge, timeout;\n\n\tif (IS_GEN(dev_priv, 6))\n\t\tprecharge = 3;\n\telse\n\t\tprecharge = 5;\n\n\tif (IS_BROADWELL(dev_priv))\n\t\ttimeout = DP_AUX_CH_CTL_TIME_OUT_600us;\n\telse\n\t\ttimeout = DP_AUX_CH_CTL_TIME_OUT_400us;\n\n\treturn DP_AUX_CH_CTL_SEND_BUSY |\n\t       DP_AUX_CH_CTL_DONE |\n\t       DP_AUX_CH_CTL_INTERRUPT |\n\t       DP_AUX_CH_CTL_TIME_OUT_ERROR |\n\t       timeout |\n\t       DP_AUX_CH_CTL_RECEIVE_ERROR |\n\t       (send_bytes << DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT) |\n\t       (precharge << DP_AUX_CH_CTL_PRECHARGE_2US_SHIFT) |\n\t       (aux_clock_divider << DP_AUX_CH_CTL_BIT_CLOCK_2X_SHIFT);\n}\n\nstatic u32 skl_get_aux_send_ctl(struct intel_dp *intel_dp,\n\t\t\t\tint send_bytes,\n\t\t\t\tu32 unused)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *i915 =\n\t\t\tto_i915(dig_port->base.base.dev);\n\tenum phy phy = intel_port_to_phy(i915, dig_port->base.port);\n\tu32 ret;\n\n\tret = DP_AUX_CH_CTL_SEND_BUSY |\n\t      DP_AUX_CH_CTL_DONE |\n\t      DP_AUX_CH_CTL_INTERRUPT |\n\t      DP_AUX_CH_CTL_TIME_OUT_ERROR |\n\t      DP_AUX_CH_CTL_TIME_OUT_MAX |\n\t      DP_AUX_CH_CTL_RECEIVE_ERROR |\n\t      (send_bytes << DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT) |\n\t      DP_AUX_CH_CTL_FW_SYNC_PULSE_SKL(32) |\n\t      DP_AUX_CH_CTL_SYNC_PULSE_SKL(32);\n\n\tif (intel_phy_is_tc(i915, phy) &&\n\t    dig_port->tc_mode == TC_PORT_TBT_ALT)\n\t\tret |= DP_AUX_CH_CTL_TBT_IO;\n\n\treturn ret;\n}\n\nstatic int\nintel_dp_aux_xfer(struct intel_dp *intel_dp,\n\t\t  const u8 *send, int send_bytes,\n\t\t  u8 *recv, int recv_size,\n\t\t  u32 aux_send_ctl_flags)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *i915 =\n\t\t\tto_i915(dig_port->base.base.dev);\n\tstruct intel_uncore *uncore = &i915->uncore;\n\tenum phy phy = intel_port_to_phy(i915, dig_port->base.port);\n\tbool is_tc_port = intel_phy_is_tc(i915, phy);\n\ti915_reg_t ch_ctl, ch_data[5];\n\tu32 aux_clock_divider;\n\tenum intel_display_power_domain aux_domain;\n\tintel_wakeref_t aux_wakeref;\n\tintel_wakeref_t pps_wakeref;\n\tint i, ret, recv_bytes;\n\tint try, clock = 0;\n\tu32 status;\n\tbool vdd;\n\n\tch_ctl = intel_dp->aux_ch_ctl_reg(intel_dp);\n\tfor (i = 0; i < ARRAY_SIZE(ch_data); i++)\n\t\tch_data[i] = intel_dp->aux_ch_data_reg(intel_dp, i);\n\n\tif (is_tc_port)\n\t\tintel_tc_port_lock(dig_port);\n\n\taux_domain = intel_aux_power_domain(dig_port);\n\n\taux_wakeref = intel_display_power_get(i915, aux_domain);\n\tpps_wakeref = pps_lock(intel_dp);\n\n\t/*\n\t * We will be called with VDD already enabled for dpcd/edid/oui reads.\n\t * In such cases we want to leave VDD enabled and it's up to upper layers\n\t * to turn it off. But for eg. i2c-dev access we need to turn it on/off\n\t * ourselves.\n\t */\n\tvdd = edp_panel_vdd_on(intel_dp);\n\n\t/* dp aux is extremely sensitive to irq latency, hence request the\n\t * lowest possible wakeup latency and so prevent the cpu from going into\n\t * deep sleep states.\n\t */\n\tcpu_latency_qos_update_request(&i915->pm_qos, 0);\n\n\tintel_dp_check_edp(intel_dp);\n\n\t/* Try to wait for any previous AUX channel activity */\n\tfor (try = 0; try < 3; try++) {\n\t\tstatus = intel_uncore_read_notrace(uncore, ch_ctl);\n\t\tif ((status & DP_AUX_CH_CTL_SEND_BUSY) == 0)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\t/* just trace the final value */\n\ttrace_i915_reg_rw(false, ch_ctl, status, sizeof(status), true);\n\n\tif (try == 3) {\n\t\tconst u32 status = intel_uncore_read(uncore, ch_ctl);\n\n\t\tif (status != intel_dp->aux_busy_last_status) {\n\t\t\tdrm_WARN(&i915->drm, 1,\n\t\t\t\t \"%s: not started (status 0x%08x)\\n\",\n\t\t\t\t intel_dp->aux.name, status);\n\t\t\tintel_dp->aux_busy_last_status = status;\n\t\t}\n\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/* Only 5 data registers! */\n\tif (drm_WARN_ON(&i915->drm, send_bytes > 20 || recv_size > 20)) {\n\t\tret = -E2BIG;\n\t\tgoto out;\n\t}\n\n\twhile ((aux_clock_divider = intel_dp->get_aux_clock_divider(intel_dp, clock++))) {\n\t\tu32 send_ctl = intel_dp->get_aux_send_ctl(intel_dp,\n\t\t\t\t\t\t\t  send_bytes,\n\t\t\t\t\t\t\t  aux_clock_divider);\n\n\t\tsend_ctl |= aux_send_ctl_flags;\n\n\t\t/* Must try at least 3 times according to DP spec */\n\t\tfor (try = 0; try < 5; try++) {\n\t\t\t/* Load the send data into the aux channel data registers */\n\t\t\tfor (i = 0; i < send_bytes; i += 4)\n\t\t\t\tintel_uncore_write(uncore,\n\t\t\t\t\t\t   ch_data[i >> 2],\n\t\t\t\t\t\t   intel_dp_pack_aux(send + i,\n\t\t\t\t\t\t\t\t     send_bytes - i));\n\n\t\t\t/* Send the command and wait for it to complete */\n\t\t\tintel_uncore_write(uncore, ch_ctl, send_ctl);\n\n\t\t\tstatus = intel_dp_aux_wait_done(intel_dp);\n\n\t\t\t/* Clear done status and any errors */\n\t\t\tintel_uncore_write(uncore,\n\t\t\t\t\t   ch_ctl,\n\t\t\t\t\t   status |\n\t\t\t\t\t   DP_AUX_CH_CTL_DONE |\n\t\t\t\t\t   DP_AUX_CH_CTL_TIME_OUT_ERROR |\n\t\t\t\t\t   DP_AUX_CH_CTL_RECEIVE_ERROR);\n\n\t\t\t/* DP CTS 1.2 Core Rev 1.1, 4.2.1.1 & 4.2.1.2\n\t\t\t *   400us delay required for errors and timeouts\n\t\t\t *   Timeout errors from the HW already meet this\n\t\t\t *   requirement so skip to next iteration\n\t\t\t */\n\t\t\tif (status & DP_AUX_CH_CTL_TIME_OUT_ERROR)\n\t\t\t\tcontinue;\n\n\t\t\tif (status & DP_AUX_CH_CTL_RECEIVE_ERROR) {\n\t\t\t\tusleep_range(400, 500);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (status & DP_AUX_CH_CTL_DONE)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif ((status & DP_AUX_CH_CTL_DONE) == 0) {\n\t\tdrm_err(&i915->drm, \"%s: not done (status 0x%08x)\\n\",\n\t\t\tintel_dp->aux.name, status);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\ndone:\n\t/* Check for timeout or receive error.\n\t * Timeouts occur when the sink is not connected\n\t */\n\tif (status & DP_AUX_CH_CTL_RECEIVE_ERROR) {\n\t\tdrm_err(&i915->drm, \"%s: receive error (status 0x%08x)\\n\",\n\t\t\tintel_dp->aux.name, status);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t/* Timeouts occur when the device isn't connected, so they're\n\t * \"normal\" -- don't fill the kernel log with these */\n\tif (status & DP_AUX_CH_CTL_TIME_OUT_ERROR) {\n\t\tdrm_dbg_kms(&i915->drm, \"%s: timeout (status 0x%08x)\\n\",\n\t\t\t    intel_dp->aux.name, status);\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t/* Unload any bytes sent back from the other side */\n\trecv_bytes = ((status & DP_AUX_CH_CTL_MESSAGE_SIZE_MASK) >>\n\t\t      DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT);\n\n\t/*\n\t * By BSpec: \"Message sizes of 0 or >20 are not allowed.\"\n\t * We have no idea of what happened so we return -EBUSY so\n\t * drm layer takes care for the necessary retries.\n\t */\n\tif (recv_bytes == 0 || recv_bytes > 20) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"%s: Forbidden recv_bytes = %d on aux transaction\\n\",\n\t\t\t    intel_dp->aux.name, recv_bytes);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (recv_bytes > recv_size)\n\t\trecv_bytes = recv_size;\n\n\tfor (i = 0; i < recv_bytes; i += 4)\n\t\tintel_dp_unpack_aux(intel_uncore_read(uncore, ch_data[i >> 2]),\n\t\t\t\t    recv + i, recv_bytes - i);\n\n\tret = recv_bytes;\nout:\n\tcpu_latency_qos_update_request(&i915->pm_qos, PM_QOS_DEFAULT_VALUE);\n\n\tif (vdd)\n\t\tedp_panel_vdd_off(intel_dp, false);\n\n\tpps_unlock(intel_dp, pps_wakeref);\n\tintel_display_power_put_async(i915, aux_domain, aux_wakeref);\n\n\tif (is_tc_port)\n\t\tintel_tc_port_unlock(dig_port);\n\n\treturn ret;\n}\n\n#define BARE_ADDRESS_SIZE\t3\n#define HEADER_SIZE\t\t(BARE_ADDRESS_SIZE + 1)\n\nstatic void\nintel_dp_aux_header(u8 txbuf[HEADER_SIZE],\n\t\t    const struct drm_dp_aux_msg *msg)\n{\n\ttxbuf[0] = (msg->request << 4) | ((msg->address >> 16) & 0xf);\n\ttxbuf[1] = (msg->address >> 8) & 0xff;\n\ttxbuf[2] = msg->address & 0xff;\n\ttxbuf[3] = msg->size - 1;\n}\n\nstatic u32 intel_dp_aux_xfer_flags(const struct drm_dp_aux_msg *msg)\n{\n\t/*\n\t * If we're trying to send the HDCP Aksv, we need to set a the Aksv\n\t * select bit to inform the hardware to send the Aksv after our header\n\t * since we can't access that data from software.\n\t */\n\tif ((msg->request & ~DP_AUX_I2C_MOT) == DP_AUX_NATIVE_WRITE &&\n\t    msg->address == DP_AUX_HDCP_AKSV)\n\t\treturn DP_AUX_CH_CTL_AUX_AKSV_SELECT;\n\n\treturn 0;\n}\n\nstatic ssize_t\nintel_dp_aux_transfer(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)\n{\n\tstruct intel_dp *intel_dp = container_of(aux, struct intel_dp, aux);\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 txbuf[20], rxbuf[20];\n\tsize_t txsize, rxsize;\n\tu32 flags = intel_dp_aux_xfer_flags(msg);\n\tint ret;\n\n\tintel_dp_aux_header(txbuf, msg);\n\n\tswitch (msg->request & ~DP_AUX_I2C_MOT) {\n\tcase DP_AUX_NATIVE_WRITE:\n\tcase DP_AUX_I2C_WRITE:\n\tcase DP_AUX_I2C_WRITE_STATUS_UPDATE:\n\t\ttxsize = msg->size ? HEADER_SIZE + msg->size : BARE_ADDRESS_SIZE;\n\t\trxsize = 2; /* 0 or 1 data bytes */\n\n\t\tif (drm_WARN_ON(&i915->drm, txsize > 20))\n\t\t\treturn -E2BIG;\n\n\t\tdrm_WARN_ON(&i915->drm, !msg->buffer != !msg->size);\n\n\t\tif (msg->buffer)\n\t\t\tmemcpy(txbuf + HEADER_SIZE, msg->buffer, msg->size);\n\n\t\tret = intel_dp_aux_xfer(intel_dp, txbuf, txsize,\n\t\t\t\t\trxbuf, rxsize, flags);\n\t\tif (ret > 0) {\n\t\t\tmsg->reply = rxbuf[0] >> 4;\n\n\t\t\tif (ret > 1) {\n\t\t\t\t/* Number of bytes written in a short write. */\n\t\t\t\tret = clamp_t(int, rxbuf[1], 0, msg->size);\n\t\t\t} else {\n\t\t\t\t/* Return payload size. */\n\t\t\t\tret = msg->size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase DP_AUX_NATIVE_READ:\n\tcase DP_AUX_I2C_READ:\n\t\ttxsize = msg->size ? HEADER_SIZE : BARE_ADDRESS_SIZE;\n\t\trxsize = msg->size + 1;\n\n\t\tif (drm_WARN_ON(&i915->drm, rxsize > 20))\n\t\t\treturn -E2BIG;\n\n\t\tret = intel_dp_aux_xfer(intel_dp, txbuf, txsize,\n\t\t\t\t\trxbuf, rxsize, flags);\n\t\tif (ret > 0) {\n\t\t\tmsg->reply = rxbuf[0] >> 4;\n\t\t\t/*\n\t\t\t * Assume happy day, and copy the data. The caller is\n\t\t\t * expected to check msg->reply before touching it.\n\t\t\t *\n\t\t\t * Return payload size.\n\t\t\t */\n\t\t\tret--;\n\t\t\tmemcpy(msg->buffer, rxbuf + 1, ret);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n\nstatic i915_reg_t g4x_aux_ctl_reg(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_B:\n\tcase AUX_CH_C:\n\tcase AUX_CH_D:\n\t\treturn DP_AUX_CH_CTL(aux_ch);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn DP_AUX_CH_CTL(AUX_CH_B);\n\t}\n}\n\nstatic i915_reg_t g4x_aux_data_reg(struct intel_dp *intel_dp, int index)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_B:\n\tcase AUX_CH_C:\n\tcase AUX_CH_D:\n\t\treturn DP_AUX_CH_DATA(aux_ch, index);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn DP_AUX_CH_DATA(AUX_CH_B, index);\n\t}\n}\n\nstatic i915_reg_t ilk_aux_ctl_reg(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_A:\n\t\treturn DP_AUX_CH_CTL(aux_ch);\n\tcase AUX_CH_B:\n\tcase AUX_CH_C:\n\tcase AUX_CH_D:\n\t\treturn PCH_DP_AUX_CH_CTL(aux_ch);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn DP_AUX_CH_CTL(AUX_CH_A);\n\t}\n}\n\nstatic i915_reg_t ilk_aux_data_reg(struct intel_dp *intel_dp, int index)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_A:\n\t\treturn DP_AUX_CH_DATA(aux_ch, index);\n\tcase AUX_CH_B:\n\tcase AUX_CH_C:\n\tcase AUX_CH_D:\n\t\treturn PCH_DP_AUX_CH_DATA(aux_ch, index);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn DP_AUX_CH_DATA(AUX_CH_A, index);\n\t}\n}\n\nstatic i915_reg_t skl_aux_ctl_reg(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_A:\n\tcase AUX_CH_B:\n\tcase AUX_CH_C:\n\tcase AUX_CH_D:\n\tcase AUX_CH_E:\n\tcase AUX_CH_F:\n\t\treturn DP_AUX_CH_CTL(aux_ch);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn DP_AUX_CH_CTL(AUX_CH_A);\n\t}\n}\n\nstatic i915_reg_t skl_aux_data_reg(struct intel_dp *intel_dp, int index)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_A:\n\tcase AUX_CH_B:\n\tcase AUX_CH_C:\n\tcase AUX_CH_D:\n\tcase AUX_CH_E:\n\tcase AUX_CH_F:\n\t\treturn DP_AUX_CH_DATA(aux_ch, index);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn DP_AUX_CH_DATA(AUX_CH_A, index);\n\t}\n}\n\nstatic i915_reg_t tgl_aux_ctl_reg(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_A:\n\tcase AUX_CH_B:\n\tcase AUX_CH_C:\n\tcase AUX_CH_USBC1:\n\tcase AUX_CH_USBC2:\n\tcase AUX_CH_USBC3:\n\tcase AUX_CH_USBC4:\n\tcase AUX_CH_USBC5:\n\tcase AUX_CH_USBC6:\n\t\treturn DP_AUX_CH_CTL(aux_ch);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn DP_AUX_CH_CTL(AUX_CH_A);\n\t}\n}\n\nstatic i915_reg_t tgl_aux_data_reg(struct intel_dp *intel_dp, int index)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tswitch (aux_ch) {\n\tcase AUX_CH_A:\n\tcase AUX_CH_B:\n\tcase AUX_CH_C:\n\tcase AUX_CH_USBC1:\n\tcase AUX_CH_USBC2:\n\tcase AUX_CH_USBC3:\n\tcase AUX_CH_USBC4:\n\tcase AUX_CH_USBC5:\n\tcase AUX_CH_USBC6:\n\t\treturn DP_AUX_CH_DATA(aux_ch, index);\n\tdefault:\n\t\tMISSING_CASE(aux_ch);\n\t\treturn DP_AUX_CH_DATA(AUX_CH_A, index);\n\t}\n}\n\nstatic void\nintel_dp_aux_fini(struct intel_dp *intel_dp)\n{\n\tkfree(intel_dp->aux.name);\n}\n\nstatic void\nintel_dp_aux_init(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct intel_encoder *encoder = &dig_port->base;\n\tenum aux_ch aux_ch = dig_port->aux_ch;\n\n\tif (INTEL_GEN(dev_priv) >= 12) {\n\t\tintel_dp->aux_ch_ctl_reg = tgl_aux_ctl_reg;\n\t\tintel_dp->aux_ch_data_reg = tgl_aux_data_reg;\n\t} else if (INTEL_GEN(dev_priv) >= 9) {\n\t\tintel_dp->aux_ch_ctl_reg = skl_aux_ctl_reg;\n\t\tintel_dp->aux_ch_data_reg = skl_aux_data_reg;\n\t} else if (HAS_PCH_SPLIT(dev_priv)) {\n\t\tintel_dp->aux_ch_ctl_reg = ilk_aux_ctl_reg;\n\t\tintel_dp->aux_ch_data_reg = ilk_aux_data_reg;\n\t} else {\n\t\tintel_dp->aux_ch_ctl_reg = g4x_aux_ctl_reg;\n\t\tintel_dp->aux_ch_data_reg = g4x_aux_data_reg;\n\t}\n\n\tif (INTEL_GEN(dev_priv) >= 9)\n\t\tintel_dp->get_aux_clock_divider = skl_get_aux_clock_divider;\n\telse if (IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv))\n\t\tintel_dp->get_aux_clock_divider = hsw_get_aux_clock_divider;\n\telse if (HAS_PCH_SPLIT(dev_priv))\n\t\tintel_dp->get_aux_clock_divider = ilk_get_aux_clock_divider;\n\telse\n\t\tintel_dp->get_aux_clock_divider = g4x_get_aux_clock_divider;\n\n\tif (INTEL_GEN(dev_priv) >= 9)\n\t\tintel_dp->get_aux_send_ctl = skl_get_aux_send_ctl;\n\telse\n\t\tintel_dp->get_aux_send_ctl = g4x_get_aux_send_ctl;\n\n\tdrm_dp_aux_init(&intel_dp->aux);\n\n\t/* Failure to allocate our preferred name is not critical */\n\tif (INTEL_GEN(dev_priv) >= 12 && aux_ch >= AUX_CH_USBC1)\n\t\tintel_dp->aux.name = kasprintf(GFP_KERNEL, \"AUX USBC%c/%s\",\n\t\t\t\t\t       aux_ch - AUX_CH_USBC1 + '1',\n\t\t\t\t\t       encoder->base.name);\n\telse\n\t\tintel_dp->aux.name = kasprintf(GFP_KERNEL, \"AUX %c/%s\",\n\t\t\t\t\t       aux_ch_name(aux_ch),\n\t\t\t\t\t       encoder->base.name);\n\n\tintel_dp->aux.transfer = intel_dp_aux_transfer;\n}\n\nbool intel_dp_source_supports_hbr2(struct intel_dp *intel_dp)\n{\n\tint max_rate = intel_dp->source_rates[intel_dp->num_source_rates - 1];\n\n\treturn max_rate >= 540000;\n}\n\nbool intel_dp_source_supports_hbr3(struct intel_dp *intel_dp)\n{\n\tint max_rate = intel_dp->source_rates[intel_dp->num_source_rates - 1];\n\n\treturn max_rate >= 810000;\n}\n\nstatic void\nintel_dp_set_clock(struct intel_encoder *encoder,\n\t\t   struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tconst struct dp_link_dpll *divisor = NULL;\n\tint i, count = 0;\n\n\tif (IS_G4X(dev_priv)) {\n\t\tdivisor = g4x_dpll;\n\t\tcount = ARRAY_SIZE(g4x_dpll);\n\t} else if (HAS_PCH_SPLIT(dev_priv)) {\n\t\tdivisor = pch_dpll;\n\t\tcount = ARRAY_SIZE(pch_dpll);\n\t} else if (IS_CHERRYVIEW(dev_priv)) {\n\t\tdivisor = chv_dpll;\n\t\tcount = ARRAY_SIZE(chv_dpll);\n\t} else if (IS_VALLEYVIEW(dev_priv)) {\n\t\tdivisor = vlv_dpll;\n\t\tcount = ARRAY_SIZE(vlv_dpll);\n\t}\n\n\tif (divisor && count) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (pipe_config->port_clock == divisor[i].clock) {\n\t\t\t\tpipe_config->dpll = divisor[i].dpll;\n\t\t\t\tpipe_config->clock_set = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void snprintf_int_array(char *str, size_t len,\n\t\t\t       const int *array, int nelem)\n{\n\tint i;\n\n\tstr[0] = '\\0';\n\n\tfor (i = 0; i < nelem; i++) {\n\t\tint r = snprintf(str, len, \"%s%d\", i ? \", \" : \"\", array[i]);\n\t\tif (r >= len)\n\t\t\treturn;\n\t\tstr += r;\n\t\tlen -= r;\n\t}\n}\n\nstatic void intel_dp_print_rates(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tchar str[128]; /* FIXME: too big for stack? */\n\n\tif (!drm_debug_enabled(DRM_UT_KMS))\n\t\treturn;\n\n\tsnprintf_int_array(str, sizeof(str),\n\t\t\t   intel_dp->source_rates, intel_dp->num_source_rates);\n\tdrm_dbg_kms(&i915->drm, \"source rates: %s\\n\", str);\n\n\tsnprintf_int_array(str, sizeof(str),\n\t\t\t   intel_dp->sink_rates, intel_dp->num_sink_rates);\n\tdrm_dbg_kms(&i915->drm, \"sink rates: %s\\n\", str);\n\n\tsnprintf_int_array(str, sizeof(str),\n\t\t\t   intel_dp->common_rates, intel_dp->num_common_rates);\n\tdrm_dbg_kms(&i915->drm, \"common rates: %s\\n\", str);\n}\n\nint\nintel_dp_max_link_rate(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tint len;\n\n\tlen = intel_dp_common_len_rate_limit(intel_dp, intel_dp->max_link_rate);\n\tif (drm_WARN_ON(&i915->drm, len <= 0))\n\t\treturn 162000;\n\n\treturn intel_dp->common_rates[len - 1];\n}\n\nint intel_dp_rate_select(struct intel_dp *intel_dp, int rate)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tint i = intel_dp_rate_index(intel_dp->sink_rates,\n\t\t\t\t    intel_dp->num_sink_rates, rate);\n\n\tif (drm_WARN_ON(&i915->drm, i < 0))\n\t\ti = 0;\n\n\treturn i;\n}\n\nvoid intel_dp_compute_rate(struct intel_dp *intel_dp, int port_clock,\n\t\t\t   u8 *link_bw, u8 *rate_select)\n{\n\t/* eDP 1.4 rate select method. */\n\tif (intel_dp->use_rate_select) {\n\t\t*link_bw = 0;\n\t\t*rate_select =\n\t\t\tintel_dp_rate_select(intel_dp, port_clock);\n\t} else {\n\t\t*link_bw = drm_dp_link_rate_to_bw_code(port_clock);\n\t\t*rate_select = 0;\n\t}\n}\n\nstatic bool intel_dp_source_supports_fec(struct intel_dp *intel_dp,\n\t\t\t\t\t const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\t/* On TGL, FEC is supported on all Pipes */\n\tif (INTEL_GEN(dev_priv) >= 12)\n\t\treturn true;\n\n\tif (IS_GEN(dev_priv, 11) && pipe_config->cpu_transcoder != TRANSCODER_A)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool intel_dp_supports_fec(struct intel_dp *intel_dp,\n\t\t\t\t  const struct intel_crtc_state *pipe_config)\n{\n\treturn intel_dp_source_supports_fec(intel_dp, pipe_config) &&\n\t\tdrm_dp_sink_supports_fec(intel_dp->fec_capable);\n}\n\nstatic bool intel_dp_supports_dsc(struct intel_dp *intel_dp,\n\t\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tif (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP) && !crtc_state->fec_enable)\n\t\treturn false;\n\n\treturn intel_dsc_source_support(crtc_state) &&\n\t\tdrm_dp_sink_supports_dsc(intel_dp->dsc_dpcd);\n}\n\nstatic bool intel_dp_hdmi_ycbcr420(struct intel_dp *intel_dp,\n\t\t\t\t   const struct intel_crtc_state *crtc_state)\n{\n\treturn crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR420 ||\n\t\t(crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR444 &&\n\t\t intel_dp->dfp.ycbcr_444_to_420);\n}\n\nstatic int intel_dp_hdmi_tmds_clock(struct intel_dp *intel_dp,\n\t\t\t\t    const struct intel_crtc_state *crtc_state, int bpc)\n{\n\tint clock = crtc_state->hw.adjusted_mode.crtc_clock * bpc / 8;\n\n\tif (intel_dp_hdmi_ycbcr420(intel_dp, crtc_state))\n\t\tclock /= 2;\n\n\treturn clock;\n}\n\nstatic bool intel_dp_hdmi_tmds_clock_valid(struct intel_dp *intel_dp,\n\t\t\t\t\t   const struct intel_crtc_state *crtc_state, int bpc)\n{\n\tint tmds_clock = intel_dp_hdmi_tmds_clock(intel_dp, crtc_state, bpc);\n\n\tif (intel_dp->dfp.min_tmds_clock &&\n\t    tmds_clock < intel_dp->dfp.min_tmds_clock)\n\t\treturn false;\n\n\tif (intel_dp->dfp.max_tmds_clock &&\n\t    tmds_clock > intel_dp->dfp.max_tmds_clock)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool intel_dp_hdmi_deep_color_possible(struct intel_dp *intel_dp,\n\t\t\t\t\t      const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t      int bpc)\n{\n\n\treturn intel_hdmi_deep_color_possible(crtc_state, bpc,\n\t\t\t\t\t      intel_dp->has_hdmi_sink,\n\t\t\t\t\t      intel_dp_hdmi_ycbcr420(intel_dp, crtc_state)) &&\n\t\tintel_dp_hdmi_tmds_clock_valid(intel_dp, crtc_state, bpc);\n}\n\nstatic int intel_dp_max_bpp(struct intel_dp *intel_dp,\n\t\t\t    const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_connector *intel_connector = intel_dp->attached_connector;\n\tint bpp, bpc;\n\n\tbpc = crtc_state->pipe_bpp / 3;\n\n\tif (intel_dp->dfp.max_bpc)\n\t\tbpc = min_t(int, bpc, intel_dp->dfp.max_bpc);\n\n\tif (intel_dp->dfp.min_tmds_clock) {\n\t\tfor (; bpc >= 10; bpc -= 2) {\n\t\t\tif (intel_dp_hdmi_deep_color_possible(intel_dp, crtc_state, bpc))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tbpp = bpc * 3;\n\tif (intel_dp_is_edp(intel_dp)) {\n\t\t/* Get bpp from vbt only for panels that dont have bpp in edid */\n\t\tif (intel_connector->base.display_info.bpc == 0 &&\n\t\t    dev_priv->vbt.edp.bpp && dev_priv->vbt.edp.bpp < bpp) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"clamping bpp for eDP panel to BIOS-provided %i\\n\",\n\t\t\t\t    dev_priv->vbt.edp.bpp);\n\t\t\tbpp = dev_priv->vbt.edp.bpp;\n\t\t}\n\t}\n\n\treturn bpp;\n}\n\n/* Adjust link config limits based on compliance test requests. */\nvoid\nintel_dp_adjust_compliance_config(struct intel_dp *intel_dp,\n\t\t\t\t  struct intel_crtc_state *pipe_config,\n\t\t\t\t  struct link_config_limits *limits)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\t/* For DP Compliance we override the computed bpp for the pipe */\n\tif (intel_dp->compliance.test_data.bpc != 0) {\n\t\tint bpp = 3 * intel_dp->compliance.test_data.bpc;\n\n\t\tlimits->min_bpp = limits->max_bpp = bpp;\n\t\tpipe_config->dither_force_disable = bpp == 6 * 3;\n\n\t\tdrm_dbg_kms(&i915->drm, \"Setting pipe_bpp to %d\\n\", bpp);\n\t}\n\n\t/* Use values requested by Compliance Test Request */\n\tif (intel_dp->compliance.test_type == DP_TEST_LINK_TRAINING) {\n\t\tint index;\n\n\t\t/* Validate the compliance test data since max values\n\t\t * might have changed due to link train fallback.\n\t\t */\n\t\tif (intel_dp_link_params_valid(intel_dp, intel_dp->compliance.test_link_rate,\n\t\t\t\t\t       intel_dp->compliance.test_lane_count)) {\n\t\t\tindex = intel_dp_rate_index(intel_dp->common_rates,\n\t\t\t\t\t\t    intel_dp->num_common_rates,\n\t\t\t\t\t\t    intel_dp->compliance.test_link_rate);\n\t\t\tif (index >= 0)\n\t\t\t\tlimits->min_clock = limits->max_clock = index;\n\t\t\tlimits->min_lane_count = limits->max_lane_count =\n\t\t\t\tintel_dp->compliance.test_lane_count;\n\t\t}\n\t}\n}\n\n/* Optimize link config in order: max bpp, min clock, min lanes */\nstatic int\nintel_dp_compute_link_config_wide(struct intel_dp *intel_dp,\n\t\t\t\t  struct intel_crtc_state *pipe_config,\n\t\t\t\t  const struct link_config_limits *limits)\n{\n\tstruct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;\n\tint bpp, clock, lane_count;\n\tint mode_rate, link_clock, link_avail;\n\n\tfor (bpp = limits->max_bpp; bpp >= limits->min_bpp; bpp -= 2 * 3) {\n\t\tint output_bpp = intel_dp_output_bpp(pipe_config->output_format, bpp);\n\n\t\tmode_rate = intel_dp_link_required(adjusted_mode->crtc_clock,\n\t\t\t\t\t\t   output_bpp);\n\n\t\tfor (clock = limits->min_clock; clock <= limits->max_clock; clock++) {\n\t\t\tfor (lane_count = limits->min_lane_count;\n\t\t\t     lane_count <= limits->max_lane_count;\n\t\t\t     lane_count <<= 1) {\n\t\t\t\tlink_clock = intel_dp->common_rates[clock];\n\t\t\t\tlink_avail = intel_dp_max_data_rate(link_clock,\n\t\t\t\t\t\t\t\t    lane_count);\n\n\t\t\t\tif (mode_rate <= link_avail) {\n\t\t\t\t\tpipe_config->lane_count = lane_count;\n\t\t\t\t\tpipe_config->pipe_bpp = bpp;\n\t\t\t\t\tpipe_config->port_clock = link_clock;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int intel_dp_dsc_compute_bpp(struct intel_dp *intel_dp, u8 dsc_max_bpc)\n{\n\tint i, num_bpc;\n\tu8 dsc_bpc[3] = {0};\n\n\tnum_bpc = drm_dp_dsc_sink_supported_input_bpcs(intel_dp->dsc_dpcd,\n\t\t\t\t\t\t       dsc_bpc);\n\tfor (i = 0; i < num_bpc; i++) {\n\t\tif (dsc_max_bpc >= dsc_bpc[i])\n\t\t\treturn dsc_bpc[i] * 3;\n\t}\n\n\treturn 0;\n}\n\n#define DSC_SUPPORTED_VERSION_MIN\t\t1\n\nstatic int intel_dp_dsc_compute_params(struct intel_encoder *encoder,\n\t\t\t\t       struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct drm_dsc_config *vdsc_cfg = &crtc_state->dsc.config;\n\tu8 line_buf_depth;\n\tint ret;\n\n\tret = intel_dsc_compute_params(encoder, crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Slice Height of 8 works for all currently available panels. So start\n\t * with that if pic_height is an integral multiple of 8. Eventually add\n\t * logic to try multiple slice heights.\n\t */\n\tif (vdsc_cfg->pic_height % 8 == 0)\n\t\tvdsc_cfg->slice_height = 8;\n\telse if (vdsc_cfg->pic_height % 4 == 0)\n\t\tvdsc_cfg->slice_height = 4;\n\telse\n\t\tvdsc_cfg->slice_height = 2;\n\n\tvdsc_cfg->dsc_version_major =\n\t\t(intel_dp->dsc_dpcd[DP_DSC_REV - DP_DSC_SUPPORT] &\n\t\t DP_DSC_MAJOR_MASK) >> DP_DSC_MAJOR_SHIFT;\n\tvdsc_cfg->dsc_version_minor =\n\t\tmin(DSC_SUPPORTED_VERSION_MIN,\n\t\t    (intel_dp->dsc_dpcd[DP_DSC_REV - DP_DSC_SUPPORT] &\n\t\t     DP_DSC_MINOR_MASK) >> DP_DSC_MINOR_SHIFT);\n\n\tvdsc_cfg->convert_rgb = intel_dp->dsc_dpcd[DP_DSC_DEC_COLOR_FORMAT_CAP - DP_DSC_SUPPORT] &\n\t\tDP_DSC_RGB;\n\n\tline_buf_depth = drm_dp_dsc_sink_line_buf_depth(intel_dp->dsc_dpcd);\n\tif (!line_buf_depth) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"DSC Sink Line Buffer Depth invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vdsc_cfg->dsc_version_minor == 2)\n\t\tvdsc_cfg->line_buf_depth = (line_buf_depth == DSC_1_2_MAX_LINEBUF_DEPTH_BITS) ?\n\t\t\tDSC_1_2_MAX_LINEBUF_DEPTH_VAL : line_buf_depth;\n\telse\n\t\tvdsc_cfg->line_buf_depth = (line_buf_depth > DSC_1_1_MAX_LINEBUF_DEPTH_BITS) ?\n\t\t\tDSC_1_1_MAX_LINEBUF_DEPTH_BITS : line_buf_depth;\n\n\tvdsc_cfg->block_pred_enable =\n\t\tintel_dp->dsc_dpcd[DP_DSC_BLK_PREDICTION_SUPPORT - DP_DSC_SUPPORT] &\n\t\tDP_DSC_BLK_PREDICTION_IS_SUPPORTED;\n\n\treturn drm_dsc_compute_rc_parameters(vdsc_cfg);\n}\n\nstatic int intel_dp_dsc_compute_config(struct intel_dp *intel_dp,\n\t\t\t\t       struct intel_crtc_state *pipe_config,\n\t\t\t\t       struct drm_connector_state *conn_state,\n\t\t\t\t       struct link_config_limits *limits)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&pipe_config->hw.adjusted_mode;\n\tu8 dsc_max_bpc;\n\tint pipe_bpp;\n\tint ret;\n\n\tpipe_config->fec_enable = !intel_dp_is_edp(intel_dp) &&\n\t\tintel_dp_supports_fec(intel_dp, pipe_config);\n\n\tif (!intel_dp_supports_dsc(intel_dp, pipe_config))\n\t\treturn -EINVAL;\n\n\t/* Max DSC Input BPC for ICL is 10 and for TGL+ is 12 */\n\tif (INTEL_GEN(dev_priv) >= 12)\n\t\tdsc_max_bpc = min_t(u8, 12, conn_state->max_requested_bpc);\n\telse\n\t\tdsc_max_bpc = min_t(u8, 10,\n\t\t\t\t    conn_state->max_requested_bpc);\n\n\tpipe_bpp = intel_dp_dsc_compute_bpp(intel_dp, dsc_max_bpc);\n\n\t/* Min Input BPC for ICL+ is 8 */\n\tif (pipe_bpp < 8 * 3) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"No DSC support for less than 8bpc\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * For now enable DSC for max bpp, max link rate, max lane count.\n\t * Optimize this later for the minimum possible link rate/lane count\n\t * with DSC enabled for the requested mode.\n\t */\n\tpipe_config->pipe_bpp = pipe_bpp;\n\tpipe_config->port_clock = intel_dp->common_rates[limits->max_clock];\n\tpipe_config->lane_count = limits->max_lane_count;\n\n\tif (intel_dp_is_edp(intel_dp)) {\n\t\tpipe_config->dsc.compressed_bpp =\n\t\t\tmin_t(u16, drm_edp_dsc_sink_output_bpp(intel_dp->dsc_dpcd) >> 4,\n\t\t\t      pipe_config->pipe_bpp);\n\t\tpipe_config->dsc.slice_count =\n\t\t\tdrm_dp_dsc_sink_max_slice_count(intel_dp->dsc_dpcd,\n\t\t\t\t\t\t\ttrue);\n\t} else {\n\t\tu16 dsc_max_output_bpp;\n\t\tu8 dsc_dp_slice_count;\n\n\t\tdsc_max_output_bpp =\n\t\t\tintel_dp_dsc_get_output_bpp(dev_priv,\n\t\t\t\t\t\t    pipe_config->port_clock,\n\t\t\t\t\t\t    pipe_config->lane_count,\n\t\t\t\t\t\t    adjusted_mode->crtc_clock,\n\t\t\t\t\t\t    adjusted_mode->crtc_hdisplay,\n\t\t\t\t\t\t    pipe_config->bigjoiner);\n\t\tdsc_dp_slice_count =\n\t\t\tintel_dp_dsc_get_slice_count(intel_dp,\n\t\t\t\t\t\t     adjusted_mode->crtc_clock,\n\t\t\t\t\t\t     adjusted_mode->crtc_hdisplay,\n\t\t\t\t\t\t     pipe_config->bigjoiner);\n\t\tif (!dsc_max_output_bpp || !dsc_dp_slice_count) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Compressed BPP/Slice Count not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpipe_config->dsc.compressed_bpp = min_t(u16,\n\t\t\t\t\t\t\t       dsc_max_output_bpp >> 4,\n\t\t\t\t\t\t\t       pipe_config->pipe_bpp);\n\t\tpipe_config->dsc.slice_count = dsc_dp_slice_count;\n\t}\n\t/*\n\t * VDSC engine operates at 1 Pixel per clock, so if peak pixel rate\n\t * is greater than the maximum Cdclock and if slice count is even\n\t * then we need to use 2 VDSC instances.\n\t */\n\tif (adjusted_mode->crtc_clock > dev_priv->max_cdclk_freq ||\n\t    pipe_config->bigjoiner) {\n\t\tif (pipe_config->dsc.slice_count < 2) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"Cannot split stream to use 2 VDSC instances\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpipe_config->dsc.dsc_split = true;\n\t}\n\n\tret = intel_dp_dsc_compute_params(&dig_port->base, pipe_config);\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Cannot compute valid DSC parameters for Input Bpp = %d \"\n\t\t\t    \"Compressed BPP = %d\\n\",\n\t\t\t    pipe_config->pipe_bpp,\n\t\t\t    pipe_config->dsc.compressed_bpp);\n\t\treturn ret;\n\t}\n\n\tpipe_config->dsc.compression_enable = true;\n\tdrm_dbg_kms(&dev_priv->drm, \"DP DSC computed with Input Bpp = %d \"\n\t\t    \"Compressed Bpp = %d Slice Count = %d\\n\",\n\t\t    pipe_config->pipe_bpp,\n\t\t    pipe_config->dsc.compressed_bpp,\n\t\t    pipe_config->dsc.slice_count);\n\n\treturn 0;\n}\n\nstatic int\nintel_dp_compute_link_config(struct intel_encoder *encoder,\n\t\t\t     struct intel_crtc_state *pipe_config,\n\t\t\t     struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&pipe_config->hw.adjusted_mode;\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct link_config_limits limits;\n\tint common_len;\n\tint ret;\n\n\tcommon_len = intel_dp_common_len_rate_limit(intel_dp,\n\t\t\t\t\t\t    intel_dp->max_link_rate);\n\n\t/* No common link rates between source and sink */\n\tdrm_WARN_ON(encoder->base.dev, common_len <= 0);\n\n\tlimits.min_clock = 0;\n\tlimits.max_clock = common_len - 1;\n\n\tlimits.min_lane_count = 1;\n\tlimits.max_lane_count = intel_dp_max_lane_count(intel_dp);\n\n\tlimits.min_bpp = intel_dp_min_bpp(pipe_config->output_format);\n\tlimits.max_bpp = intel_dp_max_bpp(intel_dp, pipe_config);\n\n\tif (intel_dp_is_edp(intel_dp)) {\n\t\t/*\n\t\t * Use the maximum clock and number of lanes the eDP panel\n\t\t * advertizes being capable of. The panels are generally\n\t\t * designed to support only a single clock and lane\n\t\t * configuration, and typically these values correspond to the\n\t\t * native resolution of the panel.\n\t\t */\n\t\tlimits.min_lane_count = limits.max_lane_count;\n\t\tlimits.min_clock = limits.max_clock;\n\t}\n\n\tintel_dp_adjust_compliance_config(intel_dp, pipe_config, &limits);\n\n\tdrm_dbg_kms(&i915->drm, \"DP link computation with max lane count %i \"\n\t\t    \"max rate %d max bpp %d pixel clock %iKHz\\n\",\n\t\t    limits.max_lane_count,\n\t\t    intel_dp->common_rates[limits.max_clock],\n\t\t    limits.max_bpp, adjusted_mode->crtc_clock);\n\n\tif ((adjusted_mode->crtc_clock > i915->max_dotclk_freq ||\n\t     adjusted_mode->crtc_hdisplay > 5120) &&\n\t    intel_dp_can_bigjoiner(intel_dp))\n\t\tpipe_config->bigjoiner = true;\n\n\t/*\n\t * Optimize for slow and wide. This is the place to add alternative\n\t * optimization policy.\n\t */\n\tret = intel_dp_compute_link_config_wide(intel_dp, pipe_config, &limits);\n\n\t/* enable compression if the mode doesn't fit available BW */\n\tdrm_dbg_kms(&i915->drm, \"Force DSC en = %d\\n\", intel_dp->force_dsc_en);\n\tif (ret || intel_dp->force_dsc_en || pipe_config->bigjoiner) {\n\t\tret = intel_dp_dsc_compute_config(intel_dp, pipe_config,\n\t\t\t\t\t\t  conn_state, &limits);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (pipe_config->dsc.compression_enable) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"DP lane count %d clock %d Input bpp %d Compressed bpp %d\\n\",\n\t\t\t    pipe_config->lane_count, pipe_config->port_clock,\n\t\t\t    pipe_config->pipe_bpp,\n\t\t\t    pipe_config->dsc.compressed_bpp);\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"DP link rate required %i available %i\\n\",\n\t\t\t    intel_dp_link_required(adjusted_mode->crtc_clock,\n\t\t\t\t\t\t   pipe_config->dsc.compressed_bpp),\n\t\t\t    intel_dp_max_data_rate(pipe_config->port_clock,\n\t\t\t\t\t\t   pipe_config->lane_count));\n\t} else {\n\t\tdrm_dbg_kms(&i915->drm, \"DP lane count %d clock %d bpp %d\\n\",\n\t\t\t    pipe_config->lane_count, pipe_config->port_clock,\n\t\t\t    pipe_config->pipe_bpp);\n\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"DP link rate required %i available %i\\n\",\n\t\t\t    intel_dp_link_required(adjusted_mode->crtc_clock,\n\t\t\t\t\t\t   pipe_config->pipe_bpp),\n\t\t\t    intel_dp_max_data_rate(pipe_config->port_clock,\n\t\t\t\t\t\t   pipe_config->lane_count));\n\t}\n\treturn 0;\n}\n\nbool intel_dp_limited_color_range(const struct intel_crtc_state *crtc_state,\n\t\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tconst struct intel_digital_connector_state *intel_conn_state =\n\t\tto_intel_digital_connector_state(conn_state);\n\tconst struct drm_display_mode *adjusted_mode =\n\t\t&crtc_state->hw.adjusted_mode;\n\n\t/*\n\t * Our YCbCr output is always limited range.\n\t * crtc_state->limited_color_range only applies to RGB,\n\t * and it must never be set for YCbCr or we risk setting\n\t * some conflicting bits in PIPECONF which will mess up\n\t * the colors on the monitor.\n\t */\n\tif (crtc_state->output_format != INTEL_OUTPUT_FORMAT_RGB)\n\t\treturn false;\n\n\tif (intel_conn_state->broadcast_rgb == INTEL_BROADCAST_RGB_AUTO) {\n\t\t/*\n\t\t * See:\n\t\t * CEA-861-E - 5.1 Default Encoding Parameters\n\t\t * VESA DisplayPort Ver.1.2a - 5.1.1.1 Video Colorimetry\n\t\t */\n\t\treturn crtc_state->pipe_bpp != 18 &&\n\t\t\tdrm_default_rgb_quant_range(adjusted_mode) ==\n\t\t\tHDMI_QUANTIZATION_RANGE_LIMITED;\n\t} else {\n\t\treturn intel_conn_state->broadcast_rgb ==\n\t\t\tINTEL_BROADCAST_RGB_LIMITED;\n\t}\n}\n\nstatic bool intel_dp_port_has_audio(struct drm_i915_private *dev_priv,\n\t\t\t\t    enum port port)\n{\n\tif (IS_G4X(dev_priv))\n\t\treturn false;\n\tif (INTEL_GEN(dev_priv) < 12 && port == PORT_A)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void intel_dp_compute_vsc_colorimetry(const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t     const struct drm_connector_state *conn_state,\n\t\t\t\t\t     struct drm_dp_vsc_sdp *vsc)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\t/*\n\t * Prepare VSC Header for SU as per DP 1.4 spec, Table 2-118\n\t * VSC SDP supporting 3D stereo, PSR2, and Pixel Encoding/\n\t * Colorimetry Format indication.\n\t */\n\tvsc->revision = 0x5;\n\tvsc->length = 0x13;\n\n\t/* DP 1.4a spec, Table 2-120 */\n\tswitch (crtc_state->output_format) {\n\tcase INTEL_OUTPUT_FORMAT_YCBCR444:\n\t\tvsc->pixelformat = DP_PIXELFORMAT_YUV444;\n\t\tbreak;\n\tcase INTEL_OUTPUT_FORMAT_YCBCR420:\n\t\tvsc->pixelformat = DP_PIXELFORMAT_YUV420;\n\t\tbreak;\n\tcase INTEL_OUTPUT_FORMAT_RGB:\n\tdefault:\n\t\tvsc->pixelformat = DP_PIXELFORMAT_RGB;\n\t}\n\n\tswitch (conn_state->colorspace) {\n\tcase DRM_MODE_COLORIMETRY_BT709_YCC:\n\t\tvsc->colorimetry = DP_COLORIMETRY_BT709_YCC;\n\t\tbreak;\n\tcase DRM_MODE_COLORIMETRY_XVYCC_601:\n\t\tvsc->colorimetry = DP_COLORIMETRY_XVYCC_601;\n\t\tbreak;\n\tcase DRM_MODE_COLORIMETRY_XVYCC_709:\n\t\tvsc->colorimetry = DP_COLORIMETRY_XVYCC_709;\n\t\tbreak;\n\tcase DRM_MODE_COLORIMETRY_SYCC_601:\n\t\tvsc->colorimetry = DP_COLORIMETRY_SYCC_601;\n\t\tbreak;\n\tcase DRM_MODE_COLORIMETRY_OPYCC_601:\n\t\tvsc->colorimetry = DP_COLORIMETRY_OPYCC_601;\n\t\tbreak;\n\tcase DRM_MODE_COLORIMETRY_BT2020_CYCC:\n\t\tvsc->colorimetry = DP_COLORIMETRY_BT2020_CYCC;\n\t\tbreak;\n\tcase DRM_MODE_COLORIMETRY_BT2020_RGB:\n\t\tvsc->colorimetry = DP_COLORIMETRY_BT2020_RGB;\n\t\tbreak;\n\tcase DRM_MODE_COLORIMETRY_BT2020_YCC:\n\t\tvsc->colorimetry = DP_COLORIMETRY_BT2020_YCC;\n\t\tbreak;\n\tcase DRM_MODE_COLORIMETRY_DCI_P3_RGB_D65:\n\tcase DRM_MODE_COLORIMETRY_DCI_P3_RGB_THEATER:\n\t\tvsc->colorimetry = DP_COLORIMETRY_DCI_P3_RGB;\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * RGB->YCBCR color conversion uses the BT.709\n\t\t * color space.\n\t\t */\n\t\tif (crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR420)\n\t\t\tvsc->colorimetry = DP_COLORIMETRY_BT709_YCC;\n\t\telse\n\t\t\tvsc->colorimetry = DP_COLORIMETRY_DEFAULT;\n\t\tbreak;\n\t}\n\n\tvsc->bpc = crtc_state->pipe_bpp / 3;\n\n\t/* only RGB pixelformat supports 6 bpc */\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    vsc->bpc == 6 && vsc->pixelformat != DP_PIXELFORMAT_RGB);\n\n\t/* all YCbCr are always limited range */\n\tvsc->dynamic_range = DP_DYNAMIC_RANGE_CTA;\n\tvsc->content_type = DP_CONTENT_TYPE_NOT_DEFINED;\n}\n\nstatic void intel_dp_compute_vsc_sdp(struct intel_dp *intel_dp,\n\t\t\t\t     struct intel_crtc_state *crtc_state,\n\t\t\t\t     const struct drm_connector_state *conn_state)\n{\n\tstruct drm_dp_vsc_sdp *vsc = &crtc_state->infoframes.vsc;\n\n\t/* When a crtc state has PSR, VSC SDP will be handled by PSR routine */\n\tif (crtc_state->has_psr)\n\t\treturn;\n\n\tif (!intel_dp_needs_vsc_sdp(crtc_state, conn_state))\n\t\treturn;\n\n\tcrtc_state->infoframes.enable |= intel_hdmi_infoframe_enable(DP_SDP_VSC);\n\tvsc->sdp_type = DP_SDP_VSC;\n\tintel_dp_compute_vsc_colorimetry(crtc_state, conn_state,\n\t\t\t\t\t &crtc_state->infoframes.vsc);\n}\n\nvoid intel_dp_compute_psr_vsc_sdp(struct intel_dp *intel_dp,\n\t\t\t\t  const struct intel_crtc_state *crtc_state,\n\t\t\t\t  const struct drm_connector_state *conn_state,\n\t\t\t\t  struct drm_dp_vsc_sdp *vsc)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tvsc->sdp_type = DP_SDP_VSC;\n\n\tif (dev_priv->psr.psr2_enabled) {\n\t\tif (dev_priv->psr.colorimetry_support &&\n\t\t    intel_dp_needs_vsc_sdp(crtc_state, conn_state)) {\n\t\t\t/* [PSR2, +Colorimetry] */\n\t\t\tintel_dp_compute_vsc_colorimetry(crtc_state, conn_state,\n\t\t\t\t\t\t\t vsc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * [PSR2, -Colorimetry]\n\t\t\t * Prepare VSC Header for SU as per eDP 1.4 spec, Table 6-11\n\t\t\t * 3D stereo + PSR/PSR2 + Y-coordinate.\n\t\t\t */\n\t\t\tvsc->revision = 0x4;\n\t\t\tvsc->length = 0xe;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * [PSR1]\n\t\t * Prepare VSC Header for SU as per DP 1.4 spec, Table 2-118\n\t\t * VSC SDP supporting 3D stereo + PSR (applies to eDP v1.3 or\n\t\t * higher).\n\t\t */\n\t\tvsc->revision = 0x2;\n\t\tvsc->length = 0x8;\n\t}\n}\n\nstatic void\nintel_dp_compute_hdr_metadata_infoframe_sdp(struct intel_dp *intel_dp,\n\t\t\t\t\t    struct intel_crtc_state *crtc_state,\n\t\t\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tint ret;\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct hdmi_drm_infoframe *drm_infoframe = &crtc_state->infoframes.drm.drm;\n\n\tif (!conn_state->hdr_output_metadata)\n\t\treturn;\n\n\tret = drm_hdmi_infoframe_set_hdr_metadata(drm_infoframe, conn_state);\n\n\tif (ret) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"couldn't set HDR metadata in infoframe\\n\");\n\t\treturn;\n\t}\n\n\tcrtc_state->infoframes.enable |=\n\t\tintel_hdmi_infoframe_enable(HDMI_PACKET_TYPE_GAMUT_METADATA);\n}\n\nstatic void\nintel_dp_drrs_compute_config(struct intel_dp *intel_dp,\n\t\t\t     struct intel_crtc_state *pipe_config,\n\t\t\t     int output_bpp, bool constant_n)\n{\n\tstruct intel_connector *intel_connector = intel_dp->attached_connector;\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\t/*\n\t * DRRS and PSR can't be enable together, so giving preference to PSR\n\t * as it allows more power-savings by complete shutting down display,\n\t * so to guarantee this, intel_dp_drrs_compute_config() must be called\n\t * after intel_psr_compute_config().\n\t */\n\tif (pipe_config->has_psr)\n\t\treturn;\n\n\tif (!intel_connector->panel.downclock_mode ||\n\t    dev_priv->drrs.type != SEAMLESS_DRRS_SUPPORT)\n\t\treturn;\n\n\tpipe_config->has_drrs = true;\n\tintel_link_compute_m_n(output_bpp, pipe_config->lane_count,\n\t\t\t       intel_connector->panel.downclock_mode->clock,\n\t\t\t       pipe_config->port_clock, &pipe_config->dp_m2_n2,\n\t\t\t       constant_n, pipe_config->fec_enable);\n}\n\nint\nintel_dp_compute_config(struct intel_encoder *encoder,\n\t\t\tstruct intel_crtc_state *pipe_config,\n\t\t\tstruct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tenum port port = encoder->port;\n\tstruct intel_connector *intel_connector = intel_dp->attached_connector;\n\tstruct intel_digital_connector_state *intel_conn_state =\n\t\tto_intel_digital_connector_state(conn_state);\n\tbool constant_n = drm_dp_has_quirk(&intel_dp->desc, 0,\n\t\t\t\t\t   DP_DPCD_QUIRK_CONSTANT_N);\n\tint ret = 0, output_bpp;\n\n\tif (HAS_PCH_SPLIT(dev_priv) && !HAS_DDI(dev_priv) && port != PORT_A)\n\t\tpipe_config->has_pch_encoder = true;\n\n\tpipe_config->output_format = intel_dp_output_format(&intel_connector->base,\n\t\t\t\t\t\t\t    adjusted_mode);\n\n\tif (pipe_config->output_format == INTEL_OUTPUT_FORMAT_YCBCR420) {\n\t\tret = intel_pch_panel_fitting(pipe_config, conn_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!intel_dp_port_has_audio(dev_priv, port))\n\t\tpipe_config->has_audio = false;\n\telse if (intel_conn_state->force_audio == HDMI_AUDIO_AUTO)\n\t\tpipe_config->has_audio = intel_dp->has_audio;\n\telse\n\t\tpipe_config->has_audio = intel_conn_state->force_audio == HDMI_AUDIO_ON;\n\n\tif (intel_dp_is_edp(intel_dp) && intel_connector->panel.fixed_mode) {\n\t\tintel_fixed_panel_mode(intel_connector->panel.fixed_mode,\n\t\t\t\t       adjusted_mode);\n\n\t\tif (HAS_GMCH(dev_priv))\n\t\t\tret = intel_gmch_panel_fitting(pipe_config, conn_state);\n\t\telse\n\t\t\tret = intel_pch_panel_fitting(pipe_config, conn_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\treturn -EINVAL;\n\n\tif (HAS_GMCH(dev_priv) &&\n\t    adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\treturn -EINVAL;\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\treturn -EINVAL;\n\n\tif (intel_dp_hdisplay_bad(dev_priv, adjusted_mode->crtc_hdisplay))\n\t\treturn -EINVAL;\n\n\tret = intel_dp_compute_link_config(encoder, pipe_config, conn_state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpipe_config->limited_color_range =\n\t\tintel_dp_limited_color_range(pipe_config, conn_state);\n\n\tif (pipe_config->dsc.compression_enable)\n\t\toutput_bpp = pipe_config->dsc.compressed_bpp;\n\telse\n\t\toutput_bpp = intel_dp_output_bpp(pipe_config->output_format,\n\t\t\t\t\t\t pipe_config->pipe_bpp);\n\n\tintel_link_compute_m_n(output_bpp,\n\t\t\t       pipe_config->lane_count,\n\t\t\t       adjusted_mode->crtc_clock,\n\t\t\t       pipe_config->port_clock,\n\t\t\t       &pipe_config->dp_m_n,\n\t\t\t       constant_n, pipe_config->fec_enable);\n\n\tif (!HAS_DDI(dev_priv))\n\t\tintel_dp_set_clock(encoder, pipe_config);\n\n\tintel_psr_compute_config(intel_dp, pipe_config);\n\tintel_dp_drrs_compute_config(intel_dp, pipe_config, output_bpp,\n\t\t\t\t     constant_n);\n\tintel_dp_compute_vsc_sdp(intel_dp, pipe_config, conn_state);\n\tintel_dp_compute_hdr_metadata_infoframe_sdp(intel_dp, pipe_config, conn_state);\n\n\treturn 0;\n}\n\nvoid intel_dp_set_link_params(struct intel_dp *intel_dp,\n\t\t\t      int link_rate, int lane_count)\n{\n\tintel_dp->link_trained = false;\n\tintel_dp->link_rate = link_rate;\n\tintel_dp->lane_count = lane_count;\n}\n\nstatic void intel_dp_prepare(struct intel_encoder *encoder,\n\t\t\t     const struct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tenum port port = encoder->port;\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tconst struct drm_display_mode *adjusted_mode = &pipe_config->hw.adjusted_mode;\n\n\tintel_dp_set_link_params(intel_dp,\n\t\t\t\t pipe_config->port_clock,\n\t\t\t\t pipe_config->lane_count);\n\n\t/*\n\t * There are four kinds of DP registers:\n\t *\n\t * \tIBX PCH\n\t * \tSNB CPU\n\t *\tIVB CPU\n\t * \tCPT PCH\n\t *\n\t * IBX PCH and CPU are the same for almost everything,\n\t * except that the CPU DP PLL is configured in this\n\t * register\n\t *\n\t * CPT PCH is quite different, having many bits moved\n\t * to the TRANS_DP_CTL register instead. That\n\t * configuration happens (oddly) in ilk_pch_enable\n\t */\n\n\t/* Preserve the BIOS-computed detected bit. This is\n\t * supposed to be read-only.\n\t */\n\tintel_dp->DP = intel_de_read(dev_priv, intel_dp->output_reg) & DP_DETECTED;\n\n\t/* Handle DP bits in common between all three register formats */\n\tintel_dp->DP |= DP_VOLTAGE_0_4 | DP_PRE_EMPHASIS_0;\n\tintel_dp->DP |= DP_PORT_WIDTH(pipe_config->lane_count);\n\n\t/* Split out the IBX/CPU vs CPT settings */\n\n\tif (IS_IVYBRIDGE(dev_priv) && port == PORT_A) {\n\t\tif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\t\tintel_dp->DP |= DP_SYNC_HS_HIGH;\n\t\tif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\t\tintel_dp->DP |= DP_SYNC_VS_HIGH;\n\t\tintel_dp->DP |= DP_LINK_TRAIN_OFF_CPT;\n\n\t\tif (drm_dp_enhanced_frame_cap(intel_dp->dpcd))\n\t\t\tintel_dp->DP |= DP_ENHANCED_FRAMING;\n\n\t\tintel_dp->DP |= DP_PIPE_SEL_IVB(crtc->pipe);\n\t} else if (HAS_PCH_CPT(dev_priv) && port != PORT_A) {\n\t\tu32 trans_dp;\n\n\t\tintel_dp->DP |= DP_LINK_TRAIN_OFF_CPT;\n\n\t\ttrans_dp = intel_de_read(dev_priv, TRANS_DP_CTL(crtc->pipe));\n\t\tif (drm_dp_enhanced_frame_cap(intel_dp->dpcd))\n\t\t\ttrans_dp |= TRANS_DP_ENH_FRAMING;\n\t\telse\n\t\t\ttrans_dp &= ~TRANS_DP_ENH_FRAMING;\n\t\tintel_de_write(dev_priv, TRANS_DP_CTL(crtc->pipe), trans_dp);\n\t} else {\n\t\tif (IS_G4X(dev_priv) && pipe_config->limited_color_range)\n\t\t\tintel_dp->DP |= DP_COLOR_RANGE_16_235;\n\n\t\tif (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\t\tintel_dp->DP |= DP_SYNC_HS_HIGH;\n\t\tif (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\t\tintel_dp->DP |= DP_SYNC_VS_HIGH;\n\t\tintel_dp->DP |= DP_LINK_TRAIN_OFF;\n\n\t\tif (drm_dp_enhanced_frame_cap(intel_dp->dpcd))\n\t\t\tintel_dp->DP |= DP_ENHANCED_FRAMING;\n\n\t\tif (IS_CHERRYVIEW(dev_priv))\n\t\t\tintel_dp->DP |= DP_PIPE_SEL_CHV(crtc->pipe);\n\t\telse\n\t\t\tintel_dp->DP |= DP_PIPE_SEL(crtc->pipe);\n\t}\n}\n\n#define IDLE_ON_MASK\t\t(PP_ON | PP_SEQUENCE_MASK | 0                     | PP_SEQUENCE_STATE_MASK)\n#define IDLE_ON_VALUE   \t(PP_ON | PP_SEQUENCE_NONE | 0                     | PP_SEQUENCE_STATE_ON_IDLE)\n\n#define IDLE_OFF_MASK\t\t(PP_ON | PP_SEQUENCE_MASK | 0                     | 0)\n#define IDLE_OFF_VALUE\t\t(0     | PP_SEQUENCE_NONE | 0                     | 0)\n\n#define IDLE_CYCLE_MASK\t\t(PP_ON | PP_SEQUENCE_MASK | PP_CYCLE_DELAY_ACTIVE | PP_SEQUENCE_STATE_MASK)\n#define IDLE_CYCLE_VALUE\t(0     | PP_SEQUENCE_NONE | 0                     | PP_SEQUENCE_STATE_OFF_IDLE)\n\nstatic void intel_pps_verify_state(struct intel_dp *intel_dp);\n\nstatic void wait_panel_status(struct intel_dp *intel_dp,\n\t\t\t\t       u32 mask,\n\t\t\t\t       u32 value)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\ti915_reg_t pp_stat_reg, pp_ctrl_reg;\n\n\tlockdep_assert_held(&dev_priv->pps_mutex);\n\n\tintel_pps_verify_state(intel_dp);\n\n\tpp_stat_reg = _pp_stat_reg(intel_dp);\n\tpp_ctrl_reg = _pp_ctrl_reg(intel_dp);\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"mask %08x value %08x status %08x control %08x\\n\",\n\t\t    mask, value,\n\t\t    intel_de_read(dev_priv, pp_stat_reg),\n\t\t    intel_de_read(dev_priv, pp_ctrl_reg));\n\n\tif (intel_de_wait_for_register(dev_priv, pp_stat_reg,\n\t\t\t\t       mask, value, 5000))\n\t\tdrm_err(&dev_priv->drm,\n\t\t\t\"Panel status timeout: status %08x control %08x\\n\",\n\t\t\tintel_de_read(dev_priv, pp_stat_reg),\n\t\t\tintel_de_read(dev_priv, pp_ctrl_reg));\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Wait complete\\n\");\n}\n\nstatic void wait_panel_on(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tdrm_dbg_kms(&i915->drm, \"Wait for panel power on\\n\");\n\twait_panel_status(intel_dp, IDLE_ON_MASK, IDLE_ON_VALUE);\n}\n\nstatic void wait_panel_off(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tdrm_dbg_kms(&i915->drm, \"Wait for panel power off time\\n\");\n\twait_panel_status(intel_dp, IDLE_OFF_MASK, IDLE_OFF_VALUE);\n}\n\nstatic void wait_panel_power_cycle(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tktime_t panel_power_on_time;\n\ts64 panel_power_off_duration;\n\n\tdrm_dbg_kms(&i915->drm, \"Wait for panel power cycle\\n\");\n\n\t/* take the difference of currrent time and panel power off time\n\t * and then make panel wait for t11_t12 if needed. */\n\tpanel_power_on_time = ktime_get_boottime();\n\tpanel_power_off_duration = ktime_ms_delta(panel_power_on_time, intel_dp->panel_power_off_time);\n\n\t/* When we disable the VDD override bit last we have to do the manual\n\t * wait. */\n\tif (panel_power_off_duration < (s64)intel_dp->panel_power_cycle_delay)\n\t\twait_remaining_ms_from_jiffies(jiffies,\n\t\t\t\t       intel_dp->panel_power_cycle_delay - panel_power_off_duration);\n\n\twait_panel_status(intel_dp, IDLE_CYCLE_MASK, IDLE_CYCLE_VALUE);\n}\n\nstatic void wait_backlight_on(struct intel_dp *intel_dp)\n{\n\twait_remaining_ms_from_jiffies(intel_dp->last_power_on,\n\t\t\t\t       intel_dp->backlight_on_delay);\n}\n\nstatic void edp_wait_backlight_off(struct intel_dp *intel_dp)\n{\n\twait_remaining_ms_from_jiffies(intel_dp->last_backlight_off,\n\t\t\t\t       intel_dp->backlight_off_delay);\n}\n\n/* Read the current pp_control value, unlocking the register if it\n * is locked\n */\n\nstatic  u32 ilk_get_pp_control(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu32 control;\n\n\tlockdep_assert_held(&dev_priv->pps_mutex);\n\n\tcontrol = intel_de_read(dev_priv, _pp_ctrl_reg(intel_dp));\n\tif (drm_WARN_ON(&dev_priv->drm, !HAS_DDI(dev_priv) &&\n\t\t\t(control & PANEL_UNLOCK_MASK) != PANEL_UNLOCK_REGS)) {\n\t\tcontrol &= ~PANEL_UNLOCK_MASK;\n\t\tcontrol |= PANEL_UNLOCK_REGS;\n\t}\n\treturn control;\n}\n\n/*\n * Must be paired with edp_panel_vdd_off().\n * Must hold pps_mutex around the whole on/off sequence.\n * Can be nested with intel_edp_panel_vdd_{on,off}() calls.\n */\nstatic bool edp_panel_vdd_on(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tu32 pp;\n\ti915_reg_t pp_stat_reg, pp_ctrl_reg;\n\tbool need_to_disable = !intel_dp->want_panel_vdd;\n\n\tlockdep_assert_held(&dev_priv->pps_mutex);\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn false;\n\n\tcancel_delayed_work(&intel_dp->panel_vdd_work);\n\tintel_dp->want_panel_vdd = true;\n\n\tif (edp_have_panel_vdd(intel_dp))\n\t\treturn need_to_disable;\n\n\tdrm_WARN_ON(&dev_priv->drm, intel_dp->vdd_wakeref);\n\tintel_dp->vdd_wakeref = intel_display_power_get(dev_priv,\n\t\t\t\t\t\t\tintel_aux_power_domain(dig_port));\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Turning [ENCODER:%d:%s] VDD on\\n\",\n\t\t    dig_port->base.base.base.id,\n\t\t    dig_port->base.base.name);\n\n\tif (!edp_have_panel_power(intel_dp))\n\t\twait_panel_power_cycle(intel_dp);\n\n\tpp = ilk_get_pp_control(intel_dp);\n\tpp |= EDP_FORCE_VDD;\n\n\tpp_stat_reg = _pp_stat_reg(intel_dp);\n\tpp_ctrl_reg = _pp_ctrl_reg(intel_dp);\n\n\tintel_de_write(dev_priv, pp_ctrl_reg, pp);\n\tintel_de_posting_read(dev_priv, pp_ctrl_reg);\n\tdrm_dbg_kms(&dev_priv->drm, \"PP_STATUS: 0x%08x PP_CONTROL: 0x%08x\\n\",\n\t\t    intel_de_read(dev_priv, pp_stat_reg),\n\t\t    intel_de_read(dev_priv, pp_ctrl_reg));\n\t/*\n\t * If the panel wasn't on, delay before accessing aux channel\n\t */\n\tif (!edp_have_panel_power(intel_dp)) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[ENCODER:%d:%s] panel power wasn't enabled\\n\",\n\t\t\t    dig_port->base.base.base.id,\n\t\t\t    dig_port->base.base.name);\n\t\tmsleep(intel_dp->panel_power_up_delay);\n\t}\n\n\treturn need_to_disable;\n}\n\n/*\n * Must be paired with intel_edp_panel_vdd_off() or\n * intel_edp_panel_off().\n * Nested calls to these functions are not allowed since\n * we drop the lock. Caller must use some higher level\n * locking to prevent nested calls from other threads.\n */\nvoid intel_edp_panel_vdd_on(struct intel_dp *intel_dp)\n{\n\tintel_wakeref_t wakeref;\n\tbool vdd;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\tvdd = false;\n\twith_pps_lock(intel_dp, wakeref)\n\t\tvdd = edp_panel_vdd_on(intel_dp);\n\tI915_STATE_WARN(!vdd, \"[ENCODER:%d:%s] VDD already requested on\\n\",\n\t\t\tdp_to_dig_port(intel_dp)->base.base.base.id,\n\t\t\tdp_to_dig_port(intel_dp)->base.base.name);\n}\n\nstatic void edp_panel_vdd_off_sync(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port =\n\t\tdp_to_dig_port(intel_dp);\n\tu32 pp;\n\ti915_reg_t pp_stat_reg, pp_ctrl_reg;\n\n\tlockdep_assert_held(&dev_priv->pps_mutex);\n\n\tdrm_WARN_ON(&dev_priv->drm, intel_dp->want_panel_vdd);\n\n\tif (!edp_have_panel_vdd(intel_dp))\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Turning [ENCODER:%d:%s] VDD off\\n\",\n\t\t    dig_port->base.base.base.id,\n\t\t    dig_port->base.base.name);\n\n\tpp = ilk_get_pp_control(intel_dp);\n\tpp &= ~EDP_FORCE_VDD;\n\n\tpp_ctrl_reg = _pp_ctrl_reg(intel_dp);\n\tpp_stat_reg = _pp_stat_reg(intel_dp);\n\n\tintel_de_write(dev_priv, pp_ctrl_reg, pp);\n\tintel_de_posting_read(dev_priv, pp_ctrl_reg);\n\n\t/* Make sure sequencer is idle before allowing subsequent activity */\n\tdrm_dbg_kms(&dev_priv->drm, \"PP_STATUS: 0x%08x PP_CONTROL: 0x%08x\\n\",\n\t\t    intel_de_read(dev_priv, pp_stat_reg),\n\t\t    intel_de_read(dev_priv, pp_ctrl_reg));\n\n\tif ((pp & PANEL_POWER_ON) == 0)\n\t\tintel_dp->panel_power_off_time = ktime_get_boottime();\n\n\tintel_display_power_put(dev_priv,\n\t\t\t\tintel_aux_power_domain(dig_port),\n\t\t\t\tfetch_and_zero(&intel_dp->vdd_wakeref));\n}\n\nstatic void edp_panel_vdd_work(struct work_struct *__work)\n{\n\tstruct intel_dp *intel_dp =\n\t\tcontainer_of(to_delayed_work(__work),\n\t\t\t     struct intel_dp, panel_vdd_work);\n\tintel_wakeref_t wakeref;\n\n\twith_pps_lock(intel_dp, wakeref) {\n\t\tif (!intel_dp->want_panel_vdd)\n\t\t\tedp_panel_vdd_off_sync(intel_dp);\n\t}\n}\n\nstatic void edp_panel_vdd_schedule_off(struct intel_dp *intel_dp)\n{\n\tunsigned long delay;\n\n\t/*\n\t * Queue the timer to fire a long time from now (relative to the power\n\t * down delay) to keep the panel power up across a sequence of\n\t * operations.\n\t */\n\tdelay = msecs_to_jiffies(intel_dp->panel_power_cycle_delay * 5);\n\tschedule_delayed_work(&intel_dp->panel_vdd_work, delay);\n}\n\n/*\n * Must be paired with edp_panel_vdd_on().\n * Must hold pps_mutex around the whole on/off sequence.\n * Can be nested with intel_edp_panel_vdd_{on,off}() calls.\n */\nstatic void edp_panel_vdd_off(struct intel_dp *intel_dp, bool sync)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tlockdep_assert_held(&dev_priv->pps_mutex);\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\tI915_STATE_WARN(!intel_dp->want_panel_vdd, \"[ENCODER:%d:%s] VDD not forced on\",\n\t\t\tdp_to_dig_port(intel_dp)->base.base.base.id,\n\t\t\tdp_to_dig_port(intel_dp)->base.base.name);\n\n\tintel_dp->want_panel_vdd = false;\n\n\tif (sync)\n\t\tedp_panel_vdd_off_sync(intel_dp);\n\telse\n\t\tedp_panel_vdd_schedule_off(intel_dp);\n}\n\nstatic void edp_panel_on(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu32 pp;\n\ti915_reg_t pp_ctrl_reg;\n\n\tlockdep_assert_held(&dev_priv->pps_mutex);\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Turn [ENCODER:%d:%s] panel power on\\n\",\n\t\t    dp_to_dig_port(intel_dp)->base.base.base.id,\n\t\t    dp_to_dig_port(intel_dp)->base.base.name);\n\n\tif (drm_WARN(&dev_priv->drm, edp_have_panel_power(intel_dp),\n\t\t     \"[ENCODER:%d:%s] panel power already on\\n\",\n\t\t     dp_to_dig_port(intel_dp)->base.base.base.id,\n\t\t     dp_to_dig_port(intel_dp)->base.base.name))\n\t\treturn;\n\n\twait_panel_power_cycle(intel_dp);\n\n\tpp_ctrl_reg = _pp_ctrl_reg(intel_dp);\n\tpp = ilk_get_pp_control(intel_dp);\n\tif (IS_GEN(dev_priv, 5)) {\n\t\t/* ILK workaround: disable reset around power sequence */\n\t\tpp &= ~PANEL_POWER_RESET;\n\t\tintel_de_write(dev_priv, pp_ctrl_reg, pp);\n\t\tintel_de_posting_read(dev_priv, pp_ctrl_reg);\n\t}\n\n\tpp |= PANEL_POWER_ON;\n\tif (!IS_GEN(dev_priv, 5))\n\t\tpp |= PANEL_POWER_RESET;\n\n\tintel_de_write(dev_priv, pp_ctrl_reg, pp);\n\tintel_de_posting_read(dev_priv, pp_ctrl_reg);\n\n\twait_panel_on(intel_dp);\n\tintel_dp->last_power_on = jiffies;\n\n\tif (IS_GEN(dev_priv, 5)) {\n\t\tpp |= PANEL_POWER_RESET; /* restore panel reset bit */\n\t\tintel_de_write(dev_priv, pp_ctrl_reg, pp);\n\t\tintel_de_posting_read(dev_priv, pp_ctrl_reg);\n\t}\n}\n\nvoid intel_edp_panel_on(struct intel_dp *intel_dp)\n{\n\tintel_wakeref_t wakeref;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\twith_pps_lock(intel_dp, wakeref)\n\t\tedp_panel_on(intel_dp);\n}\n\n\nstatic void edp_panel_off(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tu32 pp;\n\ti915_reg_t pp_ctrl_reg;\n\n\tlockdep_assert_held(&dev_priv->pps_mutex);\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Turn [ENCODER:%d:%s] panel power off\\n\",\n\t\t    dig_port->base.base.base.id, dig_port->base.base.name);\n\n\tdrm_WARN(&dev_priv->drm, !intel_dp->want_panel_vdd,\n\t\t \"Need [ENCODER:%d:%s] VDD to turn off panel\\n\",\n\t\t dig_port->base.base.base.id, dig_port->base.base.name);\n\n\tpp = ilk_get_pp_control(intel_dp);\n\t/* We need to switch off panel power _and_ force vdd, for otherwise some\n\t * panels get very unhappy and cease to work. */\n\tpp &= ~(PANEL_POWER_ON | PANEL_POWER_RESET | EDP_FORCE_VDD |\n\t\tEDP_BLC_ENABLE);\n\n\tpp_ctrl_reg = _pp_ctrl_reg(intel_dp);\n\n\tintel_dp->want_panel_vdd = false;\n\n\tintel_de_write(dev_priv, pp_ctrl_reg, pp);\n\tintel_de_posting_read(dev_priv, pp_ctrl_reg);\n\n\twait_panel_off(intel_dp);\n\tintel_dp->panel_power_off_time = ktime_get_boottime();\n\n\t/* We got a reference when we enabled the VDD. */\n\tintel_display_power_put(dev_priv,\n\t\t\t\tintel_aux_power_domain(dig_port),\n\t\t\t\tfetch_and_zero(&intel_dp->vdd_wakeref));\n}\n\nvoid intel_edp_panel_off(struct intel_dp *intel_dp)\n{\n\tintel_wakeref_t wakeref;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\twith_pps_lock(intel_dp, wakeref)\n\t\tedp_panel_off(intel_dp);\n}\n\n/* Enable backlight in the panel power control. */\nstatic void _intel_edp_backlight_on(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tintel_wakeref_t wakeref;\n\n\t/*\n\t * If we enable the backlight right away following a panel power\n\t * on, we may see slight flicker as the panel syncs with the eDP\n\t * link.  So delay a bit to make sure the image is solid before\n\t * allowing it to appear.\n\t */\n\twait_backlight_on(intel_dp);\n\n\twith_pps_lock(intel_dp, wakeref) {\n\t\ti915_reg_t pp_ctrl_reg = _pp_ctrl_reg(intel_dp);\n\t\tu32 pp;\n\n\t\tpp = ilk_get_pp_control(intel_dp);\n\t\tpp |= EDP_BLC_ENABLE;\n\n\t\tintel_de_write(dev_priv, pp_ctrl_reg, pp);\n\t\tintel_de_posting_read(dev_priv, pp_ctrl_reg);\n\t}\n}\n\n/* Enable backlight PWM and backlight PP control. */\nvoid intel_edp_backlight_on(const struct intel_crtc_state *crtc_state,\n\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(to_intel_encoder(conn_state->best_encoder));\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\tdrm_dbg_kms(&i915->drm, \"\\n\");\n\n\tintel_panel_enable_backlight(crtc_state, conn_state);\n\t_intel_edp_backlight_on(intel_dp);\n}\n\n/* Disable backlight in the panel power control. */\nstatic void _intel_edp_backlight_off(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tintel_wakeref_t wakeref;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\twith_pps_lock(intel_dp, wakeref) {\n\t\ti915_reg_t pp_ctrl_reg = _pp_ctrl_reg(intel_dp);\n\t\tu32 pp;\n\n\t\tpp = ilk_get_pp_control(intel_dp);\n\t\tpp &= ~EDP_BLC_ENABLE;\n\n\t\tintel_de_write(dev_priv, pp_ctrl_reg, pp);\n\t\tintel_de_posting_read(dev_priv, pp_ctrl_reg);\n\t}\n\n\tintel_dp->last_backlight_off = jiffies;\n\tedp_wait_backlight_off(intel_dp);\n}\n\n/* Disable backlight PP control and backlight PWM. */\nvoid intel_edp_backlight_off(const struct drm_connector_state *old_conn_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(to_intel_encoder(old_conn_state->best_encoder));\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\tdrm_dbg_kms(&i915->drm, \"\\n\");\n\n\t_intel_edp_backlight_off(intel_dp);\n\tintel_panel_disable_backlight(old_conn_state);\n}\n\n/*\n * Hook for controlling the panel power control backlight through the bl_power\n * sysfs attribute. Take care to handle multiple calls.\n */\nstatic void intel_edp_backlight_power(struct intel_connector *connector,\n\t\t\t\t      bool enable)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->base.dev);\n\tstruct intel_dp *intel_dp = intel_attached_dp(connector);\n\tintel_wakeref_t wakeref;\n\tbool is_enabled;\n\n\tis_enabled = false;\n\twith_pps_lock(intel_dp, wakeref)\n\t\tis_enabled = ilk_get_pp_control(intel_dp) & EDP_BLC_ENABLE;\n\tif (is_enabled == enable)\n\t\treturn;\n\n\tdrm_dbg_kms(&i915->drm, \"panel power control backlight %s\\n\",\n\t\t    enable ? \"enable\" : \"disable\");\n\n\tif (enable)\n\t\t_intel_edp_backlight_on(intel_dp);\n\telse\n\t\t_intel_edp_backlight_off(intel_dp);\n}\n\nstatic void assert_dp_port(struct intel_dp *intel_dp, bool state)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\tbool cur_state = intel_de_read(dev_priv, intel_dp->output_reg) & DP_PORT_EN;\n\n\tI915_STATE_WARN(cur_state != state,\n\t\t\t\"[ENCODER:%d:%s] state assertion failure (expected %s, current %s)\\n\",\n\t\t\tdig_port->base.base.base.id, dig_port->base.base.name,\n\t\t\tonoff(state), onoff(cur_state));\n}\n#define assert_dp_port_disabled(d) assert_dp_port((d), false)\n\nstatic void assert_edp_pll(struct drm_i915_private *dev_priv, bool state)\n{\n\tbool cur_state = intel_de_read(dev_priv, DP_A) & DP_PLL_ENABLE;\n\n\tI915_STATE_WARN(cur_state != state,\n\t\t\t\"eDP PLL state assertion failure (expected %s, current %s)\\n\",\n\t\t\tonoff(state), onoff(cur_state));\n}\n#define assert_edp_pll_enabled(d) assert_edp_pll((d), true)\n#define assert_edp_pll_disabled(d) assert_edp_pll((d), false)\n\nstatic void ilk_edp_pll_on(struct intel_dp *intel_dp,\n\t\t\t   const struct intel_crtc_state *pipe_config)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tassert_pipe_disabled(dev_priv, pipe_config->cpu_transcoder);\n\tassert_dp_port_disabled(intel_dp);\n\tassert_edp_pll_disabled(dev_priv);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"enabling eDP PLL for clock %d\\n\",\n\t\t    pipe_config->port_clock);\n\n\tintel_dp->DP &= ~DP_PLL_FREQ_MASK;\n\n\tif (pipe_config->port_clock == 162000)\n\t\tintel_dp->DP |= DP_PLL_FREQ_162MHZ;\n\telse\n\t\tintel_dp->DP |= DP_PLL_FREQ_270MHZ;\n\n\tintel_de_write(dev_priv, DP_A, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, DP_A);\n\tudelay(500);\n\n\t/*\n\t * [DevILK] Work around required when enabling DP PLL\n\t * while a pipe is enabled going to FDI:\n\t * 1. Wait for the start of vertical blank on the enabled pipe going to FDI\n\t * 2. Program DP PLL enable\n\t */\n\tif (IS_GEN(dev_priv, 5))\n\t\tintel_wait_for_vblank_if_active(dev_priv, !crtc->pipe);\n\n\tintel_dp->DP |= DP_PLL_ENABLE;\n\n\tintel_de_write(dev_priv, DP_A, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, DP_A);\n\tudelay(200);\n}\n\nstatic void ilk_edp_pll_off(struct intel_dp *intel_dp,\n\t\t\t    const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tstruct drm_i915_private *dev_priv = to_i915(crtc->base.dev);\n\n\tassert_pipe_disabled(dev_priv, old_crtc_state->cpu_transcoder);\n\tassert_dp_port_disabled(intel_dp);\n\tassert_edp_pll_enabled(dev_priv);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"disabling eDP PLL\\n\");\n\n\tintel_dp->DP &= ~DP_PLL_ENABLE;\n\n\tintel_de_write(dev_priv, DP_A, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, DP_A);\n\tudelay(200);\n}\n\nstatic bool downstream_hpd_needs_d0(struct intel_dp *intel_dp)\n{\n\t/*\n\t * DPCD 1.2+ should support BRANCH_DEVICE_CTRL, and thus\n\t * be capable of signalling downstream hpd with a long pulse.\n\t * Whether or not that means D3 is safe to use is not clear,\n\t * but let's assume so until proven otherwise.\n\t *\n\t * FIXME should really check all downstream ports...\n\t */\n\treturn intel_dp->dpcd[DP_DPCD_REV] == 0x11 &&\n\t\tdrm_dp_is_branch(intel_dp->dpcd) &&\n\t\tintel_dp->downstream_ports[0] & DP_DS_PORT_HPD;\n}\n\nvoid intel_dp_sink_set_decompression_state(struct intel_dp *intel_dp,\n\t\t\t\t\t   const struct intel_crtc_state *crtc_state,\n\t\t\t\t\t   bool enable)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tint ret;\n\n\tif (!crtc_state->dsc.compression_enable)\n\t\treturn;\n\n\tret = drm_dp_dpcd_writeb(&intel_dp->aux, DP_DSC_ENABLE,\n\t\t\t\t enable ? DP_DECOMPRESSION_EN : 0);\n\tif (ret < 0)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Failed to %s sink decompression state\\n\",\n\t\t\t    enable ? \"enable\" : \"disable\");\n}\n\n/* If the device supports it, try to set the power state appropriately */\nvoid intel_dp_set_power(struct intel_dp *intel_dp, u8 mode)\n{\n\tstruct intel_encoder *encoder = &dp_to_dig_port(intel_dp)->base;\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tint ret, i;\n\n\t/* Should have a valid DPCD by this point */\n\tif (intel_dp->dpcd[DP_DPCD_REV] < 0x11)\n\t\treturn;\n\n\tif (mode != DP_SET_POWER_D0) {\n\t\tif (downstream_hpd_needs_d0(intel_dp))\n\t\t\treturn;\n\n\t\tret = drm_dp_dpcd_writeb(&intel_dp->aux, DP_SET_POWER, mode);\n\t} else {\n\t\tstruct intel_lspcon *lspcon = dp_to_lspcon(intel_dp);\n\n\t\tlspcon_resume(dp_to_dig_port(intel_dp));\n\n\t\t/*\n\t\t * When turning on, we need to retry for 1ms to give the sink\n\t\t * time to wake up.\n\t\t */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tret = drm_dp_dpcd_writeb(&intel_dp->aux, DP_SET_POWER, mode);\n\t\t\tif (ret == 1)\n\t\t\t\tbreak;\n\t\t\tmsleep(1);\n\t\t}\n\n\t\tif (ret == 1 && lspcon->active)\n\t\t\tlspcon_wait_pcon_mode(lspcon);\n\t}\n\n\tif (ret != 1)\n\t\tdrm_dbg_kms(&i915->drm, \"[ENCODER:%d:%s] Set power to %s failed\\n\",\n\t\t\t    encoder->base.base.id, encoder->base.name,\n\t\t\t    mode == DP_SET_POWER_D0 ? \"D0\" : \"D3\");\n}\n\nstatic bool cpt_dp_port_selected(struct drm_i915_private *dev_priv,\n\t\t\t\t enum port port, enum pipe *pipe)\n{\n\tenum pipe p;\n\n\tfor_each_pipe(dev_priv, p) {\n\t\tu32 val = intel_de_read(dev_priv, TRANS_DP_CTL(p));\n\n\t\tif ((val & TRANS_DP_PORT_SEL_MASK) == TRANS_DP_PORT_SEL(port)) {\n\t\t\t*pipe = p;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tdrm_dbg_kms(&dev_priv->drm, \"No pipe for DP port %c found\\n\",\n\t\t    port_name(port));\n\n\t/* must initialize pipe to something for the asserts */\n\t*pipe = PIPE_A;\n\n\treturn false;\n}\n\nbool intel_dp_port_enabled(struct drm_i915_private *dev_priv,\n\t\t\t   i915_reg_t dp_reg, enum port port,\n\t\t\t   enum pipe *pipe)\n{\n\tbool ret;\n\tu32 val;\n\n\tval = intel_de_read(dev_priv, dp_reg);\n\n\tret = val & DP_PORT_EN;\n\n\t/* asserts want to know the pipe even if the port is disabled */\n\tif (IS_IVYBRIDGE(dev_priv) && port == PORT_A)\n\t\t*pipe = (val & DP_PIPE_SEL_MASK_IVB) >> DP_PIPE_SEL_SHIFT_IVB;\n\telse if (HAS_PCH_CPT(dev_priv) && port != PORT_A)\n\t\tret &= cpt_dp_port_selected(dev_priv, port, pipe);\n\telse if (IS_CHERRYVIEW(dev_priv))\n\t\t*pipe = (val & DP_PIPE_SEL_MASK_CHV) >> DP_PIPE_SEL_SHIFT_CHV;\n\telse\n\t\t*pipe = (val & DP_PIPE_SEL_MASK) >> DP_PIPE_SEL_SHIFT;\n\n\treturn ret;\n}\n\nstatic bool intel_dp_get_hw_state(struct intel_encoder *encoder,\n\t\t\t\t  enum pipe *pipe)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tintel_wakeref_t wakeref;\n\tbool ret;\n\n\twakeref = intel_display_power_get_if_enabled(dev_priv,\n\t\t\t\t\t\t     encoder->power_domain);\n\tif (!wakeref)\n\t\treturn false;\n\n\tret = intel_dp_port_enabled(dev_priv, intel_dp->output_reg,\n\t\t\t\t    encoder->port, pipe);\n\n\tintel_display_power_put(dev_priv, encoder->power_domain, wakeref);\n\n\treturn ret;\n}\n\nstatic void intel_dp_get_config(struct intel_encoder *encoder,\n\t\t\t\tstruct intel_crtc_state *pipe_config)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tu32 tmp, flags = 0;\n\tenum port port = encoder->port;\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\n\tif (encoder->type == INTEL_OUTPUT_EDP)\n\t\tpipe_config->output_types |= BIT(INTEL_OUTPUT_EDP);\n\telse\n\t\tpipe_config->output_types |= BIT(INTEL_OUTPUT_DP);\n\n\ttmp = intel_de_read(dev_priv, intel_dp->output_reg);\n\n\tpipe_config->has_audio = tmp & DP_AUDIO_OUTPUT_ENABLE && port != PORT_A;\n\n\tif (HAS_PCH_CPT(dev_priv) && port != PORT_A) {\n\t\tu32 trans_dp = intel_de_read(dev_priv,\n\t\t\t\t\t     TRANS_DP_CTL(crtc->pipe));\n\n\t\tif (trans_dp & TRANS_DP_HSYNC_ACTIVE_HIGH)\n\t\t\tflags |= DRM_MODE_FLAG_PHSYNC;\n\t\telse\n\t\t\tflags |= DRM_MODE_FLAG_NHSYNC;\n\n\t\tif (trans_dp & TRANS_DP_VSYNC_ACTIVE_HIGH)\n\t\t\tflags |= DRM_MODE_FLAG_PVSYNC;\n\t\telse\n\t\t\tflags |= DRM_MODE_FLAG_NVSYNC;\n\t} else {\n\t\tif (tmp & DP_SYNC_HS_HIGH)\n\t\t\tflags |= DRM_MODE_FLAG_PHSYNC;\n\t\telse\n\t\t\tflags |= DRM_MODE_FLAG_NHSYNC;\n\n\t\tif (tmp & DP_SYNC_VS_HIGH)\n\t\t\tflags |= DRM_MODE_FLAG_PVSYNC;\n\t\telse\n\t\t\tflags |= DRM_MODE_FLAG_NVSYNC;\n\t}\n\n\tpipe_config->hw.adjusted_mode.flags |= flags;\n\n\tif (IS_G4X(dev_priv) && tmp & DP_COLOR_RANGE_16_235)\n\t\tpipe_config->limited_color_range = true;\n\n\tpipe_config->lane_count =\n\t\t((tmp & DP_PORT_WIDTH_MASK) >> DP_PORT_WIDTH_SHIFT) + 1;\n\n\tintel_dp_get_m_n(crtc, pipe_config);\n\n\tif (port == PORT_A) {\n\t\tif ((intel_de_read(dev_priv, DP_A) & DP_PLL_FREQ_MASK) == DP_PLL_FREQ_162MHZ)\n\t\t\tpipe_config->port_clock = 162000;\n\t\telse\n\t\t\tpipe_config->port_clock = 270000;\n\t}\n\n\tpipe_config->hw.adjusted_mode.crtc_clock =\n\t\tintel_dotclock_calculate(pipe_config->port_clock,\n\t\t\t\t\t &pipe_config->dp_m_n);\n\n\tif (intel_dp_is_edp(intel_dp) && dev_priv->vbt.edp.bpp &&\n\t    pipe_config->pipe_bpp > dev_priv->vbt.edp.bpp) {\n\t\t/*\n\t\t * This is a big fat ugly hack.\n\t\t *\n\t\t * Some machines in UEFI boot mode provide us a VBT that has 18\n\t\t * bpp and 1.62 GHz link bandwidth for eDP, which for reasons\n\t\t * unknown we fail to light up. Yet the same BIOS boots up with\n\t\t * 24 bpp and 2.7 GHz link. Use the same bpp as the BIOS uses as\n\t\t * max, not what it tells us to use.\n\t\t *\n\t\t * Note: This will still be broken if the eDP panel is not lit\n\t\t * up by the BIOS, and thus we can't get the mode at module\n\t\t * load.\n\t\t */\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"pipe has %d bpp for eDP panel, overriding BIOS-provided max %d bpp\\n\",\n\t\t\t    pipe_config->pipe_bpp, dev_priv->vbt.edp.bpp);\n\t\tdev_priv->vbt.edp.bpp = pipe_config->pipe_bpp;\n\t}\n}\n\nstatic bool\nintel_dp_get_dpcd(struct intel_dp *intel_dp);\n\n/**\n * intel_dp_sync_state - sync the encoder state during init/resume\n * @encoder: intel encoder to sync\n * @crtc_state: state for the CRTC connected to the encoder\n *\n * Sync any state stored in the encoder wrt. HW state during driver init\n * and system resume.\n */\nvoid intel_dp_sync_state(struct intel_encoder *encoder,\n\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t/*\n\t * Don't clobber DPCD if it's been already read out during output\n\t * setup (eDP) or detect.\n\t */\n\tif (intel_dp->dpcd[DP_DPCD_REV] == 0)\n\t\tintel_dp_get_dpcd(intel_dp);\n\n\tintel_dp->max_link_lane_count = intel_dp_max_common_lane_count(intel_dp);\n\tintel_dp->max_link_rate = intel_dp_max_common_rate(intel_dp);\n}\n\nbool intel_dp_initial_fastset_check(struct intel_encoder *encoder,\n\t\t\t\t    struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *i915 = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t/*\n\t * If BIOS has set an unsupported or non-standard link rate for some\n\t * reason force an encoder recompute and full modeset.\n\t */\n\tif (intel_dp_rate_index(intel_dp->source_rates, intel_dp->num_source_rates,\n\t\t\t\tcrtc_state->port_clock) < 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"Forcing full modeset due to unsupported link rate\\n\");\n\t\tcrtc_state->uapi.connectors_changed = true;\n\t\treturn false;\n\t}\n\n\t/*\n\t * FIXME hack to force full modeset when DSC is being used.\n\t *\n\t * As long as we do not have full state readout and config comparison\n\t * of crtc_state->dsc, we have no way to ensure reliable fastset.\n\t * Remove once we have readout for DSC.\n\t */\n\tif (crtc_state->dsc.compression_enable) {\n\t\tdrm_dbg_kms(&i915->drm, \"Forcing full modeset due to DSC being enabled\\n\");\n\t\tcrtc_state->uapi.mode_changed = true;\n\t\treturn false;\n\t}\n\n\tif (CAN_PSR(i915) && intel_dp_is_edp(intel_dp)) {\n\t\tdrm_dbg_kms(&i915->drm, \"Forcing full modeset to compute PSR state\\n\");\n\t\tcrtc_state->uapi.mode_changed = true;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void intel_disable_dp(struct intel_atomic_state *state,\n\t\t\t     struct intel_encoder *encoder,\n\t\t\t     const struct intel_crtc_state *old_crtc_state,\n\t\t\t     const struct drm_connector_state *old_conn_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\tintel_dp->link_trained = false;\n\n\tif (old_crtc_state->has_audio)\n\t\tintel_audio_codec_disable(encoder,\n\t\t\t\t\t  old_crtc_state, old_conn_state);\n\n\t/* Make sure the panel is off before trying to change the mode. But also\n\t * ensure that we have vdd while we switch off the panel. */\n\tintel_edp_panel_vdd_on(intel_dp);\n\tintel_edp_backlight_off(old_conn_state);\n\tintel_dp_set_power(intel_dp, DP_SET_POWER_D3);\n\tintel_edp_panel_off(intel_dp);\n}\n\nstatic void g4x_disable_dp(struct intel_atomic_state *state,\n\t\t\t   struct intel_encoder *encoder,\n\t\t\t   const struct intel_crtc_state *old_crtc_state,\n\t\t\t   const struct drm_connector_state *old_conn_state)\n{\n\tintel_disable_dp(state, encoder, old_crtc_state, old_conn_state);\n}\n\nstatic void vlv_disable_dp(struct intel_atomic_state *state,\n\t\t\t   struct intel_encoder *encoder,\n\t\t\t   const struct intel_crtc_state *old_crtc_state,\n\t\t\t   const struct drm_connector_state *old_conn_state)\n{\n\tintel_disable_dp(state, encoder, old_crtc_state, old_conn_state);\n}\n\nstatic void g4x_post_disable_dp(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *old_crtc_state,\n\t\t\t\tconst struct drm_connector_state *old_conn_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tenum port port = encoder->port;\n\n\t/*\n\t * Bspec does not list a specific disable sequence for g4x DP.\n\t * Follow the ilk+ sequence (disable pipe before the port) for\n\t * g4x DP as it does not suffer from underruns like the normal\n\t * g4x modeset sequence (disable pipe after the port).\n\t */\n\tintel_dp_link_down(encoder, old_crtc_state);\n\n\t/* Only ilk+ has port A */\n\tif (port == PORT_A)\n\t\tilk_edp_pll_off(intel_dp, old_crtc_state);\n}\n\nstatic void vlv_post_disable_dp(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *old_crtc_state,\n\t\t\t\tconst struct drm_connector_state *old_conn_state)\n{\n\tintel_dp_link_down(encoder, old_crtc_state);\n}\n\nstatic void chv_post_disable_dp(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *old_crtc_state,\n\t\t\t\tconst struct drm_connector_state *old_conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\n\tintel_dp_link_down(encoder, old_crtc_state);\n\n\tvlv_dpio_get(dev_priv);\n\n\t/* Assert data lane reset */\n\tchv_data_lane_soft_reset(encoder, old_crtc_state, true);\n\n\tvlv_dpio_put(dev_priv);\n}\n\nstatic void\ncpt_set_link_train(struct intel_dp *intel_dp,\n\t\t   const struct intel_crtc_state *crtc_state,\n\t\t   u8 dp_train_pat)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu32 *DP = &intel_dp->DP;\n\n\t*DP &= ~DP_LINK_TRAIN_MASK_CPT;\n\n\tswitch (intel_dp_training_pattern_symbol(dp_train_pat)) {\n\tcase DP_TRAINING_PATTERN_DISABLE:\n\t\t*DP |= DP_LINK_TRAIN_OFF_CPT;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_1:\n\t\t*DP |= DP_LINK_TRAIN_PAT_1_CPT;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_2:\n\t\t*DP |= DP_LINK_TRAIN_PAT_2_CPT;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_3:\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"TPS3 not supported, using TPS2 instead\\n\");\n\t\t*DP |= DP_LINK_TRAIN_PAT_2_CPT;\n\t\tbreak;\n\t}\n\n\tintel_de_write(dev_priv, intel_dp->output_reg, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n}\n\nstatic void\ng4x_set_link_train(struct intel_dp *intel_dp,\n\t\t   const struct intel_crtc_state *crtc_state,\n\t\t   u8 dp_train_pat)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu32 *DP = &intel_dp->DP;\n\n\t*DP &= ~DP_LINK_TRAIN_MASK;\n\n\tswitch (intel_dp_training_pattern_symbol(dp_train_pat)) {\n\tcase DP_TRAINING_PATTERN_DISABLE:\n\t\t*DP |= DP_LINK_TRAIN_OFF;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_1:\n\t\t*DP |= DP_LINK_TRAIN_PAT_1;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_2:\n\t\t*DP |= DP_LINK_TRAIN_PAT_2;\n\t\tbreak;\n\tcase DP_TRAINING_PATTERN_3:\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"TPS3 not supported, using TPS2 instead\\n\");\n\t\t*DP |= DP_LINK_TRAIN_PAT_2;\n\t\tbreak;\n\t}\n\n\tintel_de_write(dev_priv, intel_dp->output_reg, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n}\n\nstatic void intel_dp_enable_port(struct intel_dp *intel_dp,\n\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\t/* enable with pattern 1 (as per spec) */\n\n\tintel_dp_program_link_training_pattern(intel_dp, crtc_state,\n\t\t\t\t\t       DP_TRAINING_PATTERN_1);\n\n\t/*\n\t * Magic for VLV/CHV. We _must_ first set up the register\n\t * without actually enabling the port, and then do another\n\t * write to enable the port. Otherwise link training will\n\t * fail when the power sequencer is freshly used for this port.\n\t */\n\tintel_dp->DP |= DP_PORT_EN;\n\tif (crtc_state->has_audio)\n\t\tintel_dp->DP |= DP_AUDIO_OUTPUT_ENABLE;\n\n\tintel_de_write(dev_priv, intel_dp->output_reg, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n}\n\nvoid intel_dp_configure_protocol_converter(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 tmp;\n\n\tif (intel_dp->dpcd[DP_DPCD_REV] < 0x13)\n\t\treturn;\n\n\tif (!drm_dp_is_branch(intel_dp->dpcd))\n\t\treturn;\n\n\ttmp = intel_dp->has_hdmi_sink ?\n\t\tDP_HDMI_DVI_OUTPUT_CONFIG : 0;\n\n\tif (drm_dp_dpcd_writeb(&intel_dp->aux,\n\t\t\t       DP_PROTOCOL_CONVERTER_CONTROL_0, tmp) != 1)\n\t\tdrm_dbg_kms(&i915->drm, \"Failed to set protocol converter HDMI mode to %s\\n\",\n\t\t\t    enableddisabled(intel_dp->has_hdmi_sink));\n\n\ttmp = intel_dp->dfp.ycbcr_444_to_420 ?\n\t\tDP_CONVERSION_TO_YCBCR420_ENABLE : 0;\n\n\tif (drm_dp_dpcd_writeb(&intel_dp->aux,\n\t\t\t       DP_PROTOCOL_CONVERTER_CONTROL_1, tmp) != 1)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Failed to set protocol converter YCbCr 4:2:0 conversion mode to %s\\n\",\n\t\t\t    enableddisabled(intel_dp->dfp.ycbcr_444_to_420));\n\n\ttmp = 0;\n\n\tif (drm_dp_dpcd_writeb(&intel_dp->aux,\n\t\t\t       DP_PROTOCOL_CONVERTER_CONTROL_2, tmp) <= 0)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Failed to set protocol converter YCbCr 4:2:2 conversion mode to %s\\n\",\n\t\t\t    enableddisabled(false));\n}\n\nstatic void intel_enable_dp(struct intel_atomic_state *state,\n\t\t\t    struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *pipe_config,\n\t\t\t    const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_crtc *crtc = to_intel_crtc(pipe_config->uapi.crtc);\n\tu32 dp_reg = intel_de_read(dev_priv, intel_dp->output_reg);\n\tenum pipe pipe = crtc->pipe;\n\tintel_wakeref_t wakeref;\n\n\tif (drm_WARN_ON(&dev_priv->drm, dp_reg & DP_PORT_EN))\n\t\treturn;\n\n\twith_pps_lock(intel_dp, wakeref) {\n\t\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\t\tvlv_init_panel_power_sequencer(encoder, pipe_config);\n\n\t\tintel_dp_enable_port(intel_dp, pipe_config);\n\n\t\tedp_panel_vdd_on(intel_dp);\n\t\tedp_panel_on(intel_dp);\n\t\tedp_panel_vdd_off(intel_dp, true);\n\t}\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tunsigned int lane_mask = 0x0;\n\n\t\tif (IS_CHERRYVIEW(dev_priv))\n\t\t\tlane_mask = intel_dp_unused_lane_mask(pipe_config->lane_count);\n\n\t\tvlv_wait_port_ready(dev_priv, dp_to_dig_port(intel_dp),\n\t\t\t\t    lane_mask);\n\t}\n\n\tintel_dp_set_power(intel_dp, DP_SET_POWER_D0);\n\tintel_dp_configure_protocol_converter(intel_dp);\n\tintel_dp_start_link_train(intel_dp, pipe_config);\n\tintel_dp_stop_link_train(intel_dp, pipe_config);\n\n\tif (pipe_config->has_audio) {\n\t\tdrm_dbg(&dev_priv->drm, \"Enabling DP audio on pipe %c\\n\",\n\t\t\tpipe_name(pipe));\n\t\tintel_audio_codec_enable(encoder, pipe_config, conn_state);\n\t}\n}\n\nstatic void g4x_enable_dp(struct intel_atomic_state *state,\n\t\t\t  struct intel_encoder *encoder,\n\t\t\t  const struct intel_crtc_state *pipe_config,\n\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tintel_enable_dp(state, encoder, pipe_config, conn_state);\n\tintel_edp_backlight_on(pipe_config, conn_state);\n}\n\nstatic void vlv_enable_dp(struct intel_atomic_state *state,\n\t\t\t  struct intel_encoder *encoder,\n\t\t\t  const struct intel_crtc_state *pipe_config,\n\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tintel_edp_backlight_on(pipe_config, conn_state);\n}\n\nstatic void g4x_pre_enable_dp(struct intel_atomic_state *state,\n\t\t\t      struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *pipe_config,\n\t\t\t      const struct drm_connector_state *conn_state)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tenum port port = encoder->port;\n\n\tintel_dp_prepare(encoder, pipe_config);\n\n\t/* Only ilk+ has port A */\n\tif (port == PORT_A)\n\t\tilk_edp_pll_on(intel_dp, pipe_config);\n}\n\nstatic void vlv_detach_power_sequencer(struct intel_dp *intel_dp)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);\n\tenum pipe pipe = intel_dp->pps_pipe;\n\ti915_reg_t pp_on_reg = PP_ON_DELAYS(pipe);\n\n\tdrm_WARN_ON(&dev_priv->drm, intel_dp->active_pipe != INVALID_PIPE);\n\n\tif (drm_WARN_ON(&dev_priv->drm, pipe != PIPE_A && pipe != PIPE_B))\n\t\treturn;\n\n\tedp_panel_vdd_off_sync(intel_dp);\n\n\t/*\n\t * VLV seems to get confused when multiple power sequencers\n\t * have the same port selected (even if only one has power/vdd\n\t * enabled). The failure manifests as vlv_wait_port_ready() failing\n\t * CHV on the other hand doesn't seem to mind having the same port\n\t * selected in multiple power sequencers, but let's clear the\n\t * port select always when logically disconnecting a power sequencer\n\t * from a port.\n\t */\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"detaching pipe %c power sequencer from [ENCODER:%d:%s]\\n\",\n\t\t    pipe_name(pipe), dig_port->base.base.base.id,\n\t\t    dig_port->base.base.name);\n\tintel_de_write(dev_priv, pp_on_reg, 0);\n\tintel_de_posting_read(dev_priv, pp_on_reg);\n\n\tintel_dp->pps_pipe = INVALID_PIPE;\n}\n\nstatic void vlv_steal_power_sequencer(struct drm_i915_private *dev_priv,\n\t\t\t\t      enum pipe pipe)\n{\n\tstruct intel_encoder *encoder;\n\n\tlockdep_assert_held(&dev_priv->pps_mutex);\n\n\tfor_each_intel_dp(&dev_priv->drm, encoder) {\n\t\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\n\t\tdrm_WARN(&dev_priv->drm, intel_dp->active_pipe == pipe,\n\t\t\t \"stealing pipe %c power sequencer from active [ENCODER:%d:%s]\\n\",\n\t\t\t pipe_name(pipe), encoder->base.base.id,\n\t\t\t encoder->base.name);\n\n\t\tif (intel_dp->pps_pipe != pipe)\n\t\t\tcontinue;\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"stealing pipe %c power sequencer from [ENCODER:%d:%s]\\n\",\n\t\t\t    pipe_name(pipe), encoder->base.base.id,\n\t\t\t    encoder->base.name);\n\n\t\t/* make sure vdd is off before we steal it */\n\t\tvlv_detach_power_sequencer(intel_dp);\n\t}\n}\n\nstatic void vlv_init_panel_power_sequencer(struct intel_encoder *encoder,\n\t\t\t\t\t   const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\n\tlockdep_assert_held(&dev_priv->pps_mutex);\n\n\tdrm_WARN_ON(&dev_priv->drm, intel_dp->active_pipe != INVALID_PIPE);\n\n\tif (intel_dp->pps_pipe != INVALID_PIPE &&\n\t    intel_dp->pps_pipe != crtc->pipe) {\n\t\t/*\n\t\t * If another power sequencer was being used on this\n\t\t * port previously make sure to turn off vdd there while\n\t\t * we still have control of it.\n\t\t */\n\t\tvlv_detach_power_sequencer(intel_dp);\n\t}\n\n\t/*\n\t * We may be stealing the power\n\t * sequencer from another port.\n\t */\n\tvlv_steal_power_sequencer(dev_priv, crtc->pipe);\n\n\tintel_dp->active_pipe = crtc->pipe;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\t/* now it's all ours */\n\tintel_dp->pps_pipe = crtc->pipe;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"initializing pipe %c power sequencer for [ENCODER:%d:%s]\\n\",\n\t\t    pipe_name(intel_dp->pps_pipe), encoder->base.base.id,\n\t\t    encoder->base.name);\n\n\t/* init power sequencer on this pipe and port */\n\tintel_dp_init_panel_power_sequencer(intel_dp);\n\tintel_dp_init_panel_power_sequencer_registers(intel_dp, true);\n}\n\nstatic void vlv_pre_enable_dp(struct intel_atomic_state *state,\n\t\t\t      struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *pipe_config,\n\t\t\t      const struct drm_connector_state *conn_state)\n{\n\tvlv_phy_pre_encoder_enable(encoder, pipe_config);\n\n\tintel_enable_dp(state, encoder, pipe_config, conn_state);\n}\n\nstatic void vlv_dp_pre_pll_enable(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *pipe_config,\n\t\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tintel_dp_prepare(encoder, pipe_config);\n\n\tvlv_phy_pre_pll_enable(encoder, pipe_config);\n}\n\nstatic void chv_pre_enable_dp(struct intel_atomic_state *state,\n\t\t\t      struct intel_encoder *encoder,\n\t\t\t      const struct intel_crtc_state *pipe_config,\n\t\t\t      const struct drm_connector_state *conn_state)\n{\n\tchv_phy_pre_encoder_enable(encoder, pipe_config);\n\n\tintel_enable_dp(state, encoder, pipe_config, conn_state);\n\n\t/* Second common lane will stay alive on its own now */\n\tchv_phy_release_cl2_override(encoder);\n}\n\nstatic void chv_dp_pre_pll_enable(struct intel_atomic_state *state,\n\t\t\t\t  struct intel_encoder *encoder,\n\t\t\t\t  const struct intel_crtc_state *pipe_config,\n\t\t\t\t  const struct drm_connector_state *conn_state)\n{\n\tintel_dp_prepare(encoder, pipe_config);\n\n\tchv_phy_pre_pll_enable(encoder, pipe_config);\n}\n\nstatic void chv_dp_post_pll_disable(struct intel_atomic_state *state,\n\t\t\t\t    struct intel_encoder *encoder,\n\t\t\t\t    const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t    const struct drm_connector_state *old_conn_state)\n{\n\tchv_phy_post_pll_disable(encoder, old_crtc_state);\n}\n\nstatic u8 intel_dp_voltage_max_2(struct intel_dp *intel_dp,\n\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\treturn DP_TRAIN_VOLTAGE_SWING_LEVEL_2;\n}\n\nstatic u8 intel_dp_voltage_max_3(struct intel_dp *intel_dp,\n\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\treturn DP_TRAIN_VOLTAGE_SWING_LEVEL_3;\n}\n\nstatic u8 intel_dp_preemph_max_2(struct intel_dp *intel_dp)\n{\n\treturn DP_TRAIN_PRE_EMPH_LEVEL_2;\n}\n\nstatic u8 intel_dp_preemph_max_3(struct intel_dp *intel_dp)\n{\n\treturn DP_TRAIN_PRE_EMPH_LEVEL_3;\n}\n\nstatic void vlv_set_signal_levels(struct intel_dp *intel_dp,\n\t\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_encoder *encoder = &dp_to_dig_port(intel_dp)->base;\n\tunsigned long demph_reg_value, preemph_reg_value,\n\t\tuniqtranscale_reg_value;\n\tu8 train_set = intel_dp->train_set[0];\n\n\tswitch (train_set & DP_TRAIN_PRE_EMPHASIS_MASK) {\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_0:\n\t\tpreemph_reg_value = 0x0004000;\n\t\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\t\t\tdemph_reg_value = 0x2B405555;\n\t\t\tuniqtranscale_reg_value = 0x552AB83A;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1:\n\t\t\tdemph_reg_value = 0x2B404040;\n\t\t\tuniqtranscale_reg_value = 0x5548B83A;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2:\n\t\t\tdemph_reg_value = 0x2B245555;\n\t\t\tuniqtranscale_reg_value = 0x5560B83A;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_3:\n\t\t\tdemph_reg_value = 0x2B405555;\n\t\t\tuniqtranscale_reg_value = 0x5598DA3A;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_1:\n\t\tpreemph_reg_value = 0x0002000;\n\t\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\t\t\tdemph_reg_value = 0x2B404040;\n\t\t\tuniqtranscale_reg_value = 0x5552B83A;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1:\n\t\t\tdemph_reg_value = 0x2B404848;\n\t\t\tuniqtranscale_reg_value = 0x5580B83A;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2:\n\t\t\tdemph_reg_value = 0x2B404040;\n\t\t\tuniqtranscale_reg_value = 0x55ADDA3A;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_2:\n\t\tpreemph_reg_value = 0x0000000;\n\t\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\t\t\tdemph_reg_value = 0x2B305555;\n\t\t\tuniqtranscale_reg_value = 0x5570B83A;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1:\n\t\t\tdemph_reg_value = 0x2B2B4040;\n\t\t\tuniqtranscale_reg_value = 0x55ADDA3A;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_3:\n\t\tpreemph_reg_value = 0x0006000;\n\t\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\t\t\tdemph_reg_value = 0x1B405555;\n\t\t\tuniqtranscale_reg_value = 0x55ADDA3A;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tvlv_set_phy_signal_level(encoder, crtc_state,\n\t\t\t\t demph_reg_value, preemph_reg_value,\n\t\t\t\t uniqtranscale_reg_value, 0);\n}\n\nstatic void chv_set_signal_levels(struct intel_dp *intel_dp,\n\t\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_encoder *encoder = &dp_to_dig_port(intel_dp)->base;\n\tu32 deemph_reg_value, margin_reg_value;\n\tbool uniq_trans_scale = false;\n\tu8 train_set = intel_dp->train_set[0];\n\n\tswitch (train_set & DP_TRAIN_PRE_EMPHASIS_MASK) {\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_0:\n\t\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\t\t\tdeemph_reg_value = 128;\n\t\t\tmargin_reg_value = 52;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1:\n\t\t\tdeemph_reg_value = 128;\n\t\t\tmargin_reg_value = 77;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2:\n\t\t\tdeemph_reg_value = 128;\n\t\t\tmargin_reg_value = 102;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_3:\n\t\t\tdeemph_reg_value = 128;\n\t\t\tmargin_reg_value = 154;\n\t\t\tuniq_trans_scale = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_1:\n\t\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\t\t\tdeemph_reg_value = 85;\n\t\t\tmargin_reg_value = 78;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1:\n\t\t\tdeemph_reg_value = 85;\n\t\t\tmargin_reg_value = 116;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2:\n\t\t\tdeemph_reg_value = 85;\n\t\t\tmargin_reg_value = 154;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_2:\n\t\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\t\t\tdeemph_reg_value = 64;\n\t\t\tmargin_reg_value = 104;\n\t\t\tbreak;\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1:\n\t\t\tdeemph_reg_value = 64;\n\t\t\tmargin_reg_value = 154;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_3:\n\t\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\t\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\t\t\tdeemph_reg_value = 43;\n\t\t\tmargin_reg_value = 154;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tchv_set_phy_signal_level(encoder, crtc_state,\n\t\t\t\t deemph_reg_value, margin_reg_value,\n\t\t\t\t uniq_trans_scale);\n}\n\nstatic u32 g4x_signal_levels(u8 train_set)\n{\n\tu32 signal_levels = 0;\n\n\tswitch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0:\n\tdefault:\n\t\tsignal_levels |= DP_VOLTAGE_0_4;\n\t\tbreak;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1:\n\t\tsignal_levels |= DP_VOLTAGE_0_6;\n\t\tbreak;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2:\n\t\tsignal_levels |= DP_VOLTAGE_0_8;\n\t\tbreak;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_3:\n\t\tsignal_levels |= DP_VOLTAGE_1_2;\n\t\tbreak;\n\t}\n\tswitch (train_set & DP_TRAIN_PRE_EMPHASIS_MASK) {\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_0:\n\tdefault:\n\t\tsignal_levels |= DP_PRE_EMPHASIS_0;\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_1:\n\t\tsignal_levels |= DP_PRE_EMPHASIS_3_5;\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_2:\n\t\tsignal_levels |= DP_PRE_EMPHASIS_6;\n\t\tbreak;\n\tcase DP_TRAIN_PRE_EMPH_LEVEL_3:\n\t\tsignal_levels |= DP_PRE_EMPHASIS_9_5;\n\t\tbreak;\n\t}\n\treturn signal_levels;\n}\n\nstatic void\ng4x_set_signal_levels(struct intel_dp *intel_dp,\n\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu8 train_set = intel_dp->train_set[0];\n\tu32 signal_levels;\n\n\tsignal_levels = g4x_signal_levels(train_set);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Using signal levels %08x\\n\",\n\t\t    signal_levels);\n\n\tintel_dp->DP &= ~(DP_VOLTAGE_MASK | DP_PRE_EMPHASIS_MASK);\n\tintel_dp->DP |= signal_levels;\n\n\tintel_de_write(dev_priv, intel_dp->output_reg, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n}\n\n/* SNB CPU eDP voltage swing and pre-emphasis control */\nstatic u32 snb_cpu_edp_signal_levels(u8 train_set)\n{\n\tu8 signal_levels = train_set & (DP_TRAIN_VOLTAGE_SWING_MASK |\n\t\t\t\t\tDP_TRAIN_PRE_EMPHASIS_MASK);\n\n\tswitch (signal_levels) {\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_0:\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_0:\n\t\treturn EDP_LINK_TRAIN_400_600MV_0DB_SNB_B;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_1:\n\t\treturn EDP_LINK_TRAIN_400MV_3_5DB_SNB_B;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_2:\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_2:\n\t\treturn EDP_LINK_TRAIN_400_600MV_6DB_SNB_B;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_1:\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2 | DP_TRAIN_PRE_EMPH_LEVEL_1:\n\t\treturn EDP_LINK_TRAIN_600_800MV_3_5DB_SNB_B;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2 | DP_TRAIN_PRE_EMPH_LEVEL_0:\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_3 | DP_TRAIN_PRE_EMPH_LEVEL_0:\n\t\treturn EDP_LINK_TRAIN_800_1200MV_0DB_SNB_B;\n\tdefault:\n\t\tDRM_DEBUG_KMS(\"Unsupported voltage swing/pre-emphasis level:\"\n\t\t\t      \"0x%x\\n\", signal_levels);\n\t\treturn EDP_LINK_TRAIN_400_600MV_0DB_SNB_B;\n\t}\n}\n\nstatic void\nsnb_cpu_edp_set_signal_levels(struct intel_dp *intel_dp,\n\t\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu8 train_set = intel_dp->train_set[0];\n\tu32 signal_levels;\n\n\tsignal_levels = snb_cpu_edp_signal_levels(train_set);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Using signal levels %08x\\n\",\n\t\t    signal_levels);\n\n\tintel_dp->DP &= ~EDP_LINK_TRAIN_VOL_EMP_MASK_SNB;\n\tintel_dp->DP |= signal_levels;\n\n\tintel_de_write(dev_priv, intel_dp->output_reg, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n}\n\n/* IVB CPU eDP voltage swing and pre-emphasis control */\nstatic u32 ivb_cpu_edp_signal_levels(u8 train_set)\n{\n\tu8 signal_levels = train_set & (DP_TRAIN_VOLTAGE_SWING_MASK |\n\t\t\t\t\tDP_TRAIN_PRE_EMPHASIS_MASK);\n\n\tswitch (signal_levels) {\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_0:\n\t\treturn EDP_LINK_TRAIN_400MV_0DB_IVB;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_1:\n\t\treturn EDP_LINK_TRAIN_400MV_3_5DB_IVB;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_2:\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_2:\n\t\treturn EDP_LINK_TRAIN_400MV_6DB_IVB;\n\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_0:\n\t\treturn EDP_LINK_TRAIN_600MV_0DB_IVB;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_1:\n\t\treturn EDP_LINK_TRAIN_600MV_3_5DB_IVB;\n\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2 | DP_TRAIN_PRE_EMPH_LEVEL_0:\n\t\treturn EDP_LINK_TRAIN_800MV_0DB_IVB;\n\tcase DP_TRAIN_VOLTAGE_SWING_LEVEL_2 | DP_TRAIN_PRE_EMPH_LEVEL_1:\n\t\treturn EDP_LINK_TRAIN_800MV_3_5DB_IVB;\n\n\tdefault:\n\t\tDRM_DEBUG_KMS(\"Unsupported voltage swing/pre-emphasis level:\"\n\t\t\t      \"0x%x\\n\", signal_levels);\n\t\treturn EDP_LINK_TRAIN_500MV_0DB_IVB;\n\t}\n}\n\nstatic void\nivb_cpu_edp_set_signal_levels(struct intel_dp *intel_dp,\n\t\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu8 train_set = intel_dp->train_set[0];\n\tu32 signal_levels;\n\n\tsignal_levels = ivb_cpu_edp_signal_levels(train_set);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Using signal levels %08x\\n\",\n\t\t    signal_levels);\n\n\tintel_dp->DP &= ~EDP_LINK_TRAIN_VOL_EMP_MASK_IVB;\n\tintel_dp->DP |= signal_levels;\n\n\tintel_de_write(dev_priv, intel_dp->output_reg, intel_dp->DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n}\n\nvoid intel_dp_set_signal_levels(struct intel_dp *intel_dp,\n\t\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu8 train_set = intel_dp->train_set[0];\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Using vswing level %d%s\\n\",\n\t\t    train_set & DP_TRAIN_VOLTAGE_SWING_MASK,\n\t\t    train_set & DP_TRAIN_MAX_SWING_REACHED ? \" (max)\" : \"\");\n\tdrm_dbg_kms(&dev_priv->drm, \"Using pre-emphasis level %d%s\\n\",\n\t\t    (train_set & DP_TRAIN_PRE_EMPHASIS_MASK) >>\n\t\t    DP_TRAIN_PRE_EMPHASIS_SHIFT,\n\t\t    train_set & DP_TRAIN_MAX_PRE_EMPHASIS_REACHED ?\n\t\t    \" (max)\" : \"\");\n\n\tintel_dp->set_signal_levels(intel_dp, crtc_state);\n}\n\nvoid\nintel_dp_program_link_training_pattern(struct intel_dp *intel_dp,\n\t\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t\t       u8 dp_train_pat)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tif ((intel_dp_training_pattern_symbol(dp_train_pat)) !=\n\t    DP_TRAINING_PATTERN_DISABLE)\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Using DP training pattern TPS%d\\n\",\n\t\t\t    intel_dp_training_pattern_symbol(dp_train_pat));\n\n\tintel_dp->set_link_train(intel_dp, crtc_state, dp_train_pat);\n}\n\nstatic void\nintel_dp_link_down(struct intel_encoder *encoder,\n\t\t   const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_crtc *crtc = to_intel_crtc(old_crtc_state->uapi.crtc);\n\tenum port port = encoder->port;\n\tu32 DP = intel_dp->DP;\n\n\tif (drm_WARN_ON(&dev_priv->drm,\n\t\t\t(intel_de_read(dev_priv, intel_dp->output_reg) &\n\t\t\t DP_PORT_EN) == 0))\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"\\n\");\n\n\tif ((IS_IVYBRIDGE(dev_priv) && port == PORT_A) ||\n\t    (HAS_PCH_CPT(dev_priv) && port != PORT_A)) {\n\t\tDP &= ~DP_LINK_TRAIN_MASK_CPT;\n\t\tDP |= DP_LINK_TRAIN_PAT_IDLE_CPT;\n\t} else {\n\t\tDP &= ~DP_LINK_TRAIN_MASK;\n\t\tDP |= DP_LINK_TRAIN_PAT_IDLE;\n\t}\n\tintel_de_write(dev_priv, intel_dp->output_reg, DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n\n\tDP &= ~(DP_PORT_EN | DP_AUDIO_OUTPUT_ENABLE);\n\tintel_de_write(dev_priv, intel_dp->output_reg, DP);\n\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n\n\t/*\n\t * HW workaround for IBX, we need to move the port\n\t * to transcoder A after disabling it to allow the\n\t * matching HDMI port to be enabled on transcoder A.\n\t */\n\tif (HAS_PCH_IBX(dev_priv) && crtc->pipe == PIPE_B && port != PORT_A) {\n\t\t/*\n\t\t * We get CPU/PCH FIFO underruns on the other pipe when\n\t\t * doing the workaround. Sweep them under the rug.\n\t\t */\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, PIPE_A, false);\n\t\tintel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, false);\n\n\t\t/* always enable with pattern 1 (as per spec) */\n\t\tDP &= ~(DP_PIPE_SEL_MASK | DP_LINK_TRAIN_MASK);\n\t\tDP |= DP_PORT_EN | DP_PIPE_SEL(PIPE_A) |\n\t\t\tDP_LINK_TRAIN_PAT_1;\n\t\tintel_de_write(dev_priv, intel_dp->output_reg, DP);\n\t\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n\n\t\tDP &= ~DP_PORT_EN;\n\t\tintel_de_write(dev_priv, intel_dp->output_reg, DP);\n\t\tintel_de_posting_read(dev_priv, intel_dp->output_reg);\n\n\t\tintel_wait_for_vblank_if_active(dev_priv, PIPE_A);\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, PIPE_A, true);\n\t\tintel_set_pch_fifo_underrun_reporting(dev_priv, PIPE_A, true);\n\t}\n\n\tmsleep(intel_dp->panel_power_down_delay);\n\n\tintel_dp->DP = DP;\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tintel_wakeref_t wakeref;\n\n\t\twith_pps_lock(intel_dp, wakeref)\n\t\t\tintel_dp->active_pipe = INVALID_PIPE;\n\t}\n}\n\nbool intel_dp_get_colorimetry_status(struct intel_dp *intel_dp)\n{\n\tu8 dprx = 0;\n\n\tif (drm_dp_dpcd_readb(&intel_dp->aux, DP_DPRX_FEATURE_ENUMERATION_LIST,\n\t\t\t      &dprx) != 1)\n\t\treturn false;\n\treturn dprx & DP_VSC_SDP_EXT_FOR_COLORIMETRY_SUPPORTED;\n}\n\nstatic void intel_dp_get_dsc_sink_cap(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\t/*\n\t * Clear the cached register set to avoid using stale values\n\t * for the sinks that do not support DSC.\n\t */\n\tmemset(intel_dp->dsc_dpcd, 0, sizeof(intel_dp->dsc_dpcd));\n\n\t/* Clear fec_capable to avoid using stale values */\n\tintel_dp->fec_capable = 0;\n\n\t/* Cache the DSC DPCD if eDP or DP rev >= 1.4 */\n\tif (intel_dp->dpcd[DP_DPCD_REV] >= 0x14 ||\n\t    intel_dp->edp_dpcd[0] >= DP_EDP_14) {\n\t\tif (drm_dp_dpcd_read(&intel_dp->aux, DP_DSC_SUPPORT,\n\t\t\t\t     intel_dp->dsc_dpcd,\n\t\t\t\t     sizeof(intel_dp->dsc_dpcd)) < 0)\n\t\t\tdrm_err(&i915->drm,\n\t\t\t\t\"Failed to read DPCD register 0x%x\\n\",\n\t\t\t\tDP_DSC_SUPPORT);\n\n\t\tdrm_dbg_kms(&i915->drm, \"DSC DPCD: %*ph\\n\",\n\t\t\t    (int)sizeof(intel_dp->dsc_dpcd),\n\t\t\t    intel_dp->dsc_dpcd);\n\n\t\t/* FEC is supported only on DP 1.4 */\n\t\tif (!intel_dp_is_edp(intel_dp) &&\n\t\t    drm_dp_dpcd_readb(&intel_dp->aux, DP_FEC_CAPABILITY,\n\t\t\t\t      &intel_dp->fec_capable) < 0)\n\t\t\tdrm_err(&i915->drm,\n\t\t\t\t\"Failed to read FEC DPCD register\\n\");\n\n\t\tdrm_dbg_kms(&i915->drm, \"FEC CAPABILITY: %x\\n\",\n\t\t\t    intel_dp->fec_capable);\n\t}\n}\n\nstatic bool\nintel_edp_init_dpcd(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tto_i915(dp_to_dig_port(intel_dp)->base.base.dev);\n\n\t/* this function is meant to be called only once */\n\tdrm_WARN_ON(&dev_priv->drm, intel_dp->dpcd[DP_DPCD_REV] != 0);\n\n\tif (drm_dp_read_dpcd_caps(&intel_dp->aux, intel_dp->dpcd) != 0)\n\t\treturn false;\n\n\tdrm_dp_read_desc(&intel_dp->aux, &intel_dp->desc,\n\t\t\t drm_dp_is_branch(intel_dp->dpcd));\n\n\t/*\n\t * Read the eDP display control registers.\n\t *\n\t * Do this independent of DP_DPCD_DISPLAY_CONTROL_CAPABLE bit in\n\t * DP_EDP_CONFIGURATION_CAP, because some buggy displays do not have it\n\t * set, but require eDP 1.4+ detection (e.g. for supported link rates\n\t * method). The display control registers should read zero if they're\n\t * not supported anyway.\n\t */\n\tif (drm_dp_dpcd_read(&intel_dp->aux, DP_EDP_DPCD_REV,\n\t\t\t     intel_dp->edp_dpcd, sizeof(intel_dp->edp_dpcd)) ==\n\t\t\t     sizeof(intel_dp->edp_dpcd))\n\t\tdrm_dbg_kms(&dev_priv->drm, \"eDP DPCD: %*ph\\n\",\n\t\t\t    (int)sizeof(intel_dp->edp_dpcd),\n\t\t\t    intel_dp->edp_dpcd);\n\n\t/*\n\t * This has to be called after intel_dp->edp_dpcd is filled, PSR checks\n\t * for SET_POWER_CAPABLE bit in intel_dp->edp_dpcd[1]\n\t */\n\tintel_psr_init_dpcd(intel_dp);\n\n\t/* Read the eDP 1.4+ supported link rates. */\n\tif (intel_dp->edp_dpcd[0] >= DP_EDP_14) {\n\t\t__le16 sink_rates[DP_MAX_SUPPORTED_RATES];\n\t\tint i;\n\n\t\tdrm_dp_dpcd_read(&intel_dp->aux, DP_SUPPORTED_LINK_RATES,\n\t\t\t\tsink_rates, sizeof(sink_rates));\n\n\t\tfor (i = 0; i < ARRAY_SIZE(sink_rates); i++) {\n\t\t\tint val = le16_to_cpu(sink_rates[i]);\n\n\t\t\tif (val == 0)\n\t\t\t\tbreak;\n\n\t\t\t/* Value read multiplied by 200kHz gives the per-lane\n\t\t\t * link rate in kHz. The source rates are, however,\n\t\t\t * stored in terms of LS_Clk kHz. The full conversion\n\t\t\t * back to symbols is\n\t\t\t * (val * 200kHz)*(8/10 ch. encoding)*(1/8 bit to Byte)\n\t\t\t */\n\t\t\tintel_dp->sink_rates[i] = (val * 200) / 10;\n\t\t}\n\t\tintel_dp->num_sink_rates = i;\n\t}\n\n\t/*\n\t * Use DP_LINK_RATE_SET if DP_SUPPORTED_LINK_RATES are available,\n\t * default to DP_MAX_LINK_RATE and DP_LINK_BW_SET otherwise.\n\t */\n\tif (intel_dp->num_sink_rates)\n\t\tintel_dp->use_rate_select = true;\n\telse\n\t\tintel_dp_set_sink_rates(intel_dp);\n\n\tintel_dp_set_common_rates(intel_dp);\n\n\t/* Read the eDP DSC DPCD registers */\n\tif (INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv))\n\t\tintel_dp_get_dsc_sink_cap(intel_dp);\n\n\treturn true;\n}\n\nstatic bool\nintel_dp_has_sink_count(struct intel_dp *intel_dp)\n{\n\tif (!intel_dp->attached_connector)\n\t\treturn false;\n\n\treturn drm_dp_read_sink_count_cap(&intel_dp->attached_connector->base,\n\t\t\t\t\t  intel_dp->dpcd,\n\t\t\t\t\t  &intel_dp->desc);\n}\n\nstatic bool\nintel_dp_get_dpcd(struct intel_dp *intel_dp)\n{\n\tint ret;\n\n\tintel_dp_lttpr_init(intel_dp);\n\n\tif (drm_dp_read_dpcd_caps(&intel_dp->aux, intel_dp->dpcd))\n\t\treturn false;\n\n\t/*\n\t * Don't clobber cached eDP rates. Also skip re-reading\n\t * the OUI/ID since we know it won't change.\n\t */\n\tif (!intel_dp_is_edp(intel_dp)) {\n\t\tdrm_dp_read_desc(&intel_dp->aux, &intel_dp->desc,\n\t\t\t\t drm_dp_is_branch(intel_dp->dpcd));\n\n\t\tintel_dp_set_sink_rates(intel_dp);\n\t\tintel_dp_set_common_rates(intel_dp);\n\t}\n\n\tif (intel_dp_has_sink_count(intel_dp)) {\n\t\tret = drm_dp_read_sink_count(&intel_dp->aux);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Sink count can change between short pulse hpd hence\n\t\t * a member variable in intel_dp will track any changes\n\t\t * between short pulse interrupts.\n\t\t */\n\t\tintel_dp->sink_count = ret;\n\n\t\t/*\n\t\t * SINK_COUNT == 0 and DOWNSTREAM_PORT_PRESENT == 1 implies that\n\t\t * a dongle is present but no display. Unless we require to know\n\t\t * if a dongle is present or not, we don't need to update\n\t\t * downstream port information. So, an early return here saves\n\t\t * time from performing other operations which are not required.\n\t\t */\n\t\tif (!intel_dp->sink_count)\n\t\t\treturn false;\n\t}\n\n\treturn drm_dp_read_downstream_info(&intel_dp->aux, intel_dp->dpcd,\n\t\t\t\t\t   intel_dp->downstream_ports) == 0;\n}\n\nstatic bool\nintel_dp_can_mst(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\n\treturn i915->params.enable_dp_mst &&\n\t\tintel_dp->can_mst &&\n\t\tdrm_dp_read_mst_cap(&intel_dp->aux, intel_dp->dpcd);\n}\n\nstatic void\nintel_dp_configure_mst(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_encoder *encoder =\n\t\t&dp_to_dig_port(intel_dp)->base;\n\tbool sink_can_mst = drm_dp_read_mst_cap(&intel_dp->aux, intel_dp->dpcd);\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[ENCODER:%d:%s] MST support: port: %s, sink: %s, modparam: %s\\n\",\n\t\t    encoder->base.base.id, encoder->base.name,\n\t\t    yesno(intel_dp->can_mst), yesno(sink_can_mst),\n\t\t    yesno(i915->params.enable_dp_mst));\n\n\tif (!intel_dp->can_mst)\n\t\treturn;\n\n\tintel_dp->is_mst = sink_can_mst &&\n\t\ti915->params.enable_dp_mst;\n\n\tdrm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr,\n\t\t\t\t\tintel_dp->is_mst);\n}\n\nstatic bool\nintel_dp_get_sink_irq_esi(struct intel_dp *intel_dp, u8 *sink_irq_vector)\n{\n\treturn drm_dp_dpcd_read(&intel_dp->aux, DP_SINK_COUNT_ESI,\n\t\t\t\tsink_irq_vector, DP_DPRX_ESI_LEN) ==\n\t\tDP_DPRX_ESI_LEN;\n}\n\nbool\nintel_dp_needs_vsc_sdp(const struct intel_crtc_state *crtc_state,\n\t\t       const struct drm_connector_state *conn_state)\n{\n\t/*\n\t * As per DP 1.4a spec section 2.2.4.3 [MSA Field for Indication\n\t * of Color Encoding Format and Content Color Gamut], in order to\n\t * sending YCBCR 420 or HDR BT.2020 signals we should use DP VSC SDP.\n\t */\n\tif (crtc_state->output_format == INTEL_OUTPUT_FORMAT_YCBCR420)\n\t\treturn true;\n\n\tswitch (conn_state->colorspace) {\n\tcase DRM_MODE_COLORIMETRY_SYCC_601:\n\tcase DRM_MODE_COLORIMETRY_OPYCC_601:\n\tcase DRM_MODE_COLORIMETRY_BT2020_YCC:\n\tcase DRM_MODE_COLORIMETRY_BT2020_RGB:\n\tcase DRM_MODE_COLORIMETRY_BT2020_CYCC:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic ssize_t intel_dp_vsc_sdp_pack(const struct drm_dp_vsc_sdp *vsc,\n\t\t\t\t     struct dp_sdp *sdp, size_t size)\n{\n\tsize_t length = sizeof(struct dp_sdp);\n\n\tif (size < length)\n\t\treturn -ENOSPC;\n\n\tmemset(sdp, 0, size);\n\n\t/*\n\t * Prepare VSC Header for SU as per DP 1.4a spec, Table 2-119\n\t * VSC SDP Header Bytes\n\t */\n\tsdp->sdp_header.HB0 = 0; /* Secondary-Data Packet ID = 0 */\n\tsdp->sdp_header.HB1 = vsc->sdp_type; /* Secondary-data Packet Type */\n\tsdp->sdp_header.HB2 = vsc->revision; /* Revision Number */\n\tsdp->sdp_header.HB3 = vsc->length; /* Number of Valid Data Bytes */\n\n\t/*\n\t * Only revision 0x5 supports Pixel Encoding/Colorimetry Format as\n\t * per DP 1.4a spec.\n\t */\n\tif (vsc->revision != 0x5)\n\t\tgoto out;\n\n\t/* VSC SDP Payload for DB16 through DB18 */\n\t/* Pixel Encoding and Colorimetry Formats  */\n\tsdp->db[16] = (vsc->pixelformat & 0xf) << 4; /* DB16[7:4] */\n\tsdp->db[16] |= vsc->colorimetry & 0xf; /* DB16[3:0] */\n\n\tswitch (vsc->bpc) {\n\tcase 6:\n\t\t/* 6bpc: 0x0 */\n\t\tbreak;\n\tcase 8:\n\t\tsdp->db[17] = 0x1; /* DB17[3:0] */\n\t\tbreak;\n\tcase 10:\n\t\tsdp->db[17] = 0x2;\n\t\tbreak;\n\tcase 12:\n\t\tsdp->db[17] = 0x3;\n\t\tbreak;\n\tcase 16:\n\t\tsdp->db[17] = 0x4;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(vsc->bpc);\n\t\tbreak;\n\t}\n\t/* Dynamic Range and Component Bit Depth */\n\tif (vsc->dynamic_range == DP_DYNAMIC_RANGE_CTA)\n\t\tsdp->db[17] |= 0x80;  /* DB17[7] */\n\n\t/* Content Type */\n\tsdp->db[18] = vsc->content_type & 0x7;\n\nout:\n\treturn length;\n}\n\nstatic ssize_t\nintel_dp_hdr_metadata_infoframe_sdp_pack(const struct hdmi_drm_infoframe *drm_infoframe,\n\t\t\t\t\t struct dp_sdp *sdp,\n\t\t\t\t\t size_t size)\n{\n\tsize_t length = sizeof(struct dp_sdp);\n\tconst int infoframe_size = HDMI_INFOFRAME_HEADER_SIZE + HDMI_DRM_INFOFRAME_SIZE;\n\tunsigned char buf[HDMI_INFOFRAME_HEADER_SIZE + HDMI_DRM_INFOFRAME_SIZE];\n\tssize_t len;\n\n\tif (size < length)\n\t\treturn -ENOSPC;\n\n\tmemset(sdp, 0, size);\n\n\tlen = hdmi_drm_infoframe_pack_only(drm_infoframe, buf, sizeof(buf));\n\tif (len < 0) {\n\t\tDRM_DEBUG_KMS(\"buffer size is smaller than hdr metadata infoframe\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (len != infoframe_size) {\n\t\tDRM_DEBUG_KMS(\"wrong static hdr metadata size\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\t/*\n\t * Set up the infoframe sdp packet for HDR static metadata.\n\t * Prepare VSC Header for SU as per DP 1.4a spec,\n\t * Table 2-100 and Table 2-101\n\t */\n\n\t/* Secondary-Data Packet ID, 00h for non-Audio INFOFRAME */\n\tsdp->sdp_header.HB0 = 0;\n\t/*\n\t * Packet Type 80h + Non-audio INFOFRAME Type value\n\t * HDMI_INFOFRAME_TYPE_DRM: 0x87\n\t * - 80h + Non-audio INFOFRAME Type value\n\t * - InfoFrame Type: 0x07\n\t *    [CTA-861-G Table-42 Dynamic Range and Mastering InfoFrame]\n\t */\n\tsdp->sdp_header.HB1 = drm_infoframe->type;\n\t/*\n\t * Least Significant Eight Bits of (Data Byte Count \u2013 1)\n\t * infoframe_size - 1\n\t */\n\tsdp->sdp_header.HB2 = 0x1D;\n\t/* INFOFRAME SDP Version Number */\n\tsdp->sdp_header.HB3 = (0x13 << 2);\n\t/* CTA Header Byte 2 (INFOFRAME Version Number) */\n\tsdp->db[0] = drm_infoframe->version;\n\t/* CTA Header Byte 3 (Length of INFOFRAME): HDMI_DRM_INFOFRAME_SIZE */\n\tsdp->db[1] = drm_infoframe->length;\n\t/*\n\t * Copy HDMI_DRM_INFOFRAME_SIZE size from a buffer after\n\t * HDMI_INFOFRAME_HEADER_SIZE\n\t */\n\tBUILD_BUG_ON(sizeof(sdp->db) < HDMI_DRM_INFOFRAME_SIZE + 2);\n\tmemcpy(&sdp->db[2], &buf[HDMI_INFOFRAME_HEADER_SIZE],\n\t       HDMI_DRM_INFOFRAME_SIZE);\n\n\t/*\n\t * Size of DP infoframe sdp packet for HDR static metadata consists of\n\t * - DP SDP Header(struct dp_sdp_header): 4 bytes\n\t * - Two Data Blocks: 2 bytes\n\t *    CTA Header Byte2 (INFOFRAME Version Number)\n\t *    CTA Header Byte3 (Length of INFOFRAME)\n\t * - HDMI_DRM_INFOFRAME_SIZE: 26 bytes\n\t *\n\t * Prior to GEN11's GMP register size is identical to DP HDR static metadata\n\t * infoframe size. But GEN11+ has larger than that size, write_infoframe\n\t * will pad rest of the size.\n\t */\n\treturn sizeof(struct dp_sdp_header) + 2 + HDMI_DRM_INFOFRAME_SIZE;\n}\n\nstatic void intel_write_dp_sdp(struct intel_encoder *encoder,\n\t\t\t       const struct intel_crtc_state *crtc_state,\n\t\t\t       unsigned int type)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct dp_sdp sdp = {};\n\tssize_t len;\n\n\tif ((crtc_state->infoframes.enable &\n\t     intel_hdmi_infoframe_enable(type)) == 0)\n\t\treturn;\n\n\tswitch (type) {\n\tcase DP_SDP_VSC:\n\t\tlen = intel_dp_vsc_sdp_pack(&crtc_state->infoframes.vsc, &sdp,\n\t\t\t\t\t    sizeof(sdp));\n\t\tbreak;\n\tcase HDMI_PACKET_TYPE_GAMUT_METADATA:\n\t\tlen = intel_dp_hdr_metadata_infoframe_sdp_pack(&crtc_state->infoframes.drm.drm,\n\t\t\t\t\t\t\t       &sdp, sizeof(sdp));\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(type);\n\t\treturn;\n\t}\n\n\tif (drm_WARN_ON(&dev_priv->drm, len < 0))\n\t\treturn;\n\n\tdig_port->write_infoframe(encoder, crtc_state, type, &sdp, len);\n}\n\nvoid intel_write_dp_vsc_sdp(struct intel_encoder *encoder,\n\t\t\t    const struct intel_crtc_state *crtc_state,\n\t\t\t    struct drm_dp_vsc_sdp *vsc)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct dp_sdp sdp = {};\n\tssize_t len;\n\n\tlen = intel_dp_vsc_sdp_pack(vsc, &sdp, sizeof(sdp));\n\n\tif (drm_WARN_ON(&dev_priv->drm, len < 0))\n\t\treturn;\n\n\tdig_port->write_infoframe(encoder, crtc_state, DP_SDP_VSC,\n\t\t\t\t\t&sdp, len);\n}\n\nvoid intel_dp_set_infoframes(struct intel_encoder *encoder,\n\t\t\t     bool enable,\n\t\t\t     const struct intel_crtc_state *crtc_state,\n\t\t\t     const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\ti915_reg_t reg = HSW_TVIDEO_DIP_CTL(crtc_state->cpu_transcoder);\n\tu32 dip_enable = VIDEO_DIP_ENABLE_AVI_HSW | VIDEO_DIP_ENABLE_GCP_HSW |\n\t\t\t VIDEO_DIP_ENABLE_VS_HSW | VIDEO_DIP_ENABLE_GMP_HSW |\n\t\t\t VIDEO_DIP_ENABLE_SPD_HSW | VIDEO_DIP_ENABLE_DRM_GLK;\n\tu32 val = intel_de_read(dev_priv, reg);\n\n\t/* TODO: Add DSC case (DIP_ENABLE_PPS) */\n\t/* When PSR is enabled, this routine doesn't disable VSC DIP */\n\tif (intel_psr_enabled(intel_dp))\n\t\tval &= ~dip_enable;\n\telse\n\t\tval &= ~(dip_enable | VIDEO_DIP_ENABLE_VSC_HSW);\n\n\tif (!enable) {\n\t\tintel_de_write(dev_priv, reg, val);\n\t\tintel_de_posting_read(dev_priv, reg);\n\t\treturn;\n\t}\n\n\tintel_de_write(dev_priv, reg, val);\n\tintel_de_posting_read(dev_priv, reg);\n\n\t/* When PSR is enabled, VSC SDP is handled by PSR routine */\n\tif (!intel_psr_enabled(intel_dp))\n\t\tintel_write_dp_sdp(encoder, crtc_state, DP_SDP_VSC);\n\n\tintel_write_dp_sdp(encoder, crtc_state, HDMI_PACKET_TYPE_GAMUT_METADATA);\n}\n\nstatic int intel_dp_vsc_sdp_unpack(struct drm_dp_vsc_sdp *vsc,\n\t\t\t\t   const void *buffer, size_t size)\n{\n\tconst struct dp_sdp *sdp = buffer;\n\n\tif (size < sizeof(struct dp_sdp))\n\t\treturn -EINVAL;\n\n\tmemset(vsc, 0, size);\n\n\tif (sdp->sdp_header.HB0 != 0)\n\t\treturn -EINVAL;\n\n\tif (sdp->sdp_header.HB1 != DP_SDP_VSC)\n\t\treturn -EINVAL;\n\n\tvsc->sdp_type = sdp->sdp_header.HB1;\n\tvsc->revision = sdp->sdp_header.HB2;\n\tvsc->length = sdp->sdp_header.HB3;\n\n\tif ((sdp->sdp_header.HB2 == 0x2 && sdp->sdp_header.HB3 == 0x8) ||\n\t    (sdp->sdp_header.HB2 == 0x4 && sdp->sdp_header.HB3 == 0xe)) {\n\t\t/*\n\t\t * - HB2 = 0x2, HB3 = 0x8\n\t\t *   VSC SDP supporting 3D stereo + PSR\n\t\t * - HB2 = 0x4, HB3 = 0xe\n\t\t *   VSC SDP supporting 3D stereo + PSR2 with Y-coordinate of\n\t\t *   first scan line of the SU region (applies to eDP v1.4b\n\t\t *   and higher).\n\t\t */\n\t\treturn 0;\n\t} else if (sdp->sdp_header.HB2 == 0x5 && sdp->sdp_header.HB3 == 0x13) {\n\t\t/*\n\t\t * - HB2 = 0x5, HB3 = 0x13\n\t\t *   VSC SDP supporting 3D stereo + PSR2 + Pixel Encoding/Colorimetry\n\t\t *   Format.\n\t\t */\n\t\tvsc->pixelformat = (sdp->db[16] >> 4) & 0xf;\n\t\tvsc->colorimetry = sdp->db[16] & 0xf;\n\t\tvsc->dynamic_range = (sdp->db[17] >> 7) & 0x1;\n\n\t\tswitch (sdp->db[17] & 0x7) {\n\t\tcase 0x0:\n\t\t\tvsc->bpc = 6;\n\t\t\tbreak;\n\t\tcase 0x1:\n\t\t\tvsc->bpc = 8;\n\t\t\tbreak;\n\t\tcase 0x2:\n\t\t\tvsc->bpc = 10;\n\t\t\tbreak;\n\t\tcase 0x3:\n\t\t\tvsc->bpc = 12;\n\t\t\tbreak;\n\t\tcase 0x4:\n\t\t\tvsc->bpc = 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(sdp->db[17] & 0x7);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvsc->content_type = sdp->db[18] & 0x7;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nintel_dp_hdr_metadata_infoframe_sdp_unpack(struct hdmi_drm_infoframe *drm_infoframe,\n\t\t\t\t\t   const void *buffer, size_t size)\n{\n\tint ret;\n\n\tconst struct dp_sdp *sdp = buffer;\n\n\tif (size < sizeof(struct dp_sdp))\n\t\treturn -EINVAL;\n\n\tif (sdp->sdp_header.HB0 != 0)\n\t\treturn -EINVAL;\n\n\tif (sdp->sdp_header.HB1 != HDMI_INFOFRAME_TYPE_DRM)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Least Significant Eight Bits of (Data Byte Count \u2013 1)\n\t * 1Dh (i.e., Data Byte Count = 30 bytes).\n\t */\n\tif (sdp->sdp_header.HB2 != 0x1D)\n\t\treturn -EINVAL;\n\n\t/* Most Significant Two Bits of (Data Byte Count \u2013 1), Clear to 00b. */\n\tif ((sdp->sdp_header.HB3 & 0x3) != 0)\n\t\treturn -EINVAL;\n\n\t/* INFOFRAME SDP Version Number */\n\tif (((sdp->sdp_header.HB3 >> 2) & 0x3f) != 0x13)\n\t\treturn -EINVAL;\n\n\t/* CTA Header Byte 2 (INFOFRAME Version Number) */\n\tif (sdp->db[0] != 1)\n\t\treturn -EINVAL;\n\n\t/* CTA Header Byte 3 (Length of INFOFRAME): HDMI_DRM_INFOFRAME_SIZE */\n\tif (sdp->db[1] != HDMI_DRM_INFOFRAME_SIZE)\n\t\treturn -EINVAL;\n\n\tret = hdmi_drm_infoframe_unpack_only(drm_infoframe, &sdp->db[2],\n\t\t\t\t\t     HDMI_DRM_INFOFRAME_SIZE);\n\n\treturn ret;\n}\n\nstatic void intel_read_dp_vsc_sdp(struct intel_encoder *encoder,\n\t\t\t\t  struct intel_crtc_state *crtc_state,\n\t\t\t\t  struct drm_dp_vsc_sdp *vsc)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tunsigned int type = DP_SDP_VSC;\n\tstruct dp_sdp sdp = {};\n\tint ret;\n\n\t/* When PSR is enabled, VSC SDP is handled by PSR routine */\n\tif (intel_psr_enabled(intel_dp))\n\t\treturn;\n\n\tif ((crtc_state->infoframes.enable &\n\t     intel_hdmi_infoframe_enable(type)) == 0)\n\t\treturn;\n\n\tdig_port->read_infoframe(encoder, crtc_state, type, &sdp, sizeof(sdp));\n\n\tret = intel_dp_vsc_sdp_unpack(vsc, &sdp, sizeof(sdp));\n\n\tif (ret)\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Failed to unpack DP VSC SDP\\n\");\n}\n\nstatic void intel_read_dp_hdr_metadata_infoframe_sdp(struct intel_encoder *encoder,\n\t\t\t\t\t\t     struct intel_crtc_state *crtc_state,\n\t\t\t\t\t\t     struct hdmi_drm_infoframe *drm_infoframe)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tunsigned int type = HDMI_PACKET_TYPE_GAMUT_METADATA;\n\tstruct dp_sdp sdp = {};\n\tint ret;\n\n\tif ((crtc_state->infoframes.enable &\n\t    intel_hdmi_infoframe_enable(type)) == 0)\n\t\treturn;\n\n\tdig_port->read_infoframe(encoder, crtc_state, type, &sdp,\n\t\t\t\t sizeof(sdp));\n\n\tret = intel_dp_hdr_metadata_infoframe_sdp_unpack(drm_infoframe, &sdp,\n\t\t\t\t\t\t\t sizeof(sdp));\n\n\tif (ret)\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Failed to unpack DP HDR Metadata Infoframe SDP\\n\");\n}\n\nvoid intel_read_dp_sdp(struct intel_encoder *encoder,\n\t\t       struct intel_crtc_state *crtc_state,\n\t\t       unsigned int type)\n{\n\tif (encoder->type != INTEL_OUTPUT_DDI)\n\t\treturn;\n\n\tswitch (type) {\n\tcase DP_SDP_VSC:\n\t\tintel_read_dp_vsc_sdp(encoder, crtc_state,\n\t\t\t\t      &crtc_state->infoframes.vsc);\n\t\tbreak;\n\tcase HDMI_PACKET_TYPE_GAMUT_METADATA:\n\t\tintel_read_dp_hdr_metadata_infoframe_sdp(encoder, crtc_state,\n\t\t\t\t\t\t\t &crtc_state->infoframes.drm.drm);\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(type);\n\t\tbreak;\n\t}\n}\n\nstatic u8 intel_dp_autotest_link_training(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tint status = 0;\n\tint test_link_rate;\n\tu8 test_lane_count, test_link_bw;\n\t/* (DP CTS 1.2)\n\t * 4.3.1.11\n\t */\n\t/* Read the TEST_LANE_COUNT and TEST_LINK_RTAE fields (DP CTS 3.1.4) */\n\tstatus = drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_LANE_COUNT,\n\t\t\t\t   &test_lane_count);\n\n\tif (status <= 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"Lane count read failed\\n\");\n\t\treturn DP_TEST_NAK;\n\t}\n\ttest_lane_count &= DP_MAX_LANE_COUNT_MASK;\n\n\tstatus = drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_LINK_RATE,\n\t\t\t\t   &test_link_bw);\n\tif (status <= 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"Link Rate read failed\\n\");\n\t\treturn DP_TEST_NAK;\n\t}\n\ttest_link_rate = drm_dp_bw_code_to_link_rate(test_link_bw);\n\n\t/* Validate the requested link rate and lane count */\n\tif (!intel_dp_link_params_valid(intel_dp, test_link_rate,\n\t\t\t\t\ttest_lane_count))\n\t\treturn DP_TEST_NAK;\n\n\tintel_dp->compliance.test_lane_count = test_lane_count;\n\tintel_dp->compliance.test_link_rate = test_link_rate;\n\n\treturn DP_TEST_ACK;\n}\n\nstatic u8 intel_dp_autotest_video_pattern(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 test_pattern;\n\tu8 test_misc;\n\t__be16 h_width, v_height;\n\tint status = 0;\n\n\t/* Read the TEST_PATTERN (DP CTS 3.1.5) */\n\tstatus = drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_PATTERN,\n\t\t\t\t   &test_pattern);\n\tif (status <= 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"Test pattern read failed\\n\");\n\t\treturn DP_TEST_NAK;\n\t}\n\tif (test_pattern != DP_COLOR_RAMP)\n\t\treturn DP_TEST_NAK;\n\n\tstatus = drm_dp_dpcd_read(&intel_dp->aux, DP_TEST_H_WIDTH_HI,\n\t\t\t\t  &h_width, 2);\n\tif (status <= 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"H Width read failed\\n\");\n\t\treturn DP_TEST_NAK;\n\t}\n\n\tstatus = drm_dp_dpcd_read(&intel_dp->aux, DP_TEST_V_HEIGHT_HI,\n\t\t\t\t  &v_height, 2);\n\tif (status <= 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"V Height read failed\\n\");\n\t\treturn DP_TEST_NAK;\n\t}\n\n\tstatus = drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_MISC0,\n\t\t\t\t   &test_misc);\n\tif (status <= 0) {\n\t\tdrm_dbg_kms(&i915->drm, \"TEST MISC read failed\\n\");\n\t\treturn DP_TEST_NAK;\n\t}\n\tif ((test_misc & DP_TEST_COLOR_FORMAT_MASK) != DP_COLOR_FORMAT_RGB)\n\t\treturn DP_TEST_NAK;\n\tif (test_misc & DP_TEST_DYNAMIC_RANGE_CEA)\n\t\treturn DP_TEST_NAK;\n\tswitch (test_misc & DP_TEST_BIT_DEPTH_MASK) {\n\tcase DP_TEST_BIT_DEPTH_6:\n\t\tintel_dp->compliance.test_data.bpc = 6;\n\t\tbreak;\n\tcase DP_TEST_BIT_DEPTH_8:\n\t\tintel_dp->compliance.test_data.bpc = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn DP_TEST_NAK;\n\t}\n\n\tintel_dp->compliance.test_data.video_pattern = test_pattern;\n\tintel_dp->compliance.test_data.hdisplay = be16_to_cpu(h_width);\n\tintel_dp->compliance.test_data.vdisplay = be16_to_cpu(v_height);\n\t/* Set test active flag here so userspace doesn't interrupt things */\n\tintel_dp->compliance.test_active = true;\n\n\treturn DP_TEST_ACK;\n}\n\nstatic u8 intel_dp_autotest_edid(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 test_result = DP_TEST_ACK;\n\tstruct intel_connector *intel_connector = intel_dp->attached_connector;\n\tstruct drm_connector *connector = &intel_connector->base;\n\n\tif (intel_connector->detect_edid == NULL ||\n\t    connector->edid_corrupt ||\n\t    intel_dp->aux.i2c_defer_count > 6) {\n\t\t/* Check EDID read for NACKs, DEFERs and corruption\n\t\t * (DP CTS 1.2 Core r1.1)\n\t\t *    4.2.2.4 : Failed EDID read, I2C_NAK\n\t\t *    4.2.2.5 : Failed EDID read, I2C_DEFER\n\t\t *    4.2.2.6 : EDID corruption detected\n\t\t * Use failsafe mode for all cases\n\t\t */\n\t\tif (intel_dp->aux.i2c_nack_count > 0 ||\n\t\t\tintel_dp->aux.i2c_defer_count > 0)\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"EDID read had %d NACKs, %d DEFERs\\n\",\n\t\t\t\t    intel_dp->aux.i2c_nack_count,\n\t\t\t\t    intel_dp->aux.i2c_defer_count);\n\t\tintel_dp->compliance.test_data.edid = INTEL_DP_RESOLUTION_FAILSAFE;\n\t} else {\n\t\tstruct edid *block = intel_connector->detect_edid;\n\n\t\t/* We have to write the checksum\n\t\t * of the last block read\n\t\t */\n\t\tblock += intel_connector->detect_edid->extensions;\n\n\t\tif (drm_dp_dpcd_writeb(&intel_dp->aux, DP_TEST_EDID_CHECKSUM,\n\t\t\t\t       block->checksum) <= 0)\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"Failed to write EDID checksum\\n\");\n\n\t\ttest_result = DP_TEST_ACK | DP_TEST_EDID_CHECKSUM_WRITE;\n\t\tintel_dp->compliance.test_data.edid = INTEL_DP_RESOLUTION_PREFERRED;\n\t}\n\n\t/* Set test active flag here so userspace doesn't interrupt things */\n\tintel_dp->compliance.test_active = true;\n\n\treturn test_result;\n}\n\nstatic void intel_dp_phy_pattern_update(struct intel_dp *intel_dp,\n\t\t\t\t\tconst struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\t\tto_i915(dp_to_dig_port(intel_dp)->base.base.dev);\n\tstruct drm_dp_phy_test_params *data =\n\t\t\t&intel_dp->compliance.test_data.phytest;\n\tstruct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum pipe pipe = crtc->pipe;\n\tu32 pattern_val;\n\n\tswitch (data->phy_pattern) {\n\tcase DP_PHY_TEST_PATTERN_NONE:\n\t\tDRM_DEBUG_KMS(\"Disable Phy Test Pattern\\n\");\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_CTL(pipe), 0x0);\n\t\tbreak;\n\tcase DP_PHY_TEST_PATTERN_D10_2:\n\t\tDRM_DEBUG_KMS(\"Set D10.2 Phy Test Pattern\\n\");\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_CTL(pipe),\n\t\t\t       DDI_DP_COMP_CTL_ENABLE | DDI_DP_COMP_CTL_D10_2);\n\t\tbreak;\n\tcase DP_PHY_TEST_PATTERN_ERROR_COUNT:\n\t\tDRM_DEBUG_KMS(\"Set Error Count Phy Test Pattern\\n\");\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_CTL(pipe),\n\t\t\t       DDI_DP_COMP_CTL_ENABLE |\n\t\t\t       DDI_DP_COMP_CTL_SCRAMBLED_0);\n\t\tbreak;\n\tcase DP_PHY_TEST_PATTERN_PRBS7:\n\t\tDRM_DEBUG_KMS(\"Set PRBS7 Phy Test Pattern\\n\");\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_CTL(pipe),\n\t\t\t       DDI_DP_COMP_CTL_ENABLE | DDI_DP_COMP_CTL_PRBS7);\n\t\tbreak;\n\tcase DP_PHY_TEST_PATTERN_80BIT_CUSTOM:\n\t\t/*\n\t\t * FIXME: Ideally pattern should come from DPCD 0x250. As\n\t\t * current firmware of DPR-100 could not set it, so hardcoding\n\t\t * now for complaince test.\n\t\t */\n\t\tDRM_DEBUG_KMS(\"Set 80Bit Custom Phy Test Pattern 0x3e0f83e0 0x0f83e0f8 0x0000f83e\\n\");\n\t\tpattern_val = 0x3e0f83e0;\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_PAT(pipe, 0), pattern_val);\n\t\tpattern_val = 0x0f83e0f8;\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_PAT(pipe, 1), pattern_val);\n\t\tpattern_val = 0x0000f83e;\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_PAT(pipe, 2), pattern_val);\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_CTL(pipe),\n\t\t\t       DDI_DP_COMP_CTL_ENABLE |\n\t\t\t       DDI_DP_COMP_CTL_CUSTOM80);\n\t\tbreak;\n\tcase DP_PHY_TEST_PATTERN_CP2520:\n\t\t/*\n\t\t * FIXME: Ideally pattern should come from DPCD 0x24A. As\n\t\t * current firmware of DPR-100 could not set it, so hardcoding\n\t\t * now for complaince test.\n\t\t */\n\t\tDRM_DEBUG_KMS(\"Set HBR2 compliance Phy Test Pattern\\n\");\n\t\tpattern_val = 0xFB;\n\t\tintel_de_write(dev_priv, DDI_DP_COMP_CTL(pipe),\n\t\t\t       DDI_DP_COMP_CTL_ENABLE | DDI_DP_COMP_CTL_HBR2 |\n\t\t\t       pattern_val);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Invalid Phy Test Pattern\\n\");\n\t}\n}\n\nstatic void\nintel_dp_autotest_phy_ddi_disable(struct intel_dp *intel_dp,\n\t\t\t\t  const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_device *dev = dig_port->base.base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tstruct intel_crtc *crtc = to_intel_crtc(dig_port->base.base.crtc);\n\tenum pipe pipe = crtc->pipe;\n\tu32 trans_ddi_func_ctl_value, trans_conf_value, dp_tp_ctl_value;\n\n\ttrans_ddi_func_ctl_value = intel_de_read(dev_priv,\n\t\t\t\t\t\t TRANS_DDI_FUNC_CTL(pipe));\n\ttrans_conf_value = intel_de_read(dev_priv, PIPECONF(pipe));\n\tdp_tp_ctl_value = intel_de_read(dev_priv, TGL_DP_TP_CTL(pipe));\n\n\ttrans_ddi_func_ctl_value &= ~(TRANS_DDI_FUNC_ENABLE |\n\t\t\t\t      TGL_TRANS_DDI_PORT_MASK);\n\ttrans_conf_value &= ~PIPECONF_ENABLE;\n\tdp_tp_ctl_value &= ~DP_TP_CTL_ENABLE;\n\n\tintel_de_write(dev_priv, PIPECONF(pipe), trans_conf_value);\n\tintel_de_write(dev_priv, TRANS_DDI_FUNC_CTL(pipe),\n\t\t       trans_ddi_func_ctl_value);\n\tintel_de_write(dev_priv, TGL_DP_TP_CTL(pipe), dp_tp_ctl_value);\n}\n\nstatic void\nintel_dp_autotest_phy_ddi_enable(struct intel_dp *intel_dp,\n\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct drm_device *dev = dig_port->base.base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum port port = dig_port->base.port;\n\tstruct intel_crtc *crtc = to_intel_crtc(dig_port->base.base.crtc);\n\tenum pipe pipe = crtc->pipe;\n\tu32 trans_ddi_func_ctl_value, trans_conf_value, dp_tp_ctl_value;\n\n\ttrans_ddi_func_ctl_value = intel_de_read(dev_priv,\n\t\t\t\t\t\t TRANS_DDI_FUNC_CTL(pipe));\n\ttrans_conf_value = intel_de_read(dev_priv, PIPECONF(pipe));\n\tdp_tp_ctl_value = intel_de_read(dev_priv, TGL_DP_TP_CTL(pipe));\n\n\ttrans_ddi_func_ctl_value |= TRANS_DDI_FUNC_ENABLE |\n\t\t\t\t    TGL_TRANS_DDI_SELECT_PORT(port);\n\ttrans_conf_value |= PIPECONF_ENABLE;\n\tdp_tp_ctl_value |= DP_TP_CTL_ENABLE;\n\n\tintel_de_write(dev_priv, PIPECONF(pipe), trans_conf_value);\n\tintel_de_write(dev_priv, TGL_DP_TP_CTL(pipe), dp_tp_ctl_value);\n\tintel_de_write(dev_priv, TRANS_DDI_FUNC_CTL(pipe),\n\t\t       trans_ddi_func_ctl_value);\n}\n\nstatic void intel_dp_process_phy_request(struct intel_dp *intel_dp,\n\t\t\t\t\t const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_dp_phy_test_params *data =\n\t\t&intel_dp->compliance.test_data.phytest;\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\n\tif (drm_dp_dpcd_read_phy_link_status(&intel_dp->aux, DP_PHY_DPRX,\n\t\t\t\t\t     link_status) < 0) {\n\t\tDRM_DEBUG_KMS(\"failed to get link status\\n\");\n\t\treturn;\n\t}\n\n\t/* retrieve vswing & pre-emphasis setting */\n\tintel_dp_get_adjust_train(intel_dp, crtc_state, DP_PHY_DPRX,\n\t\t\t\t  link_status);\n\n\tintel_dp_autotest_phy_ddi_disable(intel_dp, crtc_state);\n\n\tintel_dp_set_signal_levels(intel_dp, crtc_state);\n\n\tintel_dp_phy_pattern_update(intel_dp, crtc_state);\n\n\tintel_dp_autotest_phy_ddi_enable(intel_dp, crtc_state);\n\n\tdrm_dp_set_phy_test_pattern(&intel_dp->aux, data,\n\t\t\t\t    link_status[DP_DPCD_REV]);\n}\n\nstatic u8 intel_dp_autotest_phy_pattern(struct intel_dp *intel_dp)\n{\n\tstruct drm_dp_phy_test_params *data =\n\t\t&intel_dp->compliance.test_data.phytest;\n\n\tif (drm_dp_get_phy_test_pattern(&intel_dp->aux, data)) {\n\t\tDRM_DEBUG_KMS(\"DP Phy Test pattern AUX read failure\\n\");\n\t\treturn DP_TEST_NAK;\n\t}\n\n\t/* Set test active flag here so userspace doesn't interrupt things */\n\tintel_dp->compliance.test_active = true;\n\n\treturn DP_TEST_ACK;\n}\n\nstatic void intel_dp_handle_test_request(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 response = DP_TEST_NAK;\n\tu8 request = 0;\n\tint status;\n\n\tstatus = drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_REQUEST, &request);\n\tif (status <= 0) {\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Could not read test request from sink\\n\");\n\t\tgoto update_status;\n\t}\n\n\tswitch (request) {\n\tcase DP_TEST_LINK_TRAINING:\n\t\tdrm_dbg_kms(&i915->drm, \"LINK_TRAINING test requested\\n\");\n\t\tresponse = intel_dp_autotest_link_training(intel_dp);\n\t\tbreak;\n\tcase DP_TEST_LINK_VIDEO_PATTERN:\n\t\tdrm_dbg_kms(&i915->drm, \"TEST_PATTERN test requested\\n\");\n\t\tresponse = intel_dp_autotest_video_pattern(intel_dp);\n\t\tbreak;\n\tcase DP_TEST_LINK_EDID_READ:\n\t\tdrm_dbg_kms(&i915->drm, \"EDID test requested\\n\");\n\t\tresponse = intel_dp_autotest_edid(intel_dp);\n\t\tbreak;\n\tcase DP_TEST_LINK_PHY_TEST_PATTERN:\n\t\tdrm_dbg_kms(&i915->drm, \"PHY_PATTERN test requested\\n\");\n\t\tresponse = intel_dp_autotest_phy_pattern(intel_dp);\n\t\tbreak;\n\tdefault:\n\t\tdrm_dbg_kms(&i915->drm, \"Invalid test request '%02x'\\n\",\n\t\t\t    request);\n\t\tbreak;\n\t}\n\n\tif (response & DP_TEST_ACK)\n\t\tintel_dp->compliance.test_type = request;\n\nupdate_status:\n\tstatus = drm_dp_dpcd_writeb(&intel_dp->aux, DP_TEST_RESPONSE, response);\n\tif (status <= 0)\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"Could not write test response to sink\\n\");\n}\n\n/**\n * intel_dp_check_mst_status - service any pending MST interrupts, check link status\n * @intel_dp: Intel DP struct\n *\n * Read any pending MST interrupts, call MST core to handle these and ack the\n * interrupts. Check if the main and AUX link state is ok.\n *\n * Returns:\n * - %true if pending interrupts were serviced (or no interrupts were\n *   pending) w/o detecting an error condition.\n * - %false if an error condition - like AUX failure or a loss of link - is\n *   detected, which needs servicing from the hotplug work.\n */\nstatic bool\nintel_dp_check_mst_status(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tbool link_ok = true;\n\n\tdrm_WARN_ON_ONCE(&i915->drm, intel_dp->active_mst_links < 0);\n\n\tfor (;;) {\n\t\tu8 esi[DP_DPRX_ESI_LEN] = {};\n\t\tbool handled;\n\t\tint retry;\n\n\t\tif (!intel_dp_get_sink_irq_esi(intel_dp, esi)) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"failed to get ESI - device may have failed\\n\");\n\t\t\tlink_ok = false;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check link status - esi[10] = 0x200c */\n\t\tif (intel_dp->active_mst_links > 0 && link_ok &&\n\t\t    !drm_dp_channel_eq_ok(&esi[10], intel_dp->lane_count)) {\n\t\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t\t    \"channel EQ not ok, retraining\\n\");\n\t\t\tlink_ok = false;\n\t\t}\n\n\t\tdrm_dbg_kms(&i915->drm, \"got esi %3ph\\n\", esi);\n\n\t\tdrm_dp_mst_hpd_irq(&intel_dp->mst_mgr, esi, &handled);\n\t\tif (!handled)\n\t\t\tbreak;\n\n\t\tfor (retry = 0; retry < 3; retry++) {\n\t\t\tint wret;\n\n\t\t\twret = drm_dp_dpcd_write(&intel_dp->aux,\n\t\t\t\t\t\t DP_SINK_COUNT_ESI+1,\n\t\t\t\t\t\t &esi[1], 3);\n\t\t\tif (wret == 3)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn link_ok;\n}\n\nstatic bool\nintel_dp_needs_link_retrain(struct intel_dp *intel_dp)\n{\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\n\tif (!intel_dp->link_trained)\n\t\treturn false;\n\n\t/*\n\t * While PSR source HW is enabled, it will control main-link sending\n\t * frames, enabling and disabling it so trying to do a retrain will fail\n\t * as the link would or not be on or it could mix training patterns\n\t * and frame data at the same time causing retrain to fail.\n\t * Also when exiting PSR, HW will retrain the link anyways fixing\n\t * any link status error.\n\t */\n\tif (intel_psr_enabled(intel_dp))\n\t\treturn false;\n\n\tif (drm_dp_dpcd_read_phy_link_status(&intel_dp->aux, DP_PHY_DPRX,\n\t\t\t\t\t     link_status) < 0)\n\t\treturn false;\n\n\t/*\n\t * Validate the cached values of intel_dp->link_rate and\n\t * intel_dp->lane_count before attempting to retrain.\n\t *\n\t * FIXME would be nice to user the crtc state here, but since\n\t * we need to call this from the short HPD handler that seems\n\t * a bit hard.\n\t */\n\tif (!intel_dp_link_params_valid(intel_dp, intel_dp->link_rate,\n\t\t\t\t\tintel_dp->lane_count))\n\t\treturn false;\n\n\t/* Retrain if Channel EQ or CR not ok */\n\treturn !drm_dp_channel_eq_ok(link_status, intel_dp->lane_count);\n}\n\nstatic bool intel_dp_has_connector(struct intel_dp *intel_dp,\n\t\t\t\t   const struct drm_connector_state *conn_state)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_encoder *encoder;\n\tenum pipe pipe;\n\n\tif (!conn_state->best_encoder)\n\t\treturn false;\n\n\t/* SST */\n\tencoder = &dp_to_dig_port(intel_dp)->base;\n\tif (conn_state->best_encoder == &encoder->base)\n\t\treturn true;\n\n\t/* MST */\n\tfor_each_pipe(i915, pipe) {\n\t\tencoder = &intel_dp->mst_encoders[pipe]->base;\n\t\tif (conn_state->best_encoder == &encoder->base)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int intel_dp_prep_link_retrain(struct intel_dp *intel_dp,\n\t\t\t\t      struct drm_modeset_acquire_ctx *ctx,\n\t\t\t\t      u32 *crtc_mask)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct intel_connector *connector;\n\tint ret = 0;\n\n\t*crtc_mask = 0;\n\n\tif (!intel_dp_needs_link_retrain(intel_dp))\n\t\treturn 0;\n\n\tdrm_connector_list_iter_begin(&i915->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tstruct drm_connector_state *conn_state =\n\t\t\tconnector->base.state;\n\t\tstruct intel_crtc_state *crtc_state;\n\t\tstruct intel_crtc *crtc;\n\n\t\tif (!intel_dp_has_connector(intel_dp, conn_state))\n\t\t\tcontinue;\n\n\t\tcrtc = to_intel_crtc(conn_state->crtc);\n\t\tif (!crtc)\n\t\t\tcontinue;\n\n\t\tret = drm_modeset_lock(&crtc->base.mutex, ctx);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tcrtc_state = to_intel_crtc_state(crtc->base.state);\n\n\t\tdrm_WARN_ON(&i915->drm, !intel_crtc_has_dp_encoder(crtc_state));\n\n\t\tif (!crtc_state->hw.active)\n\t\t\tcontinue;\n\n\t\tif (conn_state->commit &&\n\t\t    !try_wait_for_completion(&conn_state->commit->hw_done))\n\t\t\tcontinue;\n\n\t\t*crtc_mask |= drm_crtc_mask(&crtc->base);\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tif (!intel_dp_needs_link_retrain(intel_dp))\n\t\t*crtc_mask = 0;\n\n\treturn ret;\n}\n\nstatic bool intel_dp_is_connected(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\n\treturn connector->base.status == connector_status_connected ||\n\t\tintel_dp->is_mst;\n}\n\nint intel_dp_retrain_link(struct intel_encoder *encoder,\n\t\t\t  struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_crtc *crtc;\n\tu32 crtc_mask;\n\tint ret;\n\n\tif (!intel_dp_is_connected(intel_dp))\n\t\treturn 0;\n\n\tret = drm_modeset_lock(&dev_priv->drm.mode_config.connection_mutex,\n\t\t\t       ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_dp_prep_link_retrain(intel_dp, ctx, &crtc_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tif (crtc_mask == 0)\n\t\treturn 0;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[ENCODER:%d:%s] retraining link\\n\",\n\t\t    encoder->base.base.id, encoder->base.name);\n\n\tfor_each_intel_crtc_mask(&dev_priv->drm, crtc, crtc_mask) {\n\t\tconst struct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\t/* Suppress underruns caused by re-training */\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, crtc->pipe, false);\n\t\tif (crtc_state->has_pch_encoder)\n\t\t\tintel_set_pch_fifo_underrun_reporting(dev_priv,\n\t\t\t\t\t\t\t      intel_crtc_pch_transcoder(crtc), false);\n\t}\n\n\tfor_each_intel_crtc_mask(&dev_priv->drm, crtc, crtc_mask) {\n\t\tconst struct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\t/* retrain on the MST master transcoder */\n\t\tif (INTEL_GEN(dev_priv) >= 12 &&\n\t\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST) &&\n\t\t    !intel_dp_mst_is_master_trans(crtc_state))\n\t\t\tcontinue;\n\n\t\tintel_dp_start_link_train(intel_dp, crtc_state);\n\t\tintel_dp_stop_link_train(intel_dp, crtc_state);\n\t\tbreak;\n\t}\n\n\tfor_each_intel_crtc_mask(&dev_priv->drm, crtc, crtc_mask) {\n\t\tconst struct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\t/* Keep underrun reporting disabled until things are stable */\n\t\tintel_wait_for_vblank(dev_priv, crtc->pipe);\n\n\t\tintel_set_cpu_fifo_underrun_reporting(dev_priv, crtc->pipe, true);\n\t\tif (crtc_state->has_pch_encoder)\n\t\t\tintel_set_pch_fifo_underrun_reporting(dev_priv,\n\t\t\t\t\t\t\t      intel_crtc_pch_transcoder(crtc), true);\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_dp_prep_phy_test(struct intel_dp *intel_dp,\n\t\t\t\t  struct drm_modeset_acquire_ctx *ctx,\n\t\t\t\t  u32 *crtc_mask)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct intel_connector *connector;\n\tint ret = 0;\n\n\t*crtc_mask = 0;\n\n\tdrm_connector_list_iter_begin(&i915->drm, &conn_iter);\n\tfor_each_intel_connector_iter(connector, &conn_iter) {\n\t\tstruct drm_connector_state *conn_state =\n\t\t\tconnector->base.state;\n\t\tstruct intel_crtc_state *crtc_state;\n\t\tstruct intel_crtc *crtc;\n\n\t\tif (!intel_dp_has_connector(intel_dp, conn_state))\n\t\t\tcontinue;\n\n\t\tcrtc = to_intel_crtc(conn_state->crtc);\n\t\tif (!crtc)\n\t\t\tcontinue;\n\n\t\tret = drm_modeset_lock(&crtc->base.mutex, ctx);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tcrtc_state = to_intel_crtc_state(crtc->base.state);\n\n\t\tdrm_WARN_ON(&i915->drm, !intel_crtc_has_dp_encoder(crtc_state));\n\n\t\tif (!crtc_state->hw.active)\n\t\t\tcontinue;\n\n\t\tif (conn_state->commit &&\n\t\t    !try_wait_for_completion(&conn_state->commit->hw_done))\n\t\t\tcontinue;\n\n\t\t*crtc_mask |= drm_crtc_mask(&crtc->base);\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn ret;\n}\n\nstatic int intel_dp_do_phy_test(struct intel_encoder *encoder,\n\t\t\t\tstruct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct intel_crtc *crtc;\n\tu32 crtc_mask;\n\tint ret;\n\n\tret = drm_modeset_lock(&dev_priv->drm.mode_config.connection_mutex,\n\t\t\t       ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tret = intel_dp_prep_phy_test(intel_dp, ctx, &crtc_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tif (crtc_mask == 0)\n\t\treturn 0;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[ENCODER:%d:%s] PHY test\\n\",\n\t\t    encoder->base.base.id, encoder->base.name);\n\n\tfor_each_intel_crtc_mask(&dev_priv->drm, crtc, crtc_mask) {\n\t\tconst struct intel_crtc_state *crtc_state =\n\t\t\tto_intel_crtc_state(crtc->base.state);\n\n\t\t/* test on the MST master transcoder */\n\t\tif (INTEL_GEN(dev_priv) >= 12 &&\n\t\t    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_DP_MST) &&\n\t\t    !intel_dp_mst_is_master_trans(crtc_state))\n\t\t\tcontinue;\n\n\t\tintel_dp_process_phy_request(intel_dp, crtc_state);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void intel_dp_phy_test(struct intel_encoder *encoder)\n{\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret;\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\n\tfor (;;) {\n\t\tret = intel_dp_do_phy_test(encoder, &ctx);\n\n\t\tif (ret == -EDEADLK) {\n\t\t\tdrm_modeset_backoff(&ctx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\tdrm_WARN(encoder->base.dev, ret,\n\t\t \"Acquiring modeset locks failed with %i\\n\", ret);\n}\n\n/*\n * If display is now connected check links status,\n * there has been known issues of link loss triggering\n * long pulse.\n *\n * Some sinks (eg. ASUS PB287Q) seem to perform some\n * weird HPD ping pong during modesets. So we can apparently\n * end up with HPD going low during a modeset, and then\n * going back up soon after. And once that happens we must\n * retrain the link to get a picture. That's in case no\n * userspace component reacted to intermittent HPD dip.\n */\nstatic enum intel_hotplug_state\nintel_dp_hotplug(struct intel_encoder *encoder,\n\t\t struct intel_connector *connector)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(encoder);\n\tstruct drm_modeset_acquire_ctx ctx;\n\tenum intel_hotplug_state state;\n\tint ret;\n\n\tif (intel_dp->compliance.test_active &&\n\t    intel_dp->compliance.test_type == DP_TEST_LINK_PHY_TEST_PATTERN) {\n\t\tintel_dp_phy_test(encoder);\n\t\t/* just do the PHY test and nothing else */\n\t\treturn INTEL_HOTPLUG_UNCHANGED;\n\t}\n\n\tstate = intel_encoder_hotplug(encoder, connector);\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\n\tfor (;;) {\n\t\tret = intel_dp_retrain_link(encoder, &ctx);\n\n\t\tif (ret == -EDEADLK) {\n\t\t\tdrm_modeset_backoff(&ctx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\tdrm_WARN(encoder->base.dev, ret,\n\t\t \"Acquiring modeset locks failed with %i\\n\", ret);\n\n\t/*\n\t * Keeping it consistent with intel_ddi_hotplug() and\n\t * intel_hdmi_hotplug().\n\t */\n\tif (state == INTEL_HOTPLUG_UNCHANGED && !connector->hotplug_retries)\n\t\tstate = INTEL_HOTPLUG_RETRY;\n\n\treturn state;\n}\n\nstatic void intel_dp_check_service_irq(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tu8 val;\n\n\tif (intel_dp->dpcd[DP_DPCD_REV] < 0x11)\n\t\treturn;\n\n\tif (drm_dp_dpcd_readb(&intel_dp->aux,\n\t\t\t      DP_DEVICE_SERVICE_IRQ_VECTOR, &val) != 1 || !val)\n\t\treturn;\n\n\tdrm_dp_dpcd_writeb(&intel_dp->aux, DP_DEVICE_SERVICE_IRQ_VECTOR, val);\n\n\tif (val & DP_AUTOMATED_TEST_REQUEST)\n\t\tintel_dp_handle_test_request(intel_dp);\n\n\tif (val & DP_CP_IRQ)\n\t\tintel_hdcp_handle_cp_irq(intel_dp->attached_connector);\n\n\tif (val & DP_SINK_SPECIFIC_IRQ)\n\t\tdrm_dbg_kms(&i915->drm, \"Sink specific irq unhandled\\n\");\n}\n\n/*\n * According to DP spec\n * 5.1.2:\n *  1. Read DPCD\n *  2. Configure link according to Receiver Capabilities\n *  3. Use Link Training from 2.5.3.3 and 3.5.1.3\n *  4. Check link status on receipt of hot-plug interrupt\n *\n * intel_dp_short_pulse -  handles short pulse interrupts\n * when full detection is not required.\n * Returns %true if short pulse is handled and full detection\n * is NOT required and %false otherwise.\n */\nstatic bool\nintel_dp_short_pulse(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu8 old_sink_count = intel_dp->sink_count;\n\tbool ret;\n\n\t/*\n\t * Clearing compliance test variables to allow capturing\n\t * of values for next automated test request.\n\t */\n\tmemset(&intel_dp->compliance, 0, sizeof(intel_dp->compliance));\n\n\t/*\n\t * Now read the DPCD to see if it's actually running\n\t * If the current value of sink count doesn't match with\n\t * the value that was stored earlier or dpcd read failed\n\t * we need to do full detection\n\t */\n\tret = intel_dp_get_dpcd(intel_dp);\n\n\tif ((old_sink_count != intel_dp->sink_count) || !ret) {\n\t\t/* No need to proceed if we are going to do full detect */\n\t\treturn false;\n\t}\n\n\tintel_dp_check_service_irq(intel_dp);\n\n\t/* Handle CEC interrupts, if any */\n\tdrm_dp_cec_irq(&intel_dp->aux);\n\n\t/* defer to the hotplug work for link retraining if needed */\n\tif (intel_dp_needs_link_retrain(intel_dp))\n\t\treturn false;\n\n\tintel_psr_short_pulse(intel_dp);\n\n\tswitch (intel_dp->compliance.test_type) {\n\tcase DP_TEST_LINK_TRAINING:\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Link Training Compliance Test requested\\n\");\n\t\t/* Send a Hotplug Uevent to userspace to start modeset */\n\t\tdrm_kms_helper_hotplug_event(&dev_priv->drm);\n\t\tbreak;\n\tcase DP_TEST_LINK_PHY_TEST_PATTERN:\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"PHY test pattern Compliance Test requested\\n\");\n\t\t/*\n\t\t * Schedule long hpd to do the test\n\t\t *\n\t\t * FIXME get rid of the ad-hoc phy test modeset code\n\t\t * and properly incorporate it into the normal modeset.\n\t\t */\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/* XXX this is probably wrong for multiple downstream ports */\nstatic enum drm_connector_status\nintel_dp_detect_dpcd(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tu8 *dpcd = intel_dp->dpcd;\n\tu8 type;\n\n\tif (drm_WARN_ON(&i915->drm, intel_dp_is_edp(intel_dp)))\n\t\treturn connector_status_connected;\n\n\tlspcon_resume(dig_port);\n\n\tif (!intel_dp_get_dpcd(intel_dp))\n\t\treturn connector_status_disconnected;\n\n\t/* if there's no downstream port, we're done */\n\tif (!drm_dp_is_branch(dpcd))\n\t\treturn connector_status_connected;\n\n\t/* If we're HPD-aware, SINK_COUNT changes dynamically */\n\tif (intel_dp_has_sink_count(intel_dp) &&\n\t    intel_dp->downstream_ports[0] & DP_DS_PORT_HPD) {\n\t\treturn intel_dp->sink_count ?\n\t\tconnector_status_connected : connector_status_disconnected;\n\t}\n\n\tif (intel_dp_can_mst(intel_dp))\n\t\treturn connector_status_connected;\n\n\t/* If no HPD, poke DDC gently */\n\tif (drm_probe_ddc(&intel_dp->aux.ddc))\n\t\treturn connector_status_connected;\n\n\t/* Well we tried, say unknown for unreliable port types */\n\tif (intel_dp->dpcd[DP_DPCD_REV] >= 0x11) {\n\t\ttype = intel_dp->downstream_ports[0] & DP_DS_PORT_TYPE_MASK;\n\t\tif (type == DP_DS_PORT_TYPE_VGA ||\n\t\t    type == DP_DS_PORT_TYPE_NON_EDID)\n\t\t\treturn connector_status_unknown;\n\t} else {\n\t\ttype = intel_dp->dpcd[DP_DOWNSTREAMPORT_PRESENT] &\n\t\t\tDP_DWN_STRM_PORT_TYPE_MASK;\n\t\tif (type == DP_DWN_STRM_PORT_TYPE_ANALOG ||\n\t\t    type == DP_DWN_STRM_PORT_TYPE_OTHER)\n\t\t\treturn connector_status_unknown;\n\t}\n\n\t/* Anything else is out of spec, warn and ignore */\n\tdrm_dbg_kms(&i915->drm, \"Broken DP branch device, ignoring\\n\");\n\treturn connector_status_disconnected;\n}\n\nstatic enum drm_connector_status\nedp_detect(struct intel_dp *intel_dp)\n{\n\treturn connector_status_connected;\n}\n\nstatic bool ibx_digital_port_connected(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 bit = dev_priv->hotplug.pch_hpd[encoder->hpd_pin];\n\n\treturn intel_de_read(dev_priv, SDEISR) & bit;\n}\n\nstatic bool g4x_digital_port_connected(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 bit;\n\n\tswitch (encoder->hpd_pin) {\n\tcase HPD_PORT_B:\n\t\tbit = PORTB_HOTPLUG_LIVE_STATUS_G4X;\n\t\tbreak;\n\tcase HPD_PORT_C:\n\t\tbit = PORTC_HOTPLUG_LIVE_STATUS_G4X;\n\t\tbreak;\n\tcase HPD_PORT_D:\n\t\tbit = PORTD_HOTPLUG_LIVE_STATUS_G4X;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(encoder->hpd_pin);\n\t\treturn false;\n\t}\n\n\treturn intel_de_read(dev_priv, PORT_HOTPLUG_STAT) & bit;\n}\n\nstatic bool gm45_digital_port_connected(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 bit;\n\n\tswitch (encoder->hpd_pin) {\n\tcase HPD_PORT_B:\n\t\tbit = PORTB_HOTPLUG_LIVE_STATUS_GM45;\n\t\tbreak;\n\tcase HPD_PORT_C:\n\t\tbit = PORTC_HOTPLUG_LIVE_STATUS_GM45;\n\t\tbreak;\n\tcase HPD_PORT_D:\n\t\tbit = PORTD_HOTPLUG_LIVE_STATUS_GM45;\n\t\tbreak;\n\tdefault:\n\t\tMISSING_CASE(encoder->hpd_pin);\n\t\treturn false;\n\t}\n\n\treturn intel_de_read(dev_priv, PORT_HOTPLUG_STAT) & bit;\n}\n\nstatic bool ilk_digital_port_connected(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tu32 bit = dev_priv->hotplug.hpd[encoder->hpd_pin];\n\n\treturn intel_de_read(dev_priv, DEISR) & bit;\n}\n\n/*\n * intel_digital_port_connected - is the specified port connected?\n * @encoder: intel_encoder\n *\n * In cases where there's a connector physically connected but it can't be used\n * by our hardware we also return false, since the rest of the driver should\n * pretty much treat the port as disconnected. This is relevant for type-C\n * (starting on ICL) where there's ownership involved.\n *\n * Return %true if port is connected, %false otherwise.\n */\nbool intel_digital_port_connected(struct intel_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(encoder);\n\tbool is_connected = false;\n\tintel_wakeref_t wakeref;\n\n\twith_intel_display_power(dev_priv, POWER_DOMAIN_DISPLAY_CORE, wakeref)\n\t\tis_connected = dig_port->connected(encoder);\n\n\treturn is_connected;\n}\n\nstatic struct edid *\nintel_dp_get_edid(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *intel_connector = intel_dp->attached_connector;\n\n\t/* use cached edid if we have one */\n\tif (intel_connector->edid) {\n\t\t/* invalid edid */\n\t\tif (IS_ERR(intel_connector->edid))\n\t\t\treturn NULL;\n\n\t\treturn drm_edid_duplicate(intel_connector->edid);\n\t} else\n\t\treturn drm_get_edid(&intel_connector->base,\n\t\t\t\t    &intel_dp->aux.ddc);\n}\n\nstatic void\nintel_dp_update_dfp(struct intel_dp *intel_dp,\n\t\t    const struct edid *edid)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\n\tintel_dp->dfp.max_bpc =\n\t\tdrm_dp_downstream_max_bpc(intel_dp->dpcd,\n\t\t\t\t\t  intel_dp->downstream_ports, edid);\n\n\tintel_dp->dfp.max_dotclock =\n\t\tdrm_dp_downstream_max_dotclock(intel_dp->dpcd,\n\t\t\t\t\t       intel_dp->downstream_ports);\n\n\tintel_dp->dfp.min_tmds_clock =\n\t\tdrm_dp_downstream_min_tmds_clock(intel_dp->dpcd,\n\t\t\t\t\t\t intel_dp->downstream_ports,\n\t\t\t\t\t\t edid);\n\tintel_dp->dfp.max_tmds_clock =\n\t\tdrm_dp_downstream_max_tmds_clock(intel_dp->dpcd,\n\t\t\t\t\t\t intel_dp->downstream_ports,\n\t\t\t\t\t\t edid);\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CONNECTOR:%d:%s] DFP max bpc %d, max dotclock %d, TMDS clock %d-%d\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    intel_dp->dfp.max_bpc,\n\t\t    intel_dp->dfp.max_dotclock,\n\t\t    intel_dp->dfp.min_tmds_clock,\n\t\t    intel_dp->dfp.max_tmds_clock);\n}\n\nstatic void\nintel_dp_update_420(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *i915 = dp_to_i915(intel_dp);\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tbool is_branch, ycbcr_420_passthrough, ycbcr_444_to_420;\n\n\t/* No YCbCr output support on gmch platforms */\n\tif (HAS_GMCH(i915))\n\t\treturn;\n\n\t/*\n\t * ILK doesn't seem capable of DP YCbCr output. The\n\t * displayed image is severly corrupted. SNB+ is fine.\n\t */\n\tif (IS_GEN(i915, 5))\n\t\treturn;\n\n\tis_branch = drm_dp_is_branch(intel_dp->dpcd);\n\tycbcr_420_passthrough =\n\t\tdrm_dp_downstream_420_passthrough(intel_dp->dpcd,\n\t\t\t\t\t\t  intel_dp->downstream_ports);\n\t/* on-board LSPCON always assumed to support 4:4:4->4:2:0 conversion */\n\tycbcr_444_to_420 =\n\t\tdp_to_dig_port(intel_dp)->lspcon.active ||\n\t\tdrm_dp_downstream_444_to_420_conversion(intel_dp->dpcd,\n\t\t\t\t\t\t\tintel_dp->downstream_ports);\n\n\tif (INTEL_GEN(i915) >= 11) {\n\t\t/* Prefer 4:2:0 passthrough over 4:4:4->4:2:0 conversion */\n\t\tintel_dp->dfp.ycbcr_444_to_420 =\n\t\t\tycbcr_444_to_420 && !ycbcr_420_passthrough;\n\n\t\tconnector->base.ycbcr_420_allowed =\n\t\t\t!is_branch || ycbcr_444_to_420 || ycbcr_420_passthrough;\n\t} else {\n\t\t/* 4:4:4->4:2:0 conversion is the only way */\n\t\tintel_dp->dfp.ycbcr_444_to_420 = ycbcr_444_to_420;\n\n\t\tconnector->base.ycbcr_420_allowed = ycbcr_444_to_420;\n\t}\n\n\tdrm_dbg_kms(&i915->drm,\n\t\t    \"[CONNECTOR:%d:%s] YCbCr 4:2:0 allowed? %s, YCbCr 4:4:4->4:2:0 conversion? %s\\n\",\n\t\t    connector->base.base.id, connector->base.name,\n\t\t    yesno(connector->base.ycbcr_420_allowed),\n\t\t    yesno(intel_dp->dfp.ycbcr_444_to_420));\n}\n\nstatic void\nintel_dp_set_edid(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\tstruct edid *edid;\n\n\tintel_dp_unset_edid(intel_dp);\n\tedid = intel_dp_get_edid(intel_dp);\n\tconnector->detect_edid = edid;\n\n\tintel_dp_update_dfp(intel_dp, edid);\n\tintel_dp_update_420(intel_dp);\n\n\tif (edid && edid->input & DRM_EDID_INPUT_DIGITAL) {\n\t\tintel_dp->has_hdmi_sink = drm_detect_hdmi_monitor(edid);\n\t\tintel_dp->has_audio = drm_detect_monitor_audio(edid);\n\t}\n\n\tdrm_dp_cec_set_edid(&intel_dp->aux, edid);\n\tintel_dp->edid_quirks = drm_dp_get_edid_quirks(edid);\n}\n\nstatic void\nintel_dp_unset_edid(struct intel_dp *intel_dp)\n{\n\tstruct intel_connector *connector = intel_dp->attached_connector;\n\n\tdrm_dp_cec_unset_edid(&intel_dp->aux);\n\tkfree(connector->detect_edid);\n\tconnector->detect_edid = NULL;\n\n\tintel_dp->has_hdmi_sink = false;\n\tintel_dp->has_audio = false;\n\tintel_dp->edid_quirks = 0;\n\n\tintel_dp->dfp.max_bpc = 0;\n\tintel_dp->dfp.max_dotclock = 0;\n\tintel_dp->dfp.min_tmds_clock = 0;\n\tintel_dp->dfp.max_tmds_clock = 0;\n\n\tintel_dp->dfp.ycbcr_444_to_420 = false;\n\tconnector->base.ycbcr_420_allowed = false;\n}\n\nstatic int\nintel_dp_detect(struct drm_connector *connector,\n\t\tstruct drm_modeset_acquire_ctx *ctx,\n\t\tbool force)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->dev);\n\tstruct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct intel_encoder *encoder = &dig_port->base;\n\tenum drm_connector_status status;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[CONNECTOR:%d:%s]\\n\",\n\t\t    connector->base.id, connector->name);\n\tdrm_WARN_ON(&dev_priv->drm,\n\t\t    !drm_modeset_is_locked(&dev_priv->drm.mode_config.connection_mutex));\n\n\tif (!INTEL_DISPLAY_ENABLED(dev_priv))\n\t\treturn connector_status_disconnected;\n\n\t/* Can't disconnect eDP */\n\tif (intel_dp_is_edp(intel_dp))\n\t\tstatus = edp_detect(intel_dp);\n\telse if (intel_digital_port_connected(encoder))\n\t\tstatus = intel_dp_detect_dpcd(intel_dp);\n\telse\n\t\tstatus = connector_status_disconnected;\n\n\tif (status == connector_status_disconnected) {\n\t\tmemset(&intel_dp->compliance, 0, sizeof(intel_dp->compliance));\n\t\tmemset(intel_dp->dsc_dpcd, 0, sizeof(intel_dp->dsc_dpcd));\n\n\t\tif (intel_dp->is_mst) {\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"MST device may have disappeared %d vs %d\\n\",\n\t\t\t\t    intel_dp->is_mst,\n\t\t\t\t    intel_dp->mst_mgr.mst_state);\n\t\t\tintel_dp->is_mst = false;\n\t\t\tdrm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr,\n\t\t\t\t\t\t\tintel_dp->is_mst);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t/* Read DP Sink DSC Cap DPCD regs for DP v1.4 */\n\tif (INTEL_GEN(dev_priv) >= 11)\n\t\tintel_dp_get_dsc_sink_cap(intel_dp);\n\n\tintel_dp_configure_mst(intel_dp);\n\n\t/*\n\t * TODO: Reset link params when switching to MST mode, until MST\n\t * supports link training fallback params.\n\t */\n\tif (intel_dp->reset_link_params || intel_dp->is_mst) {\n\t\t/* Initial max link lane count */\n\t\tintel_dp->max_link_lane_count = intel_dp_max_common_lane_count(intel_dp);\n\n\t\t/* Initial max link rate */\n\t\tintel_dp->max_link_rate = intel_dp_max_common_rate(intel_dp);\n\n\t\tintel_dp->reset_link_params = false;\n\t}\n\n\tintel_dp_print_rates(intel_dp);\n\n\tif (intel_dp->is_mst) {\n\t\t/*\n\t\t * If we are in MST mode then this connector\n\t\t * won't appear connected or have anything\n\t\t * with EDID on it\n\t\t */\n\t\tstatus = connector_status_disconnected;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Some external monitors do not signal loss of link synchronization\n\t * with an IRQ_HPD, so force a link status check.\n\t */\n\tif (!intel_dp_is_edp(intel_dp)) {\n\t\tint ret;\n\n\t\tret = intel_dp_retrain_link(encoder, ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * Clearing NACK and defer counts to get their exact values\n\t * while reading EDID which are required by Compliance tests\n\t * 4.2.2.4 and 4.2.2.5\n\t */\n\tintel_dp->aux.i2c_nack_count = 0;\n\tintel_dp->aux.i2c_defer_count = 0;\n\n\tintel_dp_set_edid(intel_dp);\n\tif (intel_dp_is_edp(intel_dp) ||\n\t    to_intel_connector(connector)->detect_edid)\n\t\tstatus = connector_status_connected;\n\n\tintel_dp_check_service_irq(intel_dp);\n\nout:\n\tif (status != connector_status_connected && !intel_dp->is_mst)\n\t\tintel_dp_unset_edid(intel_dp);\n\n\t/*\n\t * Make sure the refs for power wells enabled during detect are\n\t * dropped to avoid a new detect cycle triggered by HPD polling.\n\t */\n\tintel_display_power_flush_work(dev_priv);\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\tdrm_dp_set_subconnector_property(connector,\n\t\t\t\t\t\t status,\n\t\t\t\t\t\t intel_dp->dpcd,\n\t\t\t\t\t\t intel_dp->downstream_ports);\n\treturn status;\n}\n\nstatic void\nintel_dp_force(struct drm_connector *connector)\n{\n\tstruct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct intel_encoder *intel_encoder = &dig_port->base;\n\tstruct drm_i915_private *dev_priv = to_i915(intel_encoder->base.dev);\n\tenum intel_display_power_domain aux_domain =\n\t\tintel_aux_power_domain(dig_port);\n\tintel_wakeref_t wakeref;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"[CONNECTOR:%d:%s]\\n\",\n\t\t    connector->base.id, connector->name);\n\tintel_dp_unset_edid(intel_dp);\n\n\tif (connector->status != connector_status_connected)\n\t\treturn;\n\n\twakeref = intel_display_power_get(dev_priv, aux_domain);\n\n\tintel_dp_set_edid(intel_dp);\n\n\tintel_display_power_put(dev_priv, aux_domain, wakeref);\n}\n\nstatic int intel_dp_get_modes(struct drm_connector *connector)\n{\n\tstruct intel_connector *intel_connector = to_intel_connector(connector);\n\tstruct edid *edid;\n\n\tedid = intel_connector->detect_edid;\n\tif (edid) {\n\t\tint ret = intel_connector_update_modes(connector, edid);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* if eDP has no EDID, fall back to fixed mode */\n\tif (intel_dp_is_edp(intel_attached_dp(intel_connector)) &&\n\t    intel_connector->panel.fixed_mode) {\n\t\tstruct drm_display_mode *mode;\n\n\t\tmode = drm_mode_duplicate(connector->dev,\n\t\t\t\t\t  intel_connector->panel.fixed_mode);\n\t\tif (mode) {\n\t\t\tdrm_mode_probed_add(connector, mode);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (!edid) {\n\t\tstruct intel_dp *intel_dp = intel_attached_dp(intel_connector);\n\t\tstruct drm_display_mode *mode;\n\n\t\tmode = drm_dp_downstream_mode(connector->dev,\n\t\t\t\t\t      intel_dp->dpcd,\n\t\t\t\t\t      intel_dp->downstream_ports);\n\t\tif (mode) {\n\t\t\tdrm_mode_probed_add(connector, mode);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nintel_dp_connector_register(struct drm_connector *connector)\n{\n\tstruct drm_i915_private *i915 = to_i915(connector->dev);\n\tstruct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\tstruct intel_lspcon *lspcon = &dig_port->lspcon;\n\tint ret;\n\n\tret = intel_connector_register(connector);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_dbg_kms(&i915->drm, \"registering %s bus for %s\\n\",\n\t\t    intel_dp->aux.name, connector->kdev->kobj.name);\n\n\tintel_dp->aux.dev = connector->kdev;\n\tret = drm_dp_aux_register(&intel_dp->aux);\n\tif (!ret)\n\t\tdrm_dp_cec_register_connector(&intel_dp->aux, connector);\n\n\tif (!intel_bios_is_lspcon_present(i915, dig_port->base.port))\n\t\treturn ret;\n\n\t/*\n\t * ToDo: Clean this up to handle lspcon init and resume more\n\t * efficiently and streamlined.\n\t */\n\tif (lspcon_init(dig_port)) {\n\t\tlspcon_detect_hdr_capability(lspcon);\n\t\tif (lspcon->hdr_supported)\n\t\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t\t   connector->dev->mode_config.hdr_output_metadata_property,\n\t\t\t\t\t\t   0);\n\t}\n\n\treturn ret;\n}\n\nstatic void\nintel_dp_connector_unregister(struct drm_connector *connector)\n{\n\tstruct intel_dp *intel_dp = intel_attached_dp(to_intel_connector(connector));\n\n\tdrm_dp_cec_unregister_connector(&intel_dp->aux);\n\tdrm_dp_aux_unregister(&intel_dp->aux);\n\tintel_connector_unregister(connector);\n}\n\nvoid intel_dp_encoder_flush_work(struct drm_encoder *encoder)\n{\n\tstruct intel_digital_port *dig_port = enc_to_dig_port(to_intel_encoder(encoder));\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\n\tintel_dp_mst_encoder_cleanup(dig_port);\n\tif (intel_dp_is_edp(intel_dp)) {\n\t\tintel_wakeref_t wakeref;\n\n\t\tcancel_delayed_work_sync(&intel_dp->panel_vdd_work);\n\t\t/*\n\t\t * vdd might still be enabled do to the delayed vdd off.\n\t\t * Make sure vdd is actually turned off here.\n\t\t */\n\t\twith_pps_lock(intel_dp, wakeref)\n\t\t\tedp_panel_vdd_off_sync(intel_dp);\n\t}\n\n\tintel_dp_aux_fini(intel_dp);\n}\n\nstatic void intel_dp_encoder_destroy(struct drm_encoder *encoder)\n{\n\tintel_dp_encoder_flush_work(encoder);\n\n\tdrm_encoder_cleanup(encoder);\n\tkfree(enc_to_dig_port(to_intel_encoder(encoder)));\n}\n\nvoid intel_dp_encoder_suspend(struct intel_encoder *intel_encoder)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(intel_encoder);\n\tintel_wakeref_t wakeref;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\t/*\n\t * vdd might still be enabled do to the delayed vdd off.\n\t * Make sure vdd is actually turned off here.\n\t */\n\tcancel_delayed_work_sync(&intel_dp->panel_vdd_work);\n\twith_pps_lock(intel_dp, wakeref)\n\t\tedp_panel_vdd_off_sync(intel_dp);\n}\n\nvoid intel_dp_encoder_shutdown(struct intel_encoder *intel_encoder)\n{\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(intel_encoder);\n\tintel_wakeref_t wakeref;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\twith_pps_lock(intel_dp, wakeref)\n\t\twait_panel_power_cycle(intel_dp);\n}\n\nstatic void intel_edp_panel_vdd_sanitize(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);\n\n\tlockdep_assert_held(&dev_priv->pps_mutex);\n\n\tif (!edp_have_panel_vdd(intel_dp))\n\t\treturn;\n\n\t/*\n\t * The VDD bit needs a power domain reference, so if the bit is\n\t * already enabled when we boot or resume, grab this reference and\n\t * schedule a vdd off, so we don't hold on to the reference\n\t * indefinitely.\n\t */\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"VDD left on by BIOS, adjusting state tracking\\n\");\n\tdrm_WARN_ON(&dev_priv->drm, intel_dp->vdd_wakeref);\n\tintel_dp->vdd_wakeref = intel_display_power_get(dev_priv,\n\t\t\t\t\t\t\tintel_aux_power_domain(dig_port));\n\n\tedp_panel_vdd_schedule_off(intel_dp);\n}\n\nstatic enum pipe vlv_active_pipe(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct intel_encoder *encoder = &dp_to_dig_port(intel_dp)->base;\n\tenum pipe pipe;\n\n\tif (intel_dp_port_enabled(dev_priv, intel_dp->output_reg,\n\t\t\t\t  encoder->port, &pipe))\n\t\treturn pipe;\n\n\treturn INVALID_PIPE;\n}\n\nvoid intel_dp_encoder_reset(struct drm_encoder *encoder)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->dev);\n\tstruct intel_dp *intel_dp = enc_to_intel_dp(to_intel_encoder(encoder));\n\tintel_wakeref_t wakeref;\n\n\tif (!HAS_DDI(dev_priv))\n\t\tintel_dp->DP = intel_de_read(dev_priv, intel_dp->output_reg);\n\n\tintel_dp->reset_link_params = true;\n\n\tif (!IS_VALLEYVIEW(dev_priv) && !IS_CHERRYVIEW(dev_priv) &&\n\t    !intel_dp_is_edp(intel_dp))\n\t\treturn;\n\n\twith_pps_lock(intel_dp, wakeref) {\n\t\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\t\tintel_dp->active_pipe = vlv_active_pipe(intel_dp);\n\n\t\tif (intel_dp_is_edp(intel_dp)) {\n\t\t\t/*\n\t\t\t * Reinit the power sequencer, in case BIOS did\n\t\t\t * something nasty with it.\n\t\t\t */\n\t\t\tintel_dp_pps_init(intel_dp);\n\t\t\tintel_edp_panel_vdd_sanitize(intel_dp);\n\t\t}\n\t}\n}\n\nstatic int intel_modeset_tile_group(struct intel_atomic_state *state,\n\t\t\t\t    int tile_group_id)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector;\n\tint ret = 0;\n\n\tdrm_connector_list_iter_begin(&dev_priv->drm, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tstruct drm_connector_state *conn_state;\n\t\tstruct intel_crtc_state *crtc_state;\n\t\tstruct intel_crtc *crtc;\n\n\t\tif (!connector->has_tile ||\n\t\t    connector->tile_group->id != tile_group_id)\n\t\t\tcontinue;\n\n\t\tconn_state = drm_atomic_get_connector_state(&state->base,\n\t\t\t\t\t\t\t    connector);\n\t\tif (IS_ERR(conn_state)) {\n\t\t\tret = PTR_ERR(conn_state);\n\t\t\tbreak;\n\t\t}\n\n\t\tcrtc = to_intel_crtc(conn_state->crtc);\n\n\t\tif (!crtc)\n\t\t\tcontinue;\n\n\t\tcrtc_state = intel_atomic_get_new_crtc_state(state, crtc);\n\t\tcrtc_state->uapi.mode_changed = true;\n\n\t\tret = drm_atomic_add_affected_planes(&state->base, &crtc->base);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn ret;\n}\n\nstatic int intel_modeset_affected_transcoders(struct intel_atomic_state *state, u8 transcoders)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(state->base.dev);\n\tstruct intel_crtc *crtc;\n\n\tif (transcoders == 0)\n\t\treturn 0;\n\n\tfor_each_intel_crtc(&dev_priv->drm, crtc) {\n\t\tstruct intel_crtc_state *crtc_state;\n\t\tint ret;\n\n\t\tcrtc_state = intel_atomic_get_crtc_state(&state->base, crtc);\n\t\tif (IS_ERR(crtc_state))\n\t\t\treturn PTR_ERR(crtc_state);\n\n\t\tif (!crtc_state->hw.enable)\n\t\t\tcontinue;\n\n\t\tif (!(transcoders & BIT(crtc_state->cpu_transcoder)))\n\t\t\tcontinue;\n\n\t\tcrtc_state->uapi.mode_changed = true;\n\n\t\tret = drm_atomic_add_affected_connectors(&state->base, &crtc->base);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = drm_atomic_add_affected_planes(&state->base, &crtc->base);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttranscoders &= ~BIT(crtc_state->cpu_transcoder);\n\t}\n\n\tdrm_WARN_ON(&dev_priv->drm, transcoders != 0);\n\n\treturn 0;\n}\n\nstatic int intel_modeset_synced_crtcs(struct intel_atomic_state *state,\n\t\t\t\t      struct drm_connector *connector)\n{\n\tconst struct drm_connector_state *old_conn_state =\n\t\tdrm_atomic_get_old_connector_state(&state->base, connector);\n\tconst struct intel_crtc_state *old_crtc_state;\n\tstruct intel_crtc *crtc;\n\tu8 transcoders;\n\n\tcrtc = to_intel_crtc(old_conn_state->crtc);\n\tif (!crtc)\n\t\treturn 0;\n\n\told_crtc_state = intel_atomic_get_old_crtc_state(state, crtc);\n\n\tif (!old_crtc_state->hw.active)\n\t\treturn 0;\n\n\ttranscoders = old_crtc_state->sync_mode_slaves_mask;\n\tif (old_crtc_state->master_transcoder != INVALID_TRANSCODER)\n\t\ttranscoders |= BIT(old_crtc_state->master_transcoder);\n\n\treturn intel_modeset_affected_transcoders(state,\n\t\t\t\t\t\t  transcoders);\n}\n\nstatic int intel_dp_connector_atomic_check(struct drm_connector *conn,\n\t\t\t\t\t   struct drm_atomic_state *_state)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(conn->dev);\n\tstruct intel_atomic_state *state = to_intel_atomic_state(_state);\n\tint ret;\n\n\tret = intel_digital_connector_atomic_check(conn, &state->base);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * We don't enable port sync on BDW due to missing w/as and\n\t * due to not having adjusted the modeset sequence appropriately.\n\t */\n\tif (INTEL_GEN(dev_priv) < 9)\n\t\treturn 0;\n\n\tif (!intel_connector_needs_modeset(state, conn))\n\t\treturn 0;\n\n\tif (conn->has_tile) {\n\t\tret = intel_modeset_tile_group(state, conn->tile_group->id);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn intel_modeset_synced_crtcs(state, conn);\n}\n\nstatic const struct drm_connector_funcs intel_dp_connector_funcs = {\n\t.force = intel_dp_force,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.atomic_get_property = intel_digital_connector_atomic_get_property,\n\t.atomic_set_property = intel_digital_connector_atomic_set_property,\n\t.late_register = intel_dp_connector_register,\n\t.early_unregister = intel_dp_connector_unregister,\n\t.destroy = intel_connector_destroy,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.atomic_duplicate_state = intel_digital_connector_duplicate_state,\n};\n\nstatic const struct drm_connector_helper_funcs intel_dp_connector_helper_funcs = {\n\t.detect_ctx = intel_dp_detect,\n\t.get_modes = intel_dp_get_modes,\n\t.mode_valid = intel_dp_mode_valid,\n\t.atomic_check = intel_dp_connector_atomic_check,\n};\n\nstatic const struct drm_encoder_funcs intel_dp_enc_funcs = {\n\t.reset = intel_dp_encoder_reset,\n\t.destroy = intel_dp_encoder_destroy,\n};\n\nstatic bool intel_edp_have_power(struct intel_dp *intel_dp)\n{\n\tintel_wakeref_t wakeref;\n\tbool have_power = false;\n\n\twith_pps_lock(intel_dp, wakeref) {\n\t\thave_power = edp_have_panel_power(intel_dp) &&\n\t\t\t\t\t\t  edp_have_panel_vdd(intel_dp);\n\t}\n\n\treturn have_power;\n}\n\nenum irqreturn\nintel_dp_hpd_pulse(struct intel_digital_port *dig_port, bool long_hpd)\n{\n\tstruct drm_i915_private *i915 = to_i915(dig_port->base.base.dev);\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\n\tif (dig_port->base.type == INTEL_OUTPUT_EDP &&\n\t    (long_hpd || !intel_edp_have_power(intel_dp))) {\n\t\t/*\n\t\t * vdd off can generate a long/short pulse on eDP which\n\t\t * would require vdd on to handle it, and thus we\n\t\t * would end up in an endless cycle of\n\t\t * \"vdd off -> long/short hpd -> vdd on -> detect -> vdd off -> ...\"\n\t\t */\n\t\tdrm_dbg_kms(&i915->drm,\n\t\t\t    \"ignoring %s hpd on eDP [ENCODER:%d:%s]\\n\",\n\t\t\t    long_hpd ? \"long\" : \"short\",\n\t\t\t    dig_port->base.base.base.id,\n\t\t\t    dig_port->base.base.name);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tdrm_dbg_kms(&i915->drm, \"got hpd irq on [ENCODER:%d:%s] - %s\\n\",\n\t\t    dig_port->base.base.base.id,\n\t\t    dig_port->base.base.name,\n\t\t    long_hpd ? \"long\" : \"short\");\n\n\tif (long_hpd) {\n\t\tintel_dp->reset_link_params = true;\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (intel_dp->is_mst) {\n\t\tif (!intel_dp_check_mst_status(intel_dp))\n\t\t\treturn IRQ_NONE;\n\t} else if (!intel_dp_short_pulse(intel_dp)) {\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n/* check the VBT to see whether the eDP is on another port */\nbool intel_dp_is_port_edp(struct drm_i915_private *dev_priv, enum port port)\n{\n\t/*\n\t * eDP not supported on g4x. so bail out early just\n\t * for a bit extra safety in case the VBT is bonkers.\n\t */\n\tif (INTEL_GEN(dev_priv) < 5)\n\t\treturn false;\n\n\tif (INTEL_GEN(dev_priv) < 9 && port == PORT_A)\n\t\treturn true;\n\n\treturn intel_bios_is_port_edp(dev_priv, port);\n}\n\nstatic void\nintel_dp_add_properties(struct intel_dp *intel_dp, struct drm_connector *connector)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->dev);\n\tenum port port = dp_to_dig_port(intel_dp)->base.port;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\tdrm_connector_attach_dp_subconnector_property(connector);\n\n\tif (!IS_G4X(dev_priv) && port != PORT_A)\n\t\tintel_attach_force_audio_property(connector);\n\n\tintel_attach_broadcast_rgb_property(connector);\n\tif (HAS_GMCH(dev_priv))\n\t\tdrm_connector_attach_max_bpc_property(connector, 6, 10);\n\telse if (INTEL_GEN(dev_priv) >= 5)\n\t\tdrm_connector_attach_max_bpc_property(connector, 6, 12);\n\n\t/* Register HDMI colorspace for case of lspcon */\n\tif (intel_bios_is_lspcon_present(dev_priv, port)) {\n\t\tdrm_connector_attach_content_type_property(connector);\n\t\tintel_attach_hdmi_colorspace_property(connector);\n\t} else {\n\t\tintel_attach_dp_colorspace_property(connector);\n\t}\n\n\tif (IS_GEMINILAKE(dev_priv) || INTEL_GEN(dev_priv) >= 11)\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t   connector->dev->mode_config.hdr_output_metadata_property,\n\t\t\t\t\t   0);\n\n\tif (intel_dp_is_edp(intel_dp)) {\n\t\tu32 allowed_scalers;\n\n\t\tallowed_scalers = BIT(DRM_MODE_SCALE_ASPECT) | BIT(DRM_MODE_SCALE_FULLSCREEN);\n\t\tif (!HAS_GMCH(dev_priv))\n\t\t\tallowed_scalers |= BIT(DRM_MODE_SCALE_CENTER);\n\n\t\tdrm_connector_attach_scaling_mode_property(connector, allowed_scalers);\n\n\t\tconnector->state->scaling_mode = DRM_MODE_SCALE_ASPECT;\n\n\t}\n}\n\nstatic void intel_dp_init_panel_power_timestamps(struct intel_dp *intel_dp)\n{\n\tintel_dp->panel_power_off_time = ktime_get_boottime();\n\tintel_dp->last_power_on = jiffies;\n\tintel_dp->last_backlight_off = jiffies;\n}\n\nstatic void\nintel_pps_readout_hw_state(struct intel_dp *intel_dp, struct edp_power_seq *seq)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu32 pp_on, pp_off, pp_ctl;\n\tstruct pps_registers regs;\n\n\tintel_pps_get_registers(intel_dp, &regs);\n\n\tpp_ctl = ilk_get_pp_control(intel_dp);\n\n\t/* Ensure PPS is unlocked */\n\tif (!HAS_DDI(dev_priv))\n\t\tintel_de_write(dev_priv, regs.pp_ctrl, pp_ctl);\n\n\tpp_on = intel_de_read(dev_priv, regs.pp_on);\n\tpp_off = intel_de_read(dev_priv, regs.pp_off);\n\n\t/* Pull timing values out of registers */\n\tseq->t1_t3 = REG_FIELD_GET(PANEL_POWER_UP_DELAY_MASK, pp_on);\n\tseq->t8 = REG_FIELD_GET(PANEL_LIGHT_ON_DELAY_MASK, pp_on);\n\tseq->t9 = REG_FIELD_GET(PANEL_LIGHT_OFF_DELAY_MASK, pp_off);\n\tseq->t10 = REG_FIELD_GET(PANEL_POWER_DOWN_DELAY_MASK, pp_off);\n\n\tif (i915_mmio_reg_valid(regs.pp_div)) {\n\t\tu32 pp_div;\n\n\t\tpp_div = intel_de_read(dev_priv, regs.pp_div);\n\n\t\tseq->t11_t12 = REG_FIELD_GET(PANEL_POWER_CYCLE_DELAY_MASK, pp_div) * 1000;\n\t} else {\n\t\tseq->t11_t12 = REG_FIELD_GET(BXT_POWER_CYCLE_DELAY_MASK, pp_ctl) * 1000;\n\t}\n}\n\nstatic void\nintel_pps_dump_state(const char *state_name, const struct edp_power_seq *seq)\n{\n\tDRM_DEBUG_KMS(\"%s t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\\n\",\n\t\t      state_name,\n\t\t      seq->t1_t3, seq->t8, seq->t9, seq->t10, seq->t11_t12);\n}\n\nstatic void\nintel_pps_verify_state(struct intel_dp *intel_dp)\n{\n\tstruct edp_power_seq hw;\n\tstruct edp_power_seq *sw = &intel_dp->pps_delays;\n\n\tintel_pps_readout_hw_state(intel_dp, &hw);\n\n\tif (hw.t1_t3 != sw->t1_t3 || hw.t8 != sw->t8 || hw.t9 != sw->t9 ||\n\t    hw.t10 != sw->t10 || hw.t11_t12 != sw->t11_t12) {\n\t\tDRM_ERROR(\"PPS state mismatch\\n\");\n\t\tintel_pps_dump_state(\"sw\", sw);\n\t\tintel_pps_dump_state(\"hw\", &hw);\n\t}\n}\n\nstatic void\nintel_dp_init_panel_power_sequencer(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct edp_power_seq cur, vbt, spec,\n\t\t*final = &intel_dp->pps_delays;\n\n\tlockdep_assert_held(&dev_priv->pps_mutex);\n\n\t/* already initialized? */\n\tif (final->t11_t12 != 0)\n\t\treturn;\n\n\tintel_pps_readout_hw_state(intel_dp, &cur);\n\n\tintel_pps_dump_state(\"cur\", &cur);\n\n\tvbt = dev_priv->vbt.edp.pps;\n\t/* On Toshiba Satellite P50-C-18C system the VBT T12 delay\n\t * of 500ms appears to be too short. Ocassionally the panel\n\t * just fails to power back on. Increasing the delay to 800ms\n\t * seems sufficient to avoid this problem.\n\t */\n\tif (dev_priv->quirks & QUIRK_INCREASE_T12_DELAY) {\n\t\tvbt.t11_t12 = max_t(u16, vbt.t11_t12, 1300 * 10);\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Increasing T12 panel delay as per the quirk to %d\\n\",\n\t\t\t    vbt.t11_t12);\n\t}\n\t/* T11_T12 delay is special and actually in units of 100ms, but zero\n\t * based in the hw (so we need to add 100 ms). But the sw vbt\n\t * table multiplies it with 1000 to make it in units of 100usec,\n\t * too. */\n\tvbt.t11_t12 += 100 * 10;\n\n\t/* Upper limits from eDP 1.3 spec. Note that we use the clunky units of\n\t * our hw here, which are all in 100usec. */\n\tspec.t1_t3 = 210 * 10;\n\tspec.t8 = 50 * 10; /* no limit for t8, use t7 instead */\n\tspec.t9 = 50 * 10; /* no limit for t9, make it symmetric with t8 */\n\tspec.t10 = 500 * 10;\n\t/* This one is special and actually in units of 100ms, but zero\n\t * based in the hw (so we need to add 100 ms). But the sw vbt\n\t * table multiplies it with 1000 to make it in units of 100usec,\n\t * too. */\n\tspec.t11_t12 = (510 + 100) * 10;\n\n\tintel_pps_dump_state(\"vbt\", &vbt);\n\n\t/* Use the max of the register settings and vbt. If both are\n\t * unset, fall back to the spec limits. */\n#define assign_final(field)\tfinal->field = (max(cur.field, vbt.field) == 0 ? \\\n\t\t\t\t       spec.field : \\\n\t\t\t\t       max(cur.field, vbt.field))\n\tassign_final(t1_t3);\n\tassign_final(t8);\n\tassign_final(t9);\n\tassign_final(t10);\n\tassign_final(t11_t12);\n#undef assign_final\n\n#define get_delay(field)\t(DIV_ROUND_UP(final->field, 10))\n\tintel_dp->panel_power_up_delay = get_delay(t1_t3);\n\tintel_dp->backlight_on_delay = get_delay(t8);\n\tintel_dp->backlight_off_delay = get_delay(t9);\n\tintel_dp->panel_power_down_delay = get_delay(t10);\n\tintel_dp->panel_power_cycle_delay = get_delay(t11_t12);\n#undef get_delay\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"panel power up delay %d, power down delay %d, power cycle delay %d\\n\",\n\t\t    intel_dp->panel_power_up_delay,\n\t\t    intel_dp->panel_power_down_delay,\n\t\t    intel_dp->panel_power_cycle_delay);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"backlight on delay %d, off delay %d\\n\",\n\t\t    intel_dp->backlight_on_delay,\n\t\t    intel_dp->backlight_off_delay);\n\n\t/*\n\t * We override the HW backlight delays to 1 because we do manual waits\n\t * on them. For T8, even BSpec recommends doing it. For T9, if we\n\t * don't do this, we'll end up waiting for the backlight off delay\n\t * twice: once when we do the manual sleep, and once when we disable\n\t * the panel and wait for the PP_STATUS bit to become zero.\n\t */\n\tfinal->t8 = 1;\n\tfinal->t9 = 1;\n\n\t/*\n\t * HW has only a 100msec granularity for t11_t12 so round it up\n\t * accordingly.\n\t */\n\tfinal->t11_t12 = roundup(final->t11_t12, 100 * 10);\n}\n\nstatic void\nintel_dp_init_panel_power_sequencer_registers(struct intel_dp *intel_dp,\n\t\t\t\t\t      bool force_disable_vdd)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tu32 pp_on, pp_off, port_sel = 0;\n\tint div = RUNTIME_INFO(dev_priv)->rawclk_freq / 1000;\n\tstruct pps_registers regs;\n\tenum port port = dp_to_dig_port(intel_dp)->base.port;\n\tconst struct edp_power_seq *seq = &intel_dp->pps_delays;\n\n\tlockdep_assert_held(&dev_priv->pps_mutex);\n\n\tintel_pps_get_registers(intel_dp, &regs);\n\n\t/*\n\t * On some VLV machines the BIOS can leave the VDD\n\t * enabled even on power sequencers which aren't\n\t * hooked up to any port. This would mess up the\n\t * power domain tracking the first time we pick\n\t * one of these power sequencers for use since\n\t * edp_panel_vdd_on() would notice that the VDD was\n\t * already on and therefore wouldn't grab the power\n\t * domain reference. Disable VDD first to avoid this.\n\t * This also avoids spuriously turning the VDD on as\n\t * soon as the new power sequencer gets initialized.\n\t */\n\tif (force_disable_vdd) {\n\t\tu32 pp = ilk_get_pp_control(intel_dp);\n\n\t\tdrm_WARN(&dev_priv->drm, pp & PANEL_POWER_ON,\n\t\t\t \"Panel power already on\\n\");\n\n\t\tif (pp & EDP_FORCE_VDD)\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"VDD already on, disabling first\\n\");\n\n\t\tpp &= ~EDP_FORCE_VDD;\n\n\t\tintel_de_write(dev_priv, regs.pp_ctrl, pp);\n\t}\n\n\tpp_on = REG_FIELD_PREP(PANEL_POWER_UP_DELAY_MASK, seq->t1_t3) |\n\t\tREG_FIELD_PREP(PANEL_LIGHT_ON_DELAY_MASK, seq->t8);\n\tpp_off = REG_FIELD_PREP(PANEL_LIGHT_OFF_DELAY_MASK, seq->t9) |\n\t\tREG_FIELD_PREP(PANEL_POWER_DOWN_DELAY_MASK, seq->t10);\n\n\t/* Haswell doesn't have any port selection bits for the panel\n\t * power sequencer any more. */\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tport_sel = PANEL_PORT_SELECT_VLV(port);\n\t} else if (HAS_PCH_IBX(dev_priv) || HAS_PCH_CPT(dev_priv)) {\n\t\tswitch (port) {\n\t\tcase PORT_A:\n\t\t\tport_sel = PANEL_PORT_SELECT_DPA;\n\t\t\tbreak;\n\t\tcase PORT_C:\n\t\t\tport_sel = PANEL_PORT_SELECT_DPC;\n\t\t\tbreak;\n\t\tcase PORT_D:\n\t\t\tport_sel = PANEL_PORT_SELECT_DPD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tMISSING_CASE(port);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpp_on |= port_sel;\n\n\tintel_de_write(dev_priv, regs.pp_on, pp_on);\n\tintel_de_write(dev_priv, regs.pp_off, pp_off);\n\n\t/*\n\t * Compute the divisor for the pp clock, simply match the Bspec formula.\n\t */\n\tif (i915_mmio_reg_valid(regs.pp_div)) {\n\t\tintel_de_write(dev_priv, regs.pp_div,\n\t\t\t       REG_FIELD_PREP(PP_REFERENCE_DIVIDER_MASK, (100 * div) / 2 - 1) | REG_FIELD_PREP(PANEL_POWER_CYCLE_DELAY_MASK, DIV_ROUND_UP(seq->t11_t12, 1000)));\n\t} else {\n\t\tu32 pp_ctl;\n\n\t\tpp_ctl = intel_de_read(dev_priv, regs.pp_ctrl);\n\t\tpp_ctl &= ~BXT_POWER_CYCLE_DELAY_MASK;\n\t\tpp_ctl |= REG_FIELD_PREP(BXT_POWER_CYCLE_DELAY_MASK, DIV_ROUND_UP(seq->t11_t12, 1000));\n\t\tintel_de_write(dev_priv, regs.pp_ctrl, pp_ctl);\n\t}\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"panel power sequencer register settings: PP_ON %#x, PP_OFF %#x, PP_DIV %#x\\n\",\n\t\t    intel_de_read(dev_priv, regs.pp_on),\n\t\t    intel_de_read(dev_priv, regs.pp_off),\n\t\t    i915_mmio_reg_valid(regs.pp_div) ?\n\t\t    intel_de_read(dev_priv, regs.pp_div) :\n\t\t    (intel_de_read(dev_priv, regs.pp_ctrl) & BXT_POWER_CYCLE_DELAY_MASK));\n}\n\nstatic void intel_dp_pps_init(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\tvlv_initial_power_sequencer_setup(intel_dp);\n\t} else {\n\t\tintel_dp_init_panel_power_sequencer(intel_dp);\n\t\tintel_dp_init_panel_power_sequencer_registers(intel_dp, false);\n\t}\n}\n\n/**\n * intel_dp_set_drrs_state - program registers for RR switch to take effect\n * @dev_priv: i915 device\n * @crtc_state: a pointer to the active intel_crtc_state\n * @refresh_rate: RR to be programmed\n *\n * This function gets called when refresh rate (RR) has to be changed from\n * one frequency to another. Switches can be between high and low RR\n * supported by the panel or to any other RR based on media playback (in\n * this case, RR value needs to be passed from user space).\n *\n * The caller of this function needs to take a lock on dev_priv->drrs.\n */\nstatic void intel_dp_set_drrs_state(struct drm_i915_private *dev_priv,\n\t\t\t\t    const struct intel_crtc_state *crtc_state,\n\t\t\t\t    int refresh_rate)\n{\n\tstruct intel_dp *intel_dp = dev_priv->drrs.dp;\n\tstruct intel_crtc *intel_crtc = to_intel_crtc(crtc_state->uapi.crtc);\n\tenum drrs_refresh_rate_type index = DRRS_HIGH_RR;\n\n\tif (refresh_rate <= 0) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Refresh rate should be positive non-zero.\\n\");\n\t\treturn;\n\t}\n\n\tif (intel_dp == NULL) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"DRRS not supported.\\n\");\n\t\treturn;\n\t}\n\n\tif (!intel_crtc) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"DRRS: intel_crtc not initialized\\n\");\n\t\treturn;\n\t}\n\n\tif (dev_priv->drrs.type < SEAMLESS_DRRS_SUPPORT) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"Only Seamless DRRS supported.\\n\");\n\t\treturn;\n\t}\n\n\tif (drm_mode_vrefresh(intel_dp->attached_connector->panel.downclock_mode) ==\n\t\t\trefresh_rate)\n\t\tindex = DRRS_LOW_RR;\n\n\tif (index == dev_priv->drrs.refresh_rate_type) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"DRRS requested for previously set RR...ignoring\\n\");\n\t\treturn;\n\t}\n\n\tif (!crtc_state->hw.active) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"eDP encoder disabled. CRTC not Active\\n\");\n\t\treturn;\n\t}\n\n\tif (INTEL_GEN(dev_priv) >= 8 && !IS_CHERRYVIEW(dev_priv)) {\n\t\tswitch (index) {\n\t\tcase DRRS_HIGH_RR:\n\t\t\tintel_dp_set_m_n(crtc_state, M1_N1);\n\t\t\tbreak;\n\t\tcase DRRS_LOW_RR:\n\t\t\tintel_dp_set_m_n(crtc_state, M2_N2);\n\t\t\tbreak;\n\t\tcase DRRS_MAX_RR:\n\t\tdefault:\n\t\t\tdrm_err(&dev_priv->drm,\n\t\t\t\t\"Unsupported refreshrate type\\n\");\n\t\t}\n\t} else if (INTEL_GEN(dev_priv) > 6) {\n\t\ti915_reg_t reg = PIPECONF(crtc_state->cpu_transcoder);\n\t\tu32 val;\n\n\t\tval = intel_de_read(dev_priv, reg);\n\t\tif (index > DRRS_HIGH_RR) {\n\t\t\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\t\t\tval |= PIPECONF_EDP_RR_MODE_SWITCH_VLV;\n\t\t\telse\n\t\t\t\tval |= PIPECONF_EDP_RR_MODE_SWITCH;\n\t\t} else {\n\t\t\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\t\t\tval &= ~PIPECONF_EDP_RR_MODE_SWITCH_VLV;\n\t\t\telse\n\t\t\t\tval &= ~PIPECONF_EDP_RR_MODE_SWITCH;\n\t\t}\n\t\tintel_de_write(dev_priv, reg, val);\n\t}\n\n\tdev_priv->drrs.refresh_rate_type = index;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"eDP Refresh Rate set to : %dHz\\n\",\n\t\t    refresh_rate);\n}\n\nstatic void\nintel_edp_drrs_enable_locked(struct intel_dp *intel_dp)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tdev_priv->drrs.busy_frontbuffer_bits = 0;\n\tdev_priv->drrs.dp = intel_dp;\n}\n\n/**\n * intel_edp_drrs_enable - init drrs struct if supported\n * @intel_dp: DP struct\n * @crtc_state: A pointer to the active crtc state.\n *\n * Initializes frontbuffer_bits and drrs.dp\n */\nvoid intel_edp_drrs_enable(struct intel_dp *intel_dp,\n\t\t\t   const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tif (!crtc_state->has_drrs)\n\t\treturn;\n\n\tdrm_dbg_kms(&dev_priv->drm, \"Enabling DRRS\\n\");\n\n\tmutex_lock(&dev_priv->drrs.mutex);\n\n\tif (dev_priv->drrs.dp) {\n\t\tdrm_warn(&dev_priv->drm, \"DRRS already enabled\\n\");\n\t\tgoto unlock;\n\t}\n\n\tintel_edp_drrs_enable_locked(intel_dp);\n\nunlock:\n\tmutex_unlock(&dev_priv->drrs.mutex);\n}\n\nstatic void\nintel_edp_drrs_disable_locked(struct intel_dp *intel_dp,\n\t\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tif (dev_priv->drrs.refresh_rate_type == DRRS_LOW_RR) {\n\t\tint refresh;\n\n\t\trefresh = drm_mode_vrefresh(intel_dp->attached_connector->panel.fixed_mode);\n\t\tintel_dp_set_drrs_state(dev_priv, crtc_state, refresh);\n\t}\n\n\tdev_priv->drrs.dp = NULL;\n}\n\n/**\n * intel_edp_drrs_disable - Disable DRRS\n * @intel_dp: DP struct\n * @old_crtc_state: Pointer to old crtc_state.\n *\n */\nvoid intel_edp_drrs_disable(struct intel_dp *intel_dp,\n\t\t\t    const struct intel_crtc_state *old_crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tif (!old_crtc_state->has_drrs)\n\t\treturn;\n\n\tmutex_lock(&dev_priv->drrs.mutex);\n\tif (!dev_priv->drrs.dp) {\n\t\tmutex_unlock(&dev_priv->drrs.mutex);\n\t\treturn;\n\t}\n\n\tintel_edp_drrs_disable_locked(intel_dp, old_crtc_state);\n\tmutex_unlock(&dev_priv->drrs.mutex);\n\n\tcancel_delayed_work_sync(&dev_priv->drrs.work);\n}\n\n/**\n * intel_edp_drrs_update - Update DRRS state\n * @intel_dp: Intel DP\n * @crtc_state: new CRTC state\n *\n * This function will update DRRS states, disabling or enabling DRRS when\n * executing fastsets. For full modeset, intel_edp_drrs_disable() and\n * intel_edp_drrs_enable() should be called instead.\n */\nvoid\nintel_edp_drrs_update(struct intel_dp *intel_dp,\n\t\t      const struct intel_crtc_state *crtc_state)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\n\tif (dev_priv->drrs.type != SEAMLESS_DRRS_SUPPORT)\n\t\treturn;\n\n\tmutex_lock(&dev_priv->drrs.mutex);\n\n\t/* New state matches current one? */\n\tif (crtc_state->has_drrs == !!dev_priv->drrs.dp)\n\t\tgoto unlock;\n\n\tif (crtc_state->has_drrs)\n\t\tintel_edp_drrs_enable_locked(intel_dp);\n\telse\n\t\tintel_edp_drrs_disable_locked(intel_dp, crtc_state);\n\nunlock:\n\tmutex_unlock(&dev_priv->drrs.mutex);\n}\n\nstatic void intel_edp_drrs_downclock_work(struct work_struct *work)\n{\n\tstruct drm_i915_private *dev_priv =\n\t\tcontainer_of(work, typeof(*dev_priv), drrs.work.work);\n\tstruct intel_dp *intel_dp;\n\n\tmutex_lock(&dev_priv->drrs.mutex);\n\n\tintel_dp = dev_priv->drrs.dp;\n\n\tif (!intel_dp)\n\t\tgoto unlock;\n\n\t/*\n\t * The delayed work can race with an invalidate hence we need to\n\t * recheck.\n\t */\n\n\tif (dev_priv->drrs.busy_frontbuffer_bits)\n\t\tgoto unlock;\n\n\tif (dev_priv->drrs.refresh_rate_type != DRRS_LOW_RR) {\n\t\tstruct drm_crtc *crtc = dp_to_dig_port(intel_dp)->base.base.crtc;\n\n\t\tintel_dp_set_drrs_state(dev_priv, to_intel_crtc(crtc)->config,\n\t\t\tdrm_mode_vrefresh(intel_dp->attached_connector->panel.downclock_mode));\n\t}\n\nunlock:\n\tmutex_unlock(&dev_priv->drrs.mutex);\n}\n\n/**\n * intel_edp_drrs_invalidate - Disable Idleness DRRS\n * @dev_priv: i915 device\n * @frontbuffer_bits: frontbuffer plane tracking bits\n *\n * This function gets called everytime rendering on the given planes start.\n * Hence DRRS needs to be Upclocked, i.e. (LOW_RR -> HIGH_RR).\n *\n * Dirty frontbuffers relevant to DRRS are tracked in busy_frontbuffer_bits.\n */\nvoid intel_edp_drrs_invalidate(struct drm_i915_private *dev_priv,\n\t\t\t       unsigned int frontbuffer_bits)\n{\n\tstruct intel_dp *intel_dp;\n\tstruct drm_crtc *crtc;\n\tenum pipe pipe;\n\n\tif (dev_priv->drrs.type == DRRS_NOT_SUPPORTED)\n\t\treturn;\n\n\tcancel_delayed_work(&dev_priv->drrs.work);\n\n\tmutex_lock(&dev_priv->drrs.mutex);\n\n\tintel_dp = dev_priv->drrs.dp;\n\tif (!intel_dp) {\n\t\tmutex_unlock(&dev_priv->drrs.mutex);\n\t\treturn;\n\t}\n\n\tcrtc = dp_to_dig_port(intel_dp)->base.base.crtc;\n\tpipe = to_intel_crtc(crtc)->pipe;\n\n\tfrontbuffer_bits &= INTEL_FRONTBUFFER_ALL_MASK(pipe);\n\tdev_priv->drrs.busy_frontbuffer_bits |= frontbuffer_bits;\n\n\t/* invalidate means busy screen hence upclock */\n\tif (frontbuffer_bits && dev_priv->drrs.refresh_rate_type == DRRS_LOW_RR)\n\t\tintel_dp_set_drrs_state(dev_priv, to_intel_crtc(crtc)->config,\n\t\t\t\t\tdrm_mode_vrefresh(intel_dp->attached_connector->panel.fixed_mode));\n\n\tmutex_unlock(&dev_priv->drrs.mutex);\n}\n\n/**\n * intel_edp_drrs_flush - Restart Idleness DRRS\n * @dev_priv: i915 device\n * @frontbuffer_bits: frontbuffer plane tracking bits\n *\n * This function gets called every time rendering on the given planes has\n * completed or flip on a crtc is completed. So DRRS should be upclocked\n * (LOW_RR -> HIGH_RR). And also Idleness detection should be started again,\n * if no other planes are dirty.\n *\n * Dirty frontbuffers relevant to DRRS are tracked in busy_frontbuffer_bits.\n */\nvoid intel_edp_drrs_flush(struct drm_i915_private *dev_priv,\n\t\t\t  unsigned int frontbuffer_bits)\n{\n\tstruct intel_dp *intel_dp;\n\tstruct drm_crtc *crtc;\n\tenum pipe pipe;\n\n\tif (dev_priv->drrs.type == DRRS_NOT_SUPPORTED)\n\t\treturn;\n\n\tcancel_delayed_work(&dev_priv->drrs.work);\n\n\tmutex_lock(&dev_priv->drrs.mutex);\n\n\tintel_dp = dev_priv->drrs.dp;\n\tif (!intel_dp) {\n\t\tmutex_unlock(&dev_priv->drrs.mutex);\n\t\treturn;\n\t}\n\n\tcrtc = dp_to_dig_port(intel_dp)->base.base.crtc;\n\tpipe = to_intel_crtc(crtc)->pipe;\n\n\tfrontbuffer_bits &= INTEL_FRONTBUFFER_ALL_MASK(pipe);\n\tdev_priv->drrs.busy_frontbuffer_bits &= ~frontbuffer_bits;\n\n\t/* flush means busy screen hence upclock */\n\tif (frontbuffer_bits && dev_priv->drrs.refresh_rate_type == DRRS_LOW_RR)\n\t\tintel_dp_set_drrs_state(dev_priv, to_intel_crtc(crtc)->config,\n\t\t\t\t\tdrm_mode_vrefresh(intel_dp->attached_connector->panel.fixed_mode));\n\n\t/*\n\t * flush also means no more activity hence schedule downclock, if all\n\t * other fbs are quiescent too\n\t */\n\tif (!dev_priv->drrs.busy_frontbuffer_bits)\n\t\tschedule_delayed_work(&dev_priv->drrs.work,\n\t\t\t\tmsecs_to_jiffies(1000));\n\tmutex_unlock(&dev_priv->drrs.mutex);\n}\n\n/**\n * DOC: Display Refresh Rate Switching (DRRS)\n *\n * Display Refresh Rate Switching (DRRS) is a power conservation feature\n * which enables swtching between low and high refresh rates,\n * dynamically, based on the usage scenario. This feature is applicable\n * for internal panels.\n *\n * Indication that the panel supports DRRS is given by the panel EDID, which\n * would list multiple refresh rates for one resolution.\n *\n * DRRS is of 2 types - static and seamless.\n * Static DRRS involves changing refresh rate (RR) by doing a full modeset\n * (may appear as a blink on screen) and is used in dock-undock scenario.\n * Seamless DRRS involves changing RR without any visual effect to the user\n * and can be used during normal system usage. This is done by programming\n * certain registers.\n *\n * Support for static/seamless DRRS may be indicated in the VBT based on\n * inputs from the panel spec.\n *\n * DRRS saves power by switching to low RR based on usage scenarios.\n *\n * The implementation is based on frontbuffer tracking implementation.  When\n * there is a disturbance on the screen triggered by user activity or a periodic\n * system activity, DRRS is disabled (RR is changed to high RR).  When there is\n * no movement on screen, after a timeout of 1 second, a switch to low RR is\n * made.\n *\n * For integration with frontbuffer tracking code, intel_edp_drrs_invalidate()\n * and intel_edp_drrs_flush() are called.\n *\n * DRRS can be further extended to support other internal panels and also\n * the scenario of video playback wherein RR is set based on the rate\n * requested by userspace.\n */\n\n/**\n * intel_dp_drrs_init - Init basic DRRS work and mutex.\n * @connector: eDP connector\n * @fixed_mode: preferred mode of panel\n *\n * This function is  called only once at driver load to initialize basic\n * DRRS stuff.\n *\n * Returns:\n * Downclock mode if panel supports it, else return NULL.\n * DRRS support is determined by the presence of downclock mode (apart\n * from VBT setting).\n */\nstatic struct drm_display_mode *\nintel_dp_drrs_init(struct intel_connector *connector,\n\t\t   struct drm_display_mode *fixed_mode)\n{\n\tstruct drm_i915_private *dev_priv = to_i915(connector->base.dev);\n\tstruct drm_display_mode *downclock_mode = NULL;\n\n\tINIT_DELAYED_WORK(&dev_priv->drrs.work, intel_edp_drrs_downclock_work);\n\tmutex_init(&dev_priv->drrs.mutex);\n\n\tif (INTEL_GEN(dev_priv) <= 6) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"DRRS supported for Gen7 and above\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (dev_priv->vbt.drrs_type != SEAMLESS_DRRS_SUPPORT) {\n\t\tdrm_dbg_kms(&dev_priv->drm, \"VBT doesn't support DRRS\\n\");\n\t\treturn NULL;\n\t}\n\n\tdownclock_mode = intel_panel_edid_downclock_mode(connector, fixed_mode);\n\tif (!downclock_mode) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"Downclock mode is not found. DRRS not supported\\n\");\n\t\treturn NULL;\n\t}\n\n\tdev_priv->drrs.type = dev_priv->vbt.drrs_type;\n\n\tdev_priv->drrs.refresh_rate_type = DRRS_HIGH_RR;\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"seamless DRRS supported for eDP panel.\\n\");\n\treturn downclock_mode;\n}\n\nstatic bool intel_edp_init_connector(struct intel_dp *intel_dp,\n\t\t\t\t     struct intel_connector *intel_connector)\n{\n\tstruct drm_i915_private *dev_priv = dp_to_i915(intel_dp);\n\tstruct drm_device *dev = &dev_priv->drm;\n\tstruct drm_connector *connector = &intel_connector->base;\n\tstruct drm_display_mode *fixed_mode = NULL;\n\tstruct drm_display_mode *downclock_mode = NULL;\n\tbool has_dpcd;\n\tenum pipe pipe = INVALID_PIPE;\n\tintel_wakeref_t wakeref;\n\tstruct edid *edid;\n\n\tif (!intel_dp_is_edp(intel_dp))\n\t\treturn true;\n\n\tINIT_DELAYED_WORK(&intel_dp->panel_vdd_work, edp_panel_vdd_work);\n\n\t/*\n\t * On IBX/CPT we may get here with LVDS already registered. Since the\n\t * driver uses the only internal power sequencer available for both\n\t * eDP and LVDS bail out early in this case to prevent interfering\n\t * with an already powered-on LVDS power sequencer.\n\t */\n\tif (intel_get_lvds_encoder(dev_priv)) {\n\t\tdrm_WARN_ON(dev,\n\t\t\t    !(HAS_PCH_IBX(dev_priv) || HAS_PCH_CPT(dev_priv)));\n\t\tdrm_info(&dev_priv->drm,\n\t\t\t \"LVDS was detected, not registering eDP\\n\");\n\n\t\treturn false;\n\t}\n\n\twith_pps_lock(intel_dp, wakeref) {\n\t\tintel_dp_init_panel_power_timestamps(intel_dp);\n\t\tintel_dp_pps_init(intel_dp);\n\t\tintel_edp_panel_vdd_sanitize(intel_dp);\n\t}\n\n\t/* Cache DPCD and EDID for edp. */\n\thas_dpcd = intel_edp_init_dpcd(intel_dp);\n\n\tif (!has_dpcd) {\n\t\t/* if this fails, presume the device is a ghost */\n\t\tdrm_info(&dev_priv->drm,\n\t\t\t \"failed to retrieve link info, disabling eDP\\n\");\n\t\tgoto out_vdd_off;\n\t}\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tedid = drm_get_edid(connector, &intel_dp->aux.ddc);\n\tif (edid) {\n\t\tif (drm_add_edid_modes(connector, edid)) {\n\t\t\tdrm_connector_update_edid_property(connector, edid);\n\t\t\tintel_dp->edid_quirks = drm_dp_get_edid_quirks(edid);\n\t\t} else {\n\t\t\tkfree(edid);\n\t\t\tedid = ERR_PTR(-EINVAL);\n\t\t}\n\t} else {\n\t\tedid = ERR_PTR(-ENOENT);\n\t}\n\tintel_connector->edid = edid;\n\n\tfixed_mode = intel_panel_edid_fixed_mode(intel_connector);\n\tif (fixed_mode)\n\t\tdownclock_mode = intel_dp_drrs_init(intel_connector, fixed_mode);\n\n\t/* fallback to VBT if available for eDP */\n\tif (!fixed_mode)\n\t\tfixed_mode = intel_panel_vbt_fixed_mode(intel_connector);\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {\n\t\t/*\n\t\t * Figure out the current pipe for the initial backlight setup.\n\t\t * If the current pipe isn't valid, try the PPS pipe, and if that\n\t\t * fails just assume pipe A.\n\t\t */\n\t\tpipe = vlv_active_pipe(intel_dp);\n\n\t\tif (pipe != PIPE_A && pipe != PIPE_B)\n\t\t\tpipe = intel_dp->pps_pipe;\n\n\t\tif (pipe != PIPE_A && pipe != PIPE_B)\n\t\t\tpipe = PIPE_A;\n\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"using pipe %c for initial backlight setup\\n\",\n\t\t\t    pipe_name(pipe));\n\t}\n\n\tintel_panel_init(&intel_connector->panel, fixed_mode, downclock_mode);\n\tintel_connector->panel.backlight.power = intel_edp_backlight_power;\n\tintel_panel_setup_backlight(connector, pipe);\n\n\tif (fixed_mode) {\n\t\tdrm_connector_set_panel_orientation_with_quirk(connector,\n\t\t\t\tdev_priv->vbt.orientation,\n\t\t\t\tfixed_mode->hdisplay, fixed_mode->vdisplay);\n\t}\n\n\treturn true;\n\nout_vdd_off:\n\tcancel_delayed_work_sync(&intel_dp->panel_vdd_work);\n\t/*\n\t * vdd might still be enabled do to the delayed vdd off.\n\t * Make sure vdd is actually turned off here.\n\t */\n\twith_pps_lock(intel_dp, wakeref)\n\t\tedp_panel_vdd_off_sync(intel_dp);\n\n\treturn false;\n}\n\nstatic void intel_dp_modeset_retry_work_fn(struct work_struct *work)\n{\n\tstruct intel_connector *intel_connector;\n\tstruct drm_connector *connector;\n\n\tintel_connector = container_of(work, typeof(*intel_connector),\n\t\t\t\t       modeset_retry_work);\n\tconnector = &intel_connector->base;\n\tDRM_DEBUG_KMS(\"[CONNECTOR:%d:%s]\\n\", connector->base.id,\n\t\t      connector->name);\n\n\t/* Grab the locks before changing connector property*/\n\tmutex_lock(&connector->dev->mode_config.mutex);\n\t/* Set connector link status to BAD and send a Uevent to notify\n\t * userspace to do a modeset.\n\t */\n\tdrm_connector_set_link_status_property(connector,\n\t\t\t\t\t       DRM_MODE_LINK_STATUS_BAD);\n\tmutex_unlock(&connector->dev->mode_config.mutex);\n\t/* Send Hotplug uevent so userspace can reprobe */\n\tdrm_kms_helper_hotplug_event(connector->dev);\n}\n\nbool\nintel_dp_init_connector(struct intel_digital_port *dig_port,\n\t\t\tstruct intel_connector *intel_connector)\n{\n\tstruct drm_connector *connector = &intel_connector->base;\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\tstruct intel_encoder *intel_encoder = &dig_port->base;\n\tstruct drm_device *dev = intel_encoder->base.dev;\n\tstruct drm_i915_private *dev_priv = to_i915(dev);\n\tenum port port = intel_encoder->port;\n\tenum phy phy = intel_port_to_phy(dev_priv, port);\n\tint type;\n\n\t/* Initialize the work for modeset in case of link train failure */\n\tINIT_WORK(&intel_connector->modeset_retry_work,\n\t\t  intel_dp_modeset_retry_work_fn);\n\n\tif (drm_WARN(dev, dig_port->max_lanes < 1,\n\t\t     \"Not enough lanes (%d) for DP on [ENCODER:%d:%s]\\n\",\n\t\t     dig_port->max_lanes, intel_encoder->base.base.id,\n\t\t     intel_encoder->base.name))\n\t\treturn false;\n\n\tintel_dp_set_source_rates(intel_dp);\n\n\tintel_dp->reset_link_params = true;\n\tintel_dp->pps_pipe = INVALID_PIPE;\n\tintel_dp->active_pipe = INVALID_PIPE;\n\n\t/* Preserve the current hw state. */\n\tintel_dp->DP = intel_de_read(dev_priv, intel_dp->output_reg);\n\tintel_dp->attached_connector = intel_connector;\n\n\tif (intel_dp_is_port_edp(dev_priv, port)) {\n\t\t/*\n\t\t * Currently we don't support eDP on TypeC ports, although in\n\t\t * theory it could work on TypeC legacy ports.\n\t\t */\n\t\tdrm_WARN_ON(dev, intel_phy_is_tc(dev_priv, phy));\n\t\ttype = DRM_MODE_CONNECTOR_eDP;\n\t} else {\n\t\ttype = DRM_MODE_CONNECTOR_DisplayPort;\n\t}\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv))\n\t\tintel_dp->active_pipe = vlv_active_pipe(intel_dp);\n\n\t/*\n\t * For eDP we always set the encoder type to INTEL_OUTPUT_EDP, but\n\t * for DP the encoder type can be set by the caller to\n\t * INTEL_OUTPUT_UNKNOWN for DDI, so don't rewrite it.\n\t */\n\tif (type == DRM_MODE_CONNECTOR_eDP)\n\t\tintel_encoder->type = INTEL_OUTPUT_EDP;\n\n\t/* eDP only on port B and/or C on vlv/chv */\n\tif (drm_WARN_ON(dev, (IS_VALLEYVIEW(dev_priv) ||\n\t\t\t      IS_CHERRYVIEW(dev_priv)) &&\n\t\t\tintel_dp_is_edp(intel_dp) &&\n\t\t\tport != PORT_B && port != PORT_C))\n\t\treturn false;\n\n\tdrm_dbg_kms(&dev_priv->drm,\n\t\t    \"Adding %s connector on [ENCODER:%d:%s]\\n\",\n\t\t    type == DRM_MODE_CONNECTOR_eDP ? \"eDP\" : \"DP\",\n\t\t    intel_encoder->base.base.id, intel_encoder->base.name);\n\n\tdrm_connector_init(dev, connector, &intel_dp_connector_funcs, type);\n\tdrm_connector_helper_add(connector, &intel_dp_connector_helper_funcs);\n\n\tif (!HAS_GMCH(dev_priv))\n\t\tconnector->interlace_allowed = true;\n\tconnector->doublescan_allowed = 0;\n\n\tintel_connector->polled = DRM_CONNECTOR_POLL_HPD;\n\n\tintel_dp_aux_init(intel_dp);\n\n\tintel_connector_attach_encoder(intel_connector, intel_encoder);\n\n\tif (HAS_DDI(dev_priv))\n\t\tintel_connector->get_hw_state = intel_ddi_connector_get_hw_state;\n\telse\n\t\tintel_connector->get_hw_state = intel_connector_get_hw_state;\n\n\t/* init MST on ports that can support it */\n\tintel_dp_mst_encoder_init(dig_port,\n\t\t\t\t  intel_connector->base.base.id);\n\n\tif (!intel_edp_init_connector(intel_dp, intel_connector)) {\n\t\tintel_dp_aux_fini(intel_dp);\n\t\tintel_dp_mst_encoder_cleanup(dig_port);\n\t\tgoto fail;\n\t}\n\n\tintel_dp_add_properties(intel_dp, connector);\n\n\tif (is_hdcp_supported(dev_priv, port) && !intel_dp_is_edp(intel_dp)) {\n\t\tint ret = intel_dp_init_hdcp(dig_port, intel_connector);\n\t\tif (ret)\n\t\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t\t    \"HDCP init failed, skipping.\\n\");\n\t}\n\n\t/* For G4X desktop chip, PEG_BAND_GAP_DATA 3:0 must first be written\n\t * 0xd.  Failure to do so will result in spurious interrupts being\n\t * generated on the port when a cable is not attached.\n\t */\n\tif (IS_G45(dev_priv)) {\n\t\tu32 temp = intel_de_read(dev_priv, PEG_BAND_GAP_DATA);\n\t\tintel_de_write(dev_priv, PEG_BAND_GAP_DATA,\n\t\t\t       (temp & ~0xf) | 0xd);\n\t}\n\n\treturn true;\n\nfail:\n\tdrm_connector_cleanup(connector);\n\n\treturn false;\n}\n\nbool intel_dp_init(struct drm_i915_private *dev_priv,\n\t\t   i915_reg_t output_reg,\n\t\t   enum port port)\n{\n\tstruct intel_digital_port *dig_port;\n\tstruct intel_encoder *intel_encoder;\n\tstruct drm_encoder *encoder;\n\tstruct intel_connector *intel_connector;\n\n\tdig_port = kzalloc(sizeof(*dig_port), GFP_KERNEL);\n\tif (!dig_port)\n\t\treturn false;\n\n\tintel_connector = intel_connector_alloc();\n\tif (!intel_connector)\n\t\tgoto err_connector_alloc;\n\n\tintel_encoder = &dig_port->base;\n\tencoder = &intel_encoder->base;\n\n\tmutex_init(&dig_port->hdcp_mutex);\n\n\tif (drm_encoder_init(&dev_priv->drm, &intel_encoder->base,\n\t\t\t     &intel_dp_enc_funcs, DRM_MODE_ENCODER_TMDS,\n\t\t\t     \"DP %c\", port_name(port)))\n\t\tgoto err_encoder_init;\n\n\tintel_encoder->hotplug = intel_dp_hotplug;\n\tintel_encoder->compute_config = intel_dp_compute_config;\n\tintel_encoder->get_hw_state = intel_dp_get_hw_state;\n\tintel_encoder->get_config = intel_dp_get_config;\n\tintel_encoder->sync_state = intel_dp_sync_state;\n\tintel_encoder->initial_fastset_check = intel_dp_initial_fastset_check;\n\tintel_encoder->update_pipe = intel_panel_update_backlight;\n\tintel_encoder->suspend = intel_dp_encoder_suspend;\n\tintel_encoder->shutdown = intel_dp_encoder_shutdown;\n\tif (IS_CHERRYVIEW(dev_priv)) {\n\t\tintel_encoder->pre_pll_enable = chv_dp_pre_pll_enable;\n\t\tintel_encoder->pre_enable = chv_pre_enable_dp;\n\t\tintel_encoder->enable = vlv_enable_dp;\n\t\tintel_encoder->disable = vlv_disable_dp;\n\t\tintel_encoder->post_disable = chv_post_disable_dp;\n\t\tintel_encoder->post_pll_disable = chv_dp_post_pll_disable;\n\t} else if (IS_VALLEYVIEW(dev_priv)) {\n\t\tintel_encoder->pre_pll_enable = vlv_dp_pre_pll_enable;\n\t\tintel_encoder->pre_enable = vlv_pre_enable_dp;\n\t\tintel_encoder->enable = vlv_enable_dp;\n\t\tintel_encoder->disable = vlv_disable_dp;\n\t\tintel_encoder->post_disable = vlv_post_disable_dp;\n\t} else {\n\t\tintel_encoder->pre_enable = g4x_pre_enable_dp;\n\t\tintel_encoder->enable = g4x_enable_dp;\n\t\tintel_encoder->disable = g4x_disable_dp;\n\t\tintel_encoder->post_disable = g4x_post_disable_dp;\n\t}\n\n\tif ((IS_IVYBRIDGE(dev_priv) && port == PORT_A) ||\n\t    (HAS_PCH_CPT(dev_priv) && port != PORT_A))\n\t\tdig_port->dp.set_link_train = cpt_set_link_train;\n\telse\n\t\tdig_port->dp.set_link_train = g4x_set_link_train;\n\n\tif (IS_CHERRYVIEW(dev_priv))\n\t\tdig_port->dp.set_signal_levels = chv_set_signal_levels;\n\telse if (IS_VALLEYVIEW(dev_priv))\n\t\tdig_port->dp.set_signal_levels = vlv_set_signal_levels;\n\telse if (IS_IVYBRIDGE(dev_priv) && port == PORT_A)\n\t\tdig_port->dp.set_signal_levels = ivb_cpu_edp_set_signal_levels;\n\telse if (IS_GEN(dev_priv, 6) && port == PORT_A)\n\t\tdig_port->dp.set_signal_levels = snb_cpu_edp_set_signal_levels;\n\telse\n\t\tdig_port->dp.set_signal_levels = g4x_set_signal_levels;\n\n\tif (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv) ||\n\t    (HAS_PCH_SPLIT(dev_priv) && port != PORT_A)) {\n\t\tdig_port->dp.preemph_max = intel_dp_preemph_max_3;\n\t\tdig_port->dp.voltage_max = intel_dp_voltage_max_3;\n\t} else {\n\t\tdig_port->dp.preemph_max = intel_dp_preemph_max_2;\n\t\tdig_port->dp.voltage_max = intel_dp_voltage_max_2;\n\t}\n\n\tdig_port->dp.output_reg = output_reg;\n\tdig_port->max_lanes = 4;\n\n\tintel_encoder->type = INTEL_OUTPUT_DP;\n\tintel_encoder->power_domain = intel_port_to_power_domain(port);\n\tif (IS_CHERRYVIEW(dev_priv)) {\n\t\tif (port == PORT_D)\n\t\t\tintel_encoder->pipe_mask = BIT(PIPE_C);\n\t\telse\n\t\t\tintel_encoder->pipe_mask = BIT(PIPE_A) | BIT(PIPE_B);\n\t} else {\n\t\tintel_encoder->pipe_mask = ~0;\n\t}\n\tintel_encoder->cloneable = 0;\n\tintel_encoder->port = port;\n\tintel_encoder->hpd_pin = intel_hpd_pin_default(dev_priv, port);\n\n\tdig_port->hpd_pulse = intel_dp_hpd_pulse;\n\n\tif (HAS_GMCH(dev_priv)) {\n\t\tif (IS_GM45(dev_priv))\n\t\t\tdig_port->connected = gm45_digital_port_connected;\n\t\telse\n\t\t\tdig_port->connected = g4x_digital_port_connected;\n\t} else {\n\t\tif (port == PORT_A)\n\t\t\tdig_port->connected = ilk_digital_port_connected;\n\t\telse\n\t\t\tdig_port->connected = ibx_digital_port_connected;\n\t}\n\n\tif (port != PORT_A)\n\t\tintel_infoframe_init(dig_port);\n\n\tdig_port->aux_ch = intel_bios_port_aux_ch(dev_priv, port);\n\tif (!intel_dp_init_connector(dig_port, intel_connector))\n\t\tgoto err_init_connector;\n\n\treturn true;\n\nerr_init_connector:\n\tdrm_encoder_cleanup(encoder);\nerr_encoder_init:\n\tkfree(intel_connector);\nerr_connector_alloc:\n\tkfree(dig_port);\n\treturn false;\n}\n\nvoid intel_dp_mst_suspend(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\n\tfor_each_intel_encoder(&dev_priv->drm, encoder) {\n\t\tstruct intel_dp *intel_dp;\n\n\t\tif (encoder->type != INTEL_OUTPUT_DDI)\n\t\t\tcontinue;\n\n\t\tintel_dp = enc_to_intel_dp(encoder);\n\n\t\tif (!intel_dp->can_mst)\n\t\t\tcontinue;\n\n\t\tif (intel_dp->is_mst)\n\t\t\tdrm_dp_mst_topology_mgr_suspend(&intel_dp->mst_mgr);\n\t}\n}\n\nvoid intel_dp_mst_resume(struct drm_i915_private *dev_priv)\n{\n\tstruct intel_encoder *encoder;\n\n\tfor_each_intel_encoder(&dev_priv->drm, encoder) {\n\t\tstruct intel_dp *intel_dp;\n\t\tint ret;\n\n\t\tif (encoder->type != INTEL_OUTPUT_DDI)\n\t\t\tcontinue;\n\n\t\tintel_dp = enc_to_intel_dp(encoder);\n\n\t\tif (!intel_dp->can_mst)\n\t\t\tcontinue;\n\n\t\tret = drm_dp_mst_topology_mgr_resume(&intel_dp->mst_mgr,\n\t\t\t\t\t\t     true);\n\t\tif (ret) {\n\t\t\tintel_dp->is_mst = false;\n\t\t\tdrm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr,\n\t\t\t\t\t\t\tfalse);\n\t\t}\n\t}\n}\n"}}, "reports": [{"events": [{"location": {"col": 51, "file": 0, "line": 2965}, "message": "duplicated argument to & or |"}], "macros": [], "notes": [], "path": "/src/drivers/gpu/drm/i915/display/intel_dp.c", "reportHash": "7a1c8d2a9c604289692e34de1b4d58f5", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 25, "file": 0, "line": 2966}, "message": "duplicated argument to & or |"}], "macros": [], "notes": [], "path": "/src/drivers/gpu/drm/i915/display/intel_dp.c", "reportHash": "1f1083791bbb0e0cc961d5430b91ddd7", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 52, "file": 0, "line": 2966}, "message": "duplicated argument to & or |"}], "macros": [], "notes": [], "path": "/src/drivers/gpu/drm/i915/display/intel_dp.c", "reportHash": "f345dafe6c9651f359239b01ce1f44c1", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 0, "line": 2969}, "message": "duplicated argument to & or |"}], "macros": [], "notes": [], "path": "/src/drivers/gpu/drm/i915/display/intel_dp.c", "reportHash": "40c8aab1306a73b3b6a6eab386ad1344", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
