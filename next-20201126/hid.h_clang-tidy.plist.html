<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/src/drivers/hid/hid-apple.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  USB HID quirks support for Linux\n *\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>\n *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc\n *  Copyright (c) 2006-2007 Jiri Kosina\n *  Copyright (c) 2008 Jiri Slaby <jirislaby@gmail.com>\n */\n\n/*\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"hid-ids.h\"\n\n#define APPLE_RDESC_JIS\t\t0x0001\n#define APPLE_IGNORE_MOUSE\t0x0002\n#define APPLE_HAS_FN\t\t0x0004\n#define APPLE_HIDDEV\t\t0x0008\n/* 0x0010 reserved, was: APPLE_ISO_KEYBOARD */\n#define APPLE_MIGHTYMOUSE\t0x0020\n#define APPLE_INVERT_HWHEEL\t0x0040\n#define APPLE_IGNORE_HIDINPUT\t0x0080\n#define APPLE_NUMLOCK_EMULATION\t0x0100\n\n#define APPLE_FLAG_FKEY\t\t0x01\n\n#define HID_COUNTRY_INTERNATIONAL_ISO\t13\n\nstatic unsigned int fnmode = 1;\nmodule_param(fnmode, uint, 0644);\nMODULE_PARM_DESC(fnmode, \"Mode of fn key on Apple keyboards (0 = disabled, \"\n\t\t\"[1] = fkeyslast, 2 = fkeysfirst)\");\n\nstatic unsigned int iso_layout = 1;\nmodule_param(iso_layout, uint, 0644);\nMODULE_PARM_DESC(iso_layout, \"Enable/Disable hardcoded ISO-layout of the keyboard. \"\n\t\t\"(0 = disabled, [1] = enabled)\");\n\nstatic unsigned int swap_opt_cmd;\nmodule_param(swap_opt_cmd, uint, 0644);\nMODULE_PARM_DESC(swap_opt_cmd, \"Swap the Option (\\\"Alt\\\") and Command (\\\"Flag\\\") keys. \"\n\t\t\"(For people who want to keep Windows PC keyboard muscle memory. \"\n\t\t\"[0] = as-is, Mac layout. 1 = swapped, Windows layout.)\");\n\nstatic unsigned int swap_fn_leftctrl;\nmodule_param(swap_fn_leftctrl, uint, 0644);\nMODULE_PARM_DESC(swap_fn_leftctrl, \"Swap the Fn and left Control keys. \"\n\t\t\"(For people who want to keep PC keyboard muscle memory. \"\n\t\t\"[0] = as-is, Mac layout, 1 = swapped, PC layout)\");\n\nstruct apple_sc {\n\tunsigned long quirks;\n\tunsigned int fn_on;\n\tunsigned int fn_found;\n\tDECLARE_BITMAP(pressed_numlock, KEY_CNT);\n};\n\nstruct apple_key_translation {\n\tu16 from;\n\tu16 to;\n\tu8 flags;\n};\n\nstatic const struct apple_key_translation macbookair_fn_keys[] = {\n\t{ KEY_BACKSPACE, KEY_DELETE },\n\t{ KEY_ENTER,\tKEY_INSERT },\n\t{ KEY_F1,\tKEY_BRIGHTNESSDOWN, APPLE_FLAG_FKEY },\n\t{ KEY_F2,\tKEY_BRIGHTNESSUP,   APPLE_FLAG_FKEY },\n\t{ KEY_F3,\tKEY_SCALE,          APPLE_FLAG_FKEY },\n\t{ KEY_F4,\tKEY_DASHBOARD,      APPLE_FLAG_FKEY },\n\t{ KEY_F6,\tKEY_PREVIOUSSONG,   APPLE_FLAG_FKEY },\n\t{ KEY_F7,\tKEY_PLAYPAUSE,      APPLE_FLAG_FKEY },\n\t{ KEY_F8,\tKEY_NEXTSONG,       APPLE_FLAG_FKEY },\n\t{ KEY_F9,\tKEY_MUTE,           APPLE_FLAG_FKEY },\n\t{ KEY_F10,\tKEY_VOLUMEDOWN,     APPLE_FLAG_FKEY },\n\t{ KEY_F11,\tKEY_VOLUMEUP,       APPLE_FLAG_FKEY },\n\t{ KEY_F12,\tKEY_EJECTCD,        APPLE_FLAG_FKEY },\n\t{ KEY_UP,\tKEY_PAGEUP },\n\t{ KEY_DOWN,\tKEY_PAGEDOWN },\n\t{ KEY_LEFT,\tKEY_HOME },\n\t{ KEY_RIGHT,\tKEY_END },\n\t{ }\n};\n\nstatic const struct apple_key_translation apple_fn_keys[] = {\n\t{ KEY_BACKSPACE, KEY_DELETE },\n\t{ KEY_ENTER,\tKEY_INSERT },\n\t{ KEY_F1,\tKEY_BRIGHTNESSDOWN, APPLE_FLAG_FKEY },\n\t{ KEY_F2,\tKEY_BRIGHTNESSUP,   APPLE_FLAG_FKEY },\n\t{ KEY_F3,\tKEY_SCALE,          APPLE_FLAG_FKEY },\n\t{ KEY_F4,\tKEY_DASHBOARD,      APPLE_FLAG_FKEY },\n\t{ KEY_F5,\tKEY_KBDILLUMDOWN,   APPLE_FLAG_FKEY },\n\t{ KEY_F6,\tKEY_KBDILLUMUP,     APPLE_FLAG_FKEY },\n\t{ KEY_F7,\tKEY_PREVIOUSSONG,   APPLE_FLAG_FKEY },\n\t{ KEY_F8,\tKEY_PLAYPAUSE,      APPLE_FLAG_FKEY },\n\t{ KEY_F9,\tKEY_NEXTSONG,       APPLE_FLAG_FKEY },\n\t{ KEY_F10,\tKEY_MUTE,           APPLE_FLAG_FKEY },\n\t{ KEY_F11,\tKEY_VOLUMEDOWN,     APPLE_FLAG_FKEY },\n\t{ KEY_F12,\tKEY_VOLUMEUP,       APPLE_FLAG_FKEY },\n\t{ KEY_UP,\tKEY_PAGEUP },\n\t{ KEY_DOWN,\tKEY_PAGEDOWN },\n\t{ KEY_LEFT,\tKEY_HOME },\n\t{ KEY_RIGHT,\tKEY_END },\n\t{ }\n};\n\nstatic const struct apple_key_translation powerbook_fn_keys[] = {\n\t{ KEY_BACKSPACE, KEY_DELETE },\n\t{ KEY_F1,\tKEY_BRIGHTNESSDOWN,     APPLE_FLAG_FKEY },\n\t{ KEY_F2,\tKEY_BRIGHTNESSUP,       APPLE_FLAG_FKEY },\n\t{ KEY_F3,\tKEY_MUTE,               APPLE_FLAG_FKEY },\n\t{ KEY_F4,\tKEY_VOLUMEDOWN,         APPLE_FLAG_FKEY },\n\t{ KEY_F5,\tKEY_VOLUMEUP,           APPLE_FLAG_FKEY },\n\t{ KEY_F6,\tKEY_NUMLOCK,            APPLE_FLAG_FKEY },\n\t{ KEY_F7,\tKEY_SWITCHVIDEOMODE,    APPLE_FLAG_FKEY },\n\t{ KEY_F8,\tKEY_KBDILLUMTOGGLE,     APPLE_FLAG_FKEY },\n\t{ KEY_F9,\tKEY_KBDILLUMDOWN,       APPLE_FLAG_FKEY },\n\t{ KEY_F10,\tKEY_KBDILLUMUP,         APPLE_FLAG_FKEY },\n\t{ KEY_UP,\tKEY_PAGEUP },\n\t{ KEY_DOWN,\tKEY_PAGEDOWN },\n\t{ KEY_LEFT,\tKEY_HOME },\n\t{ KEY_RIGHT,\tKEY_END },\n\t{ }\n};\n\nstatic const struct apple_key_translation powerbook_numlock_keys[] = {\n\t{ KEY_J,\tKEY_KP1 },\n\t{ KEY_K,\tKEY_KP2 },\n\t{ KEY_L,\tKEY_KP3 },\n\t{ KEY_U,\tKEY_KP4 },\n\t{ KEY_I,\tKEY_KP5 },\n\t{ KEY_O,\tKEY_KP6 },\n\t{ KEY_7,\tKEY_KP7 },\n\t{ KEY_8,\tKEY_KP8 },\n\t{ KEY_9,\tKEY_KP9 },\n\t{ KEY_M,\tKEY_KP0 },\n\t{ KEY_DOT,\tKEY_KPDOT },\n\t{ KEY_SLASH,\tKEY_KPPLUS },\n\t{ KEY_SEMICOLON, KEY_KPMINUS },\n\t{ KEY_P,\tKEY_KPASTERISK },\n\t{ KEY_MINUS,\tKEY_KPEQUAL },\n\t{ KEY_0,\tKEY_KPSLASH },\n\t{ KEY_F6,\tKEY_NUMLOCK },\n\t{ KEY_KPENTER,\tKEY_KPENTER },\n\t{ KEY_BACKSPACE, KEY_BACKSPACE },\n\t{ }\n};\n\nstatic const struct apple_key_translation apple_iso_keyboard[] = {\n\t{ KEY_GRAVE,\tKEY_102ND },\n\t{ KEY_102ND,\tKEY_GRAVE },\n\t{ }\n};\n\nstatic const struct apple_key_translation swapped_option_cmd_keys[] = {\n\t{ KEY_LEFTALT,\tKEY_LEFTMETA },\n\t{ KEY_LEFTMETA,\tKEY_LEFTALT },\n\t{ KEY_RIGHTALT,\tKEY_RIGHTMETA },\n\t{ KEY_RIGHTMETA,KEY_RIGHTALT },\n\t{ }\n};\n\nstatic const struct apple_key_translation swapped_fn_leftctrl_keys[] = {\n\t{ KEY_FN, KEY_LEFTCTRL },\n\t{ }\n};\n\nstatic const struct apple_key_translation *apple_find_translation(\n\t\tconst struct apple_key_translation *table, u16 from)\n{\n\tconst struct apple_key_translation *trans;\n\n\t/* Look for the translation */\n\tfor (trans = table; trans->from; trans++)\n\t\tif (trans->from == from)\n\t\t\treturn trans;\n\n\treturn NULL;\n}\n\nstatic int hidinput_apple_event(struct hid_device *hid, struct input_dev *input,\n\t\tstruct hid_usage *usage, __s32 value)\n{\n\tstruct apple_sc *asc = hid_get_drvdata(hid);\n\tconst struct apple_key_translation *trans, *table;\n\tbool do_translate;\n\tu16 code = 0;\n\n\tu16 fn_keycode = (swap_fn_leftctrl) ? (KEY_LEFTCTRL) : (KEY_FN);\n\n\tif (usage->code == fn_keycode) {\n\t\tasc->fn_on = !!value;\n\t\tinput_event(input, usage->type, KEY_FN, value);\n\t\treturn 1;\n\t}\n\n\tif (fnmode) {\n\t\tif (hid->product >= USB_DEVICE_ID_APPLE_WELLSPRING4_ANSI &&\n\t\t\t\thid->product <= USB_DEVICE_ID_APPLE_WELLSPRING4A_JIS)\n\t\t\ttable = macbookair_fn_keys;\n\t\telse if (hid->product < 0x21d || hid->product >= 0x300)\n\t\t\ttable = powerbook_fn_keys;\n\t\telse\n\t\t\ttable = apple_fn_keys;\n\n\t\ttrans = apple_find_translation (table, usage->code);\n\n\t\tif (trans) {\n\t\t\tif (test_bit(trans->from, input->key))\n\t\t\t\tcode = trans->from;\n\t\t\telse if (test_bit(trans->to, input->key))\n\t\t\t\tcode = trans->to;\n\n\t\t\tif (!code) {\n\t\t\t\tif (trans->flags & APPLE_FLAG_FKEY) {\n\t\t\t\t\tswitch (fnmode) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tdo_translate = !asc->fn_on;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tdo_translate = asc->fn_on;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* should never happen */\n\t\t\t\t\t\tdo_translate = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdo_translate = asc->fn_on;\n\t\t\t\t}\n\n\t\t\t\tcode = do_translate ? trans->to : trans->from;\n\t\t\t}\n\n\t\t\tinput_event(input, usage->type, code, value);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (asc->quirks & APPLE_NUMLOCK_EMULATION &&\n\t\t\t\t(test_bit(usage->code, asc->pressed_numlock) ||\n\t\t\t\ttest_bit(LED_NUML, input->led))) {\n\t\t\ttrans = apple_find_translation(powerbook_numlock_keys,\n\t\t\t\t\tusage->code);\n\n\t\t\tif (trans) {\n\t\t\t\tif (value)\n\t\t\t\t\tset_bit(usage->code,\n\t\t\t\t\t\t\tasc->pressed_numlock);\n\t\t\t\telse\n\t\t\t\t\tclear_bit(usage->code,\n\t\t\t\t\t\t\tasc->pressed_numlock);\n\n\t\t\t\tinput_event(input, usage->type, trans->to,\n\t\t\t\t\t\tvalue);\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (iso_layout) {\n\t\tif (hid->country == HID_COUNTRY_INTERNATIONAL_ISO) {\n\t\t\ttrans = apple_find_translation(apple_iso_keyboard, usage->code);\n\t\t\tif (trans) {\n\t\t\t\tinput_event(input, usage->type, trans->to, value);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (swap_opt_cmd) {\n\t\ttrans = apple_find_translation(swapped_option_cmd_keys, usage->code);\n\t\tif (trans) {\n\t\t\tinput_event(input, usage->type, trans->to, value);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (swap_fn_leftctrl) {\n\t\ttrans = apple_find_translation(swapped_fn_leftctrl_keys, usage->code);\n\t\tif (trans) {\n\t\t\tinput_event(input, usage->type, trans->to, value);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int apple_event(struct hid_device *hdev, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value)\n{\n\tstruct apple_sc *asc = hid_get_drvdata(hdev);\n\n\tif (!(hdev->claimed & HID_CLAIMED_INPUT) || !field->hidinput ||\n\t\t\t!usage->type)\n\t\treturn 0;\n\n\tif ((asc->quirks & APPLE_INVERT_HWHEEL) &&\n\t\t\tusage->code == REL_HWHEEL) {\n\t\tinput_event(field->hidinput->input, usage->type, usage->code,\n\t\t\t\t-value);\n\t\treturn 1;\n\t}\n\n\tif ((asc->quirks & APPLE_HAS_FN) &&\n\t\t\thidinput_apple_event(hdev, field->hidinput->input,\n\t\t\t\tusage, value))\n\t\treturn 1;\n\n\n\treturn 0;\n}\n\n/*\n * MacBook JIS keyboard has wrong logical maximum\n */\nstatic __u8 *apple_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tstruct apple_sc *asc = hid_get_drvdata(hdev);\n\n\tif ((asc->quirks & APPLE_RDESC_JIS) && *rsize >= 60 &&\n\t\t\trdesc[53] == 0x65 && rdesc[59] == 0x65) {\n\t\thid_info(hdev,\n\t\t\t \"fixing up MacBook JIS keyboard report descriptor\\n\");\n\t\trdesc[53] = rdesc[59] = 0xe7;\n\t}\n\treturn rdesc;\n}\n\nstatic void apple_setup_input(struct input_dev *input)\n{\n\tconst struct apple_key_translation *trans;\n\n\tset_bit(KEY_NUMLOCK, input->keybit);\n\n\t/* Enable all needed keys */\n\tfor (trans = apple_fn_keys; trans->from; trans++)\n\t\tset_bit(trans->to, input->keybit);\n\n\tfor (trans = powerbook_fn_keys; trans->from; trans++)\n\t\tset_bit(trans->to, input->keybit);\n\n\tfor (trans = powerbook_numlock_keys; trans->from; trans++)\n\t\tset_bit(trans->to, input->keybit);\n\n\tfor (trans = apple_iso_keyboard; trans->from; trans++)\n\t\tset_bit(trans->to, input->keybit);\n\n\tif (swap_fn_leftctrl) {\n\t\tfor (trans = swapped_fn_leftctrl_keys; trans->from; trans++)\n\t\t\tset_bit(trans->to, input->keybit);\n\t}\n}\n\nstatic int apple_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tstruct apple_sc *asc = hid_get_drvdata(hdev);\n\n\tif (usage->hid == (HID_UP_CUSTOM | 0x0003) ||\n\t\t\tusage->hid == (HID_UP_MSVENDOR | 0x0003) ||\n\t\t\tusage->hid == (HID_UP_HPVENDOR2 | 0x0003)) {\n\t\t/* The fn key on Apple USB keyboards */\n\t\tset_bit(EV_REP, hi->input->evbit);\n\t\thid_map_usage_clear(hi, usage, bit, max, EV_KEY, KEY_FN);\n\t\tasc->fn_found = true;\n\t\tapple_setup_input(hi->input);\n\t\treturn 1;\n\t}\n\n\t/* we want the hid layer to go through standard path (set and ignore) */\n\treturn 0;\n}\n\nstatic int apple_input_mapped(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tstruct apple_sc *asc = hid_get_drvdata(hdev);\n\n\tif (asc->quirks & APPLE_MIGHTYMOUSE) {\n\t\tif (usage->hid == HID_GD_Z)\n\t\t\thid_map_usage(hi, usage, bit, max, EV_REL, REL_HWHEEL);\n\t\telse if (usage->code == BTN_1)\n\t\t\thid_map_usage(hi, usage, bit, max, EV_KEY, BTN_2);\n\t\telse if (usage->code == BTN_2)\n\t\t\thid_map_usage(hi, usage, bit, max, EV_KEY, BTN_1);\n\t}\n\n\treturn 0;\n}\n\nstatic int apple_input_configured(struct hid_device *hdev,\n\t\tstruct hid_input *hidinput)\n{\n\tstruct apple_sc *asc = hid_get_drvdata(hdev);\n\n\tif ((asc->quirks & APPLE_HAS_FN) && !asc->fn_found) {\n\t\thid_info(hdev, \"Fn key not found (Apple Wireless Keyboard clone?), disabling Fn key handling\\n\");\n\t\tasc->quirks = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int apple_probe(struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\tunsigned long quirks = id->driver_data;\n\tstruct apple_sc *asc;\n\tunsigned int connect_mask = HID_CONNECT_DEFAULT;\n\tint ret;\n\n\tasc = devm_kzalloc(&hdev->dev, sizeof(*asc), GFP_KERNEL);\n\tif (asc == NULL) {\n\t\thid_err(hdev, \"can't alloc apple descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tasc->quirks = quirks;\n\n\thid_set_drvdata(hdev, asc);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (quirks & APPLE_HIDDEV)\n\t\tconnect_mask |= HID_CONNECT_HIDDEV_FORCE;\n\tif (quirks & APPLE_IGNORE_HIDINPUT)\n\t\tconnect_mask &= ~HID_CONNECT_HIDINPUT;\n\n\tret = hid_hw_start(hdev, connect_mask);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hid_device_id apple_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MIGHTYMOUSE),\n\t\t.driver_data = APPLE_MIGHTYMOUSE | APPLE_INVERT_HWHEEL },\n\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_ANSI),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_ISO),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_ANSI),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_ISO),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_JIS),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_ANSI),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_ISO),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_JIS),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN |\n\t\t\tAPPLE_RDESC_JIS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_ANSI),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_ISO),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_JIS),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN |\n\t\t\tAPPLE_RDESC_JIS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_MINI_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_MINI_ISO),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_MINI_JIS),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_ISO),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_JIS),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_ANSI),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_ISO),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER4_HF_JIS),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN |\n\t\t\tAPPLE_RDESC_JIS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_REVB_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_REVB_ISO),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_REVB_ISO),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_REVB_JIS),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_ANSI),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_ISO),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ISO),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,\n\t\t\t\tUSB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,\n\t\t\t\tUSB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_JIS),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_JIS),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGIC_KEYBOARD_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_BLUETOOTH_DEVICE(BT_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGIC_KEYBOARD_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGIC_KEYBOARD_NUMPAD_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_BLUETOOTH_DEVICE(BT_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGIC_KEYBOARD_NUMPAD_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING_ISO),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING_JIS),\n\t\t.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING2_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING2_ISO),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING2_JIS),\n\t\t.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_ISO),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING3_JIS),\n\t\t.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4_ISO),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4_JIS),\n\t\t.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4A_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4A_ISO),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING4A_JIS),\n\t\t.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_ISO),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5_JIS),\n\t\t.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6_ISO),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6_JIS),\n\t\t.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_ISO),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING6A_JIS),\n\t\t.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5A_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5A_ISO),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING5A_JIS),\n\t\t.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_ISO),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7_JIS),\n\t\t.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_ISO),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING7A_JIS),\n\t\t.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_ISO),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING8_JIS),\n\t\t.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING9_ANSI),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING9_ISO),\n\t\t.driver_data = APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_WELLSPRING9_JIS),\n\t\t.driver_data = APPLE_HAS_FN | APPLE_RDESC_JIS },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_JIS),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY),\n\t\t.driver_data = APPLE_NUMLOCK_EMULATION | APPLE_HAS_FN },\n\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, apple_devices);\n\nstatic struct hid_driver apple_driver = {\n\t.name = \"apple\",\n\t.id_table = apple_devices,\n\t.report_fixup = apple_report_fixup,\n\t.probe = apple_probe,\n\t.event = apple_event,\n\t.input_mapping = apple_input_mapping,\n\t.input_mapped = apple_input_mapped,\n\t.input_configured = apple_input_configured,\n};\nmodule_hid_driver(apple_driver);\n\nMODULE_LICENSE(\"GPL\");\n"}, "0": {"id": 0, "path": "/src/include/linux/hid.h", "content": "/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2001 Vojtech Pavlik\n *  Copyright (c) 2006-2007 Jiri Kosina\n */\n/*\n *\n * Should you need to contact me, the author, you can do so either by\n * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:\n * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic\n */\n#ifndef __HID_H\n#define __HID_H\n\n\n#include <linux/bitops.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/mod_devicetable.h> /* hid_device_id */\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#include <linux/input.h>\n#include <linux/semaphore.h>\n#include <linux/mutex.h>\n#include <linux/power_supply.h>\n#include <uapi/linux/hid.h>\n\n/*\n * We parse each description item into this structure. Short items data\n * values are expanded to 32-bit signed int, long items contain a pointer\n * into the data area.\n */\n\nstruct hid_item {\n\tunsigned  format;\n\t__u8      size;\n\t__u8      type;\n\t__u8      tag;\n\tunion {\n\t    __u8   u8;\n\t    __s8   s8;\n\t    __u16  u16;\n\t    __s16  s16;\n\t    __u32  u32;\n\t    __s32  s32;\n\t    __u8  *longdata;\n\t} data;\n};\n\n/*\n * HID report item format\n */\n\n#define HID_ITEM_FORMAT_SHORT\t0\n#define HID_ITEM_FORMAT_LONG\t1\n\n/*\n * Special tag indicating long items\n */\n\n#define HID_ITEM_TAG_LONG\t15\n\n/*\n * HID report descriptor item type (prefix bit 2,3)\n */\n\n#define HID_ITEM_TYPE_MAIN\t\t0\n#define HID_ITEM_TYPE_GLOBAL\t\t1\n#define HID_ITEM_TYPE_LOCAL\t\t2\n#define HID_ITEM_TYPE_RESERVED\t\t3\n\n/*\n * HID report descriptor main item tags\n */\n\n#define HID_MAIN_ITEM_TAG_INPUT\t\t\t8\n#define HID_MAIN_ITEM_TAG_OUTPUT\t\t9\n#define HID_MAIN_ITEM_TAG_FEATURE\t\t11\n#define HID_MAIN_ITEM_TAG_BEGIN_COLLECTION\t10\n#define HID_MAIN_ITEM_TAG_END_COLLECTION\t12\n\n/*\n * HID report descriptor main item contents\n */\n\n#define HID_MAIN_ITEM_CONSTANT\t\t0x001\n#define HID_MAIN_ITEM_VARIABLE\t\t0x002\n#define HID_MAIN_ITEM_RELATIVE\t\t0x004\n#define HID_MAIN_ITEM_WRAP\t\t0x008\n#define HID_MAIN_ITEM_NONLINEAR\t\t0x010\n#define HID_MAIN_ITEM_NO_PREFERRED\t0x020\n#define HID_MAIN_ITEM_NULL_STATE\t0x040\n#define HID_MAIN_ITEM_VOLATILE\t\t0x080\n#define HID_MAIN_ITEM_BUFFERED_BYTE\t0x100\n\n/*\n * HID report descriptor collection item types\n */\n\n#define HID_COLLECTION_PHYSICAL\t\t0\n#define HID_COLLECTION_APPLICATION\t1\n#define HID_COLLECTION_LOGICAL\t\t2\n\n/*\n * HID report descriptor global item tags\n */\n\n#define HID_GLOBAL_ITEM_TAG_USAGE_PAGE\t\t0\n#define HID_GLOBAL_ITEM_TAG_LOGICAL_MINIMUM\t1\n#define HID_GLOBAL_ITEM_TAG_LOGICAL_MAXIMUM\t2\n#define HID_GLOBAL_ITEM_TAG_PHYSICAL_MINIMUM\t3\n#define HID_GLOBAL_ITEM_TAG_PHYSICAL_MAXIMUM\t4\n#define HID_GLOBAL_ITEM_TAG_UNIT_EXPONENT\t5\n#define HID_GLOBAL_ITEM_TAG_UNIT\t\t6\n#define HID_GLOBAL_ITEM_TAG_REPORT_SIZE\t\t7\n#define HID_GLOBAL_ITEM_TAG_REPORT_ID\t\t8\n#define HID_GLOBAL_ITEM_TAG_REPORT_COUNT\t9\n#define HID_GLOBAL_ITEM_TAG_PUSH\t\t10\n#define HID_GLOBAL_ITEM_TAG_POP\t\t\t11\n\n/*\n * HID report descriptor local item tags\n */\n\n#define HID_LOCAL_ITEM_TAG_USAGE\t\t0\n#define HID_LOCAL_ITEM_TAG_USAGE_MINIMUM\t1\n#define HID_LOCAL_ITEM_TAG_USAGE_MAXIMUM\t2\n#define HID_LOCAL_ITEM_TAG_DESIGNATOR_INDEX\t3\n#define HID_LOCAL_ITEM_TAG_DESIGNATOR_MINIMUM\t4\n#define HID_LOCAL_ITEM_TAG_DESIGNATOR_MAXIMUM\t5\n#define HID_LOCAL_ITEM_TAG_STRING_INDEX\t\t7\n#define HID_LOCAL_ITEM_TAG_STRING_MINIMUM\t8\n#define HID_LOCAL_ITEM_TAG_STRING_MAXIMUM\t9\n#define HID_LOCAL_ITEM_TAG_DELIMITER\t\t10\n\n/*\n * HID usage tables\n */\n\n#define HID_USAGE_PAGE\t\t0xffff0000\n\n#define HID_UP_UNDEFINED\t0x00000000\n#define HID_UP_GENDESK\t\t0x00010000\n#define HID_UP_SIMULATION\t0x00020000\n#define HID_UP_GENDEVCTRLS\t0x00060000\n#define HID_UP_KEYBOARD\t\t0x00070000\n#define HID_UP_LED\t\t0x00080000\n#define HID_UP_BUTTON\t\t0x00090000\n#define HID_UP_ORDINAL\t\t0x000a0000\n#define HID_UP_TELEPHONY\t0x000b0000\n#define HID_UP_CONSUMER\t\t0x000c0000\n#define HID_UP_DIGITIZER\t0x000d0000\n#define HID_UP_PID\t\t0x000f0000\n#define HID_UP_HPVENDOR         0xff7f0000\n#define HID_UP_HPVENDOR2        0xff010000\n#define HID_UP_MSVENDOR\t\t0xff000000\n#define HID_UP_CUSTOM\t\t0x00ff0000\n#define HID_UP_LOGIVENDOR\t0xffbc0000\n#define HID_UP_LOGIVENDOR2   0xff090000\n#define HID_UP_LOGIVENDOR3   0xff430000\n#define HID_UP_LNVENDOR\t\t0xffa00000\n#define HID_UP_SENSOR\t\t0x00200000\n#define HID_UP_ASUSVENDOR\t0xff310000\n#define HID_UP_GOOGLEVENDOR\t0xffd10000\n\n#define HID_USAGE\t\t0x0000ffff\n\n#define HID_GD_POINTER\t\t0x00010001\n#define HID_GD_MOUSE\t\t0x00010002\n#define HID_GD_JOYSTICK\t\t0x00010004\n#define HID_GD_GAMEPAD\t\t0x00010005\n#define HID_GD_KEYBOARD\t\t0x00010006\n#define HID_GD_KEYPAD\t\t0x00010007\n#define HID_GD_MULTIAXIS\t0x00010008\n/*\n * Microsoft Win8 Wireless Radio Controls extensions CA, see:\n * http://www.usb.org/developers/hidpage/HUTRR40RadioHIDUsagesFinal.pdf\n */\n#define HID_GD_WIRELESS_RADIO_CTLS\t0x0001000c\n/*\n * System Multi-Axis, see:\n * http://www.usb.org/developers/hidpage/HUTRR62_-_Generic_Desktop_CA_for_System_Multi-Axis_Controllers.txt\n */\n#define HID_GD_SYSTEM_MULTIAXIS\t0x0001000e\n\n#define HID_GD_X\t\t0x00010030\n#define HID_GD_Y\t\t0x00010031\n#define HID_GD_Z\t\t0x00010032\n#define HID_GD_RX\t\t0x00010033\n#define HID_GD_RY\t\t0x00010034\n#define HID_GD_RZ\t\t0x00010035\n#define HID_GD_SLIDER\t\t0x00010036\n#define HID_GD_DIAL\t\t0x00010037\n#define HID_GD_WHEEL\t\t0x00010038\n#define HID_GD_HATSWITCH\t0x00010039\n#define HID_GD_BUFFER\t\t0x0001003a\n#define HID_GD_BYTECOUNT\t0x0001003b\n#define HID_GD_MOTION\t\t0x0001003c\n#define HID_GD_START\t\t0x0001003d\n#define HID_GD_SELECT\t\t0x0001003e\n#define HID_GD_VX\t\t0x00010040\n#define HID_GD_VY\t\t0x00010041\n#define HID_GD_VZ\t\t0x00010042\n#define HID_GD_VBRX\t\t0x00010043\n#define HID_GD_VBRY\t\t0x00010044\n#define HID_GD_VBRZ\t\t0x00010045\n#define HID_GD_VNO\t\t0x00010046\n#define HID_GD_FEATURE\t\t0x00010047\n#define HID_GD_RESOLUTION_MULTIPLIER\t0x00010048\n#define HID_GD_SYSTEM_CONTROL\t0x00010080\n#define HID_GD_UP\t\t0x00010090\n#define HID_GD_DOWN\t\t0x00010091\n#define HID_GD_RIGHT\t\t0x00010092\n#define HID_GD_LEFT\t\t0x00010093\n/* Microsoft Win8 Wireless Radio Controls CA usage codes */\n#define HID_GD_RFKILL_BTN\t0x000100c6\n#define HID_GD_RFKILL_LED\t0x000100c7\n#define HID_GD_RFKILL_SWITCH\t0x000100c8\n\n#define HID_DC_BATTERYSTRENGTH\t0x00060020\n\n#define HID_CP_CONSUMER_CONTROL\t0x000c0001\n#define HID_CP_AC_PAN\t\t0x000c0238\n\n#define HID_DG_DIGITIZER\t0x000d0001\n#define HID_DG_PEN\t\t0x000d0002\n#define HID_DG_LIGHTPEN\t\t0x000d0003\n#define HID_DG_TOUCHSCREEN\t0x000d0004\n#define HID_DG_TOUCHPAD\t\t0x000d0005\n#define HID_DG_WHITEBOARD\t0x000d0006\n#define HID_DG_STYLUS\t\t0x000d0020\n#define HID_DG_PUCK\t\t0x000d0021\n#define HID_DG_FINGER\t\t0x000d0022\n#define HID_DG_TIPPRESSURE\t0x000d0030\n#define HID_DG_BARRELPRESSURE\t0x000d0031\n#define HID_DG_INRANGE\t\t0x000d0032\n#define HID_DG_TOUCH\t\t0x000d0033\n#define HID_DG_UNTOUCH\t\t0x000d0034\n#define HID_DG_TAP\t\t0x000d0035\n#define HID_DG_TABLETFUNCTIONKEY\t0x000d0039\n#define HID_DG_PROGRAMCHANGEKEY\t0x000d003a\n#define HID_DG_BATTERYSTRENGTH\t0x000d003b\n#define HID_DG_INVERT\t\t0x000d003c\n#define HID_DG_TILT_X\t\t0x000d003d\n#define HID_DG_TILT_Y\t\t0x000d003e\n#define HID_DG_TWIST\t\t0x000d0041\n#define HID_DG_TIPSWITCH\t0x000d0042\n#define HID_DG_TIPSWITCH2\t0x000d0043\n#define HID_DG_BARRELSWITCH\t0x000d0044\n#define HID_DG_ERASER\t\t0x000d0045\n#define HID_DG_TABLETPICK\t0x000d0046\n\n#define HID_CP_CONSUMERCONTROL\t0x000c0001\n#define HID_CP_NUMERICKEYPAD\t0x000c0002\n#define HID_CP_PROGRAMMABLEBUTTONS\t0x000c0003\n#define HID_CP_MICROPHONE\t0x000c0004\n#define HID_CP_HEADPHONE\t0x000c0005\n#define HID_CP_GRAPHICEQUALIZER\t0x000c0006\n#define HID_CP_FUNCTIONBUTTONS\t0x000c0036\n#define HID_CP_SELECTION\t0x000c0080\n#define HID_CP_MEDIASELECTION\t0x000c0087\n#define HID_CP_SELECTDISC\t0x000c00ba\n#define HID_CP_PLAYBACKSPEED\t0x000c00f1\n#define HID_CP_PROXIMITY\t0x000c0109\n#define HID_CP_SPEAKERSYSTEM\t0x000c0160\n#define HID_CP_CHANNELLEFT\t0x000c0161\n#define HID_CP_CHANNELRIGHT\t0x000c0162\n#define HID_CP_CHANNELCENTER\t0x000c0163\n#define HID_CP_CHANNELFRONT\t0x000c0164\n#define HID_CP_CHANNELCENTERFRONT\t0x000c0165\n#define HID_CP_CHANNELSIDE\t0x000c0166\n#define HID_CP_CHANNELSURROUND\t0x000c0167\n#define HID_CP_CHANNELLOWFREQUENCYENHANCEMENT\t0x000c0168\n#define HID_CP_CHANNELTOP\t0x000c0169\n#define HID_CP_CHANNELUNKNOWN\t0x000c016a\n#define HID_CP_APPLICATIONLAUNCHBUTTONS\t0x000c0180\n#define HID_CP_GENERICGUIAPPLICATIONCONTROLS\t0x000c0200\n\n#define HID_DG_DEVICECONFIG\t0x000d000e\n#define HID_DG_DEVICESETTINGS\t0x000d0023\n#define HID_DG_AZIMUTH\t\t0x000d003f\n#define HID_DG_CONFIDENCE\t0x000d0047\n#define HID_DG_WIDTH\t\t0x000d0048\n#define HID_DG_HEIGHT\t\t0x000d0049\n#define HID_DG_CONTACTID\t0x000d0051\n#define HID_DG_INPUTMODE\t0x000d0052\n#define HID_DG_DEVICEINDEX\t0x000d0053\n#define HID_DG_CONTACTCOUNT\t0x000d0054\n#define HID_DG_CONTACTMAX\t0x000d0055\n#define HID_DG_SCANTIME\t\t0x000d0056\n#define HID_DG_SURFACESWITCH\t0x000d0057\n#define HID_DG_BUTTONSWITCH\t0x000d0058\n#define HID_DG_BUTTONTYPE\t0x000d0059\n#define HID_DG_BARRELSWITCH2\t0x000d005a\n#define HID_DG_TOOLSERIALNUMBER\t0x000d005b\n#define HID_DG_LATENCYMODE\t0x000d0060\n\n#define HID_VD_ASUS_CUSTOM_MEDIA_KEYS\t0xff310076\n/*\n * HID report types --- Ouch! HID spec says 1 2 3!\n */\n\n#define HID_INPUT_REPORT\t0\n#define HID_OUTPUT_REPORT\t1\n#define HID_FEATURE_REPORT\t2\n\n#define HID_REPORT_TYPES\t3\n\n/*\n * HID connect requests\n */\n\n#define HID_CONNECT_HIDINPUT\t\tBIT(0)\n#define HID_CONNECT_HIDINPUT_FORCE\tBIT(1)\n#define HID_CONNECT_HIDRAW\t\tBIT(2)\n#define HID_CONNECT_HIDDEV\t\tBIT(3)\n#define HID_CONNECT_HIDDEV_FORCE\tBIT(4)\n#define HID_CONNECT_FF\t\t\tBIT(5)\n#define HID_CONNECT_DRIVER\t\tBIT(6)\n#define HID_CONNECT_DEFAULT\t(HID_CONNECT_HIDINPUT|HID_CONNECT_HIDRAW| \\\n\t\tHID_CONNECT_HIDDEV|HID_CONNECT_FF)\n\n/*\n * HID device quirks.\n */\n\n/* \n * Increase this if you need to configure more HID quirks at module load time\n */\n#define MAX_USBHID_BOOT_QUIRKS 4\n\n#define HID_QUIRK_INVERT\t\t\tBIT(0)\n#define HID_QUIRK_NOTOUCH\t\t\tBIT(1)\n#define HID_QUIRK_IGNORE\t\t\tBIT(2)\n#define HID_QUIRK_NOGET\t\t\t\tBIT(3)\n#define HID_QUIRK_HIDDEV_FORCE\t\t\tBIT(4)\n#define HID_QUIRK_BADPAD\t\t\tBIT(5)\n#define HID_QUIRK_MULTI_INPUT\t\t\tBIT(6)\n#define HID_QUIRK_HIDINPUT_FORCE\t\tBIT(7)\n/* BIT(8) reserved for backward compatibility, was HID_QUIRK_NO_EMPTY_INPUT */\n/* BIT(9) reserved for backward compatibility, was NO_INIT_INPUT_REPORTS */\n#define HID_QUIRK_ALWAYS_POLL\t\t\tBIT(10)\n#define HID_QUIRK_INPUT_PER_APP\t\t\tBIT(11)\n#define HID_QUIRK_SKIP_OUTPUT_REPORTS\t\tBIT(16)\n#define HID_QUIRK_SKIP_OUTPUT_REPORT_ID\t\tBIT(17)\n#define HID_QUIRK_NO_OUTPUT_REPORTS_ON_INTR_EP\tBIT(18)\n#define HID_QUIRK_HAVE_SPECIAL_DRIVER\t\tBIT(19)\n#define HID_QUIRK_INCREMENT_USAGE_ON_DUPLICATE\tBIT(20)\n#define HID_QUIRK_FULLSPEED_INTERVAL\t\tBIT(28)\n#define HID_QUIRK_NO_INIT_REPORTS\t\tBIT(29)\n#define HID_QUIRK_NO_IGNORE\t\t\tBIT(30)\n#define HID_QUIRK_NO_INPUT_SYNC\t\t\tBIT(31)\n\n/*\n * HID device groups\n *\n * Note: HID_GROUP_ANY is declared in linux/mod_devicetable.h\n * and has a value of 0x0000\n */\n#define HID_GROUP_GENERIC\t\t\t0x0001\n#define HID_GROUP_MULTITOUCH\t\t\t0x0002\n#define HID_GROUP_SENSOR_HUB\t\t\t0x0003\n#define HID_GROUP_MULTITOUCH_WIN_8\t\t0x0004\n\n/*\n * Vendor specific HID device groups\n */\n#define HID_GROUP_RMI\t\t\t\t0x0100\n#define HID_GROUP_WACOM\t\t\t\t0x0101\n#define HID_GROUP_LOGITECH_DJ_DEVICE\t\t0x0102\n#define HID_GROUP_STEAM\t\t\t\t0x0103\n#define HID_GROUP_LOGITECH_27MHZ_DEVICE\t\t0x0104\n#define HID_GROUP_VIVALDI\t\t\t0x0105\n\n/*\n * HID protocol status\n */\n#define HID_REPORT_PROTOCOL\t1\n#define HID_BOOT_PROTOCOL\t0\n\n/*\n * This is the global environment of the parser. This information is\n * persistent for main-items. The global environment can be saved and\n * restored with PUSH/POP statements.\n */\n\nstruct hid_global {\n\tunsigned usage_page;\n\t__s32    logical_minimum;\n\t__s32    logical_maximum;\n\t__s32    physical_minimum;\n\t__s32    physical_maximum;\n\t__s32    unit_exponent;\n\tunsigned unit;\n\tunsigned report_id;\n\tunsigned report_size;\n\tunsigned report_count;\n};\n\n/*\n * This is the local environment. It is persistent up the next main-item.\n */\n\n#define HID_MAX_USAGES\t\t\t12288\n#define HID_DEFAULT_NUM_COLLECTIONS\t16\n\nstruct hid_local {\n\tunsigned usage[HID_MAX_USAGES]; /* usage array */\n\tu8 usage_size[HID_MAX_USAGES]; /* usage size array */\n\tunsigned collection_index[HID_MAX_USAGES]; /* collection index array */\n\tunsigned usage_index;\n\tunsigned usage_minimum;\n\tunsigned delimiter_depth;\n\tunsigned delimiter_branch;\n};\n\n/*\n * This is the collection stack. We climb up the stack to determine\n * application and function of each field.\n */\n\nstruct hid_collection {\n\tint parent_idx; /* device->collection */\n\tunsigned type;\n\tunsigned usage;\n\tunsigned level;\n};\n\nstruct hid_usage {\n\tunsigned  hid;\t\t\t/* hid usage code */\n\tunsigned  collection_index;\t/* index into collection array */\n\tunsigned  usage_index;\t\t/* index into usage array */\n\t__s8\t  resolution_multiplier;/* Effective Resolution Multiplier\n\t\t\t\t\t   (HUT v1.12, 4.3.1), default: 1 */\n\t/* hidinput data */\n\t__s8\t  wheel_factor;\t\t/* 120/resolution_multiplier */\n\t__u16     code;\t\t\t/* input driver code */\n\t__u8      type;\t\t\t/* input driver type */\n\t__s8\t  hat_min;\t\t/* hat switch fun */\n\t__s8\t  hat_max;\t\t/* ditto */\n\t__s8\t  hat_dir;\t\t/* ditto */\n\t__s16\t  wheel_accumulated;\t/* hi-res wheel */\n};\n\nstruct hid_input;\n\nstruct hid_field {\n\tunsigned  physical;\t\t/* physical usage for this field */\n\tunsigned  logical;\t\t/* logical usage for this field */\n\tunsigned  application;\t\t/* application usage for this field */\n\tstruct hid_usage *usage;\t/* usage table for this function */\n\tunsigned  maxusage;\t\t/* maximum usage index */\n\tunsigned  flags;\t\t/* main-item flags (i.e. volatile,array,constant) */\n\tunsigned  report_offset;\t/* bit offset in the report */\n\tunsigned  report_size;\t\t/* size of this field in the report */\n\tunsigned  report_count;\t\t/* number of this field in the report */\n\tunsigned  report_type;\t\t/* (input,output,feature) */\n\t__s32    *value;\t\t/* last known value(s) */\n\t__s32     logical_minimum;\n\t__s32     logical_maximum;\n\t__s32     physical_minimum;\n\t__s32     physical_maximum;\n\t__s32     unit_exponent;\n\tunsigned  unit;\n\tstruct hid_report *report;\t/* associated report */\n\tunsigned index;\t\t\t/* index into report->field[] */\n\t/* hidinput data */\n\tstruct hid_input *hidinput;\t/* associated input structure */\n\t__u16 dpad;\t\t\t/* dpad input code */\n};\n\n#define HID_MAX_FIELDS 256\n\nstruct hid_report {\n\tstruct list_head list;\n\tstruct list_head hidinput_list;\n\tunsigned int id;\t\t\t\t/* id of this report */\n\tunsigned int type;\t\t\t\t/* report type */\n\tunsigned int application;\t\t\t/* application usage for this report */\n\tstruct hid_field *field[HID_MAX_FIELDS];\t/* fields of the report */\n\tunsigned maxfield;\t\t\t\t/* maximum valid field index */\n\tunsigned size;\t\t\t\t\t/* size of the report (bits) */\n\tstruct hid_device *device;\t\t\t/* associated device */\n};\n\n#define HID_MAX_IDS 256\n\nstruct hid_report_enum {\n\tunsigned numbered;\n\tstruct list_head report_list;\n\tstruct hid_report *report_id_hash[HID_MAX_IDS];\n};\n\n#define HID_MIN_BUFFER_SIZE\t64\t\t/* make sure there is at least a packet size of space */\n#define HID_MAX_BUFFER_SIZE\t8192\t\t/* 8kb */\n#define HID_CONTROL_FIFO_SIZE\t256\t\t/* to init devices with >100 reports */\n#define HID_OUTPUT_FIFO_SIZE\t64\n\nstruct hid_control_fifo {\n\tunsigned char dir;\n\tstruct hid_report *report;\n\tchar *raw_report;\n};\n\nstruct hid_output_fifo {\n\tstruct hid_report *report;\n\tchar *raw_report;\n};\n\n#define HID_CLAIMED_INPUT\tBIT(0)\n#define HID_CLAIMED_HIDDEV\tBIT(1)\n#define HID_CLAIMED_HIDRAW\tBIT(2)\n#define HID_CLAIMED_DRIVER\tBIT(3)\n\n#define HID_STAT_ADDED\t\tBIT(0)\n#define HID_STAT_PARSED\t\tBIT(1)\n#define HID_STAT_DUP_DETECTED\tBIT(2)\n#define HID_STAT_REPROBED\tBIT(3)\n\nstruct hid_input {\n\tstruct list_head list;\n\tstruct hid_report *report;\n\tstruct input_dev *input;\n\tconst char *name;\n\tbool registered;\n\tstruct list_head reports;\t/* the list of reports */\n\tunsigned int application;\t/* application usage for this input */\n};\n\nenum hid_type {\n\tHID_TYPE_OTHER = 0,\n\tHID_TYPE_USBMOUSE,\n\tHID_TYPE_USBNONE\n};\n\nenum hid_battery_status {\n\tHID_BATTERY_UNKNOWN = 0,\n\tHID_BATTERY_QUERIED,\t\t/* Kernel explicitly queried battery strength */\n\tHID_BATTERY_REPORTED,\t\t/* Device sent unsolicited battery strength report */\n};\n\nstruct hid_driver;\nstruct hid_ll_driver;\n\nstruct hid_device {\t\t\t\t\t\t\t/* device report descriptor */\n\t__u8 *dev_rdesc;\n\tunsigned dev_rsize;\n\t__u8 *rdesc;\n\tunsigned rsize;\n\tstruct hid_collection *collection;\t\t\t\t/* List of HID collections */\n\tunsigned collection_size;\t\t\t\t\t/* Number of allocated hid_collections */\n\tunsigned maxcollection;\t\t\t\t\t\t/* Number of parsed collections */\n\tunsigned maxapplication;\t\t\t\t\t/* Number of applications */\n\t__u16 bus;\t\t\t\t\t\t\t/* BUS ID */\n\t__u16 group;\t\t\t\t\t\t\t/* Report group */\n\t__u32 vendor;\t\t\t\t\t\t\t/* Vendor ID */\n\t__u32 product;\t\t\t\t\t\t\t/* Product ID */\n\t__u32 version;\t\t\t\t\t\t\t/* HID version */\n\tenum hid_type type;\t\t\t\t\t\t/* device type (mouse, kbd, ...) */\n\tunsigned country;\t\t\t\t\t\t/* HID country */\n\tstruct hid_report_enum report_enum[HID_REPORT_TYPES];\n\tstruct work_struct led_work;\t\t\t\t\t/* delayed LED worker */\n\n\tstruct semaphore driver_input_lock;\t\t\t\t/* protects the current driver */\n\tstruct device dev;\t\t\t\t\t\t/* device */\n\tstruct hid_driver *driver;\n\n\tstruct hid_ll_driver *ll_driver;\n\tstruct mutex ll_open_lock;\n\tunsigned int ll_open_count;\n\n#ifdef CONFIG_HID_BATTERY_STRENGTH\n\t/*\n\t * Power supply information for HID devices which report\n\t * battery strength. power_supply was successfully registered if\n\t * battery is non-NULL.\n\t */\n\tstruct power_supply *battery;\n\t__s32 battery_capacity;\n\t__s32 battery_min;\n\t__s32 battery_max;\n\t__s32 battery_report_type;\n\t__s32 battery_report_id;\n\tenum hid_battery_status battery_status;\n\tbool battery_avoid_query;\n\tktime_t battery_ratelimit_time;\n#endif\n\n\tunsigned long status;\t\t\t\t\t\t/* see STAT flags above */\n\tunsigned claimed;\t\t\t\t\t\t/* Claimed by hidinput, hiddev? */\n\tunsigned quirks;\t\t\t\t\t\t/* Various quirks the device can pull on us */\n\tbool io_started;\t\t\t\t\t\t/* If IO has started */\n\n\tstruct list_head inputs;\t\t\t\t\t/* The list of inputs */\n\tvoid *hiddev;\t\t\t\t\t\t\t/* The hiddev structure */\n\tvoid *hidraw;\n\n\tchar name[128];\t\t\t\t\t\t\t/* Device name */\n\tchar phys[64];\t\t\t\t\t\t\t/* Device physical location */\n\tchar uniq[64];\t\t\t\t\t\t\t/* Device unique identifier (serial #) */\n\n\tvoid *driver_data;\n\n\t/* temporary hid_ff handling (until moved to the drivers) */\n\tint (*ff_init)(struct hid_device *);\n\n\t/* hiddev event handler */\n\tint (*hiddev_connect)(struct hid_device *, unsigned int);\n\tvoid (*hiddev_disconnect)(struct hid_device *);\n\tvoid (*hiddev_hid_event) (struct hid_device *, struct hid_field *field,\n\t\t\t\t  struct hid_usage *, __s32);\n\tvoid (*hiddev_report_event) (struct hid_device *, struct hid_report *);\n\n\t/* debugging support via debugfs */\n\tunsigned short debug;\n\tstruct dentry *debug_dir;\n\tstruct dentry *debug_rdesc;\n\tstruct dentry *debug_events;\n\tstruct list_head debug_list;\n\tspinlock_t  debug_list_lock;\n\twait_queue_head_t debug_wait;\n};\n\n#define to_hid_device(pdev) \\\n\tcontainer_of(pdev, struct hid_device, dev)\n\nstatic inline void *hid_get_drvdata(struct hid_device *hdev)\n{\n\treturn dev_get_drvdata(&hdev->dev);\n}\n\nstatic inline void hid_set_drvdata(struct hid_device *hdev, void *data)\n{\n\tdev_set_drvdata(&hdev->dev, data);\n}\n\n#define HID_GLOBAL_STACK_SIZE 4\n#define HID_COLLECTION_STACK_SIZE 4\n\n#define HID_SCAN_FLAG_MT_WIN_8\t\t\tBIT(0)\n#define HID_SCAN_FLAG_VENDOR_SPECIFIC\t\tBIT(1)\n#define HID_SCAN_FLAG_GD_POINTER\t\tBIT(2)\n\nstruct hid_parser {\n\tstruct hid_global     global;\n\tstruct hid_global     global_stack[HID_GLOBAL_STACK_SIZE];\n\tunsigned int          global_stack_ptr;\n\tstruct hid_local      local;\n\tunsigned int         *collection_stack;\n\tunsigned int          collection_stack_ptr;\n\tunsigned int          collection_stack_size;\n\tstruct hid_device    *device;\n\tunsigned int          scan_flags;\n};\n\nstruct hid_class_descriptor {\n\t__u8  bDescriptorType;\n\t__le16 wDescriptorLength;\n} __attribute__ ((packed));\n\nstruct hid_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__le16 bcdHID;\n\t__u8  bCountryCode;\n\t__u8  bNumDescriptors;\n\n\tstruct hid_class_descriptor desc[1];\n} __attribute__ ((packed));\n\n#define HID_DEVICE(b, g, ven, prod)\t\t\t\t\t\\\n\t.bus = (b), .group = (g), .vendor = (ven), .product = (prod)\n#define HID_USB_DEVICE(ven, prod)\t\t\t\t\\\n\t.bus = BUS_USB, .vendor = (ven), .product = (prod)\n#define HID_BLUETOOTH_DEVICE(ven, prod)\t\t\t\t\t\\\n\t.bus = BUS_BLUETOOTH, .vendor = (ven), .product = (prod)\n#define HID_I2C_DEVICE(ven, prod)\t\t\t\t\\\n\t.bus = BUS_I2C, .vendor = (ven), .product = (prod)\n\n#define HID_REPORT_ID(rep) \\\n\t.report_type = (rep)\n#define HID_USAGE_ID(uhid, utype, ucode) \\\n\t.usage_hid = (uhid), .usage_type = (utype), .usage_code = (ucode)\n/* we don't want to catch types and codes equal to 0 */\n#define HID_TERMINATOR\t\t(HID_ANY_ID - 1)\n\nstruct hid_report_id {\n\t__u32 report_type;\n};\nstruct hid_usage_id {\n\t__u32 usage_hid;\n\t__u32 usage_type;\n\t__u32 usage_code;\n};\n\n/**\n * struct hid_driver\n * @name: driver name (e.g. \"Footech_bar-wheel\")\n * @id_table: which devices is this driver for (must be non-NULL for probe\n * \t      to be called)\n * @dyn_list: list of dynamically added device ids\n * @dyn_lock: lock protecting @dyn_list\n * @match: check if the given device is handled by this driver\n * @probe: new device inserted\n * @remove: device removed (NULL if not a hot-plug capable driver)\n * @report_table: on which reports to call raw_event (NULL means all)\n * @raw_event: if report in report_table, this hook is called (NULL means nop)\n * @usage_table: on which events to call event (NULL means all)\n * @event: if usage in usage_table, this hook is called (NULL means nop)\n * @report: this hook is called after parsing a report (NULL means nop)\n * @report_fixup: called before report descriptor parsing (NULL means nop)\n * @input_mapping: invoked on input registering before mapping an usage\n * @input_mapped: invoked on input registering after mapping an usage\n * @input_configured: invoked just before the device is registered\n * @feature_mapping: invoked on feature registering\n * @suspend: invoked on suspend (NULL means nop)\n * @resume: invoked on resume if device was not reset (NULL means nop)\n * @reset_resume: invoked on resume if device was reset (NULL means nop)\n *\n * probe should return -errno on error, or 0 on success. During probe,\n * input will not be passed to raw_event unless hid_device_io_start is\n * called.\n *\n * raw_event and event should return negative on error, any other value will\n * pass the event on to .event() typically return 0 for success.\n *\n * input_mapping shall return a negative value to completely ignore this usage\n * (e.g. doubled or invalid usage), zero to continue with parsing of this\n * usage by generic code (no special handling needed) or positive to skip\n * generic parsing (needed special handling which was done in the hook already)\n * input_mapped shall return negative to inform the layer that this usage\n * should not be considered for further processing or zero to notify that\n * no processing was performed and should be done in a generic manner\n * Both these functions may be NULL which means the same behavior as returning\n * zero from them.\n */\nstruct hid_driver {\n\tchar *name;\n\tconst struct hid_device_id *id_table;\n\n\tstruct list_head dyn_list;\n\tspinlock_t dyn_lock;\n\n\tbool (*match)(struct hid_device *dev, bool ignore_special_driver);\n\tint (*probe)(struct hid_device *dev, const struct hid_device_id *id);\n\tvoid (*remove)(struct hid_device *dev);\n\n\tconst struct hid_report_id *report_table;\n\tint (*raw_event)(struct hid_device *hdev, struct hid_report *report,\n\t\t\tu8 *data, int size);\n\tconst struct hid_usage_id *usage_table;\n\tint (*event)(struct hid_device *hdev, struct hid_field *field,\n\t\t\tstruct hid_usage *usage, __s32 value);\n\tvoid (*report)(struct hid_device *hdev, struct hid_report *report);\n\n\t__u8 *(*report_fixup)(struct hid_device *hdev, __u8 *buf,\n\t\t\tunsigned int *size);\n\n\tint (*input_mapping)(struct hid_device *hdev,\n\t\t\tstruct hid_input *hidinput, struct hid_field *field,\n\t\t\tstruct hid_usage *usage, unsigned long **bit, int *max);\n\tint (*input_mapped)(struct hid_device *hdev,\n\t\t\tstruct hid_input *hidinput, struct hid_field *field,\n\t\t\tstruct hid_usage *usage, unsigned long **bit, int *max);\n\tint (*input_configured)(struct hid_device *hdev,\n\t\t\t\tstruct hid_input *hidinput);\n\tvoid (*feature_mapping)(struct hid_device *hdev,\n\t\t\tstruct hid_field *field,\n\t\t\tstruct hid_usage *usage);\n#ifdef CONFIG_PM\n\tint (*suspend)(struct hid_device *hdev, pm_message_t message);\n\tint (*resume)(struct hid_device *hdev);\n\tint (*reset_resume)(struct hid_device *hdev);\n#endif\n/* private: */\n\tstruct device_driver driver;\n};\n\n#define to_hid_driver(pdrv) \\\n\tcontainer_of(pdrv, struct hid_driver, driver)\n\n/**\n * hid_ll_driver - low level driver callbacks\n * @start: called on probe to start the device\n * @stop: called on remove\n * @open: called by input layer on open\n * @close: called by input layer on close\n * @power: request underlying hardware to enter requested power mode\n * @parse: this method is called only once to parse the device data,\n *\t   shouldn't allocate anything to not leak memory\n * @request: send report request to device (e.g. feature report)\n * @wait: wait for buffered io to complete (send/recv reports)\n * @raw_request: send raw report request to device (e.g. feature report)\n * @output_report: send output report to device\n * @idle: send idle request to device\n */\nstruct hid_ll_driver {\n\tint (*start)(struct hid_device *hdev);\n\tvoid (*stop)(struct hid_device *hdev);\n\n\tint (*open)(struct hid_device *hdev);\n\tvoid (*close)(struct hid_device *hdev);\n\n\tint (*power)(struct hid_device *hdev, int level);\n\n\tint (*parse)(struct hid_device *hdev);\n\n\tvoid (*request)(struct hid_device *hdev,\n\t\t\tstruct hid_report *report, int reqtype);\n\n\tint (*wait)(struct hid_device *hdev);\n\n\tint (*raw_request) (struct hid_device *hdev, unsigned char reportnum,\n\t\t\t    __u8 *buf, size_t len, unsigned char rtype,\n\t\t\t    int reqtype);\n\n\tint (*output_report) (struct hid_device *hdev, __u8 *buf, size_t len);\n\n\tint (*idle)(struct hid_device *hdev, int report, int idle, int reqtype);\n};\n\nextern struct hid_ll_driver i2c_hid_ll_driver;\nextern struct hid_ll_driver hidp_hid_driver;\nextern struct hid_ll_driver uhid_hid_driver;\nextern struct hid_ll_driver usb_hid_driver;\n\nstatic inline bool hid_is_using_ll_driver(struct hid_device *hdev,\n\t\tstruct hid_ll_driver *driver)\n{\n\treturn hdev->ll_driver == driver;\n}\n\n#define\tPM_HINT_FULLON\t1<<5\n#define PM_HINT_NORMAL\t1<<1\n\n/* Applications from HID Usage Tables 4/8/99 Version 1.1 */\n/* We ignore a few input applications that are not widely used */\n#define IS_INPUT_APPLICATION(a) \\\n\t\t(((a >= HID_UP_GENDESK) && (a <= HID_GD_MULTIAXIS)) \\\n\t\t|| ((a >= HID_DG_PEN) && (a <= HID_DG_WHITEBOARD)) \\\n\t\t|| (a == HID_GD_SYSTEM_CONTROL) || (a == HID_CP_CONSUMER_CONTROL) \\\n\t\t|| (a == HID_GD_WIRELESS_RADIO_CTLS))\n\n/* HID core API */\n\nextern int hid_debug;\n\nextern bool hid_ignore(struct hid_device *);\nextern int hid_add_device(struct hid_device *);\nextern void hid_destroy_device(struct hid_device *);\n\nextern struct bus_type hid_bus_type;\n\nextern int __must_check __hid_register_driver(struct hid_driver *,\n\t\tstruct module *, const char *mod_name);\n\n/* use a define to avoid include chaining to get THIS_MODULE & friends */\n#define hid_register_driver(driver) \\\n\t__hid_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)\n\nextern void hid_unregister_driver(struct hid_driver *);\n\n/**\n * module_hid_driver() - Helper macro for registering a HID driver\n * @__hid_driver: hid_driver struct\n *\n * Helper macro for HID drivers which do not do anything special in module\n * init/exit. This eliminates a lot of boilerplate. Each module may only\n * use this macro once, and calling it replaces module_init() and module_exit()\n */\n#define module_hid_driver(__hid_driver) \\\n\tmodule_driver(__hid_driver, hid_register_driver, \\\n\t\t      hid_unregister_driver)\n\nextern void hidinput_hid_event(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);\nextern void hidinput_report_event(struct hid_device *hid, struct hid_report *report);\nextern int hidinput_connect(struct hid_device *hid, unsigned int force);\nextern void hidinput_disconnect(struct hid_device *);\n\nint hid_set_field(struct hid_field *, unsigned, __s32);\nint hid_input_report(struct hid_device *, int type, u8 *, u32, int);\nint hidinput_find_field(struct hid_device *hid, unsigned int type, unsigned int code, struct hid_field **field);\nstruct hid_field *hidinput_get_led_field(struct hid_device *hid);\nunsigned int hidinput_count_leds(struct hid_device *hid);\n__s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code);\nvoid hid_output_report(struct hid_report *report, __u8 *data);\nint __hid_request(struct hid_device *hid, struct hid_report *rep, int reqtype);\nu8 *hid_alloc_report_buf(struct hid_report *report, gfp_t flags);\nstruct hid_device *hid_allocate_device(void);\nstruct hid_report *hid_register_report(struct hid_device *device,\n\t\t\t\t       unsigned int type, unsigned int id,\n\t\t\t\t       unsigned int application);\nint hid_parse_report(struct hid_device *hid, __u8 *start, unsigned size);\nstruct hid_report *hid_validate_values(struct hid_device *hid,\n\t\t\t\t       unsigned int type, unsigned int id,\n\t\t\t\t       unsigned int field_index,\n\t\t\t\t       unsigned int report_counts);\n\nvoid hid_setup_resolution_multiplier(struct hid_device *hid);\nint hid_open_report(struct hid_device *device);\nint hid_check_keys_pressed(struct hid_device *hid);\nint hid_connect(struct hid_device *hid, unsigned int connect_mask);\nvoid hid_disconnect(struct hid_device *hid);\nbool hid_match_one_id(const struct hid_device *hdev,\n\t\t      const struct hid_device_id *id);\nconst struct hid_device_id *hid_match_id(const struct hid_device *hdev,\n\t\t\t\t\t const struct hid_device_id *id);\nconst struct hid_device_id *hid_match_device(struct hid_device *hdev,\n\t\t\t\t\t     struct hid_driver *hdrv);\nbool hid_compare_device_paths(struct hid_device *hdev_a,\n\t\t\t      struct hid_device *hdev_b, char separator);\ns32 hid_snto32(__u32 value, unsigned n);\n__u32 hid_field_extract(const struct hid_device *hid, __u8 *report,\n\t\t     unsigned offset, unsigned n);\n\n/**\n * hid_device_io_start - enable HID input during probe, remove\n *\n * @hid - the device\n *\n * This should only be called during probe or remove and only be\n * called by the thread calling probe or remove. It will allow\n * incoming packets to be delivered to the driver.\n */\nstatic inline void hid_device_io_start(struct hid_device *hid) {\n\tif (hid->io_started) {\n\t\tdev_warn(&hid->dev, \"io already started\\n\");\n\t\treturn;\n\t}\n\thid->io_started = true;\n\tup(&hid->driver_input_lock);\n}\n\n/**\n * hid_device_io_stop - disable HID input during probe, remove\n *\n * @hid - the device\n *\n * Should only be called after hid_device_io_start. It will prevent\n * incoming packets from going to the driver for the duration of\n * probe, remove. If called during probe, packets will still go to the\n * driver after probe is complete. This function should only be called\n * by the thread calling probe or remove.\n */\nstatic inline void hid_device_io_stop(struct hid_device *hid) {\n\tif (!hid->io_started) {\n\t\tdev_warn(&hid->dev, \"io already stopped\\n\");\n\t\treturn;\n\t}\n\thid->io_started = false;\n\tdown(&hid->driver_input_lock);\n}\n\n/**\n * hid_map_usage - map usage input bits\n *\n * @hidinput: hidinput which we are interested in\n * @usage: usage to fill in\n * @bit: pointer to input->{}bit (out parameter)\n * @max: maximal valid usage->code to consider later (out parameter)\n * @type: input event type (EV_KEY, EV_REL, ...)\n * @c: code which corresponds to this usage and type\n *\n * The value pointed to by @bit will be set to NULL if either @type is\n * an unhandled event type, or if @c is out of range for @type. This\n * can be used as an error condition.\n */\nstatic inline void hid_map_usage(struct hid_input *hidinput,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max,\n\t\t__u8 type, unsigned int c)\n{\n\tstruct input_dev *input = hidinput->input;\n\tunsigned long *bmap = NULL;\n\tunsigned int limit = 0;\n\n\tswitch (type) {\n\tcase EV_ABS:\n\t\tbmap = input->absbit;\n\t\tlimit = ABS_MAX;\n\t\tbreak;\n\tcase EV_REL:\n\t\tbmap = input->relbit;\n\t\tlimit = REL_MAX;\n\t\tbreak;\n\tcase EV_KEY:\n\t\tbmap = input->keybit;\n\t\tlimit = KEY_MAX;\n\t\tbreak;\n\tcase EV_LED:\n\t\tbmap = input->ledbit;\n\t\tlimit = LED_MAX;\n\t\tbreak;\n\t}\n\n\tif (unlikely(c > limit || !bmap)) {\n\t\tpr_warn_ratelimited(\"%s: Invalid code %d type %d\\n\",\n\t\t\t\t    input->name, c, type);\n\t\t*bit = NULL;\n\t\treturn;\n\t}\n\n\tusage->type = type;\n\tusage->code = c;\n\t*max = limit;\n\t*bit = bmap;\n}\n\n/**\n * hid_map_usage_clear - map usage input bits and clear the input bit\n *\n * The same as hid_map_usage, except the @c bit is also cleared in supported\n * bits (@bit).\n */\nstatic inline void hid_map_usage_clear(struct hid_input *hidinput,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max,\n\t\t__u8 type, __u16 c)\n{\n\thid_map_usage(hidinput, usage, bit, max, type, c);\n\tif (*bit)\n\t\tclear_bit(usage->code, *bit);\n}\n\n/**\n * hid_parse - parse HW reports\n *\n * @hdev: hid device\n *\n * Call this from probe after you set up the device (if needed). Your\n * report_fixup will be called (if non-NULL) after reading raw report from\n * device before passing it to hid layer for real parsing.\n */\nstatic inline int __must_check hid_parse(struct hid_device *hdev)\n{\n\treturn hid_open_report(hdev);\n}\n\nint __must_check hid_hw_start(struct hid_device *hdev,\n\t\t\t      unsigned int connect_mask);\nvoid hid_hw_stop(struct hid_device *hdev);\nint __must_check hid_hw_open(struct hid_device *hdev);\nvoid hid_hw_close(struct hid_device *hdev);\n\n/**\n * hid_hw_power - requests underlying HW to go into given power mode\n *\n * @hdev: hid device\n * @level: requested power level (one of %PM_HINT_* defines)\n *\n * This function requests underlying hardware to enter requested power\n * mode.\n */\n\nstatic inline int hid_hw_power(struct hid_device *hdev, int level)\n{\n\treturn hdev->ll_driver->power ? hdev->ll_driver->power(hdev, level) : 0;\n}\n\n\n/**\n * hid_hw_request - send report request to device\n *\n * @hdev: hid device\n * @report: report to send\n * @reqtype: hid request type\n */\nstatic inline void hid_hw_request(struct hid_device *hdev,\n\t\t\t\t  struct hid_report *report, int reqtype)\n{\n\tif (hdev->ll_driver->request)\n\t\treturn hdev->ll_driver->request(hdev, report, reqtype);\n\n\t__hid_request(hdev, report, reqtype);\n}\n\n/**\n * hid_hw_raw_request - send report request to device\n *\n * @hdev: hid device\n * @reportnum: report ID\n * @buf: in/out data to transfer\n * @len: length of buf\n * @rtype: HID report type\n * @reqtype: HID_REQ_GET_REPORT or HID_REQ_SET_REPORT\n *\n * @return: count of data transfered, negative if error\n *\n * Same behavior as hid_hw_request, but with raw buffers instead.\n */\nstatic inline int hid_hw_raw_request(struct hid_device *hdev,\n\t\t\t\t  unsigned char reportnum, __u8 *buf,\n\t\t\t\t  size_t len, unsigned char rtype, int reqtype)\n{\n\tif (len < 1 || len > HID_MAX_BUFFER_SIZE || !buf)\n\t\treturn -EINVAL;\n\n\treturn hdev->ll_driver->raw_request(hdev, reportnum, buf, len,\n\t\t\t\t\t\t    rtype, reqtype);\n}\n\n/**\n * hid_hw_output_report - send output report to device\n *\n * @hdev: hid device\n * @buf: raw data to transfer\n * @len: length of buf\n *\n * @return: count of data transfered, negative if error\n */\nstatic inline int hid_hw_output_report(struct hid_device *hdev, __u8 *buf,\n\t\t\t\t\tsize_t len)\n{\n\tif (len < 1 || len > HID_MAX_BUFFER_SIZE || !buf)\n\t\treturn -EINVAL;\n\n\tif (hdev->ll_driver->output_report)\n\t\treturn hdev->ll_driver->output_report(hdev, buf, len);\n\n\treturn -ENOSYS;\n}\n\n/**\n * hid_hw_idle - send idle request to device\n *\n * @hdev: hid device\n * @report: report to control\n * @idle: idle state\n * @reqtype: hid request type\n */\nstatic inline int hid_hw_idle(struct hid_device *hdev, int report, int idle,\n\t\tint reqtype)\n{\n\tif (hdev->ll_driver->idle)\n\t\treturn hdev->ll_driver->idle(hdev, report, idle, reqtype);\n\n\treturn 0;\n}\n\n/**\n * hid_hw_wait - wait for buffered io to complete\n *\n * @hdev: hid device\n */\nstatic inline void hid_hw_wait(struct hid_device *hdev)\n{\n\tif (hdev->ll_driver->wait)\n\t\thdev->ll_driver->wait(hdev);\n}\n\n/**\n * hid_report_len - calculate the report length\n *\n * @report: the report we want to know the length\n */\nstatic inline u32 hid_report_len(struct hid_report *report)\n{\n\t/* equivalent to DIV_ROUND_UP(report->size, 8) + !!(report->id > 0) */\n\treturn ((report->size - 1) >> 3) + 1 + (report->id > 0);\n}\n\nint hid_report_raw_event(struct hid_device *hid, int type, u8 *data, u32 size,\n\t\tint interrupt);\n\n/* HID quirks API */\nunsigned long hid_lookup_quirk(const struct hid_device *hdev);\nint hid_quirks_init(char **quirks_param, __u16 bus, int count);\nvoid hid_quirks_exit(__u16 bus);\n\n#ifdef CONFIG_HID_PID\nint hid_pidff_init(struct hid_device *hid);\n#else\n#define hid_pidff_init NULL\n#endif\n\n#define dbg_hid(fmt, ...)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (hid_debug)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG \"%s: \" fmt, __FILE__, ##__VA_ARGS__);\t\\\n} while (0)\n\n#define hid_err(hid, fmt, ...)\t\t\t\t\\\n\tdev_err(&(hid)->dev, fmt, ##__VA_ARGS__)\n#define hid_notice(hid, fmt, ...)\t\t\t\\\n\tdev_notice(&(hid)->dev, fmt, ##__VA_ARGS__)\n#define hid_warn(hid, fmt, ...)\t\t\t\t\\\n\tdev_warn(&(hid)->dev, fmt, ##__VA_ARGS__)\n#define hid_info(hid, fmt, ...)\t\t\t\t\\\n\tdev_info(&(hid)->dev, fmt, ##__VA_ARGS__)\n#define hid_dbg(hid, fmt, ...)\t\t\t\t\\\n\tdev_dbg(&(hid)->dev, fmt, ##__VA_ARGS__)\n\n#define hid_err_once(hid, fmt, ...)\t\t\t\\\n\tdev_err_once(&(hid)->dev, fmt, ##__VA_ARGS__)\n#define hid_notice_once(hid, fmt, ...)\t\t\t\\\n\tdev_notice_once(&(hid)->dev, fmt, ##__VA_ARGS__)\n#define hid_warn_once(hid, fmt, ...)\t\t\t\\\n\tdev_warn_once(&(hid)->dev, fmt, ##__VA_ARGS__)\n#define hid_info_once(hid, fmt, ...)\t\t\t\\\n\tdev_info_once(&(hid)->dev, fmt, ##__VA_ARGS__)\n#define hid_dbg_once(hid, fmt, ...)\t\t\t\\\n\tdev_dbg_once(&(hid)->dev, fmt, ##__VA_ARGS__)\n\n#endif\n"}, "2": {"id": 2, "path": "/src/include/linux/compiler.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_H\n#define __LINUX_COMPILER_H\n\n#include <linux/compiler_types.h>\n\n#ifndef __ASSEMBLY__\n\n#ifdef __KERNEL__\n\n/*\n * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code\n * to disable branch tracing on a per file basis.\n */\n#if defined(CONFIG_TRACE_BRANCH_PROFILING) \\\n    && !defined(DISABLE_BRANCH_PROFILING) && !defined(__CHECKER__)\nvoid ftrace_likely_update(struct ftrace_likely_data *f, int val,\n\t\t\t  int expect, int is_constant);\n\n#define likely_notrace(x)\t__builtin_expect(!!(x), 1)\n#define unlikely_notrace(x)\t__builtin_expect(!!(x), 0)\n\n#define __branch_check__(x, expect, is_constant) ({\t\t\t\\\n\t\t\tlong ______r;\t\t\t\t\t\\\n\t\t\tstatic struct ftrace_likely_data\t\t\\\n\t\t\t\t__aligned(4)\t\t\t\t\\\n\t\t\t\t__section(\"_ftrace_annotated_branch\")\t\\\n\t\t\t\t______f = {\t\t\t\t\\\n\t\t\t\t.data.func = __func__,\t\t\t\\\n\t\t\t\t.data.file = __FILE__,\t\t\t\\\n\t\t\t\t.data.line = __LINE__,\t\t\t\\\n\t\t\t};\t\t\t\t\t\t\\\n\t\t\t______r = __builtin_expect(!!(x), expect);\t\\\n\t\t\tftrace_likely_update(&______f, ______r,\t\t\\\n\t\t\t\t\t     expect, is_constant);\t\\\n\t\t\t______r;\t\t\t\t\t\\\n\t\t})\n\n/*\n * Using __builtin_constant_p(x) to ignore cases where the return\n * value is always the same.  This idea is taken from a similar patch\n * written by Daniel Walker.\n */\n# ifndef likely\n#  define likely(x)\t(__branch_check__(x, 1, __builtin_constant_p(x)))\n# endif\n# ifndef unlikely\n#  define unlikely(x)\t(__branch_check__(x, 0, __builtin_constant_p(x)))\n# endif\n\n#ifdef CONFIG_PROFILE_ALL_BRANCHES\n/*\n * \"Define 'is'\", Bill Clinton\n * \"Define 'if'\", Steven Rostedt\n */\n#define if(cond, ...) if ( __trace_if_var( !!(cond , ## __VA_ARGS__) ) )\n\n#define __trace_if_var(cond) (__builtin_constant_p(cond) ? (cond) : __trace_if_value(cond))\n\n#define __trace_if_value(cond) ({\t\t\t\\\n\tstatic struct ftrace_branch_data\t\t\\\n\t\t__aligned(4)\t\t\t\t\\\n\t\t__section(\"_ftrace_branch\")\t\t\\\n\t\t__if_trace = {\t\t\t\t\\\n\t\t\t.func = __func__,\t\t\\\n\t\t\t.file = __FILE__,\t\t\\\n\t\t\t.line = __LINE__,\t\t\\\n\t\t};\t\t\t\t\t\\\n\t(cond) ?\t\t\t\t\t\\\n\t\t(__if_trace.miss_hit[1]++,1) :\t\t\\\n\t\t(__if_trace.miss_hit[0]++,0);\t\t\\\n})\n\n#endif /* CONFIG_PROFILE_ALL_BRANCHES */\n\n#else\n# define likely(x)\t__builtin_expect(!!(x), 1)\n# define unlikely(x)\t__builtin_expect(!!(x), 0)\n#endif\n\n/* Optimization barrier */\n#ifndef barrier\n/* The \"volatile\" is due to gcc bugs */\n# define barrier() __asm__ __volatile__(\"\": : :\"memory\")\n#endif\n\n#ifndef barrier_data\n/*\n * This version is i.e. to prevent dead stores elimination on @ptr\n * where gcc and llvm may behave differently when otherwise using\n * normal barrier(): while gcc behavior gets along with a normal\n * barrier(), llvm needs an explicit input variable to be assumed\n * clobbered. The issue is as follows: while the inline asm might\n * access any memory it wants, the compiler could have fit all of\n * @ptr into memory registers instead, and since @ptr never escaped\n * from that, it proved that the inline asm wasn't touching any of\n * it. This version works well with both compilers, i.e. we're telling\n * the compiler that the inline asm absolutely may see the contents\n * of @ptr. See also: https://llvm.org/bugs/show_bug.cgi?id=15495\n */\n# define barrier_data(ptr) __asm__ __volatile__(\"\": :\"r\"(ptr) :\"memory\")\n#endif\n\n/* workaround for GCC PR82365 if needed */\n#ifndef barrier_before_unreachable\n# define barrier_before_unreachable() do { } while (0)\n#endif\n\n/* Unreachable code */\n#ifdef CONFIG_STACK_VALIDATION\n/*\n * These macros help objtool understand GCC code flow for unreachable code.\n * The __COUNTER__ based labels are a hack to make each instance of the macros\n * unique, to convince GCC not to merge duplicate inline asm statements.\n */\n#define annotate_reachable() ({\t\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.reachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define annotate_unreachable() ({\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.unreachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define ASM_UNREACHABLE\t\t\t\t\t\t\t\\\n\t\"999:\\n\\t\"\t\t\t\t\t\t\t\\\n\t\".pushsection .discard.unreachable\\n\\t\"\t\t\t\t\\\n\t\".long 999b - .\\n\\t\"\t\t\t\t\t\t\\\n\t\".popsection\\n\\t\"\n\n/* Annotate a C jump table to allow objtool to follow the code flow */\n#define __annotate_jump_table __section(\".rodata..c_jump_table\")\n\n#else\n#define annotate_reachable()\n#define annotate_unreachable()\n#define __annotate_jump_table\n#endif\n\n#ifndef ASM_UNREACHABLE\n# define ASM_UNREACHABLE\n#endif\n#ifndef unreachable\n# define unreachable() do {\t\t\\\n\tannotate_unreachable();\t\t\\\n\t__builtin_unreachable();\t\\\n} while (0)\n#endif\n\n/*\n * KENTRY - kernel entry point\n * This can be used to annotate symbols (functions or data) that are used\n * without their linker symbol being referenced explicitly. For example,\n * interrupt vector handlers, or functions in the kernel image that are found\n * programatically.\n *\n * Not required for symbols exported with EXPORT_SYMBOL, or initcalls. Those\n * are handled in their own way (with KEEP() in linker scripts).\n *\n * KENTRY can be avoided if the symbols in question are marked as KEEP() in the\n * linker script. For example an architecture could KEEP() its entire\n * boot/exception vector code rather than annotate each function and data.\n */\n#ifndef KENTRY\n# define KENTRY(sym)\t\t\t\t\t\t\\\n\textern typeof(sym) sym;\t\t\t\t\t\\\n\tstatic const unsigned long __kentry_##sym\t\t\\\n\t__used\t\t\t\t\t\t\t\\\n\t__attribute__((__section__(\"___kentry+\" #sym)))\t\t\\\n\t= (unsigned long)&sym;\n#endif\n\n#ifndef RELOC_HIDE\n# define RELOC_HIDE(ptr, off)\t\t\t\t\t\\\n  ({ unsigned long __ptr;\t\t\t\t\t\\\n     __ptr = (unsigned long) (ptr);\t\t\t\t\\\n    (typeof(ptr)) (__ptr + (off)); })\n#endif\n\n#ifndef OPTIMIZER_HIDE_VAR\n/* Make the optimizer believe the variable can be manipulated arbitrarily. */\n#define OPTIMIZER_HIDE_VAR(var)\t\t\t\t\t\t\\\n\t__asm__ (\"\" : \"=r\" (var) : \"0\" (var))\n#endif\n\n/* Not-quite-unique ID. */\n#ifndef __UNIQUE_ID\n# define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)\n#endif\n\n/**\n * data_race - mark an expression as containing intentional data races\n *\n * This data_race() macro is useful for situations in which data races\n * should be forgiven.  One example is diagnostic code that accesses\n * shared variables but is not a part of the core synchronization design.\n *\n * This macro *does not* affect normal code generation, but is a hint\n * to tooling that data races here are to be ignored.\n */\n#define data_race(expr)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__unqual_scalar_typeof(({ expr; })) __v = ({\t\t\t\\\n\t\t__kcsan_disable_current();\t\t\t\t\\\n\t\texpr;\t\t\t\t\t\t\t\\\n\t});\t\t\t\t\t\t\t\t\\\n\t__kcsan_enable_current();\t\t\t\t\t\\\n\t__v;\t\t\t\t\t\t\t\t\\\n})\n\n#endif /* __KERNEL__ */\n\n/*\n * Force the compiler to emit 'sym' as a symbol, so that we can reference\n * it from inline assembler. Necessary in case 'sym' could be inlined\n * otherwise, or eliminated entirely due to lack of references that are\n * visible to the compiler.\n */\n#define __ADDRESSABLE(sym) \\\n\tstatic void * __section(\".discard.addressable\") __used \\\n\t\t__UNIQUE_ID(__PASTE(__addressable_,sym)) = (void *)&sym;\n\n/**\n * offset_to_ptr - convert a relative memory offset to an absolute pointer\n * @off:\tthe address of the 32-bit offset value\n */\nstatic inline void *offset_to_ptr(const int *off)\n{\n\treturn (void *)((unsigned long)off + *off);\n}\n\n#endif /* __ASSEMBLY__ */\n\n/* &a[0] degrades to a pointer: a different type from an array */\n#define __must_be_array(a)\tBUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))\n\n/*\n * This is needed in functions which generate the stack canary, see\n * arch/x86/kernel/smpboot.c::start_secondary() for an example.\n */\n#define prevent_tail_call_optimization()\tmb()\n\n#include <asm/rwonce.h>\n\n#endif /* __LINUX_COMPILER_H */\n"}, "3": {"id": 3, "path": "/src/include/linux/printk.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __KERNEL_PRINTK__\n#define __KERNEL_PRINTK__\n\n#include <stdarg.h>\n#include <linux/init.h>\n#include <linux/kern_levels.h>\n#include <linux/linkage.h>\n#include <linux/cache.h>\n#include <linux/ratelimit_types.h>\n\nextern const char linux_banner[];\nextern const char linux_proc_banner[];\n\nextern int oops_in_progress;\t/* If set, an oops, panic(), BUG() or die() is in progress */\n\n#define PRINTK_MAX_SINGLE_HEADER_LEN 2\n\nstatic inline int printk_get_level(const char *buffer)\n{\n\tif (buffer[0] == KERN_SOH_ASCII && buffer[1]) {\n\t\tswitch (buffer[1]) {\n\t\tcase '0' ... '7':\n\t\tcase 'c':\t/* KERN_CONT */\n\t\t\treturn buffer[1];\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic inline const char *printk_skip_level(const char *buffer)\n{\n\tif (printk_get_level(buffer))\n\t\treturn buffer + 2;\n\n\treturn buffer;\n}\n\nstatic inline const char *printk_skip_headers(const char *buffer)\n{\n\twhile (printk_get_level(buffer))\n\t\tbuffer = printk_skip_level(buffer);\n\n\treturn buffer;\n}\n\n#define CONSOLE_EXT_LOG_MAX\t8192\n\n/* printk's without a loglevel use this.. */\n#define MESSAGE_LOGLEVEL_DEFAULT CONFIG_MESSAGE_LOGLEVEL_DEFAULT\n\n/* We show everything that is MORE important than this.. */\n#define CONSOLE_LOGLEVEL_SILENT  0 /* Mum's the word */\n#define CONSOLE_LOGLEVEL_MIN\t 1 /* Minimum loglevel we let people use */\n#define CONSOLE_LOGLEVEL_DEBUG\t10 /* issue debug messages */\n#define CONSOLE_LOGLEVEL_MOTORMOUTH 15\t/* You can't shut this one up */\n\n/*\n * Default used to be hard-coded at 7, quiet used to be hardcoded at 4,\n * we're now allowing both to be set from kernel config.\n */\n#define CONSOLE_LOGLEVEL_DEFAULT CONFIG_CONSOLE_LOGLEVEL_DEFAULT\n#define CONSOLE_LOGLEVEL_QUIET\t CONFIG_CONSOLE_LOGLEVEL_QUIET\n\nextern int console_printk[];\n\n#define console_loglevel (console_printk[0])\n#define default_message_loglevel (console_printk[1])\n#define minimum_console_loglevel (console_printk[2])\n#define default_console_loglevel (console_printk[3])\n\nstatic inline void console_silent(void)\n{\n\tconsole_loglevel = CONSOLE_LOGLEVEL_SILENT;\n}\n\nstatic inline void console_verbose(void)\n{\n\tif (console_loglevel)\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n}\n\n/* strlen(\"ratelimit\") + 1 */\n#define DEVKMSG_STR_MAX_SIZE 10\nextern char devkmsg_log_str[];\nstruct ctl_table;\n\nextern int suppress_printk;\n\nstruct va_format {\n\tconst char *fmt;\n\tva_list *va;\n};\n\n/*\n * FW_BUG\n * Add this to a message where you are sure the firmware is buggy or behaves\n * really stupid or out of spec. Be aware that the responsible BIOS developer\n * should be able to fix this issue or at least get a concrete idea of the\n * problem by reading your message without the need of looking at the kernel\n * code.\n *\n * Use it for definite and high priority BIOS bugs.\n *\n * FW_WARN\n * Use it for not that clear (e.g. could the kernel messed up things already?)\n * and medium priority BIOS bugs.\n *\n * FW_INFO\n * Use this one if you want to tell the user or vendor about something\n * suspicious, but generally harmless related to the firmware.\n *\n * Use it for information or very low priority BIOS bugs.\n */\n#define FW_BUG\t\t\"[Firmware Bug]: \"\n#define FW_WARN\t\t\"[Firmware Warn]: \"\n#define FW_INFO\t\t\"[Firmware Info]: \"\n\n/*\n * HW_ERR\n * Add this to a message for hardware errors, so that user can report\n * it to hardware vendor instead of LKML or software vendor.\n */\n#define HW_ERR\t\t\"[Hardware Error]: \"\n\n/*\n * DEPRECATED\n * Add this to a message whenever you want to warn user space about the use\n * of a deprecated aspect of an API so they can stop using it\n */\n#define DEPRECATED\t\"[Deprecated]: \"\n\n/*\n * Dummy printk for disabled debugging statements to use whilst maintaining\n * gcc's format checking.\n */\n#define no_printk(fmt, ...)\t\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\\\n\t\tprintk(fmt, ##__VA_ARGS__);\t\t\\\n\t0;\t\t\t\t\t\t\\\n})\n\n#ifdef CONFIG_EARLY_PRINTK\nextern asmlinkage __printf(1, 2)\nvoid early_printk(const char *fmt, ...);\n#else\nstatic inline __printf(1, 2) __cold\nvoid early_printk(const char *s, ...) { }\n#endif\n\n#ifdef CONFIG_PRINTK_NMI\nextern void printk_nmi_enter(void);\nextern void printk_nmi_exit(void);\nextern void printk_nmi_direct_enter(void);\nextern void printk_nmi_direct_exit(void);\n#else\nstatic inline void printk_nmi_enter(void) { }\nstatic inline void printk_nmi_exit(void) { }\nstatic inline void printk_nmi_direct_enter(void) { }\nstatic inline void printk_nmi_direct_exit(void) { }\n#endif /* PRINTK_NMI */\n\nstruct dev_printk_info;\n\n#ifdef CONFIG_PRINTK\nasmlinkage __printf(4, 0)\nint vprintk_emit(int facility, int level,\n\t\t const struct dev_printk_info *dev_info,\n\t\t const char *fmt, va_list args);\n\nasmlinkage __printf(1, 0)\nint vprintk(const char *fmt, va_list args);\n\nasmlinkage __printf(1, 2) __cold\nint printk(const char *fmt, ...);\n\n/*\n * Special printk facility for scheduler/timekeeping use only, _DO_NOT_USE_ !\n */\n__printf(1, 2) __cold int printk_deferred(const char *fmt, ...);\n\n/*\n * Please don't use printk_ratelimit(), because it shares ratelimiting state\n * with all other unrelated printk_ratelimit() callsites.  Instead use\n * printk_ratelimited() or plain old __ratelimit().\n */\nextern int __printk_ratelimit(const char *func);\n#define printk_ratelimit() __printk_ratelimit(__func__)\nextern bool printk_timed_ratelimit(unsigned long *caller_jiffies,\n\t\t\t\t   unsigned int interval_msec);\n\nextern int printk_delay_msec;\nextern int dmesg_restrict;\n\nextern int\ndevkmsg_sysctl_set_loglvl(struct ctl_table *table, int write, void *buf,\n\t\t\t  size_t *lenp, loff_t *ppos);\n\nextern void wake_up_klogd(void);\n\nchar *log_buf_addr_get(void);\nu32 log_buf_len_get(void);\nvoid log_buf_vmcoreinfo_setup(void);\nvoid __init setup_log_buf(int early);\n__printf(1, 2) void dump_stack_set_arch_desc(const char *fmt, ...);\nvoid dump_stack_print_info(const char *log_lvl);\nvoid show_regs_print_info(const char *log_lvl);\nextern asmlinkage void dump_stack(void) __cold;\nextern void printk_safe_flush(void);\nextern void printk_safe_flush_on_panic(void);\n#else\nstatic inline __printf(1, 0)\nint vprintk(const char *s, va_list args)\n{\n\treturn 0;\n}\nstatic inline __printf(1, 2) __cold\nint printk(const char *s, ...)\n{\n\treturn 0;\n}\nstatic inline __printf(1, 2) __cold\nint printk_deferred(const char *s, ...)\n{\n\treturn 0;\n}\nstatic inline int printk_ratelimit(void)\n{\n\treturn 0;\n}\nstatic inline bool printk_timed_ratelimit(unsigned long *caller_jiffies,\n\t\t\t\t\t  unsigned int interval_msec)\n{\n\treturn false;\n}\n\nstatic inline void wake_up_klogd(void)\n{\n}\n\nstatic inline char *log_buf_addr_get(void)\n{\n\treturn NULL;\n}\n\nstatic inline u32 log_buf_len_get(void)\n{\n\treturn 0;\n}\n\nstatic inline void log_buf_vmcoreinfo_setup(void)\n{\n}\n\nstatic inline void setup_log_buf(int early)\n{\n}\n\nstatic inline __printf(1, 2) void dump_stack_set_arch_desc(const char *fmt, ...)\n{\n}\n\nstatic inline void dump_stack_print_info(const char *log_lvl)\n{\n}\n\nstatic inline void show_regs_print_info(const char *log_lvl)\n{\n}\n\nstatic inline void dump_stack(void)\n{\n}\n\nstatic inline void printk_safe_flush(void)\n{\n}\n\nstatic inline void printk_safe_flush_on_panic(void)\n{\n}\n#endif\n\nextern int kptr_restrict;\n\n/**\n * pr_fmt - used by the pr_*() macros to generate the printk format string\n * @fmt: format string passed from a pr_*() macro\n *\n * This macro can be used to generate a unified format string for pr_*()\n * macros. A common use is to prefix all pr_*() messages in a file with a common\n * string. For example, defining this at the top of a source file:\n *\n *        #define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n *\n * would prefix all pr_info, pr_emerg... messages in the file with the module\n * name.\n */\n#ifndef pr_fmt\n#define pr_fmt(fmt) fmt\n#endif\n\n/**\n * pr_emerg - Print an emergency-level message\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_EMERG loglevel. It uses pr_fmt() to\n * generate the format string.\n */\n#define pr_emerg(fmt, ...) \\\n\tprintk(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)\n/**\n * pr_alert - Print an alert-level message\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_ALERT loglevel. It uses pr_fmt() to\n * generate the format string.\n */\n#define pr_alert(fmt, ...) \\\n\tprintk(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)\n/**\n * pr_crit - Print a critical-level message\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_CRIT loglevel. It uses pr_fmt() to\n * generate the format string.\n */\n#define pr_crit(fmt, ...) \\\n\tprintk(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)\n/**\n * pr_err - Print an error-level message\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_ERR loglevel. It uses pr_fmt() to\n * generate the format string.\n */\n#define pr_err(fmt, ...) \\\n\tprintk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)\n/**\n * pr_warn - Print a warning-level message\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_WARNING loglevel. It uses pr_fmt()\n * to generate the format string.\n */\n#define pr_warn(fmt, ...) \\\n\tprintk(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)\n/**\n * pr_notice - Print a notice-level message\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_NOTICE loglevel. It uses pr_fmt() to\n * generate the format string.\n */\n#define pr_notice(fmt, ...) \\\n\tprintk(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)\n/**\n * pr_info - Print an info-level message\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_INFO loglevel. It uses pr_fmt() to\n * generate the format string.\n */\n#define pr_info(fmt, ...) \\\n\tprintk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)\n\n/**\n * pr_cont - Continues a previous log message in the same line.\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_CONT loglevel. It should only be\n * used when continuing a log message with no newline ('\\n') enclosed. Otherwise\n * it defaults back to KERN_DEFAULT loglevel.\n */\n#define pr_cont(fmt, ...) \\\n\tprintk(KERN_CONT fmt, ##__VA_ARGS__)\n\n/**\n * pr_devel - Print a debug-level message conditionally\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_DEBUG loglevel if DEBUG is\n * defined. Otherwise it does nothing.\n *\n * It uses pr_fmt() to generate the format string.\n */\n#ifdef DEBUG\n#define pr_devel(fmt, ...) \\\n\tprintk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#else\n#define pr_devel(fmt, ...) \\\n\tno_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#endif\n\n\n/* If you are writing a driver, please use dev_dbg instead */\n#if defined(CONFIG_DYNAMIC_DEBUG) || \\\n\t(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))\n#include <linux/dynamic_debug.h>\n\n/**\n * pr_debug - Print a debug-level message conditionally\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to dynamic_pr_debug() if CONFIG_DYNAMIC_DEBUG is\n * set. Otherwise, if DEBUG is defined, it's equivalent to a printk with\n * KERN_DEBUG loglevel. If DEBUG is not defined it does nothing.\n *\n * It uses pr_fmt() to generate the format string (dynamic_pr_debug() uses\n * pr_fmt() internally).\n */\n#define pr_debug(fmt, ...)\t\t\t\\\n\tdynamic_pr_debug(fmt, ##__VA_ARGS__)\n#elif defined(DEBUG)\n#define pr_debug(fmt, ...) \\\n\tprintk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#else\n#define pr_debug(fmt, ...) \\\n\tno_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#endif\n\n/*\n * Print a one-time message (analogous to WARN_ONCE() et al):\n */\n\n#ifdef CONFIG_PRINTK\n#define printk_once(fmt, ...)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tstatic bool __section(\".data.once\") __print_once;\t\\\n\tbool __ret_print_once = !__print_once;\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (!__print_once) {\t\t\t\t\t\\\n\t\t__print_once = true;\t\t\t\t\\\n\t\tprintk(fmt, ##__VA_ARGS__);\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_print_once);\t\t\t\t\\\n})\n#define printk_deferred_once(fmt, ...)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tstatic bool __section(\".data.once\") __print_once;\t\\\n\tbool __ret_print_once = !__print_once;\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (!__print_once) {\t\t\t\t\t\\\n\t\t__print_once = true;\t\t\t\t\\\n\t\tprintk_deferred(fmt, ##__VA_ARGS__);\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_print_once);\t\t\t\t\\\n})\n#else\n#define printk_once(fmt, ...)\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__)\n#define printk_deferred_once(fmt, ...)\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__)\n#endif\n\n#define pr_emerg_once(fmt, ...)\t\t\t\t\t\\\n\tprintk_once(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_alert_once(fmt, ...)\t\t\t\t\t\\\n\tprintk_once(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_crit_once(fmt, ...)\t\t\t\t\t\\\n\tprintk_once(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_err_once(fmt, ...)\t\t\t\t\t\\\n\tprintk_once(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_warn_once(fmt, ...)\t\t\t\t\t\\\n\tprintk_once(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_notice_once(fmt, ...)\t\t\t\t\\\n\tprintk_once(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_info_once(fmt, ...)\t\t\t\t\t\\\n\tprintk_once(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)\n/* no pr_cont_once, don't do that... */\n\n#if defined(DEBUG)\n#define pr_devel_once(fmt, ...)\t\t\t\t\t\\\n\tprintk_once(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#else\n#define pr_devel_once(fmt, ...)\t\t\t\t\t\\\n\tno_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#endif\n\n/* If you are writing a driver, please use dev_dbg instead */\n#if defined(DEBUG)\n#define pr_debug_once(fmt, ...)\t\t\t\t\t\\\n\tprintk_once(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#else\n#define pr_debug_once(fmt, ...)\t\t\t\t\t\\\n\tno_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#endif\n\n/*\n * ratelimited messages with local ratelimit_state,\n * no local ratelimit_state used in the !PRINTK case\n */\n#ifdef CONFIG_PRINTK\n#define printk_ratelimited(fmt, ...)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstatic DEFINE_RATELIMIT_STATE(_rs,\t\t\t\t\\\n\t\t\t\t      DEFAULT_RATELIMIT_INTERVAL,\t\\\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__ratelimit(&_rs))\t\t\t\t\t\t\\\n\t\tprintk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n})\n#else\n#define printk_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__)\n#endif\n\n#define pr_emerg_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_alert_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_crit_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_err_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_warn_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_notice_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_info_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)\n/* no pr_cont_ratelimited, don't do that... */\n\n#if defined(DEBUG)\n#define pr_devel_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#else\n#define pr_devel_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tno_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#endif\n\n/* If you are writing a driver, please use dev_dbg instead */\n#if defined(CONFIG_DYNAMIC_DEBUG) || \\\n\t(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))\n/* descriptor check is first to prevent flooding with \"callbacks suppressed\" */\n#define pr_debug_ratelimited(fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tstatic DEFINE_RATELIMIT_STATE(_rs,\t\t\t\t\\\n\t\t\t\t      DEFAULT_RATELIMIT_INTERVAL,\t\\\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\t\t\\\n\tDEFINE_DYNAMIC_DEBUG_METADATA(descriptor, pr_fmt(fmt));\t\t\\\n\tif (DYNAMIC_DEBUG_BRANCH(descriptor) &&\t\t\t\t\\\n\t    __ratelimit(&_rs))\t\t\t\t\t\t\\\n\t\t__dynamic_pr_debug(&descriptor, pr_fmt(fmt), ##__VA_ARGS__);\t\\\n} while (0)\n#elif defined(DEBUG)\n#define pr_debug_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#else\n#define pr_debug_ratelimited(fmt, ...) \\\n\tno_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#endif\n\nextern const struct file_operations kmsg_fops;\n\nenum {\n\tDUMP_PREFIX_NONE,\n\tDUMP_PREFIX_ADDRESS,\n\tDUMP_PREFIX_OFFSET\n};\nextern int hex_dump_to_buffer(const void *buf, size_t len, int rowsize,\n\t\t\t      int groupsize, char *linebuf, size_t linebuflen,\n\t\t\t      bool ascii);\n#ifdef CONFIG_PRINTK\nextern void print_hex_dump(const char *level, const char *prefix_str,\n\t\t\t   int prefix_type, int rowsize, int groupsize,\n\t\t\t   const void *buf, size_t len, bool ascii);\n#else\nstatic inline void print_hex_dump(const char *level, const char *prefix_str,\n\t\t\t\t  int prefix_type, int rowsize, int groupsize,\n\t\t\t\t  const void *buf, size_t len, bool ascii)\n{\n}\nstatic inline void print_hex_dump_bytes(const char *prefix_str, int prefix_type,\n\t\t\t\t\tconst void *buf, size_t len)\n{\n}\n\n#endif\n\n#if defined(CONFIG_DYNAMIC_DEBUG) || \\\n\t(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))\n#define print_hex_dump_debug(prefix_str, prefix_type, rowsize,\t\\\n\t\t\t     groupsize, buf, len, ascii)\t\\\n\tdynamic_hex_dump(prefix_str, prefix_type, rowsize,\t\\\n\t\t\t groupsize, buf, len, ascii)\n#elif defined(DEBUG)\n#define print_hex_dump_debug(prefix_str, prefix_type, rowsize,\t\t\\\n\t\t\t     groupsize, buf, len, ascii)\t\t\\\n\tprint_hex_dump(KERN_DEBUG, prefix_str, prefix_type, rowsize,\t\\\n\t\t       groupsize, buf, len, ascii)\n#else\nstatic inline void print_hex_dump_debug(const char *prefix_str, int prefix_type,\n\t\t\t\t\tint rowsize, int groupsize,\n\t\t\t\t\tconst void *buf, size_t len, bool ascii)\n{\n}\n#endif\n\n/**\n * print_hex_dump_bytes - shorthand form of print_hex_dump() with default params\n * @prefix_str: string to prefix each line with;\n *  caller supplies trailing spaces for alignment if desired\n * @prefix_type: controls whether prefix of an offset, address, or none\n *  is printed (%DUMP_PREFIX_OFFSET, %DUMP_PREFIX_ADDRESS, %DUMP_PREFIX_NONE)\n * @buf: data blob to dump\n * @len: number of bytes in the @buf\n *\n * Calls print_hex_dump(), with log level of KERN_DEBUG,\n * rowsize of 16, groupsize of 1, and ASCII output included.\n */\n#define print_hex_dump_bytes(prefix_str, prefix_type, buf, len)\t\\\n\tprint_hex_dump_debug(prefix_str, prefix_type, 16, 1, buf, len, true)\n\n#endif\n"}, "4": {"id": 4, "path": "/src/include/linux/ratelimit_types.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_RATELIMIT_TYPES_H\n#define _LINUX_RATELIMIT_TYPES_H\n\n#include <linux/bits.h>\n#include <linux/param.h>\n#include <linux/spinlock_types.h>\n\n#define DEFAULT_RATELIMIT_INTERVAL\t(5 * HZ)\n#define DEFAULT_RATELIMIT_BURST\t\t10\n\n/* issue num suppressed message on exit */\n#define RATELIMIT_MSG_ON_RELEASE\tBIT(0)\n\nstruct ratelimit_state {\n\traw_spinlock_t\tlock;\t\t/* protect the state */\n\n\tint\t\tinterval;\n\tint\t\tburst;\n\tint\t\tprinted;\n\tint\t\tmissed;\n\tunsigned long\tbegin;\n\tunsigned long\tflags;\n};\n\n#define RATELIMIT_STATE_INIT(name, interval_init, burst_init) {\t\t\\\n\t\t.lock\t\t= __RAW_SPIN_LOCK_UNLOCKED(name.lock),\t\\\n\t\t.interval\t= interval_init,\t\t\t\\\n\t\t.burst\t\t= burst_init,\t\t\t\t\\\n\t}\n\n#define RATELIMIT_STATE_INIT_DISABLED\t\t\t\t\t\\\n\tRATELIMIT_STATE_INIT(ratelimit_state, 0, DEFAULT_RATELIMIT_BURST)\n\n#define DEFINE_RATELIMIT_STATE(name, interval_init, burst_init)\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tstruct ratelimit_state name =\t\t\t\t\t\\\n\t\tRATELIMIT_STATE_INIT(name, interval_init, burst_init)\t\\\n\nextern int ___ratelimit(struct ratelimit_state *rs, const char *func);\n#define __ratelimit(state) ___ratelimit(state, __func__)\n\n#endif /* _LINUX_RATELIMIT_TYPES_H */\n"}, "5": {"id": 5, "path": "/src/drivers/hid/hid-belkin.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  HID driver for some belkin \"special\" devices\n *\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>\n *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc\n *  Copyright (c) 2006-2007 Jiri Kosina\n *  Copyright (c) 2008 Jiri Slaby\n */\n\n/*\n */\n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n#define BELKIN_HIDDEV\t0x01\n#define BELKIN_WKBD\t0x02\n\n#define belkin_map_key_clear(c)\thid_map_usage_clear(hi, usage, bit, max, \\\n\t\t\t\t\tEV_KEY, (c))\nstatic int belkin_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tunsigned long quirks = (unsigned long)hid_get_drvdata(hdev);\n\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_CONSUMER ||\n\t\t\t!(quirks & BELKIN_WKBD))\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\tcase 0x03a: belkin_map_key_clear(KEY_SOUND);\t\tbreak;\n\tcase 0x03b: belkin_map_key_clear(KEY_CAMERA);\t\tbreak;\n\tcase 0x03c: belkin_map_key_clear(KEY_DOCUMENTS);\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int belkin_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tunsigned long quirks = id->driver_data;\n\tint ret;\n\n\thid_set_drvdata(hdev, (void *)quirks);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT |\n\t\t((quirks & BELKIN_HIDDEV) ? HID_CONNECT_HIDDEV_FORCE : 0));\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\treturn 0;\nerr_free:\n\treturn ret;\n}\n\nstatic const struct hid_device_id belkin_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BELKIN, USB_DEVICE_ID_FLIP_KVM),\n\t\t.driver_data = BELKIN_HIDDEV },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LABTEC, USB_DEVICE_ID_LABTEC_WIRELESS_KEYBOARD),\n\t\t.driver_data = BELKIN_WKBD },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, belkin_devices);\n\nstatic struct hid_driver belkin_driver = {\n\t.name = \"belkin\",\n\t.id_table = belkin_devices,\n\t.input_mapping = belkin_input_mapping,\n\t.probe = belkin_probe,\n};\nmodule_hid_driver(belkin_driver);\n\nMODULE_LICENSE(\"GPL\");\n"}, "6": {"id": 6, "path": "/src/drivers/hid/hid-cherry.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  HID driver for some cherry \"special\" devices\n *\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>\n *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc\n *  Copyright (c) 2006-2007 Jiri Kosina\n *  Copyright (c) 2008 Jiri Slaby\n */\n\n/*\n */\n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n/*\n * Cherry Cymotion keyboard have an invalid HID report descriptor,\n * that needs fixing before we can parse it.\n */\nstatic __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 18 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n\t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n\t\trdesc[11] = rdesc[16] = 0xff;\n\t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}\n\n#define ch_map_key_clear(c)\thid_map_usage_clear(hi, usage, bit, max, \\\n\t\t\t\t\tEV_KEY, (c))\nstatic int ch_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_CONSUMER)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\tcase 0x301: ch_map_key_clear(KEY_PROG1);\tbreak;\n\tcase 0x302: ch_map_key_clear(KEY_PROG2);\tbreak;\n\tcase 0x303: ch_map_key_clear(KEY_PROG3);\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic const struct hid_device_id ch_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHERRY, USB_DEVICE_ID_CHERRY_CYMOTION) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHERRY, USB_DEVICE_ID_CHERRY_CYMOTION_SOLAR) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, ch_devices);\n\nstatic struct hid_driver ch_driver = {\n\t.name = \"cherry\",\n\t.id_table = ch_devices,\n\t.report_fixup = ch_report_fixup,\n\t.input_mapping = ch_input_mapping,\n};\nmodule_hid_driver(ch_driver);\n\nMODULE_LICENSE(\"GPL\");\n"}, "7": {"id": 7, "path": "/src/drivers/hid/hid-chicony.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  HID driver for some chicony \"special\" devices\n *\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>\n *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc\n *  Copyright (c) 2006-2007 Jiri Kosina\n *  Copyright (c) 2007 Paul Walmsley\n *  Copyright (c) 2008 Jiri Slaby\n */\n\n/*\n */\n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n\n#include \"hid-ids.h\"\n\n#define ch_map_key_clear(c)\thid_map_usage_clear(hi, usage, bit, max, \\\n\t\t\t\t\tEV_KEY, (c))\nstatic int ch_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_MSVENDOR)\n\t\treturn 0;\n\n\tset_bit(EV_REP, hi->input->evbit);\n\tswitch (usage->hid & HID_USAGE) {\n\tcase 0xff01: ch_map_key_clear(BTN_1);\tbreak;\n\tcase 0xff02: ch_map_key_clear(BTN_2);\tbreak;\n\tcase 0xff03: ch_map_key_clear(BTN_3);\tbreak;\n\tcase 0xff04: ch_map_key_clear(BTN_4);\tbreak;\n\tcase 0xff05: ch_map_key_clear(BTN_5);\tbreak;\n\tcase 0xff06: ch_map_key_clear(BTN_6);\tbreak;\n\tcase 0xff07: ch_map_key_clear(BTN_7);\tbreak;\n\tcase 0xff08: ch_map_key_clear(BTN_8);\tbreak;\n\tcase 0xff09: ch_map_key_clear(BTN_9);\tbreak;\n\tcase 0xff0a: ch_map_key_clear(BTN_A);\tbreak;\n\tcase 0xff0b: ch_map_key_clear(BTN_B);\tbreak;\n\tcase 0x00f1: ch_map_key_clear(KEY_WLAN);\tbreak;\n\tcase 0x00f2: ch_map_key_clear(KEY_BRIGHTNESSDOWN);\tbreak;\n\tcase 0x00f3: ch_map_key_clear(KEY_BRIGHTNESSUP);\tbreak;\n\tcase 0x00f4: ch_map_key_clear(KEY_DISPLAY_OFF);\tbreak;\n\tcase 0x00f7: ch_map_key_clear(KEY_CAMERA);\tbreak;\n\tcase 0x00f8: ch_map_key_clear(KEY_PROG1);\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic __u8 *ch_switch12_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\t\n\tif (intf->cur_altsetting->desc.bInterfaceNumber == 1) {\n\t\t/* Change usage maximum and logical maximum from 0x7fff to\n\t\t * 0x2fff, so they don't exceed HID_MAX_USAGES */\n\t\tswitch (hdev->product) {\n\t\tcase USB_DEVICE_ID_CHICONY_ACER_SWITCH12:\n\t\t\tif (*rsize >= 128 && rdesc[64] == 0xff && rdesc[65] == 0x7f\n\t\t\t\t\t&& rdesc[69] == 0xff && rdesc[70] == 0x7f) {\n\t\t\t\thid_info(hdev, \"Fixing up report descriptor\\n\");\n\t\t\t\trdesc[65] = rdesc[70] = 0x2f;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t}\n\treturn rdesc;\n}\n\n\nstatic const struct hid_device_id ch_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_TACTICAL_PAD) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_WIRELESS2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_ACER_SWITCH12) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, ch_devices);\n\nstatic struct hid_driver ch_driver = {\n\t.name = \"chicony\",\n\t.id_table = ch_devices,\n\t.report_fixup = ch_switch12_report_fixup,\n\t.input_mapping = ch_input_mapping,\n};\nmodule_hid_driver(ch_driver);\n\nMODULE_LICENSE(\"GPL\");\n"}, "8": {"id": 8, "path": "/src/drivers/hid/hid-ezkey.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  HID driver for some ezkey \"special\" devices\n *\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>\n *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc\n *  Copyright (c) 2006-2007 Jiri Kosina\n *  Copyright (c) 2008 Jiri Slaby\n */\n\n/*\n */\n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n#define ez_map_rel(c)\thid_map_usage(hi, usage, bit, max, EV_REL, (c))\n#define ez_map_key(c)\thid_map_usage(hi, usage, bit, max, EV_KEY, (c))\n\nstatic int ez_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_CONSUMER)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\tcase 0x230: ez_map_key(BTN_MOUSE);\tbreak;\n\tcase 0x231: ez_map_rel(REL_WHEEL);\tbreak;\n\t/*\n\t * this keyboard has a scrollwheel implemented in\n\t * totally broken way. We map this usage temporarily\n\t * to HWHEEL and handle it in the event quirk handler\n\t */\n\tcase 0x232: ez_map_rel(REL_HWHEEL);\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int ez_event(struct hid_device *hdev, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value)\n{\n\tif (!(hdev->claimed & HID_CLAIMED_INPUT) || !field->hidinput ||\n\t\t\t!usage->type)\n\t\treturn 0;\n\n\t/* handle the temporary quirky mapping to HWHEEL */\n\tif (usage->type == EV_REL && usage->code == REL_HWHEEL) {\n\t\tstruct input_dev *input = field->hidinput->input;\n\t\tinput_event(input, usage->type, REL_WHEEL, -value);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hid_device_id ez_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_EZKEY, USB_DEVICE_ID_BTC_8193) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, ez_devices);\n\nstatic struct hid_driver ez_driver = {\n\t.name = \"ezkey\",\n\t.id_table = ez_devices,\n\t.input_mapping = ez_input_mapping,\n\t.event = ez_event,\n};\nmodule_hid_driver(ez_driver);\n\nMODULE_LICENSE(\"GPL\");\n"}, "9": {"id": 9, "path": "/src/drivers/hid/hid-gyration.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  HID driver for some gyration \"special\" devices\n *\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>\n *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc\n *  Copyright (c) 2008 Jiri Slaby\n *  Copyright (c) 2006-2008 Jiri Kosina\n */\n\n/*\n */\n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n#define gy_map_key_clear(c)\thid_map_usage_clear(hi, usage, bit, max, \\\n\t\t\t\t\tEV_KEY, (c))\nstatic int gyration_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_LOGIVENDOR)\n\t\treturn 0;\n\n\tset_bit(EV_REP, hi->input->evbit);\n\tswitch (usage->hid & HID_USAGE) {\n\t/* Reported on Gyration MCE Remote */\n\tcase 0x00d: gy_map_key_clear(KEY_HOME);\t\tbreak;\n\tcase 0x024: gy_map_key_clear(KEY_DVD);\t\tbreak;\n\tcase 0x025: gy_map_key_clear(KEY_PVR);\t\tbreak;\n\tcase 0x046: gy_map_key_clear(KEY_MEDIA);\tbreak;\n\tcase 0x047: gy_map_key_clear(KEY_MP3);\t\tbreak;\n\tcase 0x048: gy_map_key_clear(KEY_MEDIA);\tbreak;\n\tcase 0x049: gy_map_key_clear(KEY_CAMERA);\tbreak;\n\tcase 0x04a: gy_map_key_clear(KEY_VIDEO);\tbreak;\n\tcase 0x05a: gy_map_key_clear(KEY_TEXT);\t\tbreak;\n\tcase 0x05b: gy_map_key_clear(KEY_RED);\t\tbreak;\n\tcase 0x05c: gy_map_key_clear(KEY_GREEN);\tbreak;\n\tcase 0x05d: gy_map_key_clear(KEY_YELLOW);\tbreak;\n\tcase 0x05e: gy_map_key_clear(KEY_BLUE);\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int gyration_event(struct hid_device *hdev, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value)\n{\n\n\tif (!(hdev->claimed & HID_CLAIMED_INPUT) || !field->hidinput)\n\t\treturn 0;\n\n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_GENDESK &&\n\t\t\t(usage->hid & 0xff) == 0x82) {\n\t\tstruct input_dev *input = field->hidinput->input;\n\t\tinput_event(input, usage->type, usage->code, 1);\n\t\tinput_sync(input);\n\t\tinput_event(input, usage->type, usage->code, 0);\n\t\tinput_sync(input);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hid_device_id gyration_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GYRATION, USB_DEVICE_ID_GYRATION_REMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GYRATION, USB_DEVICE_ID_GYRATION_REMOTE_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_GYRATION, USB_DEVICE_ID_GYRATION_REMOTE_3) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, gyration_devices);\n\nstatic struct hid_driver gyration_driver = {\n\t.name = \"gyration\",\n\t.id_table = gyration_devices,\n\t.input_mapping = gyration_input_mapping,\n\t.event = gyration_event,\n};\nmodule_hid_driver(gyration_driver);\n\nMODULE_LICENSE(\"GPL\");\n"}, "10": {"id": 10, "path": "/src/drivers/hid/hid-ite.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * HID driver for some ITE \"special\" devices\n * Copyright (c) 2017 Hans de Goede <hdegoede@redhat.com>\n */\n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n#define QUIRK_TOUCHPAD_ON_OFF_REPORT\t\tBIT(0)\n\nstatic __u8 *ite_report_fixup(struct hid_device *hdev, __u8 *rdesc, unsigned int *rsize)\n{\n\tunsigned long quirks = (unsigned long)hid_get_drvdata(hdev);\n\n\tif (quirks & QUIRK_TOUCHPAD_ON_OFF_REPORT) {\n\t\tif (*rsize == 188 && rdesc[162] == 0x81 && rdesc[163] == 0x02) {\n\t\t\thid_info(hdev, \"Fixing up ITE keyboard report descriptor\\n\");\n\t\t\trdesc[163] = HID_MAIN_ITEM_RELATIVE;\n\t\t}\n\t}\n\n\treturn rdesc;\n}\n\nstatic int ite_input_mapping(struct hid_device *hdev,\n\t\tstruct hid_input *hi, struct hid_field *field,\n\t\tstruct hid_usage *usage, unsigned long **bit,\n\t\tint *max)\n{\n\n\tunsigned long quirks = (unsigned long)hid_get_drvdata(hdev);\n\n\tif ((quirks & QUIRK_TOUCHPAD_ON_OFF_REPORT) &&\n\t    (usage->hid & HID_USAGE_PAGE) == 0x00880000) {\n\t\tif (usage->hid == 0x00880078) {\n\t\t\t/* Touchpad on, userspace expects F22 for this */\n\t\t\thid_map_usage_clear(hi, usage, bit, max, EV_KEY, KEY_F22);\n\t\t\treturn 1;\n\t\t}\n\t\tif (usage->hid == 0x00880079) {\n\t\t\t/* Touchpad off, userspace expects F23 for this */\n\t\t\thid_map_usage_clear(hi, usage, bit, max, EV_KEY, KEY_F23);\n\t\t\treturn 1;\n\t\t}\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int ite_event(struct hid_device *hdev, struct hid_field *field,\n\t\t     struct hid_usage *usage, __s32 value)\n{\n\tstruct input_dev *input;\n\n\tif (!(hdev->claimed & HID_CLAIMED_INPUT) || !field->hidinput)\n\t\treturn 0;\n\n\tinput = field->hidinput->input;\n\n\t/*\n\t * The ITE8595 always reports 0 as value for the rfkill button. Luckily\n\t * it is the only button in its report, and it sends a report on\n\t * release only, so receiving a report means the button was pressed.\n\t */\n\tif (usage->hid == HID_GD_RFKILL_BTN) {\n\t\tinput_event(input, EV_KEY, KEY_RFKILL, 1);\n\t\tinput_sync(input);\n\t\tinput_event(input, EV_KEY, KEY_RFKILL, 0);\n\t\tinput_sync(input);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int ite_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\n\thid_set_drvdata(hdev, (void *)id->driver_data);\n\n\tret = hid_open_report(hdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n}\n\nstatic const struct hid_device_id ite_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_ITE, USB_DEVICE_ID_ITE8595) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_258A, USB_DEVICE_ID_258A_6A88) },\n\t/* ITE8595 USB kbd ctlr, with Synaptics touchpad connected to it. */\n\t{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,\n\t\t     USB_VENDOR_ID_SYNAPTICS,\n\t\t     USB_DEVICE_ID_SYNAPTICS_ACER_SWITCH5_012),\n\t  .driver_data = QUIRK_TOUCHPAD_ON_OFF_REPORT },\n\t/* ITE8910 USB kbd ctlr, with Synaptics touchpad connected to it. */\n\t{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,\n\t\t     USB_VENDOR_ID_SYNAPTICS,\n\t\t     USB_DEVICE_ID_SYNAPTICS_ACER_ONE_S1003) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, ite_devices);\n\nstatic struct hid_driver ite_driver = {\n\t.name = \"itetech\",\n\t.id_table = ite_devices,\n\t.probe = ite_probe,\n\t.report_fixup = ite_report_fixup,\n\t.input_mapping = ite_input_mapping,\n\t.event = ite_event,\n};\nmodule_hid_driver(ite_driver);\n\nMODULE_LICENSE(\"GPL\");\n"}, "11": {"id": 11, "path": "/src/drivers/hid/hid-kensington.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  HID driver for Kensigton Slimblade Trackball\n *\n *  Copyright (c) 2009 Jiri Kosina\n */\n\n/*\n */\n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n#define ks_map_key(c)\thid_map_usage(hi, usage, bit, max, EV_KEY, (c))\n\nstatic int ks_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_MSVENDOR)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\tcase 0x01: ks_map_key(BTN_MIDDLE);\tbreak;\n\tcase 0x02: ks_map_key(BTN_SIDE);\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic const struct hid_device_id ks_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_KENSINGTON, USB_DEVICE_ID_KS_SLIMBLADE) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, ks_devices);\n\nstatic struct hid_driver ks_driver = {\n\t.name = \"kensington\",\n\t.id_table = ks_devices,\n\t.input_mapping = ks_input_mapping,\n};\nmodule_hid_driver(ks_driver);\n\nMODULE_LICENSE(\"GPL\");\n"}, "12": {"id": 12, "path": "/src/drivers/hid/hid-lg.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  HID driver for some logitech \"special\" devices\n *\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>\n *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc\n *  Copyright (c) 2006-2007 Jiri Kosina\n *  Copyright (c) 2008 Jiri Slaby\n *  Copyright (c) 2010 Hendrik Iben\n */\n\n/*\n */\n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/sched.h>\n#include <linux/usb.h>\n#include <linux/wait.h>\n\n#include \"usbhid/usbhid.h\"\n#include \"hid-ids.h\"\n#include \"hid-lg.h\"\n#include \"hid-lg4ff.h\"\n\n#define LG_RDESC\t\t0x001\n#define LG_BAD_RELATIVE_KEYS\t0x002\n#define LG_DUPLICATE_USAGES\t0x004\n#define LG_EXPANDED_KEYMAP\t0x010\n#define LG_IGNORE_DOUBLED_WHEEL\t0x020\n#define LG_WIRELESS\t\t0x040\n#define LG_INVERT_HWHEEL\t0x080\n#define LG_NOGET\t\t0x100\n#define LG_FF\t\t\t0x200\n#define LG_FF2\t\t\t0x400\n#define LG_RDESC_REL_ABS\t0x800\n#define LG_FF3\t\t\t0x1000\n#define LG_FF4\t\t\t0x2000\n\n/* Size of the original descriptors of the Driving Force (and Pro) wheels */\n#define DF_RDESC_ORIG_SIZE\t130\n#define DFP_RDESC_ORIG_SIZE\t97\n#define FV_RDESC_ORIG_SIZE\t130\n#define MOMO_RDESC_ORIG_SIZE\t87\n#define MOMO2_RDESC_ORIG_SIZE\t87\n#define FFG_RDESC_ORIG_SIZE\t85\n#define FG_RDESC_ORIG_SIZE\t82\n\n/* Fixed report descriptors for Logitech Driving Force (and Pro)\n * wheel controllers\n *\n * The original descriptors hide the separate throttle and brake axes in\n * a custom vendor usage page, providing only a combined value as\n * GenericDesktop.Y.\n * These descriptors remove the combined Y axis and instead report\n * separate throttle (Y) and brake (RZ).\n */\nstatic __u8 df_rdesc_fixed[] = {\n0x05, 0x01,         /*  Usage Page (Desktop),                   */\n0x09, 0x04,         /*  Usage (Joystick),                       */\n0xA1, 0x01,         /*  Collection (Application),               */\n0xA1, 0x02,         /*      Collection (Logical),               */\n0x95, 0x01,         /*          Report Count (1),               */\n0x75, 0x0A,         /*          Report Size (10),               */\n0x14,               /*          Logical Minimum (0),            */\n0x26, 0xFF, 0x03,   /*          Logical Maximum (1023),         */\n0x34,               /*          Physical Minimum (0),           */\n0x46, 0xFF, 0x03,   /*          Physical Maximum (1023),        */\n0x09, 0x30,         /*          Usage (X),                      */\n0x81, 0x02,         /*          Input (Variable),               */\n0x95, 0x0C,         /*          Report Count (12),              */\n0x75, 0x01,         /*          Report Size (1),                */\n0x25, 0x01,         /*          Logical Maximum (1),            */\n0x45, 0x01,         /*          Physical Maximum (1),           */\n0x05, 0x09,         /*          Usage (Buttons),                */\n0x19, 0x01,         /*          Usage Minimum (1),              */\n0x29, 0x0c,         /*          Usage Maximum (12),             */\n0x81, 0x02,         /*          Input (Variable),               */\n0x95, 0x02,         /*          Report Count (2),               */\n0x06, 0x00, 0xFF,   /*          Usage Page (Vendor: 65280),     */\n0x09, 0x01,         /*          Usage (?: 1),                   */\n0x81, 0x02,         /*          Input (Variable),               */\n0x05, 0x01,         /*          Usage Page (Desktop),           */\n0x26, 0xFF, 0x00,   /*          Logical Maximum (255),          */\n0x46, 0xFF, 0x00,   /*          Physical Maximum (255),         */\n0x95, 0x01,         /*          Report Count (1),               */\n0x75, 0x08,         /*          Report Size (8),                */\n0x81, 0x02,         /*          Input (Variable),               */\n0x25, 0x07,         /*          Logical Maximum (7),            */\n0x46, 0x3B, 0x01,   /*          Physical Maximum (315),         */\n0x75, 0x04,         /*          Report Size (4),                */\n0x65, 0x14,         /*          Unit (Degrees),                 */\n0x09, 0x39,         /*          Usage (Hat Switch),             */\n0x81, 0x42,         /*          Input (Variable, Null State),   */\n0x75, 0x01,         /*          Report Size (1),                */\n0x95, 0x04,         /*          Report Count (4),               */\n0x65, 0x00,         /*          Unit (none),                    */\n0x06, 0x00, 0xFF,   /*          Usage Page (Vendor: 65280),     */\n0x09, 0x01,         /*          Usage (?: 1),                   */\n0x25, 0x01,         /*          Logical Maximum (1),            */\n0x45, 0x01,         /*          Physical Maximum (1),           */\n0x81, 0x02,         /*          Input (Variable),               */\n0x05, 0x01,         /*          Usage Page (Desktop),           */\n0x95, 0x01,         /*          Report Count (1),               */\n0x75, 0x08,         /*          Report Size (8),                */\n0x26, 0xFF, 0x00,   /*          Logical Maximum (255),          */\n0x46, 0xFF, 0x00,   /*          Physical Maximum (255),         */\n0x09, 0x31,         /*          Usage (Y),                      */\n0x81, 0x02,         /*          Input (Variable),               */\n0x09, 0x35,         /*          Usage (Rz),                     */\n0x81, 0x02,         /*          Input (Variable),               */\n0xC0,               /*      End Collection,                     */\n0xA1, 0x02,         /*      Collection (Logical),               */\n0x26, 0xFF, 0x00,   /*          Logical Maximum (255),          */\n0x46, 0xFF, 0x00,   /*          Physical Maximum (255),         */\n0x95, 0x07,         /*          Report Count (7),               */\n0x75, 0x08,         /*          Report Size (8),                */\n0x09, 0x03,         /*          Usage (?: 3),                   */\n0x91, 0x02,         /*          Output (Variable),              */\n0xC0,               /*      End Collection,                     */\n0xC0                /*  End Collection                          */\n};\n\nstatic __u8 dfp_rdesc_fixed[] = {\n0x05, 0x01,         /*  Usage Page (Desktop),                   */\n0x09, 0x04,         /*  Usage (Joystick),                       */\n0xA1, 0x01,         /*  Collection (Application),               */\n0xA1, 0x02,         /*      Collection (Logical),               */\n0x95, 0x01,         /*          Report Count (1),               */\n0x75, 0x0E,         /*          Report Size (14),               */\n0x14,               /*          Logical Minimum (0),            */\n0x26, 0xFF, 0x3F,   /*          Logical Maximum (16383),        */\n0x34,               /*          Physical Minimum (0),           */\n0x46, 0xFF, 0x3F,   /*          Physical Maximum (16383),       */\n0x09, 0x30,         /*          Usage (X),                      */\n0x81, 0x02,         /*          Input (Variable),               */\n0x95, 0x0E,         /*          Report Count (14),              */\n0x75, 0x01,         /*          Report Size (1),                */\n0x25, 0x01,         /*          Logical Maximum (1),            */\n0x45, 0x01,         /*          Physical Maximum (1),           */\n0x05, 0x09,         /*          Usage Page (Button),            */\n0x19, 0x01,         /*          Usage Minimum (01h),            */\n0x29, 0x0E,         /*          Usage Maximum (0Eh),            */\n0x81, 0x02,         /*          Input (Variable),               */\n0x05, 0x01,         /*          Usage Page (Desktop),           */\n0x95, 0x01,         /*          Report Count (1),               */\n0x75, 0x04,         /*          Report Size (4),                */\n0x25, 0x07,         /*          Logical Maximum (7),            */\n0x46, 0x3B, 0x01,   /*          Physical Maximum (315),         */\n0x65, 0x14,         /*          Unit (Degrees),                 */\n0x09, 0x39,         /*          Usage (Hat Switch),             */\n0x81, 0x42,         /*          Input (Variable, Nullstate),    */\n0x65, 0x00,         /*          Unit,                           */\n0x26, 0xFF, 0x00,   /*          Logical Maximum (255),          */\n0x46, 0xFF, 0x00,   /*          Physical Maximum (255),         */\n0x75, 0x08,         /*          Report Size (8),                */\n0x81, 0x01,         /*          Input (Constant),               */\n0x09, 0x31,         /*          Usage (Y),                      */\n0x81, 0x02,         /*          Input (Variable),               */\n0x09, 0x35,         /*          Usage (Rz),                     */\n0x81, 0x02,         /*          Input (Variable),               */\n0x81, 0x01,         /*          Input (Constant),               */\n0xC0,               /*      End Collection,                     */\n0xA1, 0x02,         /*      Collection (Logical),               */\n0x09, 0x02,         /*          Usage (02h),                    */\n0x95, 0x07,         /*          Report Count (7),               */\n0x91, 0x02,         /*          Output (Variable),              */\n0xC0,               /*      End Collection,                     */\n0xC0                /*  End Collection                          */\n};\n\nstatic __u8 fv_rdesc_fixed[] = {\n0x05, 0x01,         /*  Usage Page (Desktop),                   */\n0x09, 0x04,         /*  Usage (Joystick),                       */\n0xA1, 0x01,         /*  Collection (Application),               */\n0xA1, 0x02,         /*      Collection (Logical),               */\n0x95, 0x01,         /*          Report Count (1),               */\n0x75, 0x0A,         /*          Report Size (10),               */\n0x15, 0x00,         /*          Logical Minimum (0),            */\n0x26, 0xFF, 0x03,   /*          Logical Maximum (1023),         */\n0x35, 0x00,         /*          Physical Minimum (0),           */\n0x46, 0xFF, 0x03,   /*          Physical Maximum (1023),        */\n0x09, 0x30,         /*          Usage (X),                      */\n0x81, 0x02,         /*          Input (Variable),               */\n0x95, 0x0C,         /*          Report Count (12),              */\n0x75, 0x01,         /*          Report Size (1),                */\n0x25, 0x01,         /*          Logical Maximum (1),            */\n0x45, 0x01,         /*          Physical Maximum (1),           */\n0x05, 0x09,         /*          Usage Page (Button),            */\n0x19, 0x01,         /*          Usage Minimum (01h),            */\n0x29, 0x0C,         /*          Usage Maximum (0Ch),            */\n0x81, 0x02,         /*          Input (Variable),               */\n0x95, 0x02,         /*          Report Count (2),               */\n0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),             */\n0x09, 0x01,         /*          Usage (01h),                    */\n0x81, 0x02,         /*          Input (Variable),               */\n0x09, 0x02,         /*          Usage (02h),                    */\n0x26, 0xFF, 0x00,   /*          Logical Maximum (255),          */\n0x46, 0xFF, 0x00,   /*          Physical Maximum (255),         */\n0x95, 0x01,         /*          Report Count (1),               */\n0x75, 0x08,         /*          Report Size (8),                */\n0x81, 0x02,         /*          Input (Variable),               */\n0x05, 0x01,         /*          Usage Page (Desktop),           */\n0x25, 0x07,         /*          Logical Maximum (7),            */\n0x46, 0x3B, 0x01,   /*          Physical Maximum (315),         */\n0x75, 0x04,         /*          Report Size (4),                */\n0x65, 0x14,         /*          Unit (Degrees),                 */\n0x09, 0x39,         /*          Usage (Hat Switch),             */\n0x81, 0x42,         /*          Input (Variable, Null State),   */\n0x75, 0x01,         /*          Report Size (1),                */\n0x95, 0x04,         /*          Report Count (4),               */\n0x65, 0x00,         /*          Unit,                           */\n0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),             */\n0x09, 0x01,         /*          Usage (01h),                    */\n0x25, 0x01,         /*          Logical Maximum (1),            */\n0x45, 0x01,         /*          Physical Maximum (1),           */\n0x81, 0x02,         /*          Input (Variable),               */\n0x05, 0x01,         /*          Usage Page (Desktop),           */\n0x95, 0x01,         /*          Report Count (1),               */\n0x75, 0x08,         /*          Report Size (8),                */\n0x26, 0xFF, 0x00,   /*          Logical Maximum (255),          */\n0x46, 0xFF, 0x00,   /*          Physical Maximum (255),         */\n0x09, 0x31,         /*          Usage (Y),                      */\n0x81, 0x02,         /*          Input (Variable),               */\n0x09, 0x32,         /*          Usage (Z),                      */\n0x81, 0x02,         /*          Input (Variable),               */\n0xC0,               /*      End Collection,                     */\n0xA1, 0x02,         /*      Collection (Logical),               */\n0x26, 0xFF, 0x00,   /*          Logical Maximum (255),          */\n0x46, 0xFF, 0x00,   /*          Physical Maximum (255),         */\n0x95, 0x07,         /*          Report Count (7),               */\n0x75, 0x08,         /*          Report Size (8),                */\n0x09, 0x03,         /*          Usage (03h),                    */\n0x91, 0x02,         /*          Output (Variable),              */\n0xC0,               /*      End Collection,                     */\n0xC0                /*  End Collection                          */\n};\n\nstatic __u8 momo_rdesc_fixed[] = {\n0x05, 0x01,         /*  Usage Page (Desktop),               */\n0x09, 0x04,         /*  Usage (Joystick),                   */\n0xA1, 0x01,         /*  Collection (Application),           */\n0xA1, 0x02,         /*      Collection (Logical),           */\n0x95, 0x01,         /*          Report Count (1),           */\n0x75, 0x0A,         /*          Report Size (10),           */\n0x15, 0x00,         /*          Logical Minimum (0),        */\n0x26, 0xFF, 0x03,   /*          Logical Maximum (1023),     */\n0x35, 0x00,         /*          Physical Minimum (0),       */\n0x46, 0xFF, 0x03,   /*          Physical Maximum (1023),    */\n0x09, 0x30,         /*          Usage (X),                  */\n0x81, 0x02,         /*          Input (Variable),           */\n0x95, 0x08,         /*          Report Count (8),           */\n0x75, 0x01,         /*          Report Size (1),            */\n0x25, 0x01,         /*          Logical Maximum (1),        */\n0x45, 0x01,         /*          Physical Maximum (1),       */\n0x05, 0x09,         /*          Usage Page (Button),        */\n0x19, 0x01,         /*          Usage Minimum (01h),        */\n0x29, 0x08,         /*          Usage Maximum (08h),        */\n0x81, 0x02,         /*          Input (Variable),           */\n0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),         */\n0x75, 0x0E,         /*          Report Size (14),           */\n0x95, 0x01,         /*          Report Count (1),           */\n0x26, 0xFF, 0x00,   /*          Logical Maximum (255),      */\n0x46, 0xFF, 0x00,   /*          Physical Maximum (255),     */\n0x09, 0x00,         /*          Usage (00h),                */\n0x81, 0x02,         /*          Input (Variable),           */\n0x05, 0x01,         /*          Usage Page (Desktop),       */\n0x75, 0x08,         /*          Report Size (8),            */\n0x09, 0x31,         /*          Usage (Y),                  */\n0x81, 0x02,         /*          Input (Variable),           */\n0x09, 0x32,         /*          Usage (Z),                  */\n0x81, 0x02,         /*          Input (Variable),           */\n0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),         */\n0x09, 0x01,         /*          Usage (01h),                */\n0x81, 0x02,         /*          Input (Variable),           */\n0xC0,               /*      End Collection,                 */\n0xA1, 0x02,         /*      Collection (Logical),           */\n0x09, 0x02,         /*          Usage (02h),                */\n0x95, 0x07,         /*          Report Count (7),           */\n0x91, 0x02,         /*          Output (Variable),          */\n0xC0,               /*      End Collection,                 */\n0xC0                /*  End Collection                      */\n};\n\nstatic __u8 momo2_rdesc_fixed[] = {\n0x05, 0x01,         /*  Usage Page (Desktop),               */\n0x09, 0x04,         /*  Usage (Joystick),                   */\n0xA1, 0x01,         /*  Collection (Application),           */\n0xA1, 0x02,         /*      Collection (Logical),           */\n0x95, 0x01,         /*          Report Count (1),           */\n0x75, 0x0A,         /*          Report Size (10),           */\n0x15, 0x00,         /*          Logical Minimum (0),        */\n0x26, 0xFF, 0x03,   /*          Logical Maximum (1023),     */\n0x35, 0x00,         /*          Physical Minimum (0),       */\n0x46, 0xFF, 0x03,   /*          Physical Maximum (1023),    */\n0x09, 0x30,         /*          Usage (X),                  */\n0x81, 0x02,         /*          Input (Variable),           */\n0x95, 0x0A,         /*          Report Count (10),          */\n0x75, 0x01,         /*          Report Size (1),            */\n0x25, 0x01,         /*          Logical Maximum (1),        */\n0x45, 0x01,         /*          Physical Maximum (1),       */\n0x05, 0x09,         /*          Usage Page (Button),        */\n0x19, 0x01,         /*          Usage Minimum (01h),        */\n0x29, 0x0A,         /*          Usage Maximum (0Ah),        */\n0x81, 0x02,         /*          Input (Variable),           */\n0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),         */\n0x09, 0x00,         /*          Usage (00h),                */\n0x95, 0x04,         /*          Report Count (4),           */\n0x81, 0x02,         /*          Input (Variable),           */\n0x95, 0x01,         /*          Report Count (1),           */\n0x75, 0x08,         /*          Report Size (8),            */\n0x26, 0xFF, 0x00,   /*          Logical Maximum (255),      */\n0x46, 0xFF, 0x00,   /*          Physical Maximum (255),     */\n0x09, 0x01,         /*          Usage (01h),                */\n0x81, 0x02,         /*          Input (Variable),           */\n0x05, 0x01,         /*          Usage Page (Desktop),       */\n0x09, 0x31,         /*          Usage (Y),                  */\n0x81, 0x02,         /*          Input (Variable),           */\n0x09, 0x32,         /*          Usage (Z),                  */\n0x81, 0x02,         /*          Input (Variable),           */\n0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),         */\n0x09, 0x00,         /*          Usage (00h),                */\n0x81, 0x02,         /*          Input (Variable),           */\n0xC0,               /*      End Collection,                 */\n0xA1, 0x02,         /*      Collection (Logical),           */\n0x09, 0x02,         /*          Usage (02h),                */\n0x95, 0x07,         /*          Report Count (7),           */\n0x91, 0x02,         /*          Output (Variable),          */\n0xC0,               /*      End Collection,                 */\n0xC0                /*  End Collection                      */\n};\n\nstatic __u8 ffg_rdesc_fixed[] = {\n0x05, 0x01,         /*  Usage Page (Desktop),               */\n0x09, 0x04,         /*  Usage (Joystik),                    */\n0xA1, 0x01,         /*  Collection (Application),           */\n0xA1, 0x02,         /*      Collection (Logical),           */\n0x95, 0x01,         /*          Report Count (1),           */\n0x75, 0x0A,         /*          Report Size (10),           */\n0x15, 0x00,         /*          Logical Minimum (0),        */\n0x26, 0xFF, 0x03,   /*          Logical Maximum (1023),     */\n0x35, 0x00,         /*          Physical Minimum (0),       */\n0x46, 0xFF, 0x03,   /*          Physical Maximum (1023),    */\n0x09, 0x30,         /*          Usage (X),                  */\n0x81, 0x02,         /*          Input (Variable),           */\n0x95, 0x06,         /*          Report Count (6),           */\n0x75, 0x01,         /*          Report Size (1),            */\n0x25, 0x01,         /*          Logical Maximum (1),        */\n0x45, 0x01,         /*          Physical Maximum (1),       */\n0x05, 0x09,         /*          Usage Page (Button),        */\n0x19, 0x01,         /*          Usage Minimum (01h),        */\n0x29, 0x06,         /*          Usage Maximum (06h),        */\n0x81, 0x02,         /*          Input (Variable),           */\n0x95, 0x01,         /*          Report Count (1),           */\n0x75, 0x08,         /*          Report Size (8),            */\n0x26, 0xFF, 0x00,   /*          Logical Maximum (255),      */\n0x46, 0xFF, 0x00,   /*          Physical Maximum (255),     */\n0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),         */\n0x09, 0x01,         /*          Usage (01h),                */\n0x81, 0x02,         /*          Input (Variable),           */\n0x05, 0x01,         /*          Usage Page (Desktop),       */\n0x81, 0x01,         /*          Input (Constant),           */\n0x09, 0x31,         /*          Usage (Y),                  */\n0x81, 0x02,         /*          Input (Variable),           */\n0x09, 0x32,         /*          Usage (Z),                  */\n0x81, 0x02,         /*          Input (Variable),           */\n0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),         */\n0x09, 0x01,         /*          Usage (01h),                */\n0x81, 0x02,         /*          Input (Variable),           */\n0xC0,               /*      End Collection,                 */\n0xA1, 0x02,         /*      Collection (Logical),           */\n0x09, 0x02,         /*          Usage (02h),                */\n0x95, 0x07,         /*          Report Count (7),           */\n0x91, 0x02,         /*          Output (Variable),          */\n0xC0,               /*      End Collection,                 */\n0xC0                /*  End Collection                      */\n};\n\nstatic __u8 fg_rdesc_fixed[] = {\n0x05, 0x01,         /*  Usage Page (Desktop),               */\n0x09, 0x04,         /*  Usage (Joystik),                    */\n0xA1, 0x01,         /*  Collection (Application),           */\n0xA1, 0x02,         /*      Collection (Logical),           */\n0x15, 0x00,         /*          Logical Minimum (0),        */\n0x26, 0xFF, 0x00,   /*          Logical Maximum (255),      */\n0x35, 0x00,         /*          Physical Minimum (0),       */\n0x46, 0xFF, 0x00,   /*          Physical Maximum (255),     */\n0x75, 0x08,         /*          Report Size (8),            */\n0x95, 0x01,         /*          Report Count (1),           */\n0x09, 0x30,         /*          Usage (X),                  */\n0x81, 0x02,         /*          Input (Variable),           */\n0xA4,               /*  Push,                               */\n0x25, 0x01,         /*          Logical Maximum (1),        */\n0x45, 0x01,         /*          Physical Maximum (1),       */\n0x75, 0x01,         /*          Report Size (1),            */\n0x95, 0x02,         /*          Report Count (2),           */\n0x81, 0x01,         /*          Input (Constant),           */\n0x95, 0x06,         /*          Report Count (6),           */\n0x05, 0x09,         /*          Usage Page (Button),        */\n0x19, 0x01,         /*          Usage Minimum (01h),        */\n0x29, 0x06,         /*          Usage Maximum (06h),        */\n0x81, 0x02,         /*          Input (Variable),           */\n0x05, 0x01,         /*          Usage Page (Desktop),       */\n0xB4,               /*  Pop,                                */\n0x81, 0x02,         /*          Input (Constant),           */\n0x09, 0x31,         /*          Usage (Y),                  */\n0x81, 0x02,         /*          Input (Variable),           */\n0x09, 0x32,         /*          Usage (Z),                  */\n0x81, 0x02,         /*          Input (Variable),           */\n0xC0,               /*      End Collection,                 */\n0xA1, 0x02,         /*      Collection (Logical),           */\n0x26, 0xFF, 0x00,   /*          Logical Maximum (255),      */\n0x46, 0xFF, 0x00,   /*          Physical Maximum (255),     */\n0x75, 0x08,         /*          Report Size (8),            */\n0x95, 0x04,         /*          Report Count (4),           */\n0x09, 0x02,         /*          Usage (02h),                */\n0xB1, 0x02,         /*          Feature (Variable),         */\n0xC0,               /*      End Collection,                 */\n0xC0                /*  End Collection,                     */\n};\n\n/*\n * Certain Logitech keyboards send in report #3 keys which are far\n * above the logical maximum described in descriptor. This extends\n * the original value of 0x28c of logical maximum to 0x104d\n */\nstatic __u8 *lg_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\n\n\tif ((drv_data->quirks & LG_RDESC) && *rsize >= 91 && rdesc[83] == 0x26 &&\n\t\t\trdesc[84] == 0x8c && rdesc[85] == 0x02) {\n\t\thid_info(hdev,\n\t\t\t \"fixing up Logitech keyboard report descriptor\\n\");\n\t\trdesc[84] = rdesc[89] = 0x4d;\n\t\trdesc[85] = rdesc[90] = 0x10;\n\t}\n\tif ((drv_data->quirks & LG_RDESC_REL_ABS) && *rsize >= 51 &&\n\t\t\trdesc[32] == 0x81 && rdesc[33] == 0x06 &&\n\t\t\trdesc[49] == 0x81 && rdesc[50] == 0x06) {\n\t\thid_info(hdev,\n\t\t\t \"fixing up rel/abs in Logitech report descriptor\\n\");\n\t\trdesc[33] = rdesc[50] = 0x02;\n\t}\n\n\tswitch (hdev->product) {\n\n\tcase USB_DEVICE_ID_LOGITECH_WINGMAN_FG:\n\t\tif (*rsize == FG_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Wingman Formula GP report descriptor\\n\");\n\t\t\trdesc = fg_rdesc_fixed;\n\t\t\t*rsize = sizeof(fg_rdesc_fixed);\n\t\t} else {\n\t\t\thid_info(hdev,\n\t\t\t\t\"rdesc size test failed for formula gp\\n\");\n\t\t}\n\t\tbreak;\n\n\n\tcase USB_DEVICE_ID_LOGITECH_WINGMAN_FFG:\n\t\tif (*rsize == FFG_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Wingman Formula Force GP report descriptor\\n\");\n\t\t\trdesc = ffg_rdesc_fixed;\n\t\t\t*rsize = sizeof(ffg_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\t/* Several wheels report as this id when operating in emulation mode. */\n\tcase USB_DEVICE_ID_LOGITECH_WHEEL:\n\t\tif (*rsize == DF_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force report descriptor\\n\");\n\t\t\trdesc = df_rdesc_fixed;\n\t\t\t*rsize = sizeof(df_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:\n\t\tif (*rsize == MOMO_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Force (Red) report descriptor\\n\");\n\t\t\trdesc = momo_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:\n\t\tif (*rsize == MOMO2_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Racing Force (Black) report descriptor\\n\");\n\t\t\trdesc = momo2_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo2_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL:\n\t\tif (*rsize == FV_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Formula Vibration report descriptor\\n\");\n\t\t\trdesc = fv_rdesc_fixed;\n\t\t\t*rsize = sizeof(fv_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\tif (*rsize == DFP_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force Pro report descriptor\\n\");\n\t\t\trdesc = dfp_rdesc_fixed;\n\t\t\t*rsize = sizeof(dfp_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_WII_WHEEL:\n\t\tif (*rsize >= 101 && rdesc[41] == 0x95 && rdesc[42] == 0x0B &&\n\t\t\t\trdesc[47] == 0x05 && rdesc[48] == 0x09) {\n\t\t\thid_info(hdev, \"fixing up Logitech Speed Force Wireless report descriptor\\n\");\n\t\t\trdesc[41] = 0x05;\n\t\t\trdesc[42] = 0x09;\n\t\t\trdesc[47] = 0x95;\n\t\t\trdesc[48] = 0x0B;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn rdesc;\n}\n\n#define lg_map_key_clear(c)\thid_map_usage_clear(hi, usage, bit, max, \\\n\t\tEV_KEY, (c))\n\nstatic int lg_ultrax_remote_mapping(struct hid_input *hi,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_LOGIVENDOR)\n\t\treturn 0;\n\n\tset_bit(EV_REP, hi->input->evbit);\n\tswitch (usage->hid & HID_USAGE) {\n\t/* Reported on Logitech Ultra X Media Remote */\n\tcase 0x004: lg_map_key_clear(KEY_AGAIN);\tbreak;\n\tcase 0x00d: lg_map_key_clear(KEY_HOME);\t\tbreak;\n\tcase 0x024: lg_map_key_clear(KEY_SHUFFLE);\tbreak;\n\tcase 0x025: lg_map_key_clear(KEY_TV);\t\tbreak;\n\tcase 0x026: lg_map_key_clear(KEY_MENU);\t\tbreak;\n\tcase 0x031: lg_map_key_clear(KEY_AUDIO);\tbreak;\n\tcase 0x032: lg_map_key_clear(KEY_TEXT);\t\tbreak;\n\tcase 0x033: lg_map_key_clear(KEY_LAST);\t\tbreak;\n\tcase 0x047: lg_map_key_clear(KEY_MP3);\t\tbreak;\n\tcase 0x048: lg_map_key_clear(KEY_DVD);\t\tbreak;\n\tcase 0x049: lg_map_key_clear(KEY_MEDIA);\tbreak;\n\tcase 0x04a: lg_map_key_clear(KEY_VIDEO);\tbreak;\n\tcase 0x04b: lg_map_key_clear(KEY_ANGLE);\tbreak;\n\tcase 0x04c: lg_map_key_clear(KEY_LANGUAGE);\tbreak;\n\tcase 0x04d: lg_map_key_clear(KEY_SUBTITLE);\tbreak;\n\tcase 0x051: lg_map_key_clear(KEY_RED);\t\tbreak;\n\tcase 0x052: lg_map_key_clear(KEY_CLOSE);\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int lg_dinovo_mapping(struct hid_input *hi, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_LOGIVENDOR)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\n\tcase 0x00d: lg_map_key_clear(KEY_MEDIA);\tbreak;\n\tdefault:\n\t\treturn 0;\n\n\t}\n\treturn 1;\n}\n\nstatic int lg_wireless_mapping(struct hid_input *hi, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_CONSUMER)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\tcase 0x1001: lg_map_key_clear(KEY_MESSENGER);\t\tbreak;\n\tcase 0x1003: lg_map_key_clear(KEY_SOUND);\t\tbreak;\n\tcase 0x1004: lg_map_key_clear(KEY_VIDEO);\t\tbreak;\n\tcase 0x1005: lg_map_key_clear(KEY_AUDIO);\t\tbreak;\n\tcase 0x100a: lg_map_key_clear(KEY_DOCUMENTS);\t\tbreak;\n\t/* The following two entries are Playlist 1 and 2 on the MX3200 */\n\tcase 0x100f: lg_map_key_clear(KEY_FN_1);\t\tbreak;\n\tcase 0x1010: lg_map_key_clear(KEY_FN_2);\t\tbreak;\n\tcase 0x1011: lg_map_key_clear(KEY_PREVIOUSSONG);\tbreak;\n\tcase 0x1012: lg_map_key_clear(KEY_NEXTSONG);\t\tbreak;\n\tcase 0x1013: lg_map_key_clear(KEY_CAMERA);\t\tbreak;\n\tcase 0x1014: lg_map_key_clear(KEY_MESSENGER);\t\tbreak;\n\tcase 0x1015: lg_map_key_clear(KEY_RECORD);\t\tbreak;\n\tcase 0x1016: lg_map_key_clear(KEY_PLAYER);\t\tbreak;\n\tcase 0x1017: lg_map_key_clear(KEY_EJECTCD);\t\tbreak;\n\tcase 0x1018: lg_map_key_clear(KEY_MEDIA);\t\tbreak;\n\tcase 0x1019: lg_map_key_clear(KEY_PROG1);\t\tbreak;\n\tcase 0x101a: lg_map_key_clear(KEY_PROG2);\t\tbreak;\n\tcase 0x101b: lg_map_key_clear(KEY_PROG3);\t\tbreak;\n\tcase 0x101c: lg_map_key_clear(KEY_CYCLEWINDOWS);\tbreak;\n\tcase 0x101f: lg_map_key_clear(KEY_ZOOMIN);\t\tbreak;\n\tcase 0x1020: lg_map_key_clear(KEY_ZOOMOUT);\t\tbreak;\n\tcase 0x1021: lg_map_key_clear(KEY_ZOOMRESET);\t\tbreak;\n\tcase 0x1023: lg_map_key_clear(KEY_CLOSE);\t\tbreak;\n\tcase 0x1027: lg_map_key_clear(KEY_MENU);\t\tbreak;\n\t/* this one is marked as 'Rotate' */\n\tcase 0x1028: lg_map_key_clear(KEY_ANGLE);\t\tbreak;\n\tcase 0x1029: lg_map_key_clear(KEY_SHUFFLE);\t\tbreak;\n\tcase 0x102a: lg_map_key_clear(KEY_BACK);\t\tbreak;\n\tcase 0x102b: lg_map_key_clear(KEY_CYCLEWINDOWS);\tbreak;\n\tcase 0x102d: lg_map_key_clear(KEY_WWW);\t\t\tbreak;\n\t/* The following two are 'Start/answer call' and 'End/reject call'\n\t   on the MX3200 */\n\tcase 0x1031: lg_map_key_clear(KEY_OK);\t\t\tbreak;\n\tcase 0x1032: lg_map_key_clear(KEY_CANCEL);\t\tbreak;\n\tcase 0x1041: lg_map_key_clear(KEY_BATTERY);\t\tbreak;\n\tcase 0x1042: lg_map_key_clear(KEY_WORDPROCESSOR);\tbreak;\n\tcase 0x1043: lg_map_key_clear(KEY_SPREADSHEET);\t\tbreak;\n\tcase 0x1044: lg_map_key_clear(KEY_PRESENTATION);\tbreak;\n\tcase 0x1045: lg_map_key_clear(KEY_UNDO);\t\tbreak;\n\tcase 0x1046: lg_map_key_clear(KEY_REDO);\t\tbreak;\n\tcase 0x1047: lg_map_key_clear(KEY_PRINT);\t\tbreak;\n\tcase 0x1048: lg_map_key_clear(KEY_SAVE);\t\tbreak;\n\tcase 0x1049: lg_map_key_clear(KEY_PROG1);\t\tbreak;\n\tcase 0x104a: lg_map_key_clear(KEY_PROG2);\t\tbreak;\n\tcase 0x104b: lg_map_key_clear(KEY_PROG3);\t\tbreak;\n\tcase 0x104c: lg_map_key_clear(KEY_PROG4);\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int lg_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\t/* extended mapping for certain Logitech hardware (Logitech cordless\n\t   desktop LX500) */\n\tstatic const u8 e_keymap[] = {\n\t\t  0,216,  0,213,175,156,  0,  0,  0,  0,\n\t\t144,  0,  0,  0,  0,  0,  0,  0,  0,212,\n\t\t174,167,152,161,112,  0,  0,  0,154,  0,\n\t\t  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t\t  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t\t  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t\t  0,  0,  0,  0,  0,183,184,185,186,187,\n\t\t188,189,190,191,192,193,194,  0,  0,  0\n\t};\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\n\tunsigned int hid = usage->hid;\n\n\tif (hdev->product == USB_DEVICE_ID_LOGITECH_RECEIVER &&\n\t\t\tlg_ultrax_remote_mapping(hi, usage, bit, max))\n\t\treturn 1;\n\n\tif (hdev->product == USB_DEVICE_ID_DINOVO_MINI &&\n\t\t\tlg_dinovo_mapping(hi, usage, bit, max))\n\t\treturn 1;\n\n\tif ((drv_data->quirks & LG_WIRELESS) && lg_wireless_mapping(hi, usage, bit, max))\n\t\treturn 1;\n\n\tif ((hid & HID_USAGE_PAGE) != HID_UP_BUTTON)\n\t\treturn 0;\n\n\thid &= HID_USAGE;\n\n\t/* Special handling for Logitech Cordless Desktop */\n\tif (field->application == HID_GD_MOUSE) {\n\t\tif ((drv_data->quirks & LG_IGNORE_DOUBLED_WHEEL) &&\n\t\t\t\t(hid == 7 || hid == 8))\n\t\t\treturn -1;\n\t} else {\n\t\tif ((drv_data->quirks & LG_EXPANDED_KEYMAP) &&\n\t\t\t\thid < ARRAY_SIZE(e_keymap) &&\n\t\t\t\te_keymap[hid] != 0) {\n\t\t\thid_map_usage(hi, usage, bit, max, EV_KEY,\n\t\t\t\t\te_keymap[hid]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int lg_input_mapped(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\n\n\tif ((drv_data->quirks & LG_BAD_RELATIVE_KEYS) && usage->type == EV_KEY &&\n\t\t\t(field->flags & HID_MAIN_ITEM_RELATIVE))\n\t\tfield->flags &= ~HID_MAIN_ITEM_RELATIVE;\n\n\tif ((drv_data->quirks & LG_DUPLICATE_USAGES) && (usage->type == EV_KEY ||\n\t\t\t usage->type == EV_REL || usage->type == EV_ABS))\n\t\tclear_bit(usage->code, *bit);\n\n\t/* Ensure that Logitech wheels are not given a default fuzz/flat value */\n\tif (usage->type == EV_ABS && (usage->code == ABS_X ||\n\t\t\tusage->code == ABS_Y || usage->code == ABS_Z ||\n\t\t\tusage->code == ABS_RZ)) {\n\t\tswitch (hdev->product) {\n\t\tcase USB_DEVICE_ID_LOGITECH_G29_WHEEL:\n\t\tcase USB_DEVICE_ID_LOGITECH_WINGMAN_FG:\n\t\tcase USB_DEVICE_ID_LOGITECH_WINGMAN_FFG:\n\t\tcase USB_DEVICE_ID_LOGITECH_WHEEL:\n\t\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:\n\t\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\tcase USB_DEVICE_ID_LOGITECH_G25_WHEEL:\n\t\tcase USB_DEVICE_ID_LOGITECH_DFGT_WHEEL:\n\t\tcase USB_DEVICE_ID_LOGITECH_G27_WHEEL:\n\t\tcase USB_DEVICE_ID_LOGITECH_WII_WHEEL:\n\t\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:\n\t\tcase USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL:\n\t\t\tfield->application = HID_GD_MULTIAXIS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int lg_event(struct hid_device *hdev, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value)\n{\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\n\n\tif ((drv_data->quirks & LG_INVERT_HWHEEL) && usage->code == REL_HWHEEL) {\n\t\tinput_event(field->hidinput->input, usage->type, usage->code,\n\t\t\t\t-value);\n\t\treturn 1;\n\t}\n\tif (drv_data->quirks & LG_FF4) {\n\t\treturn lg4ff_adjust_input_event(hdev, field, usage, value, drv_data);\n\t}\n\n\treturn 0;\n}\n\nstatic int lg_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t\tu8 *rd, int size)\n{\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\n\n\tif (drv_data->quirks & LG_FF4)\n\t\treturn lg4ff_raw_event(hdev, report, rd, size, drv_data);\n\n\treturn 0;\n}\n\nstatic int lg_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct usb_interface *iface = to_usb_interface(hdev->dev.parent);\n\t__u8 iface_num = iface->cur_altsetting->desc.bInterfaceNumber;\n\tunsigned int connect_mask = HID_CONNECT_DEFAULT;\n\tstruct lg_drv_data *drv_data;\n\tint ret;\n\n\t/* G29 only work with the 1st interface */\n\tif ((hdev->product == USB_DEVICE_ID_LOGITECH_G29_WHEEL) &&\n\t    (iface_num != 0)) {\n\t\tdbg_hid(\"%s: ignoring ifnum %d\\n\", __func__, iface_num);\n\t\treturn -ENODEV;\n\t}\n\n\tdrv_data = kzalloc(sizeof(struct lg_drv_data), GFP_KERNEL);\n\tif (!drv_data) {\n\t\thid_err(hdev, \"Insufficient memory, cannot allocate driver data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdrv_data->quirks = id->driver_data;\n\n\thid_set_drvdata(hdev, (void *)drv_data);\n\n\tif (drv_data->quirks & LG_NOGET)\n\t\thdev->quirks |= HID_QUIRK_NOGET;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (drv_data->quirks & (LG_FF | LG_FF2 | LG_FF3 | LG_FF4))\n\t\tconnect_mask &= ~HID_CONNECT_FF;\n\n\tret = hid_hw_start(hdev, connect_mask);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\t/* Setup wireless link with Logitech Wii wheel */\n\tif (hdev->product == USB_DEVICE_ID_LOGITECH_WII_WHEEL) {\n\t\tstatic const unsigned char cbuf[] = {\n\t\t\t0x00, 0xAF,  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n\t\t};\n\t\tu8 *buf = kmemdup(cbuf, sizeof(cbuf), GFP_KERNEL);\n\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_stop;\n\t\t}\n\n\t\tret = hid_hw_raw_request(hdev, buf[0], buf, sizeof(cbuf),\n\t\t\t\t\tHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\t\tif (ret >= 0) {\n\t\t\t/* insert a little delay of 10 jiffies ~ 40ms */\n\t\t\twait_queue_head_t wait;\n\t\t\tinit_waitqueue_head (&wait);\n\t\t\twait_event_interruptible_timeout(wait, 0,\n\t\t\t\t\t\t\t msecs_to_jiffies(40));\n\n\t\t\t/* Select random Address */\n\t\t\tbuf[1] = 0xB2;\n\t\t\tget_random_bytes(&buf[2], 2);\n\n\t\t\tret = hid_hw_raw_request(hdev, buf[0], buf, sizeof(cbuf),\n\t\t\t\t\tHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\n\t\t}\n\t\tkfree(buf);\n\t}\n\n\tif (drv_data->quirks & LG_FF)\n\t\tret = lgff_init(hdev);\n\telse if (drv_data->quirks & LG_FF2)\n\t\tret = lg2ff_init(hdev);\n\telse if (drv_data->quirks & LG_FF3)\n\t\tret = lg3ff_init(hdev);\n\telse if (drv_data->quirks & LG_FF4)\n\t\tret = lg4ff_init(hdev);\n\n\tif (ret)\n\t\tgoto err_stop;\n\n\treturn 0;\n\nerr_stop:\n\thid_hw_stop(hdev);\nerr_free:\n\tkfree(drv_data);\n\treturn ret;\n}\n\nstatic void lg_remove(struct hid_device *hdev)\n{\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\n\tif (drv_data->quirks & LG_FF4)\n\t\tlg4ff_deinit(hdev);\n\thid_hw_stop(hdev);\n\tkfree(drv_data);\n}\n\nstatic const struct hid_device_id lg_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_S510_RECEIVER),\n\t\t.driver_data = LG_RDESC | LG_WIRELESS },\n\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RECEIVER),\n\t\t.driver_data = LG_BAD_RELATIVE_KEYS },\n\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_DINOVO_DESKTOP),\n\t\t.driver_data = LG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_DINOVO_EDGE),\n\t\t.driver_data = LG_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_DINOVO_MINI),\n\t\t.driver_data = LG_DUPLICATE_USAGES },\n\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_ELITE_KBD),\n\t\t.driver_data = LG_IGNORE_DOUBLED_WHEEL | LG_EXPANDED_KEYMAP },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_CORDLESS_DESKTOP_LX500),\n\t\t.driver_data = LG_IGNORE_DOUBLED_WHEEL | LG_EXPANDED_KEYMAP },\n\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_EXTREME_3D),\n\t\t.driver_data = LG_NOGET },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_DUAL_ACTION),\n\t\t.driver_data = LG_NOGET },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WHEEL),\n\t\t.driver_data = LG_NOGET | LG_FF4 },\n\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD_CORD),\n\t\t.driver_data = LG_FF2 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD),\n\t\t.driver_data = LG_FF },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD2_2),\n\t\t.driver_data = LG_FF },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G29_WHEEL),\n\t\t.driver_data = LG_FF4 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WINGMAN_F3D),\n\t\t.driver_data = LG_FF },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_FORCE3D_PRO),\n\t\t.driver_data = LG_FF },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_MOMO_WHEEL),\n\t\t.driver_data = LG_NOGET | LG_FF4 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2),\n\t\t.driver_data = LG_FF4 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL),\n\t\t.driver_data = LG_FF2 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G25_WHEEL),\n\t\t.driver_data = LG_FF4 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_DFGT_WHEEL),\n\t\t.driver_data = LG_FF4 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G27_WHEEL),\n\t\t.driver_data = LG_FF4 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_DFP_WHEEL),\n\t\t.driver_data = LG_NOGET | LG_FF4 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WII_WHEEL),\n\t\t.driver_data = LG_FF4 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WINGMAN_FG),\n\t\t.driver_data = LG_NOGET },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WINGMAN_FFG),\n\t\t.driver_data = LG_NOGET | LG_FF4 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD2),\n\t\t.driver_data = LG_NOGET | LG_FF2 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_FLIGHT_SYSTEM_G940),\n\t\t.driver_data = LG_FF3 },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_SPACENAVIGATOR),\n\t\t.driver_data = LG_RDESC_REL_ABS },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_SPACETRAVELLER),\n\t\t.driver_data = LG_RDESC_REL_ABS },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(hid, lg_devices);\n\nstatic struct hid_driver lg_driver = {\n\t.name = \"logitech\",\n\t.id_table = lg_devices,\n\t.report_fixup = lg_report_fixup,\n\t.input_mapping = lg_input_mapping,\n\t.input_mapped = lg_input_mapped,\n\t.event = lg_event,\n\t.raw_event = lg_raw_event,\n\t.probe = lg_probe,\n\t.remove = lg_remove,\n};\nmodule_hid_driver(lg_driver);\n\n#ifdef CONFIG_LOGIWHEELS_FF\nint lg4ff_no_autoswitch = 0;\nmodule_param_named(lg4ff_no_autoswitch, lg4ff_no_autoswitch, int, S_IRUGO);\nMODULE_PARM_DESC(lg4ff_no_autoswitch, \"Do not switch multimode wheels to their native mode automatically\");\n#endif\n\nMODULE_LICENSE(\"GPL\");\n"}, "13": {"id": 13, "path": "/src/drivers/hid/hid-microsoft.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  HID driver for some microsoft \"special\" devices\n *\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>\n *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc\n *  Copyright (c) 2006-2007 Jiri Kosina\n *  Copyright (c) 2008 Jiri Slaby\n */\n\n/*\n */\n\n#include <linux/device.h>\n#include <linux/input.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n#define MS_HIDINPUT\t\tBIT(0)\n#define MS_ERGONOMY\t\tBIT(1)\n#define MS_PRESENTER\t\tBIT(2)\n#define MS_RDESC\t\tBIT(3)\n#define MS_NOGET\t\tBIT(4)\n#define MS_DUPLICATE_USAGES\tBIT(5)\n#define MS_SURFACE_DIAL\t\tBIT(6)\n#define MS_QUIRK_FF\t\tBIT(7)\n\nstruct ms_data {\n\tunsigned long quirks;\n\tstruct hid_device *hdev;\n\tstruct work_struct ff_worker;\n\t__u8 strong;\n\t__u8 weak;\n\tvoid *output_report_dmabuf;\n};\n\n#define XB1S_FF_REPORT\t\t3\n#define ENABLE_WEAK\t\tBIT(0)\n#define ENABLE_STRONG\t\tBIT(1)\n\nenum {\n\tMAGNITUDE_STRONG = 2,\n\tMAGNITUDE_WEAK,\n\tMAGNITUDE_NUM\n};\n\nstruct xb1s_ff_report {\n\t__u8\treport_id;\n\t__u8\tenable;\n\t__u8\tmagnitude[MAGNITUDE_NUM];\n\t__u8\tduration_10ms;\n\t__u8\tstart_delay_10ms;\n\t__u8\tloop_count;\n} __packed;\n\nstatic __u8 *ms_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tstruct ms_data *ms = hid_get_drvdata(hdev);\n\tunsigned long quirks = ms->quirks;\n\n\t/*\n\t * Microsoft Wireless Desktop Receiver (Model 1028) has\n\t * 'Usage Min/Max' where it ought to have 'Physical Min/Max'\n\t */\n\tif ((quirks & MS_RDESC) && *rsize == 571 && rdesc[557] == 0x19 &&\n\t\t\trdesc[559] == 0x29) {\n\t\thid_info(hdev, \"fixing up Microsoft Wireless Receiver Model 1028 report descriptor\\n\");\n\t\trdesc[557] = 0x35;\n\t\trdesc[559] = 0x45;\n\t}\n\treturn rdesc;\n}\n\n#define ms_map_key_clear(c)\thid_map_usage_clear(hi, usage, bit, max, \\\n\t\t\t\t\tEV_KEY, (c))\nstatic int ms_ergonomy_kb_quirk(struct hid_input *hi, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tstruct input_dev *input = hi->input;\n\n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_CONSUMER) {\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\t/*\n\t\t * Microsoft uses these 2 reserved usage ids for 2 keys on\n\t\t * the MS office kb labelled \"Office Home\" and \"Task Pane\".\n\t\t */\n\t\tcase 0x29d:\n\t\t\tms_map_key_clear(KEY_PROG1);\n\t\t\treturn 1;\n\t\tcase 0x29e:\n\t\t\tms_map_key_clear(KEY_PROG2);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_MSVENDOR)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\tcase 0xfd06: ms_map_key_clear(KEY_CHAT);\tbreak;\n\tcase 0xfd07: ms_map_key_clear(KEY_PHONE);\tbreak;\n\tcase 0xff00:\n\t\t/* Special keypad keys */\n\t\tms_map_key_clear(KEY_KPEQUAL);\n\t\tset_bit(KEY_KPLEFTPAREN, input->keybit);\n\t\tset_bit(KEY_KPRIGHTPAREN, input->keybit);\n\t\tbreak;\n\tcase 0xff01:\n\t\t/* Scroll wheel */\n\t\thid_map_usage_clear(hi, usage, bit, max, EV_REL, REL_WHEEL);\n\t\tbreak;\n\tcase 0xff02:\n\t\t/*\n\t\t * This byte contains a copy of the modifier keys byte of a\n\t\t * standard hid keyboard report, as send by interface 0\n\t\t * (this usage is found on interface 1).\n\t\t *\n\t\t * This byte only gets send when another key in the same report\n\t\t * changes state, and as such is useless, ignore it.\n\t\t */\n\t\treturn -1;\n\tcase 0xff05:\n\t\tset_bit(EV_REP, input->evbit);\n\t\tms_map_key_clear(KEY_F13);\n\t\tset_bit(KEY_F14, input->keybit);\n\t\tset_bit(KEY_F15, input->keybit);\n\t\tset_bit(KEY_F16, input->keybit);\n\t\tset_bit(KEY_F17, input->keybit);\n\t\tset_bit(KEY_F18, input->keybit);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int ms_presenter_8k_quirk(struct hid_input *hi, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_MSVENDOR)\n\t\treturn 0;\n\n\tset_bit(EV_REP, hi->input->evbit);\n\tswitch (usage->hid & HID_USAGE) {\n\tcase 0xfd08: ms_map_key_clear(KEY_FORWARD);\tbreak;\n\tcase 0xfd09: ms_map_key_clear(KEY_BACK);\tbreak;\n\tcase 0xfd0b: ms_map_key_clear(KEY_PLAYPAUSE);\tbreak;\n\tcase 0xfd0e: ms_map_key_clear(KEY_CLOSE);\tbreak;\n\tcase 0xfd0f: ms_map_key_clear(KEY_PLAY);\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int ms_surface_dial_quirk(struct hid_input *hi, struct hid_field *field,\n\t\tstruct hid_usage *usage, unsigned long **bit, int *max)\n{\n\tswitch (usage->hid & HID_USAGE_PAGE) {\n\tcase 0xff070000:\n\tcase HID_UP_DIGITIZER:\n\t\t/* ignore those axis */\n\t\treturn -1;\n\tcase HID_UP_GENDESK:\n\t\tswitch (usage->hid) {\n\t\tcase HID_GD_X:\n\t\tcase HID_GD_Y:\n\t\tcase HID_GD_RFKILL_BTN:\n\t\t\t/* ignore those axis */\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ms_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tstruct ms_data *ms = hid_get_drvdata(hdev);\n\tunsigned long quirks = ms->quirks;\n\n\tif (quirks & MS_ERGONOMY) {\n\t\tint ret = ms_ergonomy_kb_quirk(hi, usage, bit, max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif ((quirks & MS_PRESENTER) &&\n\t\t\tms_presenter_8k_quirk(hi, usage, bit, max))\n\t\treturn 1;\n\n\tif (quirks & MS_SURFACE_DIAL) {\n\t\tint ret = ms_surface_dial_quirk(hi, field, usage, bit, max);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ms_input_mapped(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tstruct ms_data *ms = hid_get_drvdata(hdev);\n\tunsigned long quirks = ms->quirks;\n\n\tif (quirks & MS_DUPLICATE_USAGES)\n\t\tclear_bit(usage->code, *bit);\n\n\treturn 0;\n}\n\nstatic int ms_event(struct hid_device *hdev, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value)\n{\n\tstruct ms_data *ms = hid_get_drvdata(hdev);\n\tunsigned long quirks = ms->quirks;\n\tstruct input_dev *input;\n\n\tif (!(hdev->claimed & HID_CLAIMED_INPUT) || !field->hidinput ||\n\t\t\t!usage->type)\n\t\treturn 0;\n\n\tinput = field->hidinput->input;\n\n\t/* Handling MS keyboards special buttons */\n\tif (quirks & MS_ERGONOMY && usage->hid == (HID_UP_MSVENDOR | 0xff00)) {\n\t\t/* Special keypad keys */\n\t\tinput_report_key(input, KEY_KPEQUAL, value & 0x01);\n\t\tinput_report_key(input, KEY_KPLEFTPAREN, value & 0x02);\n\t\tinput_report_key(input, KEY_KPRIGHTPAREN, value & 0x04);\n\t\treturn 1;\n\t}\n\n\tif (quirks & MS_ERGONOMY && usage->hid == (HID_UP_MSVENDOR | 0xff01)) {\n\t\t/* Scroll wheel */\n\t\tint step = ((value & 0x60) >> 5) + 1;\n\n\t\tswitch (value & 0x1f) {\n\t\tcase 0x01:\n\t\t\tinput_report_rel(input, REL_WHEEL, step);\n\t\t\tbreak;\n\t\tcase 0x1f:\n\t\t\tinput_report_rel(input, REL_WHEEL, -step);\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (quirks & MS_ERGONOMY && usage->hid == (HID_UP_MSVENDOR | 0xff05)) {\n\t\tstatic unsigned int last_key = 0;\n\t\tunsigned int key = 0;\n\t\tswitch (value) {\n\t\tcase 0x01: key = KEY_F14; break;\n\t\tcase 0x02: key = KEY_F15; break;\n\t\tcase 0x04: key = KEY_F16; break;\n\t\tcase 0x08: key = KEY_F17; break;\n\t\tcase 0x10: key = KEY_F18; break;\n\t\t}\n\t\tif (key) {\n\t\t\tinput_event(input, usage->type, key, 1);\n\t\t\tlast_key = key;\n\t\t} else\n\t\t\tinput_event(input, usage->type, last_key, 0);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void ms_ff_worker(struct work_struct *work)\n{\n\tstruct ms_data *ms = container_of(work, struct ms_data, ff_worker);\n\tstruct hid_device *hdev = ms->hdev;\n\tstruct xb1s_ff_report *r = ms->output_report_dmabuf;\n\tint ret;\n\n\tmemset(r, 0, sizeof(*r));\n\n\tr->report_id = XB1S_FF_REPORT;\n\tr->enable = ENABLE_WEAK | ENABLE_STRONG;\n\t/*\n\t * Specifying maximum duration and maximum loop count should\n\t * cover maximum duration of a single effect, which is 65536\n\t * ms\n\t */\n\tr->duration_10ms = U8_MAX;\n\tr->loop_count = U8_MAX;\n\tr->magnitude[MAGNITUDE_STRONG] = ms->strong; /* left actuator */\n\tr->magnitude[MAGNITUDE_WEAK] = ms->weak;     /* right actuator */\n\n\tret = hid_hw_output_report(hdev, (__u8 *)r, sizeof(*r));\n\tif (ret < 0)\n\t\thid_warn(hdev, \"failed to send FF report\\n\");\n}\n\nstatic int ms_play_effect(struct input_dev *dev, void *data,\n\t\t\t  struct ff_effect *effect)\n{\n\tstruct hid_device *hid = input_get_drvdata(dev);\n\tstruct ms_data *ms = hid_get_drvdata(hid);\n\n\tif (effect->type != FF_RUMBLE)\n\t\treturn 0;\n\n\t/*\n\t * Magnitude is 0..100 so scale the 16-bit input here\n\t */\n\tms->strong = ((u32) effect->u.rumble.strong_magnitude * 100) / U16_MAX;\n\tms->weak = ((u32) effect->u.rumble.weak_magnitude * 100) / U16_MAX;\n\n\tschedule_work(&ms->ff_worker);\n\treturn 0;\n}\n\nstatic int ms_init_ff(struct hid_device *hdev)\n{\n\tstruct hid_input *hidinput;\n\tstruct input_dev *input_dev;\n\tstruct ms_data *ms = hid_get_drvdata(hdev);\n\n\tif (list_empty(&hdev->inputs)) {\n\t\thid_err(hdev, \"no inputs found\\n\");\n\t\treturn -ENODEV;\n\t}\n\thidinput = list_entry(hdev->inputs.next, struct hid_input, list);\n\tinput_dev = hidinput->input;\n\n\tif (!(ms->quirks & MS_QUIRK_FF))\n\t\treturn 0;\n\n\tms->hdev = hdev;\n\tINIT_WORK(&ms->ff_worker, ms_ff_worker);\n\n\tms->output_report_dmabuf = devm_kzalloc(&hdev->dev,\n\t\t\t\t\t\tsizeof(struct xb1s_ff_report),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (ms->output_report_dmabuf == NULL)\n\t\treturn -ENOMEM;\n\n\tinput_set_capability(input_dev, EV_FF, FF_RUMBLE);\n\treturn input_ff_create_memless(input_dev, NULL, ms_play_effect);\n}\n\nstatic void ms_remove_ff(struct hid_device *hdev)\n{\n\tstruct ms_data *ms = hid_get_drvdata(hdev);\n\n\tif (!(ms->quirks & MS_QUIRK_FF))\n\t\treturn;\n\n\tcancel_work_sync(&ms->ff_worker);\n}\n\nstatic int ms_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tunsigned long quirks = id->driver_data;\n\tstruct ms_data *ms;\n\tint ret;\n\n\tms = devm_kzalloc(&hdev->dev, sizeof(*ms), GFP_KERNEL);\n\tif (ms == NULL)\n\t\treturn -ENOMEM;\n\n\tms->quirks = quirks;\n\n\thid_set_drvdata(hdev, ms);\n\n\tif (quirks & MS_NOGET)\n\t\thdev->quirks |= HID_QUIRK_NOGET;\n\n\tif (quirks & MS_SURFACE_DIAL)\n\t\thdev->quirks |= HID_QUIRK_INPUT_PER_APP;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT | ((quirks & MS_HIDINPUT) ?\n\t\t\t\tHID_CONNECT_HIDINPUT_FORCE : 0));\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = ms_init_ff(hdev);\n\tif (ret)\n\t\thid_err(hdev, \"could not initialize ff, continuing anyway\");\n\n\treturn 0;\nerr_free:\n\treturn ret;\n}\n\nstatic void ms_remove(struct hid_device *hdev)\n{\n\thid_hw_stop(hdev);\n\tms_remove_ff(hdev);\n}\n\nstatic const struct hid_device_id ms_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_SIDEWINDER_GV),\n\t\t.driver_data = MS_HIDINPUT },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_OFFICE_KB),\n\t\t.driver_data = MS_ERGONOMY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_NE4K),\n\t\t.driver_data = MS_ERGONOMY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_NE4K_JP),\n\t\t.driver_data = MS_ERGONOMY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_NE7K),\n\t\t.driver_data = MS_ERGONOMY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_LK6K),\n\t\t.driver_data = MS_ERGONOMY | MS_RDESC },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_PRESENTER_8K_USB),\n\t\t.driver_data = MS_PRESENTER },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_DIGITAL_MEDIA_3K),\n\t\t.driver_data = MS_ERGONOMY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_DIGITAL_MEDIA_7K),\n\t\t.driver_data = MS_ERGONOMY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_DIGITAL_MEDIA_600),\n\t\t.driver_data = MS_ERGONOMY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_DIGITAL_MEDIA_3KV1),\n\t\t.driver_data = MS_ERGONOMY },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_WIRELESS_OPTICAL_DESKTOP_3_0),\n\t\t.driver_data = MS_NOGET },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_COMFORT_MOUSE_4500),\n\t\t.driver_data = MS_DUPLICATE_USAGES },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_POWER_COVER),\n\t\t.driver_data = MS_HIDINPUT },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_COMFORT_KEYBOARD),\n\t\t.driver_data = MS_ERGONOMY},\n\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_PRESENTER_8K_BT),\n\t\t.driver_data = MS_PRESENTER },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, 0x091B),\n\t\t.driver_data = MS_SURFACE_DIAL },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_XBOX_ONE_S_CONTROLLER),\n\t\t.driver_data = MS_QUIRK_FF },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_8BITDO_SN30_PRO_PLUS),\n\t\t.driver_data = MS_QUIRK_FF },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, ms_devices);\n\nstatic struct hid_driver ms_driver = {\n\t.name = \"microsoft\",\n\t.id_table = ms_devices,\n\t.report_fixup = ms_report_fixup,\n\t.input_mapping = ms_input_mapping,\n\t.input_mapped = ms_input_mapped,\n\t.event = ms_event,\n\t.probe = ms_probe,\n\t.remove = ms_remove,\n};\nmodule_hid_driver(ms_driver);\n\nMODULE_LICENSE(\"GPL\");\n"}, "14": {"id": 14, "path": "/src/drivers/hid/hid-monterey.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  HID driver for some monterey \"special\" devices\n *\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>\n *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc\n *  Copyright (c) 2006-2007 Jiri Kosina\n *  Copyright (c) 2008 Jiri Slaby\n */\n\n/*\n */\n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\nstatic __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 31 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}\n\n#define mr_map_key_clear(c)\thid_map_usage_clear(hi, usage, bit, max, \\\n\t\t\t\t\tEV_KEY, (c))\nstatic int mr_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_CONSUMER)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\tcase 0x156: mr_map_key_clear(KEY_WORDPROCESSOR);\tbreak;\n\tcase 0x157: mr_map_key_clear(KEY_SPREADSHEET);\t\tbreak;\n\tcase 0x158: mr_map_key_clear(KEY_PRESENTATION);\t\tbreak;\n\tcase 0x15c: mr_map_key_clear(KEY_STOP);\t\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic const struct hid_device_id mr_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_MONTEREY, USB_DEVICE_ID_GENIUS_KB29E) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, mr_devices);\n\nstatic struct hid_driver mr_driver = {\n\t.name = \"monterey\",\n\t.id_table = mr_devices,\n\t.report_fixup = mr_report_fixup,\n\t.input_mapping = mr_input_mapping,\n};\nmodule_hid_driver(mr_driver);\n\nMODULE_LICENSE(\"GPL\");\n"}, "15": {"id": 15, "path": "/src/drivers/hid/hid-petalynx.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  HID driver for some petalynx \"special\" devices\n *\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>\n *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc\n *  Copyright (c) 2006-2007 Jiri Kosina\n *  Copyright (c) 2008 Jiri Slaby\n */\n\n/*\n */\n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n/* Petalynx Maxter Remote has maximum for consumer page set too low */\nstatic __u8 *pl_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 62 && rdesc[39] == 0x2a && rdesc[40] == 0xf5 &&\n\t\t\trdesc[41] == 0x00 && rdesc[59] == 0x26 &&\n\t\t\trdesc[60] == 0xf9 && rdesc[61] == 0x00) {\n\t\thid_info(hdev, \"fixing up Petalynx Maxter Remote report descriptor\\n\");\n\t\trdesc[60] = 0xfa;\n\t\trdesc[40] = 0xfa;\n\t}\n\treturn rdesc;\n}\n\n#define pl_map_key_clear(c)\thid_map_usage_clear(hi, usage, bit, max, \\\n\t\t\t\t\tEV_KEY, (c))\nstatic int pl_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_LOGIVENDOR) {\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x05a: pl_map_key_clear(KEY_TEXT);\t\tbreak;\n\t\tcase 0x05b: pl_map_key_clear(KEY_RED);\t\tbreak;\n\t\tcase 0x05c: pl_map_key_clear(KEY_GREEN);\tbreak;\n\t\tcase 0x05d: pl_map_key_clear(KEY_YELLOW);\tbreak;\n\t\tcase 0x05e: pl_map_key_clear(KEY_BLUE);\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_CONSUMER) {\n\t\tswitch (usage->hid & HID_USAGE) {\n\t\tcase 0x0f6: pl_map_key_clear(KEY_NEXT);\t\tbreak;\n\t\tcase 0x0fa: pl_map_key_clear(KEY_BACK);\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int pl_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tint ret;\n\n\thdev->quirks |= HID_QUIRK_NOGET;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\treturn 0;\nerr_free:\n\treturn ret;\n}\n\nstatic const struct hid_device_id pl_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_PETALYNX, USB_DEVICE_ID_PETALYNX_MAXTER_REMOTE) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, pl_devices);\n\nstatic struct hid_driver pl_driver = {\n\t.name = \"petalynx\",\n\t.id_table = pl_devices,\n\t.report_fixup = pl_report_fixup,\n\t.input_mapping = pl_input_mapping,\n\t.probe = pl_probe,\n};\nmodule_hid_driver(pl_driver);\n\nMODULE_LICENSE(\"GPL\");\n"}, "16": {"id": 16, "path": "/src/drivers/hid/hid-samsung.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  HID driver for some samsung \"special\" devices\n *\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>\n *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc\n *  Copyright (c) 2006-2007 Jiri Kosina\n *  Copyright (c) 2008 Jiri Slaby\n *  Copyright (c) 2010 Don Prince <dhprince.devel@yahoo.co.uk>\n *\n *  This driver supports several HID devices:\n *\n *  [0419:0001] Samsung IrDA remote controller (reports as Cypress USB Mouse).\n *\tvarious hid report fixups for different variants.\n *\n *  [0419:0600] Creative Desktop Wireless 6000 keyboard/mouse combo\n *\tseveral key mappings used from the consumer usage page\n *\tdeviate from the USB HUT 1.12 standard.\n */\n\n/*\n */\n\n#include <linux/device.h>\n#include <linux/usb.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n/*\n * There are several variants for 0419:0001:\n *\n * 1. 184 byte report descriptor\n * Vendor specific report #4 has a size of 48 bit,\n * and therefore is not accepted when inspecting the descriptors.\n * As a workaround we reinterpret the report as:\n *   Variable type, count 6, size 8 bit, log. maximum 255\n * The burden to reconstruct the data is moved into user space.\n *\n * 2. 203 byte report descriptor\n * Report #4 has an array field with logical range 0..18 instead of 1..15.\n *\n * 3. 135 byte report descriptor\n * Report #4 has an array field with logical range 0..17 instead of 1..14.\n *\n * 4. 171 byte report descriptor\n * Report #3 has an array field with logical range 0..1 instead of 1..3.\n */\nstatic inline void samsung_irda_dev_trace(struct hid_device *hdev,\n\t\tunsigned int rsize)\n{\n\thid_info(hdev, \"fixing up Samsung IrDA %d byte report descriptor\\n\",\n\t\t rsize);\n}\n\nstatic __u8 *samsung_irda_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize == 184 && rdesc[175] == 0x25 && rdesc[176] == 0x40 &&\n\t\t\trdesc[177] == 0x75 && rdesc[178] == 0x30 &&\n\t\t\trdesc[179] == 0x95 && rdesc[180] == 0x01 &&\n\t\t\trdesc[182] == 0x40) {\n\t\tsamsung_irda_dev_trace(hdev, 184);\n\t\trdesc[176] = 0xff;\n\t\trdesc[178] = 0x08;\n\t\trdesc[180] = 0x06;\n\t\trdesc[182] = 0x42;\n\t} else\n\tif (*rsize == 203 && rdesc[192] == 0x15 && rdesc[193] == 0x0 &&\n\t\t\trdesc[194] == 0x25 && rdesc[195] == 0x12) {\n\t\tsamsung_irda_dev_trace(hdev, 203);\n\t\trdesc[193] = 0x1;\n\t\trdesc[195] = 0xf;\n\t} else\n\tif (*rsize == 135 && rdesc[124] == 0x15 && rdesc[125] == 0x0 &&\n\t\t\trdesc[126] == 0x25 && rdesc[127] == 0x11) {\n\t\tsamsung_irda_dev_trace(hdev, 135);\n\t\trdesc[125] = 0x1;\n\t\trdesc[127] = 0xe;\n\t} else\n\tif (*rsize == 171 && rdesc[160] == 0x15 && rdesc[161] == 0x0 &&\n\t\t\trdesc[162] == 0x25 && rdesc[163] == 0x01) {\n\t\tsamsung_irda_dev_trace(hdev, 171);\n\t\trdesc[161] = 0x1;\n\t\trdesc[163] = 0x3;\n\t}\n\treturn rdesc;\n}\n\n#define samsung_kbd_mouse_map_key_clear(c) \\\n\thid_map_usage_clear(hi, usage, bit, max, EV_KEY, (c))\n\nstatic int samsung_kbd_mouse_input_mapping(struct hid_device *hdev,\n\tstruct hid_input *hi, struct hid_field *field, struct hid_usage *usage,\n\tunsigned long **bit, int *max)\n{\n\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\tunsigned short ifnum = intf->cur_altsetting->desc.bInterfaceNumber;\n\n\tif (1 != ifnum || HID_UP_CONSUMER != (usage->hid & HID_USAGE_PAGE))\n\t\treturn 0;\n\n\tdbg_hid(\"samsung wireless keyboard/mouse input mapping event [0x%x]\\n\",\n\t\tusage->hid & HID_USAGE);\n\n\tswitch (usage->hid & HID_USAGE) {\n\t/* report 2 */\n\tcase 0x183: samsung_kbd_mouse_map_key_clear(KEY_MEDIA); break;\n\tcase 0x195: samsung_kbd_mouse_map_key_clear(KEY_EMAIL);\tbreak;\n\tcase 0x196: samsung_kbd_mouse_map_key_clear(KEY_CALC); break;\n\tcase 0x197: samsung_kbd_mouse_map_key_clear(KEY_COMPUTER); break;\n\tcase 0x22b: samsung_kbd_mouse_map_key_clear(KEY_SEARCH); break;\n\tcase 0x22c: samsung_kbd_mouse_map_key_clear(KEY_WWW); break;\n\tcase 0x22d: samsung_kbd_mouse_map_key_clear(KEY_BACK); break;\n\tcase 0x22e: samsung_kbd_mouse_map_key_clear(KEY_FORWARD); break;\n\tcase 0x22f: samsung_kbd_mouse_map_key_clear(KEY_FAVORITES); break;\n\tcase 0x230: samsung_kbd_mouse_map_key_clear(KEY_REFRESH); break;\n\tcase 0x231: samsung_kbd_mouse_map_key_clear(KEY_STOP); break;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic __u8 *samsung_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\tunsigned int *rsize)\n{\n\tif (USB_DEVICE_ID_SAMSUNG_IR_REMOTE == hdev->product)\n\t\trdesc = samsung_irda_report_fixup(hdev, rdesc, rsize);\n\treturn rdesc;\n}\n\nstatic int samsung_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\tstruct hid_field *field, struct hid_usage *usage,\n\tunsigned long **bit, int *max)\n{\n\tint ret = 0;\n\n\tif (USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE == hdev->product)\n\t\tret = samsung_kbd_mouse_input_mapping(hdev,\n\t\t\thi, field, usage, bit, max);\n\n\treturn ret;\n}\n\nstatic int samsung_probe(struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\tint ret;\n\tunsigned int cmask = HID_CONNECT_DEFAULT;\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (USB_DEVICE_ID_SAMSUNG_IR_REMOTE == hdev->product) {\n\t\tif (hdev->rsize == 184) {\n\t\t\t/* disable hidinput, force hiddev */\n\t\t\tcmask = (cmask & ~HID_CONNECT_HIDINPUT) |\n\t\t\t\tHID_CONNECT_HIDDEV_FORCE;\n\t\t}\n\t}\n\n\tret = hid_hw_start(hdev, cmask);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\treturn 0;\nerr_free:\n\treturn ret;\n}\n\nstatic const struct hid_device_id samsung_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_IR_REMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SAMSUNG, USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, samsung_devices);\n\nstatic struct hid_driver samsung_driver = {\n\t.name = \"samsung\",\n\t.id_table = samsung_devices,\n\t.report_fixup = samsung_report_fixup,\n\t.input_mapping = samsung_input_mapping,\n\t.probe = samsung_probe,\n};\nmodule_hid_driver(samsung_driver);\n\nMODULE_LICENSE(\"GPL\");\n"}, "17": {"id": 17, "path": "/src/drivers/hid/hid-ids.h", "content": "/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n *  USB HID quirks support for Linux\n *\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>\n *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc\n *  Copyright (c) 2006-2007 Jiri Kosina\n */\n\n/*\n */\n\n#ifndef HID_IDS_H_FILE\n#define HID_IDS_H_FILE\n\n#define USB_VENDOR_ID_258A\t\t0x258a\n#define USB_DEVICE_ID_258A_6A88\t\t0x6a88\n\n#define USB_VENDOR_ID_3M\t\t0x0596\n#define USB_DEVICE_ID_3M1968\t\t0x0500\n#define USB_DEVICE_ID_3M2256\t\t0x0502\n#define USB_DEVICE_ID_3M3266\t\t0x0506\n\n#define USB_VENDOR_ID_A4TECH\t\t0x09da\n#define USB_DEVICE_ID_A4TECH_WCP32PU\t0x0006\n#define USB_DEVICE_ID_A4TECH_X5_005D\t0x000a\n#define USB_DEVICE_ID_A4TECH_RP_649\t0x001a\n\n#define USB_VENDOR_ID_AASHIMA\t\t0x06d6\n#define USB_DEVICE_ID_AASHIMA_GAMEPAD\t0x0025\n#define USB_DEVICE_ID_AASHIMA_PREDATOR\t0x0026\n\n#define USB_VENDOR_ID_ACECAD\t\t0x0460\n#define USB_DEVICE_ID_ACECAD_FLAIR\t0x0004\n#define USB_DEVICE_ID_ACECAD_302\t0x0008\n\n#define USB_VENDOR_ID_ACRUX\t\t0x1a34\n\n#define USB_VENDOR_ID_ACTIONSTAR\t0x2101\n#define USB_DEVICE_ID_ACTIONSTAR_1011\t0x1011\n\n#define USB_VENDOR_ID_ADS_TECH\t\t0x06e1\n#define USB_DEVICE_ID_ADS_TECH_RADIO_SI470X\t0xa155\n\n#define USB_VENDOR_ID_AFATECH\t\t0x15a4\n#define USB_DEVICE_ID_AFATECH_AF9016\t0x9016\n\n#define USB_VENDOR_ID_AIPTEK\t\t0x08ca\n#define USB_DEVICE_ID_AIPTEK_01\t\t0x0001\n#define USB_DEVICE_ID_AIPTEK_10\t\t0x0010\n#define USB_DEVICE_ID_AIPTEK_20\t\t0x0020\n#define USB_DEVICE_ID_AIPTEK_21\t\t0x0021\n#define USB_DEVICE_ID_AIPTEK_22\t\t0x0022\n#define USB_DEVICE_ID_AIPTEK_23\t\t0x0023\n#define USB_DEVICE_ID_AIPTEK_24\t\t0x0024\n\n#define USB_VENDOR_ID_AIRCABLE\t\t0x16CA\n#define USB_DEVICE_ID_AIRCABLE1\t\t0x1502\n\n#define USB_VENDOR_ID_AIREN\t\t0x1a2c\n#define USB_DEVICE_ID_AIREN_SLIMPLUS\t0x0002\n\n#define USB_VENDOR_ID_AKAI\t\t0x2011\n#define USB_DEVICE_ID_AKAI_MPKMINI2\t0x0715\n\n#define USB_VENDOR_ID_AKAI_09E8\t\t0x09E8\n#define USB_DEVICE_ID_AKAI_09E8_MIDIMIX\t0x0031\n\n#define USB_VENDOR_ID_ALCOR\t\t0x058f\n#define USB_DEVICE_ID_ALCOR_USBRS232\t0x9720\n#define USB_DEVICE_ID_ALCOR_MALTRON_KB 0x9410\n\n#define USB_VENDOR_ID_ALPS\t\t0x0433\n#define USB_DEVICE_ID_IBM_GAMEPAD\t0x1101\n\n#define USB_VENDOR_ID_ALPS_JP\t\t0x044E\n#define HID_DEVICE_ID_ALPS_U1_DUAL\t0x120B\n#define HID_DEVICE_ID_ALPS_U1\t\t0x1215\n#define HID_DEVICE_ID_ALPS_U1_UNICORN_LEGACY         0x121E\n#define HID_DEVICE_ID_ALPS_T4_BTNLESS\t0x120C\n\n#define USB_VENDOR_ID_AMI\t\t0x046b\n#define USB_DEVICE_ID_AMI_VIRT_KEYBOARD_AND_MOUSE\t0xff10\n\n#define USB_VENDOR_ID_ANTON\t\t0x1130\n#define USB_DEVICE_ID_ANTON_TOUCH_PAD\t0x3101\n\n#define USB_VENDOR_ID_APPLE\t\t0x05ac\n#define BT_VENDOR_ID_APPLE\t\t0x004c\n#define USB_DEVICE_ID_APPLE_MIGHTYMOUSE\t0x0304\n#define USB_DEVICE_ID_APPLE_MAGICMOUSE\t0x030d\n#define USB_DEVICE_ID_APPLE_MAGICTRACKPAD\t0x030e\n#define USB_DEVICE_ID_APPLE_MAGICTRACKPAD2\t0x0265\n#define USB_DEVICE_ID_APPLE_FOUNTAIN_ANSI\t0x020e\n#define USB_DEVICE_ID_APPLE_FOUNTAIN_ISO\t0x020f\n#define USB_DEVICE_ID_APPLE_GEYSER_ANSI\t0x0214\n#define USB_DEVICE_ID_APPLE_GEYSER_ISO\t0x0215\n#define USB_DEVICE_ID_APPLE_GEYSER_JIS\t0x0216\n#define USB_DEVICE_ID_APPLE_GEYSER3_ANSI\t0x0217\n#define USB_DEVICE_ID_APPLE_GEYSER3_ISO\t0x0218\n#define USB_DEVICE_ID_APPLE_GEYSER3_JIS\t0x0219\n#define USB_DEVICE_ID_APPLE_GEYSER4_ANSI\t0x021a\n#define USB_DEVICE_ID_APPLE_GEYSER4_ISO\t0x021b\n#define USB_DEVICE_ID_APPLE_GEYSER4_JIS\t0x021c\n#define USB_DEVICE_ID_APPLE_ALU_MINI_ANSI\t0x021d\n#define USB_DEVICE_ID_APPLE_ALU_MINI_ISO\t0x021e\n#define USB_DEVICE_ID_APPLE_ALU_MINI_JIS\t0x021f\n#define USB_DEVICE_ID_APPLE_ALU_ANSI\t0x0220\n#define USB_DEVICE_ID_APPLE_ALU_ISO\t0x0221\n#define USB_DEVICE_ID_APPLE_ALU_JIS\t0x0222\n#define USB_DEVICE_ID_APPLE_WELLSPRING_ANSI\t0x0223\n#define USB_DEVICE_ID_APPLE_WELLSPRING_ISO\t0x0224\n#define USB_DEVICE_ID_APPLE_WELLSPRING_JIS\t0x0225\n#define USB_DEVICE_ID_APPLE_GEYSER4_HF_ANSI\t0x0229\n#define USB_DEVICE_ID_APPLE_GEYSER4_HF_ISO\t0x022a\n#define USB_DEVICE_ID_APPLE_GEYSER4_HF_JIS\t0x022b\n#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_ANSI\t0x022c\n#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_ISO\t0x022d\n#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_JIS\t0x022e\n#define USB_DEVICE_ID_APPLE_WELLSPRING2_ANSI\t0x0230\n#define USB_DEVICE_ID_APPLE_WELLSPRING2_ISO\t0x0231\n#define USB_DEVICE_ID_APPLE_WELLSPRING2_JIS\t0x0232\n#define USB_DEVICE_ID_APPLE_WELLSPRING3_ANSI\t0x0236\n#define USB_DEVICE_ID_APPLE_WELLSPRING3_ISO\t0x0237\n#define USB_DEVICE_ID_APPLE_WELLSPRING3_JIS\t0x0238\n#define USB_DEVICE_ID_APPLE_WELLSPRING4_ANSI\t0x023f\n#define USB_DEVICE_ID_APPLE_WELLSPRING4_ISO\t0x0240\n#define USB_DEVICE_ID_APPLE_WELLSPRING4_JIS\t0x0241\n#define USB_DEVICE_ID_APPLE_WELLSPRING4A_ANSI\t0x0242\n#define USB_DEVICE_ID_APPLE_WELLSPRING4A_ISO\t0x0243\n#define USB_DEVICE_ID_APPLE_WELLSPRING4A_JIS\t0x0244\n#define USB_DEVICE_ID_APPLE_WELLSPRING5_ANSI\t0x0245\n#define USB_DEVICE_ID_APPLE_WELLSPRING5_ISO\t0x0246\n#define USB_DEVICE_ID_APPLE_WELLSPRING5_JIS\t0x0247\n#define USB_DEVICE_ID_APPLE_ALU_REVB_ANSI\t0x024f\n#define USB_DEVICE_ID_APPLE_ALU_REVB_ISO\t0x0250\n#define USB_DEVICE_ID_APPLE_ALU_REVB_JIS\t0x0251\n#define USB_DEVICE_ID_APPLE_WELLSPRING5A_ANSI\t0x0252\n#define USB_DEVICE_ID_APPLE_WELLSPRING5A_ISO\t0x0253\n#define USB_DEVICE_ID_APPLE_WELLSPRING5A_JIS\t0x0254\n#define USB_DEVICE_ID_APPLE_WELLSPRING7A_ANSI\t0x0259\n#define USB_DEVICE_ID_APPLE_WELLSPRING7A_ISO\t0x025a\n#define USB_DEVICE_ID_APPLE_WELLSPRING7A_JIS\t0x025b\n#define USB_DEVICE_ID_APPLE_WELLSPRING6A_ANSI\t0x0249\n#define USB_DEVICE_ID_APPLE_WELLSPRING6A_ISO\t0x024a\n#define USB_DEVICE_ID_APPLE_WELLSPRING6A_JIS\t0x024b\n#define USB_DEVICE_ID_APPLE_WELLSPRING6_ANSI\t0x024c\n#define USB_DEVICE_ID_APPLE_WELLSPRING6_ISO\t0x024d\n#define USB_DEVICE_ID_APPLE_WELLSPRING6_JIS\t0x024e\n#define USB_DEVICE_ID_APPLE_WELLSPRING7_ANSI\t0x0262\n#define USB_DEVICE_ID_APPLE_WELLSPRING7_ISO\t0x0263\n#define USB_DEVICE_ID_APPLE_WELLSPRING7_JIS\t0x0264\n#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI  0x0239\n#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO   0x023a\n#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_JIS   0x023b\n#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI  0x0255\n#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ISO   0x0256\n#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_JIS   0x0257\n#define USB_DEVICE_ID_APPLE_MAGIC_KEYBOARD_ANSI   0x0267\n#define USB_DEVICE_ID_APPLE_MAGIC_KEYBOARD_NUMPAD_ANSI   0x026c\n#define USB_DEVICE_ID_APPLE_WELLSPRING8_ANSI\t0x0290\n#define USB_DEVICE_ID_APPLE_WELLSPRING8_ISO\t0x0291\n#define USB_DEVICE_ID_APPLE_WELLSPRING8_JIS\t0x0292\n#define USB_DEVICE_ID_APPLE_WELLSPRING9_ANSI\t0x0272\n#define USB_DEVICE_ID_APPLE_WELLSPRING9_ISO\t\t0x0273\n#define USB_DEVICE_ID_APPLE_WELLSPRING9_JIS\t\t0x0274\n#define USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY\t0x030a\n#define USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY\t0x030b\n#define USB_DEVICE_ID_APPLE_IRCONTROL\t0x8240\n#define USB_DEVICE_ID_APPLE_IRCONTROL2\t0x1440\n#define USB_DEVICE_ID_APPLE_IRCONTROL3\t0x8241\n#define USB_DEVICE_ID_APPLE_IRCONTROL4\t0x8242\n#define USB_DEVICE_ID_APPLE_IRCONTROL5\t0x8243\n\n#define USB_VENDOR_ID_ASUS\t\t0x0486\n#define USB_DEVICE_ID_ASUS_T91MT\t0x0185\n#define USB_DEVICE_ID_ASUSTEK_MULTITOUCH_YFO\t0x0186\n\n#define USB_VENDOR_ID_ASUSTEK\t\t0x0b05\n#define USB_DEVICE_ID_ASUSTEK_LCM\t0x1726\n#define USB_DEVICE_ID_ASUSTEK_LCM2\t0x175b\n#define USB_DEVICE_ID_ASUSTEK_T100TA_KEYBOARD\t0x17e0\n#define USB_DEVICE_ID_ASUSTEK_T100TAF_KEYBOARD\t0x1807\n#define USB_DEVICE_ID_ASUSTEK_T100CHI_KEYBOARD\t0x8502\n#define USB_DEVICE_ID_ASUSTEK_T101HA_KEYBOARD\t0x183d\n#define USB_DEVICE_ID_ASUSTEK_T304_KEYBOARD\t0x184a\n#define USB_DEVICE_ID_ASUSTEK_I2C_KEYBOARD\t0x8585\n#define USB_DEVICE_ID_ASUSTEK_I2C_TOUCHPAD\t0x0101\n#define USB_DEVICE_ID_ASUSTEK_ROG_KEYBOARD1 0x1854\n#define USB_DEVICE_ID_ASUSTEK_ROG_KEYBOARD2 0x1837\n#define USB_DEVICE_ID_ASUSTEK_ROG_KEYBOARD3 0x1822\n#define USB_DEVICE_ID_ASUSTEK_ROG_NKEY_KEYBOARD\t0x1866\n#define USB_DEVICE_ID_ASUSTEK_FX503VD_KEYBOARD\t0x1869\n\n#define USB_VENDOR_ID_ATEN\t\t0x0557\n#define USB_DEVICE_ID_ATEN_UC100KM\t0x2004\n#define USB_DEVICE_ID_ATEN_CS124U\t0x2202\n#define USB_DEVICE_ID_ATEN_2PORTKVM\t0x2204\n#define USB_DEVICE_ID_ATEN_4PORTKVM\t0x2205\n#define USB_DEVICE_ID_ATEN_4PORTKVMC\t0x2208\n#define USB_DEVICE_ID_ATEN_CS682\t0x2213\n#define USB_DEVICE_ID_ATEN_CS692\t0x8021\n#define USB_DEVICE_ID_ATEN_CS1758\t0x2220\n\n#define USB_VENDOR_ID_ATMEL\t\t0x03eb\n#define USB_DEVICE_ID_ATMEL_MULTITOUCH\t0x211c\n#define USB_DEVICE_ID_ATMEL_MXT_DIGITIZER\t0x2118\n#define USB_VENDOR_ID_ATMEL_V_USB\t0x16c0\n#define USB_DEVICE_ID_ATMEL_V_USB\t0x05df\n\n#define USB_VENDOR_ID_AUREAL\t\t0x0755\n#define USB_DEVICE_ID_AUREAL_W01RN\t0x2626\n\n#define USB_VENDOR_ID_AVERMEDIA\t\t0x07ca\n#define USB_DEVICE_ID_AVER_FM_MR800\t0xb800\n\n#define USB_VENDOR_ID_AXENTIA\t\t0x12cf\n#define USB_DEVICE_ID_AXENTIA_FM_RADIO\t0x7111\n\n#define USB_VENDOR_ID_BAANTO\t\t0x2453\n#define USB_DEVICE_ID_BAANTO_MT_190W2\t0x0100\n\n#define USB_VENDOR_ID_BELKIN\t\t0x050d\n#define USB_DEVICE_ID_FLIP_KVM\t\t0x3201\n\n#define USB_VENDOR_ID_BERKSHIRE\t\t0x0c98\n#define USB_DEVICE_ID_BERKSHIRE_PCWD\t0x1140\n\n#define USB_VENDOR_ID_BETOP_2185BFM\t0x11c2\n#define USB_VENDOR_ID_BETOP_2185PC\t0x11c0\n#define USB_VENDOR_ID_BETOP_2185V2PC\t0x8380\n#define USB_VENDOR_ID_BETOP_2185V2BFM\t0x20bc\n\n#define USB_VENDOR_ID_BIGBEN\t0x146b\n#define USB_DEVICE_ID_BIGBEN_PS3OFMINIPAD\t0x0902\n\n#define USB_VENDOR_ID_BTC\t\t0x046e\n#define USB_DEVICE_ID_BTC_EMPREX_REMOTE\t0x5578\n#define USB_DEVICE_ID_BTC_EMPREX_REMOTE_2\t0x5577\n\n#define USB_VENDOR_ID_CANDO\t\t0x2087\n#define USB_DEVICE_ID_CANDO_PIXCIR_MULTI_TOUCH 0x0703\n#define USB_DEVICE_ID_CANDO_MULTI_TOUCH\t0x0a01\n#define USB_DEVICE_ID_CANDO_MULTI_TOUCH_10_1 0x0a02\n#define USB_DEVICE_ID_CANDO_MULTI_TOUCH_11_6 0x0b03\n#define USB_DEVICE_ID_CANDO_MULTI_TOUCH_15_6 0x0f01\n\n#define USB_VENDOR_ID_CH\t\t0x068e\n#define USB_DEVICE_ID_CH_PRO_THROTTLE\t0x00f1\n#define USB_DEVICE_ID_CH_PRO_PEDALS\t0x00f2\n#define USB_DEVICE_ID_CH_FIGHTERSTICK\t0x00f3\n#define USB_DEVICE_ID_CH_COMBATSTICK\t0x00f4\n#define USB_DEVICE_ID_CH_FLIGHT_SIM_ECLIPSE_YOKE       0x0051\n#define USB_DEVICE_ID_CH_FLIGHT_SIM_YOKE\t0x00ff\n#define USB_DEVICE_ID_CH_3AXIS_5BUTTON_STICK\t0x00d3\n#define USB_DEVICE_ID_CH_AXIS_295\t0x001c\n\n#define USB_VENDOR_ID_CHERRY\t\t0x046a\n#define USB_DEVICE_ID_CHERRY_CYMOTION\t0x0023\n#define USB_DEVICE_ID_CHERRY_CYMOTION_SOLAR\t0x0027\n\n#define USB_VENDOR_ID_CHIC\t\t0x05fe\n#define USB_DEVICE_ID_CHIC_GAMEPAD\t0x0014\n\n#define USB_VENDOR_ID_CHICONY\t\t0x04f2\n#define USB_DEVICE_ID_CHICONY_TACTICAL_PAD\t0x0418\n#define USB_DEVICE_ID_CHICONY_MULTI_TOUCH\t0xb19d\n#define USB_DEVICE_ID_CHICONY_WIRELESS\t0x0618\n#define USB_DEVICE_ID_CHICONY_PIXART_USB_OPTICAL_MOUSE\t0x1053\n#define USB_DEVICE_ID_CHICONY_PIXART_USB_OPTICAL_MOUSE2\t0x0939\n#define USB_DEVICE_ID_CHICONY_WIRELESS2\t0x1123\n#define USB_DEVICE_ID_ASUS_AK1D\t\t0x1125\n#define USB_DEVICE_ID_CHICONY_TOSHIBA_WT10A\t0x1408\n#define USB_DEVICE_ID_CHICONY_ACER_SWITCH12\t0x1421\n\n#define USB_VENDOR_ID_CHUNGHWAT\t\t0x2247\n#define USB_DEVICE_ID_CHUNGHWAT_MULTITOUCH\t0x0001\n\n#define USB_VENDOR_ID_CIDC\t\t0x1677\n\n#define USB_VENDOR_ID_CJTOUCH\t\t0x24b8\n#define USB_DEVICE_ID_CJTOUCH_MULTI_TOUCH_0020\t0x0020\n#define USB_DEVICE_ID_CJTOUCH_MULTI_TOUCH_0040\t0x0040\n\n#define USB_VENDOR_ID_CMEDIA\t\t0x0d8c\n#define USB_DEVICE_ID_CM109\t\t0x000e\n#define USB_DEVICE_ID_CM6533\t\t0x0022\n\n#define USB_VENDOR_ID_CODEMERCS\t\t0x07c0\n#define USB_DEVICE_ID_CODEMERCS_IOW_FIRST\t0x1500\n#define USB_DEVICE_ID_CODEMERCS_IOW_LAST\t0x15ff\n\n#define USB_VENDOR_ID_CORSAIR\t\t0x1b1c\n#define USB_DEVICE_ID_CORSAIR_K90\t0x1b02\n\n#define USB_VENDOR_ID_CORSAIR           0x1b1c\n#define USB_DEVICE_ID_CORSAIR_K70R      0x1b09\n#define USB_DEVICE_ID_CORSAIR_K95RGB    0x1b11\n#define USB_DEVICE_ID_CORSAIR_M65RGB    0x1b12\n#define USB_DEVICE_ID_CORSAIR_K70RGB    0x1b13\n#define USB_DEVICE_ID_CORSAIR_STRAFE    0x1b15\n#define USB_DEVICE_ID_CORSAIR_K65RGB    0x1b17\n#define USB_DEVICE_ID_CORSAIR_GLAIVE_RGB        0x1b34\n#define USB_DEVICE_ID_CORSAIR_K70RGB_RAPIDFIRE  0x1b38\n#define USB_DEVICE_ID_CORSAIR_K65RGB_RAPIDFIRE  0x1b39\n#define USB_DEVICE_ID_CORSAIR_SCIMITAR_PRO_RGB  0x1b3e\n\n#define USB_VENDOR_ID_CREATIVELABS\t0x041e\n#define USB_DEVICE_ID_CREATIVE_SB_OMNI_SURROUND_51\t0x322c\n#define USB_DEVICE_ID_PRODIKEYS_PCMIDI\t0x2801\n#define USB_DEVICE_ID_CREATIVE_SB0540\t0x3100\n\n#define USB_VENDOR_ID_CVTOUCH\t\t0x1ff7\n#define USB_DEVICE_ID_CVTOUCH_SCREEN\t0x0013\n\n#define USB_VENDOR_ID_CYGNAL\t\t0x10c4\n#define USB_DEVICE_ID_CYGNAL_RADIO_SI470X\t0x818a\n#define USB_DEVICE_ID_FOCALTECH_FTXXXX_MULTITOUCH\t0x81b9\n#define USB_DEVICE_ID_CYGNAL_CP2112\t0xea90\n#define USB_DEVICE_ID_U2F_ZERO\t\t0x8acf\n\n#define USB_DEVICE_ID_CYGNAL_RADIO_SI4713       0x8244\n\n#define USB_VENDOR_ID_CYPRESS\t\t0x04b4\n#define USB_DEVICE_ID_CYPRESS_MOUSE\t0x0001\n#define USB_DEVICE_ID_CYPRESS_HIDCOM\t0x5500\n#define USB_DEVICE_ID_CYPRESS_ULTRAMOUSE\t0x7417\n#define USB_DEVICE_ID_CYPRESS_BARCODE_1\t0xde61\n#define USB_DEVICE_ID_CYPRESS_BARCODE_2\t0xde64\n#define USB_DEVICE_ID_CYPRESS_BARCODE_3\t0xbca1\n#define USB_DEVICE_ID_CYPRESS_BARCODE_4\t0xed81\n#define USB_DEVICE_ID_CYPRESS_TRUETOUCH\t0xc001\n\n#define USB_DEVICE_ID_CYPRESS_VARMILO_VA104M_07B1   0X07b1\n\n#define USB_VENDOR_ID_DATA_MODUL\t0x7374\n#define USB_VENDOR_ID_DATA_MODUL_EASYMAXTOUCH\t0x1201\n\n#define USB_VENDOR_ID_DEALEXTREAME\t0x10c5\n#define USB_DEVICE_ID_DEALEXTREAME_RADIO_SI4701\t0x819a\n\n#define USB_VENDOR_ID_DELCOM\t\t0x0fc5\n#define USB_DEVICE_ID_DELCOM_VISUAL_IND\t0xb080\n\n#define USB_VENDOR_ID_DELL\t\t\t\t0x413c\n#define USB_DEVICE_ID_DELL_PIXART_USB_OPTICAL_MOUSE\t0x301a\n\n#define USB_VENDOR_ID_DELORME\t\t0x1163\n#define USB_DEVICE_ID_DELORME_EARTHMATE\t0x0100\n#define USB_DEVICE_ID_DELORME_EM_LT20\t0x0200\n\n#define USB_VENDOR_ID_DMI\t\t0x0c0b\n#define USB_DEVICE_ID_DMI_ENC\t\t0x5fab\n\n#define USB_VENDOR_ID_DRAGONRISE\t\t0x0079\n#define USB_DEVICE_ID_REDRAGON_SEYMUR2\t\t0x0006\n#define USB_DEVICE_ID_DRAGONRISE_WIIU\t\t0x1800\n#define USB_DEVICE_ID_DRAGONRISE_PS3\t\t0x1801\n#define USB_DEVICE_ID_DRAGONRISE_DOLPHINBAR\t0x1803\n#define USB_DEVICE_ID_DRAGONRISE_GAMECUBE1\t0x1843\n#define USB_DEVICE_ID_DRAGONRISE_GAMECUBE2\t0x1844\n#define USB_DEVICE_ID_DRAGONRISE_GAMECUBE3\t0x1846\n\n#define USB_VENDOR_ID_DWAV\t\t0x0eef\n#define USB_DEVICE_ID_EGALAX_TOUCHCONTROLLER\t0x0001\n#define USB_DEVICE_ID_DWAV_TOUCHCONTROLLER\t0x0002\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_480D\t0x480d\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_480E\t0x480e\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7207\t0x7207\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_720C\t0x720c\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7224\t0x7224\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_722A\t0x722A\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_725E\t0x725e\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7262\t0x7262\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_726B\t0x726b\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72A1\t0x72a1\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72AA\t0x72aa\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72C4\t0x72c4\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72D0\t0x72d0\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72FA\t0x72fa\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7302\t0x7302\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7349\t0x7349\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_73F7\t0x73f7\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_A001\t0xa001\n#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_C002\t0xc002\n\n#define USB_VENDOR_ID_ELAN\t\t0x04f3\n#define USB_DEVICE_ID_TOSHIBA_CLICK_L9W\t0x0401\n#define USB_DEVICE_ID_HP_X2\t\t0x074d\n#define USB_DEVICE_ID_HP_X2_10_COVER\t0x0755\n\n#define USB_VENDOR_ID_ELECOM\t\t0x056e\n#define USB_DEVICE_ID_ELECOM_BM084\t0x0061\n#define USB_DEVICE_ID_ELECOM_M_XGL20DLBK\t0x00e6\n#define USB_DEVICE_ID_ELECOM_M_XT3URBK\t0x00fb\n#define USB_DEVICE_ID_ELECOM_M_XT3DRBK\t0x00fc\n#define USB_DEVICE_ID_ELECOM_M_XT4DRBK\t0x00fd\n#define USB_DEVICE_ID_ELECOM_M_DT1URBK\t0x00fe\n#define USB_DEVICE_ID_ELECOM_M_DT1DRBK\t0x00ff\n#define USB_DEVICE_ID_ELECOM_M_HT1URBK\t0x010c\n#define USB_DEVICE_ID_ELECOM_M_HT1DRBK\t0x010d\n\n#define USB_VENDOR_ID_DREAM_CHEEKY\t0x1d34\n#define USB_DEVICE_ID_DREAM_CHEEKY_WN\t0x0004\n#define USB_DEVICE_ID_DREAM_CHEEKY_FA\t0x000a\n\n#define USB_VENDOR_ID_ELITEGROUP\t0x03fc\n#define USB_DEVICE_ID_ELITEGROUP_05D8\t0x05d8\n\n#define USB_VENDOR_ID_ELO\t\t0x04E7\n#define USB_DEVICE_ID_ELO_TS2515\t0x0022\n#define USB_DEVICE_ID_ELO_TS2700\t0x0020\n#define USB_DEVICE_ID_ELO_ACCUTOUCH_2216\t0x0050\n\n#define USB_VENDOR_ID_EMS\t\t0x2006\n#define USB_DEVICE_ID_EMS_TRIO_LINKER_PLUS_II 0x0118\n\n#define USB_VENDOR_ID_FLATFROG\t\t0x25b5\n#define USB_DEVICE_ID_MULTITOUCH_3200\t0x0002\n\n#define USB_VENDOR_ID_FUTABA            0x0547\n#define USB_DEVICE_ID_LED_DISPLAY       0x7000\n\n#define USB_VENDOR_ID_FUTURE_TECHNOLOGY\t0x0403\n#define USB_DEVICE_ID_RETRODE2\t\t0x97c1\n\n#define USB_VENDOR_ID_ESSENTIAL_REALITY\t0x0d7f\n#define USB_DEVICE_ID_ESSENTIAL_REALITY_P5 0x0100\n\n#define USB_VENDOR_ID_ETT\t\t0x0664\n#define USB_DEVICE_ID_TC5UH\t\t0x0309\n#define USB_DEVICE_ID_TC4UM\t\t0x0306\n\n#define USB_VENDOR_ID_ETURBOTOUCH\t0x22b9\n#define USB_DEVICE_ID_ETURBOTOUCH\t0x0006\n#define USB_DEVICE_ID_ETURBOTOUCH_2968\t0x2968\n\n#define USB_VENDOR_ID_EZKEY\t\t0x0518\n#define USB_DEVICE_ID_BTC_8193\t\t0x0002\n\n#define USB_VENDOR_ID_FORMOSA          0x147a\n#define USB_DEVICE_ID_FORMOSA_IR_RECEIVER      0xe03e\n\n#define USB_VENDOR_ID_FREESCALE\t\t0x15A2\n#define USB_DEVICE_ID_FREESCALE_MX28\t0x004F\n\n#define USB_VENDOR_ID_FRUCTEL\t0x25B6\n#define USB_DEVICE_ID_GAMETEL_MT_MODE\t0x0002\n\n#define USB_VENDOR_ID_GAMEVICE\t0x27F8\n#define USB_DEVICE_ID_GAMEVICE_GV186\t0x0BBE\n#define USB_DEVICE_ID_GAMEVICE_KISHI\t0x0BBF\n\n#define USB_VENDOR_ID_GAMERON\t\t0x0810\n#define USB_DEVICE_ID_GAMERON_DUAL_PSX_ADAPTOR\t0x0001\n#define USB_DEVICE_ID_GAMERON_DUAL_PCS_ADAPTOR\t0x0002\n\n#define USB_VENDOR_ID_GEMBIRD\t\t\t0x11ff\n#define USB_DEVICE_ID_GEMBIRD_JPD_DUALFORCE2\t0x3331\n\n#define USB_VENDOR_ID_GENERAL_TOUCH\t0x0dfc\n#define USB_DEVICE_ID_GENERAL_TOUCH_WIN7_TWOFINGERS 0x0003\n#define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PWT_TENFINGERS 0x0100\n#define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_0101 0x0101\n#define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_0102 0x0102\n#define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_0106 0x0106\n#define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_010A 0x010a\n#define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_E100 0xe100\n\n#define USB_VENDOR_ID_GLORIOUS  0x258a\n#define USB_DEVICE_ID_GLORIOUS_MODEL_D 0x0033\n#define USB_DEVICE_ID_GLORIOUS_MODEL_O 0x0036\n\n#define I2C_VENDOR_ID_GOODIX\t\t0x27c6\n#define I2C_DEVICE_ID_GOODIX_01F0\t0x01f0\n\n#define USB_VENDOR_ID_GOODTOUCH\t\t0x1aad\n#define USB_DEVICE_ID_GOODTOUCH_000f\t0x000f\n\n#define USB_VENDOR_ID_GOOGLE\t\t0x18d1\n#define USB_DEVICE_ID_GOOGLE_HAMMER\t0x5022\n#define USB_DEVICE_ID_GOOGLE_TOUCH_ROSE\t0x5028\n#define USB_DEVICE_ID_GOOGLE_STAFF\t0x502b\n#define USB_DEVICE_ID_GOOGLE_WAND\t0x502d\n#define USB_DEVICE_ID_GOOGLE_WHISKERS\t0x5030\n#define USB_DEVICE_ID_GOOGLE_MASTERBALL\t0x503c\n#define USB_DEVICE_ID_GOOGLE_MAGNEMITE\t0x503d\n#define USB_DEVICE_ID_GOOGLE_MOONBALL\t0x5044\n\n#define USB_VENDOR_ID_GOTOP\t\t0x08f2\n#define USB_DEVICE_ID_SUPER_Q2\t\t0x007f\n#define USB_DEVICE_ID_GOGOPEN\t\t0x00ce\n#define USB_DEVICE_ID_PENPOWER\t\t0x00f4\n\n#define USB_VENDOR_ID_GREENASIA\t\t0x0e8f\n#define USB_DEVICE_ID_GREENASIA_DUAL_SAT_ADAPTOR 0x3010\n#define USB_DEVICE_ID_GREENASIA_DUAL_USB_JOYPAD\t0x3013\n\n#define USB_VENDOR_ID_GRETAGMACBETH\t0x0971\n#define USB_DEVICE_ID_GRETAGMACBETH_HUEY\t0x2005\n\n#define USB_VENDOR_ID_GRIFFIN\t\t0x077d\n#define USB_DEVICE_ID_POWERMATE\t\t0x0410\n#define USB_DEVICE_ID_SOUNDKNOB\t\t0x04AA\n#define USB_DEVICE_ID_RADIOSHARK\t0x627a\n\n#define USB_VENDOR_ID_GTCO\t\t0x078c\n#define USB_DEVICE_ID_GTCO_90\t\t0x0090\n#define USB_DEVICE_ID_GTCO_100\t\t0x0100\n#define USB_DEVICE_ID_GTCO_101\t\t0x0101\n#define USB_DEVICE_ID_GTCO_103\t\t0x0103\n#define USB_DEVICE_ID_GTCO_104\t\t0x0104\n#define USB_DEVICE_ID_GTCO_105\t\t0x0105\n#define USB_DEVICE_ID_GTCO_106\t\t0x0106\n#define USB_DEVICE_ID_GTCO_107\t\t0x0107\n#define USB_DEVICE_ID_GTCO_108\t\t0x0108\n#define USB_DEVICE_ID_GTCO_200\t\t0x0200\n#define USB_DEVICE_ID_GTCO_201\t\t0x0201\n#define USB_DEVICE_ID_GTCO_202\t\t0x0202\n#define USB_DEVICE_ID_GTCO_203\t\t0x0203\n#define USB_DEVICE_ID_GTCO_204\t\t0x0204\n#define USB_DEVICE_ID_GTCO_205\t\t0x0205\n#define USB_DEVICE_ID_GTCO_206\t\t0x0206\n#define USB_DEVICE_ID_GTCO_207\t\t0x0207\n#define USB_DEVICE_ID_GTCO_300\t\t0x0300\n#define USB_DEVICE_ID_GTCO_301\t\t0x0301\n#define USB_DEVICE_ID_GTCO_302\t\t0x0302\n#define USB_DEVICE_ID_GTCO_303\t\t0x0303\n#define USB_DEVICE_ID_GTCO_304\t\t0x0304\n#define USB_DEVICE_ID_GTCO_305\t\t0x0305\n#define USB_DEVICE_ID_GTCO_306\t\t0x0306\n#define USB_DEVICE_ID_GTCO_307\t\t0x0307\n#define USB_DEVICE_ID_GTCO_308\t\t0x0308\n#define USB_DEVICE_ID_GTCO_309\t\t0x0309\n#define USB_DEVICE_ID_GTCO_400\t\t0x0400\n#define USB_DEVICE_ID_GTCO_401\t\t0x0401\n#define USB_DEVICE_ID_GTCO_402\t\t0x0402\n#define USB_DEVICE_ID_GTCO_403\t\t0x0403\n#define USB_DEVICE_ID_GTCO_404\t\t0x0404\n#define USB_DEVICE_ID_GTCO_405\t\t0x0405\n#define USB_DEVICE_ID_GTCO_500\t\t0x0500\n#define USB_DEVICE_ID_GTCO_501\t\t0x0501\n#define USB_DEVICE_ID_GTCO_502\t\t0x0502\n#define USB_DEVICE_ID_GTCO_503\t\t0x0503\n#define USB_DEVICE_ID_GTCO_504\t\t0x0504\n#define USB_DEVICE_ID_GTCO_1000\t\t0x1000\n#define USB_DEVICE_ID_GTCO_1001\t\t0x1001\n#define USB_DEVICE_ID_GTCO_1002\t\t0x1002\n#define USB_DEVICE_ID_GTCO_1003\t\t0x1003\n#define USB_DEVICE_ID_GTCO_1004\t\t0x1004\n#define USB_DEVICE_ID_GTCO_1005\t\t0x1005\n#define USB_DEVICE_ID_GTCO_1006\t\t0x1006\n#define USB_DEVICE_ID_GTCO_1007\t\t0x1007\n\n#define USB_VENDOR_ID_GYRATION\t\t0x0c16\n#define USB_DEVICE_ID_GYRATION_REMOTE\t0x0002\n#define USB_DEVICE_ID_GYRATION_REMOTE_2 0x0003\n#define USB_DEVICE_ID_GYRATION_REMOTE_3 0x0008\n\n#define I2C_VENDOR_ID_HANTICK\t\t0x0911\n#define I2C_PRODUCT_ID_HANTICK_5288\t0x5288\n\n#define USB_VENDOR_ID_HANWANG\t\t0x0b57\n#define USB_DEVICE_ID_HANWANG_TABLET_FIRST\t0x5000\n#define USB_DEVICE_ID_HANWANG_TABLET_LAST\t0x8fff\n\n#define USB_VENDOR_ID_HANVON\t\t0x20b3\n#define USB_DEVICE_ID_HANVON_MULTITOUCH\t0x0a18\n\n#define USB_VENDOR_ID_HANVON_ALT\t0x22ed\n#define USB_DEVICE_ID_HANVON_ALT_MULTITOUCH\t0x1010\n\n#define USB_VENDOR_ID_HAPP\t\t0x078b\n#define USB_DEVICE_ID_UGCI_DRIVING\t0x0010\n#define USB_DEVICE_ID_UGCI_FLYING\t0x0020\n#define USB_DEVICE_ID_UGCI_FIGHTING\t0x0030\n\n#define USB_VENDOR_ID_HP\t\t0x03f0\n#define USB_PRODUCT_ID_HP_LOGITECH_OEM_USB_OPTICAL_MOUSE_0A4A\t0x0a4a\n#define USB_PRODUCT_ID_HP_LOGITECH_OEM_USB_OPTICAL_MOUSE_0B4A\t0x0b4a\n#define USB_PRODUCT_ID_HP_PIXART_OEM_USB_OPTICAL_MOUSE\t\t0x134a\n#define USB_PRODUCT_ID_HP_PIXART_OEM_USB_OPTICAL_MOUSE_094A\t0x094a\n#define USB_PRODUCT_ID_HP_PIXART_OEM_USB_OPTICAL_MOUSE_0941\t0x0941\n#define USB_PRODUCT_ID_HP_PIXART_OEM_USB_OPTICAL_MOUSE_0641\t0x0641\n#define USB_PRODUCT_ID_HP_PIXART_OEM_USB_OPTICAL_MOUSE_1f4a\t0x1f4a\n\n#define USB_VENDOR_ID_HUION\t\t0x256c\n#define USB_DEVICE_ID_HUION_TABLET\t0x006e\n#define USB_DEVICE_ID_HUION_HS64\t0x006d\n\n#define USB_VENDOR_ID_IBM\t\t\t\t\t0x04b3\n#define USB_DEVICE_ID_IBM_SCROLLPOINT_III\t\t\t0x3100\n#define USB_DEVICE_ID_IBM_SCROLLPOINT_PRO\t\t\t0x3103\n#define USB_DEVICE_ID_IBM_SCROLLPOINT_OPTICAL\t\t\t0x3105\n#define USB_DEVICE_ID_IBM_SCROLLPOINT_800DPI_OPTICAL\t\t0x3108\n#define USB_DEVICE_ID_IBM_SCROLLPOINT_800DPI_OPTICAL_PRO\t0x3109\n\n#define USB_VENDOR_ID_IDEACOM\t\t0x1cb6\n#define USB_DEVICE_ID_IDEACOM_IDC6650\t0x6650\n#define USB_DEVICE_ID_IDEACOM_IDC6651\t0x6651\n#define USB_DEVICE_ID_IDEACOM_IDC6680\t0x6680\n\n#define USB_VENDOR_ID_ILITEK\t\t0x222a\n#define USB_DEVICE_ID_ILITEK_MULTITOUCH\t0x0001\n\n#define USB_VENDOR_ID_INTEL_0\t\t0x8086\n#define USB_VENDOR_ID_INTEL_1\t\t0x8087\n#define USB_DEVICE_ID_INTEL_HID_SENSOR_0\t0x09fa\n#define USB_DEVICE_ID_INTEL_HID_SENSOR_1\t0x0a04\n\n#define USB_VENDOR_ID_STM_0             0x0483\n#define USB_DEVICE_ID_STM_HID_SENSOR    0x91d1\n#define USB_DEVICE_ID_STM_HID_SENSOR_1  0x9100\n\n#define USB_VENDOR_ID_ION\t\t0x15e4\n#define USB_DEVICE_ID_ICADE\t\t0x0132\n\n#define USB_VENDOR_ID_HOLTEK\t\t0x1241\n#define USB_DEVICE_ID_HOLTEK_ON_LINE_GRIP\t0x5015\n\n#define USB_VENDOR_ID_HOLTEK_ALT\t\t0x04d9\n#define USB_DEVICE_ID_HOLTEK_ALT_KEYBOARD\t0xa055\n#define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A04A\t0xa04a\n#define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A067\t0xa067\n#define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A070\t0xa070\n#define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A072\t0xa072\n#define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A081\t0xa081\n#define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A0C2\t0xa0c2\n#define USB_DEVICE_ID_HOLTEK_ALT_KEYBOARD_A096\t0xa096\n#define USB_DEVICE_ID_HOLTEK_ALT_KEYBOARD_A293\t0xa293\n\n#define USB_VENDOR_ID_IMATION\t\t0x0718\n#define USB_DEVICE_ID_DISC_STAKKA\t0xd000\n\n#define USB_VENDOR_ID_IRTOUCHSYSTEMS\t0x6615\n#define USB_DEVICE_ID_IRTOUCH_INFRARED_USB\t0x0070\n\n#define USB_VENDOR_ID_INNOMEDIA\t\t\t0x1292\n#define USB_DEVICE_ID_INNEX_GENESIS_ATARI\t0x4745\n\n#define USB_VENDOR_ID_ITE               0x048d\n#define USB_DEVICE_ID_ITE_LENOVO_YOGA   0x8386\n#define USB_DEVICE_ID_ITE_LENOVO_YOGA2  0x8350\n#define I2C_DEVICE_ID_ITE_LENOVO_LEGION_Y720\t0x837a\n#define USB_DEVICE_ID_ITE_LENOVO_YOGA900\t0x8396\n#define USB_DEVICE_ID_ITE8595\t\t0x8595\n#define USB_DEVICE_ID_ITE_MEDION_E1239T\t0xce50\n\n#define USB_VENDOR_ID_JABRA\t\t0x0b0e\n#define USB_DEVICE_ID_JABRA_SPEAK_410\t0x0412\n#define USB_DEVICE_ID_JABRA_SPEAK_510\t0x0420\n#define USB_DEVICE_ID_JABRA_GN9350E\t0x9350\n\n#define USB_VENDOR_ID_JESS\t\t0x0c45\n#define USB_DEVICE_ID_JESS_YUREX\t0x1010\n#define USB_DEVICE_ID_ASUS_MD_5112\t0x5112\n#define USB_DEVICE_ID_REDRAGON_ASURA\t0x760b\n\n#define USB_VENDOR_ID_JESS2\t\t0x0f30\n#define USB_DEVICE_ID_JESS2_COLOR_RUMBLE_PAD 0x0111\n\n#define USB_VENDOR_ID_KBGEAR\t\t0x084e\n#define USB_DEVICE_ID_KBGEAR_JAMSTUDIO\t0x1001\n\n#define USB_VENDOR_ID_KENSINGTON\t0x047d\n#define USB_DEVICE_ID_KS_SLIMBLADE\t0x2041\n\n#define USB_VENDOR_ID_KWORLD\t\t0x1b80\n#define USB_DEVICE_ID_KWORLD_RADIO_FM700\t0xd700\n\n#define USB_VENDOR_ID_KEYTOUCH\t\t0x0926\n#define USB_DEVICE_ID_KEYTOUCH_IEC\t0x3333\n\n#define USB_VENDOR_ID_KYE\t\t0x0458\n#define USB_DEVICE_ID_KYE_ERGO_525V\t0x0087\n#define USB_DEVICE_ID_GENIUS_GILA_GAMING_MOUSE\t0x0138\n#define USB_DEVICE_ID_GENIUS_MANTICORE\t0x0153\n#define USB_DEVICE_ID_GENIUS_GX_IMPERATOR\t0x4018\n#define USB_DEVICE_ID_KYE_GPEN_560\t0x5003\n#define USB_DEVICE_ID_KYE_EASYPEN_I405X\t0x5010\n#define USB_DEVICE_ID_KYE_MOUSEPEN_I608X\t0x5011\n#define USB_DEVICE_ID_KYE_MOUSEPEN_I608X_V2\t0x501a\n#define USB_DEVICE_ID_KYE_EASYPEN_M610X\t0x5013\n#define USB_DEVICE_ID_KYE_PENSKETCH_M912\t0x5015\n#define USB_DEVICE_ID_KYE_EASYPEN_M406XE\t0x5019\n\n#define USB_VENDOR_ID_LABTEC\t\t0x1020\n#define USB_DEVICE_ID_LABTEC_WIRELESS_KEYBOARD\t0x0006\n\n#define USB_VENDOR_ID_LCPOWER\t\t0x1241\n#define USB_DEVICE_ID_LCPOWER_LC1000\t0xf767\n\n#define USB_VENDOR_ID_LD\t\t0x0f11\n#define USB_DEVICE_ID_LD_CASSY\t\t0x1000\n#define USB_DEVICE_ID_LD_CASSY2\t\t0x1001\n#define USB_DEVICE_ID_LD_POCKETCASSY\t0x1010\n#define USB_DEVICE_ID_LD_POCKETCASSY2\t0x1011\n#define USB_DEVICE_ID_LD_MOBILECASSY\t0x1020\n#define USB_DEVICE_ID_LD_MOBILECASSY2\t0x1021\n#define USB_DEVICE_ID_LD_MICROCASSYVOLTAGE\t0x1031\n#define USB_DEVICE_ID_LD_MICROCASSYCURRENT\t0x1032\n#define USB_DEVICE_ID_LD_MICROCASSYTIME\t\t0x1033\n#define USB_DEVICE_ID_LD_MICROCASSYTEMPERATURE\t0x1035\n#define USB_DEVICE_ID_LD_MICROCASSYPH\t\t0x1038\n#define USB_DEVICE_ID_LD_POWERANALYSERCASSY\t0x1040\n#define USB_DEVICE_ID_LD_CONVERTERCONTROLLERCASSY\t0x1042\n#define USB_DEVICE_ID_LD_MACHINETESTCASSY\t0x1043\n#define USB_DEVICE_ID_LD_JWM\t\t0x1080\n#define USB_DEVICE_ID_LD_DMMP\t\t0x1081\n#define USB_DEVICE_ID_LD_UMIP\t\t0x1090\n#define USB_DEVICE_ID_LD_UMIC\t\t0x10A0\n#define USB_DEVICE_ID_LD_UMIB\t\t0x10B0\n#define USB_DEVICE_ID_LD_XRAY\t\t0x1100\n#define USB_DEVICE_ID_LD_XRAY2\t\t0x1101\n#define USB_DEVICE_ID_LD_XRAYCT\t\t0x1110\n#define USB_DEVICE_ID_LD_VIDEOCOM\t0x1200\n#define USB_DEVICE_ID_LD_MOTOR\t\t0x1210\n#define USB_DEVICE_ID_LD_COM3LAB\t0x2000\n#define USB_DEVICE_ID_LD_TELEPORT\t0x2010\n#define USB_DEVICE_ID_LD_NETWORKANALYSER 0x2020\n#define USB_DEVICE_ID_LD_POWERCONTROL\t0x2030\n#define USB_DEVICE_ID_LD_MACHINETEST\t0x2040\n#define USB_DEVICE_ID_LD_MOSTANALYSER\t0x2050\n#define USB_DEVICE_ID_LD_MOSTANALYSER2\t0x2051\n#define USB_DEVICE_ID_LD_ABSESP\t\t0x2060\n#define USB_DEVICE_ID_LD_AUTODATABUS\t0x2070\n#define USB_DEVICE_ID_LD_MCT\t\t0x2080\n#define USB_DEVICE_ID_LD_HYBRID\t\t0x2090\n#define USB_DEVICE_ID_LD_HEATCONTROL\t0x20A0\n\n#define USB_VENDOR_ID_LENOVO\t\t0x17ef\n#define USB_DEVICE_ID_LENOVO_TPKBD\t0x6009\n#define USB_DEVICE_ID_LENOVO_CUSBKBD\t0x6047\n#define USB_DEVICE_ID_LENOVO_CBTKBD\t0x6048\n#define USB_DEVICE_ID_LENOVO_SCROLLPOINT_OPTICAL\t0x6049\n#define USB_DEVICE_ID_LENOVO_TP10UBKBD\t0x6062\n#define USB_DEVICE_ID_LENOVO_TPPRODOCK\t0x6067\n#define USB_DEVICE_ID_LENOVO_X1_COVER\t0x6085\n#define USB_DEVICE_ID_LENOVO_X1_TAB\t0x60a3\n#define USB_DEVICE_ID_LENOVO_X1_TAB3\t0x60b5\n#define USB_DEVICE_ID_LENOVO_PIXART_USB_MOUSE_608D\t0x608d\n#define USB_DEVICE_ID_LENOVO_PIXART_USB_MOUSE_6019\t0x6019\n#define USB_DEVICE_ID_LENOVO_PIXART_USB_MOUSE_602E\t0x602e\n#define USB_DEVICE_ID_LENOVO_PIXART_USB_MOUSE_6093\t0x6093\n\n#define USB_VENDOR_ID_LG\t\t0x1fd2\n#define USB_DEVICE_ID_LG_MULTITOUCH\t0x0064\n#define USB_DEVICE_ID_LG_MELFAS_MT\t0x6007\n#define I2C_DEVICE_ID_LG_8001\t\t0x8001\n#define I2C_DEVICE_ID_LG_7010\t\t0x7010\n\n#define USB_VENDOR_ID_LOGITECH\t\t0x046d\n#define USB_DEVICE_ID_LOGITECH_AUDIOHUB 0x0a0e\n#define USB_DEVICE_ID_LOGITECH_T651\t0xb00c\n#define USB_DEVICE_ID_LOGITECH_DINOVO_EDGE_KBD\t0xb309\n#define USB_DEVICE_ID_LOGITECH_C007\t0xc007\n#define USB_DEVICE_ID_LOGITECH_C077\t0xc077\n#define USB_DEVICE_ID_LOGITECH_RECEIVER\t0xc101\n#define USB_DEVICE_ID_LOGITECH_HARMONY_FIRST  0xc110\n#define USB_DEVICE_ID_LOGITECH_HARMONY_LAST 0xc14f\n#define USB_DEVICE_ID_LOGITECH_HARMONY_PS3 0x0306\n#define USB_DEVICE_ID_LOGITECH_KEYBOARD_G710_PLUS 0xc24d\n#define USB_DEVICE_ID_LOGITECH_MOUSE_C01A\t0xc01a\n#define USB_DEVICE_ID_LOGITECH_MOUSE_C05A\t0xc05a\n#define USB_DEVICE_ID_LOGITECH_MOUSE_C06A\t0xc06a\n#define USB_DEVICE_ID_LOGITECH_RUMBLEPAD_CORD\t0xc20a\n#define USB_DEVICE_ID_LOGITECH_RUMBLEPAD\t0xc211\n#define USB_DEVICE_ID_LOGITECH_EXTREME_3D\t0xc215\n#define USB_DEVICE_ID_LOGITECH_DUAL_ACTION\t0xc216\n#define USB_DEVICE_ID_LOGITECH_RUMBLEPAD2\t0xc218\n#define USB_DEVICE_ID_LOGITECH_RUMBLEPAD2_2\t0xc219\n#define USB_DEVICE_ID_LOGITECH_G15_LCD\t\t0xc222\n#define USB_DEVICE_ID_LOGITECH_G11\t\t0xc225\n#define USB_DEVICE_ID_LOGITECH_G15_V2_LCD\t0xc227\n#define USB_DEVICE_ID_LOGITECH_G510\t\t0xc22d\n#define USB_DEVICE_ID_LOGITECH_G510_USB_AUDIO\t0xc22e\n#define USB_DEVICE_ID_LOGITECH_G29_WHEEL\t0xc24f\n#define USB_DEVICE_ID_LOGITECH_G920_WHEEL\t0xc262\n#define USB_DEVICE_ID_LOGITECH_WINGMAN_F3D\t0xc283\n#define USB_DEVICE_ID_LOGITECH_FORCE3D_PRO\t0xc286\n#define USB_DEVICE_ID_LOGITECH_FLIGHT_SYSTEM_G940\t0xc287\n#define USB_DEVICE_ID_LOGITECH_WINGMAN_FG\t0xc20e\n#define USB_DEVICE_ID_LOGITECH_WINGMAN_FFG\t0xc293\n#define USB_DEVICE_ID_LOGITECH_WHEEL\t0xc294\n#define USB_DEVICE_ID_LOGITECH_MOMO_WHEEL\t0xc295\n#define USB_DEVICE_ID_LOGITECH_DFP_WHEEL\t0xc298\n#define USB_DEVICE_ID_LOGITECH_G25_WHEEL\t0xc299\n#define USB_DEVICE_ID_LOGITECH_DFGT_WHEEL\t0xc29a\n#define USB_DEVICE_ID_LOGITECH_G27_WHEEL\t0xc29b\n#define USB_DEVICE_ID_LOGITECH_WII_WHEEL\t0xc29c\n#define USB_DEVICE_ID_LOGITECH_ELITE_KBD\t0xc30a\n#define USB_DEVICE_ID_LOGITECH_GROUP_AUDIO\t0x0882\n#define USB_DEVICE_ID_S510_RECEIVER\t0xc50c\n#define USB_DEVICE_ID_S510_RECEIVER_2\t0xc517\n#define USB_DEVICE_ID_LOGITECH_CORDLESS_DESKTOP_LX500\t0xc512\n#define USB_DEVICE_ID_MX3000_RECEIVER\t0xc513\n#define USB_DEVICE_ID_LOGITECH_27MHZ_MOUSE_RECEIVER\t0xc51b\n#define USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER\t0xc52b\n#define USB_DEVICE_ID_LOGITECH_NANO_RECEIVER\t\t0xc52f\n#define USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER_2\t0xc532\n#define USB_DEVICE_ID_LOGITECH_NANO_RECEIVER_2\t\t0xc534\n#define USB_DEVICE_ID_LOGITECH_NANO_RECEIVER_LIGHTSPEED_1\t0xc539\n#define USB_DEVICE_ID_LOGITECH_NANO_RECEIVER_LIGHTSPEED_1_1\t0xc53f\n#define USB_DEVICE_ID_LOGITECH_NANO_RECEIVER_POWERPLAY\t0xc53a\n#define USB_DEVICE_ID_SPACETRAVELLER\t0xc623\n#define USB_DEVICE_ID_SPACENAVIGATOR\t0xc626\n#define USB_DEVICE_ID_DINOVO_DESKTOP\t0xc704\n#define USB_DEVICE_ID_DINOVO_EDGE\t0xc714\n#define USB_DEVICE_ID_DINOVO_MINI\t0xc71f\n#define USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2\t0xca03\n#define USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL\t0xca04\n\n#define USB_VENDOR_ID_LUMIO\t\t0x202e\n#define USB_DEVICE_ID_CRYSTALTOUCH\t0x0006\n#define USB_DEVICE_ID_CRYSTALTOUCH_DUAL\t0x0007\n\n#define USB_VENDOR_ID_MADCATZ\t\t0x0738\n#define USB_DEVICE_ID_MADCATZ_BEATPAD\t0x4540\n#define USB_DEVICE_ID_MADCATZ_RAT5\t0x1705\n#define USB_DEVICE_ID_MADCATZ_RAT9\t0x1709\n\n#define USB_VENDOR_ID_MCC\t\t0x09db\n#define USB_DEVICE_ID_MCC_PMD1024LS\t0x0076\n#define USB_DEVICE_ID_MCC_PMD1208LS\t0x007a\n\n#define USB_VENDOR_ID_MCS\t\t0x16d0\n#define USB_DEVICE_ID_MCS_GAMEPADBLOCK\t0x0bcc\n\n#define USB_VENDOR_ID_MGE\t\t0x0463\n#define USB_DEVICE_ID_MGE_UPS\t\t0xffff\n#define USB_DEVICE_ID_MGE_UPS1\t\t0x0001\n\n#define USB_VENDOR_ID_MICROCHIP\t\t0x04d8\n#define USB_DEVICE_ID_PICKIT1\t\t0x0032\n#define USB_DEVICE_ID_PICKIT2\t\t0x0033\n#define USB_DEVICE_ID_PICOLCD\t\t0xc002\n#define USB_DEVICE_ID_PICOLCD_BOOTLOADER\t0xf002\n#define USB_DEVICE_ID_PICK16F1454\t0x0042\n#define USB_DEVICE_ID_PICK16F1454_V2\t0xf2f7\n#define USB_DEVICE_ID_LUXAFOR\t\t0xf372\n#define USB_DEVICE_ID_MCP2221\t\t0x00dd\n\n#define USB_VENDOR_ID_MICROSOFT\t\t0x045e\n#define USB_DEVICE_ID_SIDEWINDER_GV\t0x003b\n#define USB_DEVICE_ID_MS_OFFICE_KB\t0x0048\n#define USB_DEVICE_ID_WIRELESS_OPTICAL_DESKTOP_3_0 0x009d\n#define USB_DEVICE_ID_MS_DIGITAL_MEDIA_7K 0x00b4\n#define USB_DEVICE_ID_MS_NE4K\t\t0x00db\n#define USB_DEVICE_ID_MS_NE4K_JP\t0x00dc\n#define USB_DEVICE_ID_MS_LK6K\t\t0x00f9\n#define USB_DEVICE_ID_MS_PRESENTER_8K_BT\t0x0701\n#define USB_DEVICE_ID_MS_PRESENTER_8K_USB\t0x0713\n#define USB_DEVICE_ID_MS_NE7K\t\t0x071d\n#define USB_DEVICE_ID_MS_DIGITAL_MEDIA_3K\t0x0730\n#define USB_DEVICE_ID_MS_DIGITAL_MEDIA_3KV1 0x0732\n#define USB_DEVICE_ID_MS_DIGITAL_MEDIA_600  0x0750\n#define USB_DEVICE_ID_MS_COMFORT_MOUSE_4500\t0x076c\n#define USB_DEVICE_ID_MS_COMFORT_KEYBOARD 0x00e3\n#define USB_DEVICE_ID_MS_SURFACE_PRO_2   0x0799\n#define USB_DEVICE_ID_MS_TOUCH_COVER_2   0x07a7\n#define USB_DEVICE_ID_MS_TYPE_COVER_2    0x07a9\n#define USB_DEVICE_ID_MS_POWER_COVER     0x07da\n#define USB_DEVICE_ID_MS_XBOX_ONE_S_CONTROLLER\t0x02fd\n#define USB_DEVICE_ID_MS_PIXART_MOUSE    0x00cb\n#define USB_DEVICE_ID_8BITDO_SN30_PRO_PLUS      0x02e0\n\n#define USB_VENDOR_ID_MOJO\t\t0x8282\n#define USB_DEVICE_ID_RETRO_ADAPTER\t0x3201\n\n#define USB_VENDOR_ID_MONTEREY\t\t0x0566\n#define USB_DEVICE_ID_GENIUS_KB29E\t0x3004\n\n#define USB_VENDOR_ID_MSI\t\t0x1770\n#define USB_DEVICE_ID_MSI_GT683R_LED_PANEL 0xff00\n\n#define USB_VENDOR_ID_NATIONAL_SEMICONDUCTOR 0x0400\n#define USB_DEVICE_ID_N_S_HARMONY\t0xc359\n\n#define USB_VENDOR_ID_NATSU\t\t0x08b7\n#define USB_DEVICE_ID_NATSU_GAMEPAD\t0x0001\n\n#define USB_VENDOR_ID_NCR\t\t0x0404\n#define USB_DEVICE_ID_NCR_FIRST\t\t0x0300\n#define USB_DEVICE_ID_NCR_LAST\t\t0x03ff\n\n#define USB_VENDOR_ID_NEC\t\t0x073e\n#define USB_DEVICE_ID_NEC_USB_GAME_PAD\t0x0301\n\n#define USB_VENDOR_ID_NEXIO\t\t0x1870\n#define USB_DEVICE_ID_NEXIO_MULTITOUCH_420\t0x010d\n#define USB_DEVICE_ID_NEXIO_MULTITOUCH_PTI0750\t0x0110\n\n#define USB_VENDOR_ID_NEXTWINDOW\t0x1926\n#define USB_DEVICE_ID_NEXTWINDOW_TOUCHSCREEN\t0x0003\n\n#define USB_VENDOR_ID_NINTENDO\t\t0x057e\n#define USB_DEVICE_ID_NINTENDO_WIIMOTE\t0x0306\n#define USB_DEVICE_ID_NINTENDO_WIIMOTE2\t0x0330\n\n#define USB_VENDOR_ID_NOVATEK\t\t0x0603\n#define USB_DEVICE_ID_NOVATEK_PCT\t0x0600\n#define USB_DEVICE_ID_NOVATEK_MOUSE\t0x1602\n\n#define USB_VENDOR_ID_NTI               0x0757\n#define USB_DEVICE_ID_USB_SUN           0x0a00\n\n#define USB_VENDOR_ID_NTRIG\t\t0x1b96\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN   0x0001\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_1   0x0003\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_2   0x0004\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_3   0x0005\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_4   0x0006\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_5   0x0007\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_6   0x0008\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_7   0x0009\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_8   0x000A\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_9   0x000B\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_10   0x000C\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_11   0x000D\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_12   0x000E\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_13   0x000F\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_14   0x0010\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_15   0x0011\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_16   0x0012\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_17   0x0013\n#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_18   0x0014\n#define USB_DEVICE_ID_NTRIG_DUOSENSE 0x1500\n\n#define USB_VENDOR_ID_ONTRAK\t\t0x0a07\n#define USB_DEVICE_ID_ONTRAK_ADU100\t0x0064\n\n#define USB_VENDOR_ID_ORTEK\t\t0x05a4\n#define USB_DEVICE_ID_ORTEK_PKB1700\t0x1700\n#define USB_DEVICE_ID_ORTEK_WKB2000\t0x2000\n#define USB_DEVICE_ID_ORTEK_IHOME_IMAC_A210S\t0x8003\n\n#define USB_VENDOR_ID_PLANTRONICS\t0x047f\n\n#define USB_VENDOR_ID_PANASONIC\t\t0x04da\n#define USB_DEVICE_ID_PANABOARD_UBT780\t0x1044\n#define USB_DEVICE_ID_PANABOARD_UBT880\t0x104d\n\n#define USB_VENDOR_ID_PANJIT\t\t0x134c\n\n#define USB_VENDOR_ID_PANTHERLORD\t0x0810\n#define USB_DEVICE_ID_PANTHERLORD_TWIN_USB_JOYSTICK\t0x0001\n\n#define USB_VENDOR_ID_PENMOUNT\t\t0x14e1\n#define USB_DEVICE_ID_PENMOUNT_PCI\t0x3500\n#define USB_DEVICE_ID_PENMOUNT_1610\t0x1610\n#define USB_DEVICE_ID_PENMOUNT_1640\t0x1640\n#define USB_DEVICE_ID_PENMOUNT_6000\t0x6000\n\n#define USB_VENDOR_ID_PETALYNX\t\t0x18b1\n#define USB_DEVICE_ID_PETALYNX_MAXTER_REMOTE\t0x0037\n\n#define USB_VENDOR_ID_PETZL\t\t0x2122\n#define USB_DEVICE_ID_PETZL_HEADLAMP\t0x1234\n\n#define USB_VENDOR_ID_PHILIPS\t\t0x0471\n#define USB_DEVICE_ID_PHILIPS_IEEE802154_DONGLE 0x0617\n\n#define USB_VENDOR_ID_PI_ENGINEERING\t0x05f3\n#define USB_DEVICE_ID_PI_ENGINEERING_VEC_USB_FOOTPEDAL\t0xff\n\n#define USB_VENDOR_ID_PIXART\t\t\t\t0x093a\n#define USB_DEVICE_ID_PIXART_USB_OPTICAL_MOUSE_ID2\t0x0137\n#define USB_DEVICE_ID_PIXART_USB_OPTICAL_MOUSE\t\t0x2510\n#define USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN\t0x8001\n#define USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN1\t0x8002\n#define USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN2\t0x8003\n\n#define USB_VENDOR_ID_PLAYDOTCOM\t0x0b43\n#define USB_DEVICE_ID_PLAYDOTCOM_EMS_USBII\t0x0003\n\n#define USB_VENDOR_ID_POWERCOM\t\t0x0d9f\n#define USB_DEVICE_ID_POWERCOM_UPS\t0x0002\n\n#define USB_VENDOR_ID_PRODIGE\t\t0x05af\n#define USB_DEVICE_ID_PRODIGE_CORDLESS\t0x3062\n\n#define USB_VENDOR_ID_QUANTA\t\t0x0408\n#define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH\t\t0x3000\n#define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH_3001\t\t0x3001\n#define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH_3003\t\t0x3003\n#define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH_3008\t\t0x3008\n\n#define I2C_VENDOR_ID_RAYDIUM\t\t0x2386\n#define I2C_PRODUCT_ID_RAYDIUM_4B33\t0x4b33\n#define I2C_PRODUCT_ID_RAYDIUM_3118\t0x3118\n\n#define USB_VENDOR_ID_RAZER            0x1532\n#define USB_DEVICE_ID_RAZER_BLADE_14   0x011D\n\n#define USB_VENDOR_ID_REALTEK\t\t0x0bda\n#define USB_DEVICE_ID_REALTEK_READER\t0x0152\n\n#define USB_VENDOR_ID_RETROUSB\t\t0xf000\n#define USB_DEVICE_ID_RETROUSB_SNES_RETROPAD\t0x0003\n#define USB_DEVICE_ID_RETROUSB_SNES_RETROPORT\t0x00f1\n\n#define USB_VENDOR_ID_ROCCAT\t\t0x1e7d\n#define USB_DEVICE_ID_ROCCAT_ARVO\t0x30d4\n#define USB_DEVICE_ID_ROCCAT_ISKU\t0x319c\n#define USB_DEVICE_ID_ROCCAT_ISKUFX\t0x3264\n#define USB_DEVICE_ID_ROCCAT_KONE\t0x2ced\n#define USB_DEVICE_ID_ROCCAT_KONEPLUS\t0x2d51\n#define USB_DEVICE_ID_ROCCAT_KONEPURE\t0x2dbe\n#define USB_DEVICE_ID_ROCCAT_KONEPURE_OPTICAL\t0x2db4\n#define USB_DEVICE_ID_ROCCAT_KONEXTD\t0x2e22\n#define USB_DEVICE_ID_ROCCAT_KOVAPLUS\t0x2d50\n#define USB_DEVICE_ID_ROCCAT_LUA\t0x2c2e\n#define USB_DEVICE_ID_ROCCAT_PYRA_WIRED\t0x2c24\n#define USB_DEVICE_ID_ROCCAT_PYRA_WIRELESS\t0x2cf6\n#define USB_DEVICE_ID_ROCCAT_RYOS_MK\t0x3138\n#define USB_DEVICE_ID_ROCCAT_RYOS_MK_GLOW\t0x31ce\n#define USB_DEVICE_ID_ROCCAT_RYOS_MK_PRO\t0x3232\n#define USB_DEVICE_ID_ROCCAT_SAVU\t0x2d5a\n\n#define USB_VENDOR_ID_SAI\t\t0x17dd\n\n#define USB_VENDOR_ID_SAITEK\t\t0x06a3\n#define USB_DEVICE_ID_SAITEK_RUMBLEPAD\t0xff17\n#define USB_DEVICE_ID_SAITEK_PS1000\t0x0621\n#define USB_DEVICE_ID_SAITEK_RAT7_OLD\t0x0ccb\n#define USB_DEVICE_ID_SAITEK_RAT7_CONTAGION\t0x0ccd\n#define USB_DEVICE_ID_SAITEK_RAT7\t0x0cd7\n#define USB_DEVICE_ID_SAITEK_RAT9\t0x0cfa\n#define USB_DEVICE_ID_SAITEK_MMO7\t0x0cd0\n#define USB_DEVICE_ID_SAITEK_X52\t0x075c\n#define USB_DEVICE_ID_SAITEK_X52_2\t0x0255\n#define USB_DEVICE_ID_SAITEK_X52_PRO\t0x0762\n\n#define USB_VENDOR_ID_SAMSUNG\t\t0x0419\n#define USB_DEVICE_ID_SAMSUNG_IR_REMOTE\t0x0001\n#define USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE\t0x0600\n\n#define USB_VENDOR_ID_SEMICO\t\t\t0x1a2c\n#define USB_DEVICE_ID_SEMICO_USB_KEYKOARD\t0x0023\n#define USB_DEVICE_ID_SEMICO_USB_KEYKOARD2\t0x0027\n\n#define USB_VENDOR_ID_SENNHEISER\t0x1395\n#define USB_DEVICE_ID_SENNHEISER_BTD500USB\t0x002c\n\n#define USB_VENDOR_ID_SIGMA_MICRO\t0x1c4f\n#define USB_DEVICE_ID_SIGMA_MICRO_KEYBOARD\t0x0002\n\n#define USB_VENDOR_ID_SIGMATEL\t\t0x066F\n#define USB_DEVICE_ID_SIGMATEL_STMP3780\t0x3780\n\n#define USB_VENDOR_ID_SIS_TOUCH\t\t0x0457\n#define USB_DEVICE_ID_SIS9200_TOUCH\t0x9200\n#define USB_DEVICE_ID_SIS817_TOUCH\t0x0817\n#define USB_DEVICE_ID_SIS_TS\t\t0x1013\n#define USB_DEVICE_ID_SIS1030_TOUCH\t0x1030\n\n#define USB_VENDOR_ID_SKYCABLE\t\t\t0x1223\n#define\tUSB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER\t0x3F07\n\n#define USB_VENDOR_ID_SMK\t\t0x0609\n#define USB_DEVICE_ID_SMK_PS3_BDREMOTE\t0x0306\n#define USB_DEVICE_ID_SMK_NSG_MR5U_REMOTE       0x0368\n#define USB_DEVICE_ID_SMK_NSG_MR7U_REMOTE       0x0369\n\n\n#define USB_VENDOR_ID_SONY\t\t\t0x054c\n#define USB_DEVICE_ID_SONY_VAIO_VGX_MOUSE\t0x024b\n#define USB_DEVICE_ID_SONY_VAIO_VGP_MOUSE\t0x0374\n#define USB_DEVICE_ID_SONY_PS3_BDREMOTE\t\t0x0306\n#define USB_DEVICE_ID_SONY_PS3_CONTROLLER\t0x0268\n#define USB_DEVICE_ID_SONY_PS4_CONTROLLER\t0x05c4\n#define USB_DEVICE_ID_SONY_PS4_CONTROLLER_2\t0x09cc\n#define USB_DEVICE_ID_SONY_PS4_CONTROLLER_DONGLE\t0x0ba0\n#define USB_DEVICE_ID_SONY_MOTION_CONTROLLER\t0x03d5\n#define USB_DEVICE_ID_SONY_NAVIGATION_CONTROLLER\t0x042f\n#define USB_DEVICE_ID_SONY_BUZZ_CONTROLLER\t\t0x0002\n#define USB_DEVICE_ID_SONY_WIRELESS_BUZZ_CONTROLLER\t0x1000\n\n#define USB_VENDOR_ID_SINO_LITE\t\t\t0x1345\n#define USB_DEVICE_ID_SINO_LITE_CONTROLLER\t0x3008\n\n#define USB_VENDOR_ID_SOLID_YEAR\t\t\t0x060b\n#define USB_DEVICE_ID_MACALLY_IKEY_KEYBOARD\t\t0x0001\n#define USB_DEVICE_ID_COUGAR_500K_GAMING_KEYBOARD\t0x500a\n#define USB_DEVICE_ID_COUGAR_700K_GAMING_KEYBOARD\t0x700a\n\n#define USB_VENDOR_ID_SOUNDGRAPH\t0x15c2\n#define USB_DEVICE_ID_SOUNDGRAPH_IMON_FIRST\t0x0034\n#define USB_DEVICE_ID_SOUNDGRAPH_IMON_LAST\t0x0046\n\n#define USB_VENDOR_ID_STANTUM\t\t0x1f87\n#define USB_DEVICE_ID_MTP\t\t0x0002\n\n#define USB_VENDOR_ID_STANTUM_STM\t\t0x0483\n#define USB_DEVICE_ID_MTP_STM\t\t0x3261\n\n#define USB_VENDOR_ID_STANTUM_SITRONIX\t\t0x1403\n#define USB_DEVICE_ID_MTP_SITRONIX\t\t0x5001\n\n#define USB_VENDOR_ID_VALVE\t\t\t0x28de\n#define USB_DEVICE_ID_STEAM_CONTROLLER\t\t0x1102\n#define USB_DEVICE_ID_STEAM_CONTROLLER_WIRELESS\t0x1142\n\n#define USB_VENDOR_ID_STEELSERIES\t0x1038\n#define USB_DEVICE_ID_STEELSERIES_SRWS1\t0x1410\n\n#define USB_VENDOR_ID_SUN\t\t0x0430\n#define USB_DEVICE_ID_RARITAN_KVM_DONGLE\t0xcdab\n\n#define USB_VENDOR_ID_SUNPLUS\t\t0x04fc\n#define USB_DEVICE_ID_SUNPLUS_WDESKTOP\t0x05d8\n\n#define USB_VENDOR_ID_SYMBOL\t\t0x05e0\n#define USB_DEVICE_ID_SYMBOL_SCANNER_1\t0x0800\n#define USB_DEVICE_ID_SYMBOL_SCANNER_2\t0x1300\n#define USB_DEVICE_ID_SYMBOL_SCANNER_3\t0x1200\n\n#define I2C_VENDOR_ID_SYNAPTICS     0x06cb\n#define I2C_PRODUCT_ID_SYNAPTICS_SYNA2393   0x7a13\n\n#define USB_VENDOR_ID_SYNAPTICS\t\t0x06cb\n#define USB_DEVICE_ID_SYNAPTICS_TP\t0x0001\n#define USB_DEVICE_ID_SYNAPTICS_INT_TP\t0x0002\n#define USB_DEVICE_ID_SYNAPTICS_CPAD\t0x0003\n#define USB_DEVICE_ID_SYNAPTICS_TS\t0x0006\n#define USB_DEVICE_ID_SYNAPTICS_STICK\t0x0007\n#define USB_DEVICE_ID_SYNAPTICS_WP\t0x0008\n#define USB_DEVICE_ID_SYNAPTICS_COMP_TP\t0x0009\n#define USB_DEVICE_ID_SYNAPTICS_WTP\t0x0010\n#define USB_DEVICE_ID_SYNAPTICS_DPAD\t0x0013\n#define USB_DEVICE_ID_SYNAPTICS_LTS1\t0x0af8\n#define USB_DEVICE_ID_SYNAPTICS_LTS2\t0x1d10\n#define USB_DEVICE_ID_SYNAPTICS_HD\t0x0ac3\n#define USB_DEVICE_ID_SYNAPTICS_QUAD_HD\t0x1ac3\n#define USB_DEVICE_ID_SYNAPTICS_DELL_K12A\t0x2819\n#define USB_DEVICE_ID_SYNAPTICS_ACER_SWITCH5_012\t0x2968\n#define USB_DEVICE_ID_SYNAPTICS_TP_V103\t0x5710\n#define USB_DEVICE_ID_SYNAPTICS_ACER_ONE_S1003\t0x73f5\n#define USB_DEVICE_ID_SYNAPTICS_ACER_SWITCH5\t0x81a7\n\n#define USB_VENDOR_ID_TEXAS_INSTRUMENTS\t0x2047\n#define USB_DEVICE_ID_TEXAS_INSTRUMENTS_LENOVO_YOGA\t0x0855\n\n#define USB_VENDOR_ID_THINGM\t\t0x27b8\n#define USB_DEVICE_ID_BLINK1\t\t0x01ed\n\n#define USB_VENDOR_ID_THQ\t\t0x20d6\n#define USB_DEVICE_ID_THQ_PS3_UDRAW\t0xcb17\n\n#define USB_VENDOR_ID_THRUSTMASTER\t0x044f\n\n#define USB_VENDOR_ID_TIVO\t\t0x150a\n#define USB_DEVICE_ID_TIVO_SLIDE_BT\t0x1200\n#define USB_DEVICE_ID_TIVO_SLIDE\t0x1201\n#define USB_DEVICE_ID_TIVO_SLIDE_PRO\t0x1203\n\n#define USB_VENDOR_ID_TOPSEED\t\t0x0766\n#define USB_DEVICE_ID_TOPSEED_CYBERLINK\t0x0204\n\n#define USB_VENDOR_ID_TOPSEED2\t\t0x1784\n#define USB_DEVICE_ID_TOPSEED2_RF_COMBO\t0x0004\n#define USB_DEVICE_ID_TOPSEED2_PERIPAD_701\t0x0016\n\n#define USB_VENDOR_ID_TOPMAX\t\t0x0663\n#define USB_DEVICE_ID_TOPMAX_COBRAPAD\t0x0103\n\n#define USB_VENDOR_ID_TOUCH_INTL\t0x1e5e\n#define USB_DEVICE_ID_TOUCH_INTL_MULTI_TOUCH\t0x0313\n\n#define USB_VENDOR_ID_TOUCHPACK\t\t0x1bfd\n#define USB_DEVICE_ID_TOUCHPACK_RTS\t0x1688\n\n#define USB_VENDOR_ID_TPV\t\t0x25aa\n#define USB_DEVICE_ID_TPV_OPTICAL_TOUCHSCREEN_8882\t0x8882\n#define USB_DEVICE_ID_TPV_OPTICAL_TOUCHSCREEN_8883\t0x8883\n\n#define USB_VENDOR_ID_TRUST             0x145f\n#define USB_DEVICE_ID_TRUST_PANORA_TABLET   0x0212\n\n#define USB_VENDOR_ID_TURBOX\t\t0x062a\n#define USB_DEVICE_ID_TURBOX_KEYBOARD\t0x0201\n#define USB_DEVICE_ID_ASUS_MD_5110\t0x5110\n#define USB_DEVICE_ID_TURBOX_TOUCHSCREEN_MOSART\t0x7100\n\n#define USB_VENDOR_ID_TWINHAN\t\t0x6253\n#define USB_DEVICE_ID_TWINHAN_IR_REMOTE\t0x0100\n\n#define USB_VENDOR_ID_UCLOGIC\t\t0x5543\n#define USB_DEVICE_ID_UCLOGIC_TABLET_PF1209\t0x0042\n#define USB_DEVICE_ID_UCLOGIC_TABLET_KNA5\t0x6001\n#define USB_DEVICE_ID_UCLOGIC_TABLET_TWA60\t0x0064\n#define USB_DEVICE_ID_UCLOGIC_TABLET_WP4030U\t0x0003\n#define USB_DEVICE_ID_UCLOGIC_TABLET_WP5540U\t0x0004\n#define USB_DEVICE_ID_UCLOGIC_TABLET_WP8060U\t0x0005\n#define USB_DEVICE_ID_UCLOGIC_TABLET_WP1062\t0x0064\n#define USB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850\t0x0522\n#define USB_DEVICE_ID_UCLOGIC_TABLET_TWHA60\t0x0781\n#define USB_DEVICE_ID_UCLOGIC_DRAWIMAGE_G3\t0x3031\n#define USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_81\t0x0081\n#define USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_45\t0x0045\n#define USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_47\t0x0047\n#define USB_DEVICE_ID_YIYNOVA_TABLET\t\t0x004d\n\n#define USB_VENDOR_ID_UGEE\t\t0x28bd\n#define USB_DEVICE_ID_UGEE_XPPEN_TABLET_G540\t0x0075\n#define USB_DEVICE_ID_UGEE_XPPEN_TABLET_G640\t0x0094\n#define USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO01\t0x0042\n#define USB_DEVICE_ID_UGEE_TABLET_G5\t\t0x0074\n#define USB_DEVICE_ID_UGEE_TABLET_EX07S\t\t0x0071\n#define USB_DEVICE_ID_UGEE_TABLET_RAINBOW_CV720\t0x0055\n\n#define USB_VENDOR_ID_UNITEC\t0x227d\n#define USB_DEVICE_ID_UNITEC_USB_TOUCH_0709\t0x0709\n#define USB_DEVICE_ID_UNITEC_USB_TOUCH_0A19\t0x0a19\n\n#define USB_VENDOR_ID_VELLEMAN\t\t0x10cf\n#define USB_DEVICE_ID_VELLEMAN_K8055_FIRST\t0x5500\n#define USB_DEVICE_ID_VELLEMAN_K8055_LAST\t0x5503\n#define USB_DEVICE_ID_VELLEMAN_K8061_FIRST\t0x8061\n#define USB_DEVICE_ID_VELLEMAN_K8061_LAST\t0x8068\n\n#define USB_VENDOR_ID_VTL\t\t0x0306\n#define USB_DEVICE_ID_VTL_MULTITOUCH_FF3F\t0xff3f\n\n#define USB_VENDOR_ID_WACOM\t\t0x056a\n#define USB_DEVICE_ID_WACOM_GRAPHIRE_BLUETOOTH\t0x81\n#define USB_DEVICE_ID_WACOM_INTUOS4_BLUETOOTH   0x00BD\n\n#define USB_VENDOR_ID_WALTOP\t\t\t\t0x172f\n#define USB_DEVICE_ID_WALTOP_SLIM_TABLET_5_8_INCH\t0x0032\n#define USB_DEVICE_ID_WALTOP_SLIM_TABLET_12_1_INCH\t0x0034\n#define USB_DEVICE_ID_WALTOP_Q_PAD\t\t\t0x0037\n#define USB_DEVICE_ID_WALTOP_PID_0038\t\t\t0x0038\n#define USB_DEVICE_ID_WALTOP_MEDIA_TABLET_10_6_INCH\t0x0501\n#define USB_DEVICE_ID_WALTOP_MEDIA_TABLET_14_1_INCH\t0x0500\n#define USB_DEVICE_ID_WALTOP_SIRIUS_BATTERY_FREE_TABLET\t0x0502\n\n#define\tUSB_VENDOR_ID_WEIDA\t\t0x2575\n#define\tUSB_DEVICE_ID_WEIDA_8752\t0xC300\n#define\tUSB_DEVICE_ID_WEIDA_8755\t0xC301\n\n#define USB_VENDOR_ID_WISEGROUP\t\t0x0925\n#define USB_DEVICE_ID_SMARTJOY_PLUS\t0x0005\n#define USB_DEVICE_ID_SUPER_JOY_BOX_3\t0x8888\n#define USB_DEVICE_ID_QUAD_USB_JOYPAD\t0x8800\n#define USB_DEVICE_ID_DUAL_USB_JOYPAD\t0x8866\n\n#define USB_VENDOR_ID_WISEGROUP_LTD\t0x6666\n#define USB_VENDOR_ID_WISEGROUP_LTD2\t0x6677\n#define USB_DEVICE_ID_SMARTJOY_DUAL_PLUS 0x8802\n#define USB_DEVICE_ID_SUPER_JOY_BOX_3_PRO 0x8801\n#define USB_DEVICE_ID_SUPER_DUAL_BOX_PRO 0x8802\n#define USB_DEVICE_ID_SUPER_JOY_BOX_5_PRO 0x8804\n\n#define USB_VENDOR_ID_WISTRON\t\t0x0fb8\n#define USB_DEVICE_ID_WISTRON_OPTICAL_TOUCH\t\t0x1109\n\n#define USB_VENDOR_ID_X_TENSIONS               0x1ae7\n#define USB_DEVICE_ID_SPEEDLINK_VAD_CEZANNE    0x9001\n\n#define USB_VENDOR_ID_XAT\t0x2505\n#define USB_DEVICE_ID_XAT_CSR\t0x0220\n\n#define USB_VENDOR_ID_XIN_MO\t\t\t0x16c0\n#define USB_DEVICE_ID_XIN_MO_DUAL_ARCADE\t0x05e1\n#define USB_DEVICE_ID_THT_2P_ARCADE\t\t0x75e1\n\n#define USB_VENDOR_ID_XIROKU\t\t0x1477\n#define USB_DEVICE_ID_XIROKU_SPX\t0x1006\n#define USB_DEVICE_ID_XIROKU_MPX\t0x1007\n#define USB_DEVICE_ID_XIROKU_CSR\t0x100e\n#define USB_DEVICE_ID_XIROKU_SPX1\t0x1021\n#define USB_DEVICE_ID_XIROKU_CSR1\t0x1022\n#define USB_DEVICE_ID_XIROKU_MPX1\t0x1023\n#define USB_DEVICE_ID_XIROKU_SPX2\t0x1024\n#define USB_DEVICE_ID_XIROKU_CSR2\t0x1025\n#define USB_DEVICE_ID_XIROKU_MPX2\t0x1026\n\n#define USB_VENDOR_ID_YEALINK\t\t0x6993\n#define USB_DEVICE_ID_YEALINK_P1K_P4K_B2K\t0xb001\n\n#define USB_VENDOR_ID_ZEROPLUS\t\t0x0c12\n\n#define USB_VENDOR_ID_ZYDACRON\t0x13EC\n#define USB_DEVICE_ID_ZYDACRON_REMOTE_CONTROL\t0x0006\n\n#define USB_VENDOR_ID_ZYTRONIC\t\t0x14c8\n#define USB_DEVICE_ID_ZYTRONIC_ZXY100\t0x0005\n\n#define USB_VENDOR_ID_PRIMAX\t0x0461\n#define USB_DEVICE_ID_PRIMAX_MOUSE_4D22\t0x4d22\n#define USB_DEVICE_ID_PRIMAX_KEYBOARD\t0x4e05\n#define USB_DEVICE_ID_PRIMAX_REZEL\t0x4e72\n#define USB_DEVICE_ID_PRIMAX_PIXART_MOUSE_4D0F\t0x4d0f\n#define USB_DEVICE_ID_PRIMAX_PIXART_MOUSE_4D65\t0x4d65\n#define USB_DEVICE_ID_PRIMAX_PIXART_MOUSE_4E22\t0x4e22\n\n\n#define USB_VENDOR_ID_RISO_KAGAKU\t0x1294\t/* Riso Kagaku Corp. */\n#define USB_DEVICE_ID_RI_KA_WEBMAIL\t0x1320\t/* Webmail Notifier */\n\n#define USB_VENDOR_ID_MULTIPLE_1781\t0x1781\n#define USB_DEVICE_ID_RAPHNET_4NES4SNES_OLD\t0x0a9d\n\n#define USB_VENDOR_ID_DRACAL_RAPHNET\t0x289b\n#define USB_DEVICE_ID_RAPHNET_2NES2SNES\t0x0002\n#define USB_DEVICE_ID_RAPHNET_4NES4SNES\t0x0003\n\n#define USB_VENDOR_ID_UGTIZER\t\t\t0x2179\n#define USB_DEVICE_ID_UGTIZER_TABLET_GP0610\t0x0053\n#define USB_DEVICE_ID_UGTIZER_TABLET_GT5040\t0x0077\n\n#define USB_VENDOR_ID_VIEWSONIC\t\t\t0x0543\n#define USB_DEVICE_ID_VIEWSONIC_PD1011\t\t0xe621\n\n#define USB_VENDOR_ID_SIGNOTEC\t\t\t0x2133\n#define USB_DEVICE_ID_SIGNOTEC_VIEWSONIC_PD1011\t0x0018\n\n#endif\n"}, "18": {"id": 18, "path": "/src/include/linux/usb.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_USB_H\n#define __LINUX_USB_H\n\n#include <linux/mod_devicetable.h>\n#include <linux/usb/ch9.h>\n\n#define USB_MAJOR\t\t\t180\n#define USB_DEVICE_MAJOR\t\t189\n\n\n#ifdef __KERNEL__\n\n#include <linux/errno.h>        /* for -ENODEV */\n#include <linux/delay.h>\t/* for mdelay() */\n#include <linux/interrupt.h>\t/* for in_interrupt() */\n#include <linux/list.h>\t\t/* for struct list_head */\n#include <linux/kref.h>\t\t/* for struct kref */\n#include <linux/device.h>\t/* for struct device */\n#include <linux/fs.h>\t\t/* for struct file_operations */\n#include <linux/completion.h>\t/* for struct completion */\n#include <linux/sched.h>\t/* for current && schedule_timeout */\n#include <linux/mutex.h>\t/* for struct mutex */\n#include <linux/pm_runtime.h>\t/* for runtime PM */\n\nstruct usb_device;\nstruct usb_driver;\nstruct wusb_dev;\n\n/*-------------------------------------------------------------------------*/\n\n/*\n * Host-side wrappers for standard USB descriptors ... these are parsed\n * from the data provided by devices.  Parsing turns them from a flat\n * sequence of descriptors into a hierarchy:\n *\n *  - devices have one (usually) or more configs;\n *  - configs have one (often) or more interfaces;\n *  - interfaces have one (usually) or more settings;\n *  - each interface setting has zero or (usually) more endpoints.\n *  - a SuperSpeed endpoint has a companion descriptor\n *\n * And there might be other descriptors mixed in with those.\n *\n * Devices may also have class-specific or vendor-specific descriptors.\n */\n\nstruct ep_device;\n\n/**\n * struct usb_host_endpoint - host-side endpoint descriptor and queue\n * @desc: descriptor for this endpoint, wMaxPacketSize in native byteorder\n * @ss_ep_comp: SuperSpeed companion descriptor for this endpoint\n * @ssp_isoc_ep_comp: SuperSpeedPlus isoc companion descriptor for this endpoint\n * @urb_list: urbs queued to this endpoint; maintained by usbcore\n * @hcpriv: for use by HCD; typically holds hardware dma queue head (QH)\n *\twith one or more transfer descriptors (TDs) per urb\n * @ep_dev: ep_device for sysfs info\n * @extra: descriptors following this endpoint in the configuration\n * @extralen: how many bytes of \"extra\" are valid\n * @enabled: URBs may be submitted to this endpoint\n * @streams: number of USB-3 streams allocated on the endpoint\n *\n * USB requests are always queued to a given endpoint, identified by a\n * descriptor within an active interface in a given USB configuration.\n */\nstruct usb_host_endpoint {\n\tstruct usb_endpoint_descriptor\t\tdesc;\n\tstruct usb_ss_ep_comp_descriptor\tss_ep_comp;\n\tstruct usb_ssp_isoc_ep_comp_descriptor\tssp_isoc_ep_comp;\n\tstruct list_head\t\turb_list;\n\tvoid\t\t\t\t*hcpriv;\n\tstruct ep_device\t\t*ep_dev;\t/* For sysfs info */\n\n\tunsigned char *extra;   /* Extra descriptors */\n\tint extralen;\n\tint enabled;\n\tint streams;\n};\n\n/* host-side wrapper for one interface setting's parsed descriptors */\nstruct usb_host_interface {\n\tstruct usb_interface_descriptor\tdesc;\n\n\tint extralen;\n\tunsigned char *extra;   /* Extra descriptors */\n\n\t/* array of desc.bNumEndpoints endpoints associated with this\n\t * interface setting.  these will be in no particular order.\n\t */\n\tstruct usb_host_endpoint *endpoint;\n\n\tchar *string;\t\t/* iInterface string, if present */\n};\n\nenum usb_interface_condition {\n\tUSB_INTERFACE_UNBOUND = 0,\n\tUSB_INTERFACE_BINDING,\n\tUSB_INTERFACE_BOUND,\n\tUSB_INTERFACE_UNBINDING,\n};\n\nint __must_check\nusb_find_common_endpoints(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out);\n\nint __must_check\nusb_find_common_endpoints_reverse(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out);\n\nstatic inline int __must_check\nusb_find_bulk_in_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in)\n{\n\treturn usb_find_common_endpoints(alt, bulk_in, NULL, NULL, NULL);\n}\n\nstatic inline int __must_check\nusb_find_bulk_out_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_out)\n{\n\treturn usb_find_common_endpoints(alt, NULL, bulk_out, NULL, NULL);\n}\n\nstatic inline int __must_check\nusb_find_int_in_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **int_in)\n{\n\treturn usb_find_common_endpoints(alt, NULL, NULL, int_in, NULL);\n}\n\nstatic inline int __must_check\nusb_find_int_out_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\treturn usb_find_common_endpoints(alt, NULL, NULL, NULL, int_out);\n}\n\nstatic inline int __must_check\nusb_find_last_bulk_in_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in)\n{\n\treturn usb_find_common_endpoints_reverse(alt, bulk_in, NULL, NULL, NULL);\n}\n\nstatic inline int __must_check\nusb_find_last_bulk_out_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_out)\n{\n\treturn usb_find_common_endpoints_reverse(alt, NULL, bulk_out, NULL, NULL);\n}\n\nstatic inline int __must_check\nusb_find_last_int_in_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **int_in)\n{\n\treturn usb_find_common_endpoints_reverse(alt, NULL, NULL, int_in, NULL);\n}\n\nstatic inline int __must_check\nusb_find_last_int_out_endpoint(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\treturn usb_find_common_endpoints_reverse(alt, NULL, NULL, NULL, int_out);\n}\n\n/**\n * struct usb_interface - what usb device drivers talk to\n * @altsetting: array of interface structures, one for each alternate\n *\tsetting that may be selected.  Each one includes a set of\n *\tendpoint configurations.  They will be in no particular order.\n * @cur_altsetting: the current altsetting.\n * @num_altsetting: number of altsettings defined.\n * @intf_assoc: interface association descriptor\n * @minor: the minor number assigned to this interface, if this\n *\tinterface is bound to a driver that uses the USB major number.\n *\tIf this interface does not use the USB major, this field should\n *\tbe unused.  The driver should set this value in the probe()\n *\tfunction of the driver, after it has been assigned a minor\n *\tnumber from the USB core by calling usb_register_dev().\n * @condition: binding state of the interface: not bound, binding\n *\t(in probe()), bound to a driver, or unbinding (in disconnect())\n * @sysfs_files_created: sysfs attributes exist\n * @ep_devs_created: endpoint child pseudo-devices exist\n * @unregistering: flag set when the interface is being unregistered\n * @needs_remote_wakeup: flag set when the driver requires remote-wakeup\n *\tcapability during autosuspend.\n * @needs_altsetting0: flag set when a set-interface request for altsetting 0\n *\thas been deferred.\n * @needs_binding: flag set when the driver should be re-probed or unbound\n *\tfollowing a reset or suspend operation it doesn't support.\n * @authorized: This allows to (de)authorize individual interfaces instead\n *\ta whole device in contrast to the device authorization.\n * @dev: driver model's view of this device\n * @usb_dev: if an interface is bound to the USB major, this will point\n *\tto the sysfs representation for that device.\n * @reset_ws: Used for scheduling resets from atomic context.\n * @resetting_device: USB core reset the device, so use alt setting 0 as\n *\tcurrent; needs bandwidth alloc after reset.\n *\n * USB device drivers attach to interfaces on a physical device.  Each\n * interface encapsulates a single high level function, such as feeding\n * an audio stream to a speaker or reporting a change in a volume control.\n * Many USB devices only have one interface.  The protocol used to talk to\n * an interface's endpoints can be defined in a usb \"class\" specification,\n * or by a product's vendor.  The (default) control endpoint is part of\n * every interface, but is never listed among the interface's descriptors.\n *\n * The driver that is bound to the interface can use standard driver model\n * calls such as dev_get_drvdata() on the dev member of this structure.\n *\n * Each interface may have alternate settings.  The initial configuration\n * of a device sets altsetting 0, but the device driver can change\n * that setting using usb_set_interface().  Alternate settings are often\n * used to control the use of periodic endpoints, such as by having\n * different endpoints use different amounts of reserved USB bandwidth.\n * All standards-conformant USB devices that use isochronous endpoints\n * will use them in non-default settings.\n *\n * The USB specification says that alternate setting numbers must run from\n * 0 to one less than the total number of alternate settings.  But some\n * devices manage to mess this up, and the structures aren't necessarily\n * stored in numerical order anyhow.  Use usb_altnum_to_altsetting() to\n * look up an alternate setting in the altsetting array based on its number.\n */\nstruct usb_interface {\n\t/* array of alternate settings for this interface,\n\t * stored in no particular order */\n\tstruct usb_host_interface *altsetting;\n\n\tstruct usb_host_interface *cur_altsetting;\t/* the currently\n\t\t\t\t\t * active alternate setting */\n\tunsigned num_altsetting;\t/* number of alternate settings */\n\n\t/* If there is an interface association descriptor then it will list\n\t * the associated interfaces */\n\tstruct usb_interface_assoc_descriptor *intf_assoc;\n\n\tint minor;\t\t\t/* minor number this interface is\n\t\t\t\t\t * bound to */\n\tenum usb_interface_condition condition;\t\t/* state of binding */\n\tunsigned sysfs_files_created:1;\t/* the sysfs attributes exist */\n\tunsigned ep_devs_created:1;\t/* endpoint \"devices\" exist */\n\tunsigned unregistering:1;\t/* unregistration is in progress */\n\tunsigned needs_remote_wakeup:1;\t/* driver requires remote wakeup */\n\tunsigned needs_altsetting0:1;\t/* switch to altsetting 0 is pending */\n\tunsigned needs_binding:1;\t/* needs delayed unbind/rebind */\n\tunsigned resetting_device:1;\t/* true: bandwidth alloc after reset */\n\tunsigned authorized:1;\t\t/* used for interface authorization */\n\n\tstruct device dev;\t\t/* interface specific device info */\n\tstruct device *usb_dev;\n\tstruct work_struct reset_ws;\t/* for resets in atomic context */\n};\n#define\tto_usb_interface(d) container_of(d, struct usb_interface, dev)\n\nstatic inline void *usb_get_intfdata(struct usb_interface *intf)\n{\n\treturn dev_get_drvdata(&intf->dev);\n}\n\nstatic inline void usb_set_intfdata(struct usb_interface *intf, void *data)\n{\n\tdev_set_drvdata(&intf->dev, data);\n}\n\nstruct usb_interface *usb_get_intf(struct usb_interface *intf);\nvoid usb_put_intf(struct usb_interface *intf);\n\n/* Hard limit */\n#define USB_MAXENDPOINTS\t30\n/* this maximum is arbitrary */\n#define USB_MAXINTERFACES\t32\n#define USB_MAXIADS\t\t(USB_MAXINTERFACES/2)\n\n/*\n * USB Resume Timer: Every Host controller driver should drive the resume\n * signalling on the bus for the amount of time defined by this macro.\n *\n * That way we will have a 'stable' behavior among all HCDs supported by Linux.\n *\n * Note that the USB Specification states we should drive resume for *at least*\n * 20 ms, but it doesn't give an upper bound. This creates two possible\n * situations which we want to avoid:\n *\n * (a) sometimes an msleep(20) might expire slightly before 20 ms, which causes\n * us to fail USB Electrical Tests, thus failing Certification\n *\n * (b) Some (many) devices actually need more than 20 ms of resume signalling,\n * and while we can argue that's against the USB Specification, we don't have\n * control over which devices a certification laboratory will be using for\n * certification. If CertLab uses a device which was tested against Windows and\n * that happens to have relaxed resume signalling rules, we might fall into\n * situations where we fail interoperability and electrical tests.\n *\n * In order to avoid both conditions, we're using a 40 ms resume timeout, which\n * should cope with both LPJ calibration errors and devices not following every\n * detail of the USB Specification.\n */\n#define USB_RESUME_TIMEOUT\t40 /* ms */\n\n/**\n * struct usb_interface_cache - long-term representation of a device interface\n * @num_altsetting: number of altsettings defined.\n * @ref: reference counter.\n * @altsetting: variable-length array of interface structures, one for\n *\teach alternate setting that may be selected.  Each one includes a\n *\tset of endpoint configurations.  They will be in no particular order.\n *\n * These structures persist for the lifetime of a usb_device, unlike\n * struct usb_interface (which persists only as long as its configuration\n * is installed).  The altsetting arrays can be accessed through these\n * structures at any time, permitting comparison of configurations and\n * providing support for the /sys/kernel/debug/usb/devices pseudo-file.\n */\nstruct usb_interface_cache {\n\tunsigned num_altsetting;\t/* number of alternate settings */\n\tstruct kref ref;\t\t/* reference counter */\n\n\t/* variable-length array of alternate settings for this interface,\n\t * stored in no particular order */\n\tstruct usb_host_interface altsetting[];\n};\n#define\tref_to_usb_interface_cache(r) \\\n\t\tcontainer_of(r, struct usb_interface_cache, ref)\n#define\taltsetting_to_usb_interface_cache(a) \\\n\t\tcontainer_of(a, struct usb_interface_cache, altsetting[0])\n\n/**\n * struct usb_host_config - representation of a device's configuration\n * @desc: the device's configuration descriptor.\n * @string: pointer to the cached version of the iConfiguration string, if\n *\tpresent for this configuration.\n * @intf_assoc: list of any interface association descriptors in this config\n * @interface: array of pointers to usb_interface structures, one for each\n *\tinterface in the configuration.  The number of interfaces is stored\n *\tin desc.bNumInterfaces.  These pointers are valid only while the\n *\tconfiguration is active.\n * @intf_cache: array of pointers to usb_interface_cache structures, one\n *\tfor each interface in the configuration.  These structures exist\n *\tfor the entire life of the device.\n * @extra: pointer to buffer containing all extra descriptors associated\n *\twith this configuration (those preceding the first interface\n *\tdescriptor).\n * @extralen: length of the extra descriptors buffer.\n *\n * USB devices may have multiple configurations, but only one can be active\n * at any time.  Each encapsulates a different operational environment;\n * for example, a dual-speed device would have separate configurations for\n * full-speed and high-speed operation.  The number of configurations\n * available is stored in the device descriptor as bNumConfigurations.\n *\n * A configuration can contain multiple interfaces.  Each corresponds to\n * a different function of the USB device, and all are available whenever\n * the configuration is active.  The USB standard says that interfaces\n * are supposed to be numbered from 0 to desc.bNumInterfaces-1, but a lot\n * of devices get this wrong.  In addition, the interface array is not\n * guaranteed to be sorted in numerical order.  Use usb_ifnum_to_if() to\n * look up an interface entry based on its number.\n *\n * Device drivers should not attempt to activate configurations.  The choice\n * of which configuration to install is a policy decision based on such\n * considerations as available power, functionality provided, and the user's\n * desires (expressed through userspace tools).  However, drivers can call\n * usb_reset_configuration() to reinitialize the current configuration and\n * all its interfaces.\n */\nstruct usb_host_config {\n\tstruct usb_config_descriptor\tdesc;\n\n\tchar *string;\t\t/* iConfiguration string, if present */\n\n\t/* List of any Interface Association Descriptors in this\n\t * configuration. */\n\tstruct usb_interface_assoc_descriptor *intf_assoc[USB_MAXIADS];\n\n\t/* the interfaces associated with this configuration,\n\t * stored in no particular order */\n\tstruct usb_interface *interface[USB_MAXINTERFACES];\n\n\t/* Interface information available even when this is not the\n\t * active configuration */\n\tstruct usb_interface_cache *intf_cache[USB_MAXINTERFACES];\n\n\tunsigned char *extra;   /* Extra descriptors */\n\tint extralen;\n};\n\n/* USB2.0 and USB3.0 device BOS descriptor set */\nstruct usb_host_bos {\n\tstruct usb_bos_descriptor\t*desc;\n\n\t/* wireless cap descriptor is handled by wusb */\n\tstruct usb_ext_cap_descriptor\t*ext_cap;\n\tstruct usb_ss_cap_descriptor\t*ss_cap;\n\tstruct usb_ssp_cap_descriptor\t*ssp_cap;\n\tstruct usb_ss_container_id_descriptor\t*ss_id;\n\tstruct usb_ptm_cap_descriptor\t*ptm_cap;\n};\n\nint __usb_get_extra_descriptor(char *buffer, unsigned size,\n\tunsigned char type, void **ptr, size_t min);\n#define usb_get_extra_descriptor(ifpoint, type, ptr) \\\n\t\t\t\t__usb_get_extra_descriptor((ifpoint)->extra, \\\n\t\t\t\t(ifpoint)->extralen, \\\n\t\t\t\ttype, (void **)ptr, sizeof(**(ptr)))\n\n/* ----------------------------------------------------------------------- */\n\n/* USB device number allocation bitmap */\nstruct usb_devmap {\n\tunsigned long devicemap[128 / (8*sizeof(unsigned long))];\n};\n\n/*\n * Allocated per bus (tree of devices) we have:\n */\nstruct usb_bus {\n\tstruct device *controller;\t/* host side hardware */\n\tstruct device *sysdev;\t\t/* as seen from firmware or bus */\n\tint busnum;\t\t\t/* Bus number (in order of reg) */\n\tconst char *bus_name;\t\t/* stable id (PCI slot_name etc) */\n\tu8 uses_pio_for_control;\t/*\n\t\t\t\t\t * Does the host controller use PIO\n\t\t\t\t\t * for control transfers?\n\t\t\t\t\t */\n\tu8 otg_port;\t\t\t/* 0, or number of OTG/HNP port */\n\tunsigned is_b_host:1;\t\t/* true during some HNP roleswitches */\n\tunsigned b_hnp_enable:1;\t/* OTG: did A-Host enable HNP? */\n\tunsigned no_stop_on_short:1;    /*\n\t\t\t\t\t * Quirk: some controllers don't stop\n\t\t\t\t\t * the ep queue on a short transfer\n\t\t\t\t\t * with the URB_SHORT_NOT_OK flag set.\n\t\t\t\t\t */\n\tunsigned no_sg_constraint:1;\t/* no sg constraint */\n\tunsigned sg_tablesize;\t\t/* 0 or largest number of sg list entries */\n\n\tint devnum_next;\t\t/* Next open device number in\n\t\t\t\t\t * round-robin allocation */\n\tstruct mutex devnum_next_mutex; /* devnum_next mutex */\n\n\tstruct usb_devmap devmap;\t/* device address allocation map */\n\tstruct usb_device *root_hub;\t/* Root hub */\n\tstruct usb_bus *hs_companion;\t/* Companion EHCI bus, if any */\n\n\tint bandwidth_allocated;\t/* on this bus: how much of the time\n\t\t\t\t\t * reserved for periodic (intr/iso)\n\t\t\t\t\t * requests is used, on average?\n\t\t\t\t\t * Units: microseconds/frame.\n\t\t\t\t\t * Limits: Full/low speed reserve 90%,\n\t\t\t\t\t * while high speed reserves 80%.\n\t\t\t\t\t */\n\tint bandwidth_int_reqs;\t\t/* number of Interrupt requests */\n\tint bandwidth_isoc_reqs;\t/* number of Isoc. requests */\n\n\tunsigned resuming_ports;\t/* bit array: resuming root-hub ports */\n\n#if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)\n\tstruct mon_bus *mon_bus;\t/* non-null when associated */\n\tint monitored;\t\t\t/* non-zero when monitored */\n#endif\n};\n\nstruct usb_dev_state;\n\n/* ----------------------------------------------------------------------- */\n\nstruct usb_tt;\n\nenum usb_device_removable {\n\tUSB_DEVICE_REMOVABLE_UNKNOWN = 0,\n\tUSB_DEVICE_REMOVABLE,\n\tUSB_DEVICE_FIXED,\n};\n\nenum usb_port_connect_type {\n\tUSB_PORT_CONNECT_TYPE_UNKNOWN = 0,\n\tUSB_PORT_CONNECT_TYPE_HOT_PLUG,\n\tUSB_PORT_CONNECT_TYPE_HARD_WIRED,\n\tUSB_PORT_NOT_USED,\n};\n\n/*\n * USB port quirks.\n */\n\n/* For the given port, prefer the old (faster) enumeration scheme. */\n#define USB_PORT_QUIRK_OLD_SCHEME\tBIT(0)\n\n/* Decrease TRSTRCY to 10ms during device enumeration. */\n#define USB_PORT_QUIRK_FAST_ENUM\tBIT(1)\n\n/*\n * USB 2.0 Link Power Management (LPM) parameters.\n */\nstruct usb2_lpm_parameters {\n\t/* Best effort service latency indicate how long the host will drive\n\t * resume on an exit from L1.\n\t */\n\tunsigned int besl;\n\n\t/* Timeout value in microseconds for the L1 inactivity (LPM) timer.\n\t * When the timer counts to zero, the parent hub will initiate a LPM\n\t * transition to L1.\n\t */\n\tint timeout;\n};\n\n/*\n * USB 3.0 Link Power Management (LPM) parameters.\n *\n * PEL and SEL are USB 3.0 Link PM latencies for device-initiated LPM exit.\n * MEL is the USB 3.0 Link PM latency for host-initiated LPM exit.\n * All three are stored in nanoseconds.\n */\nstruct usb3_lpm_parameters {\n\t/*\n\t * Maximum exit latency (MEL) for the host to send a packet to the\n\t * device (either a Ping for isoc endpoints, or a data packet for\n\t * interrupt endpoints), the hubs to decode the packet, and for all hubs\n\t * in the path to transition the links to U0.\n\t */\n\tunsigned int mel;\n\t/*\n\t * Maximum exit latency for a device-initiated LPM transition to bring\n\t * all links into U0.  Abbreviated as \"PEL\" in section 9.4.12 of the USB\n\t * 3.0 spec, with no explanation of what \"P\" stands for.  \"Path\"?\n\t */\n\tunsigned int pel;\n\n\t/*\n\t * The System Exit Latency (SEL) includes PEL, and three other\n\t * latencies.  After a device initiates a U0 transition, it will take\n\t * some time from when the device sends the ERDY to when it will finally\n\t * receive the data packet.  Basically, SEL should be the worse-case\n\t * latency from when a device starts initiating a U0 transition to when\n\t * it will get data.\n\t */\n\tunsigned int sel;\n\t/*\n\t * The idle timeout value that is currently programmed into the parent\n\t * hub for this device.  When the timer counts to zero, the parent hub\n\t * will initiate an LPM transition to either U1 or U2.\n\t */\n\tint timeout;\n};\n\n/**\n * struct usb_device - kernel's representation of a USB device\n * @devnum: device number; address on a USB bus\n * @devpath: device ID string for use in messages (e.g., /port/...)\n * @route: tree topology hex string for use with xHCI\n * @state: device state: configured, not attached, etc.\n * @speed: device speed: high/full/low (or error)\n * @rx_lanes: number of rx lanes in use, USB 3.2 adds dual-lane support\n * @tx_lanes: number of tx lanes in use, USB 3.2 adds dual-lane support\n * @tt: Transaction Translator info; used with low/full speed dev, highspeed hub\n * @ttport: device port on that tt hub\n * @toggle: one bit for each endpoint, with ([0] = IN, [1] = OUT) endpoints\n * @parent: our hub, unless we're the root\n * @bus: bus we're part of\n * @ep0: endpoint 0 data (default control pipe)\n * @dev: generic device interface\n * @descriptor: USB device descriptor\n * @bos: USB device BOS descriptor set\n * @config: all of the device's configs\n * @actconfig: the active configuration\n * @ep_in: array of IN endpoints\n * @ep_out: array of OUT endpoints\n * @rawdescriptors: raw descriptors for each config\n * @bus_mA: Current available from the bus\n * @portnum: parent port number (origin 1)\n * @level: number of USB hub ancestors\n * @devaddr: device address, XHCI: assigned by HW, others: same as devnum\n * @can_submit: URBs may be submitted\n * @persist_enabled:  USB_PERSIST enabled for this device\n * @have_langid: whether string_langid is valid\n * @authorized: policy has said we can use it;\n *\t(user space) policy determines if we authorize this device to be\n *\tused or not. By default, wired USB devices are authorized.\n *\tWUSB devices are not, until we authorize them from user space.\n *\tFIXME -- complete doc\n * @authenticated: Crypto authentication passed\n * @wusb: device is Wireless USB\n * @lpm_capable: device supports LPM\n * @usb2_hw_lpm_capable: device can perform USB2 hardware LPM\n * @usb2_hw_lpm_besl_capable: device can perform USB2 hardware BESL LPM\n * @usb2_hw_lpm_enabled: USB2 hardware LPM is enabled\n * @usb2_hw_lpm_allowed: Userspace allows USB 2.0 LPM to be enabled\n * @usb3_lpm_u1_enabled: USB3 hardware U1 LPM enabled\n * @usb3_lpm_u2_enabled: USB3 hardware U2 LPM enabled\n * @string_langid: language ID for strings\n * @product: iProduct string, if present (static)\n * @manufacturer: iManufacturer string, if present (static)\n * @serial: iSerialNumber string, if present (static)\n * @filelist: usbfs files that are open to this device\n * @maxchild: number of ports if hub\n * @quirks: quirks of the whole device\n * @urbnum: number of URBs submitted for the whole device\n * @active_duration: total time device is not suspended\n * @connect_time: time device was first connected\n * @do_remote_wakeup:  remote wakeup should be enabled\n * @reset_resume: needs reset instead of resume\n * @port_is_suspended: the upstream port is suspended (L2 or U3)\n * @wusb_dev: if this is a Wireless USB device, link to the WUSB\n *\tspecific data for the device.\n * @slot_id: Slot ID assigned by xHCI\n * @removable: Device can be physically removed from this port\n * @l1_params: best effor service latency for USB2 L1 LPM state, and L1 timeout.\n * @u1_params: exit latencies for USB3 U1 LPM state, and hub-initiated timeout.\n * @u2_params: exit latencies for USB3 U2 LPM state, and hub-initiated timeout.\n * @lpm_disable_count: Ref count used by usb_disable_lpm() and usb_enable_lpm()\n *\tto keep track of the number of functions that require USB 3.0 Link Power\n *\tManagement to be disabled for this usb_device.  This count should only\n *\tbe manipulated by those functions, with the bandwidth_mutex is held.\n * @hub_delay: cached value consisting of:\n *\tparent->hub_delay + wHubDelay + tTPTransmissionDelay (40ns)\n *\tWill be used as wValue for SetIsochDelay requests.\n * @use_generic_driver: ask driver core to reprobe using the generic driver.\n *\n * Notes:\n * Usbcore drivers should not set usbdev->state directly.  Instead use\n * usb_set_device_state().\n */\nstruct usb_device {\n\tint\t\tdevnum;\n\tchar\t\tdevpath[16];\n\tu32\t\troute;\n\tenum usb_device_state\tstate;\n\tenum usb_device_speed\tspeed;\n\tunsigned int\t\trx_lanes;\n\tunsigned int\t\ttx_lanes;\n\n\tstruct usb_tt\t*tt;\n\tint\t\tttport;\n\n\tunsigned int toggle[2];\n\n\tstruct usb_device *parent;\n\tstruct usb_bus *bus;\n\tstruct usb_host_endpoint ep0;\n\n\tstruct device dev;\n\n\tstruct usb_device_descriptor descriptor;\n\tstruct usb_host_bos *bos;\n\tstruct usb_host_config *config;\n\n\tstruct usb_host_config *actconfig;\n\tstruct usb_host_endpoint *ep_in[16];\n\tstruct usb_host_endpoint *ep_out[16];\n\n\tchar **rawdescriptors;\n\n\tunsigned short bus_mA;\n\tu8 portnum;\n\tu8 level;\n\tu8 devaddr;\n\n\tunsigned can_submit:1;\n\tunsigned persist_enabled:1;\n\tunsigned have_langid:1;\n\tunsigned authorized:1;\n\tunsigned authenticated:1;\n\tunsigned wusb:1;\n\tunsigned lpm_capable:1;\n\tunsigned usb2_hw_lpm_capable:1;\n\tunsigned usb2_hw_lpm_besl_capable:1;\n\tunsigned usb2_hw_lpm_enabled:1;\n\tunsigned usb2_hw_lpm_allowed:1;\n\tunsigned usb3_lpm_u1_enabled:1;\n\tunsigned usb3_lpm_u2_enabled:1;\n\tint string_langid;\n\n\t/* static strings from the device */\n\tchar *product;\n\tchar *manufacturer;\n\tchar *serial;\n\n\tstruct list_head filelist;\n\n\tint maxchild;\n\n\tu32 quirks;\n\tatomic_t urbnum;\n\n\tunsigned long active_duration;\n\n#ifdef CONFIG_PM\n\tunsigned long connect_time;\n\n\tunsigned do_remote_wakeup:1;\n\tunsigned reset_resume:1;\n\tunsigned port_is_suspended:1;\n#endif\n\tstruct wusb_dev *wusb_dev;\n\tint slot_id;\n\tenum usb_device_removable removable;\n\tstruct usb2_lpm_parameters l1_params;\n\tstruct usb3_lpm_parameters u1_params;\n\tstruct usb3_lpm_parameters u2_params;\n\tunsigned lpm_disable_count;\n\n\tu16 hub_delay;\n\tunsigned use_generic_driver:1;\n};\n#define\tto_usb_device(d) container_of(d, struct usb_device, dev)\n\nstatic inline struct usb_device *interface_to_usbdev(struct usb_interface *intf)\n{\n\treturn to_usb_device(intf->dev.parent);\n}\n\nextern struct usb_device *usb_get_dev(struct usb_device *dev);\nextern void usb_put_dev(struct usb_device *dev);\nextern struct usb_device *usb_hub_find_child(struct usb_device *hdev,\n\tint port1);\n\n/**\n * usb_hub_for_each_child - iterate over all child devices on the hub\n * @hdev:  USB device belonging to the usb hub\n * @port1: portnum associated with child device\n * @child: child device pointer\n */\n#define usb_hub_for_each_child(hdev, port1, child) \\\n\tfor (port1 = 1,\tchild =\tusb_hub_find_child(hdev, port1); \\\n\t\t\tport1 <= hdev->maxchild; \\\n\t\t\tchild = usb_hub_find_child(hdev, ++port1)) \\\n\t\tif (!child) continue; else\n\n/* USB device locking */\n#define usb_lock_device(udev)\t\t\tdevice_lock(&(udev)->dev)\n#define usb_unlock_device(udev)\t\t\tdevice_unlock(&(udev)->dev)\n#define usb_lock_device_interruptible(udev)\tdevice_lock_interruptible(&(udev)->dev)\n#define usb_trylock_device(udev)\t\tdevice_trylock(&(udev)->dev)\nextern int usb_lock_device_for_reset(struct usb_device *udev,\n\t\t\t\t     const struct usb_interface *iface);\n\n/* USB port reset for device reinitialization */\nextern int usb_reset_device(struct usb_device *dev);\nextern void usb_queue_reset_device(struct usb_interface *dev);\n\n#ifdef CONFIG_ACPI\nextern int usb_acpi_set_power_state(struct usb_device *hdev, int index,\n\tbool enable);\nextern bool usb_acpi_power_manageable(struct usb_device *hdev, int index);\n#else\nstatic inline int usb_acpi_set_power_state(struct usb_device *hdev, int index,\n\tbool enable) { return 0; }\nstatic inline bool usb_acpi_power_manageable(struct usb_device *hdev, int index)\n\t{ return true; }\n#endif\n\n/* USB autosuspend and autoresume */\n#ifdef CONFIG_PM\nextern void usb_enable_autosuspend(struct usb_device *udev);\nextern void usb_disable_autosuspend(struct usb_device *udev);\n\nextern int usb_autopm_get_interface(struct usb_interface *intf);\nextern void usb_autopm_put_interface(struct usb_interface *intf);\nextern int usb_autopm_get_interface_async(struct usb_interface *intf);\nextern void usb_autopm_put_interface_async(struct usb_interface *intf);\nextern void usb_autopm_get_interface_no_resume(struct usb_interface *intf);\nextern void usb_autopm_put_interface_no_suspend(struct usb_interface *intf);\n\nstatic inline void usb_mark_last_busy(struct usb_device *udev)\n{\n\tpm_runtime_mark_last_busy(&udev->dev);\n}\n\n#else\n\nstatic inline int usb_enable_autosuspend(struct usb_device *udev)\n{ return 0; }\nstatic inline int usb_disable_autosuspend(struct usb_device *udev)\n{ return 0; }\n\nstatic inline int usb_autopm_get_interface(struct usb_interface *intf)\n{ return 0; }\nstatic inline int usb_autopm_get_interface_async(struct usb_interface *intf)\n{ return 0; }\n\nstatic inline void usb_autopm_put_interface(struct usb_interface *intf)\n{ }\nstatic inline void usb_autopm_put_interface_async(struct usb_interface *intf)\n{ }\nstatic inline void usb_autopm_get_interface_no_resume(\n\t\tstruct usb_interface *intf)\n{ }\nstatic inline void usb_autopm_put_interface_no_suspend(\n\t\tstruct usb_interface *intf)\n{ }\nstatic inline void usb_mark_last_busy(struct usb_device *udev)\n{ }\n#endif\n\nextern int usb_disable_lpm(struct usb_device *udev);\nextern void usb_enable_lpm(struct usb_device *udev);\n/* Same as above, but these functions lock/unlock the bandwidth_mutex. */\nextern int usb_unlocked_disable_lpm(struct usb_device *udev);\nextern void usb_unlocked_enable_lpm(struct usb_device *udev);\n\nextern int usb_disable_ltm(struct usb_device *udev);\nextern void usb_enable_ltm(struct usb_device *udev);\n\nstatic inline bool usb_device_supports_ltm(struct usb_device *udev)\n{\n\tif (udev->speed < USB_SPEED_SUPER || !udev->bos || !udev->bos->ss_cap)\n\t\treturn false;\n\treturn udev->bos->ss_cap->bmAttributes & USB_LTM_SUPPORT;\n}\n\nstatic inline bool usb_device_no_sg_constraint(struct usb_device *udev)\n{\n\treturn udev && udev->bus && udev->bus->no_sg_constraint;\n}\n\n\n/*-------------------------------------------------------------------------*/\n\n/* for drivers using iso endpoints */\nextern int usb_get_current_frame_number(struct usb_device *usb_dev);\n\n/* Sets up a group of bulk endpoints to support multiple stream IDs. */\nextern int usb_alloc_streams(struct usb_interface *interface,\n\t\tstruct usb_host_endpoint **eps, unsigned int num_eps,\n\t\tunsigned int num_streams, gfp_t mem_flags);\n\n/* Reverts a group of bulk endpoints back to not using stream IDs. */\nextern int usb_free_streams(struct usb_interface *interface,\n\t\tstruct usb_host_endpoint **eps, unsigned int num_eps,\n\t\tgfp_t mem_flags);\n\n/* used these for multi-interface device registration */\nextern int usb_driver_claim_interface(struct usb_driver *driver,\n\t\t\tstruct usb_interface *iface, void *priv);\n\n/**\n * usb_interface_claimed - returns true iff an interface is claimed\n * @iface: the interface being checked\n *\n * Return: %true (nonzero) iff the interface is claimed, else %false\n * (zero).\n *\n * Note:\n * Callers must own the driver model's usb bus readlock.  So driver\n * probe() entries don't need extra locking, but other call contexts\n * may need to explicitly claim that lock.\n *\n */\nstatic inline int usb_interface_claimed(struct usb_interface *iface)\n{\n\treturn (iface->dev.driver != NULL);\n}\n\nextern void usb_driver_release_interface(struct usb_driver *driver,\n\t\t\tstruct usb_interface *iface);\nconst struct usb_device_id *usb_match_id(struct usb_interface *interface,\n\t\t\t\t\t const struct usb_device_id *id);\nextern int usb_match_one_id(struct usb_interface *interface,\n\t\t\t    const struct usb_device_id *id);\n\nextern int usb_for_each_dev(void *data, int (*fn)(struct usb_device *, void *));\nextern struct usb_interface *usb_find_interface(struct usb_driver *drv,\n\t\tint minor);\nextern struct usb_interface *usb_ifnum_to_if(const struct usb_device *dev,\n\t\tunsigned ifnum);\nextern struct usb_host_interface *usb_altnum_to_altsetting(\n\t\tconst struct usb_interface *intf, unsigned int altnum);\nextern struct usb_host_interface *usb_find_alt_setting(\n\t\tstruct usb_host_config *config,\n\t\tunsigned int iface_num,\n\t\tunsigned int alt_num);\n\n/* port claiming functions */\nint usb_hub_claim_port(struct usb_device *hdev, unsigned port1,\n\t\tstruct usb_dev_state *owner);\nint usb_hub_release_port(struct usb_device *hdev, unsigned port1,\n\t\tstruct usb_dev_state *owner);\n\n/**\n * usb_make_path - returns stable device path in the usb tree\n * @dev: the device whose path is being constructed\n * @buf: where to put the string\n * @size: how big is \"buf\"?\n *\n * Return: Length of the string (> 0) or negative if size was too small.\n *\n * Note:\n * This identifier is intended to be \"stable\", reflecting physical paths in\n * hardware such as physical bus addresses for host controllers or ports on\n * USB hubs.  That makes it stay the same until systems are physically\n * reconfigured, by re-cabling a tree of USB devices or by moving USB host\n * controllers.  Adding and removing devices, including virtual root hubs\n * in host controller driver modules, does not change these path identifiers;\n * neither does rebooting or re-enumerating.  These are more useful identifiers\n * than changeable (\"unstable\") ones like bus numbers or device addresses.\n *\n * With a partial exception for devices connected to USB 2.0 root hubs, these\n * identifiers are also predictable.  So long as the device tree isn't changed,\n * plugging any USB device into a given hub port always gives it the same path.\n * Because of the use of \"companion\" controllers, devices connected to ports on\n * USB 2.0 root hubs (EHCI host controllers) will get one path ID if they are\n * high speed, and a different one if they are full or low speed.\n */\nstatic inline int usb_make_path(struct usb_device *dev, char *buf, size_t size)\n{\n\tint actual;\n\tactual = snprintf(buf, size, \"usb-%s-%s\", dev->bus->bus_name,\n\t\t\t  dev->devpath);\n\treturn (actual >= (int)size) ? -1 : actual;\n}\n\n/*-------------------------------------------------------------------------*/\n\n#define USB_DEVICE_ID_MATCH_DEVICE \\\n\t\t(USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)\n#define USB_DEVICE_ID_MATCH_DEV_RANGE \\\n\t\t(USB_DEVICE_ID_MATCH_DEV_LO | USB_DEVICE_ID_MATCH_DEV_HI)\n#define USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION \\\n\t\t(USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_RANGE)\n#define USB_DEVICE_ID_MATCH_DEV_INFO \\\n\t\t(USB_DEVICE_ID_MATCH_DEV_CLASS | \\\n\t\tUSB_DEVICE_ID_MATCH_DEV_SUBCLASS | \\\n\t\tUSB_DEVICE_ID_MATCH_DEV_PROTOCOL)\n#define USB_DEVICE_ID_MATCH_INT_INFO \\\n\t\t(USB_DEVICE_ID_MATCH_INT_CLASS | \\\n\t\tUSB_DEVICE_ID_MATCH_INT_SUBCLASS | \\\n\t\tUSB_DEVICE_ID_MATCH_INT_PROTOCOL)\n\n/**\n * USB_DEVICE - macro used to describe a specific usb device\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific device.\n */\n#define USB_DEVICE(vend, prod) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod)\n/**\n * USB_DEVICE_VER - describe a specific usb device with a version range\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n * @lo: the bcdDevice_lo value\n * @hi: the bcdDevice_hi value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific device, with a version range.\n */\n#define USB_DEVICE_VER(vend, prod, lo, hi) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bcdDevice_lo = (lo), \\\n\t.bcdDevice_hi = (hi)\n\n/**\n * USB_DEVICE_INTERFACE_CLASS - describe a usb device with a specific interface class\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n * @cl: bInterfaceClass value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific interface class of devices.\n */\n#define USB_DEVICE_INTERFACE_CLASS(vend, prod, cl) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \\\n\t\t       USB_DEVICE_ID_MATCH_INT_CLASS, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bInterfaceClass = (cl)\n\n/**\n * USB_DEVICE_INTERFACE_PROTOCOL - describe a usb device with a specific interface protocol\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n * @pr: bInterfaceProtocol value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific interface protocol of devices.\n */\n#define USB_DEVICE_INTERFACE_PROTOCOL(vend, prod, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \\\n\t\t       USB_DEVICE_ID_MATCH_INT_PROTOCOL, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bInterfaceProtocol = (pr)\n\n/**\n * USB_DEVICE_INTERFACE_NUMBER - describe a usb device with a specific interface number\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n * @num: bInterfaceNumber value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific interface number of devices.\n */\n#define USB_DEVICE_INTERFACE_NUMBER(vend, prod, num) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \\\n\t\t       USB_DEVICE_ID_MATCH_INT_NUMBER, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bInterfaceNumber = (num)\n\n/**\n * USB_DEVICE_INFO - macro used to describe a class of usb devices\n * @cl: bDeviceClass value\n * @sc: bDeviceSubClass value\n * @pr: bDeviceProtocol value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific class of devices.\n */\n#define USB_DEVICE_INFO(cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEV_INFO, \\\n\t.bDeviceClass = (cl), \\\n\t.bDeviceSubClass = (sc), \\\n\t.bDeviceProtocol = (pr)\n\n/**\n * USB_INTERFACE_INFO - macro used to describe a class of usb interfaces\n * @cl: bInterfaceClass value\n * @sc: bInterfaceSubClass value\n * @pr: bInterfaceProtocol value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific class of interfaces.\n */\n#define USB_INTERFACE_INFO(cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_INT_INFO, \\\n\t.bInterfaceClass = (cl), \\\n\t.bInterfaceSubClass = (sc), \\\n\t.bInterfaceProtocol = (pr)\n\n/**\n * USB_DEVICE_AND_INTERFACE_INFO - describe a specific usb device with a class of usb interfaces\n * @vend: the 16 bit USB Vendor ID\n * @prod: the 16 bit USB Product ID\n * @cl: bInterfaceClass value\n * @sc: bInterfaceSubClass value\n * @pr: bInterfaceProtocol value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific device with a specific class of interfaces.\n *\n * This is especially useful when explicitly matching devices that have\n * vendor specific bDeviceClass values, but standards-compliant interfaces.\n */\n#define USB_DEVICE_AND_INTERFACE_INFO(vend, prod, cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \\\n\t\t| USB_DEVICE_ID_MATCH_DEVICE, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod), \\\n\t.bInterfaceClass = (cl), \\\n\t.bInterfaceSubClass = (sc), \\\n\t.bInterfaceProtocol = (pr)\n\n/**\n * USB_VENDOR_AND_INTERFACE_INFO - describe a specific usb vendor with a class of usb interfaces\n * @vend: the 16 bit USB Vendor ID\n * @cl: bInterfaceClass value\n * @sc: bInterfaceSubClass value\n * @pr: bInterfaceProtocol value\n *\n * This macro is used to create a struct usb_device_id that matches a\n * specific vendor with a specific class of interfaces.\n *\n * This is especially useful when explicitly matching devices that have\n * vendor specific bDeviceClass values, but standards-compliant interfaces.\n */\n#define USB_VENDOR_AND_INTERFACE_INFO(vend, cl, sc, pr) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \\\n\t\t| USB_DEVICE_ID_MATCH_VENDOR, \\\n\t.idVendor = (vend), \\\n\t.bInterfaceClass = (cl), \\\n\t.bInterfaceSubClass = (sc), \\\n\t.bInterfaceProtocol = (pr)\n\n/* ----------------------------------------------------------------------- */\n\n/* Stuff for dynamic usb ids */\nstruct usb_dynids {\n\tspinlock_t lock;\n\tstruct list_head list;\n};\n\nstruct usb_dynid {\n\tstruct list_head node;\n\tstruct usb_device_id id;\n};\n\nextern ssize_t usb_store_new_id(struct usb_dynids *dynids,\n\t\t\t\tconst struct usb_device_id *id_table,\n\t\t\t\tstruct device_driver *driver,\n\t\t\t\tconst char *buf, size_t count);\n\nextern ssize_t usb_show_dynids(struct usb_dynids *dynids, char *buf);\n\n/**\n * struct usbdrv_wrap - wrapper for driver-model structure\n * @driver: The driver-model core driver structure.\n * @for_devices: Non-zero for device drivers, 0 for interface drivers.\n */\nstruct usbdrv_wrap {\n\tstruct device_driver driver;\n\tint for_devices;\n};\n\n/**\n * struct usb_driver - identifies USB interface driver to usbcore\n * @name: The driver name should be unique among USB drivers,\n *\tand should normally be the same as the module name.\n * @probe: Called to see if the driver is willing to manage a particular\n *\tinterface on a device.  If it is, probe returns zero and uses\n *\tusb_set_intfdata() to associate driver-specific data with the\n *\tinterface.  It may also use usb_set_interface() to specify the\n *\tappropriate altsetting.  If unwilling to manage the interface,\n *\treturn -ENODEV, if genuine IO errors occurred, an appropriate\n *\tnegative errno value.\n * @disconnect: Called when the interface is no longer accessible, usually\n *\tbecause its device has been (or is being) disconnected or the\n *\tdriver module is being unloaded.\n * @unlocked_ioctl: Used for drivers that want to talk to userspace through\n *\tthe \"usbfs\" filesystem.  This lets devices provide ways to\n *\texpose information to user space regardless of where they\n *\tdo (or don't) show up otherwise in the filesystem.\n * @suspend: Called when the device is going to be suspended by the\n *\tsystem either from system sleep or runtime suspend context. The\n *\treturn value will be ignored in system sleep context, so do NOT\n *\ttry to continue using the device if suspend fails in this case.\n *\tInstead, let the resume or reset-resume routine recover from\n *\tthe failure.\n * @resume: Called when the device is being resumed by the system.\n * @reset_resume: Called when the suspended device has been reset instead\n *\tof being resumed.\n * @pre_reset: Called by usb_reset_device() when the device is about to be\n *\treset.  This routine must not return until the driver has no active\n *\tURBs for the device, and no more URBs may be submitted until the\n *\tpost_reset method is called.\n * @post_reset: Called by usb_reset_device() after the device\n *\thas been reset\n * @id_table: USB drivers use ID table to support hotplugging.\n *\tExport this with MODULE_DEVICE_TABLE(usb,...).  This must be set\n *\tor your driver's probe function will never get called.\n * @dev_groups: Attributes attached to the device that will be created once it\n *\tis bound to the driver.\n * @dynids: used internally to hold the list of dynamically added device\n *\tids for this driver.\n * @drvwrap: Driver-model core structure wrapper.\n * @no_dynamic_id: if set to 1, the USB core will not allow dynamic ids to be\n *\tadded to this driver by preventing the sysfs file from being created.\n * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend\n *\tfor interfaces bound to this driver.\n * @soft_unbind: if set to 1, the USB core will not kill URBs and disable\n *\tendpoints before calling the driver's disconnect method.\n * @disable_hub_initiated_lpm: if set to 1, the USB core will not allow hubs\n *\tto initiate lower power link state transitions when an idle timeout\n *\toccurs.  Device-initiated USB 3.0 link PM will still be allowed.\n *\n * USB interface drivers must provide a name, probe() and disconnect()\n * methods, and an id_table.  Other driver fields are optional.\n *\n * The id_table is used in hotplugging.  It holds a set of descriptors,\n * and specialized data may be associated with each entry.  That table\n * is used by both user and kernel mode hotplugging support.\n *\n * The probe() and disconnect() methods are called in a context where\n * they can sleep, but they should avoid abusing the privilege.  Most\n * work to connect to a device should be done when the device is opened,\n * and undone at the last close.  The disconnect code needs to address\n * concurrency issues with respect to open() and close() methods, as\n * well as forcing all pending I/O requests to complete (by unlinking\n * them as necessary, and blocking until the unlinks complete).\n */\nstruct usb_driver {\n\tconst char *name;\n\n\tint (*probe) (struct usb_interface *intf,\n\t\t      const struct usb_device_id *id);\n\n\tvoid (*disconnect) (struct usb_interface *intf);\n\n\tint (*unlocked_ioctl) (struct usb_interface *intf, unsigned int code,\n\t\t\tvoid *buf);\n\n\tint (*suspend) (struct usb_interface *intf, pm_message_t message);\n\tint (*resume) (struct usb_interface *intf);\n\tint (*reset_resume)(struct usb_interface *intf);\n\n\tint (*pre_reset)(struct usb_interface *intf);\n\tint (*post_reset)(struct usb_interface *intf);\n\n\tconst struct usb_device_id *id_table;\n\tconst struct attribute_group **dev_groups;\n\n\tstruct usb_dynids dynids;\n\tstruct usbdrv_wrap drvwrap;\n\tunsigned int no_dynamic_id:1;\n\tunsigned int supports_autosuspend:1;\n\tunsigned int disable_hub_initiated_lpm:1;\n\tunsigned int soft_unbind:1;\n};\n#define\tto_usb_driver(d) container_of(d, struct usb_driver, drvwrap.driver)\n\n/**\n * struct usb_device_driver - identifies USB device driver to usbcore\n * @name: The driver name should be unique among USB drivers,\n *\tand should normally be the same as the module name.\n * @match: If set, used for better device/driver matching.\n * @probe: Called to see if the driver is willing to manage a particular\n *\tdevice.  If it is, probe returns zero and uses dev_set_drvdata()\n *\tto associate driver-specific data with the device.  If unwilling\n *\tto manage the device, return a negative errno value.\n * @disconnect: Called when the device is no longer accessible, usually\n *\tbecause it has been (or is being) disconnected or the driver's\n *\tmodule is being unloaded.\n * @suspend: Called when the device is going to be suspended by the system.\n * @resume: Called when the device is being resumed by the system.\n * @dev_groups: Attributes attached to the device that will be created once it\n *\tis bound to the driver.\n * @drvwrap: Driver-model core structure wrapper.\n * @id_table: used with @match() to select better matching driver at\n * \tprobe() time.\n * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend\n *\tfor devices bound to this driver.\n * @generic_subclass: if set to 1, the generic USB driver's probe, disconnect,\n *\tresume and suspend functions will be called in addition to the driver's\n *\town, so this part of the setup does not need to be replicated.\n *\n * USB drivers must provide all the fields listed above except drvwrap,\n * match, and id_table.\n */\nstruct usb_device_driver {\n\tconst char *name;\n\n\tbool (*match) (struct usb_device *udev);\n\tint (*probe) (struct usb_device *udev);\n\tvoid (*disconnect) (struct usb_device *udev);\n\n\tint (*suspend) (struct usb_device *udev, pm_message_t message);\n\tint (*resume) (struct usb_device *udev, pm_message_t message);\n\tconst struct attribute_group **dev_groups;\n\tstruct usbdrv_wrap drvwrap;\n\tconst struct usb_device_id *id_table;\n\tunsigned int supports_autosuspend:1;\n\tunsigned int generic_subclass:1;\n};\n#define\tto_usb_device_driver(d) container_of(d, struct usb_device_driver, \\\n\t\tdrvwrap.driver)\n\nextern struct bus_type usb_bus_type;\n\n/**\n * struct usb_class_driver - identifies a USB driver that wants to use the USB major number\n * @name: the usb class device name for this driver.  Will show up in sysfs.\n * @devnode: Callback to provide a naming hint for a possible\n *\tdevice node to create.\n * @fops: pointer to the struct file_operations of this driver.\n * @minor_base: the start of the minor range for this driver.\n *\n * This structure is used for the usb_register_dev() and\n * usb_deregister_dev() functions, to consolidate a number of the\n * parameters used for them.\n */\nstruct usb_class_driver {\n\tchar *name;\n\tchar *(*devnode)(struct device *dev, umode_t *mode);\n\tconst struct file_operations *fops;\n\tint minor_base;\n};\n\n/*\n * use these in module_init()/module_exit()\n * and don't forget MODULE_DEVICE_TABLE(usb, ...)\n */\nextern int usb_register_driver(struct usb_driver *, struct module *,\n\t\t\t       const char *);\n\n/* use a define to avoid include chaining to get THIS_MODULE & friends */\n#define usb_register(driver) \\\n\tusb_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)\n\nextern void usb_deregister(struct usb_driver *);\n\n/**\n * module_usb_driver() - Helper macro for registering a USB driver\n * @__usb_driver: usb_driver struct\n *\n * Helper macro for USB drivers which do not do anything special in module\n * init/exit. This eliminates a lot of boilerplate. Each module may only\n * use this macro once, and calling it replaces module_init() and module_exit()\n */\n#define module_usb_driver(__usb_driver) \\\n\tmodule_driver(__usb_driver, usb_register, \\\n\t\t       usb_deregister)\n\nextern int usb_register_device_driver(struct usb_device_driver *,\n\t\t\tstruct module *);\nextern void usb_deregister_device_driver(struct usb_device_driver *);\n\nextern int usb_register_dev(struct usb_interface *intf,\n\t\t\t    struct usb_class_driver *class_driver);\nextern void usb_deregister_dev(struct usb_interface *intf,\n\t\t\t       struct usb_class_driver *class_driver);\n\nextern int usb_disabled(void);\n\n/* ----------------------------------------------------------------------- */\n\n/*\n * URB support, for asynchronous request completions\n */\n\n/*\n * urb->transfer_flags:\n *\n * Note: URB_DIR_IN/OUT is automatically set in usb_submit_urb().\n */\n#define URB_SHORT_NOT_OK\t0x0001\t/* report short reads as errors */\n#define URB_ISO_ASAP\t\t0x0002\t/* iso-only; use the first unexpired\n\t\t\t\t\t * slot in the schedule */\n#define URB_NO_TRANSFER_DMA_MAP\t0x0004\t/* urb->transfer_dma valid on submit */\n#define URB_ZERO_PACKET\t\t0x0040\t/* Finish bulk OUT with short packet */\n#define URB_NO_INTERRUPT\t0x0080\t/* HINT: no non-error interrupt\n\t\t\t\t\t * needed */\n#define URB_FREE_BUFFER\t\t0x0100\t/* Free transfer buffer with the URB */\n\n/* The following flags are used internally by usbcore and HCDs */\n#define URB_DIR_IN\t\t0x0200\t/* Transfer from device to host */\n#define URB_DIR_OUT\t\t0\n#define URB_DIR_MASK\t\tURB_DIR_IN\n\n#define URB_DMA_MAP_SINGLE\t0x00010000\t/* Non-scatter-gather mapping */\n#define URB_DMA_MAP_PAGE\t0x00020000\t/* HCD-unsupported S-G */\n#define URB_DMA_MAP_SG\t\t0x00040000\t/* HCD-supported S-G */\n#define URB_MAP_LOCAL\t\t0x00080000\t/* HCD-local-memory mapping */\n#define URB_SETUP_MAP_SINGLE\t0x00100000\t/* Setup packet DMA mapped */\n#define URB_SETUP_MAP_LOCAL\t0x00200000\t/* HCD-local setup packet */\n#define URB_DMA_SG_COMBINED\t0x00400000\t/* S-G entries were combined */\n#define URB_ALIGNED_TEMP_BUFFER\t0x00800000\t/* Temp buffer was alloc'd */\n\nstruct usb_iso_packet_descriptor {\n\tunsigned int offset;\n\tunsigned int length;\t\t/* expected length */\n\tunsigned int actual_length;\n\tint status;\n};\n\nstruct urb;\n\nstruct usb_anchor {\n\tstruct list_head urb_list;\n\twait_queue_head_t wait;\n\tspinlock_t lock;\n\tatomic_t suspend_wakeups;\n\tunsigned int poisoned:1;\n};\n\nstatic inline void init_usb_anchor(struct usb_anchor *anchor)\n{\n\tmemset(anchor, 0, sizeof(*anchor));\n\tINIT_LIST_HEAD(&anchor->urb_list);\n\tinit_waitqueue_head(&anchor->wait);\n\tspin_lock_init(&anchor->lock);\n}\n\ntypedef void (*usb_complete_t)(struct urb *);\n\n/**\n * struct urb - USB Request Block\n * @urb_list: For use by current owner of the URB.\n * @anchor_list: membership in the list of an anchor\n * @anchor: to anchor URBs to a common mooring\n * @ep: Points to the endpoint's data structure.  Will eventually\n *\treplace @pipe.\n * @pipe: Holds endpoint number, direction, type, and more.\n *\tCreate these values with the eight macros available;\n *\tusb_{snd,rcv}TYPEpipe(dev,endpoint), where the TYPE is \"ctrl\"\n *\t(control), \"bulk\", \"int\" (interrupt), or \"iso\" (isochronous).\n *\tFor example usb_sndbulkpipe() or usb_rcvintpipe().  Endpoint\n *\tnumbers range from zero to fifteen.  Note that \"in\" endpoint two\n *\tis a different endpoint (and pipe) from \"out\" endpoint two.\n *\tThe current configuration controls the existence, type, and\n *\tmaximum packet size of any given endpoint.\n * @stream_id: the endpoint's stream ID for bulk streams\n * @dev: Identifies the USB device to perform the request.\n * @status: This is read in non-iso completion functions to get the\n *\tstatus of the particular request.  ISO requests only use it\n *\tto tell whether the URB was unlinked; detailed status for\n *\teach frame is in the fields of the iso_frame-desc.\n * @transfer_flags: A variety of flags may be used to affect how URB\n *\tsubmission, unlinking, or operation are handled.  Different\n *\tkinds of URB can use different flags.\n * @transfer_buffer:  This identifies the buffer to (or from) which the I/O\n *\trequest will be performed unless URB_NO_TRANSFER_DMA_MAP is set\n *\t(however, do not leave garbage in transfer_buffer even then).\n *\tThis buffer must be suitable for DMA; allocate it with\n *\tkmalloc() or equivalent.  For transfers to \"in\" endpoints, contents\n *\tof this buffer will be modified.  This buffer is used for the data\n *\tstage of control transfers.\n * @transfer_dma: When transfer_flags includes URB_NO_TRANSFER_DMA_MAP,\n *\tthe device driver is saying that it provided this DMA address,\n *\twhich the host controller driver should use in preference to the\n *\ttransfer_buffer.\n * @sg: scatter gather buffer list, the buffer size of each element in\n * \tthe list (except the last) must be divisible by the endpoint's\n * \tmax packet size if no_sg_constraint isn't set in 'struct usb_bus'\n * @num_mapped_sgs: (internal) number of mapped sg entries\n * @num_sgs: number of entries in the sg list\n * @transfer_buffer_length: How big is transfer_buffer.  The transfer may\n *\tbe broken up into chunks according to the current maximum packet\n *\tsize for the endpoint, which is a function of the configuration\n *\tand is encoded in the pipe.  When the length is zero, neither\n *\ttransfer_buffer nor transfer_dma is used.\n * @actual_length: This is read in non-iso completion functions, and\n *\tit tells how many bytes (out of transfer_buffer_length) were\n *\ttransferred.  It will normally be the same as requested, unless\n *\teither an error was reported or a short read was performed.\n *\tThe URB_SHORT_NOT_OK transfer flag may be used to make such\n *\tshort reads be reported as errors.\n * @setup_packet: Only used for control transfers, this points to eight bytes\n *\tof setup data.  Control transfers always start by sending this data\n *\tto the device.  Then transfer_buffer is read or written, if needed.\n * @setup_dma: DMA pointer for the setup packet.  The caller must not use\n *\tthis field; setup_packet must point to a valid buffer.\n * @start_frame: Returns the initial frame for isochronous transfers.\n * @number_of_packets: Lists the number of ISO transfer buffers.\n * @interval: Specifies the polling interval for interrupt or isochronous\n *\ttransfers.  The units are frames (milliseconds) for full and low\n *\tspeed devices, and microframes (1/8 millisecond) for highspeed\n *\tand SuperSpeed devices.\n * @error_count: Returns the number of ISO transfers that reported errors.\n * @context: For use in completion functions.  This normally points to\n *\trequest-specific driver context.\n * @complete: Completion handler. This URB is passed as the parameter to the\n *\tcompletion function.  The completion function may then do what\n *\tit likes with the URB, including resubmitting or freeing it.\n * @iso_frame_desc: Used to provide arrays of ISO transfer buffers and to\n *\tcollect the transfer status for each buffer.\n *\n * This structure identifies USB transfer requests.  URBs must be allocated by\n * calling usb_alloc_urb() and freed with a call to usb_free_urb().\n * Initialization may be done using various usb_fill_*_urb() functions.  URBs\n * are submitted using usb_submit_urb(), and pending requests may be canceled\n * using usb_unlink_urb() or usb_kill_urb().\n *\n * Data Transfer Buffers:\n *\n * Normally drivers provide I/O buffers allocated with kmalloc() or otherwise\n * taken from the general page pool.  That is provided by transfer_buffer\n * (control requests also use setup_packet), and host controller drivers\n * perform a dma mapping (and unmapping) for each buffer transferred.  Those\n * mapping operations can be expensive on some platforms (perhaps using a dma\n * bounce buffer or talking to an IOMMU),\n * although they're cheap on commodity x86 and ppc hardware.\n *\n * Alternatively, drivers may pass the URB_NO_TRANSFER_DMA_MAP transfer flag,\n * which tells the host controller driver that no such mapping is needed for\n * the transfer_buffer since\n * the device driver is DMA-aware.  For example, a device driver might\n * allocate a DMA buffer with usb_alloc_coherent() or call usb_buffer_map().\n * When this transfer flag is provided, host controller drivers will\n * attempt to use the dma address found in the transfer_dma\n * field rather than determining a dma address themselves.\n *\n * Note that transfer_buffer must still be set if the controller\n * does not support DMA (as indicated by hcd_uses_dma()) and when talking\n * to root hub. If you have to trasfer between highmem zone and the device\n * on such controller, create a bounce buffer or bail out with an error.\n * If transfer_buffer cannot be set (is in highmem) and the controller is DMA\n * capable, assign NULL to it, so that usbmon knows not to use the value.\n * The setup_packet must always be set, so it cannot be located in highmem.\n *\n * Initialization:\n *\n * All URBs submitted must initialize the dev, pipe, transfer_flags (may be\n * zero), and complete fields.  All URBs must also initialize\n * transfer_buffer and transfer_buffer_length.  They may provide the\n * URB_SHORT_NOT_OK transfer flag, indicating that short reads are\n * to be treated as errors; that flag is invalid for write requests.\n *\n * Bulk URBs may\n * use the URB_ZERO_PACKET transfer flag, indicating that bulk OUT transfers\n * should always terminate with a short packet, even if it means adding an\n * extra zero length packet.\n *\n * Control URBs must provide a valid pointer in the setup_packet field.\n * Unlike the transfer_buffer, the setup_packet may not be mapped for DMA\n * beforehand.\n *\n * Interrupt URBs must provide an interval, saying how often (in milliseconds\n * or, for highspeed devices, 125 microsecond units)\n * to poll for transfers.  After the URB has been submitted, the interval\n * field reflects how the transfer was actually scheduled.\n * The polling interval may be more frequent than requested.\n * For example, some controllers have a maximum interval of 32 milliseconds,\n * while others support intervals of up to 1024 milliseconds.\n * Isochronous URBs also have transfer intervals.  (Note that for isochronous\n * endpoints, as well as high speed interrupt endpoints, the encoding of\n * the transfer interval in the endpoint descriptor is logarithmic.\n * Device drivers must convert that value to linear units themselves.)\n *\n * If an isochronous endpoint queue isn't already running, the host\n * controller will schedule a new URB to start as soon as bandwidth\n * utilization allows.  If the queue is running then a new URB will be\n * scheduled to start in the first transfer slot following the end of the\n * preceding URB, if that slot has not already expired.  If the slot has\n * expired (which can happen when IRQ delivery is delayed for a long time),\n * the scheduling behavior depends on the URB_ISO_ASAP flag.  If the flag\n * is clear then the URB will be scheduled to start in the expired slot,\n * implying that some of its packets will not be transferred; if the flag\n * is set then the URB will be scheduled in the first unexpired slot,\n * breaking the queue's synchronization.  Upon URB completion, the\n * start_frame field will be set to the (micro)frame number in which the\n * transfer was scheduled.  Ranges for frame counter values are HC-specific\n * and can go from as low as 256 to as high as 65536 frames.\n *\n * Isochronous URBs have a different data transfer model, in part because\n * the quality of service is only \"best effort\".  Callers provide specially\n * allocated URBs, with number_of_packets worth of iso_frame_desc structures\n * at the end.  Each such packet is an individual ISO transfer.  Isochronous\n * URBs are normally queued, submitted by drivers to arrange that\n * transfers are at least double buffered, and then explicitly resubmitted\n * in completion handlers, so\n * that data (such as audio or video) streams at as constant a rate as the\n * host controller scheduler can support.\n *\n * Completion Callbacks:\n *\n * The completion callback is made in_interrupt(), and one of the first\n * things that a completion handler should do is check the status field.\n * The status field is provided for all URBs.  It is used to report\n * unlinked URBs, and status for all non-ISO transfers.  It should not\n * be examined before the URB is returned to the completion handler.\n *\n * The context field is normally used to link URBs back to the relevant\n * driver or request state.\n *\n * When the completion callback is invoked for non-isochronous URBs, the\n * actual_length field tells how many bytes were transferred.  This field\n * is updated even when the URB terminated with an error or was unlinked.\n *\n * ISO transfer status is reported in the status and actual_length fields\n * of the iso_frame_desc array, and the number of errors is reported in\n * error_count.  Completion callbacks for ISO transfers will normally\n * (re)submit URBs to ensure a constant transfer rate.\n *\n * Note that even fields marked \"public\" should not be touched by the driver\n * when the urb is owned by the hcd, that is, since the call to\n * usb_submit_urb() till the entry into the completion routine.\n */\nstruct urb {\n\t/* private: usb core and host controller only fields in the urb */\n\tstruct kref kref;\t\t/* reference count of the URB */\n\tint unlinked;\t\t\t/* unlink error code */\n\tvoid *hcpriv;\t\t\t/* private data for host controller */\n\tatomic_t use_count;\t\t/* concurrent submissions counter */\n\tatomic_t reject;\t\t/* submissions will fail */\n\n\t/* public: documented fields in the urb that can be used by drivers */\n\tstruct list_head urb_list;\t/* list head for use by the urb's\n\t\t\t\t\t * current owner */\n\tstruct list_head anchor_list;\t/* the URB may be anchored */\n\tstruct usb_anchor *anchor;\n\tstruct usb_device *dev;\t\t/* (in) pointer to associated device */\n\tstruct usb_host_endpoint *ep;\t/* (internal) pointer to endpoint */\n\tunsigned int pipe;\t\t/* (in) pipe information */\n\tunsigned int stream_id;\t\t/* (in) stream ID */\n\tint status;\t\t\t/* (return) non-ISO status */\n\tunsigned int transfer_flags;\t/* (in) URB_SHORT_NOT_OK | ...*/\n\tvoid *transfer_buffer;\t\t/* (in) associated data buffer */\n\tdma_addr_t transfer_dma;\t/* (in) dma addr for transfer_buffer */\n\tstruct scatterlist *sg;\t\t/* (in) scatter gather buffer list */\n\tint num_mapped_sgs;\t\t/* (internal) mapped sg entries */\n\tint num_sgs;\t\t\t/* (in) number of entries in the sg list */\n\tu32 transfer_buffer_length;\t/* (in) data buffer length */\n\tu32 actual_length;\t\t/* (return) actual transfer length */\n\tunsigned char *setup_packet;\t/* (in) setup packet (control only) */\n\tdma_addr_t setup_dma;\t\t/* (in) dma addr for setup_packet */\n\tint start_frame;\t\t/* (modify) start frame (ISO) */\n\tint number_of_packets;\t\t/* (in) number of ISO packets */\n\tint interval;\t\t\t/* (modify) transfer interval\n\t\t\t\t\t * (INT/ISO) */\n\tint error_count;\t\t/* (return) number of ISO errors */\n\tvoid *context;\t\t\t/* (in) context for completion */\n\tusb_complete_t complete;\t/* (in) completion routine */\n\tstruct usb_iso_packet_descriptor iso_frame_desc[];\n\t\t\t\t\t/* (in) ISO ONLY */\n};\n\n/* ----------------------------------------------------------------------- */\n\n/**\n * usb_fill_control_urb - initializes a control urb\n * @urb: pointer to the urb to initialize.\n * @dev: pointer to the struct usb_device for this urb.\n * @pipe: the endpoint pipe\n * @setup_packet: pointer to the setup_packet buffer\n * @transfer_buffer: pointer to the transfer buffer\n * @buffer_length: length of the transfer buffer\n * @complete_fn: pointer to the usb_complete_t function\n * @context: what to set the urb context to.\n *\n * Initializes a control urb with the proper information needed to submit\n * it to a device.\n */\nstatic inline void usb_fill_control_urb(struct urb *urb,\n\t\t\t\t\tstruct usb_device *dev,\n\t\t\t\t\tunsigned int pipe,\n\t\t\t\t\tunsigned char *setup_packet,\n\t\t\t\t\tvoid *transfer_buffer,\n\t\t\t\t\tint buffer_length,\n\t\t\t\t\tusb_complete_t complete_fn,\n\t\t\t\t\tvoid *context)\n{\n\turb->dev = dev;\n\turb->pipe = pipe;\n\turb->setup_packet = setup_packet;\n\turb->transfer_buffer = transfer_buffer;\n\turb->transfer_buffer_length = buffer_length;\n\turb->complete = complete_fn;\n\turb->context = context;\n}\n\n/**\n * usb_fill_bulk_urb - macro to help initialize a bulk urb\n * @urb: pointer to the urb to initialize.\n * @dev: pointer to the struct usb_device for this urb.\n * @pipe: the endpoint pipe\n * @transfer_buffer: pointer to the transfer buffer\n * @buffer_length: length of the transfer buffer\n * @complete_fn: pointer to the usb_complete_t function\n * @context: what to set the urb context to.\n *\n * Initializes a bulk urb with the proper information needed to submit it\n * to a device.\n */\nstatic inline void usb_fill_bulk_urb(struct urb *urb,\n\t\t\t\t     struct usb_device *dev,\n\t\t\t\t     unsigned int pipe,\n\t\t\t\t     void *transfer_buffer,\n\t\t\t\t     int buffer_length,\n\t\t\t\t     usb_complete_t complete_fn,\n\t\t\t\t     void *context)\n{\n\turb->dev = dev;\n\turb->pipe = pipe;\n\turb->transfer_buffer = transfer_buffer;\n\turb->transfer_buffer_length = buffer_length;\n\turb->complete = complete_fn;\n\turb->context = context;\n}\n\n/**\n * usb_fill_int_urb - macro to help initialize a interrupt urb\n * @urb: pointer to the urb to initialize.\n * @dev: pointer to the struct usb_device for this urb.\n * @pipe: the endpoint pipe\n * @transfer_buffer: pointer to the transfer buffer\n * @buffer_length: length of the transfer buffer\n * @complete_fn: pointer to the usb_complete_t function\n * @context: what to set the urb context to.\n * @interval: what to set the urb interval to, encoded like\n *\tthe endpoint descriptor's bInterval value.\n *\n * Initializes a interrupt urb with the proper information needed to submit\n * it to a device.\n *\n * Note that High Speed and SuperSpeed(+) interrupt endpoints use a logarithmic\n * encoding of the endpoint interval, and express polling intervals in\n * microframes (eight per millisecond) rather than in frames (one per\n * millisecond).\n *\n * Wireless USB also uses the logarithmic encoding, but specifies it in units of\n * 128us instead of 125us.  For Wireless USB devices, the interval is passed\n * through to the host controller, rather than being translated into microframe\n * units.\n */\nstatic inline void usb_fill_int_urb(struct urb *urb,\n\t\t\t\t    struct usb_device *dev,\n\t\t\t\t    unsigned int pipe,\n\t\t\t\t    void *transfer_buffer,\n\t\t\t\t    int buffer_length,\n\t\t\t\t    usb_complete_t complete_fn,\n\t\t\t\t    void *context,\n\t\t\t\t    int interval)\n{\n\turb->dev = dev;\n\turb->pipe = pipe;\n\turb->transfer_buffer = transfer_buffer;\n\turb->transfer_buffer_length = buffer_length;\n\turb->complete = complete_fn;\n\turb->context = context;\n\n\tif (dev->speed == USB_SPEED_HIGH || dev->speed >= USB_SPEED_SUPER) {\n\t\t/* make sure interval is within allowed range */\n\t\tinterval = clamp(interval, 1, 16);\n\n\t\turb->interval = 1 << (interval - 1);\n\t} else {\n\t\turb->interval = interval;\n\t}\n\n\turb->start_frame = -1;\n}\n\nextern void usb_init_urb(struct urb *urb);\nextern struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags);\nextern void usb_free_urb(struct urb *urb);\n#define usb_put_urb usb_free_urb\nextern struct urb *usb_get_urb(struct urb *urb);\nextern int usb_submit_urb(struct urb *urb, gfp_t mem_flags);\nextern int usb_unlink_urb(struct urb *urb);\nextern void usb_kill_urb(struct urb *urb);\nextern void usb_poison_urb(struct urb *urb);\nextern void usb_unpoison_urb(struct urb *urb);\nextern void usb_block_urb(struct urb *urb);\nextern void usb_kill_anchored_urbs(struct usb_anchor *anchor);\nextern void usb_poison_anchored_urbs(struct usb_anchor *anchor);\nextern void usb_unpoison_anchored_urbs(struct usb_anchor *anchor);\nextern void usb_unlink_anchored_urbs(struct usb_anchor *anchor);\nextern void usb_anchor_suspend_wakeups(struct usb_anchor *anchor);\nextern void usb_anchor_resume_wakeups(struct usb_anchor *anchor);\nextern void usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor);\nextern void usb_unanchor_urb(struct urb *urb);\nextern int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,\n\t\t\t\t\t unsigned int timeout);\nextern struct urb *usb_get_from_anchor(struct usb_anchor *anchor);\nextern void usb_scuttle_anchored_urbs(struct usb_anchor *anchor);\nextern int usb_anchor_empty(struct usb_anchor *anchor);\n\n#define usb_unblock_urb\tusb_unpoison_urb\n\n/**\n * usb_urb_dir_in - check if an URB describes an IN transfer\n * @urb: URB to be checked\n *\n * Return: 1 if @urb describes an IN transfer (device-to-host),\n * otherwise 0.\n */\nstatic inline int usb_urb_dir_in(struct urb *urb)\n{\n\treturn (urb->transfer_flags & URB_DIR_MASK) == URB_DIR_IN;\n}\n\n/**\n * usb_urb_dir_out - check if an URB describes an OUT transfer\n * @urb: URB to be checked\n *\n * Return: 1 if @urb describes an OUT transfer (host-to-device),\n * otherwise 0.\n */\nstatic inline int usb_urb_dir_out(struct urb *urb)\n{\n\treturn (urb->transfer_flags & URB_DIR_MASK) == URB_DIR_OUT;\n}\n\nint usb_pipe_type_check(struct usb_device *dev, unsigned int pipe);\nint usb_urb_ep_type_check(const struct urb *urb);\n\nvoid *usb_alloc_coherent(struct usb_device *dev, size_t size,\n\tgfp_t mem_flags, dma_addr_t *dma);\nvoid usb_free_coherent(struct usb_device *dev, size_t size,\n\tvoid *addr, dma_addr_t dma);\n\n#if 0\nstruct urb *usb_buffer_map(struct urb *urb);\nvoid usb_buffer_dmasync(struct urb *urb);\nvoid usb_buffer_unmap(struct urb *urb);\n#endif\n\nstruct scatterlist;\nint usb_buffer_map_sg(const struct usb_device *dev, int is_in,\n\t\t      struct scatterlist *sg, int nents);\n#if 0\nvoid usb_buffer_dmasync_sg(const struct usb_device *dev, int is_in,\n\t\t\t   struct scatterlist *sg, int n_hw_ents);\n#endif\nvoid usb_buffer_unmap_sg(const struct usb_device *dev, int is_in,\n\t\t\t struct scatterlist *sg, int n_hw_ents);\n\n/*-------------------------------------------------------------------*\n *                         SYNCHRONOUS CALL SUPPORT                  *\n *-------------------------------------------------------------------*/\n\nextern int usb_control_msg(struct usb_device *dev, unsigned int pipe,\n\t__u8 request, __u8 requesttype, __u16 value, __u16 index,\n\tvoid *data, __u16 size, int timeout);\nextern int usb_interrupt_msg(struct usb_device *usb_dev, unsigned int pipe,\n\tvoid *data, int len, int *actual_length, int timeout);\nextern int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,\n\tvoid *data, int len, int *actual_length,\n\tint timeout);\n\n/* wrappers around usb_control_msg() for the most common standard requests */\nint usb_control_msg_send(struct usb_device *dev, __u8 endpoint, __u8 request,\n\t\t\t __u8 requesttype, __u16 value, __u16 index,\n\t\t\t const void *data, __u16 size, int timeout,\n\t\t\t gfp_t memflags);\nint usb_control_msg_recv(struct usb_device *dev, __u8 endpoint, __u8 request,\n\t\t\t __u8 requesttype, __u16 value, __u16 index,\n\t\t\t void *data, __u16 size, int timeout,\n\t\t\t gfp_t memflags);\nextern int usb_get_descriptor(struct usb_device *dev, unsigned char desctype,\n\tunsigned char descindex, void *buf, int size);\nextern int usb_get_status(struct usb_device *dev,\n\tint recip, int type, int target, void *data);\n\nstatic inline int usb_get_std_status(struct usb_device *dev,\n\tint recip, int target, void *data)\n{\n\treturn usb_get_status(dev, recip, USB_STATUS_TYPE_STANDARD, target,\n\t\tdata);\n}\n\nstatic inline int usb_get_ptm_status(struct usb_device *dev, void *data)\n{\n\treturn usb_get_status(dev, USB_RECIP_DEVICE, USB_STATUS_TYPE_PTM,\n\t\t0, data);\n}\n\nextern int usb_string(struct usb_device *dev, int index,\n\tchar *buf, size_t size);\n\n/* wrappers that also update important state inside usbcore */\nextern int usb_clear_halt(struct usb_device *dev, int pipe);\nextern int usb_reset_configuration(struct usb_device *dev);\nextern int usb_set_interface(struct usb_device *dev, int ifnum, int alternate);\nextern void usb_reset_endpoint(struct usb_device *dev, unsigned int epaddr);\n\n/* this request isn't really synchronous, but it belongs with the others */\nextern int usb_driver_set_configuration(struct usb_device *udev, int config);\n\n/* choose and set configuration for device */\nextern int usb_choose_configuration(struct usb_device *udev);\nextern int usb_set_configuration(struct usb_device *dev, int configuration);\n\n/*\n * timeouts, in milliseconds, used for sending/receiving control messages\n * they typically complete within a few frames (msec) after they're issued\n * USB identifies 5 second timeouts, maybe more in a few cases, and a few\n * slow devices (like some MGE Ellipse UPSes) actually push that limit.\n */\n#define USB_CTRL_GET_TIMEOUT\t5000\n#define USB_CTRL_SET_TIMEOUT\t5000\n\n\n/**\n * struct usb_sg_request - support for scatter/gather I/O\n * @status: zero indicates success, else negative errno\n * @bytes: counts bytes transferred.\n *\n * These requests are initialized using usb_sg_init(), and then are used\n * as request handles passed to usb_sg_wait() or usb_sg_cancel().  Most\n * members of the request object aren't for driver access.\n *\n * The status and bytecount values are valid only after usb_sg_wait()\n * returns.  If the status is zero, then the bytecount matches the total\n * from the request.\n *\n * After an error completion, drivers may need to clear a halt condition\n * on the endpoint.\n */\nstruct usb_sg_request {\n\tint\t\t\tstatus;\n\tsize_t\t\t\tbytes;\n\n\t/* private:\n\t * members below are private to usbcore,\n\t * and are not provided for driver access!\n\t */\n\tspinlock_t\t\tlock;\n\n\tstruct usb_device\t*dev;\n\tint\t\t\tpipe;\n\n\tint\t\t\tentries;\n\tstruct urb\t\t**urbs;\n\n\tint\t\t\tcount;\n\tstruct completion\tcomplete;\n};\n\nint usb_sg_init(\n\tstruct usb_sg_request\t*io,\n\tstruct usb_device\t*dev,\n\tunsigned\t\tpipe,\n\tunsigned\t\tperiod,\n\tstruct scatterlist\t*sg,\n\tint\t\t\tnents,\n\tsize_t\t\t\tlength,\n\tgfp_t\t\t\tmem_flags\n);\nvoid usb_sg_cancel(struct usb_sg_request *io);\nvoid usb_sg_wait(struct usb_sg_request *io);\n\n\n/* ----------------------------------------------------------------------- */\n\n/*\n * For various legacy reasons, Linux has a small cookie that's paired with\n * a struct usb_device to identify an endpoint queue.  Queue characteristics\n * are defined by the endpoint's descriptor.  This cookie is called a \"pipe\",\n * an unsigned int encoded as:\n *\n *  - direction:\tbit 7\t\t(0 = Host-to-Device [Out],\n *\t\t\t\t\t 1 = Device-to-Host [In] ...\n *\t\t\t\t\tlike endpoint bEndpointAddress)\n *  - device address:\tbits 8-14       ... bit positions known to uhci-hcd\n *  - endpoint:\t\tbits 15-18      ... bit positions known to uhci-hcd\n *  - pipe type:\tbits 30-31\t(00 = isochronous, 01 = interrupt,\n *\t\t\t\t\t 10 = control, 11 = bulk)\n *\n * Given the device address and endpoint descriptor, pipes are redundant.\n */\n\n/* NOTE:  these are not the standard USB_ENDPOINT_XFER_* values!! */\n/* (yet ... they're the values used by usbfs) */\n#define PIPE_ISOCHRONOUS\t\t0\n#define PIPE_INTERRUPT\t\t\t1\n#define PIPE_CONTROL\t\t\t2\n#define PIPE_BULK\t\t\t3\n\n#define usb_pipein(pipe)\t((pipe) & USB_DIR_IN)\n#define usb_pipeout(pipe)\t(!usb_pipein(pipe))\n\n#define usb_pipedevice(pipe)\t(((pipe) >> 8) & 0x7f)\n#define usb_pipeendpoint(pipe)\t(((pipe) >> 15) & 0xf)\n\n#define usb_pipetype(pipe)\t(((pipe) >> 30) & 3)\n#define usb_pipeisoc(pipe)\t(usb_pipetype((pipe)) == PIPE_ISOCHRONOUS)\n#define usb_pipeint(pipe)\t(usb_pipetype((pipe)) == PIPE_INTERRUPT)\n#define usb_pipecontrol(pipe)\t(usb_pipetype((pipe)) == PIPE_CONTROL)\n#define usb_pipebulk(pipe)\t(usb_pipetype((pipe)) == PIPE_BULK)\n\nstatic inline unsigned int __create_pipe(struct usb_device *dev,\n\t\tunsigned int endpoint)\n{\n\treturn (dev->devnum << 8) | (endpoint << 15);\n}\n\n/* Create various pipes... */\n#define usb_sndctrlpipe(dev, endpoint)\t\\\n\t((PIPE_CONTROL << 30) | __create_pipe(dev, endpoint))\n#define usb_rcvctrlpipe(dev, endpoint)\t\\\n\t((PIPE_CONTROL << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)\n#define usb_sndisocpipe(dev, endpoint)\t\\\n\t((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev, endpoint))\n#define usb_rcvisocpipe(dev, endpoint)\t\\\n\t((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)\n#define usb_sndbulkpipe(dev, endpoint)\t\\\n\t((PIPE_BULK << 30) | __create_pipe(dev, endpoint))\n#define usb_rcvbulkpipe(dev, endpoint)\t\\\n\t((PIPE_BULK << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)\n#define usb_sndintpipe(dev, endpoint)\t\\\n\t((PIPE_INTERRUPT << 30) | __create_pipe(dev, endpoint))\n#define usb_rcvintpipe(dev, endpoint)\t\\\n\t((PIPE_INTERRUPT << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)\n\nstatic inline struct usb_host_endpoint *\nusb_pipe_endpoint(struct usb_device *dev, unsigned int pipe)\n{\n\tstruct usb_host_endpoint **eps;\n\teps = usb_pipein(pipe) ? dev->ep_in : dev->ep_out;\n\treturn eps[usb_pipeendpoint(pipe)];\n}\n\n/*-------------------------------------------------------------------------*/\n\nstatic inline __u16\nusb_maxpacket(struct usb_device *udev, int pipe, int is_out)\n{\n\tstruct usb_host_endpoint\t*ep;\n\tunsigned\t\t\tepnum = usb_pipeendpoint(pipe);\n\n\tif (is_out) {\n\t\tWARN_ON(usb_pipein(pipe));\n\t\tep = udev->ep_out[epnum];\n\t} else {\n\t\tWARN_ON(usb_pipeout(pipe));\n\t\tep = udev->ep_in[epnum];\n\t}\n\tif (!ep)\n\t\treturn 0;\n\n\t/* NOTE:  only 0x07ff bits are for packet size... */\n\treturn usb_endpoint_maxp(&ep->desc);\n}\n\n/* ----------------------------------------------------------------------- */\n\n/* translate USB error codes to codes user space understands */\nstatic inline int usb_translate_errors(int error_code)\n{\n\tswitch (error_code) {\n\tcase 0:\n\tcase -ENOMEM:\n\tcase -ENODEV:\n\tcase -EOPNOTSUPP:\n\t\treturn error_code;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\n/* Events from the usb core */\n#define USB_DEVICE_ADD\t\t0x0001\n#define USB_DEVICE_REMOVE\t0x0002\n#define USB_BUS_ADD\t\t0x0003\n#define USB_BUS_REMOVE\t\t0x0004\nextern void usb_register_notify(struct notifier_block *nb);\nextern void usb_unregister_notify(struct notifier_block *nb);\n\n/* debugfs stuff */\nextern struct dentry *usb_debug_root;\n\n/* LED triggers */\nenum usb_led_event {\n\tUSB_LED_EVENT_HOST = 0,\n\tUSB_LED_EVENT_GADGET = 1,\n};\n\n#ifdef CONFIG_USB_LED_TRIG\nextern void usb_led_activity(enum usb_led_event ev);\n#else\nstatic inline void usb_led_activity(enum usb_led_event ev) {}\n#endif\n\n#endif  /* __KERNEL__ */\n\n#endif\n"}, "19": {"id": 19, "path": "/src/include/linux/kernel.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_KERNEL_H\n#define _LINUX_KERNEL_H\n\n#include <stdarg.h>\n#include <linux/limits.h>\n#include <linux/linkage.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/bitops.h>\n#include <linux/log2.h>\n#include <linux/math.h>\n#include <linux/minmax.h>\n#include <linux/typecheck.h>\n#include <linux/printk.h>\n#include <linux/build_bug.h>\n\n#include <asm/byteorder.h>\n\n#include <uapi/linux/kernel.h>\n\n#define STACK_MAGIC\t0xdeadbeef\n\n/**\n * REPEAT_BYTE - repeat the value @x multiple times as an unsigned long value\n * @x: value to repeat\n *\n * NOTE: @x is not checked for > 0xff; larger values produce odd results.\n */\n#define REPEAT_BYTE(x)\t((~0ul / 0xff) * (x))\n\n/* @a is a power of 2 value */\n#define ALIGN(x, a)\t\t__ALIGN_KERNEL((x), (a))\n#define ALIGN_DOWN(x, a)\t__ALIGN_KERNEL((x) - ((a) - 1), (a))\n#define __ALIGN_MASK(x, mask)\t__ALIGN_KERNEL_MASK((x), (mask))\n#define PTR_ALIGN(p, a)\t\t((typeof(p))ALIGN((unsigned long)(p), (a)))\n#define PTR_ALIGN_DOWN(p, a)\t((typeof(p))ALIGN_DOWN((unsigned long)(p), (a)))\n#define IS_ALIGNED(x, a)\t\t(((x) & ((typeof(x))(a) - 1)) == 0)\n\n/* generic data direction definitions */\n#define READ\t\t\t0\n#define WRITE\t\t\t1\n\n/**\n * ARRAY_SIZE - get the number of elements in array @arr\n * @arr: array to be sized\n */\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr))\n\n#define u64_to_user_ptr(x) (\t\t\\\n{\t\t\t\t\t\\\n\ttypecheck(u64, (x));\t\t\\\n\t(void __user *)(uintptr_t)(x);\t\\\n}\t\t\t\t\t\\\n)\n\n#define typeof_member(T, m)\ttypeof(((T*)0)->m)\n\n#define _RET_IP_\t\t(unsigned long)__builtin_return_address(0)\n#define _THIS_IP_  ({ __label__ __here; __here: (unsigned long)&&__here; })\n\n/**\n * upper_32_bits - return bits 32-63 of a number\n * @n: the number we're accessing\n *\n * A basic shift-right of a 64- or 32-bit quantity.  Use this to suppress\n * the \"right shift count >= width of type\" warning when that quantity is\n * 32-bits.\n */\n#define upper_32_bits(n) ((u32)(((n) >> 16) >> 16))\n\n/**\n * lower_32_bits - return bits 0-31 of a number\n * @n: the number we're accessing\n */\n#define lower_32_bits(n) ((u32)((n) & 0xffffffff))\n\nstruct completion;\nstruct pt_regs;\nstruct user;\n\n#ifdef CONFIG_PREEMPT_VOLUNTARY\nextern int _cond_resched(void);\n# define might_resched() _cond_resched()\n#else\n# define might_resched() do { } while (0)\n#endif\n\n#ifdef CONFIG_DEBUG_ATOMIC_SLEEP\nextern void ___might_sleep(const char *file, int line, int preempt_offset);\nextern void __might_sleep(const char *file, int line, int preempt_offset);\nextern void __cant_sleep(const char *file, int line, int preempt_offset);\n\n/**\n * might_sleep - annotation for functions that can sleep\n *\n * this macro will print a stack trace if it is executed in an atomic\n * context (spinlock, irq-handler, ...). Additional sections where blocking is\n * not allowed can be annotated with non_block_start() and non_block_end()\n * pairs.\n *\n * This is a useful debugging help to be able to catch problems early and not\n * be bitten later when the calling function happens to sleep when it is not\n * supposed to.\n */\n# define might_sleep() \\\n\tdo { __might_sleep(__FILE__, __LINE__, 0); might_resched(); } while (0)\n/**\n * cant_sleep - annotation for functions that cannot sleep\n *\n * this macro will print a stack trace if it is executed with preemption enabled\n */\n# define cant_sleep() \\\n\tdo { __cant_sleep(__FILE__, __LINE__, 0); } while (0)\n# define sched_annotate_sleep()\t(current->task_state_change = 0)\n/**\n * non_block_start - annotate the start of section where sleeping is prohibited\n *\n * This is on behalf of the oom reaper, specifically when it is calling the mmu\n * notifiers. The problem is that if the notifier were to block on, for example,\n * mutex_lock() and if the process which holds that mutex were to perform a\n * sleeping memory allocation, the oom reaper is now blocked on completion of\n * that memory allocation. Other blocking calls like wait_event() pose similar\n * issues.\n */\n# define non_block_start() (current->non_block_count++)\n/**\n * non_block_end - annotate the end of section where sleeping is prohibited\n *\n * Closes a section opened by non_block_start().\n */\n# define non_block_end() WARN_ON(current->non_block_count-- == 0)\n#else\n  static inline void ___might_sleep(const char *file, int line,\n\t\t\t\t   int preempt_offset) { }\n  static inline void __might_sleep(const char *file, int line,\n\t\t\t\t   int preempt_offset) { }\n# define might_sleep() do { might_resched(); } while (0)\n# define cant_sleep() do { } while (0)\n# define sched_annotate_sleep() do { } while (0)\n# define non_block_start() do { } while (0)\n# define non_block_end() do { } while (0)\n#endif\n\n#define might_sleep_if(cond) do { if (cond) might_sleep(); } while (0)\n\n#ifndef CONFIG_PREEMPT_RT\n# define cant_migrate()\t\tcant_sleep()\n#else\n  /* Placeholder for now */\n# define cant_migrate()\t\tdo { } while (0)\n#endif\n\n#if defined(CONFIG_MMU) && \\\n\t(defined(CONFIG_PROVE_LOCKING) || defined(CONFIG_DEBUG_ATOMIC_SLEEP))\n#define might_fault() __might_fault(__FILE__, __LINE__)\nvoid __might_fault(const char *file, int line);\n#else\nstatic inline void might_fault(void) { }\n#endif\n\nextern struct atomic_notifier_head panic_notifier_list;\nextern long (*panic_blink)(int state);\n__printf(1, 2)\nvoid panic(const char *fmt, ...) __noreturn __cold;\nvoid nmi_panic(struct pt_regs *regs, const char *msg);\nextern void oops_enter(void);\nextern void oops_exit(void);\nextern bool oops_may_print(void);\nvoid do_exit(long error_code) __noreturn;\nvoid complete_and_exit(struct completion *, long) __noreturn;\n\n/* Internal, do not use. */\nint __must_check _kstrtoul(const char *s, unsigned int base, unsigned long *res);\nint __must_check _kstrtol(const char *s, unsigned int base, long *res);\n\nint __must_check kstrtoull(const char *s, unsigned int base, unsigned long long *res);\nint __must_check kstrtoll(const char *s, unsigned int base, long long *res);\n\n/**\n * kstrtoul - convert a string to an unsigned long\n * @s: The start of the string. The string must be null-terminated, and may also\n *  include a single newline before its terminating null. The first character\n *  may also be a plus sign, but not a minus sign.\n * @base: The number base to use. The maximum supported base is 16. If base is\n *  given as 0, then the base of the string is automatically detected with the\n *  conventional semantics - If it begins with 0x the number will be parsed as a\n *  hexadecimal (case insensitive), if it otherwise begins with 0, it will be\n *  parsed as an octal number. Otherwise it will be parsed as a decimal.\n * @res: Where to write the result of the conversion on success.\n *\n * Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.\n * Preferred over simple_strtoul(). Return code must be checked.\n*/\nstatic inline int __must_check kstrtoul(const char *s, unsigned int base, unsigned long *res)\n{\n\t/*\n\t * We want to shortcut function call, but\n\t * __builtin_types_compatible_p(unsigned long, unsigned long long) = 0.\n\t */\n\tif (sizeof(unsigned long) == sizeof(unsigned long long) &&\n\t    __alignof__(unsigned long) == __alignof__(unsigned long long))\n\t\treturn kstrtoull(s, base, (unsigned long long *)res);\n\telse\n\t\treturn _kstrtoul(s, base, res);\n}\n\n/**\n * kstrtol - convert a string to a long\n * @s: The start of the string. The string must be null-terminated, and may also\n *  include a single newline before its terminating null. The first character\n *  may also be a plus sign or a minus sign.\n * @base: The number base to use. The maximum supported base is 16. If base is\n *  given as 0, then the base of the string is automatically detected with the\n *  conventional semantics - If it begins with 0x the number will be parsed as a\n *  hexadecimal (case insensitive), if it otherwise begins with 0, it will be\n *  parsed as an octal number. Otherwise it will be parsed as a decimal.\n * @res: Where to write the result of the conversion on success.\n *\n * Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.\n * Preferred over simple_strtol(). Return code must be checked.\n */\nstatic inline int __must_check kstrtol(const char *s, unsigned int base, long *res)\n{\n\t/*\n\t * We want to shortcut function call, but\n\t * __builtin_types_compatible_p(long, long long) = 0.\n\t */\n\tif (sizeof(long) == sizeof(long long) &&\n\t    __alignof__(long) == __alignof__(long long))\n\t\treturn kstrtoll(s, base, (long long *)res);\n\telse\n\t\treturn _kstrtol(s, base, res);\n}\n\nint __must_check kstrtouint(const char *s, unsigned int base, unsigned int *res);\nint __must_check kstrtoint(const char *s, unsigned int base, int *res);\n\nstatic inline int __must_check kstrtou64(const char *s, unsigned int base, u64 *res)\n{\n\treturn kstrtoull(s, base, res);\n}\n\nstatic inline int __must_check kstrtos64(const char *s, unsigned int base, s64 *res)\n{\n\treturn kstrtoll(s, base, res);\n}\n\nstatic inline int __must_check kstrtou32(const char *s, unsigned int base, u32 *res)\n{\n\treturn kstrtouint(s, base, res);\n}\n\nstatic inline int __must_check kstrtos32(const char *s, unsigned int base, s32 *res)\n{\n\treturn kstrtoint(s, base, res);\n}\n\nint __must_check kstrtou16(const char *s, unsigned int base, u16 *res);\nint __must_check kstrtos16(const char *s, unsigned int base, s16 *res);\nint __must_check kstrtou8(const char *s, unsigned int base, u8 *res);\nint __must_check kstrtos8(const char *s, unsigned int base, s8 *res);\nint __must_check kstrtobool(const char *s, bool *res);\n\nint __must_check kstrtoull_from_user(const char __user *s, size_t count, unsigned int base, unsigned long long *res);\nint __must_check kstrtoll_from_user(const char __user *s, size_t count, unsigned int base, long long *res);\nint __must_check kstrtoul_from_user(const char __user *s, size_t count, unsigned int base, unsigned long *res);\nint __must_check kstrtol_from_user(const char __user *s, size_t count, unsigned int base, long *res);\nint __must_check kstrtouint_from_user(const char __user *s, size_t count, unsigned int base, unsigned int *res);\nint __must_check kstrtoint_from_user(const char __user *s, size_t count, unsigned int base, int *res);\nint __must_check kstrtou16_from_user(const char __user *s, size_t count, unsigned int base, u16 *res);\nint __must_check kstrtos16_from_user(const char __user *s, size_t count, unsigned int base, s16 *res);\nint __must_check kstrtou8_from_user(const char __user *s, size_t count, unsigned int base, u8 *res);\nint __must_check kstrtos8_from_user(const char __user *s, size_t count, unsigned int base, s8 *res);\nint __must_check kstrtobool_from_user(const char __user *s, size_t count, bool *res);\n\nstatic inline int __must_check kstrtou64_from_user(const char __user *s, size_t count, unsigned int base, u64 *res)\n{\n\treturn kstrtoull_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtos64_from_user(const char __user *s, size_t count, unsigned int base, s64 *res)\n{\n\treturn kstrtoll_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtou32_from_user(const char __user *s, size_t count, unsigned int base, u32 *res)\n{\n\treturn kstrtouint_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtos32_from_user(const char __user *s, size_t count, unsigned int base, s32 *res)\n{\n\treturn kstrtoint_from_user(s, count, base, res);\n}\n\n/*\n * Use kstrto<foo> instead.\n *\n * NOTE: simple_strto<foo> does not check for the range overflow and,\n *\t depending on the input, may give interesting results.\n *\n * Use these functions if and only if you cannot use kstrto<foo>, because\n * the conversion ends on the first non-digit character, which may be far\n * beyond the supported range. It might be useful to parse the strings like\n * 10x50 or 12:21 without altering original string or temporary buffer in use.\n * Keep in mind above caveat.\n */\n\nextern unsigned long simple_strtoul(const char *,char **,unsigned int);\nextern long simple_strtol(const char *,char **,unsigned int);\nextern unsigned long long simple_strtoull(const char *,char **,unsigned int);\nextern long long simple_strtoll(const char *,char **,unsigned int);\n\nextern int num_to_str(char *buf, int size,\n\t\t      unsigned long long num, unsigned int width);\n\n/* lib/printf utilities */\n\nextern __printf(2, 3) int sprintf(char *buf, const char * fmt, ...);\nextern __printf(2, 0) int vsprintf(char *buf, const char *, va_list);\nextern __printf(3, 4)\nint snprintf(char *buf, size_t size, const char *fmt, ...);\nextern __printf(3, 0)\nint vsnprintf(char *buf, size_t size, const char *fmt, va_list args);\nextern __printf(3, 4)\nint scnprintf(char *buf, size_t size, const char *fmt, ...);\nextern __printf(3, 0)\nint vscnprintf(char *buf, size_t size, const char *fmt, va_list args);\nextern __printf(2, 3) __malloc\nchar *kasprintf(gfp_t gfp, const char *fmt, ...);\nextern __printf(2, 0) __malloc\nchar *kvasprintf(gfp_t gfp, const char *fmt, va_list args);\nextern __printf(2, 0)\nconst char *kvasprintf_const(gfp_t gfp, const char *fmt, va_list args);\n\nextern __scanf(2, 3)\nint sscanf(const char *, const char *, ...);\nextern __scanf(2, 0)\nint vsscanf(const char *, const char *, va_list);\n\nextern int get_option(char **str, int *pint);\nextern char *get_options(const char *str, int nints, int *ints);\nextern unsigned long long memparse(const char *ptr, char **retptr);\nextern bool parse_option_str(const char *str, const char *option);\nextern char *next_arg(char *args, char **param, char **val);\n\nextern int core_kernel_text(unsigned long addr);\nextern int init_kernel_text(unsigned long addr);\nextern int core_kernel_data(unsigned long addr);\nextern int __kernel_text_address(unsigned long addr);\nextern int kernel_text_address(unsigned long addr);\nextern int func_ptr_is_kernel_text(void *ptr);\n\n#ifdef CONFIG_SMP\nextern unsigned int sysctl_oops_all_cpu_backtrace;\n#else\n#define sysctl_oops_all_cpu_backtrace 0\n#endif /* CONFIG_SMP */\n\nextern void bust_spinlocks(int yes);\nextern int panic_timeout;\nextern unsigned long panic_print;\nextern int panic_on_oops;\nextern int panic_on_unrecovered_nmi;\nextern int panic_on_io_nmi;\nextern int panic_on_warn;\nextern unsigned long panic_on_taint;\nextern bool panic_on_taint_nousertaint;\nextern int sysctl_panic_on_rcu_stall;\nextern int sysctl_max_rcu_stall_to_panic;\nextern int sysctl_panic_on_stackoverflow;\n\nextern bool crash_kexec_post_notifiers;\n\n/*\n * panic_cpu is used for synchronizing panic() and crash_kexec() execution. It\n * holds a CPU number which is executing panic() currently. A value of\n * PANIC_CPU_INVALID means no CPU has entered panic() or crash_kexec().\n */\nextern atomic_t panic_cpu;\n#define PANIC_CPU_INVALID\t-1\n\n/*\n * Only to be used by arch init code. If the user over-wrote the default\n * CONFIG_PANIC_TIMEOUT, honor it.\n */\nstatic inline void set_arch_panic_timeout(int timeout, int arch_default_timeout)\n{\n\tif (panic_timeout == arch_default_timeout)\n\t\tpanic_timeout = timeout;\n}\nextern const char *print_tainted(void);\nenum lockdep_ok {\n\tLOCKDEP_STILL_OK,\n\tLOCKDEP_NOW_UNRELIABLE\n};\nextern void add_taint(unsigned flag, enum lockdep_ok);\nextern int test_taint(unsigned flag);\nextern unsigned long get_taint(void);\nextern int root_mountflags;\n\nextern bool early_boot_irqs_disabled;\n\n/*\n * Values used for system_state. Ordering of the states must not be changed\n * as code checks for <, <=, >, >= STATE.\n */\nextern enum system_states {\n\tSYSTEM_BOOTING,\n\tSYSTEM_SCHEDULING,\n\tSYSTEM_RUNNING,\n\tSYSTEM_HALT,\n\tSYSTEM_POWER_OFF,\n\tSYSTEM_RESTART,\n\tSYSTEM_SUSPEND,\n} system_state;\n\n/* This cannot be an enum because some may be used in assembly source. */\n#define TAINT_PROPRIETARY_MODULE\t0\n#define TAINT_FORCED_MODULE\t\t1\n#define TAINT_CPU_OUT_OF_SPEC\t\t2\n#define TAINT_FORCED_RMMOD\t\t3\n#define TAINT_MACHINE_CHECK\t\t4\n#define TAINT_BAD_PAGE\t\t\t5\n#define TAINT_USER\t\t\t6\n#define TAINT_DIE\t\t\t7\n#define TAINT_OVERRIDDEN_ACPI_TABLE\t8\n#define TAINT_WARN\t\t\t9\n#define TAINT_CRAP\t\t\t10\n#define TAINT_FIRMWARE_WORKAROUND\t11\n#define TAINT_OOT_MODULE\t\t12\n#define TAINT_UNSIGNED_MODULE\t\t13\n#define TAINT_SOFTLOCKUP\t\t14\n#define TAINT_LIVEPATCH\t\t\t15\n#define TAINT_AUX\t\t\t16\n#define TAINT_RANDSTRUCT\t\t17\n#define TAINT_FLAGS_COUNT\t\t18\n#define TAINT_FLAGS_MAX\t\t\t((1UL << TAINT_FLAGS_COUNT) - 1)\n\nstruct taint_flag {\n\tchar c_true;\t/* character printed when tainted */\n\tchar c_false;\t/* character printed when not tainted */\n\tbool module;\t/* also show as a per-module taint flag */\n};\n\nextern const struct taint_flag taint_flags[TAINT_FLAGS_COUNT];\n\nextern const char hex_asc[];\n#define hex_asc_lo(x)\thex_asc[((x) & 0x0f)]\n#define hex_asc_hi(x)\thex_asc[((x) & 0xf0) >> 4]\n\nstatic inline char *hex_byte_pack(char *buf, u8 byte)\n{\n\t*buf++ = hex_asc_hi(byte);\n\t*buf++ = hex_asc_lo(byte);\n\treturn buf;\n}\n\nextern const char hex_asc_upper[];\n#define hex_asc_upper_lo(x)\thex_asc_upper[((x) & 0x0f)]\n#define hex_asc_upper_hi(x)\thex_asc_upper[((x) & 0xf0) >> 4]\n\nstatic inline char *hex_byte_pack_upper(char *buf, u8 byte)\n{\n\t*buf++ = hex_asc_upper_hi(byte);\n\t*buf++ = hex_asc_upper_lo(byte);\n\treturn buf;\n}\n\nextern int hex_to_bin(char ch);\nextern int __must_check hex2bin(u8 *dst, const char *src, size_t count);\nextern char *bin2hex(char *dst, const void *src, size_t count);\n\nbool mac_pton(const char *s, u8 *mac);\n\n/*\n * General tracing related utility functions - trace_printk(),\n * tracing_on/tracing_off and tracing_start()/tracing_stop\n *\n * Use tracing_on/tracing_off when you want to quickly turn on or off\n * tracing. It simply enables or disables the recording of the trace events.\n * This also corresponds to the user space /sys/kernel/debug/tracing/tracing_on\n * file, which gives a means for the kernel and userspace to interact.\n * Place a tracing_off() in the kernel where you want tracing to end.\n * From user space, examine the trace, and then echo 1 > tracing_on\n * to continue tracing.\n *\n * tracing_stop/tracing_start has slightly more overhead. It is used\n * by things like suspend to ram where disabling the recording of the\n * trace is not enough, but tracing must actually stop because things\n * like calling smp_processor_id() may crash the system.\n *\n * Most likely, you want to use tracing_on/tracing_off.\n */\n\nenum ftrace_dump_mode {\n\tDUMP_NONE,\n\tDUMP_ALL,\n\tDUMP_ORIG,\n};\n\n#ifdef CONFIG_TRACING\nvoid tracing_on(void);\nvoid tracing_off(void);\nint tracing_is_on(void);\nvoid tracing_snapshot(void);\nvoid tracing_snapshot_alloc(void);\n\nextern void tracing_start(void);\nextern void tracing_stop(void);\n\nstatic inline __printf(1, 2)\nvoid ____trace_printk_check_format(const char *fmt, ...)\n{\n}\n#define __trace_printk_check_format(fmt, args...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\t\\\n\t\t____trace_printk_check_format(fmt, ##args);\t\t\\\n} while (0)\n\n/**\n * trace_printk - printf formatting in the ftrace buffer\n * @fmt: the printf format for printing\n *\n * Note: __trace_printk is an internal function for trace_printk() and\n *       the @ip is passed in via the trace_printk() macro.\n *\n * This function allows a kernel developer to debug fast path sections\n * that printk is not appropriate for. By scattering in various\n * printk like tracing in the code, a developer can quickly see\n * where problems are occurring.\n *\n * This is intended as a debugging tool for the developer only.\n * Please refrain from leaving trace_printks scattered around in\n * your code. (Extra memory is used for special buffers that are\n * allocated when trace_printk() is used.)\n *\n * A little optimization trick is done here. If there's only one\n * argument, there's no need to scan the string for printf formats.\n * The trace_puts() will suffice. But how can we take advantage of\n * using trace_puts() when trace_printk() has only one argument?\n * By stringifying the args and checking the size we can tell\n * whether or not there are args. __stringify((__VA_ARGS__)) will\n * turn into \"()\\0\" with a size of 3 when there are no args, anything\n * else will be bigger. All we need to do is define a string to this,\n * and then take its size and compare to 3. If it's bigger, use\n * do_trace_printk() otherwise, optimize it to trace_puts(). Then just\n * let gcc optimize the rest.\n */\n\n#define trace_printk(fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tchar _______STR[] = __stringify((__VA_ARGS__));\t\\\n\tif (sizeof(_______STR) > 3)\t\t\t\\\n\t\tdo_trace_printk(fmt, ##__VA_ARGS__);\t\\\n\telse\t\t\t\t\t\t\\\n\t\ttrace_puts(fmt);\t\t\t\\\n} while (0)\n\n#define do_trace_printk(fmt, args...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tstatic const char *trace_printk_fmt __used\t\t\t\\\n\t\t__section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t__builtin_constant_p(fmt) ? fmt : NULL;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__trace_printk_check_format(fmt, ##args);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(fmt))\t\t\t\t\t\\\n\t\t__trace_bprintk(_THIS_IP_, trace_printk_fmt, ##args);\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__trace_printk(_THIS_IP_, fmt, ##args);\t\t\t\\\n} while (0)\n\nextern __printf(2, 3)\nint __trace_bprintk(unsigned long ip, const char *fmt, ...);\n\nextern __printf(2, 3)\nint __trace_printk(unsigned long ip, const char *fmt, ...);\n\n/**\n * trace_puts - write a string into the ftrace buffer\n * @str: the string to record\n *\n * Note: __trace_bputs is an internal function for trace_puts and\n *       the @ip is passed in via the trace_puts macro.\n *\n * This is similar to trace_printk() but is made for those really fast\n * paths that a developer wants the least amount of \"Heisenbug\" effects,\n * where the processing of the print format is still too much.\n *\n * This function allows a kernel developer to debug fast path sections\n * that printk is not appropriate for. By scattering in various\n * printk like tracing in the code, a developer can quickly see\n * where problems are occurring.\n *\n * This is intended as a debugging tool for the developer only.\n * Please refrain from leaving trace_puts scattered around in\n * your code. (Extra memory is used for special buffers that are\n * allocated when trace_puts() is used.)\n *\n * Returns: 0 if nothing was written, positive # if string was.\n *  (1 when __trace_bputs is used, strlen(str) when __trace_puts is used)\n */\n\n#define trace_puts(str) ({\t\t\t\t\t\t\\\n\tstatic const char *trace_printk_fmt __used\t\t\t\\\n\t\t__section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t__builtin_constant_p(str) ? str : NULL;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(str))\t\t\t\t\t\\\n\t\t__trace_bputs(_THIS_IP_, trace_printk_fmt);\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__trace_puts(_THIS_IP_, str, strlen(str));\t\t\\\n})\nextern int __trace_bputs(unsigned long ip, const char *str);\nextern int __trace_puts(unsigned long ip, const char *str, int size);\n\nextern void trace_dump_stack(int skip);\n\n/*\n * The double __builtin_constant_p is because gcc will give us an error\n * if we try to allocate the static variable to fmt if it is not a\n * constant. Even with the outer if statement.\n */\n#define ftrace_vprintk(fmt, vargs)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(fmt)) {\t\t\t\t\\\n\t\tstatic const char *trace_printk_fmt __used\t\t\\\n\t\t  __section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t\t__builtin_constant_p(fmt) ? fmt : NULL;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__ftrace_vbprintk(_THIS_IP_, trace_printk_fmt, vargs);\t\\\n\t} else\t\t\t\t\t\t\t\t\\\n\t\t__ftrace_vprintk(_THIS_IP_, fmt, vargs);\t\t\\\n} while (0)\n\nextern __printf(2, 0) int\n__ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap);\n\nextern __printf(2, 0) int\n__ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap);\n\nextern void ftrace_dump(enum ftrace_dump_mode oops_dump_mode);\n#else\nstatic inline void tracing_start(void) { }\nstatic inline void tracing_stop(void) { }\nstatic inline void trace_dump_stack(int skip) { }\n\nstatic inline void tracing_on(void) { }\nstatic inline void tracing_off(void) { }\nstatic inline int tracing_is_on(void) { return 0; }\nstatic inline void tracing_snapshot(void) { }\nstatic inline void tracing_snapshot_alloc(void) { }\n\nstatic inline __printf(1, 2)\nint trace_printk(const char *fmt, ...)\n{\n\treturn 0;\n}\nstatic __printf(1, 0) inline int\nftrace_vprintk(const char *fmt, va_list ap)\n{\n\treturn 0;\n}\nstatic inline void ftrace_dump(enum ftrace_dump_mode oops_dump_mode) { }\n#endif /* CONFIG_TRACING */\n\n/* This counts to 12. Any more, it will return 13th argument. */\n#define __COUNT_ARGS(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _n, X...) _n\n#define COUNT_ARGS(X...) __COUNT_ARGS(, ##X, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)\n\n#define __CONCAT(a, b) a ## b\n#define CONCATENATE(a, b) __CONCAT(a, b)\n\n/**\n * container_of - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n */\n#define container_of(ptr, type, member) ({\t\t\t\t\\\n\tvoid *__mptr = (void *)(ptr);\t\t\t\t\t\\\n\tBUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&\t\\\n\t\t\t !__same_type(*(ptr), void),\t\t\t\\\n\t\t\t \"pointer type mismatch in container_of()\");\t\\\n\t((type *)(__mptr - offsetof(type, member))); })\n\n/**\n * container_of_safe - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n * If IS_ERR_OR_NULL(ptr), ptr is returned unchanged.\n */\n#define container_of_safe(ptr, type, member) ({\t\t\t\t\\\n\tvoid *__mptr = (void *)(ptr);\t\t\t\t\t\\\n\tBUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&\t\\\n\t\t\t !__same_type(*(ptr), void),\t\t\t\\\n\t\t\t \"pointer type mismatch in container_of()\");\t\\\n\tIS_ERR_OR_NULL(__mptr) ? ERR_CAST(__mptr) :\t\t\t\\\n\t\t((type *)(__mptr - offsetof(type, member))); })\n\n/* Rebuild everything on CONFIG_FTRACE_MCOUNT_RECORD */\n#ifdef CONFIG_FTRACE_MCOUNT_RECORD\n# define REBUILD_DUE_TO_FTRACE_MCOUNT_RECORD\n#endif\n\n/* Permissions on a sysfs file: you didn't miss the 0 prefix did you? */\n#define VERIFY_OCTAL_PERMISSIONS(perms)\t\t\t\t\t\t\\\n\t(BUILD_BUG_ON_ZERO((perms) < 0) +\t\t\t\t\t\\\n\t BUILD_BUG_ON_ZERO((perms) > 0777) +\t\t\t\t\t\\\n\t /* USER_READABLE >= GROUP_READABLE >= OTHER_READABLE */\t\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 6) & 4) < (((perms) >> 3) & 4)) +\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 3) & 4) < ((perms) & 4)) +\t\t\\\n\t /* USER_WRITABLE >= GROUP_WRITABLE */\t\t\t\t\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 6) & 2) < (((perms) >> 3) & 2)) +\t\\\n\t /* OTHER_WRITABLE?  Generally considered a bad idea. */\t\t\\\n\t BUILD_BUG_ON_ZERO((perms) & 2) +\t\t\t\t\t\\\n\t (perms))\n#endif\n"}, "20": {"id": 20, "path": "/src/include/linux/build_bug.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_BUILD_BUG_H\n#define _LINUX_BUILD_BUG_H\n\n#include <linux/compiler.h>\n\n#ifdef __CHECKER__\n#define BUILD_BUG_ON_ZERO(e) (0)\n#else /* __CHECKER__ */\n/*\n * Force a compilation error if condition is true, but also produce a\n * result (of value 0 and type int), so the expression can be used\n * e.g. in a structure initializer (or where-ever else comma expressions\n * aren't permitted).\n */\n#define BUILD_BUG_ON_ZERO(e) ((int)(sizeof(struct { int:(-!!(e)); })))\n#endif /* __CHECKER__ */\n\n/* Force a compilation error if a constant expression is not a power of 2 */\n#define __BUILD_BUG_ON_NOT_POWER_OF_2(n)\t\\\n\tBUILD_BUG_ON(((n) & ((n) - 1)) != 0)\n#define BUILD_BUG_ON_NOT_POWER_OF_2(n)\t\t\t\\\n\tBUILD_BUG_ON((n) == 0 || (((n) & ((n) - 1)) != 0))\n\n/*\n * BUILD_BUG_ON_INVALID() permits the compiler to check the validity of the\n * expression but avoids the generation of any code, even if that expression\n * has side-effects.\n */\n#define BUILD_BUG_ON_INVALID(e) ((void)(sizeof((__force long)(e))))\n\n/**\n * BUILD_BUG_ON_MSG - break compile if a condition is true & emit supplied\n *\t\t      error message.\n * @condition: the condition which the compiler should know is false.\n *\n * See BUILD_BUG_ON for description.\n */\n#define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n\n/**\n * BUILD_BUG_ON - break compile if a condition is true.\n * @condition: the condition which the compiler should know is false.\n *\n * If you have some code which relies on certain constants being equal, or\n * some other compile-time-evaluated condition, you should use BUILD_BUG_ON to\n * detect if someone changes it.\n */\n#define BUILD_BUG_ON(condition) \\\n\tBUILD_BUG_ON_MSG(condition, \"BUILD_BUG_ON failed: \" #condition)\n\n/**\n * BUILD_BUG - break compile if used.\n *\n * If you have some code that you expect the compiler to eliminate at\n * build time, you should use BUILD_BUG to detect if it is\n * unexpectedly used.\n */\n#define BUILD_BUG() BUILD_BUG_ON_MSG(1, \"BUILD_BUG failed\")\n\n/**\n * static_assert - check integer constant expression at build time\n *\n * static_assert() is a wrapper for the C11 _Static_assert, with a\n * little macro magic to make the message optional (defaulting to the\n * stringification of the tested expression).\n *\n * Contrary to BUILD_BUG_ON(), static_assert() can be used at global\n * scope, but requires the expression to be an integer constant\n * expression (i.e., it is not enough that __builtin_constant_p() is\n * true for expr).\n *\n * Also note that BUILD_BUG_ON() fails the build if the condition is\n * true, while static_assert() fails the build if the expression is\n * false.\n */\n#define static_assert(expr, ...) __static_assert(expr, ##__VA_ARGS__, #expr)\n#define __static_assert(expr, msg, ...) _Static_assert(expr, msg)\n\n#endif\t/* _LINUX_BUILD_BUG_H */\n"}, "21": {"id": 21, "path": "/src/include/linux/compiler_types.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_TYPES_H\n#define __LINUX_COMPILER_TYPES_H\n\n#ifndef __ASSEMBLY__\n\n#ifdef __CHECKER__\n/* address spaces */\n# define __kernel\t__attribute__((address_space(0)))\n# define __user\t\t__attribute__((noderef, address_space(__user)))\n# define __iomem\t__attribute__((noderef, address_space(__iomem)))\n# define __percpu\t__attribute__((noderef, address_space(__percpu)))\n# define __rcu\t\t__attribute__((noderef, address_space(__rcu)))\nstatic inline void __chk_user_ptr(const volatile void __user *ptr) { }\nstatic inline void __chk_io_ptr(const volatile void __iomem *ptr) { }\n/* context/locking */\n# define __must_hold(x)\t__attribute__((context(x,1,1)))\n# define __acquires(x)\t__attribute__((context(x,0,1)))\n# define __releases(x)\t__attribute__((context(x,1,0)))\n# define __acquire(x)\t__context__(x,1)\n# define __release(x)\t__context__(x,-1)\n# define __cond_lock(x,c)\t((c) ? ({ __acquire(x); 1; }) : 0)\n/* other */\n# define __force\t__attribute__((force))\n# define __nocast\t__attribute__((nocast))\n# define __safe\t\t__attribute__((safe))\n# define __private\t__attribute__((noderef))\n# define ACCESS_PRIVATE(p, member) (*((typeof((p)->member) __force *) &(p)->member))\n#else /* __CHECKER__ */\n/* address spaces */\n# define __kernel\n# ifdef STRUCTLEAK_PLUGIN\n#  define __user\t__attribute__((user))\n# else\n#  define __user\n# endif\n# define __iomem\n# define __percpu\n# define __rcu\n# define __chk_user_ptr(x)\t(void)0\n# define __chk_io_ptr(x)\t(void)0\n/* context/locking */\n# define __must_hold(x)\n# define __acquires(x)\n# define __releases(x)\n# define __acquire(x)\t(void)0\n# define __release(x)\t(void)0\n# define __cond_lock(x,c) (c)\n/* other */\n# define __force\n# define __nocast\n# define __safe\n# define __private\n# define ACCESS_PRIVATE(p, member) ((p)->member)\n# define __builtin_warning(x, y...) (1)\n#endif /* __CHECKER__ */\n\n/* Indirect macros required for expanded argument pasting, eg. __LINE__. */\n#define ___PASTE(a,b) a##b\n#define __PASTE(a,b) ___PASTE(a,b)\n\n#ifdef __KERNEL__\n\n/* Attributes */\n#include <linux/compiler_attributes.h>\n\n/* Builtins */\n\n/*\n * __has_builtin is supported on gcc >= 10, clang >= 3 and icc >= 21.\n * In the meantime, to support gcc < 10, we implement __has_builtin\n * by hand.\n */\n#ifndef __has_builtin\n#define __has_builtin(x) (0)\n#endif\n\n/* Compiler specific macros. */\n#ifdef __clang__\n#include <linux/compiler-clang.h>\n#elif defined(__INTEL_COMPILER)\n#include <linux/compiler-intel.h>\n#elif defined(__GNUC__)\n/* The above compilers also define __GNUC__, so order is important here. */\n#include <linux/compiler-gcc.h>\n#else\n#error \"Unknown compiler\"\n#endif\n\n/*\n * Some architectures need to provide custom definitions of macros provided\n * by linux/compiler-*.h, and can do so using asm/compiler.h. We include that\n * conditionally rather than using an asm-generic wrapper in order to avoid\n * build failures if any C compilation, which will include this file via an\n * -include argument in c_flags, occurs prior to the asm-generic wrappers being\n * generated.\n */\n#ifdef CONFIG_HAVE_ARCH_COMPILER_H\n#include <asm/compiler.h>\n#endif\n\nstruct ftrace_branch_data {\n\tconst char *func;\n\tconst char *file;\n\tunsigned line;\n\tunion {\n\t\tstruct {\n\t\t\tunsigned long correct;\n\t\t\tunsigned long incorrect;\n\t\t};\n\t\tstruct {\n\t\t\tunsigned long miss;\n\t\t\tunsigned long hit;\n\t\t};\n\t\tunsigned long miss_hit[2];\n\t};\n};\n\nstruct ftrace_likely_data {\n\tstruct ftrace_branch_data\tdata;\n\tunsigned long\t\t\tconstant;\n};\n\n#ifdef CONFIG_ENABLE_MUST_CHECK\n#define __must_check\t\t__attribute__((__warn_unused_result__))\n#else\n#define __must_check\n#endif\n\n#if defined(CC_USING_HOTPATCH)\n#define notrace\t\t\t__attribute__((hotpatch(0, 0)))\n#elif defined(CC_USING_PATCHABLE_FUNCTION_ENTRY)\n#define notrace\t\t\t__attribute__((patchable_function_entry(0, 0)))\n#else\n#define notrace\t\t\t__attribute__((__no_instrument_function__))\n#endif\n\n/*\n * it doesn't make sense on ARM (currently the only user of __naked)\n * to trace naked functions because then mcount is called without\n * stack and frame pointer being set up and there is no chance to\n * restore the lr register to the value before mcount was called.\n */\n#define __naked\t\t\t__attribute__((__naked__)) notrace\n\n#define __compiler_offsetof(a, b)\t__builtin_offsetof(a, b)\n\n/*\n * Prefer gnu_inline, so that extern inline functions do not emit an\n * externally visible function. This makes extern inline behave as per gnu89\n * semantics rather than c99. This prevents multiple symbol definition errors\n * of extern inline functions at link time.\n * A lot of inline functions can cause havoc with function tracing.\n */\n#define inline inline __gnu_inline __inline_maybe_unused notrace\n\n/*\n * gcc provides both __inline__ and __inline as alternate spellings of\n * the inline keyword, though the latter is undocumented. New kernel\n * code should only use the inline spelling, but some existing code\n * uses __inline__. Since we #define inline above, to ensure\n * __inline__ has the same semantics, we need this #define.\n *\n * However, the spelling __inline is strictly reserved for referring\n * to the bare keyword.\n */\n#define __inline__ inline\n\n/*\n * GCC does not warn about unused static inline functions for -Wunused-function.\n * Suppress the warning in clang as well by using __maybe_unused, but enable it\n * for W=1 build. This will allow clang to find unused functions. Remove the\n * __inline_maybe_unused entirely after fixing most of -Wunused-function warnings.\n */\n#ifdef KBUILD_EXTRA_WARN1\n#define __inline_maybe_unused\n#else\n#define __inline_maybe_unused __maybe_unused\n#endif\n\n/*\n * Rather then using noinline to prevent stack consumption, use\n * noinline_for_stack instead.  For documentation reasons.\n */\n#define noinline_for_stack noinline\n\n/*\n * Sanitizer helper attributes: Because using __always_inline and\n * __no_sanitize_* conflict, provide helper attributes that will either expand\n * to __no_sanitize_* in compilation units where instrumentation is enabled\n * (__SANITIZE_*__), or __always_inline in compilation units without\n * instrumentation (__SANITIZE_*__ undefined).\n */\n#ifdef __SANITIZE_ADDRESS__\n/*\n * We can't declare function 'inline' because __no_sanitize_address conflicts\n * with inlining. Attempt to inline it may cause a build failure.\n *     https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67368\n * '__maybe_unused' allows us to avoid defined-but-not-used warnings.\n */\n# define __no_kasan_or_inline __no_sanitize_address notrace __maybe_unused\n# define __no_sanitize_or_inline __no_kasan_or_inline\n#else\n# define __no_kasan_or_inline __always_inline\n#endif\n\n#define __no_kcsan __no_sanitize_thread\n#ifdef __SANITIZE_THREAD__\n# define __no_sanitize_or_inline __no_kcsan notrace __maybe_unused\n#endif\n\n#ifndef __no_sanitize_or_inline\n#define __no_sanitize_or_inline __always_inline\n#endif\n\n/* Section for code which can't be instrumented at all */\n#define noinstr\t\t\t\t\t\t\t\t\\\n\tnoinline notrace __attribute((__section__(\".noinstr.text\")))\t\\\n\t__no_kcsan __no_sanitize_address\n\n#endif /* __KERNEL__ */\n\n#endif /* __ASSEMBLY__ */\n\n/*\n * The below symbols may be defined for one or more, but not ALL, of the above\n * compilers. We don't consider that to be an error, so set them to nothing.\n * For example, some of them are for compiler specific plugins.\n */\n#ifndef __latent_entropy\n# define __latent_entropy\n#endif\n\n#ifndef __randomize_layout\n# define __randomize_layout __designated_init\n#endif\n\n#ifndef __no_randomize_layout\n# define __no_randomize_layout\n#endif\n\n#ifndef randomized_struct_fields_start\n# define randomized_struct_fields_start\n# define randomized_struct_fields_end\n#endif\n\n#ifndef __noscs\n# define __noscs\n#endif\n\n#ifndef asm_volatile_goto\n#define asm_volatile_goto(x...) asm goto(x)\n#endif\n\n#ifdef CONFIG_CC_HAS_ASM_INLINE\n#define asm_inline asm __inline\n#else\n#define asm_inline asm\n#endif\n\n/* Are two types/vars the same type (ignoring qualifiers)? */\n#define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))\n\n/*\n * __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leaving\n *\t\t\t       non-scalar types unchanged.\n */\n/*\n * Prefer C11 _Generic for better compile-times and simpler code. Note: 'char'\n * is not type-compatible with 'signed char', and we define a separate case.\n */\n#define __scalar_type_to_expr_cases(type)\t\t\t\t\\\n\t\tunsigned type:\t(unsigned type)0,\t\t\t\\\n\t\tsigned type:\t(signed type)0\n\n#define __unqual_scalar_typeof(x) typeof(\t\t\t\t\\\n\t\t_Generic((x),\t\t\t\t\t\t\\\n\t\t\t char:\t(char)0,\t\t\t\t\\\n\t\t\t __scalar_type_to_expr_cases(char),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(short),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(int),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(long),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(long long),\t\\\n\t\t\t default: (x)))\n\n/* Is this type a native word size -- useful for atomic operations */\n#define __native_word(t) \\\n\t(sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || \\\n\t sizeof(t) == sizeof(int) || sizeof(t) == sizeof(long))\n\n/* Compile time object size, -1 for unknown */\n#ifndef __compiletime_object_size\n# define __compiletime_object_size(obj) -1\n#endif\n#ifndef __compiletime_warning\n# define __compiletime_warning(message)\n#endif\n#ifndef __compiletime_error\n# define __compiletime_error(message)\n#endif\n\n#ifdef __OPTIMIZE__\n# define __compiletime_assert(condition, msg, prefix, suffix)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\textern void prefix ## suffix(void) __compiletime_error(msg); \\\n\t\tif (!(condition))\t\t\t\t\t\\\n\t\t\tprefix ## suffix();\t\t\t\t\\\n\t} while (0)\n#else\n# define __compiletime_assert(condition, msg, prefix, suffix) do { } while (0)\n#endif\n\n#define _compiletime_assert(condition, msg, prefix, suffix) \\\n\t__compiletime_assert(condition, msg, prefix, suffix)\n\n/**\n * compiletime_assert - break build and emit msg if condition is false\n * @condition: a compile-time constant condition to check\n * @msg:       a message to emit if condition is false\n *\n * In tradition of POSIX assert, this macro will break the build if the\n * supplied condition is *false*, emitting the supplied error message if the\n * compiler has support to do so.\n */\n#define compiletime_assert(condition, msg) \\\n\t_compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n\n#define compiletime_assert_atomic_type(t)\t\t\t\t\\\n\tcompiletime_assert(__native_word(t),\t\t\t\t\\\n\t\t\"Need native word sized stores/loads for atomicity.\")\n\n/* Helpers for emitting diagnostics in pragmas. */\n#ifndef __diag\n#define __diag(string)\n#endif\n\n#ifndef __diag_GCC\n#define __diag_GCC(version, severity, string)\n#endif\n\n#define __diag_push()\t__diag(push)\n#define __diag_pop()\t__diag(pop)\n\n#define __diag_ignore(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, ignore, option)\n#define __diag_warn(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, warn, option)\n#define __diag_error(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, error, option)\n\n#endif /* __LINUX_COMPILER_TYPES_H */\n"}, "22": {"id": 22, "path": "/src/drivers/hid/hid-sunplus.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  HID driver for some sunplus \"special\" devices\n *\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>\n *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc\n *  Copyright (c) 2006-2007 Jiri Kosina\n *  Copyright (c) 2008 Jiri Slaby\n */\n\n/*\n */\n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\nstatic __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 112 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&\n\t\t\trdesc[106] == 0x03) {\n\t\thid_info(hdev, \"fixing up Sunplus Wireless Desktop report descriptor\\n\");\n\t\trdesc[105] = rdesc[110] = 0x03;\n\t\trdesc[106] = rdesc[111] = 0x21;\n\t}\n\treturn rdesc;\n}\n\n#define sp_map_key_clear(c)\thid_map_usage_clear(hi, usage, bit, max, \\\n\t\tEV_KEY, (c))\nstatic int sp_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_CONSUMER)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\tcase 0x2003: sp_map_key_clear(KEY_ZOOMIN);\t\tbreak;\n\tcase 0x2103: sp_map_key_clear(KEY_ZOOMOUT);\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic const struct hid_device_id sp_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_SUNPLUS, USB_DEVICE_ID_SUNPLUS_WDESKTOP) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, sp_devices);\n\nstatic struct hid_driver sp_driver = {\n\t.name = \"sunplus\",\n\t.id_table = sp_devices,\n\t.report_fixup = sp_report_fixup,\n\t.input_mapping = sp_input_mapping,\n};\nmodule_hid_driver(sp_driver);\n\nMODULE_LICENSE(\"GPL\");\n"}, "23": {"id": 23, "path": "/src/drivers/hid/hid-topseed.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *  HID driver for TopSeed Cyberlink remote\n *\n *  Copyright (c) 2008 Lev Babiev\n *  based on hid-cherry driver\n *\n *  Modified to also support BTC \"Emprex 3009URF III Vista MCE Remote\" by\n *  Wayne Thomas 2010.\n *\n *  Modified to support Conceptronic CLLRCMCE by\n *  Kees Bakker 2010.\n */\n\n/*\n */\n\n#include <linux/device.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n\n#include \"hid-ids.h\"\n\n#define ts_map_key_clear(c)\thid_map_usage_clear(hi, usage, bit, max, \\\n\t\t\t\t\tEV_KEY, (c))\nstatic int ts_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n\t\tstruct hid_field *field, struct hid_usage *usage,\n\t\tunsigned long **bit, int *max)\n{\n\tif ((usage->hid & HID_USAGE_PAGE) != HID_UP_LOGIVENDOR)\n\t\treturn 0;\n\n\tswitch (usage->hid & HID_USAGE) {\n\tcase 0x00c: ts_map_key_clear(KEY_WLAN);\t\tbreak;\n\tcase 0x00d: ts_map_key_clear(KEY_MEDIA);\tbreak;\n\tcase 0x010: ts_map_key_clear(KEY_ZOOM);\t\tbreak;\n\tcase 0x024: ts_map_key_clear(KEY_MENU);\t\tbreak;\n\tcase 0x025: ts_map_key_clear(KEY_TV);\t\tbreak;\n\tcase 0x027: ts_map_key_clear(KEY_MODE);\t\tbreak;\n\tcase 0x031: ts_map_key_clear(KEY_AUDIO);\tbreak;\n\tcase 0x032: ts_map_key_clear(KEY_TEXT);\t\tbreak;\n\tcase 0x033: ts_map_key_clear(KEY_CHANNEL);\tbreak;\n\tcase 0x047: ts_map_key_clear(KEY_MP3);\t\tbreak;\n\tcase 0x048: ts_map_key_clear(KEY_TV2);\t\tbreak;\n\tcase 0x049: ts_map_key_clear(KEY_CAMERA);\tbreak;\n\tcase 0x04a: ts_map_key_clear(KEY_VIDEO);\tbreak;\n\tcase 0x04b: ts_map_key_clear(KEY_ANGLE);\tbreak;\n\tcase 0x04c: ts_map_key_clear(KEY_LANGUAGE);\tbreak;\n\tcase 0x04d: ts_map_key_clear(KEY_SUBTITLE);\tbreak;\n\tcase 0x050: ts_map_key_clear(KEY_RADIO);\tbreak;\n\tcase 0x05a: ts_map_key_clear(KEY_TEXT);\t\tbreak;\n\tcase 0x05b: ts_map_key_clear(KEY_RED);\t\tbreak;\n\tcase 0x05c: ts_map_key_clear(KEY_GREEN);\tbreak;\n\tcase 0x05d: ts_map_key_clear(KEY_YELLOW);\tbreak;\n\tcase 0x05e: ts_map_key_clear(KEY_BLUE);\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic const struct hid_device_id ts_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_TOPSEED, USB_DEVICE_ID_TOPSEED_CYBERLINK) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BTC, USB_DEVICE_ID_BTC_EMPREX_REMOTE) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_BTC, USB_DEVICE_ID_BTC_EMPREX_REMOTE_2) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_TOPSEED2, USB_DEVICE_ID_TOPSEED2_RF_COMBO) },\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_WIRELESS) },\n\t{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_TOSHIBA_WT10A) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, ts_devices);\n\nstatic struct hid_driver ts_driver = {\n\t.name = \"topseed\",\n\t.id_table = ts_devices,\n\t.input_mapping = ts_input_mapping,\n};\nmodule_hid_driver(ts_driver);\n\nMODULE_LICENSE(\"GPL\");\n"}}, "reports": [{"events": [{"location": {"col": 6, "file": 1, "line": 371}, "message": "Assuming the condition is true"}, {"location": {"col": 45, "file": 1, "line": 371}, "message": "Left side of '||' is true"}, {"location": {"col": 3, "file": 1, "line": 376}, "message": "Calling 'hid_map_usage_clear'"}, {"location": {"col": 2, "file": 0, "line": 1020}, "message": "Calling 'hid_map_usage'"}, {"location": {"col": 2, "file": 0, "line": 974}, "message": "'input' initialized here"}, {"location": {"col": 2, "file": 0, "line": 978}, "message": "Control jumps to 'case 1:'  at line 987"}, {"location": {"col": 3, "file": 0, "line": 990}, "message": "Execution continues on line 997"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "'c' is <= 'limit'"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming 'bmap' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming pointer value is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 997}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 6, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 28, "file": 4, "line": 41}, "message": "expanded from macro '__ratelimit'"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 2, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}, {"location": {"col": 49, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 17, "file": 3, "line": 512}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}], "macros": [], "notes": [], "path": "/src/include/linux/hid.h", "reportHash": "eb17d6697d1eea16f0e7629803602da1", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 5, "line": 32}, "message": "Assuming the condition is false"}, {"location": {"col": 6, "file": 5, "line": 32}, "message": "Left side of '||' is false"}, {"location": {"col": 4, "file": 5, "line": 33}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 5, "line": 32}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 5, "line": 36}, "message": "Control jumps to 'case 60:'  at line 39"}, {"location": {"col": 14, "file": 5, "line": 39}, "message": "Calling 'hid_map_usage_clear'"}, {"location": {"col": 33, "file": 5, "line": 24}, "message": "expanded from macro 'belkin_map_key_clear'"}, {"location": {"col": 2, "file": 0, "line": 1020}, "message": "Calling 'hid_map_usage'"}, {"location": {"col": 2, "file": 0, "line": 974}, "message": "'input' initialized here"}, {"location": {"col": 2, "file": 0, "line": 978}, "message": "Control jumps to 'case 1:'  at line 987"}, {"location": {"col": 3, "file": 0, "line": 990}, "message": "Execution continues on line 997"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "'c' is <= 'limit'"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming 'bmap' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming pointer value is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 997}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 6, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 28, "file": 4, "line": 41}, "message": "expanded from macro '__ratelimit'"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 2, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}, {"location": {"col": 49, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 17, "file": 3, "line": 512}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}], "macros": [], "notes": [], "path": "/src/include/linux/hid.h", "reportHash": "eb17d6697d1eea16f0e7629803602da1", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 6, "line": 42}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 6, "line": 42}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 6, "line": 45}, "message": "Control jumps to 'case 771:'  at line 48"}, {"location": {"col": 14, "file": 6, "line": 48}, "message": "Calling 'hid_map_usage_clear'"}, {"location": {"col": 29, "file": 6, "line": 36}, "message": "expanded from macro 'ch_map_key_clear'"}, {"location": {"col": 2, "file": 0, "line": 1020}, "message": "Calling 'hid_map_usage'"}, {"location": {"col": 2, "file": 0, "line": 974}, "message": "'input' initialized here"}, {"location": {"col": 2, "file": 0, "line": 978}, "message": "Control jumps to 'case 1:'  at line 987"}, {"location": {"col": 3, "file": 0, "line": 990}, "message": "Execution continues on line 997"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "'c' is <= 'limit'"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming 'bmap' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming pointer value is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 997}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 6, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 28, "file": 4, "line": 41}, "message": "expanded from macro '__ratelimit'"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 2, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}, {"location": {"col": 49, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 17, "file": 3, "line": 512}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}], "macros": [], "notes": [], "path": "/src/include/linux/hid.h", "reportHash": "eb17d6697d1eea16f0e7629803602da1", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 7, "line": 30}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 7, "line": 30}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 7, "line": 34}, "message": "Control jumps to 'case 248:'  at line 51"}, {"location": {"col": 15, "file": 7, "line": 51}, "message": "Calling 'hid_map_usage_clear'"}, {"location": {"col": 29, "file": 7, "line": 24}, "message": "expanded from macro 'ch_map_key_clear'"}, {"location": {"col": 2, "file": 0, "line": 1020}, "message": "Calling 'hid_map_usage'"}, {"location": {"col": 2, "file": 0, "line": 974}, "message": "'input' initialized here"}, {"location": {"col": 2, "file": 0, "line": 978}, "message": "Control jumps to 'case 1:'  at line 987"}, {"location": {"col": 3, "file": 0, "line": 990}, "message": "Execution continues on line 997"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "'c' is <= 'limit'"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming 'bmap' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming pointer value is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 997}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 6, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 28, "file": 4, "line": 41}, "message": "expanded from macro '__ratelimit'"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 2, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}, {"location": {"col": 49, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 17, "file": 3, "line": 512}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}], "macros": [], "notes": [], "path": "/src/include/linux/hid.h", "reportHash": "eb17d6697d1eea16f0e7629803602da1", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 8, "line": 29}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 8, "line": 29}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 8, "line": 32}, "message": "Control jumps to 'case 562:'  at line 40"}, {"location": {"col": 14, "file": 8, "line": 40}, "message": "Calling 'hid_map_usage'"}, {"location": {"col": 23, "file": 8, "line": 22}, "message": "expanded from macro 'ez_map_rel'"}, {"location": {"col": 2, "file": 0, "line": 974}, "message": "'input' initialized here"}, {"location": {"col": 2, "file": 0, "line": 978}, "message": "Control jumps to 'case 2:'  at line 983"}, {"location": {"col": 3, "file": 0, "line": 986}, "message": "Execution continues on line 997"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "'c' is <= 'limit'"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming 'bmap' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 997}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 6, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 28, "file": 4, "line": 41}, "message": "expanded from macro '__ratelimit'"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 2, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}, {"location": {"col": 49, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 17, "file": 3, "line": 512}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}], "macros": [], "notes": [], "path": "/src/include/linux/hid.h", "reportHash": "eb17d6697d1eea16f0e7629803602da1", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 9, "line": 28}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 9, "line": 28}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 9, "line": 32}, "message": "Control jumps to 'case 94:'  at line 46"}, {"location": {"col": 14, "file": 9, "line": 46}, "message": "Calling 'hid_map_usage_clear'"}, {"location": {"col": 29, "file": 9, "line": 22}, "message": "expanded from macro 'gy_map_key_clear'"}, {"location": {"col": 2, "file": 0, "line": 1020}, "message": "Calling 'hid_map_usage'"}, {"location": {"col": 2, "file": 0, "line": 974}, "message": "'input' initialized here"}, {"location": {"col": 2, "file": 0, "line": 978}, "message": "Control jumps to 'case 1:'  at line 987"}, {"location": {"col": 3, "file": 0, "line": 990}, "message": "Execution continues on line 997"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "'c' is <= 'limit'"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming 'bmap' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming pointer value is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 997}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 6, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 28, "file": 4, "line": 41}, "message": "expanded from macro '__ratelimit'"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 2, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}, {"location": {"col": 49, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 17, "file": 3, "line": 512}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}], "macros": [], "notes": [], "path": "/src/include/linux/hid.h", "reportHash": "eb17d6697d1eea16f0e7629803602da1", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 10, "line": 38}, "message": "Assuming the condition is true"}, {"location": {"col": 6, "file": 10, "line": 38}, "message": "Left side of '&&' is true"}, {"location": {"col": 6, "file": 10, "line": 39}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 10, "line": 38}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 10, "line": 40}, "message": "Assuming field 'hid' is equal to 8913016"}, {"location": {"col": 3, "file": 10, "line": 40}, "message": "Taking true branch"}, {"location": {"col": 4, "file": 10, "line": 42}, "message": "Calling 'hid_map_usage_clear'"}, {"location": {"col": 2, "file": 0, "line": 1020}, "message": "Calling 'hid_map_usage'"}, {"location": {"col": 2, "file": 0, "line": 974}, "message": "'input' initialized here"}, {"location": {"col": 2, "file": 0, "line": 978}, "message": "Control jumps to 'case 1:'  at line 987"}, {"location": {"col": 3, "file": 0, "line": 990}, "message": "Execution continues on line 997"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "'c' is <= 'limit'"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming 'bmap' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming pointer value is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 997}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 6, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 28, "file": 4, "line": 41}, "message": "expanded from macro '__ratelimit'"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 2, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}, {"location": {"col": 49, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 17, "file": 3, "line": 512}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}], "macros": [], "notes": [], "path": "/src/include/linux/hid.h", "reportHash": "eb17d6697d1eea16f0e7629803602da1", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 11, "line": 24}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 11, "line": 24}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 11, "line": 27}, "message": "Control jumps to 'case 2:'  at line 29"}, {"location": {"col": 13, "file": 11, "line": 29}, "message": "Calling 'hid_map_usage'"}, {"location": {"col": 23, "file": 11, "line": 18}, "message": "expanded from macro 'ks_map_key'"}, {"location": {"col": 2, "file": 0, "line": 974}, "message": "'input' initialized here"}, {"location": {"col": 2, "file": 0, "line": 978}, "message": "Control jumps to 'case 1:'  at line 987"}, {"location": {"col": 3, "file": 0, "line": 990}, "message": "Execution continues on line 997"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "'c' is <= 'limit'"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming 'bmap' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 997}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 6, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 28, "file": 4, "line": 41}, "message": "expanded from macro '__ratelimit'"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 2, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}, {"location": {"col": 49, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 17, "file": 3, "line": 512}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}], "macros": [], "notes": [], "path": "/src/include/linux/hid.h", "reportHash": "eb17d6697d1eea16f0e7629803602da1", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 12, "line": 667}, "message": "Assuming field 'product' is not equal to USB_DEVICE_ID_LOGITECH_RECEIVER"}, {"location": {"col": 55, "file": 12, "line": 667}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 12, "line": 671}, "message": "Assuming field 'product' is not equal to USB_DEVICE_ID_DINOVO_MINI"}, {"location": {"col": 49, "file": 12, "line": 671}, "message": "Left side of '&&' is false"}, {"location": {"col": 7, "file": 12, "line": 675}, "message": "Assuming the condition is true"}, {"location": {"col": 6, "file": 12, "line": 675}, "message": "Left side of '&&' is true"}, {"location": {"col": 42, "file": 12, "line": 675}, "message": "Calling 'lg_wireless_mapping'"}, {"location": {"col": 6, "file": 12, "line": 590}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 12, "line": 590}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 12, "line": 593}, "message": "Control jumps to 'case 4172:'  at line 640"}, {"location": {"col": 15, "file": 12, "line": 640}, "message": "Calling 'hid_map_usage_clear'"}, {"location": {"col": 29, "file": 12, "line": 535}, "message": "expanded from macro 'lg_map_key_clear'"}, {"location": {"col": 2, "file": 0, "line": 1020}, "message": "Calling 'hid_map_usage'"}, {"location": {"col": 2, "file": 0, "line": 974}, "message": "'input' initialized here"}, {"location": {"col": 2, "file": 0, "line": 978}, "message": "Control jumps to 'case 1:'  at line 987"}, {"location": {"col": 3, "file": 0, "line": 990}, "message": "Execution continues on line 997"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "'c' is <= 'limit'"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming 'bmap' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming pointer value is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 997}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 6, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 28, "file": 4, "line": 41}, "message": "expanded from macro '__ratelimit'"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 2, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}, {"location": {"col": 49, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 17, "file": 3, "line": 512}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}], "macros": [], "notes": [], "path": "/src/include/linux/hid.h", "reportHash": "eb17d6697d1eea16f0e7629803602da1", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 189}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 13, "line": 189}, "message": "Taking true branch"}, {"location": {"col": 13, "file": 13, "line": 190}, "message": "Calling 'ms_ergonomy_kb_quirk'"}, {"location": {"col": 6, "file": 13, "line": 85}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 13, "line": 85}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 13, "line": 86}, "message": "Control jumps to 'case 670:'  at line 94"}, {"location": {"col": 4, "file": 13, "line": 95}, "message": "Calling 'hid_map_usage_clear'"}, {"location": {"col": 29, "file": 13, "line": 78}, "message": "expanded from macro 'ms_map_key_clear'"}, {"location": {"col": 2, "file": 0, "line": 1020}, "message": "Calling 'hid_map_usage'"}, {"location": {"col": 2, "file": 0, "line": 974}, "message": "'input' initialized here"}, {"location": {"col": 2, "file": 0, "line": 978}, "message": "Control jumps to 'case 1:'  at line 987"}, {"location": {"col": 3, "file": 0, "line": 990}, "message": "Execution continues on line 997"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "'c' is <= 'limit'"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming 'bmap' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming pointer value is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 997}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 6, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 28, "file": 4, "line": 41}, "message": "expanded from macro '__ratelimit'"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 2, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}, {"location": {"col": 49, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 17, "file": 3, "line": 512}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}], "macros": [], "notes": [], "path": "/src/include/linux/hid.h", "reportHash": "eb17d6697d1eea16f0e7629803602da1", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 14, "line": 37}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 14, "line": 37}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 14, "line": 40}, "message": "Control jumps to 'case 348:'  at line 44"}, {"location": {"col": 14, "file": 14, "line": 44}, "message": "Calling 'hid_map_usage_clear'"}, {"location": {"col": 29, "file": 14, "line": 31}, "message": "expanded from macro 'mr_map_key_clear'"}, {"location": {"col": 2, "file": 0, "line": 1020}, "message": "Calling 'hid_map_usage'"}, {"location": {"col": 2, "file": 0, "line": 974}, "message": "'input' initialized here"}, {"location": {"col": 2, "file": 0, "line": 978}, "message": "Control jumps to 'case 1:'  at line 987"}, {"location": {"col": 3, "file": 0, "line": 990}, "message": "Execution continues on line 997"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "'c' is <= 'limit'"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming 'bmap' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming pointer value is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 997}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 6, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 28, "file": 4, "line": 41}, "message": "expanded from macro '__ratelimit'"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 2, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}, {"location": {"col": 49, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 17, "file": 3, "line": 512}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}], "macros": [], "notes": [], "path": "/src/include/linux/hid.h", "reportHash": "eb17d6697d1eea16f0e7629803602da1", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 15, "line": 41}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 15, "line": 41}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 15, "line": 42}, "message": "Control jumps to 'case 94:'  at line 47"}, {"location": {"col": 15, "file": 15, "line": 47}, "message": "Calling 'hid_map_usage_clear'"}, {"location": {"col": 29, "file": 15, "line": 35}, "message": "expanded from macro 'pl_map_key_clear'"}, {"location": {"col": 2, "file": 0, "line": 1020}, "message": "Calling 'hid_map_usage'"}, {"location": {"col": 2, "file": 0, "line": 974}, "message": "'input' initialized here"}, {"location": {"col": 2, "file": 0, "line": 978}, "message": "Control jumps to 'case 1:'  at line 987"}, {"location": {"col": 3, "file": 0, "line": 990}, "message": "Execution continues on line 997"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "'c' is <= 'limit'"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming 'bmap' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming pointer value is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 997}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 6, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 28, "file": 4, "line": 41}, "message": "expanded from macro '__ratelimit'"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 2, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}, {"location": {"col": 49, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 17, "file": 3, "line": 512}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}], "macros": [], "notes": [], "path": "/src/include/linux/hid.h", "reportHash": "eb17d6697d1eea16f0e7629803602da1", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 16, "line": 142}, "message": "Assuming USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE is equal to field 'product'"}, {"location": {"col": 50, "file": 17, "line": 1037}, "message": "expanded from macro 'USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE'"}, {"location": {"col": 2, "file": 16, "line": 142}, "message": "Taking true branch"}, {"location": {"col": 9, "file": 16, "line": 143}, "message": "Calling 'samsung_kbd_mouse_input_mapping'"}, {"location": {"col": 31, "file": 16, "line": 99}, "message": "Left side of '&&' is false"}, {"location": {"col": 29, "file": 18, "line": 261}, "message": "expanded from macro 'to_usb_interface'"}, {"location": {"col": 61, "file": 19, "line": 687}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 31, "file": 16, "line": 99}, "message": "Taking false branch"}, {"location": {"col": 29, "file": 18, "line": 261}, "message": "expanded from macro 'to_usb_interface'"}, {"location": {"col": 2, "file": 19, "line": 687}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 20, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 21, "line": 326}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 21, "line": 314}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 3, "file": 21, "line": 306}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 31, "file": 16, "line": 99}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 29, "file": 18, "line": 261}, "message": "expanded from macro 'to_usb_interface'"}, {"location": {"col": 2, "file": 19, "line": 687}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 20, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 21, "line": 326}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 21, "line": 314}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 2, "file": 21, "line": 304}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 6, "file": 16, "line": 102}, "message": "Assuming 'ifnum' is equal to 1"}, {"location": {"col": 6, "file": 16, "line": 102}, "message": "Left side of '||' is false"}, {"location": {"col": 20, "file": 16, "line": 102}, "message": "Assuming the condition is false"}, {"location": {"col": 26, "file": 0, "line": 153}, "message": "expanded from macro 'HID_UP_CONSUMER'"}, {"location": {"col": 2, "file": 16, "line": 102}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 16, "line": 105}, "message": "Assuming 'hid_debug' is 0"}, {"location": {"col": 6, "file": 0, "line": 1178}, "message": "expanded from macro 'dbg_hid'"}, {"location": {"col": 2, "file": 16, "line": 105}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1178}, "message": "expanded from macro 'dbg_hid'"}, {"location": {"col": 2, "file": 16, "line": 105}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 32, "file": 0, "line": 1176}, "message": "expanded from macro 'dbg_hid'"}, {"location": {"col": 2, "file": 16, "line": 108}, "message": "Control jumps to 'case 561:'  at line 120"}, {"location": {"col": 14, "file": 16, "line": 120}, "message": "Calling 'hid_map_usage_clear'"}, {"location": {"col": 2, "file": 16, "line": 93}, "message": "expanded from macro 'samsung_kbd_mouse_map_key_clear'"}, {"location": {"col": 2, "file": 0, "line": 1020}, "message": "Calling 'hid_map_usage'"}, {"location": {"col": 2, "file": 0, "line": 974}, "message": "'input' initialized here"}, {"location": {"col": 2, "file": 0, "line": 978}, "message": "Control jumps to 'case 1:'  at line 987"}, {"location": {"col": 3, "file": 0, "line": 990}, "message": "Execution continues on line 997"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "'c' is <= 'limit'"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming 'bmap' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming pointer value is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 997}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 6, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 28, "file": 4, "line": 41}, "message": "expanded from macro '__ratelimit'"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 2, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}, {"location": {"col": 49, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 17, "file": 3, "line": 512}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}], "macros": [], "notes": [], "path": "/src/include/linux/hid.h", "reportHash": "eb17d6697d1eea16f0e7629803602da1", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 22, "line": 39}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 22, "line": 39}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 22, "line": 42}, "message": "Control jumps to 'case 8451:'  at line 44"}, {"location": {"col": 15, "file": 22, "line": 44}, "message": "Calling 'hid_map_usage_clear'"}, {"location": {"col": 29, "file": 22, "line": 33}, "message": "expanded from macro 'sp_map_key_clear'"}, {"location": {"col": 2, "file": 0, "line": 1020}, "message": "Calling 'hid_map_usage'"}, {"location": {"col": 2, "file": 0, "line": 974}, "message": "'input' initialized here"}, {"location": {"col": 2, "file": 0, "line": 978}, "message": "Control jumps to 'case 1:'  at line 987"}, {"location": {"col": 3, "file": 0, "line": 990}, "message": "Execution continues on line 997"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "'c' is <= 'limit'"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming 'bmap' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming pointer value is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 997}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 6, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 28, "file": 4, "line": 41}, "message": "expanded from macro '__ratelimit'"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 2, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}, {"location": {"col": 49, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 17, "file": 3, "line": 512}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}], "macros": [], "notes": [], "path": "/src/include/linux/hid.h", "reportHash": "eb17d6697d1eea16f0e7629803602da1", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 23, "line": 30}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 23, "line": 30}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 23, "line": 33}, "message": "Control jumps to 'case 16:'  at line 36"}, {"location": {"col": 14, "file": 23, "line": 36}, "message": "Calling 'hid_map_usage_clear'"}, {"location": {"col": 29, "file": 23, "line": 24}, "message": "expanded from macro 'ts_map_key_clear'"}, {"location": {"col": 2, "file": 0, "line": 1020}, "message": "Calling 'hid_map_usage'"}, {"location": {"col": 2, "file": 0, "line": 974}, "message": "'input' initialized here"}, {"location": {"col": 2, "file": 0, "line": 978}, "message": "Control jumps to 'case 1:'  at line 987"}, {"location": {"col": 3, "file": 0, "line": 990}, "message": "Execution continues on line 997"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "'c' is <= 'limit'"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 15, "file": 0, "line": 997}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming 'bmap' is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 28, "file": 0, "line": 997}, "message": "Assuming pointer value is null"}, {"location": {"col": 42, "file": 2, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 997}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 6, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 28, "file": 4, "line": 41}, "message": "expanded from macro '__ratelimit'"}, {"location": {"col": 3, "file": 0, "line": 998}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 2, "file": 3, "line": 511}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}, {"location": {"col": 49, "file": 3, "line": 528}, "message": "expanded from macro 'pr_warn_ratelimited'"}, {"location": {"col": 17, "file": 3, "line": 512}, "message": "expanded from macro 'printk_ratelimited'"}, {"location": {"col": 9, "file": 0, "line": 999}, "message": "Access to field 'name' results in a dereference of a null pointer (loaded from variable 'input')"}], "macros": [], "notes": [], "path": "/src/include/linux/hid.h", "reportHash": "eb17d6697d1eea16f0e7629803602da1", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
