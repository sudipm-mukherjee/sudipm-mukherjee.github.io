<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/scsi/lpfc/lpfc_els.c", "content": "/*******************************************************************\n * This file is part of the Emulex Linux Device Driver for         *\n * Fibre Channel Host Bus Adapters.                                *\n * Copyright (C) 2017-2020 Broadcom. All Rights Reserved. The term *\n * \u201cBroadcom\u201d refers to Broadcom Inc. and/or its subsidiaries.     *\n * Copyright (C) 2004-2016 Emulex.  All rights reserved.           *\n * EMULEX and SLI are trademarks of Emulex.                        *\n * www.broadcom.com                                                *\n * Portions Copyright (C) 2004-2005 Christoph Hellwig              *\n *                                                                 *\n * This program is free software; you can redistribute it and/or   *\n * modify it under the terms of version 2 of the GNU General       *\n * Public License as published by the Free Software Foundation.    *\n * This program is distributed in the hope that it will be useful. *\n * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *\n * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *\n * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *\n * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *\n * TO BE LEGALLY INVALID.  See the GNU General Public License for  *\n * more details, a copy of which can be found in the file COPYING  *\n * included with this package.                                     *\n *******************************************************************/\n/* See Fibre Channel protocol T11 FC-LS for details */\n#include <linux/blkdev.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport_fc.h>\n#include <uapi/scsi/fc/fc_fs.h>\n#include <uapi/scsi/fc/fc_els.h>\n\n#include \"lpfc_hw4.h\"\n#include \"lpfc_hw.h\"\n#include \"lpfc_sli.h\"\n#include \"lpfc_sli4.h\"\n#include \"lpfc_nl.h\"\n#include \"lpfc_disc.h\"\n#include \"lpfc_scsi.h\"\n#include \"lpfc.h\"\n#include \"lpfc_logmsg.h\"\n#include \"lpfc_crtn.h\"\n#include \"lpfc_vport.h\"\n#include \"lpfc_debugfs.h\"\n\nstatic int lpfc_els_retry(struct lpfc_hba *, struct lpfc_iocbq *,\n\t\t\t  struct lpfc_iocbq *);\nstatic void lpfc_cmpl_fabric_iocb(struct lpfc_hba *, struct lpfc_iocbq *,\n\t\t\tstruct lpfc_iocbq *);\nstatic void lpfc_fabric_abort_vport(struct lpfc_vport *vport);\nstatic int lpfc_issue_els_fdisc(struct lpfc_vport *vport,\n\t\t\t\tstruct lpfc_nodelist *ndlp, uint8_t retry);\nstatic int lpfc_issue_fabric_iocb(struct lpfc_hba *phba,\n\t\t\t\t  struct lpfc_iocbq *iocb);\n\nstatic int lpfc_max_els_tries = 3;\n\n/**\n * lpfc_els_chk_latt - Check host link attention event for a vport\n * @vport: pointer to a host virtual N_Port data structure.\n *\n * This routine checks whether there is an outstanding host link\n * attention event during the discovery process with the @vport. It is done\n * by reading the HBA's Host Attention (HA) register. If there is any host\n * link attention events during this @vport's discovery process, the @vport\n * shall be marked as FC_ABORT_DISCOVERY, a host link attention clear shall\n * be issued if the link state is not already in host link cleared state,\n * and a return code shall indicate whether the host link attention event\n * had happened.\n *\n * Note that, if either the host link is in state LPFC_LINK_DOWN or @vport\n * state in LPFC_VPORT_READY, the request for checking host link attention\n * event will be ignored and a return code shall indicate no host link\n * attention event had happened.\n *\n * Return codes\n *   0 - no host link attention event happened\n *   1 - host link attention event happened\n **/\nint\nlpfc_els_chk_latt(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tuint32_t ha_copy;\n\n\tif (vport->port_state >= LPFC_VPORT_READY ||\n\t    phba->link_state == LPFC_LINK_DOWN ||\n\t    phba->sli_rev > LPFC_SLI_REV3)\n\t\treturn 0;\n\n\t/* Read the HBA Host Attention Register */\n\tif (lpfc_readl(phba->HAregaddr, &ha_copy))\n\t\treturn 1;\n\n\tif (!(ha_copy & HA_LATT))\n\t\treturn 0;\n\n\t/* Pending Link Event during Discovery */\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0237 Pending Link Event during \"\n\t\t\t \"Discovery: State x%x\\n\",\n\t\t\t phba->pport->port_state);\n\n\t/* CLEAR_LA should re-enable link attention events and\n\t * we should then immediately take a LATT event. The\n\t * LATT processing should call lpfc_linkdown() which\n\t * will cleanup any left over in-progress discovery\n\t * events.\n\t */\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag |= FC_ABORT_DISCOVERY;\n\tspin_unlock_irq(shost->host_lock);\n\n\tif (phba->link_state != LPFC_CLEAR_LA)\n\t\tlpfc_issue_clear_la(phba, vport);\n\n\treturn 1;\n}\n\n/**\n * lpfc_prep_els_iocb - Allocate and prepare a lpfc iocb data structure\n * @vport: pointer to a host virtual N_Port data structure.\n * @expectRsp: flag indicating whether response is expected.\n * @cmdSize: size of the ELS command.\n * @retry: number of retries to the command IOCB when it fails.\n * @ndlp: pointer to a node-list data structure.\n * @did: destination identifier.\n * @elscmd: the ELS command code.\n *\n * This routine is used for allocating a lpfc-IOCB data structure from\n * the driver lpfc-IOCB free-list and prepare the IOCB with the parameters\n * passed into the routine for discovery state machine to issue an Extended\n * Link Service (ELS) commands. It is a generic lpfc-IOCB allocation\n * and preparation routine that is used by all the discovery state machine\n * routines and the ELS command-specific fields will be later set up by\n * the individual discovery machine routines after calling this routine\n * allocating and preparing a generic IOCB data structure. It fills in the\n * Buffer Descriptor Entries (BDEs), allocates buffers for both command\n * payload and response payload (if expected). The reference count on the\n * ndlp is incremented by 1 and the reference to the ndlp is put into\n * context1 of the IOCB data structure for this IOCB to hold the ndlp\n * reference for the command's callback function to access later.\n *\n * Return code\n *   Pointer to the newly allocated/prepared els iocb data structure\n *   NULL - when els iocb data structure allocation/preparation failed\n **/\nstruct lpfc_iocbq *\nlpfc_prep_els_iocb(struct lpfc_vport *vport, uint8_t expectRsp,\n\t\t   uint16_t cmdSize, uint8_t retry,\n\t\t   struct lpfc_nodelist *ndlp, uint32_t did,\n\t\t   uint32_t elscmd)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct lpfc_dmabuf *pcmd, *prsp, *pbuflist;\n\tstruct ulp_bde64 *bpl;\n\tIOCB_t *icmd;\n\n\n\tif (!lpfc_is_link_up(phba))\n\t\treturn NULL;\n\n\t/* Allocate buffer for  command iocb */\n\telsiocb = lpfc_sli_get_iocbq(phba);\n\n\tif (elsiocb == NULL)\n\t\treturn NULL;\n\n\t/*\n\t * If this command is for fabric controller and HBA running\n\t * in FIP mode send FLOGI, FDISC and LOGO as FIP frames.\n\t */\n\tif ((did == Fabric_DID) &&\n\t\t(phba->hba_flag & HBA_FIP_SUPPORT) &&\n\t\t((elscmd == ELS_CMD_FLOGI) ||\n\t\t (elscmd == ELS_CMD_FDISC) ||\n\t\t (elscmd == ELS_CMD_LOGO)))\n\t\tswitch (elscmd) {\n\t\tcase ELS_CMD_FLOGI:\n\t\telsiocb->iocb_flag |=\n\t\t\t((LPFC_ELS_ID_FLOGI << LPFC_FIP_ELS_ID_SHIFT)\n\t\t\t\t\t& LPFC_FIP_ELS_ID_MASK);\n\t\tbreak;\n\t\tcase ELS_CMD_FDISC:\n\t\telsiocb->iocb_flag |=\n\t\t\t((LPFC_ELS_ID_FDISC << LPFC_FIP_ELS_ID_SHIFT)\n\t\t\t\t\t& LPFC_FIP_ELS_ID_MASK);\n\t\tbreak;\n\t\tcase ELS_CMD_LOGO:\n\t\telsiocb->iocb_flag |=\n\t\t\t((LPFC_ELS_ID_LOGO << LPFC_FIP_ELS_ID_SHIFT)\n\t\t\t\t\t& LPFC_FIP_ELS_ID_MASK);\n\t\tbreak;\n\t\t}\n\telse\n\t\telsiocb->iocb_flag &= ~LPFC_FIP_ELS_ID_MASK;\n\n\ticmd = &elsiocb->iocb;\n\n\t/* fill in BDEs for command */\n\t/* Allocate buffer for command payload */\n\tpcmd = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\n\tif (pcmd)\n\t\tpcmd->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &pcmd->phys);\n\tif (!pcmd || !pcmd->virt)\n\t\tgoto els_iocb_free_pcmb_exit;\n\n\tINIT_LIST_HEAD(&pcmd->list);\n\n\t/* Allocate buffer for response payload */\n\tif (expectRsp) {\n\t\tprsp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\n\t\tif (prsp)\n\t\t\tprsp->virt = lpfc_mbuf_alloc(phba, MEM_PRI,\n\t\t\t\t\t\t     &prsp->phys);\n\t\tif (!prsp || !prsp->virt)\n\t\t\tgoto els_iocb_free_prsp_exit;\n\t\tINIT_LIST_HEAD(&prsp->list);\n\t} else\n\t\tprsp = NULL;\n\n\t/* Allocate buffer for Buffer ptr list */\n\tpbuflist = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\n\tif (pbuflist)\n\t\tpbuflist->virt = lpfc_mbuf_alloc(phba, MEM_PRI,\n\t\t\t\t\t\t &pbuflist->phys);\n\tif (!pbuflist || !pbuflist->virt)\n\t\tgoto els_iocb_free_pbuf_exit;\n\n\tINIT_LIST_HEAD(&pbuflist->list);\n\n\tif (expectRsp) {\n\t\ticmd->un.elsreq64.bdl.addrHigh = putPaddrHigh(pbuflist->phys);\n\t\ticmd->un.elsreq64.bdl.addrLow = putPaddrLow(pbuflist->phys);\n\t\ticmd->un.elsreq64.bdl.bdeFlags = BUFF_TYPE_BLP_64;\n\t\ticmd->un.elsreq64.bdl.bdeSize = (2 * sizeof(struct ulp_bde64));\n\n\t\ticmd->un.elsreq64.remoteID = did;\t\t/* DID */\n\t\ticmd->ulpCommand = CMD_ELS_REQUEST64_CR;\n\t\tif (elscmd == ELS_CMD_FLOGI)\n\t\t\ticmd->ulpTimeout = FF_DEF_RATOV * 2;\n\t\telse if (elscmd == ELS_CMD_LOGO)\n\t\t\ticmd->ulpTimeout = phba->fc_ratov;\n\t\telse\n\t\t\ticmd->ulpTimeout = phba->fc_ratov * 2;\n\t} else {\n\t\ticmd->un.xseq64.bdl.addrHigh = putPaddrHigh(pbuflist->phys);\n\t\ticmd->un.xseq64.bdl.addrLow = putPaddrLow(pbuflist->phys);\n\t\ticmd->un.xseq64.bdl.bdeFlags = BUFF_TYPE_BLP_64;\n\t\ticmd->un.xseq64.bdl.bdeSize = sizeof(struct ulp_bde64);\n\t\ticmd->un.xseq64.xmit_els_remoteID = did;\t/* DID */\n\t\ticmd->ulpCommand = CMD_XMIT_ELS_RSP64_CX;\n\t}\n\ticmd->ulpBdeCount = 1;\n\ticmd->ulpLe = 1;\n\ticmd->ulpClass = CLASS3;\n\n\t/*\n\t * If we have NPIV enabled, we want to send ELS traffic by VPI.\n\t * For SLI4, since the driver controls VPIs we also want to include\n\t * all ELS pt2pt protocol traffic as well.\n\t */\n\tif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) ||\n\t\t((phba->sli_rev == LPFC_SLI_REV4) &&\n\t\t    (vport->fc_flag & FC_PT2PT))) {\n\n\t\tif (expectRsp) {\n\t\t\ticmd->un.elsreq64.myID = vport->fc_myDID;\n\n\t\t\t/* For ELS_REQUEST64_CR, use the VPI by default */\n\t\t\ticmd->ulpContext = phba->vpi_ids[vport->vpi];\n\t\t}\n\n\t\ticmd->ulpCt_h = 0;\n\t\t/* The CT field must be 0=INVALID_RPI for the ECHO cmd */\n\t\tif (elscmd == ELS_CMD_ECHO)\n\t\t\ticmd->ulpCt_l = 0; /* context = invalid RPI */\n\t\telse\n\t\t\ticmd->ulpCt_l = 1; /* context = VPI */\n\t}\n\n\tbpl = (struct ulp_bde64 *) pbuflist->virt;\n\tbpl->addrLow = le32_to_cpu(putPaddrLow(pcmd->phys));\n\tbpl->addrHigh = le32_to_cpu(putPaddrHigh(pcmd->phys));\n\tbpl->tus.f.bdeSize = cmdSize;\n\tbpl->tus.f.bdeFlags = 0;\n\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\n\tif (expectRsp) {\n\t\tbpl++;\n\t\tbpl->addrLow = le32_to_cpu(putPaddrLow(prsp->phys));\n\t\tbpl->addrHigh = le32_to_cpu(putPaddrHigh(prsp->phys));\n\t\tbpl->tus.f.bdeSize = FCELSSIZE;\n\t\tbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\t}\n\n\telsiocb->context2 = pcmd;\n\telsiocb->context3 = pbuflist;\n\telsiocb->retry = retry;\n\telsiocb->vport = vport;\n\telsiocb->drvrTimeout = (phba->fc_ratov << 1) + LPFC_DRVR_TIMEOUT;\n\n\tif (prsp) {\n\t\tlist_add(&prsp->list, &pcmd->list);\n\t}\n\tif (expectRsp) {\n\t\t/* Xmit ELS command <elsCmd> to remote NPORT <did> */\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"0116 Xmit ELS command x%x to remote \"\n\t\t\t\t \"NPORT x%x I/O tag: x%x, port state:x%x \"\n\t\t\t\t \"rpi x%x fc_flag:x%x\\n\",\n\t\t\t\t elscmd, did, elsiocb->iotag,\n\t\t\t\t vport->port_state, ndlp->nlp_rpi,\n\t\t\t\t vport->fc_flag);\n\t} else {\n\t\t/* Xmit ELS response <elsCmd> to remote NPORT <did> */\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"0117 Xmit ELS response x%x to remote \"\n\t\t\t\t \"NPORT x%x I/O tag: x%x, size: x%x \"\n\t\t\t\t \"port_state x%x  rpi x%x fc_flag x%x\\n\",\n\t\t\t\t elscmd, ndlp->nlp_DID, elsiocb->iotag,\n\t\t\t\t cmdSize, vport->port_state,\n\t\t\t\t ndlp->nlp_rpi, vport->fc_flag);\n\t}\n\treturn elsiocb;\n\nels_iocb_free_pbuf_exit:\n\tif (expectRsp)\n\t\tlpfc_mbuf_free(phba, prsp->virt, prsp->phys);\n\tkfree(pbuflist);\n\nels_iocb_free_prsp_exit:\n\tlpfc_mbuf_free(phba, pcmd->virt, pcmd->phys);\n\tkfree(prsp);\n\nels_iocb_free_pcmb_exit:\n\tkfree(pcmd);\n\tlpfc_sli_release_iocbq(phba, elsiocb);\n\treturn NULL;\n}\n\n/**\n * lpfc_issue_fabric_reglogin - Issue fabric registration login for a vport\n * @vport: pointer to a host virtual N_Port data structure.\n *\n * This routine issues a fabric registration login for a @vport. An\n * active ndlp node with Fabric_DID must already exist for this @vport.\n * The routine invokes two mailbox commands to carry out fabric registration\n * login through the HBA firmware: the first mailbox command requests the\n * HBA to perform link configuration for the @vport; and the second mailbox\n * command requests the HBA to perform the actual fabric registration login\n * with the @vport.\n *\n * Return code\n *   0 - successfully issued fabric registration login for @vport\n *   -ENXIO -- failed to issue fabric registration login for @vport\n **/\nint\nlpfc_issue_fabric_reglogin(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tLPFC_MBOXQ_t *mbox;\n\tstruct lpfc_dmabuf *mp;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct serv_parm *sp;\n\tint rc;\n\tint err = 0;\n\n\tsp = &phba->fc_fabparam;\n\tndlp = lpfc_findnode_did(vport, Fabric_DID);\n\tif (!ndlp) {\n\t\terr = 1;\n\t\tgoto fail;\n\t}\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox) {\n\t\terr = 2;\n\t\tgoto fail;\n\t}\n\n\tvport->port_state = LPFC_FABRIC_CFG_LINK;\n\tlpfc_config_link(phba, mbox);\n\tmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\tmbox->vport = vport;\n\n\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\terr = 3;\n\t\tgoto fail_free_mbox;\n\t}\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox) {\n\t\terr = 4;\n\t\tgoto fail;\n\t}\n\trc = lpfc_reg_rpi(phba, vport->vpi, Fabric_DID, (uint8_t *)sp, mbox,\n\t\t\t  ndlp->nlp_rpi);\n\tif (rc) {\n\t\terr = 5;\n\t\tgoto fail_free_mbox;\n\t}\n\n\tmbox->mbox_cmpl = lpfc_mbx_cmpl_fabric_reg_login;\n\tmbox->vport = vport;\n\t/* increment the reference count on ndlp to hold reference\n\t * for the callback routine.\n\t */\n\tmbox->ctx_ndlp = lpfc_nlp_get(ndlp);\n\tif (!mbox->ctx_ndlp) {\n\t\terr = 6;\n\t\tgoto fail_no_ndlp;\n\t}\n\n\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\terr = 7;\n\t\tgoto fail_issue_reg_login;\n\t}\n\n\treturn 0;\n\nfail_issue_reg_login:\n\t/* decrement the reference count on ndlp just incremented\n\t * for the failed mbox command.\n\t */\n\tlpfc_nlp_put(ndlp);\nfail_no_ndlp:\n\tmp = (struct lpfc_dmabuf *)mbox->ctx_buf;\n\tlpfc_mbuf_free(phba, mp->virt, mp->phys);\n\tkfree(mp);\nfail_free_mbox:\n\tmempool_free(mbox, phba->mbox_mem_pool);\n\nfail:\n\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0249 Cannot issue Register Fabric login: Err %d\\n\",\n\t\t\t err);\n\treturn -ENXIO;\n}\n\n/**\n * lpfc_issue_reg_vfi - Register VFI for this vport's fabric login\n * @vport: pointer to a host virtual N_Port data structure.\n *\n * This routine issues a REG_VFI mailbox for the vfi, vpi, fcfi triplet for\n * the @vport. This mailbox command is necessary for SLI4 port only.\n *\n * Return code\n *   0 - successfully issued REG_VFI for @vport\n *   A failure code otherwise.\n **/\nint\nlpfc_issue_reg_vfi(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tLPFC_MBOXQ_t *mboxq = NULL;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_dmabuf *dmabuf = NULL;\n\tint rc = 0;\n\n\t/* move forward in case of SLI4 FC port loopback test and pt2pt mode */\n\tif ((phba->sli_rev == LPFC_SLI_REV4) &&\n\t    !(phba->link_flag & LS_LOOPBACK_MODE) &&\n\t    !(vport->fc_flag & FC_PT2PT)) {\n\t\tndlp = lpfc_findnode_did(vport, Fabric_DID);\n\t\tif (!ndlp) {\n\t\t\trc = -ENODEV;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mboxq) {\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t/* Supply CSP's only if we are fabric connect or pt-to-pt connect */\n\tif ((vport->fc_flag & FC_FABRIC) || (vport->fc_flag & FC_PT2PT)) {\n\t\tdmabuf = kzalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\n\t\tif (!dmabuf) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tdmabuf->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &dmabuf->phys);\n\t\tif (!dmabuf->virt) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tmemcpy(dmabuf->virt, &phba->fc_fabparam,\n\t\t       sizeof(struct serv_parm));\n\t}\n\n\tvport->port_state = LPFC_FABRIC_CFG_LINK;\n\tif (dmabuf)\n\t\tlpfc_reg_vfi(mboxq, vport, dmabuf->phys);\n\telse\n\t\tlpfc_reg_vfi(mboxq, vport, 0);\n\n\tmboxq->mbox_cmpl = lpfc_mbx_cmpl_reg_vfi;\n\tmboxq->vport = vport;\n\tmboxq->ctx_buf = dmabuf;\n\trc = lpfc_sli_issue_mbox(phba, mboxq, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\trc = -ENXIO;\n\t\tgoto fail;\n\t}\n\treturn 0;\n\nfail:\n\tif (mboxq)\n\t\tmempool_free(mboxq, phba->mbox_mem_pool);\n\tif (dmabuf) {\n\t\tif (dmabuf->virt)\n\t\t\tlpfc_mbuf_free(phba, dmabuf->virt, dmabuf->phys);\n\t\tkfree(dmabuf);\n\t}\n\n\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0289 Issue Register VFI failed: Err %d\\n\", rc);\n\treturn rc;\n}\n\n/**\n * lpfc_issue_unreg_vfi - Unregister VFI for this vport's fabric login\n * @vport: pointer to a host virtual N_Port data structure.\n *\n * This routine issues a UNREG_VFI mailbox with the vfi, vpi, fcfi triplet for\n * the @vport. This mailbox command is necessary for SLI4 port only.\n *\n * Return code\n *   0 - successfully issued REG_VFI for @vport\n *   A failure code otherwise.\n **/\nint\nlpfc_issue_unreg_vfi(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct Scsi_Host *shost;\n\tLPFC_MBOXQ_t *mboxq;\n\tint rc;\n\n\tmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mboxq) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2556 UNREG_VFI mbox allocation failed\"\n\t\t\t\t\"HBA state x%x\\n\", phba->pport->port_state);\n\t\treturn -ENOMEM;\n\t}\n\n\tlpfc_unreg_vfi(mboxq, vport);\n\tmboxq->vport = vport;\n\tmboxq->mbox_cmpl = lpfc_unregister_vfi_cmpl;\n\n\trc = lpfc_sli_issue_mbox(phba, mboxq, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2557 UNREG_VFI issue mbox failed rc x%x \"\n\t\t\t\t\"HBA state x%x\\n\",\n\t\t\t\trc, phba->pport->port_state);\n\t\tmempool_free(mboxq, phba->mbox_mem_pool);\n\t\treturn -EIO;\n\t}\n\n\tshost = lpfc_shost_from_vport(vport);\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag &= ~FC_VFI_REGISTERED;\n\tspin_unlock_irq(shost->host_lock);\n\treturn 0;\n}\n\n/**\n * lpfc_check_clean_addr_bit - Check whether assigned FCID is clean.\n * @vport: pointer to a host virtual N_Port data structure.\n * @sp: pointer to service parameter data structure.\n *\n * This routine is called from FLOGI/FDISC completion handler functions.\n * lpfc_check_clean_addr_bit return 1 when FCID/Fabric portname/ Fabric\n * node nodename is changed in the completion service parameter else return\n * 0. This function also set flag in the vport data structure to delay\n * NP_Port discovery after the FLOGI/FDISC completion if Clean address bit\n * in FLOGI/FDISC response is cleared and FCID/Fabric portname/ Fabric\n * node nodename is changed in the completion service parameter.\n *\n * Return code\n *   0 - FCID and Fabric Nodename and Fabric portname is not changed.\n *   1 - FCID or Fabric Nodename or Fabric portname is changed.\n *\n **/\nstatic uint8_t\nlpfc_check_clean_addr_bit(struct lpfc_vport *vport,\n\t\tstruct serv_parm *sp)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tuint8_t fabric_param_changed = 0;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\tif ((vport->fc_prevDID != vport->fc_myDID) ||\n\t\tmemcmp(&vport->fabric_portname, &sp->portName,\n\t\t\tsizeof(struct lpfc_name)) ||\n\t\tmemcmp(&vport->fabric_nodename, &sp->nodeName,\n\t\t\tsizeof(struct lpfc_name)) ||\n\t\t(vport->vport_flag & FAWWPN_PARAM_CHG)) {\n\t\tfabric_param_changed = 1;\n\t\tvport->vport_flag &= ~FAWWPN_PARAM_CHG;\n\t}\n\t/*\n\t * Word 1 Bit 31 in common service parameter is overloaded.\n\t * Word 1 Bit 31 in FLOGI request is multiple NPort request\n\t * Word 1 Bit 31 in FLOGI response is clean address bit\n\t *\n\t * If fabric parameter is changed and clean address bit is\n\t * cleared delay nport discovery if\n\t * - vport->fc_prevDID != 0 (not initial discovery) OR\n\t * - lpfc_delay_discovery module parameter is set.\n\t */\n\tif (fabric_param_changed && !sp->cmn.clean_address_bit &&\n\t    (vport->fc_prevDID || phba->cfg_delay_discovery)) {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag |= FC_DISC_DELAYED;\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\n\n\treturn fabric_param_changed;\n}\n\n\n/**\n * lpfc_cmpl_els_flogi_fabric - Completion function for flogi to a fabric port\n * @vport: pointer to a host virtual N_Port data structure.\n * @ndlp: pointer to a node-list data structure.\n * @sp: pointer to service parameter data structure.\n * @irsp: pointer to the IOCB within the lpfc response IOCB.\n *\n * This routine is invoked by the lpfc_cmpl_els_flogi() completion callback\n * function to handle the completion of a Fabric Login (FLOGI) into a fabric\n * port in a fabric topology. It properly sets up the parameters to the @ndlp\n * from the IOCB response. It also check the newly assigned N_Port ID to the\n * @vport against the previously assigned N_Port ID. If it is different from\n * the previously assigned Destination ID (DID), the lpfc_unreg_rpi() routine\n * is invoked on all the remaining nodes with the @vport to unregister the\n * Remote Port Indicators (RPIs). Finally, the lpfc_issue_fabric_reglogin()\n * is invoked to register login to the fabric.\n *\n * Return code\n *   0 - Success (currently, always return 0)\n **/\nstatic int\nlpfc_cmpl_els_flogi_fabric(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t   struct serv_parm *sp, IOCB_t *irsp)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_nodelist *np;\n\tstruct lpfc_nodelist *next_np;\n\tuint8_t fabric_param_changed;\n\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag |= FC_FABRIC;\n\tspin_unlock_irq(shost->host_lock);\n\n\tphba->fc_edtov = be32_to_cpu(sp->cmn.e_d_tov);\n\tif (sp->cmn.edtovResolution)\t/* E_D_TOV ticks are in nanoseconds */\n\t\tphba->fc_edtov = (phba->fc_edtov + 999999) / 1000000;\n\n\tphba->fc_edtovResol = sp->cmn.edtovResolution;\n\tphba->fc_ratov = (be32_to_cpu(sp->cmn.w2.r_a_tov) + 999) / 1000;\n\n\tif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag |= FC_PUBLIC_LOOP;\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\n\n\tvport->fc_myDID = irsp->un.ulpWord[4] & Mask_DID;\n\tmemcpy(&ndlp->nlp_portname, &sp->portName, sizeof(struct lpfc_name));\n\tmemcpy(&ndlp->nlp_nodename, &sp->nodeName, sizeof(struct lpfc_name));\n\tndlp->nlp_class_sup = 0;\n\tif (sp->cls1.classValid)\n\t\tndlp->nlp_class_sup |= FC_COS_CLASS1;\n\tif (sp->cls2.classValid)\n\t\tndlp->nlp_class_sup |= FC_COS_CLASS2;\n\tif (sp->cls3.classValid)\n\t\tndlp->nlp_class_sup |= FC_COS_CLASS3;\n\tif (sp->cls4.classValid)\n\t\tndlp->nlp_class_sup |= FC_COS_CLASS4;\n\tndlp->nlp_maxframe = ((sp->cmn.bbRcvSizeMsb & 0x0F) << 8) |\n\t\t\t\tsp->cmn.bbRcvSizeLsb;\n\n\tfabric_param_changed = lpfc_check_clean_addr_bit(vport, sp);\n\tif (fabric_param_changed) {\n\t\t/* Reset FDMI attribute masks based on config parameter */\n\t\tif (phba->cfg_enable_SmartSAN ||\n\t\t    (phba->cfg_fdmi_on == LPFC_FDMI_SUPPORT)) {\n\t\t\t/* Setup appropriate attribute masks */\n\t\t\tvport->fdmi_hba_mask = LPFC_FDMI2_HBA_ATTR;\n\t\t\tif (phba->cfg_enable_SmartSAN)\n\t\t\t\tvport->fdmi_port_mask = LPFC_FDMI2_SMART_ATTR;\n\t\t\telse\n\t\t\t\tvport->fdmi_port_mask = LPFC_FDMI2_PORT_ATTR;\n\t\t} else {\n\t\t\tvport->fdmi_hba_mask = 0;\n\t\t\tvport->fdmi_port_mask = 0;\n\t\t}\n\n\t}\n\tmemcpy(&vport->fabric_portname, &sp->portName,\n\t\t\tsizeof(struct lpfc_name));\n\tmemcpy(&vport->fabric_nodename, &sp->nodeName,\n\t\t\tsizeof(struct lpfc_name));\n\tmemcpy(&phba->fc_fabparam, sp, sizeof(struct serv_parm));\n\n\tif (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) {\n\t\tif (sp->cmn.response_multiple_NPort) {\n\t\t\tlpfc_printf_vlog(vport, KERN_WARNING,\n\t\t\t\t\t LOG_ELS | LOG_VPORT,\n\t\t\t\t\t \"1816 FLOGI NPIV supported, \"\n\t\t\t\t\t \"response data 0x%x\\n\",\n\t\t\t\t\t sp->cmn.response_multiple_NPort);\n\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\tphba->link_flag |= LS_NPIV_FAB_SUPPORTED;\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t} else {\n\t\t\t/* Because we asked f/w for NPIV it still expects us\n\t\t\tto call reg_vnpid atleast for the physcial host */\n\t\t\tlpfc_printf_vlog(vport, KERN_WARNING,\n\t\t\t\t\t LOG_ELS | LOG_VPORT,\n\t\t\t\t\t \"1817 Fabric does not support NPIV \"\n\t\t\t\t\t \"- configuring single port mode.\\n\");\n\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\tphba->link_flag &= ~LS_NPIV_FAB_SUPPORTED;\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t}\n\t}\n\n\t/*\n\t * For FC we need to do some special processing because of the SLI\n\t * Port's default settings of the Common Service Parameters.\n\t */\n\tif ((phba->sli_rev == LPFC_SLI_REV4) &&\n\t    (phba->sli4_hba.lnk_info.lnk_tp == LPFC_LNK_TYPE_FC)) {\n\t\t/* If physical FC port changed, unreg VFI and ALL VPIs / RPIs */\n\t\tif (fabric_param_changed)\n\t\t\tlpfc_unregister_fcf_prep(phba);\n\n\t\t/* This should just update the VFI CSPs*/\n\t\tif (vport->fc_flag & FC_VFI_REGISTERED)\n\t\t\tlpfc_issue_reg_vfi(vport);\n\t}\n\n\tif (fabric_param_changed &&\n\t\t!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)) {\n\n\t\t/* If our NportID changed, we need to ensure all\n\t\t * remaining NPORTs get unreg_login'ed.\n\t\t */\n\t\tlist_for_each_entry_safe(np, next_np,\n\t\t\t\t\t&vport->fc_nodes, nlp_listp) {\n\t\t\tif ((np->nlp_state != NLP_STE_NPR_NODE) ||\n\t\t\t\t   !(np->nlp_flag & NLP_NPR_ADISC))\n\t\t\t\tcontinue;\n\t\t\tspin_lock_irq(&np->lock);\n\t\t\tnp->nlp_flag &= ~NLP_NPR_ADISC;\n\t\t\tspin_unlock_irq(&np->lock);\n\t\t\tlpfc_unreg_rpi(vport, np);\n\t\t}\n\t\tlpfc_cleanup_pending_mbox(vport);\n\n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\tlpfc_sli4_unreg_all_rpis(vport);\n\t\t\tlpfc_mbx_unreg_vpi(vport);\n\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\tvport->fc_flag |= FC_VPORT_NEEDS_INIT_VPI;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t}\n\n\t\t/*\n\t\t * For SLI3 and SLI4, the VPI needs to be reregistered in\n\t\t * response to this fabric parameter change event.\n\t\t */\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\n\t\tspin_unlock_irq(shost->host_lock);\n\t} else if ((phba->sli_rev == LPFC_SLI_REV4) &&\n\t\t!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)) {\n\t\t\t/*\n\t\t\t * Driver needs to re-reg VPI in order for f/w\n\t\t\t * to update the MAC address.\n\t\t\t */\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\n\t\t\tlpfc_register_new_vport(phba, vport, ndlp);\n\t\t\treturn 0;\n\t}\n\n\tif (phba->sli_rev < LPFC_SLI_REV4) {\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_REG_LOGIN_ISSUE);\n\t\tif (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED &&\n\t\t    vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)\n\t\t\tlpfc_register_new_vport(phba, vport, ndlp);\n\t\telse\n\t\t\tlpfc_issue_fabric_reglogin(vport);\n\t} else {\n\t\tndlp->nlp_type |= NLP_FABRIC;\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\n\t\tif ((!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)) &&\n\t\t\t(vport->vpi_state & LPFC_VPI_REGISTERED)) {\n\t\t\tlpfc_start_fdiscs(phba);\n\t\t\tlpfc_do_scr_ns_plogi(phba, vport);\n\t\t} else if (vport->fc_flag & FC_VFI_REGISTERED)\n\t\t\tlpfc_issue_init_vpi(vport);\n\t\telse {\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t\t\"3135 Need register VFI: (x%x/%x)\\n\",\n\t\t\t\t\tvport->fc_prevDID, vport->fc_myDID);\n\t\t\tlpfc_issue_reg_vfi(vport);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * lpfc_cmpl_els_flogi_nport - Completion function for flogi to an N_Port\n * @vport: pointer to a host virtual N_Port data structure.\n * @ndlp: pointer to a node-list data structure.\n * @sp: pointer to service parameter data structure.\n *\n * This routine is invoked by the lpfc_cmpl_els_flogi() completion callback\n * function to handle the completion of a Fabric Login (FLOGI) into an N_Port\n * in a point-to-point topology. First, the @vport's N_Port Name is compared\n * with the received N_Port Name: if the @vport's N_Port Name is greater than\n * the received N_Port Name lexicographically, this node shall assign local\n * N_Port ID (PT2PT_LocalID: 1) and remote N_Port ID (PT2PT_RemoteID: 2) and\n * will send out Port Login (PLOGI) with the N_Port IDs assigned. Otherwise,\n * this node shall just wait for the remote node to issue PLOGI and assign\n * N_Port IDs.\n *\n * Return code\n *   0 - Success\n *   -ENXIO - Fail\n **/\nstatic int\nlpfc_cmpl_els_flogi_nport(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  struct serv_parm *sp)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tLPFC_MBOXQ_t *mbox;\n\tint rc;\n\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);\n\tvport->fc_flag |= FC_PT2PT;\n\tspin_unlock_irq(shost->host_lock);\n\n\t/* If we are pt2pt with another NPort, force NPIV off! */\n\tphba->sli3_options &= ~LPFC_SLI3_NPIV_ENABLED;\n\n\t/* If physical FC port changed, unreg VFI and ALL VPIs / RPIs */\n\tif ((phba->sli_rev == LPFC_SLI_REV4) && phba->fc_topology_changed) {\n\t\tlpfc_unregister_fcf_prep(phba);\n\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag &= ~FC_VFI_REGISTERED;\n\t\tspin_unlock_irq(shost->host_lock);\n\t\tphba->fc_topology_changed = 0;\n\t}\n\n\trc = memcmp(&vport->fc_portname, &sp->portName,\n\t\t    sizeof(vport->fc_portname));\n\n\tif (rc >= 0) {\n\t\t/* This side will initiate the PLOGI */\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag |= FC_PT2PT_PLOGI;\n\t\tspin_unlock_irq(shost->host_lock);\n\n\t\t/*\n\t\t * N_Port ID cannot be 0, set our Id to LocalID\n\t\t * the other side will be RemoteID.\n\t\t */\n\n\t\t/* not equal */\n\t\tif (rc)\n\t\t\tvport->fc_myDID = PT2PT_LocalID;\n\n\t\t/* Decrement ndlp reference count indicating that ndlp can be\n\t\t * safely released when other references to it are done.\n\t\t */\n\t\tlpfc_nlp_put(ndlp);\n\n\t\tndlp = lpfc_findnode_did(vport, PT2PT_RemoteID);\n\t\tif (!ndlp) {\n\t\t\t/*\n\t\t\t * Cannot find existing Fabric ndlp, so allocate a\n\t\t\t * new one\n\t\t\t */\n\t\t\tndlp = lpfc_nlp_init(vport, PT2PT_RemoteID);\n\t\t\tif (!ndlp)\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tmemcpy(&ndlp->nlp_portname, &sp->portName,\n\t\t       sizeof(struct lpfc_name));\n\t\tmemcpy(&ndlp->nlp_nodename, &sp->nodeName,\n\t\t       sizeof(struct lpfc_name));\n\t\t/* Set state will put ndlp onto node list if not already done */\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_NPR_2B_DISC;\n\t\tspin_unlock_irq(&ndlp->lock);\n\n\t\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\t\tif (!mbox)\n\t\t\tgoto fail;\n\n\t\tlpfc_config_link(phba, mbox);\n\n\t\tmbox->mbox_cmpl = lpfc_mbx_cmpl_local_config_link;\n\t\tmbox->vport = vport;\n\t\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\t\tif (rc == MBX_NOT_FINISHED) {\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\t/* This side will wait for the PLOGI, decrement ndlp reference\n\t\t * count indicating that ndlp can be released when other\n\t\t * references to it are done.\n\t\t */\n\t\tlpfc_nlp_put(ndlp);\n\n\t\t/* Start discovery - this should just do CLEAR_LA */\n\t\tlpfc_disc_start(vport);\n\t}\n\n\treturn 0;\nfail:\n\treturn -ENXIO;\n}\n\n/**\n * lpfc_cmpl_els_flogi - Completion callback function for flogi\n * @phba: pointer to lpfc hba data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @rspiocb: pointer to lpfc response iocb data structure.\n *\n * This routine is the top-level completion callback function for issuing\n * a Fabric Login (FLOGI) command. If the response IOCB reported error,\n * the lpfc_els_retry() routine shall be invoked to retry the FLOGI. If\n * retry has been made (either immediately or delayed with lpfc_els_retry()\n * returning 1), the command IOCB will be released and function returned.\n * If the retry attempt has been given up (possibly reach the maximum\n * number of retries), one additional decrement of ndlp reference shall be\n * invoked before going out after releasing the command IOCB. This will\n * actually release the remote node (Note, lpfc_els_free_iocb() will also\n * invoke one decrement of ndlp reference count). If no error reported in\n * the IOCB status, the command Port ID field is used to determine whether\n * this is a point-to-point topology or a fabric topology: if the Port ID\n * field is assigned, it is a fabric topology; otherwise, it is a\n * point-to-point topology. The routine lpfc_cmpl_els_flogi_fabric() or\n * lpfc_cmpl_els_flogi_nport() shall be invoked accordingly to handle the\n * specific topology completion conditions.\n **/\nstatic void\nlpfc_cmpl_els_flogi(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t    struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct Scsi_Host  *shost = lpfc_shost_from_vport(vport);\n\tIOCB_t *irsp = &rspiocb->iocb;\n\tstruct lpfc_nodelist *ndlp = cmdiocb->context1;\n\tstruct lpfc_dmabuf *pcmd = cmdiocb->context2, *prsp;\n\tstruct serv_parm *sp;\n\tuint16_t fcf_index;\n\tint rc;\n\n\t/* Check to see if link went down during discovery */\n\tif (lpfc_els_chk_latt(vport)) {\n\t\t/* One additional decrement on node reference count to\n\t\t * trigger the release of the node\n\t\t */\n\t\tlpfc_nlp_put(ndlp);\n\t\tgoto out;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"FLOGI cmpl:      status:x%x/x%x state:x%x\",\n\t\tirsp->ulpStatus, irsp->un.ulpWord[4],\n\t\tvport->port_state);\n\n\tif (irsp->ulpStatus) {\n\t\t/*\n\t\t * In case of FIP mode, perform roundrobin FCF failover\n\t\t * due to new FCF discovery\n\t\t */\n\t\tif ((phba->hba_flag & HBA_FIP_SUPPORT) &&\n\t\t    (phba->fcf.fcf_flag & FCF_DISCOVERY)) {\n\t\t\tif (phba->link_state < LPFC_LINK_UP)\n\t\t\t\tgoto stop_rr_fcf_flogi;\n\t\t\tif ((phba->fcoe_cvl_eventtag_attn ==\n\t\t\t     phba->fcoe_cvl_eventtag) &&\n\t\t\t    (irsp->ulpStatus == IOSTAT_LOCAL_REJECT) &&\n\t\t\t    ((irsp->un.ulpWord[4] & IOERR_PARAM_MASK) ==\n\t\t\t    IOERR_SLI_ABORTED))\n\t\t\t\tgoto stop_rr_fcf_flogi;\n\t\t\telse\n\t\t\t\tphba->fcoe_cvl_eventtag_attn =\n\t\t\t\t\tphba->fcoe_cvl_eventtag;\n\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FIP | LOG_ELS,\n\t\t\t\t\t\"2611 FLOGI failed on FCF (x%x), \"\n\t\t\t\t\t\"status:x%x/x%x, tmo:x%x, perform \"\n\t\t\t\t\t\"roundrobin FCF failover\\n\",\n\t\t\t\t\tphba->fcf.current_rec.fcf_indx,\n\t\t\t\t\tirsp->ulpStatus, irsp->un.ulpWord[4],\n\t\t\t\t\tirsp->ulpTimeout);\n\t\t\tlpfc_sli4_set_fcf_flogi_fail(phba,\n\t\t\t\t\tphba->fcf.current_rec.fcf_indx);\n\t\t\tfcf_index = lpfc_sli4_fcf_rr_next_index_get(phba);\n\t\t\trc = lpfc_sli4_fcf_rr_next_proc(vport, fcf_index);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\nstop_rr_fcf_flogi:\n\t\t/* FLOGI failure */\n\t\tif (!(irsp->ulpStatus == IOSTAT_LOCAL_REJECT &&\n\t\t      ((irsp->un.ulpWord[4] & IOERR_PARAM_MASK) ==\n\t\t\t\t\tIOERR_LOOP_OPEN_FAILURE)))\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"2858 FLOGI failure Status:x%x/x%x TMO\"\n\t\t\t\t\t \":x%x Data x%x x%x\\n\",\n\t\t\t\t\t irsp->ulpStatus, irsp->un.ulpWord[4],\n\t\t\t\t\t irsp->ulpTimeout, phba->hba_flag,\n\t\t\t\t\t phba->fcf.fcf_flag);\n\n\t\t/* Check for retry */\n\t\tif (lpfc_els_retry(phba, cmdiocb, rspiocb))\n\t\t\tgoto out;\n\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_TRACE_EVENT,\n\t\t\t\t \"0150 FLOGI failure Status:x%x/x%x \"\n\t\t\t\t \"xri x%x TMO:x%x\\n\",\n\t\t\t\t irsp->ulpStatus, irsp->un.ulpWord[4],\n\t\t\t\t cmdiocb->sli4_xritag, irsp->ulpTimeout);\n\n\t\t/* If this is not a loop open failure, bail out */\n\t\tif (!(irsp->ulpStatus == IOSTAT_LOCAL_REJECT &&\n\t\t      ((irsp->un.ulpWord[4] & IOERR_PARAM_MASK) ==\n\t\t\t\t\tIOERR_LOOP_OPEN_FAILURE)))\n\t\t\tgoto flogifail;\n\n\t\t/* FLOGI failed, so there is no fabric */\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);\n\t\tspin_unlock_irq(shost->host_lock);\n\n\t\t/* If private loop, then allow max outstanding els to be\n\t\t * LPFC_MAX_DISC_THREADS (32). Scanning in the case of no\n\t\t * alpa map would take too long otherwise.\n\t\t */\n\t\tif (phba->alpa_map[0] == 0)\n\t\t\tvport->cfg_discovery_threads = LPFC_MAX_DISC_THREADS;\n\t\tif ((phba->sli_rev == LPFC_SLI_REV4) &&\n\t\t    (!(vport->fc_flag & FC_VFI_REGISTERED) ||\n\t\t     (vport->fc_prevDID != vport->fc_myDID) ||\n\t\t\tphba->fc_topology_changed)) {\n\t\t\tif (vport->fc_flag & FC_VFI_REGISTERED) {\n\t\t\t\tif (phba->fc_topology_changed) {\n\t\t\t\t\tlpfc_unregister_fcf_prep(phba);\n\t\t\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\t\t\tvport->fc_flag &= ~FC_VFI_REGISTERED;\n\t\t\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t\t\tphba->fc_topology_changed = 0;\n\t\t\t\t} else {\n\t\t\t\t\tlpfc_sli4_unreg_all_rpis(vport);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Do not register VFI if the driver aborted FLOGI */\n\t\t\tif (!lpfc_error_lost_link(irsp))\n\t\t\t\tlpfc_issue_reg_vfi(vport);\n\n\t\t\tlpfc_nlp_put(ndlp);\n\t\t\tgoto out;\n\t\t}\n\t\tgoto flogifail;\n\t}\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag &= ~FC_VPORT_CVL_RCVD;\n\tvport->fc_flag &= ~FC_VPORT_LOGO_RCVD;\n\tspin_unlock_irq(shost->host_lock);\n\n\t/*\n\t * The FLogI succeeded.  Sync the data for the CPU before\n\t * accessing it.\n\t */\n\tprsp = list_get_first(&pcmd->list, struct lpfc_dmabuf, list);\n\tif (!prsp)\n\t\tgoto out;\n\tsp = prsp->virt + sizeof(uint32_t);\n\n\t/* FLOGI completes successfully */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0101 FLOGI completes successfully, I/O tag:x%x, \"\n\t\t\t \"xri x%x Data: x%x x%x x%x x%x x%x %x\\n\",\n\t\t\t cmdiocb->iotag, cmdiocb->sli4_xritag,\n\t\t\t irsp->un.ulpWord[4], sp->cmn.e_d_tov,\n\t\t\t sp->cmn.w2.r_a_tov, sp->cmn.edtovResolution,\n\t\t\t vport->port_state, vport->fc_flag);\n\n\tif (vport->port_state == LPFC_FLOGI) {\n\t\t/*\n\t\t * If Common Service Parameters indicate Nport\n\t\t * we are point to point, if Fport we are Fabric.\n\t\t */\n\t\tif (sp->cmn.fPort)\n\t\t\trc = lpfc_cmpl_els_flogi_fabric(vport, ndlp, sp, irsp);\n\t\telse if (!(phba->hba_flag & HBA_FCOE_MODE))\n\t\t\trc = lpfc_cmpl_els_flogi_nport(vport, ndlp, sp);\n\t\telse {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2831 FLOGI response with cleared Fabric \"\n\t\t\t\t\"bit fcf_index 0x%x \"\n\t\t\t\t\"Switch Name %02x%02x%02x%02x%02x%02x%02x%02x \"\n\t\t\t\t\"Fabric Name \"\n\t\t\t\t\"%02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\t\t\tphba->fcf.current_rec.fcf_indx,\n\t\t\t\tphba->fcf.current_rec.switch_name[0],\n\t\t\t\tphba->fcf.current_rec.switch_name[1],\n\t\t\t\tphba->fcf.current_rec.switch_name[2],\n\t\t\t\tphba->fcf.current_rec.switch_name[3],\n\t\t\t\tphba->fcf.current_rec.switch_name[4],\n\t\t\t\tphba->fcf.current_rec.switch_name[5],\n\t\t\t\tphba->fcf.current_rec.switch_name[6],\n\t\t\t\tphba->fcf.current_rec.switch_name[7],\n\t\t\t\tphba->fcf.current_rec.fabric_name[0],\n\t\t\t\tphba->fcf.current_rec.fabric_name[1],\n\t\t\t\tphba->fcf.current_rec.fabric_name[2],\n\t\t\t\tphba->fcf.current_rec.fabric_name[3],\n\t\t\t\tphba->fcf.current_rec.fabric_name[4],\n\t\t\t\tphba->fcf.current_rec.fabric_name[5],\n\t\t\t\tphba->fcf.current_rec.fabric_name[6],\n\t\t\t\tphba->fcf.current_rec.fabric_name[7]);\n\n\t\t\tlpfc_nlp_put(ndlp);\n\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\tphba->fcf.fcf_flag &= ~FCF_DISCOVERY;\n\t\t\tphba->hba_flag &= ~(FCF_RR_INPROG | HBA_DEVLOSS_TMO);\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\tphba->fcf.fcf_redisc_attempted = 0; /* reset */\n\t\t\tgoto out;\n\t\t}\n\t\tif (!rc) {\n\t\t\t/* Mark the FCF discovery process done */\n\t\t\tif (phba->hba_flag & HBA_FIP_SUPPORT)\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FIP |\n\t\t\t\t\t\tLOG_ELS,\n\t\t\t\t\t\t\"2769 FLOGI to FCF (x%x) \"\n\t\t\t\t\t\t\"completed successfully\\n\",\n\t\t\t\t\t\tphba->fcf.current_rec.fcf_indx);\n\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\tphba->fcf.fcf_flag &= ~FCF_DISCOVERY;\n\t\t\tphba->hba_flag &= ~(FCF_RR_INPROG | HBA_DEVLOSS_TMO);\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\tphba->fcf.fcf_redisc_attempted = 0; /* reset */\n\t\t\tgoto out;\n\t\t}\n\t}\n\nflogifail:\n\tspin_lock_irq(&phba->hbalock);\n\tphba->fcf.fcf_flag &= ~FCF_DISCOVERY;\n\tspin_unlock_irq(&phba->hbalock);\n\n\tlpfc_nlp_put(ndlp);\n\tif (!lpfc_error_lost_link(irsp)) {\n\t\t/* FLOGI failed, so just use loop map to make discovery list */\n\t\tlpfc_disc_list_loopmap(vport);\n\n\t\t/* Start discovery */\n\t\tlpfc_disc_start(vport);\n\t} else if (((irsp->ulpStatus != IOSTAT_LOCAL_REJECT) ||\n\t\t\t(((irsp->un.ulpWord[4] & IOERR_PARAM_MASK) !=\n\t\t\t IOERR_SLI_ABORTED) &&\n\t\t\t((irsp->un.ulpWord[4] & IOERR_PARAM_MASK) !=\n\t\t\t IOERR_SLI_DOWN))) &&\n\t\t\t(phba->link_state != LPFC_CLEAR_LA)) {\n\t\t/* If FLOGI failed enable link interrupt. */\n\t\tlpfc_issue_clear_la(phba, vport);\n\t}\nout:\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n}\n\n/**\n * lpfc_cmpl_els_link_down - Completion callback function for ELS command\n *                           aborted during a link down\n * @phba: pointer to lpfc hba data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @rspiocb: pointer to lpfc response iocb data structure.\n *\n */\nstatic void\nlpfc_cmpl_els_link_down(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t\tstruct lpfc_iocbq *rspiocb)\n{\n\tIOCB_t *irsp;\n\tuint32_t *pcmd;\n\tuint32_t cmd;\n\n\tpcmd = (uint32_t *)(((struct lpfc_dmabuf *)cmdiocb->context2)->virt);\n\tcmd = *pcmd;\n\tirsp = &rspiocb->iocb;\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_ELS,\n\t\t\t\"6445 ELS completes after LINK_DOWN: \"\n\t\t\t\" Status %x/%x cmd x%x flg x%x\\n\",\n\t\t\tirsp->ulpStatus, irsp->un.ulpWord[4], cmd,\n\t\t\tcmdiocb->iocb_flag);\n\n\tif (cmdiocb->iocb_flag & LPFC_IO_FABRIC) {\n\t\tcmdiocb->iocb_flag &= ~LPFC_IO_FABRIC;\n\t\tatomic_dec(&phba->fabric_iocb_count);\n\t}\n\tlpfc_els_free_iocb(phba, cmdiocb);\n}\n\n/**\n * lpfc_issue_els_flogi - Issue an flogi iocb command for a vport\n * @vport: pointer to a host virtual N_Port data structure.\n * @ndlp: pointer to a node-list data structure.\n * @retry: number of retries to the command IOCB.\n *\n * This routine issues a Fabric Login (FLOGI) Request ELS command\n * for a @vport. The initiator service parameters are put into the payload\n * of the FLOGI Request IOCB and the top-level callback function pointer\n * to lpfc_cmpl_els_flogi() routine is put to the IOCB completion callback\n * function field. The lpfc_issue_fabric_iocb routine is invoked to send\n * out FLOGI ELS command with one outstanding fabric IOCB at a time.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the FLOGI ELS command.\n *\n * Return code\n *   0 - successfully issued flogi iocb for @vport\n *   1 - failed to issue flogi iocb for @vport\n **/\nstatic int\nlpfc_issue_els_flogi(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t     uint8_t retry)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct serv_parm *sp;\n\tIOCB_t *icmd;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct lpfc_iocbq defer_flogi_acc;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tuint32_t tmo, did;\n\tint rc;\n\n\tcmdsize = (sizeof(uint32_t) + sizeof(struct serv_parm));\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_FLOGI);\n\n\tif (!elsiocb)\n\t\treturn 1;\n\n\ticmd = &elsiocb->iocb;\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\n\t/* For FLOGI request, remainder of payload is service parameters */\n\t*((uint32_t *) (pcmd)) = ELS_CMD_FLOGI;\n\tpcmd += sizeof(uint32_t);\n\tmemcpy(pcmd, &vport->fc_sparam, sizeof(struct serv_parm));\n\tsp = (struct serv_parm *) pcmd;\n\n\t/* Setup CSPs accordingly for Fabric */\n\tsp->cmn.e_d_tov = 0;\n\tsp->cmn.w2.r_a_tov = 0;\n\tsp->cmn.virtual_fabric_support = 0;\n\tsp->cls1.classValid = 0;\n\tif (sp->cmn.fcphLow < FC_PH3)\n\t\tsp->cmn.fcphLow = FC_PH3;\n\tif (sp->cmn.fcphHigh < FC_PH3)\n\t\tsp->cmn.fcphHigh = FC_PH3;\n\n\tif  (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tif (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) ==\n\t\t    LPFC_SLI_INTF_IF_TYPE_0) {\n\t\t\telsiocb->iocb.ulpCt_h = ((SLI4_CT_FCFI >> 1) & 1);\n\t\t\telsiocb->iocb.ulpCt_l = (SLI4_CT_FCFI & 1);\n\t\t\t/* FLOGI needs to be 3 for WQE FCFI */\n\t\t\t/* Set the fcfi to the fcfi we registered with */\n\t\t\telsiocb->iocb.ulpContext = phba->fcf.fcfi;\n\t\t}\n\t\t/* Can't do SLI4 class2 without support sequence coalescing */\n\t\tsp->cls2.classValid = 0;\n\t\tsp->cls2.seqDelivery = 0;\n\t} else {\n\t\t/* Historical, setting sequential-delivery bit for SLI3 */\n\t\tsp->cls2.seqDelivery = (sp->cls2.classValid) ? 1 : 0;\n\t\tsp->cls3.seqDelivery = (sp->cls3.classValid) ? 1 : 0;\n\t\tif (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) {\n\t\t\tsp->cmn.request_multiple_Nport = 1;\n\t\t\t/* For FLOGI, Let FLOGI rsp set the NPortID for VPI 0 */\n\t\t\ticmd->ulpCt_h = 1;\n\t\t\ticmd->ulpCt_l = 0;\n\t\t} else\n\t\t\tsp->cmn.request_multiple_Nport = 0;\n\t}\n\n\tif (phba->fc_topology != LPFC_TOPOLOGY_LOOP) {\n\t\ticmd->un.elsreq64.myID = 0;\n\t\ticmd->un.elsreq64.fl = 1;\n\t}\n\n\ttmo = phba->fc_ratov;\n\tphba->fc_ratov = LPFC_DISC_FLOGI_TMO;\n\tlpfc_set_disctmo(vport);\n\tphba->fc_ratov = tmo;\n\n\tphba->fc_stat.elsXmitFLOGI++;\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_flogi;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Issue FLOGI:     opt:x%x\",\n\t\tphba->sli3_options, 0, 0);\n\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto out;\n\n\trc = lpfc_issue_fabric_iocb(phba, elsiocb);\n\tif (rc == IOCB_ERROR)\n\t\tlpfc_nlp_put(ndlp);\n\n\tphba->hba_flag |= HBA_FLOGI_ISSUED;\n\n\t/* Check for a deferred FLOGI ACC condition */\n\tif (phba->defer_flogi_acc_flag) {\n\t\tdid = vport->fc_myDID;\n\t\tvport->fc_myDID = Fabric_DID;\n\n\t\tmemset(&defer_flogi_acc, 0, sizeof(struct lpfc_iocbq));\n\n\t\tdefer_flogi_acc.iocb.ulpContext = phba->defer_flogi_acc_rx_id;\n\t\tdefer_flogi_acc.iocb.unsli3.rcvsli3.ox_id =\n\t\t\t\t\t\tphba->defer_flogi_acc_ox_id;\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"3354 Xmit deferred FLOGI ACC: rx_id: x%x,\"\n\t\t\t\t \" ox_id: x%x, hba_flag x%x\\n\",\n\t\t\t\t phba->defer_flogi_acc_rx_id,\n\t\t\t\t phba->defer_flogi_acc_ox_id, phba->hba_flag);\n\n\t\t/* Send deferred FLOGI ACC */\n\t\tlpfc_els_rsp_acc(vport, ELS_CMD_FLOGI, &defer_flogi_acc,\n\t\t\t\t ndlp, NULL);\n\n\t\tphba->defer_flogi_acc_flag = false;\n\n\t\tvport->fc_myDID = did;\n\t}\n\n\tif (!rc)\n\t\treturn 0;\n out:\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn 1;\n}\n\n/**\n * lpfc_els_abort_flogi - Abort all outstanding flogi iocbs\n * @phba: pointer to lpfc hba data structure.\n *\n * This routine aborts all the outstanding Fabric Login (FLOGI) IOCBs\n * with a @phba. This routine walks all the outstanding IOCBs on the txcmplq\n * list and issues an abort IOCB commond on each outstanding IOCB that\n * contains a active Fabric_DID ndlp. Note that this function is to issue\n * the abort IOCB command on all the outstanding IOCBs, thus when this\n * function returns, it does not guarantee all the IOCBs are actually aborted.\n *\n * Return code\n *   0 - Successfully issued abort iocb on all outstanding flogis (Always 0)\n **/\nint\nlpfc_els_abort_flogi(struct lpfc_hba *phba)\n{\n\tstruct lpfc_sli_ring *pring;\n\tstruct lpfc_iocbq *iocb, *next_iocb;\n\tstruct lpfc_nodelist *ndlp;\n\tIOCB_t *icmd;\n\n\t/* Abort outstanding I/O on NPort <nlp_DID> */\n\tlpfc_printf_log(phba, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\"0201 Abort outstanding I/O on NPort x%x\\n\",\n\t\t\tFabric_DID);\n\n\tpring = lpfc_phba_elsring(phba);\n\tif (unlikely(!pring))\n\t\treturn -EIO;\n\n\t/*\n\t * Check the txcmplq for an iocb that matches the nport the driver is\n\t * searching for.\n\t */\n\tspin_lock_irq(&phba->hbalock);\n\tlist_for_each_entry_safe(iocb, next_iocb, &pring->txcmplq, list) {\n\t\ticmd = &iocb->iocb;\n\t\tif (icmd->ulpCommand == CMD_ELS_REQUEST64_CR) {\n\t\t\tndlp = (struct lpfc_nodelist *)(iocb->context1);\n\t\t\tif (ndlp && (ndlp->nlp_DID == Fabric_DID))\n\t\t\t\tlpfc_sli_issue_abort_iotag(phba, pring, iocb,\n\t\t\t\t\t\t\t   NULL);\n\t\t}\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\n\treturn 0;\n}\n\n/**\n * lpfc_initial_flogi - Issue an initial fabric login for a vport\n * @vport: pointer to a host virtual N_Port data structure.\n *\n * This routine issues an initial Fabric Login (FLOGI) for the @vport\n * specified. It first searches the ndlp with the Fabric_DID (0xfffffe) from\n * the @vport's ndlp list. If no such ndlp found, it will create an ndlp and\n * put it into the @vport's ndlp list. If an inactive ndlp found on the list,\n * it will just be enabled and made active. The lpfc_issue_els_flogi() routine\n * is then invoked with the @vport and the ndlp to perform the FLOGI for the\n * @vport.\n *\n * Return code\n *   0 - failed to issue initial flogi for @vport\n *   1 - successfully issued initial flogi for @vport\n **/\nint\nlpfc_initial_flogi(struct lpfc_vport *vport)\n{\n\tstruct lpfc_nodelist *ndlp;\n\n\tvport->port_state = LPFC_FLOGI;\n\tlpfc_set_disctmo(vport);\n\n\t/* First look for the Fabric ndlp */\n\tndlp = lpfc_findnode_did(vport, Fabric_DID);\n\tif (!ndlp) {\n\t\t/* Cannot find existing Fabric ndlp, so allocate a new one */\n\t\tndlp = lpfc_nlp_init(vport, Fabric_DID);\n\t\tif (!ndlp)\n\t\t\treturn 0;\n\t\t/* Set the node type */\n\t\tndlp->nlp_type |= NLP_FABRIC;\n\n\t\t/* Put ndlp onto node list */\n\t\tlpfc_enqueue_node(vport, ndlp);\n\t}\n\n\tif (lpfc_issue_els_flogi(vport, ndlp, 0)) {\n\t\t/* This decrement of reference count to node shall kick off\n\t\t * the release of the node.\n\t\t */\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/**\n * lpfc_initial_fdisc - Issue an initial fabric discovery for a vport\n * @vport: pointer to a host virtual N_Port data structure.\n *\n * This routine issues an initial Fabric Discover (FDISC) for the @vport\n * specified. It first searches the ndlp with the Fabric_DID (0xfffffe) from\n * the @vport's ndlp list. If no such ndlp found, it will create an ndlp and\n * put it into the @vport's ndlp list. If an inactive ndlp found on the list,\n * it will just be enabled and made active. The lpfc_issue_els_fdisc() routine\n * is then invoked with the @vport and the ndlp to perform the FDISC for the\n * @vport.\n *\n * Return code\n *   0 - failed to issue initial fdisc for @vport\n *   1 - successfully issued initial fdisc for @vport\n **/\nint\nlpfc_initial_fdisc(struct lpfc_vport *vport)\n{\n\tstruct lpfc_nodelist *ndlp;\n\n\t/* First look for the Fabric ndlp */\n\tndlp = lpfc_findnode_did(vport, Fabric_DID);\n\tif (!ndlp) {\n\t\t/* Cannot find existing Fabric ndlp, so allocate a new one */\n\t\tndlp = lpfc_nlp_init(vport, Fabric_DID);\n\t\tif (!ndlp)\n\t\t\treturn 0;\n\n\t\t/* NPIV is only supported in Fabrics. */\n\t\tndlp->nlp_type |= NLP_FABRIC;\n\n\t\t/* Put ndlp onto node list */\n\t\tlpfc_enqueue_node(vport, ndlp);\n\t}\n\n\tif (lpfc_issue_els_fdisc(vport, ndlp, 0)) {\n\t\t/* decrement node reference count to trigger the release of\n\t\t * the node.\n\t\t */\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/**\n * lpfc_more_plogi - Check and issue remaining plogis for a vport\n * @vport: pointer to a host virtual N_Port data structure.\n *\n * This routine checks whether there are more remaining Port Logins\n * (PLOGI) to be issued for the @vport. If so, it will invoke the routine\n * lpfc_els_disc_plogi() to go through the Node Port Recovery (NPR) nodes\n * to issue ELS PLOGIs up to the configured discover threads with the\n * @vport (@vport->cfg_discovery_threads). The function also decrement\n * the @vport's num_disc_node by 1 if it is not already 0.\n **/\nvoid\nlpfc_more_plogi(struct lpfc_vport *vport)\n{\n\tif (vport->num_disc_nodes)\n\t\tvport->num_disc_nodes--;\n\n\t/* Continue discovery with <num_disc_nodes> PLOGIs to go */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"0232 Continue discovery with %d PLOGIs to go \"\n\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t vport->num_disc_nodes, vport->fc_plogi_cnt,\n\t\t\t vport->fc_flag, vport->port_state);\n\t/* Check to see if there are more PLOGIs to be sent */\n\tif (vport->fc_flag & FC_NLP_MORE)\n\t\t/* go thru NPR nodes and issue any remaining ELS PLOGIs */\n\t\tlpfc_els_disc_plogi(vport);\n\n\treturn;\n}\n\n/**\n * lpfc_plogi_confirm_nport - Confirm plogi wwpn matches stored ndlp\n * @phba: pointer to lpfc hba data structure.\n * @prsp: pointer to response IOCB payload.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine checks and indicates whether the WWPN of an N_Port, retrieved\n * from a PLOGI, matches the WWPN that is stored in the @ndlp for that N_POrt.\n * The following cases are considered N_Port confirmed:\n * 1) The N_Port is a Fabric ndlp; 2) The @ndlp is on vport list and matches\n * the WWPN of the N_Port logged into; 3) The @ndlp is not on vport list but\n * it does not have WWPN assigned either. If the WWPN is confirmed, the\n * pointer to the @ndlp will be returned. If the WWPN is not confirmed:\n * 1) if there is a node on vport list other than the @ndlp with the same\n * WWPN of the N_Port PLOGI logged into, the lpfc_unreg_rpi() will be invoked\n * on that node to release the RPI associated with the node; 2) if there is\n * no node found on vport list with the same WWPN of the N_Port PLOGI logged\n * into, a new node shall be allocated (or activated). In either case, the\n * parameters of the @ndlp shall be copied to the new_ndlp, the @ndlp shall\n * be released and the new_ndlp shall be put on to the vport node list and\n * its pointer returned as the confirmed node.\n *\n * Note that before the @ndlp got \"released\", the keepDID from not-matching\n * or inactive \"new_ndlp\" on the vport node list is assigned to the nlp_DID\n * of the @ndlp. This is because the release of @ndlp is actually to put it\n * into an inactive state on the vport node list and the vport node list\n * management algorithm does not allow two node with a same DID.\n *\n * Return code\n *   pointer to the PLOGI N_Port @ndlp\n **/\nstatic struct lpfc_nodelist *\nlpfc_plogi_confirm_nport(struct lpfc_hba *phba, uint32_t *prsp,\n\t\t\t struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_vport *vport = ndlp->vport;\n\tstruct lpfc_nodelist *new_ndlp;\n\tstruct serv_parm *sp;\n\tuint8_t  name[sizeof(struct lpfc_name)];\n\tuint32_t rc, keepDID = 0, keep_nlp_flag = 0;\n\tuint32_t keep_new_nlp_flag = 0;\n\tuint16_t keep_nlp_state;\n\tu32 keep_nlp_fc4_type = 0;\n\tstruct lpfc_nvme_rport *keep_nrport = NULL;\n\tunsigned long *active_rrqs_xri_bitmap = NULL;\n\n\t/* Fabric nodes can have the same WWPN so we don't bother searching\n\t * by WWPN.  Just return the ndlp that was given to us.\n\t */\n\tif (ndlp->nlp_type & NLP_FABRIC)\n\t\treturn ndlp;\n\n\tsp = (struct serv_parm *) ((uint8_t *) prsp + sizeof(uint32_t));\n\tmemset(name, 0, sizeof(struct lpfc_name));\n\n\t/* Now we find out if the NPort we are logging into, matches the WWPN\n\t * we have for that ndlp. If not, we have some work to do.\n\t */\n\tnew_ndlp = lpfc_findnode_wwpn(vport, &sp->portName);\n\n\t/* return immediately if the WWPN matches ndlp */\n\tif (new_ndlp == ndlp)\n\t\treturn ndlp;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tactive_rrqs_xri_bitmap = mempool_alloc(phba->active_rrq_pool,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\tif (active_rrqs_xri_bitmap)\n\t\t\tmemset(active_rrqs_xri_bitmap, 0,\n\t\t\t       phba->cfg_rrq_xri_bitmap_sz);\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS | LOG_NODE,\n\t\t\t \"3178 PLOGI confirm: ndlp x%x x%x x%x: \"\n\t\t\t \"new_ndlp x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag,  ndlp->nlp_fc4_type,\n\t\t\t (new_ndlp ? new_ndlp->nlp_DID : 0),\n\t\t\t (new_ndlp ? new_ndlp->nlp_flag : 0),\n\t\t\t (new_ndlp ? new_ndlp->nlp_fc4_type : 0));\n\n\tif (!new_ndlp) {\n\t\trc = memcmp(&ndlp->nlp_portname, name,\n\t\t\t    sizeof(struct lpfc_name));\n\t\tif (!rc) {\n\t\t\tif (active_rrqs_xri_bitmap)\n\t\t\t\tmempool_free(active_rrqs_xri_bitmap,\n\t\t\t\t\t     phba->active_rrq_pool);\n\t\t\treturn ndlp;\n\t\t}\n\t\tnew_ndlp = lpfc_nlp_init(vport, ndlp->nlp_DID);\n\t\tif (!new_ndlp) {\n\t\t\tif (active_rrqs_xri_bitmap)\n\t\t\t\tmempool_free(active_rrqs_xri_bitmap,\n\t\t\t\t\t     phba->active_rrq_pool);\n\t\t\treturn ndlp;\n\t\t}\n\t} else {\n\t\tkeepDID = new_ndlp->nlp_DID;\n\t\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t\t    active_rrqs_xri_bitmap)\n\t\t\tmemcpy(active_rrqs_xri_bitmap,\n\t\t\t       new_ndlp->active_rrqs_xri_bitmap,\n\t\t\t       phba->cfg_rrq_xri_bitmap_sz);\n\t}\n\n\t/* At this point in this routine, we know new_ndlp will be\n\t * returned. however, any previous GID_FTs that were done\n\t * would have updated nlp_fc4_type in ndlp, so we must ensure\n\t * new_ndlp has the right value.\n\t */\n\tif (vport->fc_flag & FC_FABRIC) {\n\t\tkeep_nlp_fc4_type = new_ndlp->nlp_fc4_type;\n\t\tnew_ndlp->nlp_fc4_type = ndlp->nlp_fc4_type;\n\t}\n\n\tlpfc_unreg_rpi(vport, new_ndlp);\n\tnew_ndlp->nlp_DID = ndlp->nlp_DID;\n\tnew_ndlp->nlp_prev_state = ndlp->nlp_prev_state;\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tmemcpy(new_ndlp->active_rrqs_xri_bitmap,\n\t\t       ndlp->active_rrqs_xri_bitmap,\n\t\t       phba->cfg_rrq_xri_bitmap_sz);\n\n\t/* Lock both ndlps */\n\tspin_lock_irq(&ndlp->lock);\n\tspin_lock_irq(&new_ndlp->lock);\n\tkeep_new_nlp_flag = new_ndlp->nlp_flag;\n\tkeep_nlp_flag = ndlp->nlp_flag;\n\tnew_ndlp->nlp_flag = ndlp->nlp_flag;\n\n\t/* if new_ndlp had NLP_UNREG_INP set, keep it */\n\tif (keep_new_nlp_flag & NLP_UNREG_INP)\n\t\tnew_ndlp->nlp_flag |= NLP_UNREG_INP;\n\telse\n\t\tnew_ndlp->nlp_flag &= ~NLP_UNREG_INP;\n\n\t/* if new_ndlp had NLP_RPI_REGISTERED set, keep it */\n\tif (keep_new_nlp_flag & NLP_RPI_REGISTERED)\n\t\tnew_ndlp->nlp_flag |= NLP_RPI_REGISTERED;\n\telse\n\t\tnew_ndlp->nlp_flag &= ~NLP_RPI_REGISTERED;\n\n\tndlp->nlp_flag = keep_new_nlp_flag;\n\n\t/* if ndlp had NLP_UNREG_INP set, keep it */\n\tif (keep_nlp_flag & NLP_UNREG_INP)\n\t\tndlp->nlp_flag |= NLP_UNREG_INP;\n\telse\n\t\tndlp->nlp_flag &= ~NLP_UNREG_INP;\n\n\t/* if ndlp had NLP_RPI_REGISTERED set, keep it */\n\tif (keep_nlp_flag & NLP_RPI_REGISTERED)\n\t\tndlp->nlp_flag |= NLP_RPI_REGISTERED;\n\telse\n\t\tndlp->nlp_flag &= ~NLP_RPI_REGISTERED;\n\n\tspin_unlock_irq(&new_ndlp->lock);\n\tspin_unlock_irq(&ndlp->lock);\n\n\t/* Set nlp_states accordingly */\n\tkeep_nlp_state = new_ndlp->nlp_state;\n\tlpfc_nlp_set_state(vport, new_ndlp, ndlp->nlp_state);\n\n\t/* interchange the nvme remoteport structs */\n\tkeep_nrport = new_ndlp->nrport;\n\tnew_ndlp->nrport = ndlp->nrport;\n\n\t/* Move this back to NPR state */\n\tif (memcmp(&ndlp->nlp_portname, name, sizeof(struct lpfc_name)) == 0) {\n\t\t/* The new_ndlp is replacing ndlp totally, so we need\n\t\t * to put ndlp on UNUSED list and try to free it.\n\t\t */\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"3179 PLOGI confirm NEW: %x %x\\n\",\n\t\t\t new_ndlp->nlp_DID, keepDID);\n\n\t\t/* Two ndlps cannot have the same did on the nodelist.\n\t\t * Note: for this case, ndlp has a NULL WWPN so setting\n\t\t * the nlp_fc4_type isn't required.\n\t\t */\n\t\tndlp->nlp_DID = keepDID;\n\t\tlpfc_nlp_set_state(vport, ndlp, keep_nlp_state);\n\t\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t\t    active_rrqs_xri_bitmap)\n\t\t\tmemcpy(ndlp->active_rrqs_xri_bitmap,\n\t\t\t       active_rrqs_xri_bitmap,\n\t\t\t       phba->cfg_rrq_xri_bitmap_sz);\n\n\t} else {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"3180 PLOGI confirm SWAP: %x %x\\n\",\n\t\t\t new_ndlp->nlp_DID, keepDID);\n\n\t\tlpfc_unreg_rpi(vport, ndlp);\n\n\t\t/* Two ndlps cannot have the same did and the fc4\n\t\t * type must be transferred because the ndlp is in\n\t\t * flight.\n\t\t */\n\t\tndlp->nlp_DID = keepDID;\n\t\tndlp->nlp_fc4_type = keep_nlp_fc4_type;\n\n\t\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t\t    active_rrqs_xri_bitmap)\n\t\t\tmemcpy(ndlp->active_rrqs_xri_bitmap,\n\t\t\t       active_rrqs_xri_bitmap,\n\t\t\t       phba->cfg_rrq_xri_bitmap_sz);\n\n\t\t/* Since we are switching over to the new_ndlp,\n\t\t * reset the old ndlp state\n\t\t */\n\t\tif ((ndlp->nlp_state == NLP_STE_UNMAPPED_NODE) ||\n\t\t    (ndlp->nlp_state == NLP_STE_MAPPED_NODE))\n\t\t\tkeep_nlp_state = NLP_STE_NPR_NODE;\n\t\tlpfc_nlp_set_state(vport, ndlp, keep_nlp_state);\n\t\tndlp->nrport = keep_nrport;\n\t}\n\n\t/*\n\t * If ndlp is not associated with any rport we can drop it here else\n\t * let dev_loss_tmo_callbk trigger DEVICE_RM event\n\t */\n\tif (!ndlp->rport && (ndlp->nlp_state == NLP_STE_NPR_NODE))\n\t\tlpfc_disc_state_machine(vport, ndlp, NULL, NLP_EVT_DEVICE_RM);\n\n\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t    active_rrqs_xri_bitmap)\n\t\tmempool_free(active_rrqs_xri_bitmap,\n\t\t\t     phba->active_rrq_pool);\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS | LOG_NODE,\n\t\t\t \"3173 PLOGI confirm exit: new_ndlp x%x x%x x%x\\n\",\n\t\t\t new_ndlp->nlp_DID, new_ndlp->nlp_flag,\n\t\t\t new_ndlp->nlp_fc4_type);\n\n\treturn new_ndlp;\n}\n\n/**\n * lpfc_end_rscn - Check and handle more rscn for a vport\n * @vport: pointer to a host virtual N_Port data structure.\n *\n * This routine checks whether more Registration State Change\n * Notifications (RSCNs) came in while the discovery state machine was in\n * the FC_RSCN_MODE. If so, the lpfc_els_handle_rscn() routine will be\n * invoked to handle the additional RSCNs for the @vport. Otherwise, the\n * FC_RSCN_MODE bit will be cleared with the @vport to mark as the end of\n * handling the RSCNs.\n **/\nvoid\nlpfc_end_rscn(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\tif (vport->fc_flag & FC_RSCN_MODE) {\n\t\t/*\n\t\t * Check to see if more RSCNs came in while we were\n\t\t * processing this one.\n\t\t */\n\t\tif (vport->fc_rscn_id_cnt ||\n\t\t    (vport->fc_flag & FC_RSCN_DISCOVERY) != 0)\n\t\t\tlpfc_els_handle_rscn(vport);\n\t\telse {\n\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\tvport->fc_flag &= ~FC_RSCN_MODE;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t}\n\t}\n}\n\n/**\n * lpfc_cmpl_els_rrq - Completion handled for els RRQs.\n * @phba: pointer to lpfc hba data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @rspiocb: pointer to lpfc response iocb data structure.\n *\n * This routine will call the clear rrq function to free the rrq and\n * clear the xri's bit in the ndlp's xri_bitmap. If the ndlp does not\n * exist then the clear_rrq is still called because the rrq needs to\n * be freed.\n **/\n\nstatic void\nlpfc_cmpl_els_rrq(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t    struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tIOCB_t *irsp;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_node_rrq *rrq;\n\n\t/* we pass cmdiocb to state machine which needs rspiocb as well */\n\trrq = cmdiocb->context_un.rrq;\n\tcmdiocb->context_un.rsp_iocb = rspiocb;\n\n\tirsp = &rspiocb->iocb;\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"RRQ cmpl:      status:x%x/x%x did:x%x\",\n\t\tirsp->ulpStatus, irsp->un.ulpWord[4],\n\t\tirsp->un.elsreq64.remoteID);\n\n\tndlp = lpfc_findnode_did(vport, irsp->un.elsreq64.remoteID);\n\tif (!ndlp || ndlp != rrq->ndlp) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2882 RRQ completes to NPort x%x \"\n\t\t\t\t \"with no ndlp. Data: x%x x%x x%x\\n\",\n\t\t\t\t irsp->un.elsreq64.remoteID,\n\t\t\t\t irsp->ulpStatus, irsp->un.ulpWord[4],\n\t\t\t\t irsp->ulpIoTag);\n\t\tgoto out;\n\t}\n\n\t/* rrq completes to NPort <nlp_DID> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"2880 RRQ completes to NPort x%x \"\n\t\t\t \"Data: x%x x%x x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, irsp->ulpStatus, irsp->un.ulpWord[4],\n\t\t\t irsp->ulpTimeout, rrq->xritag, rrq->rxid);\n\n\tif (irsp->ulpStatus) {\n\t\t/* Check for retry */\n\t\t/* RRQ failed Don't print the vport to vport rjts */\n\t\tif (irsp->ulpStatus != IOSTAT_LS_RJT ||\n\t\t\t(((irsp->un.ulpWord[4]) >> 16 != LSRJT_INVALID_CMD) &&\n\t\t\t((irsp->un.ulpWord[4]) >> 16 != LSRJT_UNABLE_TPC)) ||\n\t\t\t(phba)->pport->cfg_log_verbose & LOG_ELS)\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"2881 RRQ failure DID:%06X Status:\"\n\t\t\t\t\t \"x%x/x%x\\n\",\n\t\t\t\t\t ndlp->nlp_DID, irsp->ulpStatus,\n\t\t\t\t\t irsp->un.ulpWord[4]);\n\t}\nout:\n\tif (rrq)\n\t\tlpfc_clr_rrq_active(phba, rrq->xritag, rrq);\n\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n\treturn;\n}\n/**\n * lpfc_cmpl_els_plogi - Completion callback function for plogi\n * @phba: pointer to lpfc hba data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @rspiocb: pointer to lpfc response iocb data structure.\n *\n * This routine is the completion callback function for issuing the Port\n * Login (PLOGI) command. For PLOGI completion, there must be an active\n * ndlp on the vport node list that matches the remote node ID from the\n * PLOGI response IOCB. If such ndlp does not exist, the PLOGI is simply\n * ignored and command IOCB released. The PLOGI response IOCB status is\n * checked for error conditons. If there is error status reported, PLOGI\n * retry shall be attempted by invoking the lpfc_els_retry() routine.\n * Otherwise, the lpfc_plogi_confirm_nport() routine shall be invoked on\n * the ndlp and the NLP_EVT_CMPL_PLOGI state to the Discover State Machine\n * (DSM) is set for this PLOGI completion. Finally, it checks whether\n * there are additional N_Port nodes with the vport that need to perform\n * PLOGI. If so, the lpfc_more_plogi() routine is invoked to issue addition\n * PLOGIs.\n **/\nstatic void\nlpfc_cmpl_els_plogi(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t    struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct Scsi_Host  *shost = lpfc_shost_from_vport(vport);\n\tIOCB_t *irsp;\n\tstruct lpfc_nodelist *ndlp, *free_ndlp;\n\tstruct lpfc_dmabuf *prsp;\n\tint disc;\n\n\t/* we pass cmdiocb to state machine which needs rspiocb as well */\n\tcmdiocb->context_un.rsp_iocb = rspiocb;\n\n\tirsp = &rspiocb->iocb;\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"PLOGI cmpl:      status:x%x/x%x did:x%x\",\n\t\tirsp->ulpStatus, irsp->un.ulpWord[4],\n\t\tirsp->un.elsreq64.remoteID);\n\n\tndlp = lpfc_findnode_did(vport, irsp->un.elsreq64.remoteID);\n\tif (!ndlp) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0136 PLOGI completes to NPort x%x \"\n\t\t\t\t \"with no ndlp. Data: x%x x%x x%x\\n\",\n\t\t\t\t irsp->un.elsreq64.remoteID,\n\t\t\t\t irsp->ulpStatus, irsp->un.ulpWord[4],\n\t\t\t\t irsp->ulpIoTag);\n\t\tgoto out;\n\t}\n\n\t/* Since ndlp can be freed in the disc state machine, note if this node\n\t * is being used during discovery.\n\t */\n\tspin_lock_irq(&ndlp->lock);\n\tdisc = (ndlp->nlp_flag & NLP_NPR_2B_DISC);\n\tndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\n\tspin_unlock_irq(&ndlp->lock);\n\n\t/* PLOGI completes to NPort <nlp_DID> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0102 PLOGI completes to NPort x%06x \"\n\t\t\t \"Data: x%x x%x x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, ndlp->nlp_fc4_type,\n\t\t\t irsp->ulpStatus, irsp->un.ulpWord[4],\n\t\t\t disc, vport->num_disc_nodes);\n\n\t/* Check to see if link went down during discovery */\n\tif (lpfc_els_chk_latt(vport)) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_NPR_2B_DISC;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tgoto out;\n\t}\n\n\tif (irsp->ulpStatus) {\n\t\t/* Check for retry */\n\t\tif (lpfc_els_retry(phba, cmdiocb, rspiocb)) {\n\t\t\t/* ELS command is being retried */\n\t\t\tif (disc) {\n\t\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\t\tndlp->nlp_flag |= NLP_NPR_2B_DISC;\n\t\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\t/* PLOGI failed Don't print the vport to vport rjts */\n\t\tif (irsp->ulpStatus != IOSTAT_LS_RJT ||\n\t\t\t(((irsp->un.ulpWord[4]) >> 16 != LSRJT_INVALID_CMD) &&\n\t\t\t((irsp->un.ulpWord[4]) >> 16 != LSRJT_UNABLE_TPC)) ||\n\t\t\t(phba)->pport->cfg_log_verbose & LOG_ELS)\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2753 PLOGI failure DID:%06X Status:x%x/x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, irsp->ulpStatus,\n\t\t\t\t irsp->un.ulpWord[4]);\n\n\t\t/* Do not call DSM for lpfc_els_abort'ed ELS cmds */\n\t\tif (lpfc_error_lost_link(irsp))\n\t\t\tgoto check_plogi;\n\t\telse\n\t\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\t\tNLP_EVT_CMPL_PLOGI);\n\n\t\t/* As long as this node is not registered with the scsi or nvme\n\t\t * transport, it is no longer an active node.  Otherwise\n\t\t * devloss handles the final cleanup.\n\t\t */\n\t\tif (!(ndlp->fc4_xpt_flags & (SCSI_XPT_REGD | NVME_XPT_REGD))) {\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\t}\n\t} else {\n\t\t/* Good status, call state machine */\n\t\tprsp = list_entry(((struct lpfc_dmabuf *)\n\t\t\t\t   cmdiocb->context2)->list.next,\n\t\t\t\t  struct lpfc_dmabuf, list);\n\t\tndlp = lpfc_plogi_confirm_nport(phba, prsp->virt, ndlp);\n\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\tNLP_EVT_CMPL_PLOGI);\n\t}\n\n check_plogi:\n\tif (disc && vport->num_disc_nodes) {\n\t\t/* Check to see if there are more PLOGIs to be sent */\n\t\tlpfc_more_plogi(vport);\n\n\t\tif (vport->num_disc_nodes == 0) {\n\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\tvport->fc_flag &= ~FC_NDISC_ACTIVE;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\n\t\t\tlpfc_can_disctmo(vport);\n\t\t\tlpfc_end_rscn(vport);\n\t\t}\n\t}\n\nout:\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_NODE,\n\t\t\t      \"PLOGI Cmpl PUT:     did:x%x refcnt %d\",\n\t\t\t      ndlp->nlp_DID, kref_read(&ndlp->kref), 0);\n\n\t/* Release the reference on the original I/O request. */\n\tfree_ndlp = (struct lpfc_nodelist *)cmdiocb->context1;\n\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(free_ndlp);\n\treturn;\n}\n\n/**\n * lpfc_issue_els_plogi - Issue an plogi iocb command for a vport\n * @vport: pointer to a host virtual N_Port data structure.\n * @did: destination port identifier.\n * @retry: number of retries to the command IOCB.\n *\n * This routine issues a Port Login (PLOGI) command to a remote N_Port\n * (with the @did) for a @vport. Before issuing a PLOGI to a remote N_Port,\n * the ndlp with the remote N_Port DID must exist on the @vport's ndlp list.\n * This routine constructs the proper feilds of the PLOGI IOCB and invokes\n * the lpfc_sli_issue_iocb() routine to send out PLOGI ELS command.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the PLOGI ELS command.\n *\n * Return code\n *   0 - Successfully issued a plogi for @vport\n *   1 - failed to issue a plogi for @vport\n **/\nint\nlpfc_issue_els_plogi(struct lpfc_vport *vport, uint32_t did, uint8_t retry)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct serv_parm *sp;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tint ret;\n\n\tndlp = lpfc_findnode_did(vport, did);\n\n\tif (ndlp) {\n\t\t/* Defer the processing of the issue PLOGI until after the\n\t\t * outstanding UNREG_RPI mbox command completes, unless we\n\t\t * are going offline. This logic does not apply for Fabric DIDs\n\t\t */\n\t\tif ((ndlp->nlp_flag & NLP_UNREG_INP) &&\n\t\t    ((ndlp->nlp_DID & Fabric_DID_MASK) != Fabric_DID_MASK) &&\n\t\t    !(vport->fc_flag & FC_OFFLINE_MODE)) {\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t\t \"4110 Issue PLOGI x%x deferred \"\n\t\t\t\t\t \"on NPort x%x rpi x%x Data: x%px\\n\",\n\t\t\t\t\t ndlp->nlp_defer_did, ndlp->nlp_DID,\n\t\t\t\t\t ndlp->nlp_rpi, ndlp);\n\n\t\t\t/* We can only defer 1st PLOGI */\n\t\t\tif (ndlp->nlp_defer_did == NLP_EVT_NOTHING_PENDING)\n\t\t\t\tndlp->nlp_defer_did = did;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* If ndlp is not NULL, we will bump the reference count on it */\n\tcmdsize = (sizeof(uint32_t) + sizeof(struct serv_parm));\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp, did,\n\t\t\t\t     ELS_CMD_PLOGI);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~NLP_FCP_PRLI_RJT;\n\tspin_unlock_irq(&ndlp->lock);\n\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\n\t/* For PLOGI request, remainder of payload is service parameters */\n\t*((uint32_t *) (pcmd)) = ELS_CMD_PLOGI;\n\tpcmd += sizeof(uint32_t);\n\tmemcpy(pcmd, &vport->fc_sparam, sizeof(struct serv_parm));\n\tsp = (struct serv_parm *) pcmd;\n\n\t/*\n\t * If we are a N-port connected to a Fabric, fix-up paramm's so logins\n\t * to device on remote loops work.\n\t */\n\tif ((vport->fc_flag & FC_FABRIC) && !(vport->fc_flag & FC_PUBLIC_LOOP))\n\t\tsp->cmn.altBbCredit = 1;\n\n\tif (sp->cmn.fcphLow < FC_PH_4_3)\n\t\tsp->cmn.fcphLow = FC_PH_4_3;\n\n\tif (sp->cmn.fcphHigh < FC_PH3)\n\t\tsp->cmn.fcphHigh = FC_PH3;\n\n\tsp->cmn.valid_vendor_ver_level = 0;\n\tmemset(sp->un.vendorVersion, 0, sizeof(sp->un.vendorVersion));\n\tsp->cmn.bbRcvSizeMsb &= 0xF;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Issue PLOGI:     did:x%x\",\n\t\tdid, 0, 0);\n\n\t/* If our firmware supports this feature, convey that\n\t * information to the target using the vendor specific field.\n\t */\n\tif (phba->sli.sli_flag & LPFC_SLI_SUPPRESS_RSP) {\n\t\tsp->cmn.valid_vendor_ver_level = 1;\n\t\tsp->un.vv.vid = cpu_to_be32(LPFC_VV_EMLX_ID);\n\t\tsp->un.vv.flags = cpu_to_be32(LPFC_VV_SUPPRESS_RSP);\n\t}\n\n\tphba->fc_stat.elsXmitPLOGI++;\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_plogi;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"Issue PLOGI:     did:x%x refcnt %d\",\n\t\t\t      did, kref_read(&ndlp->kref), 0);\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto io_err;\n\n\tret = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (ret) {\n\t\tlpfc_nlp_put(ndlp);\n\t\tgoto io_err;\n\t}\n\treturn 0;\n\n io_err:\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn 1;\n}\n\n/**\n * lpfc_cmpl_els_prli - Completion callback function for prli\n * @phba: pointer to lpfc hba data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @rspiocb: pointer to lpfc response iocb data structure.\n *\n * This routine is the completion callback function for a Process Login\n * (PRLI) ELS command. The PRLI response IOCB status is checked for error\n * status. If there is error status reported, PRLI retry shall be attempted\n * by invoking the lpfc_els_retry() routine. Otherwise, the state\n * NLP_EVT_CMPL_PRLI is sent to the Discover State Machine (DSM) for this\n * ndlp to mark the PRLI completion.\n **/\nstatic void\nlpfc_cmpl_els_prli(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t   struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tIOCB_t *irsp;\n\tstruct lpfc_nodelist *ndlp;\n\tchar *mode;\n\tu32 loglevel;\n\n\t/* we pass cmdiocb to state machine which needs rspiocb as well */\n\tcmdiocb->context_un.rsp_iocb = rspiocb;\n\n\tirsp = &(rspiocb->iocb);\n\tndlp = (struct lpfc_nodelist *) cmdiocb->context1;\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~NLP_PRLI_SND;\n\n\t/* Driver supports multiple FC4 types.  Counters matter. */\n\tvport->fc_prli_sent--;\n\tndlp->fc4_prli_sent--;\n\tspin_unlock_irq(&ndlp->lock);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"PRLI cmpl:       status:x%x/x%x did:x%x\",\n\t\tirsp->ulpStatus, irsp->un.ulpWord[4],\n\t\tndlp->nlp_DID);\n\n\t/* PRLI completes to NPort <nlp_DID> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0103 PRLI completes to NPort x%06x \"\n\t\t\t \"Data: x%x x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, irsp->ulpStatus, irsp->un.ulpWord[4],\n\t\t\t vport->num_disc_nodes, ndlp->fc4_prli_sent);\n\n\t/* Check to see if link went down during discovery */\n\tif (lpfc_els_chk_latt(vport))\n\t\tgoto out;\n\n\tif (irsp->ulpStatus) {\n\t\t/* Check for retry */\n\t\tif (lpfc_els_retry(phba, cmdiocb, rspiocb)) {\n\t\t\t/* ELS command is being retried */\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* If we don't send GFT_ID to Fabric, a PRLI error\n\t\t * could be expected.\n\t\t */\n\t\tif ((vport->fc_flag & FC_FABRIC) ||\n\t\t    (vport->cfg_enable_fc4_type != LPFC_ENABLE_BOTH)) {\n\t\t\tmode = KERN_ERR;\n\t\t\tloglevel =  LOG_TRACE_EVENT;\n\t\t} else {\n\t\t\tmode = KERN_INFO;\n\t\t\tloglevel =  LOG_ELS;\n\t\t}\n\n\t\t/* PRLI failed */\n\t\tlpfc_printf_vlog(vport, mode, loglevel,\n\t\t\t\t \"2754 PRLI failure DID:%06X Status:x%x/x%x, \"\n\t\t\t\t \"data: x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, irsp->ulpStatus,\n\t\t\t\t irsp->un.ulpWord[4], ndlp->fc4_prli_sent);\n\n\t\t/* Do not call DSM for lpfc_els_abort'ed ELS cmds */\n\t\tif (lpfc_error_lost_link(irsp))\n\t\t\tgoto out;\n\t\telse\n\t\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\t\tNLP_EVT_CMPL_PRLI);\n\n\t\t/* As long as this node is not registered with the SCSI\n\t\t * or NVMe transport and no other PRLIs are outstanding,\n\t\t * it is no longer an active node.  Otherwise devloss\n\t\t * handles the final cleanup.\n\t\t */\n\t\tif (!(ndlp->fc4_xpt_flags & (SCSI_XPT_REGD | NVME_XPT_REGD)) &&\n\t\t    !ndlp->fc4_prli_sent) {\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\t}\n\t} else {\n\t\t/* Good status, call state machine.  However, if another\n\t\t * PRLI is outstanding, don't call the state machine\n\t\t * because final disposition to Mapped or Unmapped is\n\t\t * completed there.\n\t\t */\n\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\tNLP_EVT_CMPL_PRLI);\n\t}\n\nout:\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n\treturn;\n}\n\n/**\n * lpfc_issue_els_prli - Issue a prli iocb command for a vport\n * @vport: pointer to a host virtual N_Port data structure.\n * @ndlp: pointer to a node-list data structure.\n * @retry: number of retries to the command IOCB.\n *\n * This routine issues a Process Login (PRLI) ELS command for the\n * @vport. The PRLI service parameters are set up in the payload of the\n * PRLI Request command and the pointer to lpfc_cmpl_els_prli() routine\n * is put to the IOCB completion callback func field before invoking the\n * routine lpfc_sli_issue_iocb() to send out PRLI command.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the PRLI ELS command.\n *\n * Return code\n *   0 - successfully issued prli iocb command for @vport\n *   1 - failed to issue prli iocb command for @vport\n **/\nint\nlpfc_issue_els_prli(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t    uint8_t retry)\n{\n\tint rc = 0;\n\tstruct lpfc_hba *phba = vport->phba;\n\tPRLI *npr;\n\tstruct lpfc_nvme_prli *npr_nvme;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tu32 local_nlp_type, elscmd;\n\n\t/*\n\t * If we are in RSCN mode, the FC4 types supported from a\n\t * previous GFT_ID command may not be accurate. So, if we\n\t * are a NVME Initiator, always look for the possibility of\n\t * the remote NPort beng a NVME Target.\n\t */\n\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t    vport->fc_flag & FC_RSCN_MODE &&\n\t    vport->nvmei_support)\n\t\tndlp->nlp_fc4_type |= NLP_FC4_NVME;\n\tlocal_nlp_type = ndlp->nlp_fc4_type;\n\n\t/* This routine will issue 1 or 2 PRLIs, so zero all the ndlp\n\t * fields here before any of them can complete.\n\t */\n\tndlp->nlp_type &= ~(NLP_FCP_TARGET | NLP_FCP_INITIATOR);\n\tndlp->nlp_type &= ~(NLP_NVME_TARGET | NLP_NVME_INITIATOR);\n\tndlp->nlp_fcp_info &= ~NLP_FCP_2_DEVICE;\n\tndlp->nlp_flag &= ~(NLP_FIRSTBURST | NLP_NPR_2B_DISC);\n\tndlp->nvme_fb_size = 0;\n\n send_next_prli:\n\tif (local_nlp_type & NLP_FC4_FCP) {\n\t\t/* Payload is 4 + 16 = 20 x14 bytes. */\n\t\tcmdsize = (sizeof(uint32_t) + sizeof(PRLI));\n\t\telscmd = ELS_CMD_PRLI;\n\t} else if (local_nlp_type & NLP_FC4_NVME) {\n\t\t/* Payload is 4 + 20 = 24 x18 bytes. */\n\t\tcmdsize = (sizeof(uint32_t) + sizeof(struct lpfc_nvme_prli));\n\t\telscmd = ELS_CMD_NVMEPRLI;\n\t} else {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"3083 Unknown FC_TYPE x%x ndlp x%06x\\n\",\n\t\t\t\t ndlp->nlp_fc4_type, ndlp->nlp_DID);\n\t\treturn 1;\n\t}\n\n\t/* SLI3 ports don't support NVME.  If this rport is a strict NVME\n\t * FC4 type, implicitly LOGO.\n\t */\n\tif (phba->sli_rev == LPFC_SLI_REV3 &&\n\t    ndlp->nlp_fc4_type == NLP_FC4_NVME) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"3088 Rport fc4 type 0x%x not supported by SLI3 adapter\\n\",\n\t\t\t\t ndlp->nlp_type);\n\t\tlpfc_disc_state_machine(vport, ndlp, NULL, NLP_EVT_DEVICE_RM);\n\t\treturn 1;\n\t}\n\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, elscmd);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\n\t/* For PRLI request, remainder of payload is service parameters */\n\tmemset(pcmd, 0, cmdsize);\n\n\tif (local_nlp_type & NLP_FC4_FCP) {\n\t\t/* Remainder of payload is FCP PRLI parameter page.\n\t\t * Note: this data structure is defined as\n\t\t * BE/LE in the structure definition so no\n\t\t * byte swap call is made.\n\t\t */\n\t\t*((uint32_t *)(pcmd)) = ELS_CMD_PRLI;\n\t\tpcmd += sizeof(uint32_t);\n\t\tnpr = (PRLI *)pcmd;\n\n\t\t/*\n\t\t * If our firmware version is 3.20 or later,\n\t\t * set the following bits for FC-TAPE support.\n\t\t */\n\t\tif (phba->vpd.rev.feaLevelHigh >= 0x02) {\n\t\t\tnpr->ConfmComplAllowed = 1;\n\t\t\tnpr->Retry = 1;\n\t\t\tnpr->TaskRetryIdReq = 1;\n\t\t}\n\t\tnpr->estabImagePair = 1;\n\t\tnpr->readXferRdyDis = 1;\n\t\tif (vport->cfg_first_burst_size)\n\t\t\tnpr->writeXferRdyDis = 1;\n\n\t\t/* For FCP support */\n\t\tnpr->prliType = PRLI_FCP_TYPE;\n\t\tnpr->initiatorFunc = 1;\n\t\telsiocb->iocb_flag |= LPFC_PRLI_FCP_REQ;\n\n\t\t/* Remove FCP type - processed. */\n\t\tlocal_nlp_type &= ~NLP_FC4_FCP;\n\t} else if (local_nlp_type & NLP_FC4_NVME) {\n\t\t/* Remainder of payload is NVME PRLI parameter page.\n\t\t * This data structure is the newer definition that\n\t\t * uses bf macros so a byte swap is required.\n\t\t */\n\t\t*((uint32_t *)(pcmd)) = ELS_CMD_NVMEPRLI;\n\t\tpcmd += sizeof(uint32_t);\n\t\tnpr_nvme = (struct lpfc_nvme_prli *)pcmd;\n\t\tbf_set(prli_type_code, npr_nvme, PRLI_NVME_TYPE);\n\t\tbf_set(prli_estabImagePair, npr_nvme, 0);  /* Should be 0 */\n\t\tif (phba->nsler) {\n\t\t\tbf_set(prli_nsler, npr_nvme, 1);\n\t\t\tbf_set(prli_conf, npr_nvme, 1);\n\t\t}\n\n\t\t/* Only initiators request first burst. */\n\t\tif ((phba->cfg_nvme_enable_fb) &&\n\t\t    !phba->nvmet_support)\n\t\t\tbf_set(prli_fba, npr_nvme, 1);\n\n\t\tif (phba->nvmet_support) {\n\t\t\tbf_set(prli_tgt, npr_nvme, 1);\n\t\t\tbf_set(prli_disc, npr_nvme, 1);\n\t\t} else {\n\t\t\tbf_set(prli_init, npr_nvme, 1);\n\t\t\tbf_set(prli_conf, npr_nvme, 1);\n\t\t}\n\n\t\tnpr_nvme->word1 = cpu_to_be32(npr_nvme->word1);\n\t\tnpr_nvme->word4 = cpu_to_be32(npr_nvme->word4);\n\t\telsiocb->iocb_flag |= LPFC_PRLI_NVME_REQ;\n\n\t\t/* Remove NVME type - processed. */\n\t\tlocal_nlp_type &= ~NLP_FC4_NVME;\n\t}\n\n\tphba->fc_stat.elsXmitPRLI++;\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_prli;\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag |= NLP_PRLI_SND;\n\n\t/* The vport counters are used for lpfc_scan_finished, but\n\t * the ndlp is used to track outstanding PRLIs for different\n\t * FC4 types.\n\t */\n\tvport->fc_prli_sent++;\n\tndlp->fc4_prli_sent++;\n\tspin_unlock_irq(&ndlp->lock);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"Issue PRLI:  did:x%x refcnt %d\",\n\t\t\t      ndlp->nlp_DID, kref_read(&ndlp->kref), 0);\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto io_err;\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR)\n\t\tgoto node_err;\n\n\n\t/* The driver supports 2 FC4 types.  Make sure\n\t * a PRLI is issued for all types before exiting.\n\t */\n\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t    local_nlp_type & (NLP_FC4_FCP | NLP_FC4_NVME))\n\t\tgoto send_next_prli;\n\telse\n\t\treturn 0;\n\n node_err:\n\tlpfc_nlp_put(ndlp);\n io_err:\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~NLP_PRLI_SND;\n\tspin_unlock_irq(&ndlp->lock);\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn 1;\n}\n\n/**\n * lpfc_rscn_disc - Perform rscn discovery for a vport\n * @vport: pointer to a host virtual N_Port data structure.\n *\n * This routine performs Registration State Change Notification (RSCN)\n * discovery for a @vport. If the @vport's node port recovery count is not\n * zero, it will invoke the lpfc_els_disc_plogi() to perform PLOGI for all\n * the nodes that need recovery. If none of the PLOGI were needed through\n * the lpfc_els_disc_plogi() routine, the lpfc_end_rscn() routine shall be\n * invoked to check and handle possible more RSCN came in during the period\n * of processing the current ones.\n **/\nstatic void\nlpfc_rscn_disc(struct lpfc_vport *vport)\n{\n\tlpfc_can_disctmo(vport);\n\n\t/* RSCN discovery */\n\t/* go thru NPR nodes and issue ELS PLOGIs */\n\tif (vport->fc_npr_cnt)\n\t\tif (lpfc_els_disc_plogi(vport))\n\t\t\treturn;\n\n\tlpfc_end_rscn(vport);\n}\n\n/**\n * lpfc_adisc_done - Complete the adisc phase of discovery\n * @vport: pointer to lpfc_vport hba data structure that finished all ADISCs.\n *\n * This function is called when the final ADISC is completed during discovery.\n * This function handles clearing link attention or issuing reg_vpi depending\n * on whether npiv is enabled. This function also kicks off the PLOGI phase of\n * discovery.\n * This function is called with no locks held.\n **/\nstatic void\nlpfc_adisc_done(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host   *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\t/*\n\t * For NPIV, cmpl_reg_vpi will set port_state to READY,\n\t * and continue discovery.\n\t */\n\tif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&\n\t    !(vport->fc_flag & FC_RSCN_MODE) &&\n\t    (phba->sli_rev < LPFC_SLI_REV4)) {\n\t\t/* The ADISCs are complete.  Doesn't matter if they\n\t\t * succeeded or failed because the ADISC completion\n\t\t * routine guarantees to call the state machine and\n\t\t * the RPI is either unregistered (failed ADISC response)\n\t\t * or the RPI is still valid and the node is marked\n\t\t * mapped for a target.  The exchanges should be in the\n\t\t * correct state. This code is specific to SLI3.\n\t\t */\n\t\tlpfc_issue_clear_la(phba, vport);\n\t\tlpfc_issue_reg_vpi(phba, vport);\n\t\treturn;\n\t}\n\t/*\n\t* For SLI2, we need to set port_state to READY\n\t* and continue discovery.\n\t*/\n\tif (vport->port_state < LPFC_VPORT_READY) {\n\t\t/* If we get here, there is nothing to ADISC */\n\t\tlpfc_issue_clear_la(phba, vport);\n\t\tif (!(vport->fc_flag & FC_ABORT_DISCOVERY)) {\n\t\t\tvport->num_disc_nodes = 0;\n\t\t\t/* go thru NPR list, issue ELS PLOGIs */\n\t\t\tif (vport->fc_npr_cnt)\n\t\t\t\tlpfc_els_disc_plogi(vport);\n\t\t\tif (!vport->num_disc_nodes) {\n\t\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\t\tvport->fc_flag &= ~FC_NDISC_ACTIVE;\n\t\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t\tlpfc_can_disctmo(vport);\n\t\t\t\tlpfc_end_rscn(vport);\n\t\t\t}\n\t\t}\n\t\tvport->port_state = LPFC_VPORT_READY;\n\t} else\n\t\tlpfc_rscn_disc(vport);\n}\n\n/**\n * lpfc_more_adisc - Issue more adisc as needed\n * @vport: pointer to a host virtual N_Port data structure.\n *\n * This routine determines whether there are more ndlps on a @vport\n * node list need to have Address Discover (ADISC) issued. If so, it will\n * invoke the lpfc_els_disc_adisc() routine to issue ADISC on the @vport's\n * remaining nodes which need to have ADISC sent.\n **/\nvoid\nlpfc_more_adisc(struct lpfc_vport *vport)\n{\n\tif (vport->num_disc_nodes)\n\t\tvport->num_disc_nodes--;\n\t/* Continue discovery with <num_disc_nodes> ADISCs to go */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"0210 Continue discovery with %d ADISCs to go \"\n\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t vport->num_disc_nodes, vport->fc_adisc_cnt,\n\t\t\t vport->fc_flag, vport->port_state);\n\t/* Check to see if there are more ADISCs to be sent */\n\tif (vport->fc_flag & FC_NLP_MORE) {\n\t\tlpfc_set_disctmo(vport);\n\t\t/* go thru NPR nodes and issue any remaining ELS ADISCs */\n\t\tlpfc_els_disc_adisc(vport);\n\t}\n\tif (!vport->num_disc_nodes)\n\t\tlpfc_adisc_done(vport);\n\treturn;\n}\n\n/**\n * lpfc_cmpl_els_adisc - Completion callback function for adisc\n * @phba: pointer to lpfc hba data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @rspiocb: pointer to lpfc response iocb data structure.\n *\n * This routine is the completion function for issuing the Address Discover\n * (ADISC) command. It first checks to see whether link went down during\n * the discovery process. If so, the node will be marked as node port\n * recovery for issuing discover IOCB by the link attention handler and\n * exit. Otherwise, the response status is checked. If error was reported\n * in the response status, the ADISC command shall be retried by invoking\n * the lpfc_els_retry() routine. Otherwise, if no error was reported in\n * the response status, the state machine is invoked to set transition\n * with respect to NLP_EVT_CMPL_ADISC event.\n **/\nstatic void\nlpfc_cmpl_els_adisc(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t    struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tIOCB_t *irsp;\n\tstruct lpfc_nodelist *ndlp;\n\tint  disc;\n\n\t/* we pass cmdiocb to state machine which needs rspiocb as well */\n\tcmdiocb->context_un.rsp_iocb = rspiocb;\n\n\tirsp = &(rspiocb->iocb);\n\tndlp = (struct lpfc_nodelist *) cmdiocb->context1;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"ADISC cmpl:      status:x%x/x%x did:x%x\",\n\t\tirsp->ulpStatus, irsp->un.ulpWord[4],\n\t\tndlp->nlp_DID);\n\n\t/* Since ndlp can be freed in the disc state machine, note if this node\n\t * is being used during discovery.\n\t */\n\tspin_lock_irq(&ndlp->lock);\n\tdisc = (ndlp->nlp_flag & NLP_NPR_2B_DISC);\n\tndlp->nlp_flag &= ~(NLP_ADISC_SND | NLP_NPR_2B_DISC);\n\tspin_unlock_irq(&ndlp->lock);\n\t/* ADISC completes to NPort <nlp_DID> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0104 ADISC completes to NPort x%x \"\n\t\t\t \"Data: x%x x%x x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, irsp->ulpStatus, irsp->un.ulpWord[4],\n\t\t\t irsp->ulpTimeout, disc, vport->num_disc_nodes);\n\t/* Check to see if link went down during discovery */\n\tif (lpfc_els_chk_latt(vport)) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_NPR_2B_DISC;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tgoto out;\n\t}\n\n\tif (irsp->ulpStatus) {\n\t\t/* Check for retry */\n\t\tif (lpfc_els_retry(phba, cmdiocb, rspiocb)) {\n\t\t\t/* ELS command is being retried */\n\t\t\tif (disc) {\n\t\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\t\tndlp->nlp_flag |= NLP_NPR_2B_DISC;\n\t\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\t\tlpfc_set_disctmo(vport);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\t/* ADISC failed */\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2755 ADISC failure DID:%06X Status:x%x/x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, irsp->ulpStatus,\n\t\t\t\t irsp->un.ulpWord[4]);\n\t\t/* Do not call DSM for lpfc_els_abort'ed ELS cmds */\n\t\tif (lpfc_error_lost_link(irsp))\n\t\t\tgoto check_adisc;\n\t\telse\n\t\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\t\tNLP_EVT_CMPL_ADISC);\n\n\t\t/* As long as this node is not registered with the SCSI or NVMe\n\t\t * transport, it is no longer an active node. Otherwise\n\t\t * devloss handles the final cleanup.\n\t\t */\n\t\tif (!(ndlp->fc4_xpt_flags & (SCSI_XPT_REGD | NVME_XPT_REGD))) {\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\t}\n\t} else\n\t\t/* Good status, call state machine */\n\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\tNLP_EVT_CMPL_ADISC);\n\n check_adisc:\n\t/* Check to see if there are more ADISCs to be sent */\n\tif (disc && vport->num_disc_nodes)\n\t\tlpfc_more_adisc(vport);\nout:\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n\treturn;\n}\n\n/**\n * lpfc_issue_els_adisc - Issue an address discover iocb to an node on a vport\n * @vport: pointer to a virtual N_Port data structure.\n * @ndlp: pointer to a node-list data structure.\n * @retry: number of retries to the command IOCB.\n *\n * This routine issues an Address Discover (ADISC) for an @ndlp on a\n * @vport. It prepares the payload of the ADISC ELS command, updates the\n * and states of the ndlp, and invokes the lpfc_sli_issue_iocb() routine\n * to issue the ADISC ELS command.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the ADISC ELS command.\n *\n * Return code\n *   0 - successfully issued adisc\n *   1 - failed to issue adisc\n **/\nint\nlpfc_issue_els_adisc(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t     uint8_t retry)\n{\n\tint rc = 0;\n\tstruct lpfc_hba  *phba = vport->phba;\n\tADISC *ap;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\n\tcmdsize = (sizeof(uint32_t) + sizeof(ADISC));\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_ADISC);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\n\t/* For ADISC request, remainder of payload is service parameters */\n\t*((uint32_t *) (pcmd)) = ELS_CMD_ADISC;\n\tpcmd += sizeof(uint32_t);\n\n\t/* Fill in ADISC payload */\n\tap = (ADISC *) pcmd;\n\tap->hardAL_PA = phba->fc_pref_ALPA;\n\tmemcpy(&ap->portName, &vport->fc_portname, sizeof(struct lpfc_name));\n\tmemcpy(&ap->nodeName, &vport->fc_nodename, sizeof(struct lpfc_name));\n\tap->DID = be32_to_cpu(vport->fc_myDID);\n\n\tphba->fc_stat.elsXmitADISC++;\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_adisc;\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag |= NLP_ADISC_SND;\n\tspin_unlock_irq(&ndlp->lock);\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto node_err;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"Issue ADISC:   did:x%x refcnt %d\",\n\t\t\t      ndlp->nlp_DID, kref_read(&ndlp->kref), 0);\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR)\n\t\tgoto io_err;\n\treturn 0;\n\n io_err:\n\tlpfc_nlp_put(ndlp);\n node_err:\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~NLP_ADISC_SND;\n\tspin_unlock_irq(&ndlp->lock);\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn 1;\n}\n\n/**\n * lpfc_cmpl_els_logo - Completion callback function for logo\n * @phba: pointer to lpfc hba data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @rspiocb: pointer to lpfc response iocb data structure.\n *\n * This routine is the completion function for issuing the ELS Logout (LOGO)\n * command. If no error status was reported from the LOGO response, the\n * state machine of the associated ndlp shall be invoked for transition with\n * respect to NLP_EVT_CMPL_LOGO event. Otherwise, if error status was reported,\n * the lpfc_els_retry() routine will be invoked to retry the LOGO command.\n **/\nstatic void\nlpfc_cmpl_els_logo(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t   struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) cmdiocb->context1;\n\tstruct lpfc_vport *vport = ndlp->vport;\n\tIOCB_t *irsp;\n\tstruct lpfcMboxq *mbox;\n\tunsigned long flags;\n\tuint32_t skip_recovery = 0;\n\n\t/* we pass cmdiocb to state machine which needs rspiocb as well */\n\tcmdiocb->context_un.rsp_iocb = rspiocb;\n\n\tirsp = &(rspiocb->iocb);\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~NLP_LOGO_SND;\n\tspin_unlock_irq(&ndlp->lock);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"LOGO cmpl:       status:x%x/x%x did:x%x\",\n\t\tirsp->ulpStatus, irsp->un.ulpWord[4],\n\t\tndlp->nlp_DID);\n\n\t/* LOGO completes to NPort <nlp_DID> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0105 LOGO completes to NPort x%x \"\n\t\t\t \"refcnt %d nflags x%x Data: x%x x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, kref_read(&ndlp->kref), ndlp->nlp_flag,\n\t\t\t irsp->ulpStatus, irsp->un.ulpWord[4],\n\t\t\t irsp->ulpTimeout, vport->num_disc_nodes);\n\n\tif (lpfc_els_chk_latt(vport)) {\n\t\tskip_recovery = 1;\n\t\tgoto out;\n\t}\n\n\t/* The LOGO will not be retried on failure.  A LOGO was\n\t * issued to the remote rport and a ACC or RJT or no Answer are\n\t * all acceptable.  Note the failure and move forward with\n\t * discovery.  The PLOGI will retry.\n\t */\n\tif (irsp->ulpStatus) {\n\t\t/* LOGO failed */\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2756 LOGO failure, No Retry DID:%06X Status:x%x/x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, irsp->ulpStatus,\n\t\t\t\t irsp->un.ulpWord[4]);\n\t\t/* Do not call DSM for lpfc_els_abort'ed ELS cmds */\n\t\tif (lpfc_error_lost_link(irsp)) {\n\t\t\tskip_recovery = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Call state machine. This will unregister the rpi if needed. */\n\tlpfc_disc_state_machine(vport, ndlp, cmdiocb, NLP_EVT_CMPL_LOGO);\n\n\t/* The driver sets this flag for an NPIV instance that doesn't want to\n\t * log into the remote port.\n\t */\n\tif (ndlp->nlp_flag & NLP_TARGET_REMOVE) {\n\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tlpfc_els_free_iocb(phba, cmdiocb);\n\t\tlpfc_nlp_put(ndlp);\n\n\t\t/* Presume the node was released. */\n\t\treturn;\n\t}\n\nout:\n\t/* Driver is done with the IO.  */\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n\n\t/* If we are in pt2pt mode, we could rcv new S_ID on PLOGI */\n\tif ((vport->fc_flag & FC_PT2PT) &&\n\t\t!(vport->fc_flag & FC_PT2PT_PLOGI)) {\n\t\tphba->pport->fc_myDID = 0;\n\n\t\tif ((vport->cfg_enable_fc4_type == LPFC_ENABLE_BOTH) ||\n\t\t    (vport->cfg_enable_fc4_type == LPFC_ENABLE_NVME)) {\n\t\t\tif (phba->nvmet_support)\n\t\t\t\tlpfc_nvmet_update_targetport(phba);\n\t\t\telse\n\t\t\t\tlpfc_nvme_update_localport(phba->pport);\n\t\t}\n\n\t\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\t\tif (mbox) {\n\t\t\tlpfc_config_link(phba, mbox);\n\t\t\tmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t\t\tmbox->vport = vport;\n\t\t\tif (lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT) ==\n\t\t\t\tMBX_NOT_FINISHED) {\n\t\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\t\t\tskip_recovery = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If the node is a target, the handling attempts to recover the port.\n\t * For any other port type, the rpi is unregistered as an implicit\n\t * LOGO.\n\t */\n\tif (ndlp->nlp_type & (NLP_FCP_TARGET | NLP_NVME_TARGET) &&\n\t    skip_recovery == 0) {\n\t\tlpfc_cancel_retry_delay_tmo(vport, ndlp);\n\t\tspin_lock_irqsave(&ndlp->lock, flags);\n\t\tndlp->nlp_flag |= NLP_NPR_2B_DISC;\n\t\tspin_unlock_irqrestore(&ndlp->lock, flags);\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"3187 LOGO completes to NPort x%x: Start \"\n\t\t\t\t \"Recovery Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, irsp->ulpStatus,\n\t\t\t\t irsp->un.ulpWord[4], irsp->ulpTimeout,\n\t\t\t\t vport->num_disc_nodes);\n\t\tlpfc_disc_start(vport);\n\t\treturn;\n\t}\n\n\t/* Cleanup path for failed REG_RPI handling. If REG_RPI fails, the\n\t * driver sends a LOGO to the rport to cleanup.  For fabric and\n\t * initiator ports cleanup the node as long as it the node is not\n\t * register with the transport.\n\t */\n\tif (!(ndlp->fc4_xpt_flags & (SCSI_XPT_REGD | NVME_XPT_REGD))) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t}\n}\n\n/**\n * lpfc_issue_els_logo - Issue a logo to an node on a vport\n * @vport: pointer to a virtual N_Port data structure.\n * @ndlp: pointer to a node-list data structure.\n * @retry: number of retries to the command IOCB.\n *\n * This routine constructs and issues an ELS Logout (LOGO) iocb command\n * to a remote node, referred by an @ndlp on a @vport. It constructs the\n * payload of the IOCB, properly sets up the @ndlp state, and invokes the\n * lpfc_sli_issue_iocb() routine to send out the LOGO ELS command.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the LOGO ELS command.\n *\n * Callers of this routine are expected to unregister the RPI first\n *\n * Return code\n *   0 - successfully issued logo\n *   1 - failed to issue logo\n **/\nint\nlpfc_issue_els_logo(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t    uint8_t retry)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tint rc;\n\n\tspin_lock_irq(&ndlp->lock);\n\tif (ndlp->nlp_flag & NLP_LOGO_SND) {\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\treturn 0;\n\t}\n\tspin_unlock_irq(&ndlp->lock);\n\n\tcmdsize = (2 * sizeof(uint32_t)) + sizeof(struct lpfc_name);\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_LOGO);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\t*((uint32_t *) (pcmd)) = ELS_CMD_LOGO;\n\tpcmd += sizeof(uint32_t);\n\n\t/* Fill in LOGO payload */\n\t*((uint32_t *) (pcmd)) = be32_to_cpu(vport->fc_myDID);\n\tpcmd += sizeof(uint32_t);\n\tmemcpy(pcmd, &vport->fc_portname, sizeof(struct lpfc_name));\n\n\tphba->fc_stat.elsXmitLOGO++;\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_logo;\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag |= NLP_LOGO_SND;\n\tndlp->nlp_flag &= ~NLP_ISSUE_LOGO;\n\tspin_unlock_irq(&ndlp->lock);\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto node_err;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"Issue LOGO:      did:x%x refcnt %d\",\n\t\t\t      ndlp->nlp_DID, kref_read(&ndlp->kref), 0);\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR)\n\t\tgoto io_err;\n\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_prev_state = ndlp->nlp_state;\n\tspin_unlock_irq(&ndlp->lock);\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_LOGO_ISSUE);\n\treturn 0;\n\n io_err:\n\tlpfc_nlp_put(ndlp);\n node_err:\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~NLP_LOGO_SND;\n\tspin_unlock_irq(&ndlp->lock);\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn 1;\n}\n\n/**\n * lpfc_cmpl_els_cmd - Completion callback function for generic els command\n * @phba: pointer to lpfc hba data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @rspiocb: pointer to lpfc response iocb data structure.\n *\n * This routine is a generic completion callback function for ELS commands.\n * Specifically, it is the callback function which does not need to perform\n * any command specific operations. It is currently used by the ELS command\n * issuing routines for RSCN, lpfc_issue_els_rscn, and the ELS Fibre Channel\n * Address Resolution Protocol Response (FARPR) routine, lpfc_issue_els_farpr().\n * Other than certain debug loggings, this callback function simply invokes the\n * lpfc_els_chk_latt() routine to check whether link went down during the\n * discovery process.\n **/\nstatic void\nlpfc_cmpl_els_cmd(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t  struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct lpfc_nodelist *free_ndlp;\n\tIOCB_t *irsp;\n\n\tirsp = &rspiocb->iocb;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"ELS cmd cmpl:    status:x%x/x%x did:x%x\",\n\t\t\t      irsp->ulpStatus, irsp->un.ulpWord[4],\n\t\t\t      irsp->un.elsreq64.remoteID);\n\n\t/* ELS cmd tag <ulpIoTag> completes */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0106 ELS cmd tag x%x completes Data: x%x x%x x%x\\n\",\n\t\t\t irsp->ulpIoTag, irsp->ulpStatus,\n\t\t\t irsp->un.ulpWord[4], irsp->ulpTimeout);\n\n\t/* Check to see if link went down during discovery */\n\tlpfc_els_chk_latt(vport);\n\n\tfree_ndlp = (struct lpfc_nodelist *)cmdiocb->context1;\n\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(free_ndlp);\n}\n\n/**\n * lpfc_cmpl_els_disc_cmd - Completion callback function for Discovery ELS cmd\n * @phba: pointer to lpfc hba data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @rspiocb: pointer to lpfc response iocb data structure.\n *\n * This routine is a generic completion callback function for Discovery ELS cmd.\n * Currently used by the ELS command issuing routines for the ELS State Change\n * Request (SCR), lpfc_issue_els_scr() and the ELS RDF, lpfc_issue_els_rdf().\n * These commands will be retried once only for ELS timeout errors.\n **/\nstatic void\nlpfc_cmpl_els_disc_cmd(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t       struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tIOCB_t *irsp;\n\tstruct lpfc_els_rdf_rsp *prdf;\n\tstruct lpfc_dmabuf *pcmd, *prsp;\n\tu32 *pdata;\n\tu32 cmd;\n\tstruct lpfc_nodelist *ndlp = cmdiocb->context1;\n\n\tirsp = &rspiocb->iocb;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"ELS cmd cmpl:    status:x%x/x%x did:x%x\",\n\t\tirsp->ulpStatus, irsp->un.ulpWord[4],\n\t\tirsp->un.elsreq64.remoteID);\n\t/* ELS cmd tag <ulpIoTag> completes */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0217 ELS cmd tag x%x completes Data: x%x x%x x%x \"\n\t\t\t \"x%x\\n\",\n\t\t\t irsp->ulpIoTag, irsp->ulpStatus,\n\t\t\t irsp->un.ulpWord[4], irsp->ulpTimeout,\n\t\t\t cmdiocb->retry);\n\n\tpcmd = (struct lpfc_dmabuf *)cmdiocb->context2;\n\tif (!pcmd)\n\t\tgoto out;\n\n\tpdata = (u32 *)pcmd->virt;\n\tif (!pdata)\n\t\tgoto out;\n\tcmd = *pdata;\n\n\t/* Only 1 retry for ELS Timeout only */\n\tif (irsp->ulpStatus == IOSTAT_LOCAL_REJECT &&\n\t    ((irsp->un.ulpWord[4] & IOERR_PARAM_MASK) ==\n\t    IOERR_SEQUENCE_TIMEOUT)) {\n\t\tcmdiocb->retry++;\n\t\tif (cmdiocb->retry <= 1) {\n\t\t\tswitch (cmd) {\n\t\t\tcase ELS_CMD_SCR:\n\t\t\t\tlpfc_issue_els_scr(vport, cmdiocb->retry);\n\t\t\t\tbreak;\n\t\t\tcase ELS_CMD_RDF:\n\t\t\t\tcmdiocb->context1 = NULL; /* save ndlp refcnt */\n\t\t\t\tlpfc_issue_els_rdf(vport, cmdiocb->retry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\tphba->fc_stat.elsRetryExceeded++;\n\t}\n\tif (irsp->ulpStatus) {\n\t\t/* ELS discovery cmd completes with error */\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_ELS,\n\t\t\t\t \"4203 ELS cmd x%x error: x%x x%X\\n\", cmd,\n\t\t\t\t irsp->ulpStatus, irsp->un.ulpWord[4]);\n\t\tgoto out;\n\t}\n\n\t/* The RDF response doesn't have any impact on the running driver\n\t * but the notification descriptors are dumped here for support.\n\t */\n\tif (cmd == ELS_CMD_RDF) {\n\t\tint i;\n\n\t\tprsp = list_get_first(&pcmd->list, struct lpfc_dmabuf, list);\n\t\tif (!prsp)\n\t\t\tgoto out;\n\n\t\tprdf = (struct lpfc_els_rdf_rsp *)prsp->virt;\n\t\tif (!prdf)\n\t\t\tgoto out;\n\n\t\tfor (i = 0; i < ELS_RDF_REG_TAG_CNT &&\n\t\t\t    i < be32_to_cpu(prdf->reg_d1.reg_desc.count); i++)\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"4677 Fabric RDF Notification Grant Data: \"\n\t\t\t\t \"0x%08x\\n\",\n\t\t\t\t be32_to_cpu(\n\t\t\t\t\tprdf->reg_d1.desc_tags[i]));\n\t}\n\nout:\n\t/* Check to see if link went down during discovery */\n\tlpfc_els_chk_latt(vport);\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n\treturn;\n}\n\n/**\n * lpfc_issue_els_scr - Issue a scr to an node on a vport\n * @vport: pointer to a host virtual N_Port data structure.\n * @retry: retry counter for the command IOCB.\n *\n * This routine issues a State Change Request (SCR) to a fabric node\n * on a @vport. The remote node is Fabric Controller (0xfffffd). It\n * first search the @vport node list to find the matching ndlp. If no such\n * ndlp is found, a new ndlp shall be created for this (SCR) purpose. An\n * IOCB is allocated, payload prepared, and the lpfc_sli_issue_iocb()\n * routine is invoked to send the SCR IOCB.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the SCR ELS command.\n *\n * Return code\n *   0 - Successfully issued scr command\n *   1 - Failed to issue scr command\n **/\nint\nlpfc_issue_els_scr(struct lpfc_vport *vport, uint8_t retry)\n{\n\tint rc = 0;\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tstruct lpfc_nodelist *ndlp;\n\n\tcmdsize = (sizeof(uint32_t) + sizeof(SCR));\n\n\tndlp = lpfc_findnode_did(vport, Fabric_Cntl_DID);\n\tif (!ndlp) {\n\t\tndlp = lpfc_nlp_init(vport, Fabric_Cntl_DID);\n\t\tif (!ndlp)\n\t\t\treturn 1;\n\t\tlpfc_enqueue_node(vport, ndlp);\n\t}\n\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_SCR);\n\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\n\t*((uint32_t *) (pcmd)) = ELS_CMD_SCR;\n\tpcmd += sizeof(uint32_t);\n\n\t/* For SCR, remainder of payload is SCR parameter page */\n\tmemset(pcmd, 0, sizeof(SCR));\n\t((SCR *) pcmd)->Function = SCR_FUNC_FULL;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Issue SCR:       did:x%x\",\n\t\tndlp->nlp_DID, 0, 0);\n\n\tphba->fc_stat.elsXmitSCR++;\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_disc_cmd;\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto node_err;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"Issue SCR:     did:x%x refcnt %d\",\n\t\t\t      ndlp->nlp_DID, kref_read(&ndlp->kref), 0);\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR)\n\t\tgoto io_err;\n\n\t/* Keep the ndlp just in case RDF is being sent */\n\treturn 0;\n\n io_err:\n\tlpfc_nlp_put(ndlp);\n node_err:\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn 1;\n}\n\n/**\n * lpfc_issue_els_rscn - Issue an RSCN to the Fabric Controller (Fabric)\n *   or the other nport (pt2pt).\n * @vport: pointer to a host virtual N_Port data structure.\n * @retry: number of retries to the command IOCB.\n *\n * This routine issues a RSCN to the Fabric Controller (DID 0xFFFFFD)\n *  when connected to a fabric, or to the remote port when connected\n *  in point-to-point mode. When sent to the Fabric Controller, it will\n *  replay the RSCN to registered recipients.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the RSCN ELS command.\n *\n * Return code\n *   0 - Successfully issued RSCN command\n *   1 - Failed to issue RSCN command\n **/\nint\nlpfc_issue_els_rscn(struct lpfc_vport *vport, uint8_t retry)\n{\n\tint rc = 0;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct {\n\t\tstruct fc_els_rscn rscn;\n\t\tstruct fc_els_rscn_page portid;\n\t} *event;\n\tuint32_t nportid;\n\tuint16_t cmdsize = sizeof(*event);\n\n\t/* Not supported for private loop */\n\tif (phba->fc_topology == LPFC_TOPOLOGY_LOOP &&\n\t    !(vport->fc_flag & FC_PUBLIC_LOOP))\n\t\treturn 1;\n\n\tif (vport->fc_flag & FC_PT2PT) {\n\t\t/* find any mapped nport - that would be the other nport */\n\t\tndlp = lpfc_findnode_mapped(vport);\n\t\tif (!ndlp)\n\t\t\treturn 1;\n\t} else {\n\t\tnportid = FC_FID_FCTRL;\n\t\t/* find the fabric controller node */\n\t\tndlp = lpfc_findnode_did(vport, nportid);\n\t\tif (!ndlp) {\n\t\t\t/* if one didn't exist, make one */\n\t\t\tndlp = lpfc_nlp_init(vport, nportid);\n\t\t\tif (!ndlp)\n\t\t\t\treturn 1;\n\t\t\tlpfc_enqueue_node(vport, ndlp);\n\t\t}\n\t}\n\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_RSCN_XMT);\n\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tevent = ((struct lpfc_dmabuf *)elsiocb->context2)->virt;\n\n\tevent->rscn.rscn_cmd = ELS_RSCN;\n\tevent->rscn.rscn_page_len = sizeof(struct fc_els_rscn_page);\n\tevent->rscn.rscn_plen = cpu_to_be16(cmdsize);\n\n\tnportid = vport->fc_myDID;\n\t/* appears that page flags must be 0 for fabric to broadcast RSCN */\n\tevent->portid.rscn_page_flags = 0;\n\tevent->portid.rscn_fid[0] = (nportid & 0x00FF0000) >> 16;\n\tevent->portid.rscn_fid[1] = (nportid & 0x0000FF00) >> 8;\n\tevent->portid.rscn_fid[2] = nportid & 0x000000FF;\n\n\tphba->fc_stat.elsXmitRSCN++;\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_cmd;\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto node_err;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"Issue RSCN:       did:x%x\",\n\t\t\t      ndlp->nlp_DID, 0, 0);\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR)\n\t\tgoto io_err;\n\n\t/* This will cause the callback-function lpfc_cmpl_els_cmd to\n\t * trigger the release of node.\n\t */\n\tif (!(vport->fc_flag & FC_PT2PT))\n\t\tlpfc_nlp_put(ndlp);\n\treturn 0;\nio_err:\n\tlpfc_nlp_put(ndlp);\nnode_err:\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn 1;\n}\n\n/**\n * lpfc_issue_els_farpr - Issue a farp to an node on a vport\n * @vport: pointer to a host virtual N_Port data structure.\n * @nportid: N_Port identifier to the remote node.\n * @retry: number of retries to the command IOCB.\n *\n * This routine issues a Fibre Channel Address Resolution Response\n * (FARPR) to a node on a vport. The remote node N_Port identifier (@nportid)\n * is passed into the function. It first search the @vport node list to find\n * the matching ndlp. If no such ndlp is found, a new ndlp shall be created\n * for this (FARPR) purpose. An IOCB is allocated, payload prepared, and the\n * lpfc_sli_issue_iocb() routine is invoked to send the FARPR ELS command.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the PARPR ELS command.\n *\n * Return code\n *   0 - Successfully issued farpr command\n *   1 - Failed to issue farpr command\n **/\nstatic int\nlpfc_issue_els_farpr(struct lpfc_vport *vport, uint32_t nportid, uint8_t retry)\n{\n\tint rc = 0;\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_iocbq *elsiocb;\n\tFARP *fp;\n\tuint8_t *pcmd;\n\tuint32_t *lp;\n\tuint16_t cmdsize;\n\tstruct lpfc_nodelist *ondlp;\n\tstruct lpfc_nodelist *ndlp;\n\n\tcmdsize = (sizeof(uint32_t) + sizeof(FARP));\n\n\tndlp = lpfc_findnode_did(vport, nportid);\n\tif (!ndlp) {\n\t\tndlp = lpfc_nlp_init(vport, nportid);\n\t\tif (!ndlp)\n\t\t\treturn 1;\n\t\tlpfc_enqueue_node(vport, ndlp);\n\t}\n\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_RNID);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\n\t*((uint32_t *) (pcmd)) = ELS_CMD_FARPR;\n\tpcmd += sizeof(uint32_t);\n\n\t/* Fill in FARPR payload */\n\tfp = (FARP *) (pcmd);\n\tmemset(fp, 0, sizeof(FARP));\n\tlp = (uint32_t *) pcmd;\n\t*lp++ = be32_to_cpu(nportid);\n\t*lp++ = be32_to_cpu(vport->fc_myDID);\n\tfp->Rflags = 0;\n\tfp->Mflags = (FARP_MATCH_PORT | FARP_MATCH_NODE);\n\n\tmemcpy(&fp->RportName, &vport->fc_portname, sizeof(struct lpfc_name));\n\tmemcpy(&fp->RnodeName, &vport->fc_nodename, sizeof(struct lpfc_name));\n\tondlp = lpfc_findnode_did(vport, nportid);\n\tif (ondlp) {\n\t\tmemcpy(&fp->OportName, &ondlp->nlp_portname,\n\t\t       sizeof(struct lpfc_name));\n\t\tmemcpy(&fp->OnodeName, &ondlp->nlp_nodename,\n\t\t       sizeof(struct lpfc_name));\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Issue FARPR:     did:x%x\",\n\t\tndlp->nlp_DID, 0, 0);\n\n\tphba->fc_stat.elsXmitFARPR++;\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_cmd;\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 1;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\t/* The additional lpfc_nlp_put will cause the following\n\t\t * lpfc_els_free_iocb routine to trigger the release of\n\t\t * the node.\n\t\t */\n\t\tlpfc_nlp_put(ndlp);\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 1;\n\t}\n\t/* This will cause the callback-function lpfc_cmpl_els_cmd to\n\t * trigger the release of the node.\n\t */\n\t/* Don't release reference count as RDF is likely outstanding */\n\treturn 0;\n}\n\n/**\n * lpfc_issue_els_rdf - Register for diagnostic functions from the fabric.\n * @vport: pointer to a host virtual N_Port data structure.\n * @retry: retry counter for the command IOCB.\n *\n * This routine issues an ELS RDF to the Fabric Controller to register\n * for diagnostic functions.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the RDF ELS command.\n *\n * Return code\n *   0 - Successfully issued rdf command\n *   1 - Failed to issue rdf command\n **/\nint\nlpfc_issue_els_rdf(struct lpfc_vport *vport, uint8_t retry)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct lpfc_els_rdf_req *prdf;\n\tstruct lpfc_nodelist *ndlp;\n\tuint16_t cmdsize;\n\tint rc;\n\n\tcmdsize = sizeof(*prdf);\n\n\tndlp = lpfc_findnode_did(vport, Fabric_Cntl_DID);\n\tif (!ndlp) {\n\t\tndlp = lpfc_nlp_init(vport, Fabric_Cntl_DID);\n\t\tif (!ndlp)\n\t\t\treturn -ENODEV;\n\t\tlpfc_enqueue_node(vport, ndlp);\n\t}\n\n\t/* RDF ELS is not required on an NPIV VN_Port.  */\n\tif (vport->port_type == LPFC_NPIV_PORT) {\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn -EACCES;\n\t}\n\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_RDF);\n\tif (!elsiocb)\n\t\treturn -ENOMEM;\n\n\t/* Configure the payload for the supported FPIN events. */\n\tprdf = (struct lpfc_els_rdf_req *)\n\t\t(((struct lpfc_dmabuf *)elsiocb->context2)->virt);\n\tmemset(prdf, 0, cmdsize);\n\tprdf->rdf.fpin_cmd = ELS_RDF;\n\tprdf->rdf.desc_len = cpu_to_be32(sizeof(struct lpfc_els_rdf_req) -\n\t\t\t\t\t sizeof(struct fc_els_rdf));\n\tprdf->reg_d1.reg_desc.desc_tag = cpu_to_be32(ELS_DTAG_FPIN_REGISTER);\n\tprdf->reg_d1.reg_desc.desc_len = cpu_to_be32(\n\t\t\t\tFC_TLV_DESC_LENGTH_FROM_SZ(prdf->reg_d1));\n\tprdf->reg_d1.reg_desc.count = cpu_to_be32(ELS_RDF_REG_TAG_CNT);\n\tprdf->reg_d1.desc_tags[0] = cpu_to_be32(ELS_DTAG_LNK_INTEGRITY);\n\tprdf->reg_d1.desc_tags[1] = cpu_to_be32(ELS_DTAG_DELIVERY);\n\tprdf->reg_d1.desc_tags[2] = cpu_to_be32(ELS_DTAG_PEER_CONGEST);\n\tprdf->reg_d1.desc_tags[3] = cpu_to_be32(ELS_DTAG_CONGESTION);\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"6444 Xmit RDF to remote NPORT x%x\\n\",\n\t\t\t ndlp->nlp_DID);\n\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_disc_cmd;\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto node_err;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"Issue RDF:     did:x%x refcnt %d\",\n\t\t\t      ndlp->nlp_DID, kref_read(&ndlp->kref), 0);\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR)\n\t\tgoto io_err;\n\treturn 0;\n\n io_err:\n\tlpfc_nlp_put(ndlp);\n node_err:\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn -EIO;\n}\n\n/**\n * lpfc_cancel_retry_delay_tmo - Cancel the timer with delayed iocb-cmd retry\n * @vport: pointer to a host virtual N_Port data structure.\n * @nlp: pointer to a node-list data structure.\n *\n * This routine cancels the timer with a delayed IOCB-command retry for\n * a @vport's @ndlp. It stops the timer for the delayed function retrial and\n * removes the ELS retry event if it presents. In addition, if the\n * NLP_NPR_2B_DISC bit is set in the @nlp's nlp_flag bitmap, ADISC IOCB\n * commands are sent for the @vport's nodes that require issuing discovery\n * ADISC.\n **/\nvoid\nlpfc_cancel_retry_delay_tmo(struct lpfc_vport *vport, struct lpfc_nodelist *nlp)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_work_evt *evtp;\n\n\tif (!(nlp->nlp_flag & NLP_DELAY_TMO))\n\t\treturn;\n\tspin_lock_irq(&nlp->lock);\n\tnlp->nlp_flag &= ~NLP_DELAY_TMO;\n\tspin_unlock_irq(&nlp->lock);\n\tdel_timer_sync(&nlp->nlp_delayfunc);\n\tnlp->nlp_last_elscmd = 0;\n\tif (!list_empty(&nlp->els_retry_evt.evt_listp)) {\n\t\tlist_del_init(&nlp->els_retry_evt.evt_listp);\n\t\t/* Decrement nlp reference count held for the delayed retry */\n\t\tevtp = &nlp->els_retry_evt;\n\t\tlpfc_nlp_put((struct lpfc_nodelist *)evtp->evt_arg1);\n\t}\n\tif (nlp->nlp_flag & NLP_NPR_2B_DISC) {\n\t\tspin_lock_irq(&nlp->lock);\n\t\tnlp->nlp_flag &= ~NLP_NPR_2B_DISC;\n\t\tspin_unlock_irq(&nlp->lock);\n\t\tif (vport->num_disc_nodes) {\n\t\t\tif (vport->port_state < LPFC_VPORT_READY) {\n\t\t\t\t/* Check if there are more ADISCs to be sent */\n\t\t\t\tlpfc_more_adisc(vport);\n\t\t\t} else {\n\t\t\t\t/* Check if there are more PLOGIs to be sent */\n\t\t\t\tlpfc_more_plogi(vport);\n\t\t\t\tif (vport->num_disc_nodes == 0) {\n\t\t\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\t\t\tvport->fc_flag &= ~FC_NDISC_ACTIVE;\n\t\t\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t\t\tlpfc_can_disctmo(vport);\n\t\t\t\t\tlpfc_end_rscn(vport);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\n/**\n * lpfc_els_retry_delay - Timer function with a ndlp delayed function timer\n * @t: pointer to the timer function associated data (ndlp).\n *\n * This routine is invoked by the ndlp delayed-function timer to check\n * whether there is any pending ELS retry event(s) with the node. If not, it\n * simply returns. Otherwise, if there is at least one ELS delayed event, it\n * adds the delayed events to the HBA work list and invokes the\n * lpfc_worker_wake_up() routine to wake up worker thread to process the\n * event. Note that lpfc_nlp_get() is called before posting the event to\n * the work list to hold reference count of ndlp so that it guarantees the\n * reference to ndlp will still be available when the worker thread gets\n * to the event associated with the ndlp.\n **/\nvoid\nlpfc_els_retry_delay(struct timer_list *t)\n{\n\tstruct lpfc_nodelist *ndlp = from_timer(ndlp, t, nlp_delayfunc);\n\tstruct lpfc_vport *vport = ndlp->vport;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tunsigned long flags;\n\tstruct lpfc_work_evt  *evtp = &ndlp->els_retry_evt;\n\n\tspin_lock_irqsave(&phba->hbalock, flags);\n\tif (!list_empty(&evtp->evt_listp)) {\n\t\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\t\treturn;\n\t}\n\n\t/* We need to hold the node by incrementing the reference\n\t * count until the queued work is done\n\t */\n\tevtp->evt_arg1  = lpfc_nlp_get(ndlp);\n\tif (evtp->evt_arg1) {\n\t\tevtp->evt = LPFC_EVT_ELS_RETRY;\n\t\tlist_add_tail(&evtp->evt_listp, &phba->work_list);\n\t\tlpfc_worker_wake_up(phba);\n\t}\n\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\treturn;\n}\n\n/**\n * lpfc_els_retry_delay_handler - Work thread handler for ndlp delayed function\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine is the worker-thread handler for processing the @ndlp delayed\n * event(s), posted by the lpfc_els_retry_delay() routine. It simply retrieves\n * the last ELS command from the associated ndlp and invokes the proper ELS\n * function according to the delayed ELS command to retry the command.\n **/\nvoid\nlpfc_els_retry_delay_handler(struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_vport *vport = ndlp->vport;\n\tuint32_t cmd, retry;\n\n\tspin_lock_irq(&ndlp->lock);\n\tcmd = ndlp->nlp_last_elscmd;\n\tndlp->nlp_last_elscmd = 0;\n\n\tif (!(ndlp->nlp_flag & NLP_DELAY_TMO)) {\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\treturn;\n\t}\n\n\tndlp->nlp_flag &= ~NLP_DELAY_TMO;\n\tspin_unlock_irq(&ndlp->lock);\n\t/*\n\t * If a discovery event readded nlp_delayfunc after timer\n\t * firing and before processing the timer, cancel the\n\t * nlp_delayfunc.\n\t */\n\tdel_timer_sync(&ndlp->nlp_delayfunc);\n\tretry = ndlp->nlp_retry;\n\tndlp->nlp_retry = 0;\n\n\tswitch (cmd) {\n\tcase ELS_CMD_FLOGI:\n\t\tlpfc_issue_els_flogi(vport, ndlp, retry);\n\t\tbreak;\n\tcase ELS_CMD_PLOGI:\n\t\tif (!lpfc_issue_els_plogi(vport, ndlp->nlp_DID, retry)) {\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\n\t\t}\n\t\tbreak;\n\tcase ELS_CMD_ADISC:\n\t\tif (!lpfc_issue_els_adisc(vport, ndlp, retry)) {\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_ADISC_ISSUE);\n\t\t}\n\t\tbreak;\n\tcase ELS_CMD_PRLI:\n\tcase ELS_CMD_NVMEPRLI:\n\t\tif (!lpfc_issue_els_prli(vport, ndlp, retry)) {\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PRLI_ISSUE);\n\t\t}\n\t\tbreak;\n\tcase ELS_CMD_LOGO:\n\t\tif (!lpfc_issue_els_logo(vport, ndlp, retry)) {\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_LOGO_ISSUE);\n\t\t}\n\t\tbreak;\n\tcase ELS_CMD_FDISC:\n\t\tif (!(vport->fc_flag & FC_VPORT_NEEDS_INIT_VPI))\n\t\t\tlpfc_issue_els_fdisc(vport, ndlp, retry);\n\t\tbreak;\n\t}\n\treturn;\n}\n\n/**\n * lpfc_link_reset - Issue link reset\n * @vport: pointer to a virtual N_Port data structure.\n *\n * This routine performs link reset by sending INIT_LINK mailbox command.\n * For SLI-3 adapter, link attention interrupt is enabled before issuing\n * INIT_LINK mailbox command.\n *\n * Return code\n *   0 - Link reset initiated successfully\n *   1 - Failed to initiate link reset\n **/\nint\nlpfc_link_reset(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tLPFC_MBOXQ_t *mbox;\n\tuint32_t control;\n\tint rc;\n\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\n\t\t\t \"2851 Attempt link reset\\n\");\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2852 Failed to allocate mbox memory\");\n\t\treturn 1;\n\t}\n\n\t/* Enable Link attention interrupts */\n\tif (phba->sli_rev <= LPFC_SLI_REV3) {\n\t\tspin_lock_irq(&phba->hbalock);\n\t\tphba->sli.sli_flag |= LPFC_PROCESS_LA;\n\t\tcontrol = readl(phba->HCregaddr);\n\t\tcontrol |= HC_LAINT_ENA;\n\t\twritel(control, phba->HCregaddr);\n\t\treadl(phba->HCregaddr); /* flush */\n\t\tspin_unlock_irq(&phba->hbalock);\n\t}\n\n\tlpfc_init_link(phba, mbox, phba->cfg_topology,\n\t\t       phba->cfg_link_speed);\n\tmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\tmbox->vport = vport;\n\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\tif ((rc != MBX_BUSY) && (rc != MBX_SUCCESS)) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2853 Failed to issue INIT_LINK \"\n\t\t\t\t\"mbox command, rc:x%x\\n\", rc);\n\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * lpfc_els_retry - Make retry decision on an els command iocb\n * @phba: pointer to lpfc hba data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @rspiocb: pointer to lpfc response iocb data structure.\n *\n * This routine makes a retry decision on an ELS command IOCB, which has\n * failed. The following ELS IOCBs use this function for retrying the command\n * when previously issued command responsed with error status: FLOGI, PLOGI,\n * PRLI, ADISC, LOGO, and FDISC. Based on the ELS command type and the\n * returned error status, it makes the decision whether a retry shall be\n * issued for the command, and whether a retry shall be made immediately or\n * delayed. In the former case, the corresponding ELS command issuing-function\n * is called to retry the command. In the later case, the ELS command shall\n * be posted to the ndlp delayed event and delayed function timer set to the\n * ndlp for the delayed command issusing.\n *\n * Return code\n *   0 - No retry of els command is made\n *   1 - Immediate or delayed retry of els command is made\n **/\nstatic int\nlpfc_els_retry(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t       struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tIOCB_t *irsp = &rspiocb->iocb;\n\tstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) cmdiocb->context1;\n\tstruct lpfc_dmabuf *pcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\n\tuint32_t *elscmd;\n\tstruct ls_rjt stat;\n\tint retry = 0, maxretry = lpfc_max_els_tries, delay = 0;\n\tint logerr = 0;\n\tuint32_t cmd = 0;\n\tuint32_t did;\n\tint link_reset = 0, rc;\n\n\n\t/* Note: context2 may be 0 for internal driver abort\n\t * of delays ELS command.\n\t */\n\n\tif (pcmd && pcmd->virt) {\n\t\telscmd = (uint32_t *) (pcmd->virt);\n\t\tcmd = *elscmd++;\n\t}\n\n\tif (ndlp)\n\t\tdid = ndlp->nlp_DID;\n\telse {\n\t\t/* We should only hit this case for retrying PLOGI */\n\t\tdid = irsp->un.elsreq64.remoteID;\n\t\tndlp = lpfc_findnode_did(vport, did);\n\t\tif (!ndlp && (cmd != ELS_CMD_PLOGI))\n\t\t\treturn 1;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Retry ELS:       wd7:x%x wd4:x%x did:x%x\",\n\t\t*(((uint32_t *) irsp) + 7), irsp->un.ulpWord[4], ndlp->nlp_DID);\n\n\tswitch (irsp->ulpStatus) {\n\tcase IOSTAT_FCP_RSP_ERROR:\n\t\tbreak;\n\tcase IOSTAT_REMOTE_STOP:\n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\t/* This IO was aborted by the target, we don't\n\t\t\t * know the rxid and because we did not send the\n\t\t\t * ABTS we cannot generate and RRQ.\n\t\t\t */\n\t\t\tlpfc_set_rrq_active(phba, ndlp,\n\t\t\t\t\t cmdiocb->sli4_lxritag, 0, 0);\n\t\t}\n\t\tbreak;\n\tcase IOSTAT_LOCAL_REJECT:\n\t\tswitch ((irsp->un.ulpWord[4] & IOERR_PARAM_MASK)) {\n\t\tcase IOERR_LOOP_OPEN_FAILURE:\n\t\t\tif (cmd == ELS_CMD_FLOGI) {\n\t\t\t\tif (PCI_DEVICE_ID_HORNET ==\n\t\t\t\t\tphba->pcidev->device) {\n\t\t\t\t\tphba->fc_topology = LPFC_TOPOLOGY_LOOP;\n\t\t\t\t\tphba->pport->fc_myDID = 0;\n\t\t\t\t\tphba->alpa_map[0] = 0;\n\t\t\t\t\tphba->alpa_map[1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cmd == ELS_CMD_PLOGI && cmdiocb->retry == 0)\n\t\t\t\tdelay = 1000;\n\t\t\tretry = 1;\n\t\t\tbreak;\n\n\t\tcase IOERR_ILLEGAL_COMMAND:\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"0124 Retry illegal cmd x%x \"\n\t\t\t\t\t \"retry:x%x delay:x%x\\n\",\n\t\t\t\t\t cmd, cmdiocb->retry, delay);\n\t\t\tretry = 1;\n\t\t\t/* All command's retry policy */\n\t\t\tmaxretry = 8;\n\t\t\tif (cmdiocb->retry > 2)\n\t\t\t\tdelay = 1000;\n\t\t\tbreak;\n\n\t\tcase IOERR_NO_RESOURCES:\n\t\t\tlogerr = 1; /* HBA out of resources */\n\t\t\tretry = 1;\n\t\t\tif (cmdiocb->retry > 100)\n\t\t\t\tdelay = 100;\n\t\t\tmaxretry = 250;\n\t\t\tbreak;\n\n\t\tcase IOERR_ILLEGAL_FRAME:\n\t\t\tdelay = 100;\n\t\t\tretry = 1;\n\t\t\tbreak;\n\n\t\tcase IOERR_INVALID_RPI:\n\t\t\tif (cmd == ELS_CMD_PLOGI &&\n\t\t\t    did == NameServer_DID) {\n\t\t\t\t/* Continue forever if plogi to */\n\t\t\t\t/* the nameserver fails */\n\t\t\t\tmaxretry = 0;\n\t\t\t\tdelay = 100;\n\t\t\t}\n\t\t\tretry = 1;\n\t\t\tbreak;\n\n\t\tcase IOERR_SEQUENCE_TIMEOUT:\n\t\t\tif (cmd == ELS_CMD_PLOGI &&\n\t\t\t    did == NameServer_DID &&\n\t\t\t    (cmdiocb->retry + 1) == maxretry) {\n\t\t\t\t/* Reset the Link */\n\t\t\t\tlink_reset = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretry = 1;\n\t\t\tdelay = 100;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IOSTAT_NPORT_RJT:\n\tcase IOSTAT_FABRIC_RJT:\n\t\tif (irsp->un.ulpWord[4] & RJT_UNAVAIL_TEMP) {\n\t\t\tretry = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IOSTAT_NPORT_BSY:\n\tcase IOSTAT_FABRIC_BSY:\n\t\tlogerr = 1; /* Fabric / Remote NPort out of resources */\n\t\tretry = 1;\n\t\tbreak;\n\n\tcase IOSTAT_LS_RJT:\n\t\tstat.un.lsRjtError = be32_to_cpu(irsp->un.ulpWord[4]);\n\t\t/* Added for Vendor specifc support\n\t\t * Just keep retrying for these Rsn / Exp codes\n\t\t */\n\t\tswitch (stat.un.b.lsRjtRsnCode) {\n\t\tcase LSRJT_UNABLE_TPC:\n\t\t\t/* The driver has a VALID PLOGI but the rport has\n\t\t\t * rejected the PRLI - can't do it now.  Delay\n\t\t\t * for 1 second and try again.\n\t\t\t *\n\t\t\t * However, if explanation is REQ_UNSUPPORTED there's\n\t\t\t * no point to retry PRLI.\n\t\t\t */\n\t\t\tif ((cmd == ELS_CMD_PRLI || cmd == ELS_CMD_NVMEPRLI) &&\n\t\t\t    stat.un.b.lsRjtRsnCodeExp !=\n\t\t\t    LSEXP_REQ_UNSUPPORTED) {\n\t\t\t\tdelay = 1000;\n\t\t\t\tmaxretry = lpfc_max_els_tries + 1;\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Legacy bug fix code for targets with PLOGI delays. */\n\t\t\tif (stat.un.b.lsRjtRsnCodeExp ==\n\t\t\t    LSEXP_CMD_IN_PROGRESS) {\n\t\t\t\tif (cmd == ELS_CMD_PLOGI) {\n\t\t\t\t\tdelay = 1000;\n\t\t\t\t\tmaxretry = 48;\n\t\t\t\t}\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (stat.un.b.lsRjtRsnCodeExp ==\n\t\t\t    LSEXP_CANT_GIVE_DATA) {\n\t\t\t\tif (cmd == ELS_CMD_PLOGI) {\n\t\t\t\t\tdelay = 1000;\n\t\t\t\t\tmaxretry = 48;\n\t\t\t\t}\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cmd == ELS_CMD_PLOGI) {\n\t\t\t\tdelay = 1000;\n\t\t\t\tmaxretry = lpfc_max_els_tries + 1;\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&\n\t\t\t  (cmd == ELS_CMD_FDISC) &&\n\t\t\t  (stat.un.b.lsRjtRsnCodeExp == LSEXP_OUT_OF_RESOURCE)){\n\t\t\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t\t\t \"0125 FDISC Failed (x%x). \"\n\t\t\t\t\t\t \"Fabric out of resources\\n\",\n\t\t\t\t\t\t stat.un.lsRjtError);\n\t\t\t\tlpfc_vport_set_state(vport,\n\t\t\t\t\t\t     FC_VPORT_NO_FABRIC_RSCS);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LSRJT_LOGICAL_BSY:\n\t\t\tif ((cmd == ELS_CMD_PLOGI) ||\n\t\t\t    (cmd == ELS_CMD_PRLI) ||\n\t\t\t    (cmd == ELS_CMD_NVMEPRLI)) {\n\t\t\t\tdelay = 1000;\n\t\t\t\tmaxretry = 48;\n\t\t\t} else if (cmd == ELS_CMD_FDISC) {\n\t\t\t\t/* FDISC retry policy */\n\t\t\t\tmaxretry = 48;\n\t\t\t\tif (cmdiocb->retry >= 32)\n\t\t\t\t\tdelay = 1000;\n\t\t\t}\n\t\t\tretry = 1;\n\t\t\tbreak;\n\n\t\tcase LSRJT_LOGICAL_ERR:\n\t\t\t/* There are some cases where switches return this\n\t\t\t * error when they are not ready and should be returning\n\t\t\t * Logical Busy. We should delay every time.\n\t\t\t */\n\t\t\tif (cmd == ELS_CMD_FDISC &&\n\t\t\t    stat.un.b.lsRjtRsnCodeExp == LSEXP_PORT_LOGIN_REQ) {\n\t\t\t\tmaxretry = 3;\n\t\t\t\tdelay = 1000;\n\t\t\t\tretry = 1;\n\t\t\t} else if (cmd == ELS_CMD_FLOGI &&\n\t\t\t\t   stat.un.b.lsRjtRsnCodeExp ==\n\t\t\t\t\t\tLSEXP_NOTHING_MORE) {\n\t\t\t\tvport->fc_sparam.cmn.bbRcvSizeMsb &= 0xf;\n\t\t\t\tretry = 1;\n\t\t\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t\t\t \"0820 FLOGI Failed (x%x). \"\n\t\t\t\t\t\t \"BBCredit Not Supported\\n\",\n\t\t\t\t\t\t stat.un.lsRjtError);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LSRJT_PROTOCOL_ERR:\n\t\t\tif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&\n\t\t\t  (cmd == ELS_CMD_FDISC) &&\n\t\t\t  ((stat.un.b.lsRjtRsnCodeExp == LSEXP_INVALID_PNAME) ||\n\t\t\t  (stat.un.b.lsRjtRsnCodeExp == LSEXP_INVALID_NPORT_ID))\n\t\t\t  ) {\n\t\t\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t\t\t \"0122 FDISC Failed (x%x). \"\n\t\t\t\t\t\t \"Fabric Detected Bad WWN\\n\",\n\t\t\t\t\t\t stat.un.lsRjtError);\n\t\t\t\tlpfc_vport_set_state(vport,\n\t\t\t\t\t\t     FC_VPORT_FABRIC_REJ_WWN);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LSRJT_VENDOR_UNIQUE:\n\t\t\tif ((stat.un.b.vendorUnique == 0x45) &&\n\t\t\t    (cmd == ELS_CMD_FLOGI)) {\n\t\t\t\tgoto out_retry;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LSRJT_CMD_UNSUPPORTED:\n\t\t\t/* lpfc nvmet returns this type of LS_RJT when it\n\t\t\t * receives an FCP PRLI because lpfc nvmet only\n\t\t\t * support NVME.  ELS request is terminated for FCP4\n\t\t\t * on this rport.\n\t\t\t */\n\t\t\tif (stat.un.b.lsRjtRsnCodeExp ==\n\t\t\t    LSEXP_REQ_UNSUPPORTED && cmd == ELS_CMD_PRLI) {\n\t\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\t\tndlp->nlp_flag |= NLP_FCP_PRLI_RJT;\n\t\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\t\tretry = 0;\n\t\t\t\tgoto out_retry;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IOSTAT_INTERMED_RSP:\n\tcase IOSTAT_BA_RJT:\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (link_reset) {\n\t\trc = lpfc_link_reset(vport);\n\t\tif (rc) {\n\t\t\t/* Do not give up. Retry PLOGI one more time and attempt\n\t\t\t * link reset if PLOGI fails again.\n\t\t\t */\n\t\t\tretry = 1;\n\t\t\tdelay = 100;\n\t\t\tgoto out_retry;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (did == FDMI_DID)\n\t\tretry = 1;\n\n\tif ((cmd == ELS_CMD_FLOGI) &&\n\t    (phba->fc_topology != LPFC_TOPOLOGY_LOOP) &&\n\t    !lpfc_error_lost_link(irsp)) {\n\t\t/* FLOGI retry policy */\n\t\tretry = 1;\n\t\t/* retry FLOGI forever */\n\t\tif (phba->link_flag != LS_LOOPBACK_MODE)\n\t\t\tmaxretry = 0;\n\t\telse\n\t\t\tmaxretry = 2;\n\n\t\tif (cmdiocb->retry >= 100)\n\t\t\tdelay = 5000;\n\t\telse if (cmdiocb->retry >= 32)\n\t\t\tdelay = 1000;\n\t} else if ((cmd == ELS_CMD_FDISC) && !lpfc_error_lost_link(irsp)) {\n\t\t/* retry FDISCs every second up to devloss */\n\t\tretry = 1;\n\t\tmaxretry = vport->cfg_devloss_tmo;\n\t\tdelay = 1000;\n\t}\n\n\tcmdiocb->retry++;\n\tif (maxretry && (cmdiocb->retry >= maxretry)) {\n\t\tphba->fc_stat.elsRetryExceeded++;\n\t\tretry = 0;\n\t}\n\n\tif ((vport->load_flag & FC_UNLOADING) != 0)\n\t\tretry = 0;\n\nout_retry:\n\tif (retry) {\n\t\tif ((cmd == ELS_CMD_PLOGI) || (cmd == ELS_CMD_FDISC)) {\n\t\t\t/* Stop retrying PLOGI and FDISC if in FCF discovery */\n\t\t\tif (phba->fcf.fcf_flag & FCF_DISCOVERY) {\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t\t\t \"2849 Stop retry ELS command \"\n\t\t\t\t\t\t \"x%x to remote NPORT x%x, \"\n\t\t\t\t\t\t \"Data: x%x x%x\\n\", cmd, did,\n\t\t\t\t\t\t cmdiocb->retry, delay);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/* Retry ELS command <elsCmd> to remote NPORT <did> */\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"0107 Retry ELS command x%x to remote \"\n\t\t\t\t \"NPORT x%x Data: x%x x%x\\n\",\n\t\t\t\t cmd, did, cmdiocb->retry, delay);\n\n\t\tif (((cmd == ELS_CMD_PLOGI) || (cmd == ELS_CMD_ADISC)) &&\n\t\t\t((irsp->ulpStatus != IOSTAT_LOCAL_REJECT) ||\n\t\t\t((irsp->un.ulpWord[4] & IOERR_PARAM_MASK) !=\n\t\t\tIOERR_NO_RESOURCES))) {\n\t\t\t/* Don't reset timer for no resources */\n\n\t\t\t/* If discovery / RSCN timer is running, reset it */\n\t\t\tif (timer_pending(&vport->fc_disctmo) ||\n\t\t\t    (vport->fc_flag & FC_RSCN_MODE))\n\t\t\t\tlpfc_set_disctmo(vport);\n\t\t}\n\n\t\tphba->fc_stat.elsXmitRetry++;\n\t\tif (ndlp && delay) {\n\t\t\tphba->fc_stat.elsDelayRetry++;\n\t\t\tndlp->nlp_retry = cmdiocb->retry;\n\n\t\t\t/* delay is specified in milliseconds */\n\t\t\tmod_timer(&ndlp->nlp_delayfunc,\n\t\t\t\tjiffies + msecs_to_jiffies(delay));\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag |= NLP_DELAY_TMO;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tif ((cmd == ELS_CMD_PRLI) ||\n\t\t\t    (cmd == ELS_CMD_NVMEPRLI))\n\t\t\t\tlpfc_nlp_set_state(vport, ndlp,\n\t\t\t\t\tNLP_STE_PRLI_ISSUE);\n\t\t\telse\n\t\t\t\tlpfc_nlp_set_state(vport, ndlp,\n\t\t\t\t\tNLP_STE_NPR_NODE);\n\t\t\tndlp->nlp_last_elscmd = cmd;\n\n\t\t\treturn 1;\n\t\t}\n\t\tswitch (cmd) {\n\t\tcase ELS_CMD_FLOGI:\n\t\t\tlpfc_issue_els_flogi(vport, ndlp, cmdiocb->retry);\n\t\t\treturn 1;\n\t\tcase ELS_CMD_FDISC:\n\t\t\tlpfc_issue_els_fdisc(vport, ndlp, cmdiocb->retry);\n\t\t\treturn 1;\n\t\tcase ELS_CMD_PLOGI:\n\t\t\tif (ndlp) {\n\t\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\t\tlpfc_nlp_set_state(vport, ndlp,\n\t\t\t\t\t\t   NLP_STE_PLOGI_ISSUE);\n\t\t\t}\n\t\t\tlpfc_issue_els_plogi(vport, did, cmdiocb->retry);\n\t\t\treturn 1;\n\t\tcase ELS_CMD_ADISC:\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_ADISC_ISSUE);\n\t\t\tlpfc_issue_els_adisc(vport, ndlp, cmdiocb->retry);\n\t\t\treturn 1;\n\t\tcase ELS_CMD_PRLI:\n\t\tcase ELS_CMD_NVMEPRLI:\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PRLI_ISSUE);\n\t\t\tlpfc_issue_els_prli(vport, ndlp, cmdiocb->retry);\n\t\t\treturn 1;\n\t\tcase ELS_CMD_LOGO:\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_LOGO_ISSUE);\n\t\t\tlpfc_issue_els_logo(vport, ndlp, cmdiocb->retry);\n\t\t\treturn 1;\n\t\t}\n\t}\n\t/* No retry ELS command <elsCmd> to remote NPORT <did> */\n\tif (logerr) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0137 No retry ELS command x%x to remote \"\n\t\t\t \"NPORT x%x: Out of Resources: Error:x%x/%x\\n\",\n\t\t\t cmd, did, irsp->ulpStatus,\n\t\t\t irsp->un.ulpWord[4]);\n\t}\n\telse {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0108 No retry ELS command x%x to remote \"\n\t\t\t \"NPORT x%x Retried:%d Error:x%x/%x\\n\",\n\t\t\t cmd, did, cmdiocb->retry, irsp->ulpStatus,\n\t\t\t irsp->un.ulpWord[4]);\n\t}\n\treturn 0;\n}\n\n/**\n * lpfc_els_free_data - Free lpfc dma buffer and data structure with an iocb\n * @phba: pointer to lpfc hba data structure.\n * @buf_ptr1: pointer to the lpfc DMA buffer data structure.\n *\n * This routine releases the lpfc DMA (Direct Memory Access) buffer(s)\n * associated with a command IOCB back to the lpfc DMA buffer pool. It first\n * checks to see whether there is a lpfc DMA buffer associated with the\n * response of the command IOCB. If so, it will be released before releasing\n * the lpfc DMA buffer associated with the IOCB itself.\n *\n * Return code\n *   0 - Successfully released lpfc DMA buffer (currently, always return 0)\n **/\nstatic int\nlpfc_els_free_data(struct lpfc_hba *phba, struct lpfc_dmabuf *buf_ptr1)\n{\n\tstruct lpfc_dmabuf *buf_ptr;\n\n\t/* Free the response before processing the command. */\n\tif (!list_empty(&buf_ptr1->list)) {\n\t\tlist_remove_head(&buf_ptr1->list, buf_ptr,\n\t\t\t\t struct lpfc_dmabuf,\n\t\t\t\t list);\n\t\tlpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);\n\t\tkfree(buf_ptr);\n\t}\n\tlpfc_mbuf_free(phba, buf_ptr1->virt, buf_ptr1->phys);\n\tkfree(buf_ptr1);\n\treturn 0;\n}\n\n/**\n * lpfc_els_free_bpl - Free lpfc dma buffer and data structure with bpl\n * @phba: pointer to lpfc hba data structure.\n * @buf_ptr: pointer to the lpfc dma buffer data structure.\n *\n * This routine releases the lpfc Direct Memory Access (DMA) buffer\n * associated with a Buffer Pointer List (BPL) back to the lpfc DMA buffer\n * pool.\n *\n * Return code\n *   0 - Successfully released lpfc DMA buffer (currently, always return 0)\n **/\nstatic int\nlpfc_els_free_bpl(struct lpfc_hba *phba, struct lpfc_dmabuf *buf_ptr)\n{\n\tlpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);\n\tkfree(buf_ptr);\n\treturn 0;\n}\n\n/**\n * lpfc_els_free_iocb - Free a command iocb and its associated resources\n * @phba: pointer to lpfc hba data structure.\n * @elsiocb: pointer to lpfc els command iocb data structure.\n *\n * This routine frees a command IOCB and its associated resources. The\n * command IOCB data structure contains the reference to various associated\n * resources, these fields must be set to NULL if the associated reference\n * not present:\n *   context1 - reference to ndlp\n *   context2 - reference to cmd\n *   context2->next - reference to rsp\n *   context3 - reference to bpl\n *\n * It first properly decrements the reference count held on ndlp for the\n * IOCB completion callback function. If LPFC_DELAY_MEM_FREE flag is not\n * set, it invokes the lpfc_els_free_data() routine to release the Direct\n * Memory Access (DMA) buffers associated with the IOCB. Otherwise, it\n * adds the DMA buffer the @phba data structure for the delayed release.\n * If reference to the Buffer Pointer List (BPL) is present, the\n * lpfc_els_free_bpl() routine is invoked to release the DMA memory\n * associated with BPL. Finally, the lpfc_sli_release_iocbq() routine is\n * invoked to release the IOCB data structure back to @phba IOCBQ list.\n *\n * Return code\n *   0 - Success (currently, always return 0)\n **/\nint\nlpfc_els_free_iocb(struct lpfc_hba *phba, struct lpfc_iocbq *elsiocb)\n{\n\tstruct lpfc_dmabuf *buf_ptr, *buf_ptr1;\n\n\t/* The I/O job is complete.  Clear the context1 data. */\n\telsiocb->context1 = NULL;\n\n\t/* context2  = cmd,  context2->next = rsp, context3 = bpl */\n\tif (elsiocb->context2) {\n\t\tif (elsiocb->iocb_flag & LPFC_DELAY_MEM_FREE) {\n\t\t\t/* Firmware could still be in progress of DMAing\n\t\t\t * payload, so don't free data buffer till after\n\t\t\t * a hbeat.\n\t\t\t */\n\t\t\telsiocb->iocb_flag &= ~LPFC_DELAY_MEM_FREE;\n\t\t\tbuf_ptr = elsiocb->context2;\n\t\t\telsiocb->context2 = NULL;\n\t\t\tif (buf_ptr) {\n\t\t\t\tbuf_ptr1 = NULL;\n\t\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\t\tif (!list_empty(&buf_ptr->list)) {\n\t\t\t\t\tlist_remove_head(&buf_ptr->list,\n\t\t\t\t\t\tbuf_ptr1, struct lpfc_dmabuf,\n\t\t\t\t\t\tlist);\n\t\t\t\t\tINIT_LIST_HEAD(&buf_ptr1->list);\n\t\t\t\t\tlist_add_tail(&buf_ptr1->list,\n\t\t\t\t\t\t&phba->elsbuf);\n\t\t\t\t\tphba->elsbuf_cnt++;\n\t\t\t\t}\n\t\t\t\tINIT_LIST_HEAD(&buf_ptr->list);\n\t\t\t\tlist_add_tail(&buf_ptr->list, &phba->elsbuf);\n\t\t\t\tphba->elsbuf_cnt++;\n\t\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\t}\n\t\t} else {\n\t\t\tbuf_ptr1 = (struct lpfc_dmabuf *) elsiocb->context2;\n\t\t\tlpfc_els_free_data(phba, buf_ptr1);\n\t\t\telsiocb->context2 = NULL;\n\t\t}\n\t}\n\n\tif (elsiocb->context3) {\n\t\tbuf_ptr = (struct lpfc_dmabuf *) elsiocb->context3;\n\t\tlpfc_els_free_bpl(phba, buf_ptr);\n\t\telsiocb->context3 = NULL;\n\t}\n\tlpfc_sli_release_iocbq(phba, elsiocb);\n\treturn 0;\n}\n\n/**\n * lpfc_cmpl_els_logo_acc - Completion callback function to logo acc response\n * @phba: pointer to lpfc hba data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @rspiocb: pointer to lpfc response iocb data structure.\n *\n * This routine is the completion callback function to the Logout (LOGO)\n * Accept (ACC) Response ELS command. This routine is invoked to indicate\n * the completion of the LOGO process. It invokes the lpfc_nlp_not_used() to\n * release the ndlp if it has the last reference remaining (reference count\n * is 1). If succeeded (meaning ndlp released), it sets the IOCB context1\n * field to NULL to inform the following lpfc_els_free_iocb() routine no\n * ndlp reference count needs to be decremented. Otherwise, the ndlp\n * reference use-count shall be decremented by the lpfc_els_free_iocb()\n * routine. Finally, the lpfc_els_free_iocb() is invoked to release the\n * IOCB data structure.\n **/\nstatic void\nlpfc_cmpl_els_logo_acc(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t       struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) cmdiocb->context1;\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tIOCB_t *irsp;\n\n\tirsp = &rspiocb->iocb;\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t\"ACC LOGO cmpl:   status:x%x/x%x did:x%x\",\n\t\tirsp->ulpStatus, irsp->un.ulpWord[4], ndlp->nlp_DID);\n\t/* ACC to LOGO completes to NPort <nlp_DID> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0109 ACC to LOGO completes to NPort x%x refcnt %d\"\n\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, kref_read(&ndlp->kref), ndlp->nlp_flag,\n\t\t\t ndlp->nlp_state, ndlp->nlp_rpi);\n\n\tif (ndlp->nlp_state == NLP_STE_NPR_NODE) {\n\t\t/* NPort Recovery mode or node is just allocated */\n\t\tif (!lpfc_nlp_not_used(ndlp)) {\n\t\t\t/* If the ndlp is being used by another discovery\n\t\t\t * thread, just unregister the RPI.\n\t\t\t */\n\t\t\tlpfc_unreg_rpi(vport, ndlp);\n\t\t} else {\n\t\t\t/* Indicate the node has already released, should\n\t\t\t * not reference to it from within lpfc_els_free_iocb.\n\t\t\t */\n\t\t\tcmdiocb->context1 = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * The driver received a LOGO from the rport and has ACK'd it.\n\t * At this point, the driver is done so release the IOCB\n\t */\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n}\n\n/**\n * lpfc_mbx_cmpl_dflt_rpi - Completion callbk func for unreg dflt rpi mbox cmd\n * @phba: pointer to lpfc hba data structure.\n * @pmb: pointer to the driver internal queue element for mailbox command.\n *\n * This routine is the completion callback function for unregister default\n * RPI (Remote Port Index) mailbox command to the @phba. It simply releases\n * the associated lpfc Direct Memory Access (DMA) buffer back to the pool and\n * decrements the ndlp reference count held for this completion callback\n * function. After that, it invokes the lpfc_nlp_not_used() to check\n * whether there is only one reference left on the ndlp. If so, it will\n * perform one more decrement and trigger the release of the ndlp.\n **/\nvoid\nlpfc_mbx_cmpl_dflt_rpi(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tstruct lpfc_dmabuf *mp = (struct lpfc_dmabuf *)(pmb->ctx_buf);\n\tstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *)pmb->ctx_ndlp;\n\n\tpmb->ctx_buf = NULL;\n\tpmb->ctx_ndlp = NULL;\n\n\tlpfc_mbuf_free(phba, mp->virt, mp->phys);\n\tkfree(mp);\n\tmempool_free(pmb, phba->mbox_mem_pool);\n\tif (ndlp) {\n\t\tlpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_NODE,\n\t\t\t\t \"0006 rpi x%x DID:%x flg:%x %d x%px\\n\",\n\t\t\t\t ndlp->nlp_rpi, ndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\t\t kref_read(&ndlp->kref),\n\t\t\t\t ndlp);\n\t\t/* This is the end of the default RPI cleanup logic for\n\t\t * this ndlp and it could get released.  Clear the nlp_flags to\n\t\t * prevent any further processing.\n\t\t */\n\t\tndlp->nlp_flag &= ~NLP_REG_LOGIN_SEND;\n\t\tlpfc_nlp_put(ndlp);\n\t\tlpfc_nlp_not_used(ndlp);\n\t}\n\n\treturn;\n}\n\n/**\n * lpfc_cmpl_els_rsp - Completion callback function for els response iocb cmd\n * @phba: pointer to lpfc hba data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @rspiocb: pointer to lpfc response iocb data structure.\n *\n * This routine is the completion callback function for ELS Response IOCB\n * command. In normal case, this callback function just properly sets the\n * nlp_flag bitmap in the ndlp data structure, if the mbox command reference\n * field in the command IOCB is not NULL, the referred mailbox command will\n * be send out, and then invokes the lpfc_els_free_iocb() routine to release\n * the IOCB. Under error conditions, such as when a LS_RJT is returned or a\n * link down event occurred during the discovery, the lpfc_nlp_not_used()\n * routine shall be invoked trying to release the ndlp if no other threads\n * are currently referring it.\n **/\nstatic void\nlpfc_cmpl_els_rsp(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t  struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) cmdiocb->context1;\n\tstruct lpfc_vport *vport = ndlp ? ndlp->vport : NULL;\n\tstruct Scsi_Host  *shost = vport ? lpfc_shost_from_vport(vport) : NULL;\n\tIOCB_t  *irsp;\n\tuint8_t *pcmd;\n\tLPFC_MBOXQ_t *mbox = NULL;\n\tstruct lpfc_dmabuf *mp = NULL;\n\tuint32_t ls_rjt = 0;\n\n\tirsp = &rspiocb->iocb;\n\n\tif (!vport) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"3177 ELS response failed\\n\");\n\t\tgoto out;\n\t}\n\tif (cmdiocb->context_un.mbox)\n\t\tmbox = cmdiocb->context_un.mbox;\n\n\t/* First determine if this is a LS_RJT cmpl. Note, this callback\n\t * function can have cmdiocb->contest1 (ndlp) field set to NULL.\n\t */\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) cmdiocb->context2)->virt);\n\tif (ndlp && (*((uint32_t *) (pcmd)) == ELS_CMD_LS_RJT)) {\n\t\t/* A LS_RJT associated with Default RPI cleanup has its own\n\t\t * separate code path.\n\t\t */\n\t\tif (!(ndlp->nlp_flag & NLP_RM_DFLT_RPI))\n\t\t\tls_rjt = 1;\n\t}\n\n\t/* Check to see if link went down during discovery */\n\tif (!ndlp || lpfc_els_chk_latt(vport)) {\n\t\tif (mbox) {\n\t\t\tmp = (struct lpfc_dmabuf *)mbox->ctx_buf;\n\t\t\tif (mp) {\n\t\t\t\tlpfc_mbuf_free(phba, mp->virt, mp->phys);\n\t\t\t\tkfree(mp);\n\t\t\t}\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\t}\n\t\tif (ndlp && (ndlp->nlp_flag & NLP_RM_DFLT_RPI))\n\t\t\tif (lpfc_nlp_not_used(ndlp)) {\n\t\t\t\tndlp = NULL;\n\t\t\t\t/* Indicate the node has already released,\n\t\t\t\t * should not reference to it from within\n\t\t\t\t * the routine lpfc_els_free_iocb.\n\t\t\t\t */\n\t\t\t\tcmdiocb->context1 = NULL;\n\t\t\t}\n\t\tgoto out;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t\"ELS rsp cmpl:    status:x%x/x%x did:x%x\",\n\t\tirsp->ulpStatus, irsp->un.ulpWord[4],\n\t\tcmdiocb->iocb.un.elsreq64.remoteID);\n\t/* ELS response tag <ulpIoTag> completes */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0110 ELS response tag x%x completes \"\n\t\t\t \"Data: x%x x%x x%x x%x x%x x%x x%x\\n\",\n\t\t\t cmdiocb->iocb.ulpIoTag, rspiocb->iocb.ulpStatus,\n\t\t\t rspiocb->iocb.un.ulpWord[4], rspiocb->iocb.ulpTimeout,\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t ndlp->nlp_rpi);\n\tif (mbox) {\n\t\tif ((rspiocb->iocb.ulpStatus == 0) &&\n\t\t    (ndlp->nlp_flag & NLP_ACC_REGLOGIN)) {\n\t\t\tif (!lpfc_unreg_rpi(vport, ndlp) &&\n\t\t\t    (!(vport->fc_flag & FC_PT2PT))) {\n\t\t\t\tif (ndlp->nlp_state == NLP_STE_REG_LOGIN_ISSUE) {\n\t\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\t\t\t LOG_DISCOVERY,\n\t\t\t\t\t\t\t \"0314 PLOGI recov \"\n\t\t\t\t\t\t\t \"DID x%x \"\n\t\t\t\t\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t\t\t\t\t ndlp->nlp_DID,\n\t\t\t\t\t\t\t ndlp->nlp_state,\n\t\t\t\t\t\t\t ndlp->nlp_rpi,\n\t\t\t\t\t\t\t ndlp->nlp_flag);\n\t\t\t\t\tmp = mbox->ctx_buf;\n\t\t\t\t\tif (mp) {\n\t\t\t\t\t\tlpfc_mbuf_free(phba, mp->virt,\n\t\t\t\t\t\t\t       mp->phys);\n\t\t\t\t\t\tkfree(mp);\n\t\t\t\t\t}\n\t\t\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Increment reference count to ndlp to hold the\n\t\t\t * reference to ndlp for the callback function.\n\t\t\t */\n\t\t\tmbox->ctx_ndlp = lpfc_nlp_get(ndlp);\n\t\t\tif (!mbox->ctx_ndlp)\n\t\t\t\tgoto out;\n\n\t\t\tmbox->vport = vport;\n\t\t\tif (ndlp->nlp_flag & NLP_RM_DFLT_RPI) {\n\t\t\t\tmbox->mbox_flag |= LPFC_MBX_IMED_UNREG;\n\t\t\t\tmbox->mbox_cmpl = lpfc_mbx_cmpl_dflt_rpi;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmbox->mbox_cmpl = lpfc_mbx_cmpl_reg_login;\n\t\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\t\tlpfc_nlp_set_state(vport, ndlp,\n\t\t\t\t\t   NLP_STE_REG_LOGIN_ISSUE);\n\t\t\t}\n\n\t\t\tndlp->nlp_flag |= NLP_REG_LOGIN_SEND;\n\t\t\tif (lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT)\n\t\t\t    != MBX_NOT_FINISHED)\n\t\t\t\tgoto out;\n\n\t\t\t/* Decrement the ndlp reference count we\n\t\t\t * set for this failed mailbox command.\n\t\t\t */\n\t\t\tlpfc_nlp_put(ndlp);\n\t\t\tndlp->nlp_flag &= ~NLP_REG_LOGIN_SEND;\n\n\t\t\t/* ELS rsp: Cannot issue reg_login for <NPortid> */\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"0138 ELS rsp: Cannot issue reg_login for x%x \"\n\t\t\t\t\"Data: x%x x%x x%x\\n\",\n\t\t\t\tndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t\tndlp->nlp_rpi);\n\n\t\t\tif (lpfc_nlp_not_used(ndlp)) {\n\t\t\t\tndlp = NULL;\n\t\t\t\t/* Indicate node has already been released,\n\t\t\t\t * should not reference to it from within\n\t\t\t\t * the routine lpfc_els_free_iocb.\n\t\t\t\t */\n\t\t\t\tcmdiocb->context1 = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Do not drop node for lpfc_els_abort'ed ELS cmds */\n\t\t\tif (!lpfc_error_lost_link(irsp) &&\n\t\t\t    ndlp->nlp_flag & NLP_ACC_REGLOGIN) {\n\t\t\t\tif (lpfc_nlp_not_used(ndlp)) {\n\t\t\t\t\tndlp = NULL;\n\t\t\t\t\t/* Indicate node has already been\n\t\t\t\t\t * released, should not reference\n\t\t\t\t\t * to it from within the routine\n\t\t\t\t\t * lpfc_els_free_iocb.\n\t\t\t\t\t */\n\t\t\t\t\tcmdiocb->context1 = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmp = (struct lpfc_dmabuf *)mbox->ctx_buf;\n\t\tif (mp) {\n\t\t\tlpfc_mbuf_free(phba, mp->virt, mp->phys);\n\t\t\tkfree(mp);\n\t\t}\n\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t}\nout:\n\tif (ndlp && shost) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tif (mbox)\n\t\t\tndlp->nlp_flag &= ~NLP_ACC_REGLOGIN;\n\t\tndlp->nlp_flag &= ~NLP_RM_DFLT_RPI;\n\t\tspin_unlock_irq(&ndlp->lock);\n\n\t\t/* If the node is not being used by another discovery thread,\n\t\t * and we are sending a reject, we are done with it.\n\t\t * Release driver reference count here and free associated\n\t\t * resources.\n\t\t */\n\t\tif (ls_rjt)\n\t\t\tif (lpfc_nlp_not_used(ndlp))\n\t\t\t\t/* Indicate node has already been released,\n\t\t\t\t * should not reference to it from within\n\t\t\t\t * the routine lpfc_els_free_iocb.\n\t\t\t\t */\n\t\t\t\tcmdiocb->context1 = NULL;\n\t}\n\n\t/* Release the originating I/O reference. */\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n\treturn;\n}\n\n/**\n * lpfc_els_rsp_acc - Prepare and issue an acc response iocb command\n * @vport: pointer to a host virtual N_Port data structure.\n * @flag: the els command code to be accepted.\n * @oldiocb: pointer to the original lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n * @mbox: pointer to the driver internal queue element for mailbox command.\n *\n * This routine prepares and issues an Accept (ACC) response IOCB\n * command. It uses the @flag to properly set up the IOCB field for the\n * specific ACC response command to be issued and invokes the\n * lpfc_sli_issue_iocb() routine to send out ACC response IOCB. If a\n * @mbox pointer is passed in, it will be put into the context_un.mbox\n * field of the IOCB for the completion callback function to issue the\n * mailbox command to the HBA later when callback is invoked.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the corresponding response ELS IOCB command.\n *\n * Return code\n *   0 - Successfully issued acc response\n *   1 - Failed to issue acc response\n **/\nint\nlpfc_els_rsp_acc(struct lpfc_vport *vport, uint32_t flag,\n\t\t struct lpfc_iocbq *oldiocb, struct lpfc_nodelist *ndlp,\n\t\t LPFC_MBOXQ_t *mbox)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tIOCB_t *icmd;\n\tIOCB_t *oldcmd;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tstruct serv_parm *sp;\n\tuint16_t cmdsize;\n\tint rc;\n\tELS_PKT *els_pkt_ptr;\n\n\toldcmd = &oldiocb->iocb;\n\n\tswitch (flag) {\n\tcase ELS_CMD_ACC:\n\t\tcmdsize = sizeof(uint32_t);\n\t\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry,\n\t\t\t\t\t     ndlp, ndlp->nlp_DID, ELS_CMD_ACC);\n\t\tif (!elsiocb) {\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag &= ~NLP_LOGO_ACC;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\treturn 1;\n\t\t}\n\n\t\ticmd = &elsiocb->iocb;\n\t\ticmd->ulpContext = oldcmd->ulpContext;\t/* Xri / rx_id */\n\t\ticmd->unsli3.rcvsli3.ox_id = oldcmd->unsli3.rcvsli3.ox_id;\n\t\tpcmd = (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\t\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\t\tpcmd += sizeof(uint32_t);\n\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t\t\"Issue ACC:       did:x%x flg:x%x\",\n\t\t\tndlp->nlp_DID, ndlp->nlp_flag, 0);\n\t\tbreak;\n\tcase ELS_CMD_FLOGI:\n\tcase ELS_CMD_PLOGI:\n\t\tcmdsize = (sizeof(struct serv_parm) + sizeof(uint32_t));\n\t\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry,\n\t\t\t\t\t     ndlp, ndlp->nlp_DID, ELS_CMD_ACC);\n\t\tif (!elsiocb)\n\t\t\treturn 1;\n\n\t\ticmd = &elsiocb->iocb;\n\t\ticmd->ulpContext = oldcmd->ulpContext;\t/* Xri / rx_id */\n\t\ticmd->unsli3.rcvsli3.ox_id = oldcmd->unsli3.rcvsli3.ox_id;\n\t\tpcmd = (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\n\t\tif (mbox)\n\t\t\telsiocb->context_un.mbox = mbox;\n\n\t\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\t\tpcmd += sizeof(uint32_t);\n\t\tsp = (struct serv_parm *)pcmd;\n\n\t\tif (flag == ELS_CMD_FLOGI) {\n\t\t\t/* Copy the received service parameters back */\n\t\t\tmemcpy(sp, &phba->fc_fabparam,\n\t\t\t       sizeof(struct serv_parm));\n\n\t\t\t/* Clear the F_Port bit */\n\t\t\tsp->cmn.fPort = 0;\n\n\t\t\t/* Mark all class service parameters as invalid */\n\t\t\tsp->cls1.classValid = 0;\n\t\t\tsp->cls2.classValid = 0;\n\t\t\tsp->cls3.classValid = 0;\n\t\t\tsp->cls4.classValid = 0;\n\n\t\t\t/* Copy our worldwide names */\n\t\t\tmemcpy(&sp->portName, &vport->fc_sparam.portName,\n\t\t\t       sizeof(struct lpfc_name));\n\t\t\tmemcpy(&sp->nodeName, &vport->fc_sparam.nodeName,\n\t\t\t       sizeof(struct lpfc_name));\n\t\t} else {\n\t\t\tmemcpy(pcmd, &vport->fc_sparam,\n\t\t\t       sizeof(struct serv_parm));\n\n\t\t\tsp->cmn.valid_vendor_ver_level = 0;\n\t\t\tmemset(sp->un.vendorVersion, 0,\n\t\t\t       sizeof(sp->un.vendorVersion));\n\t\t\tsp->cmn.bbRcvSizeMsb &= 0xF;\n\n\t\t\t/* If our firmware supports this feature, convey that\n\t\t\t * info to the target using the vendor specific field.\n\t\t\t */\n\t\t\tif (phba->sli.sli_flag & LPFC_SLI_SUPPRESS_RSP) {\n\t\t\t\tsp->cmn.valid_vendor_ver_level = 1;\n\t\t\t\tsp->un.vv.vid = cpu_to_be32(LPFC_VV_EMLX_ID);\n\t\t\t\tsp->un.vv.flags =\n\t\t\t\t\tcpu_to_be32(LPFC_VV_SUPPRESS_RSP);\n\t\t\t}\n\t\t}\n\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t\t\"Issue ACC FLOGI/PLOGI: did:x%x flg:x%x\",\n\t\t\tndlp->nlp_DID, ndlp->nlp_flag, 0);\n\t\tbreak;\n\tcase ELS_CMD_PRLO:\n\t\tcmdsize = sizeof(uint32_t) + sizeof(PRLO);\n\t\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry,\n\t\t\t\t\t     ndlp, ndlp->nlp_DID, ELS_CMD_PRLO);\n\t\tif (!elsiocb)\n\t\t\treturn 1;\n\n\t\ticmd = &elsiocb->iocb;\n\t\ticmd->ulpContext = oldcmd->ulpContext;\t/* Xri / rx_id */\n\t\ticmd->unsli3.rcvsli3.ox_id = oldcmd->unsli3.rcvsli3.ox_id;\n\t\tpcmd = (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\n\t\tmemcpy(pcmd, ((struct lpfc_dmabuf *) oldiocb->context2)->virt,\n\t\t       sizeof(uint32_t) + sizeof(PRLO));\n\t\t*((uint32_t *) (pcmd)) = ELS_CMD_PRLO_ACC;\n\t\tels_pkt_ptr = (ELS_PKT *) pcmd;\n\t\tels_pkt_ptr->un.prlo.acceptRspCode = PRLO_REQ_EXECUTED;\n\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t\t\"Issue ACC PRLO:  did:x%x flg:x%x\",\n\t\t\tndlp->nlp_DID, ndlp->nlp_flag, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\tif (ndlp->nlp_flag & NLP_LOGO_ACC) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tif (!(ndlp->nlp_flag & NLP_RPI_REGISTERED ||\n\t\t\tndlp->nlp_flag & NLP_REG_LOGIN_SEND))\n\t\t\tndlp->nlp_flag &= ~NLP_LOGO_ACC;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\telsiocb->iocb_cmpl = lpfc_cmpl_els_logo_acc;\n\t} else {\n\t\telsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\n\t}\n\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto node_err;\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR)\n\t\tgoto io_err;\n\n\t/* Xmit ELS ACC response tag <ulpIoTag> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0128 Xmit ELS ACC response Status: x%x, IoTag: x%x, \"\n\t\t\t \"XRI: x%x, DID: x%x, nlp_flag: x%x nlp_state: x%x \"\n\t\t\t \"RPI: x%x, fc_flag x%x\\n\",\n\t\t\t rc, elsiocb->iotag, elsiocb->sli4_xritag,\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t ndlp->nlp_rpi, vport->fc_flag);\n\treturn 0;\n\nio_err:\n\tlpfc_nlp_put(ndlp);\nnode_err:\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn 1;\n}\n\n/**\n * lpfc_els_rsp_reject - Propare and issue a rjt response iocb command\n * @vport: pointer to a virtual N_Port data structure.\n * @rejectError: reject response to issue\n * @oldiocb: pointer to the original lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n * @mbox: pointer to the driver internal queue element for mailbox command.\n *\n * This routine prepares and issue an Reject (RJT) response IOCB\n * command. If a @mbox pointer is passed in, it will be put into the\n * context_un.mbox field of the IOCB for the completion callback function\n * to issue to the HBA later.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the reject response ELS IOCB command.\n *\n * Return code\n *   0 - Successfully issued reject response\n *   1 - Failed to issue reject response\n **/\nint\nlpfc_els_rsp_reject(struct lpfc_vport *vport, uint32_t rejectError,\n\t\t    struct lpfc_iocbq *oldiocb, struct lpfc_nodelist *ndlp,\n\t\t    LPFC_MBOXQ_t *mbox)\n{\n\tint rc;\n\tstruct lpfc_hba  *phba = vport->phba;\n\tIOCB_t *icmd;\n\tIOCB_t *oldcmd;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\n\tcmdsize = 2 * sizeof(uint32_t);\n\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_LS_RJT);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\ticmd = &elsiocb->iocb;\n\toldcmd = &oldiocb->iocb;\n\ticmd->ulpContext = oldcmd->ulpContext;\t/* Xri / rx_id */\n\ticmd->unsli3.rcvsli3.ox_id = oldcmd->unsli3.rcvsli3.ox_id;\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\n\t*((uint32_t *) (pcmd)) = ELS_CMD_LS_RJT;\n\tpcmd += sizeof(uint32_t);\n\t*((uint32_t *) (pcmd)) = rejectError;\n\n\tif (mbox)\n\t\telsiocb->context_un.mbox = mbox;\n\n\t/* Xmit ELS RJT <err> response tag <ulpIoTag> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0129 Xmit ELS RJT x%x response tag x%x \"\n\t\t\t \"xri x%x, did x%x, nlp_flag x%x, nlp_state x%x, \"\n\t\t\t \"rpi x%x\\n\",\n\t\t\t rejectError, elsiocb->iotag,\n\t\t\t elsiocb->iocb.ulpContext, ndlp->nlp_DID,\n\t\t\t ndlp->nlp_flag, ndlp->nlp_state, ndlp->nlp_rpi);\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t\"Issue LS_RJT:    did:x%x flg:x%x err:x%x\",\n\t\tndlp->nlp_DID, ndlp->nlp_flag, rejectError);\n\n\tphba->fc_stat.elsXmitLSRJT++;\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto node_err;\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR)\n\t\tgoto io_err;\n\n\treturn 0;\n\n io_err:\n\tlpfc_nlp_put(ndlp);\n node_err:\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn 1;\n}\n\n/**\n * lpfc_els_rsp_adisc_acc - Prepare and issue acc response to adisc iocb cmd\n * @vport: pointer to a virtual N_Port data structure.\n * @oldiocb: pointer to the original lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine prepares and issues an Accept (ACC) response to Address\n * Discover (ADISC) ELS command. It simply prepares the payload of the IOCB\n * and invokes the lpfc_sli_issue_iocb() routine to send out the command.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the ADISC Accept response ELS IOCB command.\n *\n * Return code\n *   0 - Successfully issued acc adisc response\n *   1 - Failed to issue adisc acc response\n **/\nint\nlpfc_els_rsp_adisc_acc(struct lpfc_vport *vport, struct lpfc_iocbq *oldiocb,\n\t\t       struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tADISC *ap;\n\tIOCB_t *icmd, *oldcmd;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tint rc;\n\n\tcmdsize = sizeof(uint32_t) + sizeof(ADISC);\n\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_ACC);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\ticmd = &elsiocb->iocb;\n\toldcmd = &oldiocb->iocb;\n\ticmd->ulpContext = oldcmd->ulpContext;\t/* Xri / rx_id */\n\ticmd->unsli3.rcvsli3.ox_id = oldcmd->unsli3.rcvsli3.ox_id;\n\n\t/* Xmit ADISC ACC response tag <ulpIoTag> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0130 Xmit ADISC ACC response iotag x%x xri: \"\n\t\t\t \"x%x, did x%x, nlp_flag x%x, nlp_state x%x rpi x%x\\n\",\n\t\t\t elsiocb->iotag, elsiocb->iocb.ulpContext,\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t ndlp->nlp_rpi);\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\n\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\tpcmd += sizeof(uint32_t);\n\n\tap = (ADISC *) (pcmd);\n\tap->hardAL_PA = phba->fc_pref_ALPA;\n\tmemcpy(&ap->portName, &vport->fc_portname, sizeof(struct lpfc_name));\n\tmemcpy(&ap->nodeName, &vport->fc_nodename, sizeof(struct lpfc_name));\n\tap->DID = be32_to_cpu(vport->fc_myDID);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t      \"Issue ACC ADISC: did:x%x flg:x%x refcnt %d\",\n\t\t      ndlp->nlp_DID, ndlp->nlp_flag, kref_read(&ndlp->kref));\n\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto node_err;\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR)\n\t\tgoto io_err;\n\n\t/* Xmit ELS ACC response tag <ulpIoTag> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0128 Xmit ELS ACC response Status: x%x, IoTag: x%x, \"\n\t\t\t \"XRI: x%x, DID: x%x, nlp_flag: x%x nlp_state: x%x \"\n\t\t\t \"RPI: x%x, fc_flag x%x\\n\",\n\t\t\t rc, elsiocb->iotag, elsiocb->sli4_xritag,\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t ndlp->nlp_rpi, vport->fc_flag);\n\treturn 0;\n\nio_err:\n\tlpfc_nlp_put(ndlp);\nnode_err:\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn 1;\n}\n\n/**\n * lpfc_els_rsp_prli_acc - Prepare and issue acc response to prli iocb cmd\n * @vport: pointer to a virtual N_Port data structure.\n * @oldiocb: pointer to the original lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine prepares and issues an Accept (ACC) response to Process\n * Login (PRLI) ELS command. It simply prepares the payload of the IOCB\n * and invokes the lpfc_sli_issue_iocb() routine to send out the command.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the PRLI Accept response ELS IOCB command.\n *\n * Return code\n *   0 - Successfully issued acc prli response\n *   1 - Failed to issue acc prli response\n **/\nint\nlpfc_els_rsp_prli_acc(struct lpfc_vport *vport, struct lpfc_iocbq *oldiocb,\n\t\t      struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tPRLI *npr;\n\tstruct lpfc_nvme_prli *npr_nvme;\n\tlpfc_vpd_t *vpd;\n\tIOCB_t *icmd;\n\tIOCB_t *oldcmd;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tuint32_t prli_fc4_req, *req_payload;\n\tstruct lpfc_dmabuf *req_buf;\n\tint rc;\n\tu32 elsrspcmd;\n\n\t/* Need the incoming PRLI payload to determine if the ACC is for an\n\t * FC4 or NVME PRLI type.  The PRLI type is at word 1.\n\t */\n\treq_buf = (struct lpfc_dmabuf *)oldiocb->context2;\n\treq_payload = (((uint32_t *)req_buf->virt) + 1);\n\n\t/* PRLI type payload is at byte 3 for FCP or NVME. */\n\tprli_fc4_req = be32_to_cpu(*req_payload);\n\tprli_fc4_req = (prli_fc4_req >> 24) & 0xff;\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"6127 PRLI_ACC:  Req Type x%x, Word1 x%08x\\n\",\n\t\t\t prli_fc4_req, *((uint32_t *)req_payload));\n\n\tif (prli_fc4_req == PRLI_FCP_TYPE) {\n\t\tcmdsize = sizeof(uint32_t) + sizeof(PRLI);\n\t\telsrspcmd = (ELS_CMD_ACC | (ELS_CMD_PRLI & ~ELS_RSP_MASK));\n\t} else if (prli_fc4_req & PRLI_NVME_TYPE) {\n\t\tcmdsize = sizeof(uint32_t) + sizeof(struct lpfc_nvme_prli);\n\t\telsrspcmd = (ELS_CMD_ACC | (ELS_CMD_NVMEPRLI & ~ELS_RSP_MASK));\n\t} else {\n\t\treturn 1;\n\t}\n\n\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\n\t\tndlp->nlp_DID, elsrspcmd);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\ticmd = &elsiocb->iocb;\n\toldcmd = &oldiocb->iocb;\n\ticmd->ulpContext = oldcmd->ulpContext;\t/* Xri / rx_id */\n\ticmd->unsli3.rcvsli3.ox_id = oldcmd->unsli3.rcvsli3.ox_id;\n\n\t/* Xmit PRLI ACC response tag <ulpIoTag> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0131 Xmit PRLI ACC response tag x%x xri x%x, \"\n\t\t\t \"did x%x, nlp_flag x%x, nlp_state x%x, rpi x%x\\n\",\n\t\t\t elsiocb->iotag, elsiocb->iocb.ulpContext,\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t ndlp->nlp_rpi);\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\tmemset(pcmd, 0, cmdsize);\n\n\t*((uint32_t *)(pcmd)) = elsrspcmd;\n\tpcmd += sizeof(uint32_t);\n\n\t/* For PRLI, remainder of payload is PRLI parameter page */\n\tvpd = &phba->vpd;\n\n\tif (prli_fc4_req == PRLI_FCP_TYPE) {\n\t\t/*\n\t\t * If the remote port is a target and our firmware version\n\t\t * is 3.20 or later, set the following bits for FC-TAPE\n\t\t * support.\n\t\t */\n\t\tnpr = (PRLI *) pcmd;\n\t\tif ((ndlp->nlp_type & NLP_FCP_TARGET) &&\n\t\t    (vpd->rev.feaLevelHigh >= 0x02)) {\n\t\t\tnpr->ConfmComplAllowed = 1;\n\t\t\tnpr->Retry = 1;\n\t\t\tnpr->TaskRetryIdReq = 1;\n\t\t}\n\t\tnpr->acceptRspCode = PRLI_REQ_EXECUTED;\n\t\tnpr->estabImagePair = 1;\n\t\tnpr->readXferRdyDis = 1;\n\t\tnpr->ConfmComplAllowed = 1;\n\t\tnpr->prliType = PRLI_FCP_TYPE;\n\t\tnpr->initiatorFunc = 1;\n\t} else if (prli_fc4_req & PRLI_NVME_TYPE) {\n\t\t/* Respond with an NVME PRLI Type */\n\t\tnpr_nvme = (struct lpfc_nvme_prli *) pcmd;\n\t\tbf_set(prli_type_code, npr_nvme, PRLI_NVME_TYPE);\n\t\tbf_set(prli_estabImagePair, npr_nvme, 0);  /* Should be 0 */\n\t\tbf_set(prli_acc_rsp_code, npr_nvme, PRLI_REQ_EXECUTED);\n\t\tif (phba->nvmet_support) {\n\t\t\tbf_set(prli_tgt, npr_nvme, 1);\n\t\t\tbf_set(prli_disc, npr_nvme, 1);\n\t\t\tif (phba->cfg_nvme_enable_fb) {\n\t\t\t\tbf_set(prli_fba, npr_nvme, 1);\n\n\t\t\t\t/* TBD.  Target mode needs to post buffers\n\t\t\t\t * that support the configured first burst\n\t\t\t\t * byte size.\n\t\t\t\t */\n\t\t\t\tbf_set(prli_fb_sz, npr_nvme,\n\t\t\t\t       phba->cfg_nvmet_fb_size);\n\t\t\t}\n\t\t} else {\n\t\t\tbf_set(prli_init, npr_nvme, 1);\n\t\t}\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_DISC,\n\t\t\t\t \"6015 NVME issue PRLI ACC word1 x%08x \"\n\t\t\t\t \"word4 x%08x word5 x%08x flag x%x, \"\n\t\t\t\t \"fcp_info x%x nlp_type x%x\\n\",\n\t\t\t\t npr_nvme->word1, npr_nvme->word4,\n\t\t\t\t npr_nvme->word5, ndlp->nlp_flag,\n\t\t\t\t ndlp->nlp_fcp_info, ndlp->nlp_type);\n\t\tnpr_nvme->word1 = cpu_to_be32(npr_nvme->word1);\n\t\tnpr_nvme->word4 = cpu_to_be32(npr_nvme->word4);\n\t\tnpr_nvme->word5 = cpu_to_be32(npr_nvme->word5);\n\t} else\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"6128 Unknown FC_TYPE x%x x%x ndlp x%06x\\n\",\n\t\t\t\t prli_fc4_req, ndlp->nlp_fc4_type,\n\t\t\t\t ndlp->nlp_DID);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t      \"Issue ACC PRLI:  did:x%x flg:x%x\",\n\t\t      ndlp->nlp_DID, ndlp->nlp_flag, kref_read(&ndlp->kref));\n\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\n\telsiocb->context1 =  lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto node_err;\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR)\n\t\tgoto io_err;\n\treturn 0;\n\n io_err:\n\tlpfc_nlp_put(ndlp);\n node_err:\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn 1;\n}\n\n/**\n * lpfc_els_rsp_rnid_acc - Issue rnid acc response iocb command\n * @vport: pointer to a virtual N_Port data structure.\n * @format: rnid command format.\n * @oldiocb: pointer to the original lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine issues a Request Node Identification Data (RNID) Accept\n * (ACC) response. It constructs the RNID ACC response command according to\n * the proper @format and then calls the lpfc_sli_issue_iocb() routine to\n * issue the response. Note that this command does not need to hold the ndlp\n * reference count for the callback. So, the ndlp reference count taken by\n * the lpfc_prep_els_iocb() routine is put back and the context1 field of\n * IOCB is set to NULL to indicate to the lpfc_els_free_iocb() routine that\n * there is no ndlp reference available.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function. However, for the RNID Accept Response ELS command,\n * this is undone later by this routine after the IOCB is allocated.\n *\n * Return code\n *   0 - Successfully issued acc rnid response\n *   1 - Failed to issue acc rnid response\n **/\nstatic int\nlpfc_els_rsp_rnid_acc(struct lpfc_vport *vport, uint8_t format,\n\t\t      struct lpfc_iocbq *oldiocb, struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tRNID *rn;\n\tIOCB_t *icmd, *oldcmd;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tint rc;\n\n\tcmdsize = sizeof(uint32_t) + sizeof(uint32_t)\n\t\t\t\t\t+ (2 * sizeof(struct lpfc_name));\n\tif (format)\n\t\tcmdsize += sizeof(RNID_TOP_DISC);\n\n\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_ACC);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\ticmd = &elsiocb->iocb;\n\toldcmd = &oldiocb->iocb;\n\ticmd->ulpContext = oldcmd->ulpContext;\t/* Xri / rx_id */\n\ticmd->unsli3.rcvsli3.ox_id = oldcmd->unsli3.rcvsli3.ox_id;\n\n\t/* Xmit RNID ACC response tag <ulpIoTag> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0132 Xmit RNID ACC response tag x%x xri x%x\\n\",\n\t\t\t elsiocb->iotag, elsiocb->iocb.ulpContext);\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\tpcmd += sizeof(uint32_t);\n\n\tmemset(pcmd, 0, sizeof(RNID));\n\trn = (RNID *) (pcmd);\n\trn->Format = format;\n\trn->CommonLen = (2 * sizeof(struct lpfc_name));\n\tmemcpy(&rn->portName, &vport->fc_portname, sizeof(struct lpfc_name));\n\tmemcpy(&rn->nodeName, &vport->fc_nodename, sizeof(struct lpfc_name));\n\tswitch (format) {\n\tcase 0:\n\t\trn->SpecificLen = 0;\n\t\tbreak;\n\tcase RNID_TOPOLOGY_DISC:\n\t\trn->SpecificLen = sizeof(RNID_TOP_DISC);\n\t\tmemcpy(&rn->un.topologyDisc.portName,\n\t\t       &vport->fc_portname, sizeof(struct lpfc_name));\n\t\trn->un.topologyDisc.unitType = RNID_HBA;\n\t\trn->un.topologyDisc.physPort = 0;\n\t\trn->un.topologyDisc.attachedNodes = 0;\n\t\tbreak;\n\tdefault:\n\t\trn->CommonLen = 0;\n\t\trn->SpecificLen = 0;\n\t\tbreak;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t      \"Issue ACC RNID:  did:x%x flg:x%x refcnt %d\",\n\t\t      ndlp->nlp_DID, ndlp->nlp_flag, kref_read(&ndlp->kref));\n\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto node_err;\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR)\n\t\tgoto io_err;\n\n\treturn 0;\n\n io_err:\n\tlpfc_nlp_put(ndlp);\n node_err:\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn 1;\n}\n\n/**\n * lpfc_els_clear_rrq - Clear the rq that this rrq describes.\n * @vport: pointer to a virtual N_Port data structure.\n * @iocb: pointer to the lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * Return\n **/\nstatic void\nlpfc_els_clear_rrq(struct lpfc_vport *vport,\n\t\t   struct lpfc_iocbq *iocb, struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tuint8_t *pcmd;\n\tstruct RRQ *rrq;\n\tuint16_t rxid;\n\tuint16_t xri;\n\tstruct lpfc_node_rrq *prrq;\n\n\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) iocb->context2)->virt);\n\tpcmd += sizeof(uint32_t);\n\trrq = (struct RRQ *)pcmd;\n\trrq->rrq_exchg = be32_to_cpu(rrq->rrq_exchg);\n\trxid = bf_get(rrq_rxid, rrq);\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\"2883 Clear RRQ for SID:x%x OXID:x%x RXID:x%x\"\n\t\t\t\" x%x x%x\\n\",\n\t\t\tbe32_to_cpu(bf_get(rrq_did, rrq)),\n\t\t\tbf_get(rrq_oxid, rrq),\n\t\t\trxid,\n\t\t\tiocb->iotag, iocb->iocb.ulpContext);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t\"Clear RRQ:  did:x%x flg:x%x exchg:x%.08x\",\n\t\tndlp->nlp_DID, ndlp->nlp_flag, rrq->rrq_exchg);\n\tif (vport->fc_myDID == be32_to_cpu(bf_get(rrq_did, rrq)))\n\t\txri = bf_get(rrq_oxid, rrq);\n\telse\n\t\txri = rxid;\n\tprrq = lpfc_get_active_rrq(vport, xri, ndlp->nlp_DID);\n\tif (prrq)\n\t\tlpfc_clr_rrq_active(phba, xri, prrq);\n\treturn;\n}\n\n/**\n * lpfc_els_rsp_echo_acc - Issue echo acc response\n * @vport: pointer to a virtual N_Port data structure.\n * @data: pointer to echo data to return in the accept.\n * @oldiocb: pointer to the original lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * Return code\n *   0 - Successfully issued acc echo response\n *   1 - Failed to issue acc echo response\n **/\nstatic int\nlpfc_els_rsp_echo_acc(struct lpfc_vport *vport, uint8_t *data,\n\t\t      struct lpfc_iocbq *oldiocb, struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tint rc;\n\n\tcmdsize = oldiocb->iocb.unsli3.rcvsli3.acc_len;\n\n\t/* The accumulated length can exceed the BPL_SIZE.  For\n\t * now, use this as the limit\n\t */\n\tif (cmdsize > LPFC_BPL_SIZE)\n\t\tcmdsize = LPFC_BPL_SIZE;\n\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_ACC);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\telsiocb->iocb.ulpContext = oldiocb->iocb.ulpContext;  /* Xri / rx_id */\n\telsiocb->iocb.unsli3.rcvsli3.ox_id = oldiocb->iocb.unsli3.rcvsli3.ox_id;\n\n\t/* Xmit ECHO ACC response tag <ulpIoTag> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"2876 Xmit ECHO ACC response tag x%x xri x%x\\n\",\n\t\t\t elsiocb->iotag, elsiocb->iocb.ulpContext);\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\tpcmd += sizeof(uint32_t);\n\tmemcpy(pcmd, data, cmdsize - sizeof(uint32_t));\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t      \"Issue ACC ECHO:  did:x%x flg:x%x refcnt %d\",\n\t\t      ndlp->nlp_DID, ndlp->nlp_flag, kref_read(&ndlp->kref));\n\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\n\telsiocb->context1 =  lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto node_err;\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR)\n\t\tgoto io_err;\n\treturn 0;\n\n io_err:\n\tlpfc_nlp_put(ndlp);\n node_err:\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn 1;\n}\n\n/**\n * lpfc_els_disc_adisc - Issue remaining adisc iocbs to npr nodes of a vport\n * @vport: pointer to a host virtual N_Port data structure.\n *\n * This routine issues Address Discover (ADISC) ELS commands to those\n * N_Ports which are in node port recovery state and ADISC has not been issued\n * for the @vport. Each time an ELS ADISC IOCB is issued by invoking the\n * lpfc_issue_els_adisc() routine, the per @vport number of discover count\n * (num_disc_nodes) shall be incremented. If the num_disc_nodes reaches a\n * pre-configured threshold (cfg_discovery_threads), the @vport fc_flag will\n * be marked with FC_NLP_MORE bit and the process of issuing remaining ADISC\n * IOCBs quit for later pick up. On the other hand, after walking through\n * all the ndlps with the @vport and there is none ADISC IOCB issued, the\n * @vport fc_flag shall be cleared with FC_NLP_MORE bit indicating there is\n * no more ADISC need to be sent.\n *\n * Return code\n *    The number of N_Ports with adisc issued.\n **/\nint\nlpfc_els_disc_adisc(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_nodelist *ndlp, *next_ndlp;\n\tint sentadisc = 0;\n\n\t/* go thru NPR nodes and issue any remaining ELS ADISCs */\n\tlist_for_each_entry_safe(ndlp, next_ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tif (ndlp->nlp_state == NLP_STE_NPR_NODE &&\n\t\t    (ndlp->nlp_flag & NLP_NPR_2B_DISC) != 0 &&\n\t\t    (ndlp->nlp_flag & NLP_NPR_ADISC) != 0) {\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag &= ~NLP_NPR_ADISC;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_ADISC_ISSUE);\n\t\t\tlpfc_issue_els_adisc(vport, ndlp, 0);\n\t\t\tsentadisc++;\n\t\t\tvport->num_disc_nodes++;\n\t\t\tif (vport->num_disc_nodes >=\n\t\t\t    vport->cfg_discovery_threads) {\n\t\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\t\tvport->fc_flag |= FC_NLP_MORE;\n\t\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (sentadisc == 0) {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag &= ~FC_NLP_MORE;\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\n\treturn sentadisc;\n}\n\n/**\n * lpfc_els_disc_plogi - Issue plogi for all npr nodes of a vport before adisc\n * @vport: pointer to a host virtual N_Port data structure.\n *\n * This routine issues Port Login (PLOGI) ELS commands to all the N_Ports\n * which are in node port recovery state, with a @vport. Each time an ELS\n * ADISC PLOGI IOCB is issued by invoking the lpfc_issue_els_plogi() routine,\n * the per @vport number of discover count (num_disc_nodes) shall be\n * incremented. If the num_disc_nodes reaches a pre-configured threshold\n * (cfg_discovery_threads), the @vport fc_flag will be marked with FC_NLP_MORE\n * bit set and quit the process of issuing remaining ADISC PLOGIN IOCBs for\n * later pick up. On the other hand, after walking through all the ndlps with\n * the @vport and there is none ADISC PLOGI IOCB issued, the @vport fc_flag\n * shall be cleared with the FC_NLP_MORE bit indicating there is no more ADISC\n * PLOGI need to be sent.\n *\n * Return code\n *   The number of N_Ports with plogi issued.\n **/\nint\nlpfc_els_disc_plogi(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_nodelist *ndlp, *next_ndlp;\n\tint sentplogi = 0;\n\n\t/* go thru NPR nodes and issue any remaining ELS PLOGIs */\n\tlist_for_each_entry_safe(ndlp, next_ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tif (ndlp->nlp_state == NLP_STE_NPR_NODE &&\n\t\t\t\t(ndlp->nlp_flag & NLP_NPR_2B_DISC) != 0 &&\n\t\t\t\t(ndlp->nlp_flag & NLP_DELAY_TMO) == 0 &&\n\t\t\t\t(ndlp->nlp_flag & NLP_NPR_ADISC) == 0) {\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\n\t\t\tlpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0);\n\t\t\tsentplogi++;\n\t\t\tvport->num_disc_nodes++;\n\t\t\tif (vport->num_disc_nodes >=\n\t\t\t\t\tvport->cfg_discovery_threads) {\n\t\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\t\tvport->fc_flag |= FC_NLP_MORE;\n\t\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"6452 Discover PLOGI %d flag x%x\\n\",\n\t\t\t sentplogi, vport->fc_flag);\n\n\tif (sentplogi) {\n\t\tlpfc_set_disctmo(vport);\n\t}\n\telse {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag &= ~FC_NLP_MORE;\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\n\treturn sentplogi;\n}\n\nstatic uint32_t\nlpfc_rdp_res_link_service(struct fc_rdp_link_service_desc *desc,\n\t\tuint32_t word0)\n{\n\n\tdesc->tag = cpu_to_be32(RDP_LINK_SERVICE_DESC_TAG);\n\tdesc->payload.els_req = word0;\n\tdesc->length = cpu_to_be32(sizeof(desc->payload));\n\n\treturn sizeof(struct fc_rdp_link_service_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_sfp_desc(struct fc_rdp_sfp_desc *desc,\n\t\tuint8_t *page_a0, uint8_t *page_a2)\n{\n\tuint16_t wavelength;\n\tuint16_t temperature;\n\tuint16_t rx_power;\n\tuint16_t tx_bias;\n\tuint16_t tx_power;\n\tuint16_t vcc;\n\tuint16_t flag = 0;\n\tstruct sff_trasnceiver_codes_byte4 *trasn_code_byte4;\n\tstruct sff_trasnceiver_codes_byte5 *trasn_code_byte5;\n\n\tdesc->tag = cpu_to_be32(RDP_SFP_DESC_TAG);\n\n\ttrasn_code_byte4 = (struct sff_trasnceiver_codes_byte4 *)\n\t\t\t&page_a0[SSF_TRANSCEIVER_CODE_B4];\n\ttrasn_code_byte5 = (struct sff_trasnceiver_codes_byte5 *)\n\t\t\t&page_a0[SSF_TRANSCEIVER_CODE_B5];\n\n\tif ((trasn_code_byte4->fc_sw_laser) ||\n\t    (trasn_code_byte5->fc_sw_laser_sl) ||\n\t    (trasn_code_byte5->fc_sw_laser_sn)) {  /* check if its short WL */\n\t\tflag |= (SFP_FLAG_PT_SWLASER << SFP_FLAG_PT_SHIFT);\n\t} else if (trasn_code_byte4->fc_lw_laser) {\n\t\twavelength = (page_a0[SSF_WAVELENGTH_B1] << 8) |\n\t\t\tpage_a0[SSF_WAVELENGTH_B0];\n\t\tif (wavelength == SFP_WAVELENGTH_LC1310)\n\t\t\tflag |= SFP_FLAG_PT_LWLASER_LC1310 << SFP_FLAG_PT_SHIFT;\n\t\tif (wavelength == SFP_WAVELENGTH_LL1550)\n\t\t\tflag |= SFP_FLAG_PT_LWLASER_LL1550 << SFP_FLAG_PT_SHIFT;\n\t}\n\t/* check if its SFP+ */\n\tflag |= ((page_a0[SSF_IDENTIFIER] == SFF_PG0_IDENT_SFP) ?\n\t\t\tSFP_FLAG_CT_SFP_PLUS : SFP_FLAG_CT_UNKNOWN)\n\t\t\t\t\t<< SFP_FLAG_CT_SHIFT;\n\n\t/* check if its OPTICAL */\n\tflag |= ((page_a0[SSF_CONNECTOR] == SFF_PG0_CONNECTOR_LC) ?\n\t\t\tSFP_FLAG_IS_OPTICAL_PORT : 0)\n\t\t\t\t\t<< SFP_FLAG_IS_OPTICAL_SHIFT;\n\n\ttemperature = (page_a2[SFF_TEMPERATURE_B1] << 8 |\n\t\tpage_a2[SFF_TEMPERATURE_B0]);\n\tvcc = (page_a2[SFF_VCC_B1] << 8 |\n\t\tpage_a2[SFF_VCC_B0]);\n\ttx_power = (page_a2[SFF_TXPOWER_B1] << 8 |\n\t\tpage_a2[SFF_TXPOWER_B0]);\n\ttx_bias = (page_a2[SFF_TX_BIAS_CURRENT_B1] << 8 |\n\t\tpage_a2[SFF_TX_BIAS_CURRENT_B0]);\n\trx_power = (page_a2[SFF_RXPOWER_B1] << 8 |\n\t\tpage_a2[SFF_RXPOWER_B0]);\n\tdesc->sfp_info.temperature = cpu_to_be16(temperature);\n\tdesc->sfp_info.rx_power = cpu_to_be16(rx_power);\n\tdesc->sfp_info.tx_bias = cpu_to_be16(tx_bias);\n\tdesc->sfp_info.tx_power = cpu_to_be16(tx_power);\n\tdesc->sfp_info.vcc = cpu_to_be16(vcc);\n\n\tdesc->sfp_info.flags = cpu_to_be16(flag);\n\tdesc->length = cpu_to_be32(sizeof(desc->sfp_info));\n\n\treturn sizeof(struct fc_rdp_sfp_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_link_error(struct fc_rdp_link_error_status_desc *desc,\n\t\tREAD_LNK_VAR *stat)\n{\n\tuint32_t type;\n\n\tdesc->tag = cpu_to_be32(RDP_LINK_ERROR_STATUS_DESC_TAG);\n\n\ttype = VN_PT_PHY_PF_PORT << VN_PT_PHY_SHIFT;\n\n\tdesc->info.port_type = cpu_to_be32(type);\n\n\tdesc->info.link_status.link_failure_cnt =\n\t\tcpu_to_be32(stat->linkFailureCnt);\n\tdesc->info.link_status.loss_of_synch_cnt =\n\t\tcpu_to_be32(stat->lossSyncCnt);\n\tdesc->info.link_status.loss_of_signal_cnt =\n\t\tcpu_to_be32(stat->lossSignalCnt);\n\tdesc->info.link_status.primitive_seq_proto_err =\n\t\tcpu_to_be32(stat->primSeqErrCnt);\n\tdesc->info.link_status.invalid_trans_word =\n\t\tcpu_to_be32(stat->invalidXmitWord);\n\tdesc->info.link_status.invalid_crc_cnt = cpu_to_be32(stat->crcCnt);\n\n\tdesc->length = cpu_to_be32(sizeof(desc->info));\n\n\treturn sizeof(struct fc_rdp_link_error_status_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_bbc_desc(struct fc_rdp_bbc_desc *desc, READ_LNK_VAR *stat,\n\t\t      struct lpfc_vport *vport)\n{\n\tuint32_t bbCredit;\n\n\tdesc->tag = cpu_to_be32(RDP_BBC_DESC_TAG);\n\n\tbbCredit = vport->fc_sparam.cmn.bbCreditLsb |\n\t\t\t(vport->fc_sparam.cmn.bbCreditMsb << 8);\n\tdesc->bbc_info.port_bbc = cpu_to_be32(bbCredit);\n\tif (vport->phba->fc_topology != LPFC_TOPOLOGY_LOOP) {\n\t\tbbCredit = vport->phba->fc_fabparam.cmn.bbCreditLsb |\n\t\t\t(vport->phba->fc_fabparam.cmn.bbCreditMsb << 8);\n\t\tdesc->bbc_info.attached_port_bbc = cpu_to_be32(bbCredit);\n\t} else {\n\t\tdesc->bbc_info.attached_port_bbc = 0;\n\t}\n\n\tdesc->bbc_info.rtt = 0;\n\tdesc->length = cpu_to_be32(sizeof(desc->bbc_info));\n\n\treturn sizeof(struct fc_rdp_bbc_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_oed_temp_desc(struct lpfc_hba *phba,\n\t\t\t   struct fc_rdp_oed_sfp_desc *desc, uint8_t *page_a2)\n{\n\tuint32_t flags = 0;\n\n\tdesc->tag = cpu_to_be32(RDP_OED_DESC_TAG);\n\n\tdesc->oed_info.hi_alarm = page_a2[SSF_TEMP_HIGH_ALARM];\n\tdesc->oed_info.lo_alarm = page_a2[SSF_TEMP_LOW_ALARM];\n\tdesc->oed_info.hi_warning = page_a2[SSF_TEMP_HIGH_WARNING];\n\tdesc->oed_info.lo_warning = page_a2[SSF_TEMP_LOW_WARNING];\n\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_HIGH_TEMPERATURE)\n\t\tflags |= RDP_OET_HIGH_ALARM;\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_LOW_TEMPERATURE)\n\t\tflags |= RDP_OET_LOW_ALARM;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_HIGH_TEMPERATURE)\n\t\tflags |= RDP_OET_HIGH_WARNING;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_LOW_TEMPERATURE)\n\t\tflags |= RDP_OET_LOW_WARNING;\n\n\tflags |= ((0xf & RDP_OED_TEMPERATURE) << RDP_OED_TYPE_SHIFT);\n\tdesc->oed_info.function_flags = cpu_to_be32(flags);\n\tdesc->length = cpu_to_be32(sizeof(desc->oed_info));\n\treturn sizeof(struct fc_rdp_oed_sfp_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_oed_voltage_desc(struct lpfc_hba *phba,\n\t\t\t      struct fc_rdp_oed_sfp_desc *desc,\n\t\t\t      uint8_t *page_a2)\n{\n\tuint32_t flags = 0;\n\n\tdesc->tag = cpu_to_be32(RDP_OED_DESC_TAG);\n\n\tdesc->oed_info.hi_alarm = page_a2[SSF_VOLTAGE_HIGH_ALARM];\n\tdesc->oed_info.lo_alarm = page_a2[SSF_VOLTAGE_LOW_ALARM];\n\tdesc->oed_info.hi_warning = page_a2[SSF_VOLTAGE_HIGH_WARNING];\n\tdesc->oed_info.lo_warning = page_a2[SSF_VOLTAGE_LOW_WARNING];\n\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_HIGH_VOLTAGE)\n\t\tflags |= RDP_OET_HIGH_ALARM;\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_LOW_VOLTAGE)\n\t\tflags |= RDP_OET_LOW_ALARM;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_HIGH_VOLTAGE)\n\t\tflags |= RDP_OET_HIGH_WARNING;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_LOW_VOLTAGE)\n\t\tflags |= RDP_OET_LOW_WARNING;\n\n\tflags |= ((0xf & RDP_OED_VOLTAGE) << RDP_OED_TYPE_SHIFT);\n\tdesc->oed_info.function_flags = cpu_to_be32(flags);\n\tdesc->length = cpu_to_be32(sizeof(desc->oed_info));\n\treturn sizeof(struct fc_rdp_oed_sfp_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_oed_txbias_desc(struct lpfc_hba *phba,\n\t\t\t     struct fc_rdp_oed_sfp_desc *desc,\n\t\t\t     uint8_t *page_a2)\n{\n\tuint32_t flags = 0;\n\n\tdesc->tag = cpu_to_be32(RDP_OED_DESC_TAG);\n\n\tdesc->oed_info.hi_alarm = page_a2[SSF_BIAS_HIGH_ALARM];\n\tdesc->oed_info.lo_alarm = page_a2[SSF_BIAS_LOW_ALARM];\n\tdesc->oed_info.hi_warning = page_a2[SSF_BIAS_HIGH_WARNING];\n\tdesc->oed_info.lo_warning = page_a2[SSF_BIAS_LOW_WARNING];\n\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_HIGH_TXBIAS)\n\t\tflags |= RDP_OET_HIGH_ALARM;\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_LOW_TXBIAS)\n\t\tflags |= RDP_OET_LOW_ALARM;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_HIGH_TXBIAS)\n\t\tflags |= RDP_OET_HIGH_WARNING;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_LOW_TXBIAS)\n\t\tflags |= RDP_OET_LOW_WARNING;\n\n\tflags |= ((0xf & RDP_OED_TXBIAS) << RDP_OED_TYPE_SHIFT);\n\tdesc->oed_info.function_flags = cpu_to_be32(flags);\n\tdesc->length = cpu_to_be32(sizeof(desc->oed_info));\n\treturn sizeof(struct fc_rdp_oed_sfp_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_oed_txpower_desc(struct lpfc_hba *phba,\n\t\t\t      struct fc_rdp_oed_sfp_desc *desc,\n\t\t\t      uint8_t *page_a2)\n{\n\tuint32_t flags = 0;\n\n\tdesc->tag = cpu_to_be32(RDP_OED_DESC_TAG);\n\n\tdesc->oed_info.hi_alarm = page_a2[SSF_TXPOWER_HIGH_ALARM];\n\tdesc->oed_info.lo_alarm = page_a2[SSF_TXPOWER_LOW_ALARM];\n\tdesc->oed_info.hi_warning = page_a2[SSF_TXPOWER_HIGH_WARNING];\n\tdesc->oed_info.lo_warning = page_a2[SSF_TXPOWER_LOW_WARNING];\n\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_HIGH_TXPOWER)\n\t\tflags |= RDP_OET_HIGH_ALARM;\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_LOW_TXPOWER)\n\t\tflags |= RDP_OET_LOW_ALARM;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_HIGH_TXPOWER)\n\t\tflags |= RDP_OET_HIGH_WARNING;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_LOW_TXPOWER)\n\t\tflags |= RDP_OET_LOW_WARNING;\n\n\tflags |= ((0xf & RDP_OED_TXPOWER) << RDP_OED_TYPE_SHIFT);\n\tdesc->oed_info.function_flags = cpu_to_be32(flags);\n\tdesc->length = cpu_to_be32(sizeof(desc->oed_info));\n\treturn sizeof(struct fc_rdp_oed_sfp_desc);\n}\n\n\nstatic uint32_t\nlpfc_rdp_res_oed_rxpower_desc(struct lpfc_hba *phba,\n\t\t\t      struct fc_rdp_oed_sfp_desc *desc,\n\t\t\t      uint8_t *page_a2)\n{\n\tuint32_t flags = 0;\n\n\tdesc->tag = cpu_to_be32(RDP_OED_DESC_TAG);\n\n\tdesc->oed_info.hi_alarm = page_a2[SSF_RXPOWER_HIGH_ALARM];\n\tdesc->oed_info.lo_alarm = page_a2[SSF_RXPOWER_LOW_ALARM];\n\tdesc->oed_info.hi_warning = page_a2[SSF_RXPOWER_HIGH_WARNING];\n\tdesc->oed_info.lo_warning = page_a2[SSF_RXPOWER_LOW_WARNING];\n\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_HIGH_RXPOWER)\n\t\tflags |= RDP_OET_HIGH_ALARM;\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_LOW_RXPOWER)\n\t\tflags |= RDP_OET_LOW_ALARM;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_HIGH_RXPOWER)\n\t\tflags |= RDP_OET_HIGH_WARNING;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_LOW_RXPOWER)\n\t\tflags |= RDP_OET_LOW_WARNING;\n\n\tflags |= ((0xf & RDP_OED_RXPOWER) << RDP_OED_TYPE_SHIFT);\n\tdesc->oed_info.function_flags = cpu_to_be32(flags);\n\tdesc->length = cpu_to_be32(sizeof(desc->oed_info));\n\treturn sizeof(struct fc_rdp_oed_sfp_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_opd_desc(struct fc_rdp_opd_sfp_desc *desc,\n\t\t      uint8_t *page_a0, struct lpfc_vport *vport)\n{\n\tdesc->tag = cpu_to_be32(RDP_OPD_DESC_TAG);\n\tmemcpy(desc->opd_info.vendor_name, &page_a0[SSF_VENDOR_NAME], 16);\n\tmemcpy(desc->opd_info.model_number, &page_a0[SSF_VENDOR_PN], 16);\n\tmemcpy(desc->opd_info.serial_number, &page_a0[SSF_VENDOR_SN], 16);\n\tmemcpy(desc->opd_info.revision, &page_a0[SSF_VENDOR_REV], 4);\n\tmemcpy(desc->opd_info.date, &page_a0[SSF_DATE_CODE], 8);\n\tdesc->length = cpu_to_be32(sizeof(desc->opd_info));\n\treturn sizeof(struct fc_rdp_opd_sfp_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_fec_desc(struct fc_fec_rdp_desc *desc, READ_LNK_VAR *stat)\n{\n\tif (bf_get(lpfc_read_link_stat_gec2, stat) == 0)\n\t\treturn 0;\n\tdesc->tag = cpu_to_be32(RDP_FEC_DESC_TAG);\n\n\tdesc->info.CorrectedBlocks =\n\t\tcpu_to_be32(stat->fecCorrBlkCount);\n\tdesc->info.UncorrectableBlocks =\n\t\tcpu_to_be32(stat->fecUncorrBlkCount);\n\n\tdesc->length = cpu_to_be32(sizeof(desc->info));\n\n\treturn sizeof(struct fc_fec_rdp_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_speed(struct fc_rdp_port_speed_desc *desc, struct lpfc_hba *phba)\n{\n\tuint16_t rdp_cap = 0;\n\tuint16_t rdp_speed;\n\n\tdesc->tag = cpu_to_be32(RDP_PORT_SPEED_DESC_TAG);\n\n\tswitch (phba->fc_linkspeed) {\n\tcase LPFC_LINK_SPEED_1GHZ:\n\t\trdp_speed = RDP_PS_1GB;\n\t\tbreak;\n\tcase LPFC_LINK_SPEED_2GHZ:\n\t\trdp_speed = RDP_PS_2GB;\n\t\tbreak;\n\tcase LPFC_LINK_SPEED_4GHZ:\n\t\trdp_speed = RDP_PS_4GB;\n\t\tbreak;\n\tcase LPFC_LINK_SPEED_8GHZ:\n\t\trdp_speed = RDP_PS_8GB;\n\t\tbreak;\n\tcase LPFC_LINK_SPEED_10GHZ:\n\t\trdp_speed = RDP_PS_10GB;\n\t\tbreak;\n\tcase LPFC_LINK_SPEED_16GHZ:\n\t\trdp_speed = RDP_PS_16GB;\n\t\tbreak;\n\tcase LPFC_LINK_SPEED_32GHZ:\n\t\trdp_speed = RDP_PS_32GB;\n\t\tbreak;\n\tcase LPFC_LINK_SPEED_64GHZ:\n\t\trdp_speed = RDP_PS_64GB;\n\t\tbreak;\n\tdefault:\n\t\trdp_speed = RDP_PS_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tdesc->info.port_speed.speed = cpu_to_be16(rdp_speed);\n\n\tif (phba->lmt & LMT_128Gb)\n\t\trdp_cap |= RDP_PS_128GB;\n\tif (phba->lmt & LMT_64Gb)\n\t\trdp_cap |= RDP_PS_64GB;\n\tif (phba->lmt & LMT_32Gb)\n\t\trdp_cap |= RDP_PS_32GB;\n\tif (phba->lmt & LMT_16Gb)\n\t\trdp_cap |= RDP_PS_16GB;\n\tif (phba->lmt & LMT_10Gb)\n\t\trdp_cap |= RDP_PS_10GB;\n\tif (phba->lmt & LMT_8Gb)\n\t\trdp_cap |= RDP_PS_8GB;\n\tif (phba->lmt & LMT_4Gb)\n\t\trdp_cap |= RDP_PS_4GB;\n\tif (phba->lmt & LMT_2Gb)\n\t\trdp_cap |= RDP_PS_2GB;\n\tif (phba->lmt & LMT_1Gb)\n\t\trdp_cap |= RDP_PS_1GB;\n\n\tif (rdp_cap == 0)\n\t\trdp_cap = RDP_CAP_UNKNOWN;\n\tif (phba->cfg_link_speed != LPFC_USER_LINK_SPEED_AUTO)\n\t\trdp_cap |= RDP_CAP_USER_CONFIGURED;\n\n\tdesc->info.port_speed.capabilities = cpu_to_be16(rdp_cap);\n\tdesc->length = cpu_to_be32(sizeof(desc->info));\n\treturn sizeof(struct fc_rdp_port_speed_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_diag_port_names(struct fc_rdp_port_name_desc *desc,\n\t\tstruct lpfc_vport *vport)\n{\n\n\tdesc->tag = cpu_to_be32(RDP_PORT_NAMES_DESC_TAG);\n\n\tmemcpy(desc->port_names.wwnn, &vport->fc_nodename,\n\t\t\tsizeof(desc->port_names.wwnn));\n\n\tmemcpy(desc->port_names.wwpn, &vport->fc_portname,\n\t\t\tsizeof(desc->port_names.wwpn));\n\n\tdesc->length = cpu_to_be32(sizeof(desc->port_names));\n\treturn sizeof(struct fc_rdp_port_name_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_attach_port_names(struct fc_rdp_port_name_desc *desc,\n\t\tstruct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\n{\n\n\tdesc->tag = cpu_to_be32(RDP_PORT_NAMES_DESC_TAG);\n\tif (vport->fc_flag & FC_FABRIC) {\n\t\tmemcpy(desc->port_names.wwnn, &vport->fabric_nodename,\n\t\t       sizeof(desc->port_names.wwnn));\n\n\t\tmemcpy(desc->port_names.wwpn, &vport->fabric_portname,\n\t\t       sizeof(desc->port_names.wwpn));\n\t} else {  /* Point to Point */\n\t\tmemcpy(desc->port_names.wwnn, &ndlp->nlp_nodename,\n\t\t       sizeof(desc->port_names.wwnn));\n\n\t\tmemcpy(desc->port_names.wwpn, &ndlp->nlp_portname,\n\t\t       sizeof(desc->port_names.wwpn));\n\t}\n\n\tdesc->length = cpu_to_be32(sizeof(desc->port_names));\n\treturn sizeof(struct fc_rdp_port_name_desc);\n}\n\nstatic void\nlpfc_els_rdp_cmpl(struct lpfc_hba *phba, struct lpfc_rdp_context *rdp_context,\n\t\tint status)\n{\n\tstruct lpfc_nodelist *ndlp = rdp_context->ndlp;\n\tstruct lpfc_vport *vport = ndlp->vport;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct ulp_bde64 *bpl;\n\tIOCB_t *icmd;\n\tuint8_t *pcmd;\n\tstruct ls_rjt *stat;\n\tstruct fc_rdp_res_frame *rdp_res;\n\tuint32_t cmdsize, len;\n\tuint16_t *flag_ptr;\n\tint rc;\n\n\tif (status != SUCCESS)\n\t\tgoto error;\n\n\t/* This will change once we know the true size of the RDP payload */\n\tcmdsize = sizeof(struct fc_rdp_res_frame);\n\n\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize,\n\t\t\tlpfc_max_els_tries, rdp_context->ndlp,\n\t\t\trdp_context->ndlp->nlp_DID, ELS_CMD_ACC);\n\tif (!elsiocb)\n\t\tgoto free_rdp_context;\n\n\ticmd = &elsiocb->iocb;\n\ticmd->ulpContext = rdp_context->rx_id;\n\ticmd->unsli3.rcvsli3.ox_id = rdp_context->ox_id;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\"2171 Xmit RDP response tag x%x xri x%x, \"\n\t\t\t\"did x%x, nlp_flag x%x, nlp_state x%x, rpi x%x\",\n\t\t\telsiocb->iotag, elsiocb->iocb.ulpContext,\n\t\t\tndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\tndlp->nlp_rpi);\n\trdp_res = (struct fc_rdp_res_frame *)\n\t\t(((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\tmemset(pcmd, 0, sizeof(struct fc_rdp_res_frame));\n\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\n\t/* Update Alarm and Warning */\n\tflag_ptr = (uint16_t *)(rdp_context->page_a2 + SSF_ALARM_FLAGS);\n\tphba->sfp_alarm |= *flag_ptr;\n\tflag_ptr = (uint16_t *)(rdp_context->page_a2 + SSF_WARNING_FLAGS);\n\tphba->sfp_warning |= *flag_ptr;\n\n\t/* For RDP payload */\n\tlen = 8;\n\tlen += lpfc_rdp_res_link_service((struct fc_rdp_link_service_desc *)\n\t\t\t\t\t (len + pcmd), ELS_CMD_RDP);\n\n\tlen += lpfc_rdp_res_sfp_desc((struct fc_rdp_sfp_desc *)(len + pcmd),\n\t\t\trdp_context->page_a0, rdp_context->page_a2);\n\tlen += lpfc_rdp_res_speed((struct fc_rdp_port_speed_desc *)(len + pcmd),\n\t\t\t\t  phba);\n\tlen += lpfc_rdp_res_link_error((struct fc_rdp_link_error_status_desc *)\n\t\t\t\t       (len + pcmd), &rdp_context->link_stat);\n\tlen += lpfc_rdp_res_diag_port_names((struct fc_rdp_port_name_desc *)\n\t\t\t\t\t     (len + pcmd), vport);\n\tlen += lpfc_rdp_res_attach_port_names((struct fc_rdp_port_name_desc *)\n\t\t\t\t\t(len + pcmd), vport, ndlp);\n\tlen += lpfc_rdp_res_fec_desc((struct fc_fec_rdp_desc *)(len + pcmd),\n\t\t\t&rdp_context->link_stat);\n\tlen += lpfc_rdp_res_bbc_desc((struct fc_rdp_bbc_desc *)(len + pcmd),\n\t\t\t\t     &rdp_context->link_stat, vport);\n\tlen += lpfc_rdp_res_oed_temp_desc(phba,\n\t\t\t\t(struct fc_rdp_oed_sfp_desc *)(len + pcmd),\n\t\t\t\trdp_context->page_a2);\n\tlen += lpfc_rdp_res_oed_voltage_desc(phba,\n\t\t\t\t(struct fc_rdp_oed_sfp_desc *)(len + pcmd),\n\t\t\t\trdp_context->page_a2);\n\tlen += lpfc_rdp_res_oed_txbias_desc(phba,\n\t\t\t\t(struct fc_rdp_oed_sfp_desc *)(len + pcmd),\n\t\t\t\trdp_context->page_a2);\n\tlen += lpfc_rdp_res_oed_txpower_desc(phba,\n\t\t\t\t(struct fc_rdp_oed_sfp_desc *)(len + pcmd),\n\t\t\t\trdp_context->page_a2);\n\tlen += lpfc_rdp_res_oed_rxpower_desc(phba,\n\t\t\t\t(struct fc_rdp_oed_sfp_desc *)(len + pcmd),\n\t\t\t\trdp_context->page_a2);\n\tlen += lpfc_rdp_res_opd_desc((struct fc_rdp_opd_sfp_desc *)(len + pcmd),\n\t\t\t\t     rdp_context->page_a0, vport);\n\n\trdp_res->length = cpu_to_be32(len - 8);\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\n\n\t/* Now that we know the true size of the payload, update the BPL */\n\tbpl = (struct ulp_bde64 *)\n\t\t(((struct lpfc_dmabuf *)(elsiocb->context3))->virt);\n\tbpl->tus.f.bdeSize = len;\n\tbpl->tus.f.bdeFlags = 0;\n\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tgoto free_rdp_context;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_nlp_put(ndlp);\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t}\n\n\tgoto free_rdp_context;\n\nerror:\n\tcmdsize = 2 * sizeof(uint32_t);\n\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, lpfc_max_els_tries,\n\t\t\tndlp, ndlp->nlp_DID, ELS_CMD_LS_RJT);\n\tif (!elsiocb)\n\t\tgoto free_rdp_context;\n\n\ticmd = &elsiocb->iocb;\n\ticmd->ulpContext = rdp_context->rx_id;\n\ticmd->unsli3.rcvsli3.ox_id = rdp_context->ox_id;\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\n\t*((uint32_t *) (pcmd)) = ELS_CMD_LS_RJT;\n\tstat = (struct ls_rjt *)(pcmd + sizeof(uint32_t));\n\tstat->un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\n\tphba->fc_stat.elsXmitLSRJT++;\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tgoto free_rdp_context;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_nlp_put(ndlp);\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t}\n\nfree_rdp_context:\n\t/* This reference put is for the original unsolicited RDP. If the\n\t * iocb prep failed, there is no reference to remove.\n\t */\n\tlpfc_nlp_put(ndlp);\n\tkfree(rdp_context);\n}\n\nstatic int\nlpfc_get_rdp_info(struct lpfc_hba *phba, struct lpfc_rdp_context *rdp_context)\n{\n\tLPFC_MBOXQ_t *mbox = NULL;\n\tint rc;\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_MBOX | LOG_ELS,\n\t\t\t\t\"7105 failed to allocate mailbox memory\");\n\t\treturn 1;\n\t}\n\n\tif (lpfc_sli4_dump_page_a0(phba, mbox))\n\t\tgoto prep_mbox_fail;\n\tmbox->vport = rdp_context->ndlp->vport;\n\tmbox->mbox_cmpl = lpfc_mbx_cmpl_rdp_page_a0;\n\tmbox->ctx_ndlp = (struct lpfc_rdp_context *)rdp_context;\n\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED)\n\t\tgoto issue_mbox_fail;\n\n\treturn 0;\n\nprep_mbox_fail:\nissue_mbox_fail:\n\tmempool_free(mbox, phba->mbox_mem_pool);\n\treturn 1;\n}\n\n/*\n * lpfc_els_rcv_rdp - Process an unsolicited RDP ELS.\n * @vport: pointer to a host virtual N_Port data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine processes an unsolicited RDP(Read Diagnostic Parameters)\n * IOCB. First, the payload of the unsolicited RDP is checked.\n * Then it will (1) send MBX_DUMP_MEMORY, Embedded DMP_LMSD sub command TYPE-3\n * for Page A0, (2) send MBX_DUMP_MEMORY, DMP_LMSD for Page A2,\n * (3) send MBX_READ_LNK_STAT to get link stat, (4) Call lpfc_els_rdp_cmpl\n * gather all data and send RDP response.\n *\n * Return code\n *   0 - Sent the acc response\n *   1 - Sent the reject response.\n */\nstatic int\nlpfc_els_rcv_rdp(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\tstruct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_dmabuf *pcmd;\n\tuint8_t rjt_err, rjt_expl = LSEXP_NOTHING_MORE;\n\tstruct fc_rdp_req_frame *rdp_req;\n\tstruct lpfc_rdp_context *rdp_context;\n\tIOCB_t *cmd = NULL;\n\tstruct ls_rjt stat;\n\n\tif (phba->sli_rev < LPFC_SLI_REV4 ||\n\t    bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) <\n\t\t\t\t\t\tLPFC_SLI_INTF_IF_TYPE_2) {\n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\trjt_expl = LSEXP_REQ_UNSUPPORTED;\n\t\tgoto error;\n\t}\n\n\tif (phba->sli_rev < LPFC_SLI_REV4 || (phba->hba_flag & HBA_FCOE_MODE)) {\n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\trjt_expl = LSEXP_REQ_UNSUPPORTED;\n\t\tgoto error;\n\t}\n\n\tpcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\n\trdp_req = (struct fc_rdp_req_frame *) pcmd->virt;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"2422 ELS RDP Request \"\n\t\t\t \"dec len %d tag x%x port_id %d len %d\\n\",\n\t\t\t be32_to_cpu(rdp_req->rdp_des_length),\n\t\t\t be32_to_cpu(rdp_req->nport_id_desc.tag),\n\t\t\t be32_to_cpu(rdp_req->nport_id_desc.nport_id),\n\t\t\t be32_to_cpu(rdp_req->nport_id_desc.length));\n\n\tif (sizeof(struct fc_rdp_nport_desc) !=\n\t\t\tbe32_to_cpu(rdp_req->rdp_des_length))\n\t\tgoto rjt_logerr;\n\tif (RDP_N_PORT_DESC_TAG != be32_to_cpu(rdp_req->nport_id_desc.tag))\n\t\tgoto rjt_logerr;\n\tif (RDP_NPORT_ID_SIZE !=\n\t\t\tbe32_to_cpu(rdp_req->nport_id_desc.length))\n\t\tgoto rjt_logerr;\n\trdp_context = kzalloc(sizeof(struct lpfc_rdp_context), GFP_KERNEL);\n\tif (!rdp_context) {\n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\tgoto error;\n\t}\n\n\tcmd = &cmdiocb->iocb;\n\trdp_context->ndlp = lpfc_nlp_get(ndlp);\n\tif (!rdp_context->ndlp) {\n\t\tkfree(rdp_context);\n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\tgoto error;\n\t}\n\trdp_context->ox_id = cmd->unsli3.rcvsli3.ox_id;\n\trdp_context->rx_id = cmd->ulpContext;\n\trdp_context->cmpl = lpfc_els_rdp_cmpl;\n\tif (lpfc_get_rdp_info(phba, rdp_context)) {\n\t\tlpfc_printf_vlog(ndlp->vport, KERN_WARNING, LOG_ELS,\n\t\t\t\t \"2423 Unable to send mailbox\");\n\t\tkfree(rdp_context);\n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\tlpfc_nlp_put(ndlp);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nrjt_logerr:\n\trjt_err = LSRJT_LOGICAL_ERR;\n\nerror:\n\tmemset(&stat, 0, sizeof(stat));\n\tstat.un.b.lsRjtRsnCode = rjt_err;\n\tstat.un.b.lsRjtRsnCodeExp = rjt_expl;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\treturn 1;\n}\n\n\nstatic void\nlpfc_els_lcb_rsp(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tMAILBOX_t *mb;\n\tIOCB_t *icmd;\n\tuint8_t *pcmd;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct ls_rjt *stat;\n\tunion lpfc_sli4_cfg_shdr *shdr;\n\tstruct lpfc_lcb_context *lcb_context;\n\tstruct fc_lcb_res_frame *lcb_res;\n\tuint32_t cmdsize, shdr_status, shdr_add_status;\n\tint rc;\n\n\tmb = &pmb->u.mb;\n\tlcb_context = (struct lpfc_lcb_context *)pmb->ctx_ndlp;\n\tndlp = lcb_context->ndlp;\n\tpmb->ctx_ndlp = NULL;\n\tpmb->ctx_buf = NULL;\n\n\tshdr = (union lpfc_sli4_cfg_shdr *)\n\t\t\t&pmb->u.mqe.un.beacon_config.header.cfg_shdr;\n\tshdr_status = bf_get(lpfc_mbox_hdr_status, &shdr->response);\n\tshdr_add_status = bf_get(lpfc_mbox_hdr_add_status, &shdr->response);\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_MBOX,\n\t\t\t\t\"0194 SET_BEACON_CONFIG mailbox \"\n\t\t\t\t\"completed with status x%x add_status x%x,\"\n\t\t\t\t\" mbx status x%x\\n\",\n\t\t\t\tshdr_status, shdr_add_status, mb->mbxStatus);\n\n\tif ((mb->mbxStatus != MBX_SUCCESS) || shdr_status ||\n\t    (shdr_add_status == ADD_STATUS_OPERATION_ALREADY_ACTIVE) ||\n\t    (shdr_add_status == ADD_STATUS_INVALID_REQUEST)) {\n\t\tmempool_free(pmb, phba->mbox_mem_pool);\n\t\tgoto error;\n\t}\n\n\tmempool_free(pmb, phba->mbox_mem_pool);\n\tcmdsize = sizeof(struct fc_lcb_res_frame);\n\telsiocb = lpfc_prep_els_iocb(phba->pport, 0, cmdsize,\n\t\t\tlpfc_max_els_tries, ndlp,\n\t\t\tndlp->nlp_DID, ELS_CMD_ACC);\n\n\t/* Decrement the ndlp reference count from previous mbox command */\n\tlpfc_nlp_put(ndlp);\n\n\tif (!elsiocb)\n\t\tgoto free_lcb_context;\n\n\tlcb_res = (struct fc_lcb_res_frame *)\n\t\t(((struct lpfc_dmabuf *)elsiocb->context2)->virt);\n\n\tmemset(lcb_res, 0, sizeof(struct fc_lcb_res_frame));\n\ticmd = &elsiocb->iocb;\n\ticmd->ulpContext = lcb_context->rx_id;\n\ticmd->unsli3.rcvsli3.ox_id = lcb_context->ox_id;\n\n\tpcmd = (uint8_t *)(((struct lpfc_dmabuf *)elsiocb->context2)->virt);\n\t*((uint32_t *)(pcmd)) = ELS_CMD_ACC;\n\tlcb_res->lcb_sub_command = lcb_context->sub_command;\n\tlcb_res->lcb_type = lcb_context->type;\n\tlcb_res->capability = lcb_context->capability;\n\tlcb_res->lcb_frequency = lcb_context->frequency;\n\tlcb_res->lcb_duration = lcb_context->duration;\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\n\tphba->fc_stat.elsXmitACC++;\n\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto node_err;\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (!rc)\n\t\tgoto out;\n\n\tlpfc_nlp_put(ndlp);\n node_err:\n\tlpfc_els_free_iocb(phba, elsiocb);\n out:\n\tkfree(lcb_context);\n\treturn;\n\nerror:\n\tcmdsize = sizeof(struct fc_lcb_res_frame);\n\telsiocb = lpfc_prep_els_iocb(phba->pport, 0, cmdsize,\n\t\t\tlpfc_max_els_tries, ndlp,\n\t\t\tndlp->nlp_DID, ELS_CMD_LS_RJT);\n\tlpfc_nlp_put(ndlp);\n\tif (!elsiocb)\n\t\tgoto free_lcb_context;\n\n\ticmd = &elsiocb->iocb;\n\ticmd->ulpContext = lcb_context->rx_id;\n\ticmd->unsli3.rcvsli3.ox_id = lcb_context->ox_id;\n\tpcmd = (uint8_t *)(((struct lpfc_dmabuf *)elsiocb->context2)->virt);\n\n\t*((uint32_t *)(pcmd)) = ELS_CMD_LS_RJT;\n\tstat = (struct ls_rjt *)(pcmd + sizeof(uint32_t));\n\tstat->un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\n\tif (shdr_add_status == ADD_STATUS_OPERATION_ALREADY_ACTIVE)\n\t\tstat->un.b.lsRjtRsnCodeExp = LSEXP_CMD_IN_PROGRESS;\n\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\n\tphba->fc_stat.elsXmitLSRJT++;\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tgoto free_lcb_context;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_nlp_put(ndlp);\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t}\nfree_lcb_context:\n\tkfree(lcb_context);\n}\n\nstatic int\nlpfc_sli4_set_beacon(struct lpfc_vport *vport,\n\t\t     struct lpfc_lcb_context *lcb_context,\n\t\t     uint32_t beacon_state)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tunion lpfc_sli4_cfg_shdr *cfg_shdr;\n\tLPFC_MBOXQ_t *mbox = NULL;\n\tuint32_t len;\n\tint rc;\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox)\n\t\treturn 1;\n\n\tcfg_shdr = &mbox->u.mqe.un.sli4_config.header.cfg_shdr;\n\tlen = sizeof(struct lpfc_mbx_set_beacon_config) -\n\t\tsizeof(struct lpfc_sli4_cfg_mhdr);\n\tlpfc_sli4_config(phba, mbox, LPFC_MBOX_SUBSYSTEM_COMMON,\n\t\t\t LPFC_MBOX_OPCODE_SET_BEACON_CONFIG, len,\n\t\t\t LPFC_SLI4_MBX_EMBED);\n\tmbox->ctx_ndlp = (void *)lcb_context;\n\tmbox->vport = phba->pport;\n\tmbox->mbox_cmpl = lpfc_els_lcb_rsp;\n\tbf_set(lpfc_mbx_set_beacon_port_num, &mbox->u.mqe.un.beacon_config,\n\t       phba->sli4_hba.physical_port);\n\tbf_set(lpfc_mbx_set_beacon_state, &mbox->u.mqe.un.beacon_config,\n\t       beacon_state);\n\tmbox->u.mqe.un.beacon_config.word5 = 0;\t\t/* Reserved */\n\n\t/*\n\t *\tCheck bv1s bit before issuing the mailbox\n\t *\tif bv1s == 1, LCB V1 supported\n\t *\telse, LCB V0 supported\n\t */\n\n\tif (phba->sli4_hba.pc_sli4_params.bv1s) {\n\t\t/* COMMON_SET_BEACON_CONFIG_V1 */\n\t\tcfg_shdr->request.word9 = BEACON_VERSION_V1;\n\t\tlcb_context->capability |= LCB_CAPABILITY_DURATION;\n\t\tbf_set(lpfc_mbx_set_beacon_port_type,\n\t\t       &mbox->u.mqe.un.beacon_config, 0);\n\t\tbf_set(lpfc_mbx_set_beacon_duration_v1,\n\t\t       &mbox->u.mqe.un.beacon_config,\n\t\t       be16_to_cpu(lcb_context->duration));\n\t} else {\n\t\t/* COMMON_SET_BEACON_CONFIG_V0 */\n\t\tif (be16_to_cpu(lcb_context->duration) != 0) {\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\t\treturn 1;\n\t\t}\n\t\tcfg_shdr->request.word9 = BEACON_VERSION_V0;\n\t\tlcb_context->capability &=  ~(LCB_CAPABILITY_DURATION);\n\t\tbf_set(lpfc_mbx_set_beacon_state,\n\t\t       &mbox->u.mqe.un.beacon_config, beacon_state);\n\t\tbf_set(lpfc_mbx_set_beacon_port_type,\n\t\t       &mbox->u.mqe.un.beacon_config, 1);\n\t\tbf_set(lpfc_mbx_set_beacon_duration,\n\t\t       &mbox->u.mqe.un.beacon_config,\n\t\t       be16_to_cpu(lcb_context->duration));\n\t}\n\n\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\n/**\n * lpfc_els_rcv_lcb - Process an unsolicited LCB\n * @vport: pointer to a host virtual N_Port data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine processes an unsolicited LCB(LINK CABLE BEACON) IOCB.\n * First, the payload of the unsolicited LCB is checked.\n * Then based on Subcommand beacon will either turn on or off.\n *\n * Return code\n * 0 - Sent the acc response\n * 1 - Sent the reject response.\n **/\nstatic int\nlpfc_els_rcv_lcb(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_dmabuf *pcmd;\n\tuint8_t *lp;\n\tstruct fc_lcb_request_frame *beacon;\n\tstruct lpfc_lcb_context *lcb_context;\n\tu8 state, rjt_err = 0;\n\tstruct ls_rjt stat;\n\n\tpcmd = (struct lpfc_dmabuf *)cmdiocb->context2;\n\tlp = (uint8_t *)pcmd->virt;\n\tbeacon = (struct fc_lcb_request_frame *)pcmd->virt;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\"0192 ELS LCB Data x%x x%x x%x x%x sub x%x \"\n\t\t\t\"type x%x frequency %x duration x%x\\n\",\n\t\t\tlp[0], lp[1], lp[2],\n\t\t\tbeacon->lcb_command,\n\t\t\tbeacon->lcb_sub_command,\n\t\t\tbeacon->lcb_type,\n\t\t\tbeacon->lcb_frequency,\n\t\t\tbe16_to_cpu(beacon->lcb_duration));\n\n\tif (beacon->lcb_sub_command != LPFC_LCB_ON &&\n\t    beacon->lcb_sub_command != LPFC_LCB_OFF) {\n\t\trjt_err = LSRJT_CMD_UNSUPPORTED;\n\t\tgoto rjt;\n\t}\n\n\tif (phba->sli_rev < LPFC_SLI_REV4  ||\n\t    phba->hba_flag & HBA_FCOE_MODE ||\n\t    (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) <\n\t    LPFC_SLI_INTF_IF_TYPE_2)) {\n\t\trjt_err = LSRJT_CMD_UNSUPPORTED;\n\t\tgoto rjt;\n\t}\n\n\tlcb_context = kmalloc(sizeof(*lcb_context), GFP_KERNEL);\n\tif (!lcb_context) {\n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\tgoto rjt;\n\t}\n\n\tstate = (beacon->lcb_sub_command == LPFC_LCB_ON) ? 1 : 0;\n\tlcb_context->sub_command = beacon->lcb_sub_command;\n\tlcb_context->capability\t= 0;\n\tlcb_context->type = beacon->lcb_type;\n\tlcb_context->frequency = beacon->lcb_frequency;\n\tlcb_context->duration = beacon->lcb_duration;\n\tlcb_context->ox_id = cmdiocb->iocb.unsli3.rcvsli3.ox_id;\n\tlcb_context->rx_id = cmdiocb->iocb.ulpContext;\n\tlcb_context->ndlp = lpfc_nlp_get(ndlp);\n\tif (!lcb_context->ndlp) {\n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\tgoto rjt_free;\n\t}\n\n\tif (lpfc_sli4_set_beacon(vport, lcb_context, state)) {\n\t\tlpfc_printf_vlog(ndlp->vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0193 failed to send mail box\");\n\t\tlpfc_nlp_put(ndlp);\n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\tgoto rjt_free;\n\t}\n\treturn 0;\n\nrjt_free:\n\tkfree(lcb_context);\nrjt:\n\tmemset(&stat, 0, sizeof(stat));\n\tstat.un.b.lsRjtRsnCode = rjt_err;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\treturn 1;\n}\n\n\n/**\n * lpfc_els_flush_rscn - Clean up any rscn activities with a vport\n * @vport: pointer to a host virtual N_Port data structure.\n *\n * This routine cleans up any Registration State Change Notification\n * (RSCN) activity with a @vport. Note that the fc_rscn_flush flag of the\n * @vport together with the host_lock is used to prevent multiple thread\n * trying to access the RSCN array on a same @vport at the same time.\n **/\nvoid\nlpfc_els_flush_rscn(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tint i;\n\n\tspin_lock_irq(shost->host_lock);\n\tif (vport->fc_rscn_flush) {\n\t\t/* Another thread is walking fc_rscn_id_list on this vport */\n\t\tspin_unlock_irq(shost->host_lock);\n\t\treturn;\n\t}\n\t/* Indicate we are walking lpfc_els_flush_rscn on this vport */\n\tvport->fc_rscn_flush = 1;\n\tspin_unlock_irq(shost->host_lock);\n\n\tfor (i = 0; i < vport->fc_rscn_id_cnt; i++) {\n\t\tlpfc_in_buf_free(phba, vport->fc_rscn_id_list[i]);\n\t\tvport->fc_rscn_id_list[i] = NULL;\n\t}\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_rscn_id_cnt = 0;\n\tvport->fc_flag &= ~(FC_RSCN_MODE | FC_RSCN_DISCOVERY);\n\tspin_unlock_irq(shost->host_lock);\n\tlpfc_can_disctmo(vport);\n\t/* Indicate we are done walking this fc_rscn_id_list */\n\tvport->fc_rscn_flush = 0;\n}\n\n/**\n * lpfc_rscn_payload_check - Check whether there is a pending rscn to a did\n * @vport: pointer to a host virtual N_Port data structure.\n * @did: remote destination port identifier.\n *\n * This routine checks whether there is any pending Registration State\n * Configuration Notification (RSCN) to a @did on @vport.\n *\n * Return code\n *   None zero - The @did matched with a pending rscn\n *   0 - not able to match @did with a pending rscn\n **/\nint\nlpfc_rscn_payload_check(struct lpfc_vport *vport, uint32_t did)\n{\n\tD_ID ns_did;\n\tD_ID rscn_did;\n\tuint32_t *lp;\n\tuint32_t payload_len, i;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\tns_did.un.word = did;\n\n\t/* Never match fabric nodes for RSCNs */\n\tif ((did & Fabric_DID_MASK) == Fabric_DID_MASK)\n\t\treturn 0;\n\n\t/* If we are doing a FULL RSCN rediscovery, match everything */\n\tif (vport->fc_flag & FC_RSCN_DISCOVERY)\n\t\treturn did;\n\n\tspin_lock_irq(shost->host_lock);\n\tif (vport->fc_rscn_flush) {\n\t\t/* Another thread is walking fc_rscn_id_list on this vport */\n\t\tspin_unlock_irq(shost->host_lock);\n\t\treturn 0;\n\t}\n\t/* Indicate we are walking fc_rscn_id_list on this vport */\n\tvport->fc_rscn_flush = 1;\n\tspin_unlock_irq(shost->host_lock);\n\tfor (i = 0; i < vport->fc_rscn_id_cnt; i++) {\n\t\tlp = vport->fc_rscn_id_list[i]->virt;\n\t\tpayload_len = be32_to_cpu(*lp++ & ~ELS_CMD_MASK);\n\t\tpayload_len -= sizeof(uint32_t);\t/* take off word 0 */\n\t\twhile (payload_len) {\n\t\t\trscn_did.un.word = be32_to_cpu(*lp++);\n\t\t\tpayload_len -= sizeof(uint32_t);\n\t\t\tswitch (rscn_did.un.b.resv & RSCN_ADDRESS_FORMAT_MASK) {\n\t\t\tcase RSCN_ADDRESS_FORMAT_PORT:\n\t\t\t\tif ((ns_did.un.b.domain == rscn_did.un.b.domain)\n\t\t\t\t    && (ns_did.un.b.area == rscn_did.un.b.area)\n\t\t\t\t    && (ns_did.un.b.id == rscn_did.un.b.id))\n\t\t\t\t\tgoto return_did_out;\n\t\t\t\tbreak;\n\t\t\tcase RSCN_ADDRESS_FORMAT_AREA:\n\t\t\t\tif ((ns_did.un.b.domain == rscn_did.un.b.domain)\n\t\t\t\t    && (ns_did.un.b.area == rscn_did.un.b.area))\n\t\t\t\t\tgoto return_did_out;\n\t\t\t\tbreak;\n\t\t\tcase RSCN_ADDRESS_FORMAT_DOMAIN:\n\t\t\t\tif (ns_did.un.b.domain == rscn_did.un.b.domain)\n\t\t\t\t\tgoto return_did_out;\n\t\t\t\tbreak;\n\t\t\tcase RSCN_ADDRESS_FORMAT_FABRIC:\n\t\t\t\tgoto return_did_out;\n\t\t\t}\n\t\t}\n\t}\n\t/* Indicate we are done with walking fc_rscn_id_list on this vport */\n\tvport->fc_rscn_flush = 0;\n\treturn 0;\nreturn_did_out:\n\t/* Indicate we are done with walking fc_rscn_id_list on this vport */\n\tvport->fc_rscn_flush = 0;\n\treturn did;\n}\n\n/**\n * lpfc_rscn_recovery_check - Send recovery event to vport nodes matching rscn\n * @vport: pointer to a host virtual N_Port data structure.\n *\n * This routine sends recovery (NLP_EVT_DEVICE_RECOVERY) event to the\n * state machine for a @vport's nodes that are with pending RSCN (Registration\n * State Change Notification).\n *\n * Return code\n *   0 - Successful (currently alway return 0)\n **/\nstatic int\nlpfc_rscn_recovery_check(struct lpfc_vport *vport)\n{\n\tstruct lpfc_nodelist *ndlp = NULL;\n\n\t/* Move all affected nodes by pending RSCNs to NPR state. */\n\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tif ((ndlp->nlp_state == NLP_STE_UNUSED_NODE) ||\n\t\t    !lpfc_rscn_payload_check(vport, ndlp->nlp_DID))\n\t\t\tcontinue;\n\n\t\t/* NVME Target mode does not do RSCN Recovery. */\n\t\tif (vport->phba->nvmet_support)\n\t\t\tcontinue;\n\n\t\t/* If we are in the process of doing discovery on this\n\t\t * NPort, let it continue on its own.\n\t\t */\n\t\tswitch (ndlp->nlp_state) {\n\t\tcase  NLP_STE_PLOGI_ISSUE:\n\t\tcase  NLP_STE_ADISC_ISSUE:\n\t\tcase  NLP_STE_REG_LOGIN_ISSUE:\n\t\tcase  NLP_STE_PRLI_ISSUE:\n\t\tcase  NLP_STE_LOGO_ISSUE:\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check to see if we need to NVME rescan this target\n\t\t * remoteport.\n\t\t */\n\t\tif (ndlp->nlp_fc4_type & NLP_FC4_NVME &&\n\t\t    ndlp->nlp_type & (NLP_NVME_TARGET | NLP_NVME_DISCOVERY))\n\t\t\tlpfc_nvme_rescan_port(vport, ndlp);\n\n\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RECOVERY);\n\t\tlpfc_cancel_retry_delay_tmo(vport, ndlp);\n\t}\n\treturn 0;\n}\n\n/**\n * lpfc_send_rscn_event - Send an RSCN event to management application\n * @vport: pointer to a host virtual N_Port data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n *\n * lpfc_send_rscn_event sends an RSCN netlink event to management\n * applications.\n */\nstatic void\nlpfc_send_rscn_event(struct lpfc_vport *vport,\n\t\tstruct lpfc_iocbq *cmdiocb)\n{\n\tstruct lpfc_dmabuf *pcmd;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tuint32_t *payload_ptr;\n\tuint32_t payload_len;\n\tstruct lpfc_rscn_event_header *rscn_event_data;\n\n\tpcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\n\tpayload_ptr = (uint32_t *) pcmd->virt;\n\tpayload_len = be32_to_cpu(*payload_ptr & ~ELS_CMD_MASK);\n\n\trscn_event_data = kmalloc(sizeof(struct lpfc_rscn_event_header) +\n\t\tpayload_len, GFP_KERNEL);\n\tif (!rscn_event_data) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"0147 Failed to allocate memory for RSCN event\\n\");\n\t\treturn;\n\t}\n\trscn_event_data->event_type = FC_REG_RSCN_EVENT;\n\trscn_event_data->payload_length = payload_len;\n\tmemcpy(rscn_event_data->rscn_payload, payload_ptr,\n\t\tpayload_len);\n\n\tfc_host_post_vendor_event(shost,\n\t\tfc_get_event_number(),\n\t\tsizeof(struct lpfc_rscn_event_header) + payload_len,\n\t\t(char *)rscn_event_data,\n\t\tLPFC_NL_VENDOR_ID);\n\n\tkfree(rscn_event_data);\n}\n\n/**\n * lpfc_els_rcv_rscn - Process an unsolicited rscn iocb\n * @vport: pointer to a host virtual N_Port data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine processes an unsolicited RSCN (Registration State Change\n * Notification) IOCB. First, the payload of the unsolicited RSCN is walked\n * to invoke fc_host_post_event() routine to the FC transport layer. If the\n * discover state machine is about to begin discovery, it just accepts the\n * RSCN and the discovery process will satisfy the RSCN. If this RSCN only\n * contains N_Port IDs for other vports on this HBA, it just accepts the\n * RSCN and ignore processing it. If the state machine is in the recovery\n * state, the fc_rscn_id_list of this @vport is walked and the\n * lpfc_rscn_recovery_check() routine is invoked to send recovery event for\n * all nodes that match RSCN payload. Otherwise, the lpfc_els_handle_rscn()\n * routine is invoked to handle the RSCN event.\n *\n * Return code\n *   0 - Just sent the acc response\n *   1 - Sent the acc response and waited for name server completion\n **/\nstatic int\nlpfc_els_rcv_rscn(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t  struct lpfc_nodelist *ndlp)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_dmabuf *pcmd;\n\tuint32_t *lp, *datap;\n\tuint32_t payload_len, length, nportid, *cmd;\n\tint rscn_cnt;\n\tint rscn_id = 0, hba_id = 0;\n\tint i, tmo;\n\n\tpcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\n\tlp = (uint32_t *) pcmd->virt;\n\n\tpayload_len = be32_to_cpu(*lp++ & ~ELS_CMD_MASK);\n\tpayload_len -= sizeof(uint32_t);\t/* take off word 0 */\n\t/* RSCN received */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"0214 RSCN received Data: x%x x%x x%x x%x\\n\",\n\t\t\t vport->fc_flag, payload_len, *lp,\n\t\t\t vport->fc_rscn_id_cnt);\n\n\t/* Send an RSCN event to the management application */\n\tlpfc_send_rscn_event(vport, cmdiocb);\n\n\tfor (i = 0; i < payload_len/sizeof(uint32_t); i++)\n\t\tfc_host_post_event(shost, fc_get_event_number(),\n\t\t\tFCH_EVT_RSCN, lp[i]);\n\n\t/* Check if RSCN is coming from a direct-connected remote NPort */\n\tif (vport->fc_flag & FC_PT2PT) {\n\t\t/* If so, just ACC it, no other action needed for now */\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"2024 pt2pt RSCN %08x Data: x%x x%x\\n\",\n\t\t\t\t *lp, vport->fc_flag, payload_len);\n\t\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\n\t\t/* Check to see if we need to NVME rescan this target\n\t\t * remoteport.\n\t\t */\n\t\tif (ndlp->nlp_fc4_type & NLP_FC4_NVME &&\n\t\t    ndlp->nlp_type & (NLP_NVME_TARGET | NLP_NVME_DISCOVERY))\n\t\t\tlpfc_nvme_rescan_port(vport, ndlp);\n\t\treturn 0;\n\t}\n\n\t/* If we are about to begin discovery, just ACC the RSCN.\n\t * Discovery processing will satisfy it.\n\t */\n\tif (vport->port_state <= LPFC_NS_QRY) {\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV RSCN ignore: did:x%x/ste:x%x flg:x%x\",\n\t\t\tndlp->nlp_DID, vport->port_state, ndlp->nlp_flag);\n\n\t\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\t\treturn 0;\n\t}\n\n\t/* If this RSCN just contains NPortIDs for other vports on this HBA,\n\t * just ACC and ignore it.\n\t */\n\tif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&\n\t\t!(vport->cfg_peer_port_login)) {\n\t\ti = payload_len;\n\t\tdatap = lp;\n\t\twhile (i > 0) {\n\t\t\tnportid = *datap++;\n\t\t\tnportid = ((be32_to_cpu(nportid)) & Mask_DID);\n\t\t\ti -= sizeof(uint32_t);\n\t\t\trscn_id++;\n\t\t\tif (lpfc_find_vport_by_did(phba, nportid))\n\t\t\t\thba_id++;\n\t\t}\n\t\tif (rscn_id == hba_id) {\n\t\t\t/* ALL NPortIDs in RSCN are on HBA */\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t\t \"0219 Ignore RSCN \"\n\t\t\t\t\t \"Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t\t vport->fc_flag, payload_len,\n\t\t\t\t\t *lp, vport->fc_rscn_id_cnt);\n\t\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\t\"RCV RSCN vport:  did:x%x/ste:x%x flg:x%x\",\n\t\t\t\tndlp->nlp_DID, vport->port_state,\n\t\t\t\tndlp->nlp_flag);\n\n\t\t\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb,\n\t\t\t\tndlp, NULL);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tspin_lock_irq(shost->host_lock);\n\tif (vport->fc_rscn_flush) {\n\t\t/* Another thread is walking fc_rscn_id_list on this vport */\n\t\tvport->fc_flag |= FC_RSCN_DISCOVERY;\n\t\tspin_unlock_irq(shost->host_lock);\n\t\t/* Send back ACC */\n\t\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\t\treturn 0;\n\t}\n\t/* Indicate we are walking fc_rscn_id_list on this vport */\n\tvport->fc_rscn_flush = 1;\n\tspin_unlock_irq(shost->host_lock);\n\t/* Get the array count after successfully have the token */\n\trscn_cnt = vport->fc_rscn_id_cnt;\n\t/* If we are already processing an RSCN, save the received\n\t * RSCN payload buffer, cmdiocb->context2 to process later.\n\t */\n\tif (vport->fc_flag & (FC_RSCN_MODE | FC_NDISC_ACTIVE)) {\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV RSCN defer:  did:x%x/ste:x%x flg:x%x\",\n\t\t\tndlp->nlp_DID, vport->port_state, ndlp->nlp_flag);\n\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag |= FC_RSCN_DEFERRED;\n\n\t\t/* Restart disctmo if its already running */\n\t\tif (vport->fc_flag & FC_DISC_TMO) {\n\t\t\ttmo = ((phba->fc_ratov * 3) + 3);\n\t\t\tmod_timer(&vport->fc_disctmo,\n\t\t\t\t  jiffies + msecs_to_jiffies(1000 * tmo));\n\t\t}\n\t\tif ((rscn_cnt < FC_MAX_HOLD_RSCN) &&\n\t\t    !(vport->fc_flag & FC_RSCN_DISCOVERY)) {\n\t\t\tvport->fc_flag |= FC_RSCN_MODE;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\tif (rscn_cnt) {\n\t\t\t\tcmd = vport->fc_rscn_id_list[rscn_cnt-1]->virt;\n\t\t\t\tlength = be32_to_cpu(*cmd & ~ELS_CMD_MASK);\n\t\t\t}\n\t\t\tif ((rscn_cnt) &&\n\t\t\t    (payload_len + length <= LPFC_BPL_SIZE)) {\n\t\t\t\t*cmd &= ELS_CMD_MASK;\n\t\t\t\t*cmd |= cpu_to_be32(payload_len + length);\n\t\t\t\tmemcpy(((uint8_t *)cmd) + length, lp,\n\t\t\t\t       payload_len);\n\t\t\t} else {\n\t\t\t\tvport->fc_rscn_id_list[rscn_cnt] = pcmd;\n\t\t\t\tvport->fc_rscn_id_cnt++;\n\t\t\t\t/* If we zero, cmdiocb->context2, the calling\n\t\t\t\t * routine will not try to free it.\n\t\t\t\t */\n\t\t\t\tcmdiocb->context2 = NULL;\n\t\t\t}\n\t\t\t/* Deferred RSCN */\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t\t \"0235 Deferred RSCN \"\n\t\t\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t\t\t vport->fc_rscn_id_cnt, vport->fc_flag,\n\t\t\t\t\t vport->port_state);\n\t\t} else {\n\t\t\tvport->fc_flag |= FC_RSCN_DISCOVERY;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t/* ReDiscovery RSCN */\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t\t \"0234 ReDiscovery RSCN \"\n\t\t\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t\t\t vport->fc_rscn_id_cnt, vport->fc_flag,\n\t\t\t\t\t vport->port_state);\n\t\t}\n\t\t/* Indicate we are done walking fc_rscn_id_list on this vport */\n\t\tvport->fc_rscn_flush = 0;\n\t\t/* Send back ACC */\n\t\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\t\t/* send RECOVERY event for ALL nodes that match RSCN payload */\n\t\tlpfc_rscn_recovery_check(vport);\n\t\treturn 0;\n\t}\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\"RCV RSCN:        did:x%x/ste:x%x flg:x%x\",\n\t\tndlp->nlp_DID, vport->port_state, ndlp->nlp_flag);\n\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag |= FC_RSCN_MODE;\n\tspin_unlock_irq(shost->host_lock);\n\tvport->fc_rscn_id_list[vport->fc_rscn_id_cnt++] = pcmd;\n\t/* Indicate we are done walking fc_rscn_id_list on this vport */\n\tvport->fc_rscn_flush = 0;\n\t/*\n\t * If we zero, cmdiocb->context2, the calling routine will\n\t * not try to free it.\n\t */\n\tcmdiocb->context2 = NULL;\n\tlpfc_set_disctmo(vport);\n\t/* Send back ACC */\n\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\t/* send RECOVERY event for ALL nodes that match RSCN payload */\n\tlpfc_rscn_recovery_check(vport);\n\treturn lpfc_els_handle_rscn(vport);\n}\n\n/**\n * lpfc_els_handle_rscn - Handle rscn for a vport\n * @vport: pointer to a host virtual N_Port data structure.\n *\n * This routine handles the Registration State Configuration Notification\n * (RSCN) for a @vport. If login to NameServer does not exist, a new ndlp shall\n * be created and a Port Login (PLOGI) to the NameServer is issued. Otherwise,\n * if the ndlp to NameServer exists, a Common Transport (CT) command to the\n * NameServer shall be issued. If CT command to the NameServer fails to be\n * issued, the lpfc_els_flush_rscn() routine shall be invoked to clean up any\n * RSCN activities with the @vport.\n *\n * Return code\n *   0 - Cleaned up rscn on the @vport\n *   1 - Wait for plogi to name server before proceed\n **/\nint\nlpfc_els_handle_rscn(struct lpfc_vport *vport)\n{\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_hba  *phba = vport->phba;\n\n\t/* Ignore RSCN if the port is being torn down. */\n\tif (vport->load_flag & FC_UNLOADING) {\n\t\tlpfc_els_flush_rscn(vport);\n\t\treturn 0;\n\t}\n\n\t/* Start timer for RSCN processing */\n\tlpfc_set_disctmo(vport);\n\n\t/* RSCN processed */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"0215 RSCN processed Data: x%x x%x x%x x%x x%x x%x\\n\",\n\t\t\t vport->fc_flag, 0, vport->fc_rscn_id_cnt,\n\t\t\t vport->port_state, vport->num_disc_nodes,\n\t\t\t vport->gidft_inp);\n\n\t/* To process RSCN, first compare RSCN data with NameServer */\n\tvport->fc_ns_retry = 0;\n\tvport->num_disc_nodes = 0;\n\n\tndlp = lpfc_findnode_did(vport, NameServer_DID);\n\tif (ndlp && ndlp->nlp_state == NLP_STE_UNMAPPED_NODE) {\n\t\t/* Good ndlp, issue CT Request to NameServer.  Need to\n\t\t * know how many gidfts were issued.  If none, then just\n\t\t * flush the RSCN.  Otherwise, the outstanding requests\n\t\t * need to complete.\n\t\t */\n\t\tif (phba->cfg_ns_query == LPFC_NS_QUERY_GID_FT) {\n\t\t\tif (lpfc_issue_gidft(vport) > 0)\n\t\t\t\treturn 1;\n\t\t} else if (phba->cfg_ns_query == LPFC_NS_QUERY_GID_PT) {\n\t\t\tif (lpfc_issue_gidpt(vport) > 0)\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\t/* Nameserver login in question.  Revalidate. */\n\t\tif (ndlp) {\n\t\t\tndlp->nlp_prev_state = NLP_STE_UNUSED_NODE;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\n\t\t} else {\n\t\t\tndlp = lpfc_nlp_init(vport, NameServer_DID);\n\t\t\tif (!ndlp) {\n\t\t\t\tlpfc_els_flush_rscn(vport);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\n\t\t}\n\t\tndlp->nlp_type |= NLP_FABRIC;\n\t\tlpfc_issue_els_plogi(vport, NameServer_DID, 0);\n\t\t/* Wait for NameServer login cmpl before we can\n\t\t * continue\n\t\t */\n\t\treturn 1;\n\t}\n\n\tlpfc_els_flush_rscn(vport);\n\treturn 0;\n}\n\n/**\n * lpfc_els_rcv_flogi - Process an unsolicited flogi iocb\n * @vport: pointer to a host virtual N_Port data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine processes Fabric Login (FLOGI) IOCB received as an ELS\n * unsolicited event. An unsolicited FLOGI can be received in a point-to-\n * point topology. As an unsolicited FLOGI should not be received in a loop\n * mode, any unsolicited FLOGI received in loop mode shall be ignored. The\n * lpfc_check_sparm() routine is invoked to check the parameters in the\n * unsolicited FLOGI. If parameters validation failed, the routine\n * lpfc_els_rsp_reject() shall be called with reject reason code set to\n * LSEXP_SPARM_OPTIONS to reject the FLOGI. Otherwise, the Port WWN in the\n * FLOGI shall be compared with the Port WWN of the @vport to determine who\n * will initiate PLOGI. The higher lexicographical value party shall has\n * higher priority (as the winning port) and will initiate PLOGI and\n * communicate Port_IDs (Addresses) for both nodes in PLOGI. The result\n * of this will be marked in the @vport fc_flag field with FC_PT2PT_PLOGI\n * and then the lpfc_els_rsp_acc() routine is invoked to accept the FLOGI.\n *\n * Return code\n *   0 - Successfully processed the unsolicited flogi\n *   1 - Failed to process the unsolicited flogi\n **/\nstatic int\nlpfc_els_rcv_flogi(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t   struct lpfc_nodelist *ndlp)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_dmabuf *pcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\n\tuint32_t *lp = (uint32_t *) pcmd->virt;\n\tIOCB_t *icmd = &cmdiocb->iocb;\n\tstruct serv_parm *sp;\n\tLPFC_MBOXQ_t *mbox;\n\tuint32_t cmd, did;\n\tint rc;\n\tuint32_t fc_flag = 0;\n\tuint32_t port_state = 0;\n\n\tcmd = *lp++;\n\tsp = (struct serv_parm *) lp;\n\n\t/* FLOGI received */\n\n\tlpfc_set_disctmo(vport);\n\n\tif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\t/* We should never receive a FLOGI in loop mode, ignore it */\n\t\tdid = icmd->un.elsreq64.remoteID;\n\n\t\t/* An FLOGI ELS command <elsCmd> was received from DID <did> in\n\t\t   Loop Mode */\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0113 An FLOGI ELS command x%x was \"\n\t\t\t\t \"received from DID x%x in Loop Mode\\n\",\n\t\t\t\t cmd, did);\n\t\treturn 1;\n\t}\n\n\t(void) lpfc_check_sparm(vport, ndlp, sp, CLASS3, 1);\n\n\t/*\n\t * If our portname is greater than the remote portname,\n\t * then we initiate Nport login.\n\t */\n\n\trc = memcmp(&vport->fc_portname, &sp->portName,\n\t\t    sizeof(struct lpfc_name));\n\n\tif (!rc) {\n\t\tif (phba->sli_rev < LPFC_SLI_REV4) {\n\t\t\tmbox = mempool_alloc(phba->mbox_mem_pool,\n\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (!mbox)\n\t\t\t\treturn 1;\n\t\t\tlpfc_linkdown(phba);\n\t\t\tlpfc_init_link(phba, mbox,\n\t\t\t\t       phba->cfg_topology,\n\t\t\t\t       phba->cfg_link_speed);\n\t\t\tmbox->u.mb.un.varInitLnk.lipsr_AL_PA = 0;\n\t\t\tmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t\t\tmbox->vport = vport;\n\t\t\trc = lpfc_sli_issue_mbox(phba, mbox,\n\t\t\t\t\t\t MBX_NOWAIT);\n\t\t\tlpfc_set_loopback_flag(phba);\n\t\t\tif (rc == MBX_NOT_FINISHED)\n\t\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* abort the flogi coming back to ourselves\n\t\t * due to external loopback on the port.\n\t\t */\n\t\tlpfc_els_abort_flogi(phba);\n\t\treturn 0;\n\n\t} else if (rc > 0) {\t/* greater than */\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag |= FC_PT2PT_PLOGI;\n\t\tspin_unlock_irq(shost->host_lock);\n\n\t\t/* If we have the high WWPN we can assign our own\n\t\t * myDID; otherwise, we have to WAIT for a PLOGI\n\t\t * from the remote NPort to find out what it\n\t\t * will be.\n\t\t */\n\t\tvport->fc_myDID = PT2PT_LocalID;\n\t} else {\n\t\tvport->fc_myDID = PT2PT_RemoteID;\n\t}\n\n\t/*\n\t * The vport state should go to LPFC_FLOGI only\n\t * AFTER we issue a FLOGI, not receive one.\n\t */\n\tspin_lock_irq(shost->host_lock);\n\tfc_flag = vport->fc_flag;\n\tport_state = vport->port_state;\n\tvport->fc_flag |= FC_PT2PT;\n\tvport->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);\n\n\t/* Acking an unsol FLOGI.  Count 1 for link bounce\n\t * work-around.\n\t */\n\tvport->rcv_flogi_cnt++;\n\tspin_unlock_irq(shost->host_lock);\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"3311 Rcv Flogi PS x%x new PS x%x \"\n\t\t\t \"fc_flag x%x new fc_flag x%x\\n\",\n\t\t\t port_state, vport->port_state,\n\t\t\t fc_flag, vport->fc_flag);\n\n\t/*\n\t * We temporarily set fc_myDID to make it look like we are\n\t * a Fabric. This is done just so we end up with the right\n\t * did / sid on the FLOGI ACC rsp.\n\t */\n\tdid = vport->fc_myDID;\n\tvport->fc_myDID = Fabric_DID;\n\n\tmemcpy(&phba->fc_fabparam, sp, sizeof(struct serv_parm));\n\n\t/* Defer ACC response until AFTER we issue a FLOGI */\n\tif (!(phba->hba_flag & HBA_FLOGI_ISSUED)) {\n\t\tphba->defer_flogi_acc_rx_id = cmdiocb->iocb.ulpContext;\n\t\tphba->defer_flogi_acc_ox_id =\n\t\t\t\t\tcmdiocb->iocb.unsli3.rcvsli3.ox_id;\n\n\t\tvport->fc_myDID = did;\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"3344 Deferring FLOGI ACC: rx_id: x%x,\"\n\t\t\t\t \" ox_id: x%x, hba_flag x%x\\n\",\n\t\t\t\t phba->defer_flogi_acc_rx_id,\n\t\t\t\t phba->defer_flogi_acc_ox_id, phba->hba_flag);\n\n\t\tphba->defer_flogi_acc_flag = true;\n\n\t\treturn 0;\n\t}\n\n\t/* Send back ACC */\n\tlpfc_els_rsp_acc(vport, ELS_CMD_FLOGI, cmdiocb, ndlp, NULL);\n\n\t/* Now lets put fc_myDID back to what its supposed to be */\n\tvport->fc_myDID = did;\n\n\treturn 0;\n}\n\n/**\n * lpfc_els_rcv_rnid - Process an unsolicited rnid iocb\n * @vport: pointer to a host virtual N_Port data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine processes Request Node Identification Data (RNID) IOCB\n * received as an ELS unsolicited event. Only when the RNID specified format\n * 0x0 or 0xDF (Topology Discovery Specific Node Identification Data)\n * present, this routine will invoke the lpfc_els_rsp_rnid_acc() routine to\n * Accept (ACC) the RNID ELS command. All the other RNID formats are\n * rejected by invoking the lpfc_els_rsp_reject() routine.\n *\n * Return code\n *   0 - Successfully processed rnid iocb (currently always return 0)\n **/\nstatic int\nlpfc_els_rcv_rnid(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t  struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_dmabuf *pcmd;\n\tuint32_t *lp;\n\tRNID *rn;\n\tstruct ls_rjt stat;\n\n\tpcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\n\tlp = (uint32_t *) pcmd->virt;\n\n\tlp++;\n\trn = (RNID *) lp;\n\n\t/* RNID received */\n\n\tswitch (rn->Format) {\n\tcase 0:\n\tcase RNID_TOPOLOGY_DISC:\n\t\t/* Send back ACC */\n\t\tlpfc_els_rsp_rnid_acc(vport, rn->Format, cmdiocb, ndlp);\n\t\tbreak;\n\tdefault:\n\t\t/* Reject this request because format not supported */\n\t\tstat.un.b.lsRjtRsvd0 = 0;\n\t\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\t\tstat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;\n\t\tstat.un.b.vendorUnique = 0;\n\t\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp,\n\t\t\tNULL);\n\t}\n\treturn 0;\n}\n\n/**\n * lpfc_els_rcv_echo - Process an unsolicited echo iocb\n * @vport: pointer to a host virtual N_Port data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * Return code\n *   0 - Successfully processed echo iocb (currently always return 0)\n **/\nstatic int\nlpfc_els_rcv_echo(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t  struct lpfc_nodelist *ndlp)\n{\n\tuint8_t *pcmd;\n\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) cmdiocb->context2)->virt);\n\n\t/* skip over first word of echo command to find echo data */\n\tpcmd += sizeof(uint32_t);\n\n\tlpfc_els_rsp_echo_acc(vport, pcmd, cmdiocb, ndlp);\n\treturn 0;\n}\n\n/**\n * lpfc_els_rcv_lirr - Process an unsolicited lirr iocb\n * @vport: pointer to a host virtual N_Port data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine processes a Link Incident Report Registration(LIRR) IOCB\n * received as an ELS unsolicited event. Currently, this function just invokes\n * the lpfc_els_rsp_reject() routine to reject the LIRR IOCB unconditionally.\n *\n * Return code\n *   0 - Successfully processed lirr iocb (currently always return 0)\n **/\nstatic int\nlpfc_els_rcv_lirr(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t  struct lpfc_nodelist *ndlp)\n{\n\tstruct ls_rjt stat;\n\n\t/* For now, unconditionally reject this command */\n\tstat.un.b.lsRjtRsvd0 = 0;\n\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\tstat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;\n\tstat.un.b.vendorUnique = 0;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\treturn 0;\n}\n\n/**\n * lpfc_els_rcv_rrq - Process an unsolicited rrq iocb\n * @vport: pointer to a host virtual N_Port data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine processes a Reinstate Recovery Qualifier (RRQ) IOCB\n * received as an ELS unsolicited event. A request to RRQ shall only\n * be accepted if the Originator Nx_Port N_Port_ID or the Responder\n * Nx_Port N_Port_ID of the target Exchange is the same as the\n * N_Port_ID of the Nx_Port that makes the request. If the RRQ is\n * not accepted, an LS_RJT with reason code \"Unable to perform\n * command request\" and reason code explanation \"Invalid Originator\n * S_ID\" shall be returned. For now, we just unconditionally accept\n * RRQ from the target.\n **/\nstatic void\nlpfc_els_rcv_rrq(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t struct lpfc_nodelist *ndlp)\n{\n\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\tif (vport->phba->sli_rev == LPFC_SLI_REV4)\n\t\tlpfc_els_clear_rrq(vport, cmdiocb, ndlp);\n}\n\n/**\n * lpfc_els_rsp_rls_acc - Completion callbk func for MBX_READ_LNK_STAT mbox cmd\n * @phba: pointer to lpfc hba data structure.\n * @pmb: pointer to the driver internal queue element for mailbox command.\n *\n * This routine is the completion callback function for the MBX_READ_LNK_STAT\n * mailbox command. This callback function is to actually send the Accept\n * (ACC) response to a Read Port Status (RPS) unsolicited IOCB event. It\n * collects the link statistics from the completion of the MBX_READ_LNK_STAT\n * mailbox command, constructs the RPS response with the link statistics\n * collected, and then invokes the lpfc_sli_issue_iocb() routine to send ACC\n * response to the RPS.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the RPS Accept Response ELS IOCB command.\n *\n **/\nstatic void\nlpfc_els_rsp_rls_acc(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tint rc = 0;\n\tMAILBOX_t *mb;\n\tIOCB_t *icmd;\n\tstruct RLS_RSP *rls_rsp;\n\tuint8_t *pcmd;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct lpfc_nodelist *ndlp;\n\tuint16_t oxid;\n\tuint16_t rxid;\n\tuint32_t cmdsize;\n\n\tmb = &pmb->u.mb;\n\n\tndlp = (struct lpfc_nodelist *)pmb->ctx_ndlp;\n\trxid = (uint16_t)((unsigned long)(pmb->ctx_buf) & 0xffff);\n\toxid = (uint16_t)(((unsigned long)(pmb->ctx_buf) >> 16) & 0xffff);\n\tpmb->ctx_buf = NULL;\n\tpmb->ctx_ndlp = NULL;\n\n\tif (mb->mbxStatus) {\n\t\tmempool_free(pmb, phba->mbox_mem_pool);\n\t\treturn;\n\t}\n\n\tcmdsize = sizeof(struct RLS_RSP) + sizeof(uint32_t);\n\telsiocb = lpfc_prep_els_iocb(phba->pport, 0, cmdsize,\n\t\t\t\t     lpfc_max_els_tries, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_ACC);\n\n\t/* Decrement the ndlp reference count from previous mbox command */\n\tlpfc_nlp_put(ndlp);\n\n\tif (!elsiocb) {\n\t\tmempool_free(pmb, phba->mbox_mem_pool);\n\t\treturn;\n\t}\n\n\ticmd = &elsiocb->iocb;\n\ticmd->ulpContext = rxid;\n\ticmd->unsli3.rcvsli3.ox_id = oxid;\n\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\tpcmd += sizeof(uint32_t); /* Skip past command */\n\trls_rsp = (struct RLS_RSP *)pcmd;\n\n\trls_rsp->linkFailureCnt = cpu_to_be32(mb->un.varRdLnk.linkFailureCnt);\n\trls_rsp->lossSyncCnt = cpu_to_be32(mb->un.varRdLnk.lossSyncCnt);\n\trls_rsp->lossSignalCnt = cpu_to_be32(mb->un.varRdLnk.lossSignalCnt);\n\trls_rsp->primSeqErrCnt = cpu_to_be32(mb->un.varRdLnk.primSeqErrCnt);\n\trls_rsp->invalidXmitWord = cpu_to_be32(mb->un.varRdLnk.invalidXmitWord);\n\trls_rsp->crcCnt = cpu_to_be32(mb->un.varRdLnk.crcCnt);\n\tmempool_free(pmb, phba->mbox_mem_pool);\n\t/* Xmit ELS RLS ACC response tag <ulpIoTag> */\n\tlpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_ELS,\n\t\t\t \"2874 Xmit ELS RLS ACC response tag x%x xri x%x, \"\n\t\t\t \"did x%x, nlp_flag x%x, nlp_state x%x, rpi x%x\\n\",\n\t\t\t elsiocb->iotag, elsiocb->iocb.ulpContext,\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t ndlp->nlp_rpi);\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto node_err;\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR)\n\t\tgoto io_err;\n\treturn;\n\n io_err:\n\tlpfc_nlp_put(ndlp);\n node_err:\n\tlpfc_els_free_iocb(phba, elsiocb);\n}\n\n/**\n * lpfc_els_rcv_rls - Process an unsolicited rls iocb\n * @vport: pointer to a host virtual N_Port data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine processes Read Link Status (RLS) IOCB received as an\n * ELS unsolicited event. It first checks the remote port state. If the\n * remote port is not in NLP_STE_UNMAPPED_NODE state or NLP_STE_MAPPED_NODE\n * state, it invokes the lpfc_els_rsl_reject() routine to send the reject\n * response. Otherwise, it issue the MBX_READ_LNK_STAT mailbox command\n * for reading the HBA link statistics. It is for the callback function,\n * lpfc_els_rsp_rls_acc(), set to the MBX_READ_LNK_STAT mailbox command\n * to actually sending out RPL Accept (ACC) response.\n *\n * Return codes\n *   0 - Successfully processed rls iocb (currently always return 0)\n **/\nstatic int\nlpfc_els_rcv_rls(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tLPFC_MBOXQ_t *mbox;\n\tstruct ls_rjt stat;\n\n\tif ((ndlp->nlp_state != NLP_STE_UNMAPPED_NODE) &&\n\t    (ndlp->nlp_state != NLP_STE_MAPPED_NODE))\n\t\t/* reject the unsolicited RLS request and done with it */\n\t\tgoto reject_out;\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_ATOMIC);\n\tif (mbox) {\n\t\tlpfc_read_lnk_stat(phba, mbox);\n\t\tmbox->ctx_buf = (void *)((unsigned long)\n\t\t\t((cmdiocb->iocb.unsli3.rcvsli3.ox_id << 16) |\n\t\t\tcmdiocb->iocb.ulpContext)); /* rx_id */\n\t\tmbox->ctx_ndlp = lpfc_nlp_get(ndlp);\n\t\tif (!mbox->ctx_ndlp)\n\t\t\tgoto node_err;\n\t\tmbox->vport = vport;\n\t\tmbox->mbox_cmpl = lpfc_els_rsp_rls_acc;\n\t\tif (lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT)\n\t\t\t!= MBX_NOT_FINISHED)\n\t\t\t/* Mbox completion will send ELS Response */\n\t\t\treturn 0;\n\t\t/* Decrement reference count used for the failed mbox\n\t\t * command.\n\t\t */\n\t\tlpfc_nlp_put(ndlp);\nnode_err:\n\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t}\nreject_out:\n\t/* issue rejection response */\n\tstat.un.b.lsRjtRsvd0 = 0;\n\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\tstat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;\n\tstat.un.b.vendorUnique = 0;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\treturn 0;\n}\n\n/**\n * lpfc_els_rcv_rtv - Process an unsolicited rtv iocb\n * @vport: pointer to a host virtual N_Port data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine processes Read Timout Value (RTV) IOCB received as an\n * ELS unsolicited event. It first checks the remote port state. If the\n * remote port is not in NLP_STE_UNMAPPED_NODE state or NLP_STE_MAPPED_NODE\n * state, it invokes the lpfc_els_rsl_reject() routine to send the reject\n * response. Otherwise, it sends the Accept(ACC) response to a Read Timeout\n * Value (RTV) unsolicited IOCB event.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the RTV Accept Response ELS IOCB command.\n *\n * Return codes\n *   0 - Successfully processed rtv iocb (currently always return 0)\n **/\nstatic int\nlpfc_els_rcv_rtv(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t struct lpfc_nodelist *ndlp)\n{\n\tint rc = 0;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct ls_rjt stat;\n\tstruct RTV_RSP *rtv_rsp;\n\tuint8_t *pcmd;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint32_t cmdsize;\n\n\n\tif ((ndlp->nlp_state != NLP_STE_UNMAPPED_NODE) &&\n\t    (ndlp->nlp_state != NLP_STE_MAPPED_NODE))\n\t\t/* reject the unsolicited RTV request and done with it */\n\t\tgoto reject_out;\n\n\tcmdsize = sizeof(struct RTV_RSP) + sizeof(uint32_t);\n\telsiocb = lpfc_prep_els_iocb(phba->pport, 0, cmdsize,\n\t\t\t\t     lpfc_max_els_tries, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_ACC);\n\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\tpcmd += sizeof(uint32_t); /* Skip past command */\n\n\t/* use the command's xri in the response */\n\telsiocb->iocb.ulpContext = cmdiocb->iocb.ulpContext;  /* Xri / rx_id */\n\telsiocb->iocb.unsli3.rcvsli3.ox_id = cmdiocb->iocb.unsli3.rcvsli3.ox_id;\n\n\trtv_rsp = (struct RTV_RSP *)pcmd;\n\n\t/* populate RTV payload */\n\trtv_rsp->ratov = cpu_to_be32(phba->fc_ratov * 1000); /* report msecs */\n\trtv_rsp->edtov = cpu_to_be32(phba->fc_edtov);\n\tbf_set(qtov_edtovres, rtv_rsp, phba->fc_edtovResol ? 1 : 0);\n\tbf_set(qtov_rttov, rtv_rsp, 0); /* Field is for FC ONLY */\n\trtv_rsp->qtov = cpu_to_be32(rtv_rsp->qtov);\n\n\t/* Xmit ELS RLS ACC response tag <ulpIoTag> */\n\tlpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_ELS,\n\t\t\t \"2875 Xmit ELS RTV ACC response tag x%x xri x%x, \"\n\t\t\t \"did x%x, nlp_flag x%x, nlp_state x%x, rpi x%x, \"\n\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t elsiocb->iotag, elsiocb->iocb.ulpContext,\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t ndlp->nlp_rpi,\n\t\t\trtv_rsp->ratov, rtv_rsp->edtov, rtv_rsp->qtov);\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 0;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_nlp_put(ndlp);\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t}\n\treturn 0;\n\nreject_out:\n\t/* issue rejection response */\n\tstat.un.b.lsRjtRsvd0 = 0;\n\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\tstat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;\n\tstat.un.b.vendorUnique = 0;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\treturn 0;\n}\n\n/* lpfc_issue_els_rrq - Process an unsolicited rrq iocb\n * @vport: pointer to a host virtual N_Port data structure.\n * @ndlp: pointer to a node-list data structure.\n * @did: DID of the target.\n * @rrq: Pointer to the rrq struct.\n *\n * Build a ELS RRQ command and send it to the target. If the issue_iocb is\n * Successful the the completion handler will clear the RRQ.\n *\n * Return codes\n *   0 - Successfully sent rrq els iocb.\n *   1 - Failed to send rrq els iocb.\n **/\nstatic int\nlpfc_issue_els_rrq(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\tuint32_t did, struct lpfc_node_rrq *rrq)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct RRQ *els_rrq;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tint ret;\n\n\n\tif (ndlp != rrq->ndlp)\n\t\tndlp = rrq->ndlp;\n\tif (!ndlp)\n\t\treturn 1;\n\n\t/* If ndlp is not NULL, we will bump the reference count on it */\n\tcmdsize = (sizeof(uint32_t) + sizeof(struct RRQ));\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, 0, ndlp, did,\n\t\t\t\t     ELS_CMD_RRQ);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\n\t/* For RRQ request, remainder of payload is Exchange IDs */\n\t*((uint32_t *) (pcmd)) = ELS_CMD_RRQ;\n\tpcmd += sizeof(uint32_t);\n\tels_rrq = (struct RRQ *) pcmd;\n\n\tbf_set(rrq_oxid, els_rrq, phba->sli4_hba.xri_ids[rrq->xritag]);\n\tbf_set(rrq_rxid, els_rrq, rrq->rxid);\n\tbf_set(rrq_did, els_rrq, vport->fc_myDID);\n\tels_rrq->rrq = cpu_to_be32(els_rrq->rrq);\n\tels_rrq->rrq_exchg = cpu_to_be32(els_rrq->rrq_exchg);\n\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Issue RRQ:     did:x%x\",\n\t\tdid, rrq->xritag, rrq->rxid);\n\telsiocb->context_un.rrq = rrq;\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_rrq;\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto node_err;\n\n\tret = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (ret == IOCB_ERROR)\n\t\tgoto io_err;\n\treturn 0;\n\n io_err:\n\tlpfc_nlp_put(ndlp);\n node_err:\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn 1;\n}\n\n/**\n * lpfc_send_rrq - Sends ELS RRQ if needed.\n * @phba: pointer to lpfc hba data structure.\n * @rrq: pointer to the active rrq.\n *\n * This routine will call the lpfc_issue_els_rrq if the rrq is\n * still active for the xri. If this function returns a failure then\n * the caller needs to clean up the RRQ by calling lpfc_clr_active_rrq.\n *\n * Returns 0 Success.\n *         1 Failure.\n **/\nint\nlpfc_send_rrq(struct lpfc_hba *phba, struct lpfc_node_rrq *rrq)\n{\n\tstruct lpfc_nodelist *ndlp = lpfc_findnode_did(rrq->vport,\n\t\t\t\t\t\t       rrq->nlp_DID);\n\tif (!ndlp)\n\t\treturn 1;\n\n\tif (lpfc_test_rrq_active(phba, ndlp, rrq->xritag))\n\t\treturn lpfc_issue_els_rrq(rrq->vport, ndlp,\n\t\t\t\t\t rrq->nlp_DID, rrq);\n\telse\n\t\treturn 1;\n}\n\n/**\n * lpfc_els_rsp_rpl_acc - Issue an accept rpl els command\n * @vport: pointer to a host virtual N_Port data structure.\n * @cmdsize: size of the ELS command.\n * @oldiocb: pointer to the original lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine issuees an Accept (ACC) Read Port List (RPL) ELS command.\n * It is to be called by the lpfc_els_rcv_rpl() routine to accept the RPL.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the RPL Accept Response ELS command.\n *\n * Return code\n *   0 - Successfully issued ACC RPL ELS command\n *   1 - Failed to issue ACC RPL ELS command\n **/\nstatic int\nlpfc_els_rsp_rpl_acc(struct lpfc_vport *vport, uint16_t cmdsize,\n\t\t     struct lpfc_iocbq *oldiocb, struct lpfc_nodelist *ndlp)\n{\n\tint rc = 0;\n\tstruct lpfc_hba *phba = vport->phba;\n\tIOCB_t *icmd, *oldcmd;\n\tRPL_RSP rpl_rsp;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\n\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_ACC);\n\n\tif (!elsiocb)\n\t\treturn 1;\n\n\ticmd = &elsiocb->iocb;\n\toldcmd = &oldiocb->iocb;\n\ticmd->ulpContext = oldcmd->ulpContext;\t/* Xri / rx_id */\n\ticmd->unsli3.rcvsli3.ox_id = oldcmd->unsli3.rcvsli3.ox_id;\n\n\tpcmd = (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\tpcmd += sizeof(uint16_t);\n\t*((uint16_t *)(pcmd)) = be16_to_cpu(cmdsize);\n\tpcmd += sizeof(uint16_t);\n\n\t/* Setup the RPL ACC payload */\n\trpl_rsp.listLen = be32_to_cpu(1);\n\trpl_rsp.index = 0;\n\trpl_rsp.port_num_blk.portNum = 0;\n\trpl_rsp.port_num_blk.portID = be32_to_cpu(vport->fc_myDID);\n\tmemcpy(&rpl_rsp.port_num_blk.portName, &vport->fc_portname,\n\t    sizeof(struct lpfc_name));\n\tmemcpy(pcmd, &rpl_rsp, cmdsize - sizeof(uint32_t));\n\t/* Xmit ELS RPL ACC response tag <ulpIoTag> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0120 Xmit ELS RPL ACC response tag x%x \"\n\t\t\t \"xri x%x, did x%x, nlp_flag x%x, nlp_state x%x, \"\n\t\t\t \"rpi x%x\\n\",\n\t\t\t elsiocb->iotag, elsiocb->iocb.ulpContext,\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t ndlp->nlp_rpi);\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_rsp;\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto node_err;\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR)\n\t\tgoto io_err;\n\treturn 0;\n\n io_err:\n\tlpfc_nlp_put(ndlp);\n node_err:\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn 1;\n}\n\n/**\n * lpfc_els_rcv_rpl - Process an unsolicited rpl iocb\n * @vport: pointer to a host virtual N_Port data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine processes Read Port List (RPL) IOCB received as an ELS\n * unsolicited event. It first checks the remote port state. If the remote\n * port is not in NLP_STE_UNMAPPED_NODE and NLP_STE_MAPPED_NODE states, it\n * invokes the lpfc_els_rsp_reject() routine to send reject response.\n * Otherwise, this routine then invokes the lpfc_els_rsp_rpl_acc() routine\n * to accept the RPL.\n *\n * Return code\n *   0 - Successfully processed rpl iocb (currently always return 0)\n **/\nstatic int\nlpfc_els_rcv_rpl(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_dmabuf *pcmd;\n\tuint32_t *lp;\n\tuint32_t maxsize;\n\tuint16_t cmdsize;\n\tRPL *rpl;\n\tstruct ls_rjt stat;\n\n\tif ((ndlp->nlp_state != NLP_STE_UNMAPPED_NODE) &&\n\t    (ndlp->nlp_state != NLP_STE_MAPPED_NODE)) {\n\t\t/* issue rejection response */\n\t\tstat.un.b.lsRjtRsvd0 = 0;\n\t\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\t\tstat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;\n\t\tstat.un.b.vendorUnique = 0;\n\t\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp,\n\t\t\tNULL);\n\t\t/* rejected the unsolicited RPL request and done with it */\n\t\treturn 0;\n\t}\n\n\tpcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\n\tlp = (uint32_t *) pcmd->virt;\n\trpl = (RPL *) (lp + 1);\n\tmaxsize = be32_to_cpu(rpl->maxsize);\n\n\t/* We support only one port */\n\tif ((rpl->index == 0) &&\n\t    ((maxsize == 0) ||\n\t     ((maxsize * sizeof(uint32_t)) >= sizeof(RPL_RSP)))) {\n\t\tcmdsize = sizeof(uint32_t) + sizeof(RPL_RSP);\n\t} else {\n\t\tcmdsize = sizeof(uint32_t) + maxsize * sizeof(uint32_t);\n\t}\n\tlpfc_els_rsp_rpl_acc(vport, cmdsize, cmdiocb, ndlp);\n\n\treturn 0;\n}\n\n/**\n * lpfc_els_rcv_farp - Process an unsolicited farp request els command\n * @vport: pointer to a virtual N_Port data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine processes Fibre Channel Address Resolution Protocol\n * (FARP) Request IOCB received as an ELS unsolicited event. Currently,\n * the lpfc driver only supports matching on WWPN or WWNN for FARP. As such,\n * FARP_MATCH_PORT flag and FARP_MATCH_NODE flag are checked against the\n * Match Flag in the FARP request IOCB: if FARP_MATCH_PORT flag is set, the\n * remote PortName is compared against the FC PortName stored in the @vport\n * data structure; if FARP_MATCH_NODE flag is set, the remote NodeName is\n * compared against the FC NodeName stored in the @vport data structure.\n * If any of these matches and the FARP_REQUEST_FARPR flag is set in the\n * FARP request IOCB Response Flag, the lpfc_issue_els_farpr() routine is\n * invoked to send out FARP Response to the remote node. Before sending the\n * FARP Response, however, the FARP_REQUEST_PLOGI flag is check in the FARP\n * request IOCB Response Flag and, if it is set, the lpfc_issue_els_plogi()\n * routine is invoked to log into the remote port first.\n *\n * Return code\n *   0 - Either the FARP Match Mode not supported or successfully processed\n **/\nstatic int\nlpfc_els_rcv_farp(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t  struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_dmabuf *pcmd;\n\tuint32_t *lp;\n\tIOCB_t *icmd;\n\tFARP *fp;\n\tuint32_t cnt, did;\n\n\ticmd = &cmdiocb->iocb;\n\tdid = icmd->un.elsreq64.remoteID;\n\tpcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\n\tlp = (uint32_t *) pcmd->virt;\n\n\tlp++;\n\tfp = (FARP *) lp;\n\t/* FARP-REQ received from DID <did> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0601 FARP-REQ received from DID x%x\\n\", did);\n\t/* We will only support match on WWPN or WWNN */\n\tif (fp->Mflags & ~(FARP_MATCH_NODE | FARP_MATCH_PORT)) {\n\t\treturn 0;\n\t}\n\n\tcnt = 0;\n\t/* If this FARP command is searching for my portname */\n\tif (fp->Mflags & FARP_MATCH_PORT) {\n\t\tif (memcmp(&fp->RportName, &vport->fc_portname,\n\t\t\t   sizeof(struct lpfc_name)) == 0)\n\t\t\tcnt = 1;\n\t}\n\n\t/* If this FARP command is searching for my nodename */\n\tif (fp->Mflags & FARP_MATCH_NODE) {\n\t\tif (memcmp(&fp->RnodeName, &vport->fc_nodename,\n\t\t\t   sizeof(struct lpfc_name)) == 0)\n\t\t\tcnt = 1;\n\t}\n\n\tif (cnt) {\n\t\tif ((ndlp->nlp_state == NLP_STE_UNMAPPED_NODE) ||\n\t\t   (ndlp->nlp_state == NLP_STE_MAPPED_NODE)) {\n\t\t\t/* Log back into the node before sending the FARP. */\n\t\t\tif (fp->Rflags & FARP_REQUEST_PLOGI) {\n\t\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\t\tlpfc_nlp_set_state(vport, ndlp,\n\t\t\t\t\t\t   NLP_STE_PLOGI_ISSUE);\n\t\t\t\tlpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0);\n\t\t\t}\n\n\t\t\t/* Send a FARP response to that node */\n\t\t\tif (fp->Rflags & FARP_REQUEST_FARPR)\n\t\t\t\tlpfc_issue_els_farpr(vport, did, 0);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * lpfc_els_rcv_farpr - Process an unsolicited farp response iocb\n * @vport: pointer to a host virtual N_Port data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine processes Fibre Channel Address Resolution Protocol\n * Response (FARPR) IOCB received as an ELS unsolicited event. It simply\n * invokes the lpfc_els_rsp_acc() routine to the remote node to accept\n * the FARP response request.\n *\n * Return code\n *   0 - Successfully processed FARPR IOCB (currently always return 0)\n **/\nstatic int\nlpfc_els_rcv_farpr(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t   struct lpfc_nodelist  *ndlp)\n{\n\tstruct lpfc_dmabuf *pcmd;\n\tuint32_t *lp;\n\tIOCB_t *icmd;\n\tuint32_t did;\n\n\ticmd = &cmdiocb->iocb;\n\tdid = icmd->un.elsreq64.remoteID;\n\tpcmd = (struct lpfc_dmabuf *) cmdiocb->context2;\n\tlp = (uint32_t *) pcmd->virt;\n\n\tlp++;\n\t/* FARP-RSP received from DID <did> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0600 FARP-RSP received from DID x%x\\n\", did);\n\t/* ACCEPT the Farp resp request */\n\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\n\treturn 0;\n}\n\n/**\n * lpfc_els_rcv_fan - Process an unsolicited fan iocb command\n * @vport: pointer to a host virtual N_Port data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @fan_ndlp: pointer to a node-list data structure.\n *\n * This routine processes a Fabric Address Notification (FAN) IOCB\n * command received as an ELS unsolicited event. The FAN ELS command will\n * only be processed on a physical port (i.e., the @vport represents the\n * physical port). The fabric NodeName and PortName from the FAN IOCB are\n * compared against those in the phba data structure. If any of those is\n * different, the lpfc_initial_flogi() routine is invoked to initialize\n * Fabric Login (FLOGI) to the fabric to start the discover over. Otherwise,\n * if both of those are identical, the lpfc_issue_fabric_reglogin() routine\n * is invoked to register login to the fabric.\n *\n * Return code\n *   0 - Successfully processed fan iocb (currently always return 0).\n **/\nstatic int\nlpfc_els_rcv_fan(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t struct lpfc_nodelist *fan_ndlp)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tuint32_t *lp;\n\tFAN *fp;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS, \"0265 FAN received\\n\");\n\tlp = (uint32_t *)((struct lpfc_dmabuf *)cmdiocb->context2)->virt;\n\tfp = (FAN *) ++lp;\n\t/* FAN received; Fan does not have a reply sequence */\n\tif ((vport == phba->pport) &&\n\t    (vport->port_state == LPFC_LOCAL_CFG_LINK)) {\n\t\tif ((memcmp(&phba->fc_fabparam.nodeName, &fp->FnodeName,\n\t\t\t    sizeof(struct lpfc_name))) ||\n\t\t    (memcmp(&phba->fc_fabparam.portName, &fp->FportName,\n\t\t\t    sizeof(struct lpfc_name)))) {\n\t\t\t/* This port has switched fabrics. FLOGI is required */\n\t\t\tlpfc_issue_init_vfi(vport);\n\t\t} else {\n\t\t\t/* FAN verified - skip FLOGI */\n\t\t\tvport->fc_myDID = vport->fc_prevDID;\n\t\t\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\t\t\tlpfc_issue_fabric_reglogin(vport);\n\t\t\telse {\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t\t\"3138 Need register VFI: (x%x/%x)\\n\",\n\t\t\t\t\tvport->fc_prevDID, vport->fc_myDID);\n\t\t\t\tlpfc_issue_reg_vfi(vport);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * lpfc_els_timeout - Handler funciton to the els timer\n * @t: timer context used to obtain the vport.\n *\n * This routine is invoked by the ELS timer after timeout. It posts the ELS\n * timer timeout event by setting the WORKER_ELS_TMO bit to the work port\n * event bitmap and then invokes the lpfc_worker_wake_up() routine to wake\n * up the worker thread. It is for the worker thread to invoke the routine\n * lpfc_els_timeout_handler() to work on the posted event WORKER_ELS_TMO.\n **/\nvoid\nlpfc_els_timeout(struct timer_list *t)\n{\n\tstruct lpfc_vport *vport = from_timer(vport, t, els_tmofunc);\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t tmo_posted;\n\tunsigned long iflag;\n\n\tspin_lock_irqsave(&vport->work_port_lock, iflag);\n\ttmo_posted = vport->work_port_events & WORKER_ELS_TMO;\n\tif ((!tmo_posted) && (!(vport->load_flag & FC_UNLOADING)))\n\t\tvport->work_port_events |= WORKER_ELS_TMO;\n\tspin_unlock_irqrestore(&vport->work_port_lock, iflag);\n\n\tif ((!tmo_posted) && (!(vport->load_flag & FC_UNLOADING)))\n\t\tlpfc_worker_wake_up(phba);\n\treturn;\n}\n\n\n/**\n * lpfc_els_timeout_handler - Process an els timeout event\n * @vport: pointer to a virtual N_Port data structure.\n *\n * This routine is the actual handler function that processes an ELS timeout\n * event. It walks the ELS ring to get and abort all the IOCBs (except the\n * ABORT/CLOSE/FARP/FARPR/FDISC), which are associated with the @vport by\n * invoking the lpfc_sli_issue_abort_iotag() routine.\n **/\nvoid\nlpfc_els_timeout_handler(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_sli_ring *pring;\n\tstruct lpfc_iocbq *tmp_iocb, *piocb;\n\tIOCB_t *cmd = NULL;\n\tstruct lpfc_dmabuf *pcmd;\n\tuint32_t els_command = 0;\n\tuint32_t timeout;\n\tuint32_t remote_ID = 0xffffffff;\n\tLIST_HEAD(abort_list);\n\n\n\ttimeout = (uint32_t)(phba->fc_ratov << 1);\n\n\tpring = lpfc_phba_elsring(phba);\n\tif (unlikely(!pring))\n\t\treturn;\n\n\tif (phba->pport->load_flag & FC_UNLOADING)\n\t\treturn;\n\n\tspin_lock_irq(&phba->hbalock);\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_lock(&pring->ring_lock);\n\n\tlist_for_each_entry_safe(piocb, tmp_iocb, &pring->txcmplq, list) {\n\t\tcmd = &piocb->iocb;\n\n\t\tif ((piocb->iocb_flag & LPFC_IO_LIBDFC) != 0 ||\n\t\t    piocb->iocb.ulpCommand == CMD_ABORT_XRI_CN ||\n\t\t    piocb->iocb.ulpCommand == CMD_CLOSE_XRI_CN)\n\t\t\tcontinue;\n\n\t\tif (piocb->vport != vport)\n\t\t\tcontinue;\n\n\t\tpcmd = (struct lpfc_dmabuf *) piocb->context2;\n\t\tif (pcmd)\n\t\t\tels_command = *(uint32_t *) (pcmd->virt);\n\n\t\tif (els_command == ELS_CMD_FARP ||\n\t\t    els_command == ELS_CMD_FARPR ||\n\t\t    els_command == ELS_CMD_FDISC)\n\t\t\tcontinue;\n\n\t\tif (piocb->drvrTimeout > 0) {\n\t\t\tif (piocb->drvrTimeout >= timeout)\n\t\t\t\tpiocb->drvrTimeout -= timeout;\n\t\t\telse\n\t\t\t\tpiocb->drvrTimeout = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tremote_ID = 0xffffffff;\n\t\tif (cmd->ulpCommand != CMD_GEN_REQUEST64_CR)\n\t\t\tremote_ID = cmd->un.elsreq64.remoteID;\n\t\telse {\n\t\t\tstruct lpfc_nodelist *ndlp;\n\t\t\tndlp = __lpfc_findnode_rpi(vport, cmd->ulpContext);\n\t\t\tif (ndlp)\n\t\t\t\tremote_ID = ndlp->nlp_DID;\n\t\t}\n\t\tlist_add_tail(&piocb->dlist, &abort_list);\n\t}\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_unlock(&pring->ring_lock);\n\tspin_unlock_irq(&phba->hbalock);\n\n\tlist_for_each_entry_safe(piocb, tmp_iocb, &abort_list, dlist) {\n\t\tcmd = &piocb->iocb;\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0127 ELS timeout Data: x%x x%x x%x \"\n\t\t\t \"x%x\\n\", els_command,\n\t\t\t remote_ID, cmd->ulpCommand, cmd->ulpIoTag);\n\t\tspin_lock_irq(&phba->hbalock);\n\t\tlist_del_init(&piocb->dlist);\n\t\tlpfc_sli_issue_abort_iotag(phba, pring, piocb, NULL);\n\t\tspin_unlock_irq(&phba->hbalock);\n\t}\n\n\tif (!list_empty(&pring->txcmplq))\n\t\tif (!(phba->pport->load_flag & FC_UNLOADING))\n\t\t\tmod_timer(&vport->els_tmofunc,\n\t\t\t\t  jiffies + msecs_to_jiffies(1000 * timeout));\n}\n\n/**\n * lpfc_els_flush_cmd - Clean up the outstanding els commands to a vport\n * @vport: pointer to a host virtual N_Port data structure.\n *\n * This routine is used to clean up all the outstanding ELS commands on a\n * @vport. It first aborts the @vport by invoking lpfc_fabric_abort_vport()\n * routine. After that, it walks the ELS transmit queue to remove all the\n * IOCBs with the @vport other than the QUE_RING and ABORT/CLOSE IOCBs. For\n * the IOCBs with a non-NULL completion callback function, the callback\n * function will be invoked with the status set to IOSTAT_LOCAL_REJECT and\n * un.ulpWord[4] set to IOERR_SLI_ABORTED. For IOCBs with a NULL completion\n * callback function, the IOCB will simply be released. Finally, it walks\n * the ELS transmit completion queue to issue an abort IOCB to any transmit\n * completion queue IOCB that is associated with the @vport and is not\n * an IOCB from libdfc (i.e., the management plane IOCBs that are not\n * part of the discovery state machine) out to HBA by invoking the\n * lpfc_sli_issue_abort_iotag() routine. Note that this function issues the\n * abort IOCB to any transmit completion queueed IOCB, it does not guarantee\n * the IOCBs are aborted when this function returns.\n **/\nvoid\nlpfc_els_flush_cmd(struct lpfc_vport *vport)\n{\n\tLIST_HEAD(abort_list);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_sli_ring *pring;\n\tstruct lpfc_iocbq *tmp_iocb, *piocb;\n\tIOCB_t *cmd = NULL;\n\tunsigned long iflags = 0;\n\n\tlpfc_fabric_abort_vport(vport);\n\n\t/*\n\t * For SLI3, only the hbalock is required.  But SLI4 needs to coordinate\n\t * with the ring insert operation.  Because lpfc_sli_issue_abort_iotag\n\t * ultimately grabs the ring_lock, the driver must splice the list into\n\t * a working list and release the locks before calling the abort.\n\t */\n\tspin_lock_irqsave(&phba->hbalock, iflags);\n\tpring = lpfc_phba_elsring(phba);\n\n\t/* Bail out if we've no ELS wq, like in PCI error recovery case. */\n\tif (unlikely(!pring)) {\n\t\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\t\treturn;\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_lock(&pring->ring_lock);\n\n\t/* First we need to issue aborts to outstanding cmds on txcmpl */\n\tlist_for_each_entry_safe(piocb, tmp_iocb, &pring->txcmplq, list) {\n\t\tif (piocb->iocb_flag & LPFC_IO_LIBDFC)\n\t\t\tcontinue;\n\n\t\tif (piocb->vport != vport)\n\t\t\tcontinue;\n\n\t\tif (piocb->iocb_flag & LPFC_DRIVER_ABORTED)\n\t\t\tcontinue;\n\n\t\t/* On the ELS ring we can have ELS_REQUESTs or\n\t\t * GEN_REQUESTs waiting for a response.\n\t\t */\n\t\tcmd = &piocb->iocb;\n\t\tif (cmd->ulpCommand == CMD_ELS_REQUEST64_CR) {\n\t\t\tlist_add_tail(&piocb->dlist, &abort_list);\n\n\t\t\t/* If the link is down when flushing ELS commands\n\t\t\t * the firmware will not complete them till after\n\t\t\t * the link comes back up. This may confuse\n\t\t\t * discovery for the new link up, so we need to\n\t\t\t * change the compl routine to just clean up the iocb\n\t\t\t * and avoid any retry logic.\n\t\t\t */\n\t\t\tif (phba->link_state == LPFC_LINK_DOWN)\n\t\t\t\tpiocb->iocb_cmpl = lpfc_cmpl_els_link_down;\n\t\t}\n\t\tif (cmd->ulpCommand == CMD_GEN_REQUEST64_CR)\n\t\t\tlist_add_tail(&piocb->dlist, &abort_list);\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_unlock(&pring->ring_lock);\n\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\n\t/* Abort each txcmpl iocb on aborted list and remove the dlist links. */\n\tlist_for_each_entry_safe(piocb, tmp_iocb, &abort_list, dlist) {\n\t\tspin_lock_irqsave(&phba->hbalock, iflags);\n\t\tlist_del_init(&piocb->dlist);\n\t\tlpfc_sli_issue_abort_iotag(phba, pring, piocb, NULL);\n\t\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\t}\n\tif (!list_empty(&abort_list))\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"3387 abort list for txq not empty\\n\");\n\tINIT_LIST_HEAD(&abort_list);\n\n\tspin_lock_irqsave(&phba->hbalock, iflags);\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_lock(&pring->ring_lock);\n\n\t/* No need to abort the txq list,\n\t * just queue them up for lpfc_sli_cancel_iocbs\n\t */\n\tlist_for_each_entry_safe(piocb, tmp_iocb, &pring->txq, list) {\n\t\tcmd = &piocb->iocb;\n\n\t\tif (piocb->iocb_flag & LPFC_IO_LIBDFC) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Do not flush out the QUE_RING and ABORT/CLOSE iocbs */\n\t\tif (cmd->ulpCommand == CMD_QUE_RING_BUF_CN ||\n\t\t    cmd->ulpCommand == CMD_QUE_RING_BUF64_CN ||\n\t\t    cmd->ulpCommand == CMD_CLOSE_XRI_CN ||\n\t\t    cmd->ulpCommand == CMD_ABORT_XRI_CN)\n\t\t\tcontinue;\n\n\t\tif (piocb->vport != vport)\n\t\t\tcontinue;\n\n\t\tlist_del_init(&piocb->list);\n\t\tlist_add_tail(&piocb->list, &abort_list);\n\t}\n\n\t/* The same holds true for any FLOGI/FDISC on the fabric_iocb_list */\n\tif (vport == phba->pport) {\n\t\tlist_for_each_entry_safe(piocb, tmp_iocb,\n\t\t\t\t\t &phba->fabric_iocb_list, list) {\n\t\t\tcmd = &piocb->iocb;\n\t\t\tlist_del_init(&piocb->list);\n\t\t\tlist_add_tail(&piocb->list, &abort_list);\n\t\t}\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_unlock(&pring->ring_lock);\n\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\n\t/* Cancel all the IOCBs from the completions list */\n\tlpfc_sli_cancel_iocbs(phba, &abort_list,\n\t\t\t      IOSTAT_LOCAL_REJECT, IOERR_SLI_ABORTED);\n\n\treturn;\n}\n\n/**\n * lpfc_els_flush_all_cmd - Clean up all the outstanding els commands to a HBA\n * @phba: pointer to lpfc hba data structure.\n *\n * This routine is used to clean up all the outstanding ELS commands on a\n * @phba. It first aborts the @phba by invoking the lpfc_fabric_abort_hba()\n * routine. After that, it walks the ELS transmit queue to remove all the\n * IOCBs to the @phba other than the QUE_RING and ABORT/CLOSE IOCBs. For\n * the IOCBs with the completion callback function associated, the callback\n * function will be invoked with the status set to IOSTAT_LOCAL_REJECT and\n * un.ulpWord[4] set to IOERR_SLI_ABORTED. For IOCBs without the completion\n * callback function associated, the IOCB will simply be released. Finally,\n * it walks the ELS transmit completion queue to issue an abort IOCB to any\n * transmit completion queue IOCB that is not an IOCB from libdfc (i.e., the\n * management plane IOCBs that are not part of the discovery state machine)\n * out to HBA by invoking the lpfc_sli_issue_abort_iotag() routine.\n **/\nvoid\nlpfc_els_flush_all_cmd(struct lpfc_hba  *phba)\n{\n\tstruct lpfc_vport *vport;\n\n\tspin_lock_irq(&phba->port_list_lock);\n\tlist_for_each_entry(vport, &phba->port_list, listentry)\n\t\tlpfc_els_flush_cmd(vport);\n\tspin_unlock_irq(&phba->port_list_lock);\n\n\treturn;\n}\n\n/**\n * lpfc_send_els_failure_event - Posts an ELS command failure event\n * @phba: Pointer to hba context object.\n * @cmdiocbp: Pointer to command iocb which reported error.\n * @rspiocbp: Pointer to response iocb which reported error.\n *\n * This function sends an event when there is an ELS command\n * failure.\n **/\nvoid\nlpfc_send_els_failure_event(struct lpfc_hba *phba,\n\t\t\tstruct lpfc_iocbq *cmdiocbp,\n\t\t\tstruct lpfc_iocbq *rspiocbp)\n{\n\tstruct lpfc_vport *vport = cmdiocbp->vport;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_lsrjt_event lsrjt_event;\n\tstruct lpfc_fabric_event_header fabric_event;\n\tstruct ls_rjt stat;\n\tstruct lpfc_nodelist *ndlp;\n\tuint32_t *pcmd;\n\n\tndlp = cmdiocbp->context1;\n\tif (!ndlp)\n\t\treturn;\n\n\tif (rspiocbp->iocb.ulpStatus == IOSTAT_LS_RJT) {\n\t\tlsrjt_event.header.event_type = FC_REG_ELS_EVENT;\n\t\tlsrjt_event.header.subcategory = LPFC_EVENT_LSRJT_RCV;\n\t\tmemcpy(lsrjt_event.header.wwpn, &ndlp->nlp_portname,\n\t\t\tsizeof(struct lpfc_name));\n\t\tmemcpy(lsrjt_event.header.wwnn, &ndlp->nlp_nodename,\n\t\t\tsizeof(struct lpfc_name));\n\t\tpcmd = (uint32_t *) (((struct lpfc_dmabuf *)\n\t\t\tcmdiocbp->context2)->virt);\n\t\tlsrjt_event.command = (pcmd != NULL) ? *pcmd : 0;\n\t\tstat.un.lsRjtError = be32_to_cpu(rspiocbp->iocb.un.ulpWord[4]);\n\t\tlsrjt_event.reason_code = stat.un.b.lsRjtRsnCode;\n\t\tlsrjt_event.explanation = stat.un.b.lsRjtRsnCodeExp;\n\t\tfc_host_post_vendor_event(shost,\n\t\t\tfc_get_event_number(),\n\t\t\tsizeof(lsrjt_event),\n\t\t\t(char *)&lsrjt_event,\n\t\t\tLPFC_NL_VENDOR_ID);\n\t\treturn;\n\t}\n\tif ((rspiocbp->iocb.ulpStatus == IOSTAT_NPORT_BSY) ||\n\t\t(rspiocbp->iocb.ulpStatus == IOSTAT_FABRIC_BSY)) {\n\t\tfabric_event.event_type = FC_REG_FABRIC_EVENT;\n\t\tif (rspiocbp->iocb.ulpStatus == IOSTAT_NPORT_BSY)\n\t\t\tfabric_event.subcategory = LPFC_EVENT_PORT_BUSY;\n\t\telse\n\t\t\tfabric_event.subcategory = LPFC_EVENT_FABRIC_BUSY;\n\t\tmemcpy(fabric_event.wwpn, &ndlp->nlp_portname,\n\t\t\tsizeof(struct lpfc_name));\n\t\tmemcpy(fabric_event.wwnn, &ndlp->nlp_nodename,\n\t\t\tsizeof(struct lpfc_name));\n\t\tfc_host_post_vendor_event(shost,\n\t\t\tfc_get_event_number(),\n\t\t\tsizeof(fabric_event),\n\t\t\t(char *)&fabric_event,\n\t\t\tLPFC_NL_VENDOR_ID);\n\t\treturn;\n\t}\n\n}\n\n/**\n * lpfc_send_els_event - Posts unsolicited els event\n * @vport: Pointer to vport object.\n * @ndlp: Pointer FC node object.\n * @payload: ELS command code type.\n *\n * This function posts an event when there is an incoming\n * unsolicited ELS command.\n **/\nstatic void\nlpfc_send_els_event(struct lpfc_vport *vport,\n\t\t    struct lpfc_nodelist *ndlp,\n\t\t    uint32_t *payload)\n{\n\tstruct lpfc_els_event_header *els_data = NULL;\n\tstruct lpfc_logo_event *logo_data = NULL;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\tif (*payload == ELS_CMD_LOGO) {\n\t\tlogo_data = kmalloc(sizeof(struct lpfc_logo_event), GFP_KERNEL);\n\t\tif (!logo_data) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"0148 Failed to allocate memory \"\n\t\t\t\t\"for LOGO event\\n\");\n\t\t\treturn;\n\t\t}\n\t\tels_data = &logo_data->header;\n\t} else {\n\t\tels_data = kmalloc(sizeof(struct lpfc_els_event_header),\n\t\t\tGFP_KERNEL);\n\t\tif (!els_data) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"0149 Failed to allocate memory \"\n\t\t\t\t\"for ELS event\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tels_data->event_type = FC_REG_ELS_EVENT;\n\tswitch (*payload) {\n\tcase ELS_CMD_PLOGI:\n\t\tels_data->subcategory = LPFC_EVENT_PLOGI_RCV;\n\t\tbreak;\n\tcase ELS_CMD_PRLO:\n\t\tels_data->subcategory = LPFC_EVENT_PRLO_RCV;\n\t\tbreak;\n\tcase ELS_CMD_ADISC:\n\t\tels_data->subcategory = LPFC_EVENT_ADISC_RCV;\n\t\tbreak;\n\tcase ELS_CMD_LOGO:\n\t\tels_data->subcategory = LPFC_EVENT_LOGO_RCV;\n\t\t/* Copy the WWPN in the LOGO payload */\n\t\tmemcpy(logo_data->logo_wwpn, &payload[2],\n\t\t\tsizeof(struct lpfc_name));\n\t\tbreak;\n\tdefault:\n\t\tkfree(els_data);\n\t\treturn;\n\t}\n\tmemcpy(els_data->wwpn, &ndlp->nlp_portname, sizeof(struct lpfc_name));\n\tmemcpy(els_data->wwnn, &ndlp->nlp_nodename, sizeof(struct lpfc_name));\n\tif (*payload == ELS_CMD_LOGO) {\n\t\tfc_host_post_vendor_event(shost,\n\t\t\tfc_get_event_number(),\n\t\t\tsizeof(struct lpfc_logo_event),\n\t\t\t(char *)logo_data,\n\t\t\tLPFC_NL_VENDOR_ID);\n\t\tkfree(logo_data);\n\t} else {\n\t\tfc_host_post_vendor_event(shost,\n\t\t\tfc_get_event_number(),\n\t\t\tsizeof(struct lpfc_els_event_header),\n\t\t\t(char *)els_data,\n\t\t\tLPFC_NL_VENDOR_ID);\n\t\tkfree(els_data);\n\t}\n\n\treturn;\n}\n\n\nDECLARE_ENUM2STR_LOOKUP(lpfc_get_tlv_dtag_nm, fc_ls_tlv_dtag,\n\t\t\tFC_LS_TLV_DTAG_INIT);\n\nDECLARE_ENUM2STR_LOOKUP(lpfc_get_fpin_li_event_nm, fc_fpin_li_event_types,\n\t\t\tFC_FPIN_LI_EVT_TYPES_INIT);\n\n/**\n * lpfc_els_rcv_fpin_li - Process an FPIN Link Integrity Event.\n * @vport: Pointer to vport object.\n * @tlv:  Pointer to the Link Integrity Notification Descriptor.\n *\n * This function processes a link integrity FPIN event by\n * logging a message\n **/\nstatic void\nlpfc_els_rcv_fpin_li(struct lpfc_vport *vport, struct fc_tlv_desc *tlv)\n{\n\tstruct fc_fn_li_desc *li = (struct fc_fn_li_desc *)tlv;\n\tconst char *li_evt_str;\n\tu32 li_evt;\n\n\tli_evt = be16_to_cpu(li->event_type);\n\tli_evt_str = lpfc_get_fpin_li_event_nm(li_evt);\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"4680 FPIN Link Integrity %s (x%x) \"\n\t\t\t \"Detecting PN x%016llx Attached PN x%016llx \"\n\t\t\t \"Duration %d mSecs Count %d Port Cnt %d\\n\",\n\t\t\t li_evt_str, li_evt,\n\t\t\t be64_to_cpu(li->detecting_wwpn),\n\t\t\t be64_to_cpu(li->attached_wwpn),\n\t\t\t be32_to_cpu(li->event_threshold),\n\t\t\t be32_to_cpu(li->event_count),\n\t\t\t be32_to_cpu(li->pname_count));\n}\n\nstatic void\nlpfc_els_rcv_fpin(struct lpfc_vport *vport, struct fc_els_fpin *fpin,\n\t\t  u32 fpin_length)\n{\n\tstruct fc_tlv_desc *tlv;\n\tconst char *dtag_nm;\n\tuint32_t desc_cnt = 0, bytes_remain;\n\tu32 dtag;\n\n\t/* FPINs handled only if we are in the right discovery state */\n\tif (vport->port_state < LPFC_DISC_AUTH)\n\t\treturn;\n\n\t/* make sure there is the full fpin header */\n\tif (fpin_length < sizeof(struct fc_els_fpin))\n\t\treturn;\n\n\ttlv = (struct fc_tlv_desc *)&fpin->fpin_desc[0];\n\tbytes_remain = fpin_length - offsetof(struct fc_els_fpin, fpin_desc);\n\tbytes_remain = min_t(u32, bytes_remain, be32_to_cpu(fpin->desc_len));\n\n\t/* process each descriptor */\n\twhile (bytes_remain >= FC_TLV_DESC_HDR_SZ &&\n\t       bytes_remain >= FC_TLV_DESC_SZ_FROM_LENGTH(tlv)) {\n\n\t\tdtag = be32_to_cpu(tlv->desc_tag);\n\t\tswitch (dtag) {\n\t\tcase ELS_DTAG_LNK_INTEGRITY:\n\t\t\tlpfc_els_rcv_fpin_li(vport, tlv);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdtag_nm = lpfc_get_tlv_dtag_nm(dtag);\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"4678  skipped FPIN descriptor[%d]: \"\n\t\t\t\t\t \"tag x%x (%s)\\n\",\n\t\t\t\t\t desc_cnt, dtag, dtag_nm);\n\t\t\tbreak;\n\t\t}\n\n\t\tdesc_cnt++;\n\t\tbytes_remain -= FC_TLV_DESC_SZ_FROM_LENGTH(tlv);\n\t\ttlv = fc_tlv_next_desc(tlv);\n\t}\n\n\tfc_host_fpin_rcv(lpfc_shost_from_vport(vport), fpin_length,\n\t\t\t (char *)fpin);\n}\n\n/**\n * lpfc_els_unsol_buffer - Process an unsolicited event data buffer\n * @phba: pointer to lpfc hba data structure.\n * @pring: pointer to a SLI ring.\n * @vport: pointer to a host virtual N_Port data structure.\n * @elsiocb: pointer to lpfc els command iocb data structure.\n *\n * This routine is used for processing the IOCB associated with a unsolicited\n * event. It first determines whether there is an existing ndlp that matches\n * the DID from the unsolicited IOCB. If not, it will create a new one with\n * the DID from the unsolicited IOCB. The ELS command from the unsolicited\n * IOCB is then used to invoke the proper routine and to set up proper state\n * of the discovery state machine.\n **/\nstatic void\nlpfc_els_unsol_buffer(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,\n\t\t      struct lpfc_vport *vport, struct lpfc_iocbq *elsiocb)\n{\n\tstruct lpfc_nodelist *ndlp;\n\tstruct ls_rjt stat;\n\tuint32_t *payload, payload_len;\n\tuint32_t cmd, did, newnode;\n\tuint8_t rjt_exp, rjt_err = 0, init_link = 0;\n\tIOCB_t *icmd = &elsiocb->iocb;\n\tLPFC_MBOXQ_t *mbox;\n\n\tif (!vport || !(elsiocb->context2))\n\t\tgoto dropit;\n\n\tnewnode = 0;\n\tpayload = ((struct lpfc_dmabuf *)elsiocb->context2)->virt;\n\tpayload_len = elsiocb->iocb.unsli3.rcvsli3.acc_len;\n\tcmd = *payload;\n\tif ((phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) == 0)\n\t\tlpfc_post_buffer(phba, pring, 1);\n\n\tdid = icmd->un.rcvels.remoteID;\n\tif (icmd->ulpStatus) {\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV Unsol ELS:  status:x%x/x%x did:x%x\",\n\t\t\ticmd->ulpStatus, icmd->un.ulpWord[4], did);\n\t\tgoto dropit;\n\t}\n\n\t/* Check to see if link went down during discovery */\n\tif (lpfc_els_chk_latt(vport))\n\t\tgoto dropit;\n\n\t/* Ignore traffic received during vport shutdown. */\n\tif (vport->load_flag & FC_UNLOADING)\n\t\tgoto dropit;\n\n\t/* If NPort discovery is delayed drop incoming ELS */\n\tif ((vport->fc_flag & FC_DISC_DELAYED) &&\n\t\t\t(cmd != ELS_CMD_PLOGI))\n\t\tgoto dropit;\n\n\tndlp = lpfc_findnode_did(vport, did);\n\tif (!ndlp) {\n\t\t/* Cannot find existing Fabric ndlp, so allocate a new one */\n\t\tndlp = lpfc_nlp_init(vport, did);\n\t\tif (!ndlp)\n\t\t\tgoto dropit;\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\t\tnewnode = 1;\n\t\tif ((did & Fabric_DID_MASK) == Fabric_DID_MASK)\n\t\t\tndlp->nlp_type |= NLP_FABRIC;\n\t} else if (ndlp->nlp_state == NLP_STE_UNUSED_NODE) {\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\t\tnewnode = 1;\n\t}\n\n\tphba->fc_stat.elsRcvFrame++;\n\n\t/*\n\t * Do not process any unsolicited ELS commands\n\t * if the ndlp is in DEV_LOSS\n\t */\n\tspin_lock_irq(&ndlp->lock);\n\tif (ndlp->nlp_flag & NLP_IN_DEV_LOSS) {\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tif (newnode)\n\t\t\tlpfc_nlp_put(ndlp);\n\t\tgoto dropit;\n\t}\n\tspin_unlock_irq(&ndlp->lock);\n\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto dropit;\n\telsiocb->vport = vport;\n\n\tif ((cmd & ELS_CMD_MASK) == ELS_CMD_RSCN) {\n\t\tcmd &= ELS_CMD_MASK;\n\t}\n\t/* ELS command <elsCmd> received from NPORT <did> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0112 ELS command x%x received from NPORT x%x \"\n\t\t\t \"refcnt %d Data: x%x x%x x%x x%x\\n\",\n\t\t\t cmd, did, kref_read(&ndlp->kref), vport->port_state,\n\t\t\t vport->fc_flag, vport->fc_myDID, vport->fc_prevDID);\n\n\t/* reject till our FLOGI completes or PLOGI assigned DID via PT2PT */\n\tif ((vport->port_state < LPFC_FABRIC_CFG_LINK) &&\n\t    (cmd != ELS_CMD_FLOGI) &&\n\t    !((cmd == ELS_CMD_PLOGI) && (vport->fc_flag & FC_PT2PT))) {\n\t\trjt_err = LSRJT_LOGICAL_BSY;\n\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\tgoto lsrjt;\n\t}\n\n\tswitch (cmd) {\n\tcase ELS_CMD_PLOGI:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV PLOGI:       did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvPLOGI++;\n\t\tndlp = lpfc_plogi_confirm_nport(phba, payload, ndlp);\n\t\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t\t    (phba->pport->fc_flag & FC_PT2PT)) {\n\t\t\tvport->fc_prevDID = vport->fc_myDID;\n\t\t\t/* Our DID needs to be updated before registering\n\t\t\t * the vfi. This is done in lpfc_rcv_plogi but\n\t\t\t * that is called after the reg_vfi.\n\t\t\t */\n\t\t\tvport->fc_myDID = elsiocb->iocb.un.rcvels.parmRo;\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t\t \"3312 Remote port assigned DID x%x \"\n\t\t\t\t\t \"%x\\n\", vport->fc_myDID,\n\t\t\t\t\t vport->fc_prevDID);\n\t\t}\n\n\t\tlpfc_send_els_event(vport, ndlp, payload);\n\n\t\t/* If Nport discovery is delayed, reject PLOGIs */\n\t\tif (vport->fc_flag & FC_DISC_DELAYED) {\n\t\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (vport->port_state < LPFC_DISC_AUTH) {\n\t\t\tif (!(phba->pport->fc_flag & FC_PT2PT) ||\n\t\t\t\t(phba->pport->fc_flag & FC_PT2PT_PLOGI)) {\n\t\t\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\t\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag &= ~NLP_TARGET_REMOVE;\n\t\tspin_unlock_irq(&ndlp->lock);\n\n\t\tlpfc_disc_state_machine(vport, ndlp, elsiocb,\n\t\t\t\t\tNLP_EVT_RCV_PLOGI);\n\n\t\tbreak;\n\tcase ELS_CMD_FLOGI:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV FLOGI:       did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvFLOGI++;\n\n\t\t/* If the driver believes fabric discovery is done and is ready,\n\t\t * bounce the link.  There is some descrepancy.\n\t\t */\n\t\tif (vport->port_state >= LPFC_LOCAL_CFG_LINK &&\n\t\t    vport->fc_flag & FC_PT2PT &&\n\t\t    vport->rcv_flogi_cnt >= 1) {\n\t\t\trjt_err = LSRJT_LOGICAL_BSY;\n\t\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\t\tinit_link++;\n\t\t\tgoto lsrjt;\n\t\t}\n\n\t\tlpfc_els_rcv_flogi(vport, elsiocb, ndlp);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_LOGO:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV LOGO:        did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvLOGO++;\n\t\tlpfc_send_els_event(vport, ndlp, payload);\n\t\tif (vport->port_state < LPFC_DISC_AUTH) {\n\t\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\t\tbreak;\n\t\t}\n\t\tlpfc_disc_state_machine(vport, ndlp, elsiocb, NLP_EVT_RCV_LOGO);\n\t\tbreak;\n\tcase ELS_CMD_PRLO:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV PRLO:        did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvPRLO++;\n\t\tlpfc_send_els_event(vport, ndlp, payload);\n\t\tif (vport->port_state < LPFC_DISC_AUTH) {\n\t\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\t\tbreak;\n\t\t}\n\t\tlpfc_disc_state_machine(vport, ndlp, elsiocb, NLP_EVT_RCV_PRLO);\n\t\tbreak;\n\tcase ELS_CMD_LCB:\n\t\tphba->fc_stat.elsRcvLCB++;\n\t\tlpfc_els_rcv_lcb(vport, elsiocb, ndlp);\n\t\tbreak;\n\tcase ELS_CMD_RDP:\n\t\tphba->fc_stat.elsRcvRDP++;\n\t\tlpfc_els_rcv_rdp(vport, elsiocb, ndlp);\n\t\tbreak;\n\tcase ELS_CMD_RSCN:\n\t\tphba->fc_stat.elsRcvRSCN++;\n\t\tlpfc_els_rcv_rscn(vport, elsiocb, ndlp);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_ADISC:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV ADISC:       did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tlpfc_send_els_event(vport, ndlp, payload);\n\t\tphba->fc_stat.elsRcvADISC++;\n\t\tif (vport->port_state < LPFC_DISC_AUTH) {\n\t\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\t\tbreak;\n\t\t}\n\t\tlpfc_disc_state_machine(vport, ndlp, elsiocb,\n\t\t\t\t\tNLP_EVT_RCV_ADISC);\n\t\tbreak;\n\tcase ELS_CMD_PDISC:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV PDISC:       did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvPDISC++;\n\t\tif (vport->port_state < LPFC_DISC_AUTH) {\n\t\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\t\tbreak;\n\t\t}\n\t\tlpfc_disc_state_machine(vport, ndlp, elsiocb,\n\t\t\t\t\tNLP_EVT_RCV_PDISC);\n\t\tbreak;\n\tcase ELS_CMD_FARPR:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV FARPR:       did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvFARPR++;\n\t\tlpfc_els_rcv_farpr(vport, elsiocb, ndlp);\n\t\tbreak;\n\tcase ELS_CMD_FARP:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV FARP:        did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvFARP++;\n\t\tlpfc_els_rcv_farp(vport, elsiocb, ndlp);\n\t\tbreak;\n\tcase ELS_CMD_FAN:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV FAN:         did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvFAN++;\n\t\tlpfc_els_rcv_fan(vport, elsiocb, ndlp);\n\t\tbreak;\n\tcase ELS_CMD_PRLI:\n\tcase ELS_CMD_NVMEPRLI:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV PRLI:        did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvPRLI++;\n\t\tif ((vport->port_state < LPFC_DISC_AUTH) &&\n\t\t    (vport->fc_flag & FC_FABRIC)) {\n\t\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\t\tbreak;\n\t\t}\n\t\tlpfc_disc_state_machine(vport, ndlp, elsiocb, NLP_EVT_RCV_PRLI);\n\t\tbreak;\n\tcase ELS_CMD_LIRR:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV LIRR:        did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvLIRR++;\n\t\tlpfc_els_rcv_lirr(vport, elsiocb, ndlp);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_RLS:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV RLS:         did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvRLS++;\n\t\tlpfc_els_rcv_rls(vport, elsiocb, ndlp);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_RPL:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV RPL:         did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvRPL++;\n\t\tlpfc_els_rcv_rpl(vport, elsiocb, ndlp);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_RNID:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV RNID:        did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvRNID++;\n\t\tlpfc_els_rcv_rnid(vport, elsiocb, ndlp);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_RTV:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV RTV:        did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\t\tphba->fc_stat.elsRcvRTV++;\n\t\tlpfc_els_rcv_rtv(vport, elsiocb, ndlp);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_RRQ:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV RRQ:         did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvRRQ++;\n\t\tlpfc_els_rcv_rrq(vport, elsiocb, ndlp);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_ECHO:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV ECHO:        did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvECHO++;\n\t\tlpfc_els_rcv_echo(vport, elsiocb, ndlp);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_REC:\n\t\t/* receive this due to exchange closed */\n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\trjt_exp = LSEXP_INVALID_OX_RX;\n\t\tbreak;\n\tcase ELS_CMD_FPIN:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\t      \"RCV FPIN:       did:x%x/ste:x%x flg:x%x\",\n\t\t\t\t      did, vport->port_state, ndlp->nlp_flag);\n\n\t\tlpfc_els_rcv_fpin(vport, (struct fc_els_fpin *)payload,\n\t\t\t\t  payload_len);\n\n\t\t/* There are no replies, so no rjt codes */\n\t\tbreak;\n\tdefault:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV ELS cmd:     cmd:x%x did:x%x/ste:x%x\",\n\t\t\tcmd, did, vport->port_state);\n\n\t\t/* Unsupported ELS command, reject */\n\t\trjt_err = LSRJT_CMD_UNSUPPORTED;\n\t\trjt_exp = LSEXP_NOTHING_MORE;\n\n\t\t/* Unknown ELS command <elsCmd> received from NPORT <did> */\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0115 Unknown ELS command x%x \"\n\t\t\t\t \"received from NPORT x%x\\n\", cmd, did);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\t}\n\nlsrjt:\n\t/* check if need to LS_RJT received ELS cmd */\n\tif (rjt_err) {\n\t\tmemset(&stat, 0, sizeof(stat));\n\t\tstat.un.b.lsRjtRsnCode = rjt_err;\n\t\tstat.un.b.lsRjtRsnCodeExp = rjt_exp;\n\t\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, elsiocb, ndlp,\n\t\t\t\t    NULL);\n\t\t/* Remove the reference from above for new nodes. */\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t}\n\n\t/* Release the reference on this elsiocb, not the ndlp. */\n\tlpfc_nlp_put(elsiocb->context1);\n\telsiocb->context1 = NULL;\n\n\t/* Special case.  Driver received an unsolicited command that\n\t * unsupportable given the driver's current state.  Reset the\n\t * link and start over.\n\t */\n\tif (init_link) {\n\t\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\t\tif (!mbox)\n\t\t\treturn;\n\t\tlpfc_linkdown(phba);\n\t\tlpfc_init_link(phba, mbox,\n\t\t\t       phba->cfg_topology,\n\t\t\t       phba->cfg_link_speed);\n\t\tmbox->u.mb.un.varInitLnk.lipsr_AL_PA = 0;\n\t\tmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t\tmbox->vport = vport;\n\t\tif (lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT) ==\n\t\t    MBX_NOT_FINISHED)\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t}\n\n\treturn;\n\ndropit:\n\tif (vport && !(vport->load_flag & FC_UNLOADING))\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"0111 Dropping received ELS cmd \"\n\t\t\t\"Data: x%x x%x x%x\\n\",\n\t\t\ticmd->ulpStatus, icmd->un.ulpWord[4], icmd->ulpTimeout);\n\tphba->fc_stat.elsRcvDrop++;\n}\n\n/**\n * lpfc_els_unsol_event - Process an unsolicited event from an els sli ring\n * @phba: pointer to lpfc hba data structure.\n * @pring: pointer to a SLI ring.\n * @elsiocb: pointer to lpfc els iocb data structure.\n *\n * This routine is used to process an unsolicited event received from a SLI\n * (Service Level Interface) ring. The actual processing of the data buffer\n * associated with the unsolicited event is done by invoking the routine\n * lpfc_els_unsol_buffer() after properly set up the iocb buffer from the\n * SLI ring on which the unsolicited event was received.\n **/\nvoid\nlpfc_els_unsol_event(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,\n\t\t     struct lpfc_iocbq *elsiocb)\n{\n\tstruct lpfc_vport *vport = phba->pport;\n\tIOCB_t *icmd = &elsiocb->iocb;\n\tdma_addr_t paddr;\n\tstruct lpfc_dmabuf *bdeBuf1 = elsiocb->context2;\n\tstruct lpfc_dmabuf *bdeBuf2 = elsiocb->context3;\n\n\telsiocb->context1 = NULL;\n\telsiocb->context2 = NULL;\n\telsiocb->context3 = NULL;\n\n\tif (icmd->ulpStatus == IOSTAT_NEED_BUFFER) {\n\t\tlpfc_sli_hbqbuf_add_hbqs(phba, LPFC_ELS_HBQ);\n\t} else if (icmd->ulpStatus == IOSTAT_LOCAL_REJECT &&\n\t\t   (icmd->un.ulpWord[4] & IOERR_PARAM_MASK) ==\n\t\t   IOERR_RCV_BUFFER_WAITING) {\n\t\tphba->fc_stat.NoRcvBuf++;\n\t\t/* Not enough posted buffers; Try posting more buffers */\n\t\tif (!(phba->sli3_options & LPFC_SLI3_HBQ_ENABLED))\n\t\t\tlpfc_post_buffer(phba, pring, 0);\n\t\treturn;\n\t}\n\n\tif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&\n\t    (icmd->ulpCommand == CMD_IOCB_RCV_ELS64_CX ||\n\t     icmd->ulpCommand == CMD_IOCB_RCV_SEQ64_CX)) {\n\t\tif (icmd->unsli3.rcvsli3.vpi == 0xffff)\n\t\t\tvport = phba->pport;\n\t\telse\n\t\t\tvport = lpfc_find_vport_by_vpid(phba,\n\t\t\t\t\t\ticmd->unsli3.rcvsli3.vpi);\n\t}\n\n\t/* If there are no BDEs associated\n\t * with this IOCB, there is nothing to do.\n\t */\n\tif (icmd->ulpBdeCount == 0)\n\t\treturn;\n\n\t/* type of ELS cmd is first 32bit word\n\t * in packet\n\t */\n\tif (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) {\n\t\telsiocb->context2 = bdeBuf1;\n\t} else {\n\t\tpaddr = getPaddr(icmd->un.cont64[0].addrHigh,\n\t\t\t\t icmd->un.cont64[0].addrLow);\n\t\telsiocb->context2 = lpfc_sli_ringpostbuf_get(phba, pring,\n\t\t\t\t\t\t\t     paddr);\n\t}\n\n\tlpfc_els_unsol_buffer(phba, pring, vport, elsiocb);\n\t/*\n\t * The different unsolicited event handlers would tell us\n\t * if they are done with \"mp\" by setting context2 to NULL.\n\t */\n\tif (elsiocb->context2) {\n\t\tlpfc_in_buf_free(phba, (struct lpfc_dmabuf *)elsiocb->context2);\n\t\telsiocb->context2 = NULL;\n\t}\n\n\t/* RCV_ELS64_CX provide for 2 BDEs - process 2nd if included */\n\tif ((phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) &&\n\t    icmd->ulpBdeCount == 2) {\n\t\telsiocb->context2 = bdeBuf2;\n\t\tlpfc_els_unsol_buffer(phba, pring, vport, elsiocb);\n\t\t/* free mp if we are done with it */\n\t\tif (elsiocb->context2) {\n\t\t\tlpfc_in_buf_free(phba, elsiocb->context2);\n\t\t\telsiocb->context2 = NULL;\n\t\t}\n\t}\n}\n\nstatic void\nlpfc_start_fdmi(struct lpfc_vport *vport)\n{\n\tstruct lpfc_nodelist *ndlp;\n\n\t/* If this is the first time, allocate an ndlp and initialize\n\t * it. Otherwise, make sure the node is enabled and then do the\n\t * login.\n\t */\n\tndlp = lpfc_findnode_did(vport, FDMI_DID);\n\tif (!ndlp) {\n\t\tndlp = lpfc_nlp_init(vport, FDMI_DID);\n\t\tif (ndlp) {\n\t\t\tndlp->nlp_type |= NLP_FABRIC;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\n\tlpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0);\n}\n\n/**\n * lpfc_do_scr_ns_plogi - Issue a plogi to the name server for scr\n * @phba: pointer to lpfc hba data structure.\n * @vport: pointer to a virtual N_Port data structure.\n *\n * This routine issues a Port Login (PLOGI) to the Name Server with\n * State Change Request (SCR) for a @vport. This routine will create an\n * ndlp for the Name Server associated to the @vport if such node does\n * not already exist. The PLOGI to Name Server is issued by invoking the\n * lpfc_issue_els_plogi() routine. If Fabric-Device Management Interface\n * (FDMI) is configured to the @vport, a FDMI node will be created and\n * the PLOGI to FDMI is issued by invoking lpfc_issue_els_plogi() routine.\n **/\nvoid\nlpfc_do_scr_ns_plogi(struct lpfc_hba *phba, struct lpfc_vport *vport)\n{\n\tstruct lpfc_nodelist *ndlp;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\t/*\n\t * If lpfc_delay_discovery parameter is set and the clean address\n\t * bit is cleared and fc fabric parameters chenged, delay FC NPort\n\t * discovery.\n\t */\n\tspin_lock_irq(shost->host_lock);\n\tif (vport->fc_flag & FC_DISC_DELAYED) {\n\t\tspin_unlock_irq(shost->host_lock);\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"3334 Delay fc port discovery for %d secs\\n\",\n\t\t\t\t phba->fc_ratov);\n\t\tmod_timer(&vport->delayed_disc_tmo,\n\t\t\tjiffies + msecs_to_jiffies(1000 * phba->fc_ratov));\n\t\treturn;\n\t}\n\tspin_unlock_irq(shost->host_lock);\n\n\tndlp = lpfc_findnode_did(vport, NameServer_DID);\n\tif (!ndlp) {\n\t\tndlp = lpfc_nlp_init(vport, NameServer_DID);\n\t\tif (!ndlp) {\n\t\t\tif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\t\t\tlpfc_disc_start(vport);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"0251 NameServer login: no memory\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tndlp->nlp_type |= NLP_FABRIC;\n\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\n\n\tif (lpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0)) {\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0252 Cannot issue NameServer login\\n\");\n\t\treturn;\n\t}\n\n\tif ((phba->cfg_enable_SmartSAN ||\n\t     (phba->cfg_fdmi_on == LPFC_FDMI_SUPPORT)) &&\n\t     (vport->load_flag & FC_ALLOW_FDMI))\n\t\tlpfc_start_fdmi(vport);\n}\n\n/**\n * lpfc_cmpl_reg_new_vport - Completion callback function to register new vport\n * @phba: pointer to lpfc hba data structure.\n * @pmb: pointer to the driver internal queue element for mailbox command.\n *\n * This routine is the completion callback function to register new vport\n * mailbox command. If the new vport mailbox command completes successfully,\n * the fabric registration login shall be performed on physical port (the\n * new vport created is actually a physical port, with VPI 0) or the port\n * login to Name Server for State Change Request (SCR) will be performed\n * on virtual port (real virtual port, with VPI greater than 0).\n **/\nstatic void\nlpfc_cmpl_reg_new_vport(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tstruct lpfc_vport *vport = pmb->vport;\n\tstruct Scsi_Host  *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *)pmb->ctx_ndlp;\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tint rc;\n\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag &= ~FC_VPORT_NEEDS_REG_VPI;\n\tspin_unlock_irq(shost->host_lock);\n\n\tif (mb->mbxStatus) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"0915 Register VPI failed : Status: x%x\"\n\t\t\t\t\" upd bit: x%x \\n\", mb->mbxStatus,\n\t\t\t\t mb->un.varRegVpi.upd);\n\t\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t\t\tmb->un.varRegVpi.upd)\n\t\t\tgoto mbox_err_exit ;\n\n\t\tswitch (mb->mbxStatus) {\n\t\tcase 0x11:\t/* unsupported feature */\n\t\tcase 0x9603:\t/* max_vpi exceeded */\n\t\tcase 0x9602:\t/* Link event since CLEAR_LA */\n\t\t\t/* giving up on vport registration */\n\t\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\tvport->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\tlpfc_can_disctmo(vport);\n\t\t\tbreak;\n\t\t/* If reg_vpi fail with invalid VPI status, re-init VPI */\n\t\tcase 0x20:\n\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\tvport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\tlpfc_init_vpi(phba, pmb, vport->vpi);\n\t\t\tpmb->vport = vport;\n\t\t\tpmb->mbox_cmpl = lpfc_init_vpi_cmpl;\n\t\t\trc = lpfc_sli_issue_mbox(phba, pmb,\n\t\t\t\tMBX_NOWAIT);\n\t\t\tif (rc == MBX_NOT_FINISHED) {\n\t\t\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t\t\"2732 Failed to issue INIT_VPI\"\n\t\t\t\t\t\" mailbox command\\n\");\n\t\t\t} else {\n\t\t\t\tlpfc_nlp_put(ndlp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\t/* Try to recover from this error */\n\t\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\t\tlpfc_sli4_unreg_all_rpis(vport);\n\t\t\tlpfc_mbx_unreg_vpi(vport);\n\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\tvport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\tif (mb->mbxStatus == MBX_NOT_FINISHED)\n\t\t\t\tbreak;\n\t\t\tif ((vport->port_type == LPFC_PHYSICAL_PORT) &&\n\t\t\t    !(vport->fc_flag & FC_LOGO_RCVD_DID_CHNG)) {\n\t\t\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\t\t\tlpfc_issue_init_vfi(vport);\n\t\t\t\telse\n\t\t\t\t\tlpfc_initial_flogi(vport);\n\t\t\t} else {\n\t\t\t\tlpfc_initial_fdisc(vport);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->vpi_state |= LPFC_VPI_REGISTERED;\n\t\tspin_unlock_irq(shost->host_lock);\n\t\tif (vport == phba->pport) {\n\t\t\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\t\t\tlpfc_issue_fabric_reglogin(vport);\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * If the physical port is instantiated using\n\t\t\t\t * FDISC, do not start vport discovery.\n\t\t\t\t */\n\t\t\t\tif (vport->port_state != LPFC_FDISC)\n\t\t\t\t\tlpfc_start_fdiscs(phba);\n\t\t\t\tlpfc_do_scr_ns_plogi(phba, vport);\n\t\t\t}\n\t\t} else {\n\t\t\tlpfc_do_scr_ns_plogi(phba, vport);\n\t\t}\n\t}\nmbox_err_exit:\n\t/* Now, we decrement the ndlp reference count held for this\n\t * callback function\n\t */\n\tlpfc_nlp_put(ndlp);\n\n\tmempool_free(pmb, phba->mbox_mem_pool);\n\treturn;\n}\n\n/**\n * lpfc_register_new_vport - Register a new vport with a HBA\n * @phba: pointer to lpfc hba data structure.\n * @vport: pointer to a host virtual N_Port data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine registers the @vport as a new virtual port with a HBA.\n * It is done through a registering vpi mailbox command.\n **/\nvoid\nlpfc_register_new_vport(struct lpfc_hba *phba, struct lpfc_vport *vport,\n\t\t\tstruct lpfc_nodelist *ndlp)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tLPFC_MBOXQ_t *mbox;\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (mbox) {\n\t\tlpfc_reg_vpi(vport, mbox);\n\t\tmbox->vport = vport;\n\t\tmbox->ctx_ndlp = lpfc_nlp_get(ndlp);\n\t\tif (!mbox->ctx_ndlp) {\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\t\tgoto mbox_err_exit;\n\t\t}\n\n\t\tmbox->mbox_cmpl = lpfc_cmpl_reg_new_vport;\n\t\tif (lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT)\n\t\t    == MBX_NOT_FINISHED) {\n\t\t\t/* mailbox command not success, decrement ndlp\n\t\t\t * reference count for this command\n\t\t\t */\n\t\t\tlpfc_nlp_put(ndlp);\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"0253 Register VPI: Can't send mbox\\n\");\n\t\t\tgoto mbox_err_exit;\n\t\t}\n\t} else {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0254 Register VPI: no memory\\n\");\n\t\tgoto mbox_err_exit;\n\t}\n\treturn;\n\nmbox_err_exit:\n\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag &= ~FC_VPORT_NEEDS_REG_VPI;\n\tspin_unlock_irq(shost->host_lock);\n\treturn;\n}\n\n/**\n * lpfc_cancel_all_vport_retry_delay_timer - Cancel all vport retry delay timer\n * @phba: pointer to lpfc hba data structure.\n *\n * This routine cancels the retry delay timers to all the vports.\n **/\nvoid\nlpfc_cancel_all_vport_retry_delay_timer(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport **vports;\n\tstruct lpfc_nodelist *ndlp;\n\tuint32_t link_state;\n\tint i;\n\n\t/* Treat this failure as linkdown for all vports */\n\tlink_state = phba->link_state;\n\tlpfc_linkdown(phba);\n\tphba->link_state = link_state;\n\n\tvports = lpfc_create_vport_work_array(phba);\n\n\tif (vports) {\n\t\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\n\t\t\tndlp = lpfc_findnode_did(vports[i], Fabric_DID);\n\t\t\tif (ndlp)\n\t\t\t\tlpfc_cancel_retry_delay_tmo(vports[i], ndlp);\n\t\t\tlpfc_els_flush_cmd(vports[i]);\n\t\t}\n\t\tlpfc_destroy_vport_work_array(phba, vports);\n\t}\n}\n\n/**\n * lpfc_retry_pport_discovery - Start timer to retry FLOGI.\n * @phba: pointer to lpfc hba data structure.\n *\n * This routine abort all pending discovery commands and\n * start a timer to retry FLOGI for the physical port\n * discovery.\n **/\nvoid\nlpfc_retry_pport_discovery(struct lpfc_hba *phba)\n{\n\tstruct lpfc_nodelist *ndlp;\n\n\t/* Cancel the all vports retry delay retry timers */\n\tlpfc_cancel_all_vport_retry_delay_timer(phba);\n\n\t/* If fabric require FLOGI, then re-instantiate physical login */\n\tndlp = lpfc_findnode_did(phba->pport, Fabric_DID);\n\tif (!ndlp)\n\t\treturn;\n\n\tmod_timer(&ndlp->nlp_delayfunc, jiffies + msecs_to_jiffies(1000));\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag |= NLP_DELAY_TMO;\n\tspin_unlock_irq(&ndlp->lock);\n\tndlp->nlp_last_elscmd = ELS_CMD_FLOGI;\n\tphba->pport->port_state = LPFC_FLOGI;\n\treturn;\n}\n\n/**\n * lpfc_fabric_login_reqd - Check if FLOGI required.\n * @phba: pointer to lpfc hba data structure.\n * @cmdiocb: pointer to FDISC command iocb.\n * @rspiocb: pointer to FDISC response iocb.\n *\n * This routine checks if a FLOGI is reguired for FDISC\n * to succeed.\n **/\nstatic int\nlpfc_fabric_login_reqd(struct lpfc_hba *phba,\n\t\tstruct lpfc_iocbq *cmdiocb,\n\t\tstruct lpfc_iocbq *rspiocb)\n{\n\n\tif ((rspiocb->iocb.ulpStatus != IOSTAT_FABRIC_RJT) ||\n\t\t(rspiocb->iocb.un.ulpWord[4] != RJT_LOGIN_REQUIRED))\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\n/**\n * lpfc_cmpl_els_fdisc - Completion function for fdisc iocb command\n * @phba: pointer to lpfc hba data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @rspiocb: pointer to lpfc response iocb data structure.\n *\n * This routine is the completion callback function to a Fabric Discover\n * (FDISC) ELS command. Since all the FDISC ELS commands are issued\n * single threaded, each FDISC completion callback function will reset\n * the discovery timer for all vports such that the timers will not get\n * unnecessary timeout. The function checks the FDISC IOCB status. If error\n * detected, the vport will be set to FC_VPORT_FAILED state. Otherwise,the\n * vport will set to FC_VPORT_ACTIVE state. It then checks whether the DID\n * assigned to the vport has been changed with the completion of the FDISC\n * command. If so, both RPI (Remote Port Index) and VPI (Virtual Port Index)\n * are unregistered from the HBA, and then the lpfc_register_new_vport()\n * routine is invoked to register new vport with the HBA. Otherwise, the\n * lpfc_do_scr_ns_plogi() routine is invoked to issue a PLOGI to the Name\n * Server for State Change Request (SCR).\n **/\nstatic void\nlpfc_cmpl_els_fdisc(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t    struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct Scsi_Host  *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) cmdiocb->context1;\n\tstruct lpfc_nodelist *np;\n\tstruct lpfc_nodelist *next_np;\n\tIOCB_t *irsp = &rspiocb->iocb;\n\tstruct lpfc_iocbq *piocb;\n\tstruct lpfc_dmabuf *pcmd = cmdiocb->context2, *prsp;\n\tstruct serv_parm *sp;\n\tuint8_t fabric_param_changed;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0123 FDISC completes. x%x/x%x prevDID: x%x\\n\",\n\t\t\t irsp->ulpStatus, irsp->un.ulpWord[4],\n\t\t\t vport->fc_prevDID);\n\t/* Since all FDISCs are being single threaded, we\n\t * must reset the discovery timer for ALL vports\n\t * waiting to send FDISC when one completes.\n\t */\n\tlist_for_each_entry(piocb, &phba->fabric_iocb_list, list) {\n\t\tlpfc_set_disctmo(piocb->vport);\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"FDISC cmpl:      status:x%x/x%x prevdid:x%x\",\n\t\tirsp->ulpStatus, irsp->un.ulpWord[4], vport->fc_prevDID);\n\n\tif (irsp->ulpStatus) {\n\n\t\tif (lpfc_fabric_login_reqd(phba, cmdiocb, rspiocb)) {\n\t\t\tlpfc_retry_pport_discovery(phba);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Check for retry */\n\t\tif (lpfc_els_retry(phba, cmdiocb, rspiocb))\n\t\t\tgoto out;\n\t\t/* FDISC failed */\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0126 FDISC failed. (x%x/x%x)\\n\",\n\t\t\t\t irsp->ulpStatus, irsp->un.ulpWord[4]);\n\t\tgoto fdisc_failed;\n\t}\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag &= ~FC_VPORT_CVL_RCVD;\n\tvport->fc_flag &= ~FC_VPORT_LOGO_RCVD;\n\tvport->fc_flag |= FC_FABRIC;\n\tif (vport->phba->fc_topology == LPFC_TOPOLOGY_LOOP)\n\t\tvport->fc_flag |=  FC_PUBLIC_LOOP;\n\tspin_unlock_irq(shost->host_lock);\n\n\tvport->fc_myDID = irsp->un.ulpWord[4] & Mask_DID;\n\tlpfc_vport_set_state(vport, FC_VPORT_ACTIVE);\n\tprsp = list_get_first(&pcmd->list, struct lpfc_dmabuf, list);\n\tif (!prsp)\n\t\tgoto out;\n\tsp = prsp->virt + sizeof(uint32_t);\n\tfabric_param_changed = lpfc_check_clean_addr_bit(vport, sp);\n\tmemcpy(&vport->fabric_portname, &sp->portName,\n\t\tsizeof(struct lpfc_name));\n\tmemcpy(&vport->fabric_nodename, &sp->nodeName,\n\t\tsizeof(struct lpfc_name));\n\tif (fabric_param_changed &&\n\t\t!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)) {\n\t\t/* If our NportID changed, we need to ensure all\n\t\t * remaining NPORTs get unreg_login'ed so we can\n\t\t * issue unreg_vpi.\n\t\t */\n\t\tlist_for_each_entry_safe(np, next_np,\n\t\t\t&vport->fc_nodes, nlp_listp) {\n\t\t\tif ((np->nlp_state != NLP_STE_NPR_NODE) ||\n\t\t\t    !(np->nlp_flag & NLP_NPR_ADISC))\n\t\t\t\tcontinue;\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tnp->nlp_flag &= ~NLP_NPR_ADISC;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\tlpfc_unreg_rpi(vport, np);\n\t\t}\n\t\tlpfc_cleanup_pending_mbox(vport);\n\n\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tlpfc_sli4_unreg_all_rpis(vport);\n\n\t\tlpfc_mbx_unreg_vpi(vport);\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\n\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tvport->fc_flag |= FC_VPORT_NEEDS_INIT_VPI;\n\t\telse\n\t\t\tvport->fc_flag |= FC_LOGO_RCVD_DID_CHNG;\n\t\tspin_unlock_irq(shost->host_lock);\n\t} else if ((phba->sli_rev == LPFC_SLI_REV4) &&\n\t\t!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)) {\n\t\t/*\n\t\t * Driver needs to re-reg VPI in order for f/w\n\t\t * to update the MAC address.\n\t\t */\n\t\tlpfc_register_new_vport(phba, vport, ndlp);\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\n\t\tgoto out;\n\t}\n\n\tif (vport->fc_flag & FC_VPORT_NEEDS_INIT_VPI)\n\t\tlpfc_issue_init_vpi(vport);\n\telse if (vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)\n\t\tlpfc_register_new_vport(phba, vport, ndlp);\n\telse\n\t\tlpfc_do_scr_ns_plogi(phba, vport);\n\n\t/* The FDISC completed successfully. Move the fabric ndlp to\n\t * UNMAPPED state and register with the transport.\n\t */\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\n\tgoto out;\n\nfdisc_failed:\n\tif (vport->fc_vport &&\n\t    (vport->fc_vport->vport_state != FC_VPORT_NO_FABRIC_RSCS))\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t/* Cancel discovery timer */\n\tlpfc_can_disctmo(vport);\nout:\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n}\n\n/**\n * lpfc_issue_els_fdisc - Issue a fdisc iocb command\n * @vport: pointer to a virtual N_Port data structure.\n * @ndlp: pointer to a node-list data structure.\n * @retry: number of retries to the command IOCB.\n *\n * This routine prepares and issues a Fabric Discover (FDISC) IOCB to\n * a remote node (@ndlp) off a @vport. It uses the lpfc_issue_fabric_iocb()\n * routine to issue the IOCB, which makes sure only one outstanding fabric\n * IOCB will be sent off HBA at any given time.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the FDISC ELS command.\n *\n * Return code\n *   0 - Successfully issued fdisc iocb command\n *   1 - Failed to issue fdisc iocb command\n **/\nstatic int\nlpfc_issue_els_fdisc(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t     uint8_t retry)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tIOCB_t *icmd;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct serv_parm *sp;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tint did = ndlp->nlp_DID;\n\tint rc;\n\n\tvport->port_state = LPFC_FDISC;\n\tvport->fc_myDID = 0;\n\tcmdsize = (sizeof(uint32_t) + sizeof(struct serv_parm));\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp, did,\n\t\t\t\t     ELS_CMD_FDISC);\n\tif (!elsiocb) {\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0255 Issue FDISC: no IOCB\\n\");\n\t\treturn 1;\n\t}\n\n\ticmd = &elsiocb->iocb;\n\ticmd->un.elsreq64.myID = 0;\n\ticmd->un.elsreq64.fl = 1;\n\n\t/*\n\t * SLI3 ports require a different context type value than SLI4.\n\t * Catch SLI3 ports here and override the prep.\n\t */\n\tif (phba->sli_rev == LPFC_SLI_REV3) {\n\t\ticmd->ulpCt_h = 1;\n\t\ticmd->ulpCt_l = 0;\n\t}\n\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\t*((uint32_t *) (pcmd)) = ELS_CMD_FDISC;\n\tpcmd += sizeof(uint32_t); /* CSP Word 1 */\n\tmemcpy(pcmd, &vport->phba->pport->fc_sparam, sizeof(struct serv_parm));\n\tsp = (struct serv_parm *) pcmd;\n\t/* Setup CSPs accordingly for Fabric */\n\tsp->cmn.e_d_tov = 0;\n\tsp->cmn.w2.r_a_tov = 0;\n\tsp->cmn.virtual_fabric_support = 0;\n\tsp->cls1.classValid = 0;\n\tsp->cls2.seqDelivery = 1;\n\tsp->cls3.seqDelivery = 1;\n\n\tpcmd += sizeof(uint32_t); /* CSP Word 2 */\n\tpcmd += sizeof(uint32_t); /* CSP Word 3 */\n\tpcmd += sizeof(uint32_t); /* CSP Word 4 */\n\tpcmd += sizeof(uint32_t); /* Port Name */\n\tmemcpy(pcmd, &vport->fc_portname, 8);\n\tpcmd += sizeof(uint32_t); /* Node Name */\n\tpcmd += sizeof(uint32_t); /* Node Name */\n\tmemcpy(pcmd, &vport->fc_nodename, 8);\n\tsp->cmn.valid_vendor_ver_level = 0;\n\tmemset(sp->un.vendorVersion, 0, sizeof(sp->un.vendorVersion));\n\tlpfc_set_disctmo(vport);\n\n\tphba->fc_stat.elsXmitFDISC++;\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_fdisc;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Issue FDISC:     did:x%x\",\n\t\tdid, 0, 0);\n\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto err_out;\n\n\trc = lpfc_issue_fabric_iocb(phba, elsiocb);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_nlp_put(ndlp);\n\t\tgoto err_out;\n\t}\n\n\tlpfc_vport_set_state(vport, FC_VPORT_INITIALIZING);\n\treturn 0;\n\n err_out:\n\tlpfc_els_free_iocb(phba, elsiocb);\n\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0256 Issue FDISC: Cannot send IOCB\\n\");\n\treturn 1;\n}\n\n/**\n * lpfc_cmpl_els_npiv_logo - Completion function with vport logo\n * @phba: pointer to lpfc hba data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @rspiocb: pointer to lpfc response iocb data structure.\n *\n * This routine is the completion callback function to the issuing of a LOGO\n * ELS command off a vport. It frees the command IOCB and then decrement the\n * reference count held on ndlp for this completion function, indicating that\n * the reference to the ndlp is no long needed. Note that the\n * lpfc_els_free_iocb() routine decrements the ndlp reference held for this\n * callback function and an additional explicit ndlp reference decrementation\n * will trigger the actual release of the ndlp.\n **/\nstatic void\nlpfc_cmpl_els_npiv_logo(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t\tstruct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tIOCB_t *irsp;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\tndlp = (struct lpfc_nodelist *)cmdiocb->context1;\n\tirsp = &rspiocb->iocb;\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"LOGO npiv cmpl:  status:x%x/x%x did:x%x\",\n\t\tirsp->ulpStatus, irsp->un.ulpWord[4], irsp->un.rcvels.remoteID);\n\n\t/* NPIV LOGO completes to NPort <nlp_DID> */\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"2928 NPIV LOGO completes to NPort x%x \"\n\t\t\t \"Data: x%x x%x x%x x%x x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, irsp->ulpStatus, irsp->un.ulpWord[4],\n\t\t\t irsp->ulpTimeout, vport->num_disc_nodes,\n\t\t\t kref_read(&ndlp->kref), ndlp->nlp_flag,\n\t\t\t ndlp->fc4_xpt_flags);\n\n\tif (irsp->ulpStatus == IOSTAT_SUCCESS) {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag &= ~FC_NDISC_ACTIVE;\n\t\tvport->fc_flag &= ~FC_FABRIC;\n\t\tspin_unlock_irq(shost->host_lock);\n\t\tlpfc_can_disctmo(vport);\n\t}\n\n\t/* Safe to release resources now. */\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n\tvport->unreg_vpi_cmpl = VPORT_ERROR;\n}\n\n/**\n * lpfc_issue_els_npiv_logo - Issue a logo off a vport\n * @vport: pointer to a virtual N_Port data structure.\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine issues a LOGO ELS command to an @ndlp off a @vport.\n *\n * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp\n * will be incremented by 1 for holding the ndlp and the reference to ndlp\n * will be stored into the context1 field of the IOCB for the completion\n * callback function to the LOGO ELS command.\n *\n * Return codes\n *   0 - Successfully issued logo off the @vport\n *   1 - Failed to issue logo off the @vport\n **/\nint\nlpfc_issue_els_npiv_logo(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\n{\n\tint rc = 0;\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\n\tcmdsize = 2 * sizeof(uint32_t) + sizeof(struct lpfc_name);\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, 0, ndlp, ndlp->nlp_DID,\n\t\t\t\t     ELS_CMD_LOGO);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tpcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);\n\t*((uint32_t *) (pcmd)) = ELS_CMD_LOGO;\n\tpcmd += sizeof(uint32_t);\n\n\t/* Fill in LOGO payload */\n\t*((uint32_t *) (pcmd)) = be32_to_cpu(vport->fc_myDID);\n\tpcmd += sizeof(uint32_t);\n\tmemcpy(pcmd, &vport->fc_portname, sizeof(struct lpfc_name));\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Issue LOGO npiv  did:x%x flg:x%x\",\n\t\tndlp->nlp_DID, ndlp->nlp_flag, 0);\n\n\telsiocb->iocb_cmpl = lpfc_cmpl_els_npiv_logo;\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag |= NLP_LOGO_SND;\n\tspin_unlock_irq(&ndlp->lock);\n\telsiocb->context1 = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->context1)\n\t\tgoto node_err;\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR)\n\t\tgoto io_err;\n\treturn 0;\n\n io_err:\n\tlpfc_nlp_put(ndlp);\n node_err:\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~NLP_LOGO_SND;\n\tspin_unlock_irq(&ndlp->lock);\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn 1;\n}\n\n/**\n * lpfc_fabric_block_timeout - Handler function to the fabric block timer\n * @t: timer context used to obtain the lpfc hba.\n *\n * This routine is invoked by the fabric iocb block timer after\n * timeout. It posts the fabric iocb block timeout event by setting the\n * WORKER_FABRIC_BLOCK_TMO bit to work port event bitmap and then invokes\n * lpfc_worker_wake_up() routine to wake up the worker thread. It is for\n * the worker thread to invoke the lpfc_unblock_fabric_iocbs() on the\n * posted event WORKER_FABRIC_BLOCK_TMO.\n **/\nvoid\nlpfc_fabric_block_timeout(struct timer_list *t)\n{\n\tstruct lpfc_hba  *phba = from_timer(phba, t, fabric_block_timer);\n\tunsigned long iflags;\n\tuint32_t tmo_posted;\n\n\tspin_lock_irqsave(&phba->pport->work_port_lock, iflags);\n\ttmo_posted = phba->pport->work_port_events & WORKER_FABRIC_BLOCK_TMO;\n\tif (!tmo_posted)\n\t\tphba->pport->work_port_events |= WORKER_FABRIC_BLOCK_TMO;\n\tspin_unlock_irqrestore(&phba->pport->work_port_lock, iflags);\n\n\tif (!tmo_posted)\n\t\tlpfc_worker_wake_up(phba);\n\treturn;\n}\n\n/**\n * lpfc_resume_fabric_iocbs - Issue a fabric iocb from driver internal list\n * @phba: pointer to lpfc hba data structure.\n *\n * This routine issues one fabric iocb from the driver internal list to\n * the HBA. It first checks whether it's ready to issue one fabric iocb to\n * the HBA (whether there is no outstanding fabric iocb). If so, it shall\n * remove one pending fabric iocb from the driver internal list and invokes\n * lpfc_sli_issue_iocb() routine to send the fabric iocb to the HBA.\n **/\nstatic void\nlpfc_resume_fabric_iocbs(struct lpfc_hba *phba)\n{\n\tstruct lpfc_iocbq *iocb;\n\tunsigned long iflags;\n\tint ret;\n\tIOCB_t *cmd;\n\nrepeat:\n\tiocb = NULL;\n\tspin_lock_irqsave(&phba->hbalock, iflags);\n\t/* Post any pending iocb to the SLI layer */\n\tif (atomic_read(&phba->fabric_iocb_count) == 0) {\n\t\tlist_remove_head(&phba->fabric_iocb_list, iocb, typeof(*iocb),\n\t\t\t\t list);\n\t\tif (iocb)\n\t\t\t/* Increment fabric iocb count to hold the position */\n\t\t\tatomic_inc(&phba->fabric_iocb_count);\n\t}\n\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\tif (iocb) {\n\t\tiocb->fabric_iocb_cmpl = iocb->iocb_cmpl;\n\t\tiocb->iocb_cmpl = lpfc_cmpl_fabric_iocb;\n\t\tiocb->iocb_flag |= LPFC_IO_FABRIC;\n\n\t\tlpfc_debugfs_disc_trc(iocb->vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t\"Fabric sched1:   ste:x%x\",\n\t\t\tiocb->vport->port_state, 0, 0);\n\n\t\tret = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, iocb, 0);\n\n\t\tif (ret == IOCB_ERROR) {\n\t\t\tiocb->iocb_cmpl = iocb->fabric_iocb_cmpl;\n\t\t\tiocb->fabric_iocb_cmpl = NULL;\n\t\t\tiocb->iocb_flag &= ~LPFC_IO_FABRIC;\n\t\t\tcmd = &iocb->iocb;\n\t\t\tcmd->ulpStatus = IOSTAT_LOCAL_REJECT;\n\t\t\tcmd->un.ulpWord[4] = IOERR_SLI_ABORTED;\n\t\t\tiocb->iocb_cmpl(phba, iocb, iocb);\n\n\t\t\tatomic_dec(&phba->fabric_iocb_count);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n}\n\n/**\n * lpfc_unblock_fabric_iocbs - Unblock issuing fabric iocb command\n * @phba: pointer to lpfc hba data structure.\n *\n * This routine unblocks the  issuing fabric iocb command. The function\n * will clear the fabric iocb block bit and then invoke the routine\n * lpfc_resume_fabric_iocbs() to issue one of the pending fabric iocb\n * from the driver internal fabric iocb list.\n **/\nvoid\nlpfc_unblock_fabric_iocbs(struct lpfc_hba *phba)\n{\n\tclear_bit(FABRIC_COMANDS_BLOCKED, &phba->bit_flags);\n\n\tlpfc_resume_fabric_iocbs(phba);\n\treturn;\n}\n\n/**\n * lpfc_block_fabric_iocbs - Block issuing fabric iocb command\n * @phba: pointer to lpfc hba data structure.\n *\n * This routine blocks the issuing fabric iocb for a specified amount of\n * time (currently 100 ms). This is done by set the fabric iocb block bit\n * and set up a timeout timer for 100ms. When the block bit is set, no more\n * fabric iocb will be issued out of the HBA.\n **/\nstatic void\nlpfc_block_fabric_iocbs(struct lpfc_hba *phba)\n{\n\tint blocked;\n\n\tblocked = test_and_set_bit(FABRIC_COMANDS_BLOCKED, &phba->bit_flags);\n\t/* Start a timer to unblock fabric iocbs after 100ms */\n\tif (!blocked)\n\t\tmod_timer(&phba->fabric_block_timer,\n\t\t\t  jiffies + msecs_to_jiffies(100));\n\n\treturn;\n}\n\n/**\n * lpfc_cmpl_fabric_iocb - Completion callback function for fabric iocb\n * @phba: pointer to lpfc hba data structure.\n * @cmdiocb: pointer to lpfc command iocb data structure.\n * @rspiocb: pointer to lpfc response iocb data structure.\n *\n * This routine is the callback function that is put to the fabric iocb's\n * callback function pointer (iocb->iocb_cmpl). The original iocb's callback\n * function pointer has been stored in iocb->fabric_iocb_cmpl. This callback\n * function first restores and invokes the original iocb's callback function\n * and then invokes the lpfc_resume_fabric_iocbs() routine to issue the next\n * fabric bound iocb from the driver internal fabric iocb list onto the wire.\n **/\nstatic void\nlpfc_cmpl_fabric_iocb(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\tstruct lpfc_iocbq *rspiocb)\n{\n\tstruct ls_rjt stat;\n\n\tBUG_ON((cmdiocb->iocb_flag & LPFC_IO_FABRIC) != LPFC_IO_FABRIC);\n\n\tswitch (rspiocb->iocb.ulpStatus) {\n\t\tcase IOSTAT_NPORT_RJT:\n\t\tcase IOSTAT_FABRIC_RJT:\n\t\t\tif (rspiocb->iocb.un.ulpWord[4] & RJT_UNAVAIL_TEMP) {\n\t\t\t\tlpfc_block_fabric_iocbs(phba);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IOSTAT_NPORT_BSY:\n\t\tcase IOSTAT_FABRIC_BSY:\n\t\t\tlpfc_block_fabric_iocbs(phba);\n\t\t\tbreak;\n\n\t\tcase IOSTAT_LS_RJT:\n\t\t\tstat.un.lsRjtError =\n\t\t\t\tbe32_to_cpu(rspiocb->iocb.un.ulpWord[4]);\n\t\t\tif ((stat.un.b.lsRjtRsnCode == LSRJT_UNABLE_TPC) ||\n\t\t\t\t(stat.un.b.lsRjtRsnCode == LSRJT_LOGICAL_BSY))\n\t\t\t\tlpfc_block_fabric_iocbs(phba);\n\t\t\tbreak;\n\t}\n\n\tBUG_ON(atomic_read(&phba->fabric_iocb_count) == 0);\n\n\tcmdiocb->iocb_cmpl = cmdiocb->fabric_iocb_cmpl;\n\tcmdiocb->fabric_iocb_cmpl = NULL;\n\tcmdiocb->iocb_flag &= ~LPFC_IO_FABRIC;\n\tcmdiocb->iocb_cmpl(phba, cmdiocb, rspiocb);\n\n\tatomic_dec(&phba->fabric_iocb_count);\n\tif (!test_bit(FABRIC_COMANDS_BLOCKED, &phba->bit_flags)) {\n\t\t/* Post any pending iocbs to HBA */\n\t\tlpfc_resume_fabric_iocbs(phba);\n\t}\n}\n\n/**\n * lpfc_issue_fabric_iocb - Issue a fabric iocb command\n * @phba: pointer to lpfc hba data structure.\n * @iocb: pointer to lpfc command iocb data structure.\n *\n * This routine is used as the top-level API for issuing a fabric iocb command\n * such as FLOGI and FDISC. To accommodate certain switch fabric, this driver\n * function makes sure that only one fabric bound iocb will be outstanding at\n * any given time. As such, this function will first check to see whether there\n * is already an outstanding fabric iocb on the wire. If so, it will put the\n * newly issued iocb onto the driver internal fabric iocb list, waiting to be\n * issued later. Otherwise, it will issue the iocb on the wire and update the\n * fabric iocb count it indicate that there is one fabric iocb on the wire.\n *\n * Note, this implementation has a potential sending out fabric IOCBs out of\n * order. The problem is caused by the construction of the \"ready\" boolen does\n * not include the condition that the internal fabric IOCB list is empty. As\n * such, it is possible a fabric IOCB issued by this routine might be \"jump\"\n * ahead of the fabric IOCBs in the internal list.\n *\n * Return code\n *   IOCB_SUCCESS - either fabric iocb put on the list or issued successfully\n *   IOCB_ERROR - failed to issue fabric iocb\n **/\nstatic int\nlpfc_issue_fabric_iocb(struct lpfc_hba *phba, struct lpfc_iocbq *iocb)\n{\n\tunsigned long iflags;\n\tint ready;\n\tint ret;\n\n\tBUG_ON(atomic_read(&phba->fabric_iocb_count) > 1);\n\n\tspin_lock_irqsave(&phba->hbalock, iflags);\n\tready = atomic_read(&phba->fabric_iocb_count) == 0 &&\n\t\t!test_bit(FABRIC_COMANDS_BLOCKED, &phba->bit_flags);\n\n\tif (ready)\n\t\t/* Increment fabric iocb count to hold the position */\n\t\tatomic_inc(&phba->fabric_iocb_count);\n\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\tif (ready) {\n\t\tiocb->fabric_iocb_cmpl = iocb->iocb_cmpl;\n\t\tiocb->iocb_cmpl = lpfc_cmpl_fabric_iocb;\n\t\tiocb->iocb_flag |= LPFC_IO_FABRIC;\n\n\t\tlpfc_debugfs_disc_trc(iocb->vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t\"Fabric sched2:   ste:x%x\",\n\t\t\tiocb->vport->port_state, 0, 0);\n\n\t\tret = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, iocb, 0);\n\n\t\tif (ret == IOCB_ERROR) {\n\t\t\tiocb->iocb_cmpl = iocb->fabric_iocb_cmpl;\n\t\t\tiocb->fabric_iocb_cmpl = NULL;\n\t\t\tiocb->iocb_flag &= ~LPFC_IO_FABRIC;\n\t\t\tatomic_dec(&phba->fabric_iocb_count);\n\t\t}\n\t} else {\n\t\tspin_lock_irqsave(&phba->hbalock, iflags);\n\t\tlist_add_tail(&iocb->list, &phba->fabric_iocb_list);\n\t\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\t\tret = IOCB_SUCCESS;\n\t}\n\treturn ret;\n}\n\n/**\n * lpfc_fabric_abort_vport - Abort a vport's iocbs from driver fabric iocb list\n * @vport: pointer to a virtual N_Port data structure.\n *\n * This routine aborts all the IOCBs associated with a @vport from the\n * driver internal fabric IOCB list. The list contains fabric IOCBs to be\n * issued to the ELS IOCB ring. This abort function walks the fabric IOCB\n * list, removes each IOCB associated with the @vport off the list, set the\n * status feild to IOSTAT_LOCAL_REJECT, and invokes the callback function\n * associated with the IOCB.\n **/\nstatic void lpfc_fabric_abort_vport(struct lpfc_vport *vport)\n{\n\tLIST_HEAD(completions);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_iocbq *tmp_iocb, *piocb;\n\n\tspin_lock_irq(&phba->hbalock);\n\tlist_for_each_entry_safe(piocb, tmp_iocb, &phba->fabric_iocb_list,\n\t\t\t\t list) {\n\n\t\tif (piocb->vport != vport)\n\t\t\tcontinue;\n\n\t\tlist_move_tail(&piocb->list, &completions);\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\n\t/* Cancel all the IOCBs from the completions list */\n\tlpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,\n\t\t\t      IOERR_SLI_ABORTED);\n}\n\n/**\n * lpfc_fabric_abort_nport - Abort a ndlp's iocbs from driver fabric iocb list\n * @ndlp: pointer to a node-list data structure.\n *\n * This routine aborts all the IOCBs associated with an @ndlp from the\n * driver internal fabric IOCB list. The list contains fabric IOCBs to be\n * issued to the ELS IOCB ring. This abort function walks the fabric IOCB\n * list, removes each IOCB associated with the @ndlp off the list, set the\n * status feild to IOSTAT_LOCAL_REJECT, and invokes the callback function\n * associated with the IOCB.\n **/\nvoid lpfc_fabric_abort_nport(struct lpfc_nodelist *ndlp)\n{\n\tLIST_HEAD(completions);\n\tstruct lpfc_hba  *phba = ndlp->phba;\n\tstruct lpfc_iocbq *tmp_iocb, *piocb;\n\tstruct lpfc_sli_ring *pring;\n\n\tpring = lpfc_phba_elsring(phba);\n\n\tif (unlikely(!pring))\n\t\treturn;\n\n\tspin_lock_irq(&phba->hbalock);\n\tlist_for_each_entry_safe(piocb, tmp_iocb, &phba->fabric_iocb_list,\n\t\t\t\t list) {\n\t\tif ((lpfc_check_sli_ndlp(phba, pring, piocb, ndlp))) {\n\n\t\t\tlist_move_tail(&piocb->list, &completions);\n\t\t}\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\n\t/* Cancel all the IOCBs from the completions list */\n\tlpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,\n\t\t\t      IOERR_SLI_ABORTED);\n}\n\n/**\n * lpfc_fabric_abort_hba - Abort all iocbs on driver fabric iocb list\n * @phba: pointer to lpfc hba data structure.\n *\n * This routine aborts all the IOCBs currently on the driver internal\n * fabric IOCB list. The list contains fabric IOCBs to be issued to the ELS\n * IOCB ring. This function takes the entire IOCB list off the fabric IOCB\n * list, removes IOCBs off the list, set the status feild to\n * IOSTAT_LOCAL_REJECT, and invokes the callback function associated with\n * the IOCB.\n **/\nvoid lpfc_fabric_abort_hba(struct lpfc_hba *phba)\n{\n\tLIST_HEAD(completions);\n\n\tspin_lock_irq(&phba->hbalock);\n\tlist_splice_init(&phba->fabric_iocb_list, &completions);\n\tspin_unlock_irq(&phba->hbalock);\n\n\t/* Cancel all the IOCBs from the completions list */\n\tlpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,\n\t\t\t      IOERR_SLI_ABORTED);\n}\n\n/**\n * lpfc_sli4_vport_delete_els_xri_aborted -Remove all ndlp references for vport\n * @vport: pointer to lpfc vport data structure.\n *\n * This routine is invoked by the vport cleanup for deletions and the cleanup\n * for an ndlp on removal.\n **/\nvoid\nlpfc_sli4_vport_delete_els_xri_aborted(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_sglq *sglq_entry = NULL, *sglq_next = NULL;\n\tunsigned long iflag = 0;\n\n\tspin_lock_irqsave(&phba->hbalock, iflag);\n\tspin_lock(&phba->sli4_hba.sgl_list_lock);\n\tlist_for_each_entry_safe(sglq_entry, sglq_next,\n\t\t\t&phba->sli4_hba.lpfc_abts_els_sgl_list, list) {\n\t\tif (sglq_entry->ndlp && sglq_entry->ndlp->vport == vport) {\n\t\t\tlpfc_nlp_put(sglq_entry->ndlp);\n\t\t\tsglq_entry->ndlp = NULL;\n\t\t}\n\t}\n\tspin_unlock(&phba->sli4_hba.sgl_list_lock);\n\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n\treturn;\n}\n\n/**\n * lpfc_sli4_els_xri_aborted - Slow-path process of els xri abort\n * @phba: pointer to lpfc hba data structure.\n * @axri: pointer to the els xri abort wcqe structure.\n *\n * This routine is invoked by the worker thread to process a SLI4 slow-path\n * ELS aborted xri.\n **/\nvoid\nlpfc_sli4_els_xri_aborted(struct lpfc_hba *phba,\n\t\t\t  struct sli4_wcqe_xri_aborted *axri)\n{\n\tuint16_t xri = bf_get(lpfc_wcqe_xa_xri, axri);\n\tuint16_t rxid = bf_get(lpfc_wcqe_xa_remote_xid, axri);\n\tuint16_t lxri = 0;\n\n\tstruct lpfc_sglq *sglq_entry = NULL, *sglq_next = NULL;\n\tunsigned long iflag = 0;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_sli_ring *pring;\n\n\tpring = lpfc_phba_elsring(phba);\n\n\tspin_lock_irqsave(&phba->hbalock, iflag);\n\tspin_lock(&phba->sli4_hba.sgl_list_lock);\n\tlist_for_each_entry_safe(sglq_entry, sglq_next,\n\t\t\t&phba->sli4_hba.lpfc_abts_els_sgl_list, list) {\n\t\tif (sglq_entry->sli4_xritag == xri) {\n\t\t\tlist_del(&sglq_entry->list);\n\t\t\tndlp = sglq_entry->ndlp;\n\t\t\tsglq_entry->ndlp = NULL;\n\t\t\tlist_add_tail(&sglq_entry->list,\n\t\t\t\t&phba->sli4_hba.lpfc_els_sgl_list);\n\t\t\tsglq_entry->state = SGL_FREED;\n\t\t\tspin_unlock(&phba->sli4_hba.sgl_list_lock);\n\t\t\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n\n\t\t\tif (ndlp) {\n\t\t\t\tlpfc_set_rrq_active(phba, ndlp,\n\t\t\t\t\tsglq_entry->sli4_lxritag,\n\t\t\t\t\trxid, 1);\n\t\t\t\tlpfc_nlp_put(ndlp);\n\t\t\t}\n\n\t\t\t/* Check if TXQ queue needs to be serviced */\n\t\t\tif (pring && !list_empty(&pring->txq))\n\t\t\t\tlpfc_worker_wake_up(phba);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&phba->sli4_hba.sgl_list_lock);\n\tlxri = lpfc_sli4_xri_inrange(phba, xri);\n\tif (lxri == NO_XRI) {\n\t\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n\t\treturn;\n\t}\n\tspin_lock(&phba->sli4_hba.sgl_list_lock);\n\tsglq_entry = __lpfc_get_active_sglq(phba, lxri);\n\tif (!sglq_entry || (sglq_entry->sli4_xritag != xri)) {\n\t\tspin_unlock(&phba->sli4_hba.sgl_list_lock);\n\t\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n\t\treturn;\n\t}\n\tsglq_entry->state = SGL_XRI_ABORTED;\n\tspin_unlock(&phba->sli4_hba.sgl_list_lock);\n\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n\treturn;\n}\n\n/* lpfc_sli_abts_recover_port - Recover a port that failed a BLS_ABORT req.\n * @vport: pointer to virtual port object.\n * @ndlp: nodelist pointer for the impacted node.\n *\n * The driver calls this routine in response to an SLI4 XRI ABORT CQE\n * or an SLI3 ASYNC_STATUS_CN event from the port.  For either event,\n * the driver is required to send a LOGO to the remote node before it\n * attempts to recover its login to the remote node.\n */\nvoid\nlpfc_sli_abts_recover_port(struct lpfc_vport *vport,\n\t\t\t   struct lpfc_nodelist *ndlp)\n{\n\tstruct Scsi_Host *shost;\n\tstruct lpfc_hba *phba;\n\tunsigned long flags = 0;\n\n\tshost = lpfc_shost_from_vport(vport);\n\tphba = vport->phba;\n\tif (ndlp->nlp_state != NLP_STE_MAPPED_NODE) {\n\t\tlpfc_printf_log(phba, KERN_INFO,\n\t\t\t\tLOG_SLI, \"3093 No rport recovery needed. \"\n\t\t\t\t\"rport in state 0x%x\\n\", ndlp->nlp_state);\n\t\treturn;\n\t}\n\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"3094 Start rport recovery on shost id 0x%x \"\n\t\t\t\"fc_id 0x%06x vpi 0x%x rpi 0x%x state 0x%x \"\n\t\t\t\"flags 0x%x\\n\",\n\t\t\tshost->host_no, ndlp->nlp_DID,\n\t\t\tvport->vpi, ndlp->nlp_rpi, ndlp->nlp_state,\n\t\t\tndlp->nlp_flag);\n\t/*\n\t * The rport is not responding.  Remove the FCP-2 flag to prevent\n\t * an ADISC in the follow-up recovery code.\n\t */\n\tspin_lock_irqsave(&ndlp->lock, flags);\n\tndlp->nlp_fcp_info &= ~NLP_FCP_2_DEVICE;\n\tndlp->nlp_flag |= NLP_ISSUE_LOGO;\n\tspin_unlock_irqrestore(&ndlp->lock, flags);\n\tlpfc_unreg_rpi(vport, ndlp);\n}\n\n"}}, "reports": [{"events": [{"location": {"col": 15, "file": 0, "line": 2043}, "message": "ERROR: ndlp is NULL but dereferenced."}], "macros": [], "notes": [], "path": "/src/drivers/scsi/lpfc/lpfc_els.c", "reportHash": "15e53053e2a0cf119b35c1f8d47aa7ef", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 41, "file": 0, "line": 2043}, "message": "ERROR: ndlp is NULL but dereferenced."}], "macros": [], "notes": [], "path": "/src/drivers/scsi/lpfc/lpfc_els.c", "reportHash": "83718c674e0e46a2eea5e955d9bb18ba", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
