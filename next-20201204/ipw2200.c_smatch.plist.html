<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/net/wireless/intel/ipw2x00/ipw2200.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/******************************************************************************\n\n  Copyright(c) 2003 - 2006 Intel Corporation. All rights reserved.\n\n  802.11 status code portion of this file from ethereal-0.10.6:\n    Copyright 2000, Axis Communications AB\n    Ethereal - Network traffic analyzer\n    By Gerald Combs <gerald@ethereal.com>\n    Copyright 1998 Gerald Combs\n\n\n  Contact Information:\n  Intel Linux Wireless <ilw@linux.intel.com>\n  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497\n\n******************************************************************************/\n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/cfg80211-wext.h>\n#include \"ipw2200.h\"\n#include \"ipw.h\"\n\n\n#ifndef KBUILD_EXTMOD\n#define VK \"k\"\n#else\n#define VK\n#endif\n\n#ifdef CONFIG_IPW2200_DEBUG\n#define VD \"d\"\n#else\n#define VD\n#endif\n\n#ifdef CONFIG_IPW2200_MONITOR\n#define VM \"m\"\n#else\n#define VM\n#endif\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n#define VP \"p\"\n#else\n#define VP\n#endif\n\n#ifdef CONFIG_IPW2200_RADIOTAP\n#define VR \"r\"\n#else\n#define VR\n#endif\n\n#ifdef CONFIG_IPW2200_QOS\n#define VQ \"q\"\n#else\n#define VQ\n#endif\n\n#define IPW2200_VERSION \"1.2.2\" VK VD VM VP VR VQ\n#define DRV_DESCRIPTION\t\"Intel(R) PRO/Wireless 2200/2915 Network Driver\"\n#define DRV_COPYRIGHT\t\"Copyright(c) 2003-2006 Intel Corporation\"\n#define DRV_VERSION     IPW2200_VERSION\n\n#define ETH_P_80211_STATS (ETH_P_80211_RAW + 1)\n\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_VERSION(DRV_VERSION);\nMODULE_AUTHOR(DRV_COPYRIGHT);\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"ipw2200-ibss.fw\");\n#ifdef CONFIG_IPW2200_MONITOR\nMODULE_FIRMWARE(\"ipw2200-sniffer.fw\");\n#endif\nMODULE_FIRMWARE(\"ipw2200-bss.fw\");\n\nstatic int cmdlog = 0;\nstatic int debug = 0;\nstatic int default_channel = 0;\nstatic int network_mode = 0;\n\nstatic u32 ipw_debug_level;\nstatic int associate;\nstatic int auto_create = 1;\nstatic int led_support = 1;\nstatic int disable = 0;\nstatic int bt_coexist = 0;\nstatic int hwcrypto = 0;\nstatic int roaming = 1;\nstatic const char ipw_modes[] = {\n\t'a', 'b', 'g', '?'\n};\nstatic int antenna = CFG_SYS_ANTENNA_BOTH;\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\nstatic int rtap_iface = 0;     /* def: 0 -- do not create rtap interface */\n#endif\n\nstatic struct ieee80211_rate ipw2200_rates[] = {\n\t{ .bitrate = 10 },\n\t{ .bitrate = 20, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 60 },\n\t{ .bitrate = 90 },\n\t{ .bitrate = 120 },\n\t{ .bitrate = 180 },\n\t{ .bitrate = 240 },\n\t{ .bitrate = 360 },\n\t{ .bitrate = 480 },\n\t{ .bitrate = 540 }\n};\n\n#define ipw2200_a_rates\t\t(ipw2200_rates + 4)\n#define ipw2200_num_a_rates\t8\n#define ipw2200_bg_rates\t(ipw2200_rates + 0)\n#define ipw2200_num_bg_rates\t12\n\n/* Ugly macro to convert literal channel numbers into their mhz equivalents\n * There are certianly some conditions that will break this (like feeding it '30')\n * but they shouldn't arise since nothing talks on channel 30. */\n#define ieee80211chan2mhz(x) \\\n\t(((x) <= 14) ? \\\n\t(((x) == 14) ? 2484 : ((x) * 5) + 2407) : \\\n\t((x) + 1000) * 5)\n\n#ifdef CONFIG_IPW2200_QOS\nstatic int qos_enable = 0;\nstatic int qos_burst_enable = 0;\nstatic int qos_no_ack_mask = 0;\nstatic int burst_duration_CCK = 0;\nstatic int burst_duration_OFDM = 0;\n\nstatic struct libipw_qos_parameters def_qos_parameters_OFDM = {\n\t{QOS_TX0_CW_MIN_OFDM, QOS_TX1_CW_MIN_OFDM, QOS_TX2_CW_MIN_OFDM,\n\t QOS_TX3_CW_MIN_OFDM},\n\t{QOS_TX0_CW_MAX_OFDM, QOS_TX1_CW_MAX_OFDM, QOS_TX2_CW_MAX_OFDM,\n\t QOS_TX3_CW_MAX_OFDM},\n\t{QOS_TX0_AIFS, QOS_TX1_AIFS, QOS_TX2_AIFS, QOS_TX3_AIFS},\n\t{QOS_TX0_ACM, QOS_TX1_ACM, QOS_TX2_ACM, QOS_TX3_ACM},\n\t{QOS_TX0_TXOP_LIMIT_OFDM, QOS_TX1_TXOP_LIMIT_OFDM,\n\t QOS_TX2_TXOP_LIMIT_OFDM, QOS_TX3_TXOP_LIMIT_OFDM}\n};\n\nstatic struct libipw_qos_parameters def_qos_parameters_CCK = {\n\t{QOS_TX0_CW_MIN_CCK, QOS_TX1_CW_MIN_CCK, QOS_TX2_CW_MIN_CCK,\n\t QOS_TX3_CW_MIN_CCK},\n\t{QOS_TX0_CW_MAX_CCK, QOS_TX1_CW_MAX_CCK, QOS_TX2_CW_MAX_CCK,\n\t QOS_TX3_CW_MAX_CCK},\n\t{QOS_TX0_AIFS, QOS_TX1_AIFS, QOS_TX2_AIFS, QOS_TX3_AIFS},\n\t{QOS_TX0_ACM, QOS_TX1_ACM, QOS_TX2_ACM, QOS_TX3_ACM},\n\t{QOS_TX0_TXOP_LIMIT_CCK, QOS_TX1_TXOP_LIMIT_CCK, QOS_TX2_TXOP_LIMIT_CCK,\n\t QOS_TX3_TXOP_LIMIT_CCK}\n};\n\nstatic struct libipw_qos_parameters def_parameters_OFDM = {\n\t{DEF_TX0_CW_MIN_OFDM, DEF_TX1_CW_MIN_OFDM, DEF_TX2_CW_MIN_OFDM,\n\t DEF_TX3_CW_MIN_OFDM},\n\t{DEF_TX0_CW_MAX_OFDM, DEF_TX1_CW_MAX_OFDM, DEF_TX2_CW_MAX_OFDM,\n\t DEF_TX3_CW_MAX_OFDM},\n\t{DEF_TX0_AIFS, DEF_TX1_AIFS, DEF_TX2_AIFS, DEF_TX3_AIFS},\n\t{DEF_TX0_ACM, DEF_TX1_ACM, DEF_TX2_ACM, DEF_TX3_ACM},\n\t{DEF_TX0_TXOP_LIMIT_OFDM, DEF_TX1_TXOP_LIMIT_OFDM,\n\t DEF_TX2_TXOP_LIMIT_OFDM, DEF_TX3_TXOP_LIMIT_OFDM}\n};\n\nstatic struct libipw_qos_parameters def_parameters_CCK = {\n\t{DEF_TX0_CW_MIN_CCK, DEF_TX1_CW_MIN_CCK, DEF_TX2_CW_MIN_CCK,\n\t DEF_TX3_CW_MIN_CCK},\n\t{DEF_TX0_CW_MAX_CCK, DEF_TX1_CW_MAX_CCK, DEF_TX2_CW_MAX_CCK,\n\t DEF_TX3_CW_MAX_CCK},\n\t{DEF_TX0_AIFS, DEF_TX1_AIFS, DEF_TX2_AIFS, DEF_TX3_AIFS},\n\t{DEF_TX0_ACM, DEF_TX1_ACM, DEF_TX2_ACM, DEF_TX3_ACM},\n\t{DEF_TX0_TXOP_LIMIT_CCK, DEF_TX1_TXOP_LIMIT_CCK, DEF_TX2_TXOP_LIMIT_CCK,\n\t DEF_TX3_TXOP_LIMIT_CCK}\n};\n\nstatic u8 qos_oui[QOS_OUI_LEN] = { 0x00, 0x50, 0xF2 };\n\nstatic int from_priority_to_tx_queue[] = {\n\tIPW_TX_QUEUE_1, IPW_TX_QUEUE_2, IPW_TX_QUEUE_2, IPW_TX_QUEUE_1,\n\tIPW_TX_QUEUE_3, IPW_TX_QUEUE_3, IPW_TX_QUEUE_4, IPW_TX_QUEUE_4\n};\n\nstatic u32 ipw_qos_get_burst_duration(struct ipw_priv *priv);\n\nstatic int ipw_send_qos_params_command(struct ipw_priv *priv, struct libipw_qos_parameters\n\t\t\t\t       *qos_param);\nstatic int ipw_send_qos_info_command(struct ipw_priv *priv, struct libipw_qos_information_element\n\t\t\t\t     *qos_param);\n#endif\t\t\t\t/* CONFIG_IPW2200_QOS */\n\nstatic struct iw_statistics *ipw_get_wireless_stats(struct net_device *dev);\nstatic void ipw_remove_current_network(struct ipw_priv *priv);\nstatic void ipw_rx(struct ipw_priv *priv);\nstatic int ipw_queue_tx_reclaim(struct ipw_priv *priv,\n\t\t\t\tstruct clx2_tx_queue *txq, int qindex);\nstatic int ipw_queue_reset(struct ipw_priv *priv);\n\nstatic int ipw_queue_tx_hcmd(struct ipw_priv *priv, int hcmd, void *buf,\n\t\t\t     int len, int sync);\n\nstatic void ipw_tx_queue_free(struct ipw_priv *);\n\nstatic struct ipw_rx_queue *ipw_rx_queue_alloc(struct ipw_priv *);\nstatic void ipw_rx_queue_free(struct ipw_priv *, struct ipw_rx_queue *);\nstatic void ipw_rx_queue_replenish(void *);\nstatic int ipw_up(struct ipw_priv *);\nstatic void ipw_bg_up(struct work_struct *work);\nstatic void ipw_down(struct ipw_priv *);\nstatic void ipw_bg_down(struct work_struct *work);\nstatic int ipw_config(struct ipw_priv *);\nstatic int init_supported_rates(struct ipw_priv *priv,\n\t\t\t\tstruct ipw_supported_rates *prates);\nstatic void ipw_set_hwcrypto_keys(struct ipw_priv *);\nstatic void ipw_send_wep_keys(struct ipw_priv *, int);\n\nstatic int snprint_line(char *buf, size_t count,\n\t\t\tconst u8 * data, u32 len, u32 ofs)\n{\n\tint out, i, j, l;\n\tchar c;\n\n\tout = scnprintf(buf, count, \"%08X\", ofs);\n\n\tfor (l = 0, i = 0; i < 2; i++) {\n\t\tout += scnprintf(buf + out, count - out, \" \");\n\t\tfor (j = 0; j < 8 && l < len; j++, l++)\n\t\t\tout += scnprintf(buf + out, count - out, \"%02X \",\n\t\t\t\t\tdata[(i * 8 + j)]);\n\t\tfor (; j < 8; j++)\n\t\t\tout += scnprintf(buf + out, count - out, \"   \");\n\t}\n\n\tout += scnprintf(buf + out, count - out, \" \");\n\tfor (l = 0, i = 0; i < 2; i++) {\n\t\tout += scnprintf(buf + out, count - out, \" \");\n\t\tfor (j = 0; j < 8 && l < len; j++, l++) {\n\t\t\tc = data[(i * 8 + j)];\n\t\t\tif (!isascii(c) || !isprint(c))\n\t\t\t\tc = '.';\n\n\t\t\tout += scnprintf(buf + out, count - out, \"%c\", c);\n\t\t}\n\n\t\tfor (; j < 8; j++)\n\t\t\tout += scnprintf(buf + out, count - out, \" \");\n\t}\n\n\treturn out;\n}\n\nstatic void printk_buf(int level, const u8 * data, u32 len)\n{\n\tchar line[81];\n\tu32 ofs = 0;\n\tif (!(ipw_debug_level & level))\n\t\treturn;\n\n\twhile (len) {\n\t\tsnprint_line(line, sizeof(line), &data[ofs],\n\t\t\t     min(len, 16U), ofs);\n\t\tprintk(KERN_DEBUG \"%s\\n\", line);\n\t\tofs += 16;\n\t\tlen -= min(len, 16U);\n\t}\n}\n\nstatic int snprintk_buf(u8 * output, size_t size, const u8 * data, size_t len)\n{\n\tsize_t out = size;\n\tu32 ofs = 0;\n\tint total = 0;\n\n\twhile (size && len) {\n\t\tout = snprint_line(output, size, &data[ofs],\n\t\t\t\t   min_t(size_t, len, 16U), ofs);\n\n\t\tofs += 16;\n\t\toutput += out;\n\t\tsize -= out;\n\t\tlen -= min_t(size_t, len, 16U);\n\t\ttotal += out;\n\t}\n\treturn total;\n}\n\n/* alias for 32-bit indirect read (for SRAM/reg above 4K), with debug wrapper */\nstatic u32 _ipw_read_reg32(struct ipw_priv *priv, u32 reg);\n#define ipw_read_reg32(a, b) _ipw_read_reg32(a, b)\n\n/* alias for 8-bit indirect read (for SRAM/reg above 4K), with debug wrapper */\nstatic u8 _ipw_read_reg8(struct ipw_priv *ipw, u32 reg);\n#define ipw_read_reg8(a, b) _ipw_read_reg8(a, b)\n\n/* 8-bit indirect write (for SRAM/reg above 4K), with debug wrapper */\nstatic void _ipw_write_reg8(struct ipw_priv *priv, u32 reg, u8 value);\nstatic inline void ipw_write_reg8(struct ipw_priv *a, u32 b, u8 c)\n{\n\tIPW_DEBUG_IO(\"%s %d: write_indirect8(0x%08X, 0x%08X)\\n\", __FILE__,\n\t\t     __LINE__, (u32) (b), (u32) (c));\n\t_ipw_write_reg8(a, b, c);\n}\n\n/* 16-bit indirect write (for SRAM/reg above 4K), with debug wrapper */\nstatic void _ipw_write_reg16(struct ipw_priv *priv, u32 reg, u16 value);\nstatic inline void ipw_write_reg16(struct ipw_priv *a, u32 b, u16 c)\n{\n\tIPW_DEBUG_IO(\"%s %d: write_indirect16(0x%08X, 0x%08X)\\n\", __FILE__,\n\t\t     __LINE__, (u32) (b), (u32) (c));\n\t_ipw_write_reg16(a, b, c);\n}\n\n/* 32-bit indirect write (for SRAM/reg above 4K), with debug wrapper */\nstatic void _ipw_write_reg32(struct ipw_priv *priv, u32 reg, u32 value);\nstatic inline void ipw_write_reg32(struct ipw_priv *a, u32 b, u32 c)\n{\n\tIPW_DEBUG_IO(\"%s %d: write_indirect32(0x%08X, 0x%08X)\\n\", __FILE__,\n\t\t     __LINE__, (u32) (b), (u32) (c));\n\t_ipw_write_reg32(a, b, c);\n}\n\n/* 8-bit direct write (low 4K) */\nstatic inline void _ipw_write8(struct ipw_priv *ipw, unsigned long ofs,\n\t\tu8 val)\n{\n\twriteb(val, ipw->hw_base + ofs);\n}\n\n/* 8-bit direct write (for low 4K of SRAM/regs), with debug wrapper */\n#define ipw_write8(ipw, ofs, val) do { \\\n\tIPW_DEBUG_IO(\"%s %d: write_direct8(0x%08X, 0x%08X)\\n\", __FILE__, \\\n\t\t\t__LINE__, (u32)(ofs), (u32)(val)); \\\n\t_ipw_write8(ipw, ofs, val); \\\n} while (0)\n\n/* 16-bit direct write (low 4K) */\nstatic inline void _ipw_write16(struct ipw_priv *ipw, unsigned long ofs,\n\t\tu16 val)\n{\n\twritew(val, ipw->hw_base + ofs);\n}\n\n/* 16-bit direct write (for low 4K of SRAM/regs), with debug wrapper */\n#define ipw_write16(ipw, ofs, val) do { \\\n\tIPW_DEBUG_IO(\"%s %d: write_direct16(0x%08X, 0x%08X)\\n\", __FILE__, \\\n\t\t\t__LINE__, (u32)(ofs), (u32)(val)); \\\n\t_ipw_write16(ipw, ofs, val); \\\n} while (0)\n\n/* 32-bit direct write (low 4K) */\nstatic inline void _ipw_write32(struct ipw_priv *ipw, unsigned long ofs,\n\t\tu32 val)\n{\n\twritel(val, ipw->hw_base + ofs);\n}\n\n/* 32-bit direct write (for low 4K of SRAM/regs), with debug wrapper */\n#define ipw_write32(ipw, ofs, val) do { \\\n\tIPW_DEBUG_IO(\"%s %d: write_direct32(0x%08X, 0x%08X)\\n\", __FILE__, \\\n\t\t\t__LINE__, (u32)(ofs), (u32)(val)); \\\n\t_ipw_write32(ipw, ofs, val); \\\n} while (0)\n\n/* 8-bit direct read (low 4K) */\nstatic inline u8 _ipw_read8(struct ipw_priv *ipw, unsigned long ofs)\n{\n\treturn readb(ipw->hw_base + ofs);\n}\n\n/* alias to 8-bit direct read (low 4K of SRAM/regs), with debug wrapper */\n#define ipw_read8(ipw, ofs) ({ \\\n\tIPW_DEBUG_IO(\"%s %d: read_direct8(0x%08X)\\n\", __FILE__, __LINE__, \\\n\t\t\t(u32)(ofs)); \\\n\t_ipw_read8(ipw, ofs); \\\n})\n\n/* 16-bit direct read (low 4K) */\nstatic inline u16 _ipw_read16(struct ipw_priv *ipw, unsigned long ofs)\n{\n\treturn readw(ipw->hw_base + ofs);\n}\n\n/* alias to 16-bit direct read (low 4K of SRAM/regs), with debug wrapper */\n#define ipw_read16(ipw, ofs) ({ \\\n\tIPW_DEBUG_IO(\"%s %d: read_direct16(0x%08X)\\n\", __FILE__, __LINE__, \\\n\t\t\t(u32)(ofs)); \\\n\t_ipw_read16(ipw, ofs); \\\n})\n\n/* 32-bit direct read (low 4K) */\nstatic inline u32 _ipw_read32(struct ipw_priv *ipw, unsigned long ofs)\n{\n\treturn readl(ipw->hw_base + ofs);\n}\n\n/* alias to 32-bit direct read (low 4K of SRAM/regs), with debug wrapper */\n#define ipw_read32(ipw, ofs) ({ \\\n\tIPW_DEBUG_IO(\"%s %d: read_direct32(0x%08X)\\n\", __FILE__, __LINE__, \\\n\t\t\t(u32)(ofs)); \\\n\t_ipw_read32(ipw, ofs); \\\n})\n\nstatic void _ipw_read_indirect(struct ipw_priv *, u32, u8 *, int);\n/* alias to multi-byte read (SRAM/regs above 4K), with debug wrapper */\n#define ipw_read_indirect(a, b, c, d) ({ \\\n\tIPW_DEBUG_IO(\"%s %d: read_indirect(0x%08X) %u bytes\\n\", __FILE__, \\\n\t\t\t__LINE__, (u32)(b), (u32)(d)); \\\n\t_ipw_read_indirect(a, b, c, d); \\\n})\n\n/* alias to multi-byte read (SRAM/regs above 4K), with debug wrapper */\nstatic void _ipw_write_indirect(struct ipw_priv *priv, u32 addr, u8 * data,\n\t\t\t\tint num);\n#define ipw_write_indirect(a, b, c, d) do { \\\n\tIPW_DEBUG_IO(\"%s %d: write_indirect(0x%08X) %u bytes\\n\", __FILE__, \\\n\t\t\t__LINE__, (u32)(b), (u32)(d)); \\\n\t_ipw_write_indirect(a, b, c, d); \\\n} while (0)\n\n/* 32-bit indirect write (above 4K) */\nstatic void _ipw_write_reg32(struct ipw_priv *priv, u32 reg, u32 value)\n{\n\tIPW_DEBUG_IO(\" %p : reg = 0x%8X : value = 0x%8X\\n\", priv, reg, value);\n\t_ipw_write32(priv, IPW_INDIRECT_ADDR, reg);\n\t_ipw_write32(priv, IPW_INDIRECT_DATA, value);\n}\n\n/* 8-bit indirect write (above 4K) */\nstatic void _ipw_write_reg8(struct ipw_priv *priv, u32 reg, u8 value)\n{\n\tu32 aligned_addr = reg & IPW_INDIRECT_ADDR_MASK;\t/* dword align */\n\tu32 dif_len = reg - aligned_addr;\n\n\tIPW_DEBUG_IO(\" reg = 0x%8X : value = 0x%8X\\n\", reg, value);\n\t_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\n\t_ipw_write8(priv, IPW_INDIRECT_DATA + dif_len, value);\n}\n\n/* 16-bit indirect write (above 4K) */\nstatic void _ipw_write_reg16(struct ipw_priv *priv, u32 reg, u16 value)\n{\n\tu32 aligned_addr = reg & IPW_INDIRECT_ADDR_MASK;\t/* dword align */\n\tu32 dif_len = (reg - aligned_addr) & (~0x1ul);\n\n\tIPW_DEBUG_IO(\" reg = 0x%8X : value = 0x%8X\\n\", reg, value);\n\t_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\n\t_ipw_write16(priv, IPW_INDIRECT_DATA + dif_len, value);\n}\n\n/* 8-bit indirect read (above 4K) */\nstatic u8 _ipw_read_reg8(struct ipw_priv *priv, u32 reg)\n{\n\tu32 word;\n\t_ipw_write32(priv, IPW_INDIRECT_ADDR, reg & IPW_INDIRECT_ADDR_MASK);\n\tIPW_DEBUG_IO(\" reg = 0x%8X :\\n\", reg);\n\tword = _ipw_read32(priv, IPW_INDIRECT_DATA);\n\treturn (word >> ((reg & 0x3) * 8)) & 0xff;\n}\n\n/* 32-bit indirect read (above 4K) */\nstatic u32 _ipw_read_reg32(struct ipw_priv *priv, u32 reg)\n{\n\tu32 value;\n\n\tIPW_DEBUG_IO(\"%p : reg = 0x%08x\\n\", priv, reg);\n\n\t_ipw_write32(priv, IPW_INDIRECT_ADDR, reg);\n\tvalue = _ipw_read32(priv, IPW_INDIRECT_DATA);\n\tIPW_DEBUG_IO(\" reg = 0x%4X : value = 0x%4x\\n\", reg, value);\n\treturn value;\n}\n\n/* General purpose, no alignment requirement, iterative (multi-byte) read, */\n/*    for area above 1st 4K of SRAM/reg space */\nstatic void _ipw_read_indirect(struct ipw_priv *priv, u32 addr, u8 * buf,\n\t\t\t       int num)\n{\n\tu32 aligned_addr = addr & IPW_INDIRECT_ADDR_MASK;\t/* dword align */\n\tu32 dif_len = addr - aligned_addr;\n\tu32 i;\n\n\tIPW_DEBUG_IO(\"addr = %i, buf = %p, num = %i\\n\", addr, buf, num);\n\n\tif (num <= 0) {\n\t\treturn;\n\t}\n\n\t/* Read the first dword (or portion) byte by byte */\n\tif (unlikely(dif_len)) {\n\t\t_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\n\t\t/* Start reading at aligned_addr + dif_len */\n\t\tfor (i = dif_len; ((i < 4) && (num > 0)); i++, num--)\n\t\t\t*buf++ = _ipw_read8(priv, IPW_INDIRECT_DATA + i);\n\t\taligned_addr += 4;\n\t}\n\n\t/* Read all of the middle dwords as dwords, with auto-increment */\n\t_ipw_write32(priv, IPW_AUTOINC_ADDR, aligned_addr);\n\tfor (; num >= 4; buf += 4, aligned_addr += 4, num -= 4)\n\t\t*(u32 *) buf = _ipw_read32(priv, IPW_AUTOINC_DATA);\n\n\t/* Read the last dword (or portion) byte by byte */\n\tif (unlikely(num)) {\n\t\t_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\n\t\tfor (i = 0; num > 0; i++, num--)\n\t\t\t*buf++ = ipw_read8(priv, IPW_INDIRECT_DATA + i);\n\t}\n}\n\n/* General purpose, no alignment requirement, iterative (multi-byte) write, */\n/*    for area above 1st 4K of SRAM/reg space */\nstatic void _ipw_write_indirect(struct ipw_priv *priv, u32 addr, u8 * buf,\n\t\t\t\tint num)\n{\n\tu32 aligned_addr = addr & IPW_INDIRECT_ADDR_MASK;\t/* dword align */\n\tu32 dif_len = addr - aligned_addr;\n\tu32 i;\n\n\tIPW_DEBUG_IO(\"addr = %i, buf = %p, num = %i\\n\", addr, buf, num);\n\n\tif (num <= 0) {\n\t\treturn;\n\t}\n\n\t/* Write the first dword (or portion) byte by byte */\n\tif (unlikely(dif_len)) {\n\t\t_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\n\t\t/* Start writing at aligned_addr + dif_len */\n\t\tfor (i = dif_len; ((i < 4) && (num > 0)); i++, num--, buf++)\n\t\t\t_ipw_write8(priv, IPW_INDIRECT_DATA + i, *buf);\n\t\taligned_addr += 4;\n\t}\n\n\t/* Write all of the middle dwords as dwords, with auto-increment */\n\t_ipw_write32(priv, IPW_AUTOINC_ADDR, aligned_addr);\n\tfor (; num >= 4; buf += 4, aligned_addr += 4, num -= 4)\n\t\t_ipw_write32(priv, IPW_AUTOINC_DATA, *(u32 *) buf);\n\n\t/* Write the last dword (or portion) byte by byte */\n\tif (unlikely(num)) {\n\t\t_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\n\t\tfor (i = 0; num > 0; i++, num--, buf++)\n\t\t\t_ipw_write8(priv, IPW_INDIRECT_DATA + i, *buf);\n\t}\n}\n\n/* General purpose, no alignment requirement, iterative (multi-byte) write, */\n/*    for 1st 4K of SRAM/regs space */\nstatic void ipw_write_direct(struct ipw_priv *priv, u32 addr, void *buf,\n\t\t\t     int num)\n{\n\tmemcpy_toio((priv->hw_base + addr), buf, num);\n}\n\n/* Set bit(s) in low 4K of SRAM/regs */\nstatic inline void ipw_set_bit(struct ipw_priv *priv, u32 reg, u32 mask)\n{\n\tipw_write32(priv, reg, ipw_read32(priv, reg) | mask);\n}\n\n/* Clear bit(s) in low 4K of SRAM/regs */\nstatic inline void ipw_clear_bit(struct ipw_priv *priv, u32 reg, u32 mask)\n{\n\tipw_write32(priv, reg, ipw_read32(priv, reg) & ~mask);\n}\n\nstatic inline void __ipw_enable_interrupts(struct ipw_priv *priv)\n{\n\tif (priv->status & STATUS_INT_ENABLED)\n\t\treturn;\n\tpriv->status |= STATUS_INT_ENABLED;\n\tipw_write32(priv, IPW_INTA_MASK_R, IPW_INTA_MASK_ALL);\n}\n\nstatic inline void __ipw_disable_interrupts(struct ipw_priv *priv)\n{\n\tif (!(priv->status & STATUS_INT_ENABLED))\n\t\treturn;\n\tpriv->status &= ~STATUS_INT_ENABLED;\n\tipw_write32(priv, IPW_INTA_MASK_R, ~IPW_INTA_MASK_ALL);\n}\n\nstatic inline void ipw_enable_interrupts(struct ipw_priv *priv)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->irq_lock, flags);\n\t__ipw_enable_interrupts(priv);\n\tspin_unlock_irqrestore(&priv->irq_lock, flags);\n}\n\nstatic inline void ipw_disable_interrupts(struct ipw_priv *priv)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->irq_lock, flags);\n\t__ipw_disable_interrupts(priv);\n\tspin_unlock_irqrestore(&priv->irq_lock, flags);\n}\n\nstatic char *ipw_error_desc(u32 val)\n{\n\tswitch (val) {\n\tcase IPW_FW_ERROR_OK:\n\t\treturn \"ERROR_OK\";\n\tcase IPW_FW_ERROR_FAIL:\n\t\treturn \"ERROR_FAIL\";\n\tcase IPW_FW_ERROR_MEMORY_UNDERFLOW:\n\t\treturn \"MEMORY_UNDERFLOW\";\n\tcase IPW_FW_ERROR_MEMORY_OVERFLOW:\n\t\treturn \"MEMORY_OVERFLOW\";\n\tcase IPW_FW_ERROR_BAD_PARAM:\n\t\treturn \"BAD_PARAM\";\n\tcase IPW_FW_ERROR_BAD_CHECKSUM:\n\t\treturn \"BAD_CHECKSUM\";\n\tcase IPW_FW_ERROR_NMI_INTERRUPT:\n\t\treturn \"NMI_INTERRUPT\";\n\tcase IPW_FW_ERROR_BAD_DATABASE:\n\t\treturn \"BAD_DATABASE\";\n\tcase IPW_FW_ERROR_ALLOC_FAIL:\n\t\treturn \"ALLOC_FAIL\";\n\tcase IPW_FW_ERROR_DMA_UNDERRUN:\n\t\treturn \"DMA_UNDERRUN\";\n\tcase IPW_FW_ERROR_DMA_STATUS:\n\t\treturn \"DMA_STATUS\";\n\tcase IPW_FW_ERROR_DINO_ERROR:\n\t\treturn \"DINO_ERROR\";\n\tcase IPW_FW_ERROR_EEPROM_ERROR:\n\t\treturn \"EEPROM_ERROR\";\n\tcase IPW_FW_ERROR_SYSASSERT:\n\t\treturn \"SYSASSERT\";\n\tcase IPW_FW_ERROR_FATAL_ERROR:\n\t\treturn \"FATAL_ERROR\";\n\tdefault:\n\t\treturn \"UNKNOWN_ERROR\";\n\t}\n}\n\nstatic void ipw_dump_error_log(struct ipw_priv *priv,\n\t\t\t       struct ipw_fw_error *error)\n{\n\tu32 i;\n\n\tif (!error) {\n\t\tIPW_ERROR(\"Error allocating and capturing error log.  \"\n\t\t\t  \"Nothing to dump.\\n\");\n\t\treturn;\n\t}\n\n\tIPW_ERROR(\"Start IPW Error Log Dump:\\n\");\n\tIPW_ERROR(\"Status: 0x%08X, Config: %08X\\n\",\n\t\t  error->status, error->config);\n\n\tfor (i = 0; i < error->elem_len; i++)\n\t\tIPW_ERROR(\"%s %i 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\\n\",\n\t\t\t  ipw_error_desc(error->elem[i].desc),\n\t\t\t  error->elem[i].time,\n\t\t\t  error->elem[i].blink1,\n\t\t\t  error->elem[i].blink2,\n\t\t\t  error->elem[i].link1,\n\t\t\t  error->elem[i].link2, error->elem[i].data);\n\tfor (i = 0; i < error->log_len; i++)\n\t\tIPW_ERROR(\"%i\\t0x%08x\\t%i\\n\",\n\t\t\t  error->log[i].time,\n\t\t\t  error->log[i].data, error->log[i].event);\n}\n\nstatic inline int ipw_is_init(struct ipw_priv *priv)\n{\n\treturn (priv->status & STATUS_INIT) ? 1 : 0;\n}\n\nstatic int ipw_get_ordinal(struct ipw_priv *priv, u32 ord, void *val, u32 * len)\n{\n\tu32 addr, field_info, field_len, field_count, total_len;\n\n\tIPW_DEBUG_ORD(\"ordinal = %i\\n\", ord);\n\n\tif (!priv || !val || !len) {\n\t\tIPW_DEBUG_ORD(\"Invalid argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* verify device ordinal tables have been initialized */\n\tif (!priv->table0_addr || !priv->table1_addr || !priv->table2_addr) {\n\t\tIPW_DEBUG_ORD(\"Access ordinals before initialization\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (IPW_ORD_TABLE_ID_MASK & ord) {\n\tcase IPW_ORD_TABLE_0_MASK:\n\t\t/*\n\t\t * TABLE 0: Direct access to a table of 32 bit values\n\t\t *\n\t\t * This is a very simple table with the data directly\n\t\t * read from the table\n\t\t */\n\n\t\t/* remove the table id from the ordinal */\n\t\tord &= IPW_ORD_TABLE_VALUE_MASK;\n\n\t\t/* boundary check */\n\t\tif (ord > priv->table0_len) {\n\t\t\tIPW_DEBUG_ORD(\"ordinal value (%i) longer then \"\n\t\t\t\t      \"max (%i)\\n\", ord, priv->table0_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* verify we have enough room to store the value */\n\t\tif (*len < sizeof(u32)) {\n\t\t\tIPW_DEBUG_ORD(\"ordinal buffer length too small, \"\n\t\t\t\t      \"need %zd\\n\", sizeof(u32));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tIPW_DEBUG_ORD(\"Reading TABLE0[%i] from offset 0x%08x\\n\",\n\t\t\t      ord, priv->table0_addr + (ord << 2));\n\n\t\t*len = sizeof(u32);\n\t\tord <<= 2;\n\t\t*((u32 *) val) = ipw_read32(priv, priv->table0_addr + ord);\n\t\tbreak;\n\n\tcase IPW_ORD_TABLE_1_MASK:\n\t\t/*\n\t\t * TABLE 1: Indirect access to a table of 32 bit values\n\t\t *\n\t\t * This is a fairly large table of u32 values each\n\t\t * representing starting addr for the data (which is\n\t\t * also a u32)\n\t\t */\n\n\t\t/* remove the table id from the ordinal */\n\t\tord &= IPW_ORD_TABLE_VALUE_MASK;\n\n\t\t/* boundary check */\n\t\tif (ord > priv->table1_len) {\n\t\t\tIPW_DEBUG_ORD(\"ordinal value too long\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* verify we have enough room to store the value */\n\t\tif (*len < sizeof(u32)) {\n\t\t\tIPW_DEBUG_ORD(\"ordinal buffer length too small, \"\n\t\t\t\t      \"need %zd\\n\", sizeof(u32));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*((u32 *) val) =\n\t\t    ipw_read_reg32(priv, (priv->table1_addr + (ord << 2)));\n\t\t*len = sizeof(u32);\n\t\tbreak;\n\n\tcase IPW_ORD_TABLE_2_MASK:\n\t\t/*\n\t\t * TABLE 2: Indirect access to a table of variable sized values\n\t\t *\n\t\t * This table consist of six values, each containing\n\t\t *     - dword containing the starting offset of the data\n\t\t *     - dword containing the lengh in the first 16bits\n\t\t *       and the count in the second 16bits\n\t\t */\n\n\t\t/* remove the table id from the ordinal */\n\t\tord &= IPW_ORD_TABLE_VALUE_MASK;\n\n\t\t/* boundary check */\n\t\tif (ord > priv->table2_len) {\n\t\t\tIPW_DEBUG_ORD(\"ordinal value too long\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* get the address of statistic */\n\t\taddr = ipw_read_reg32(priv, priv->table2_addr + (ord << 3));\n\n\t\t/* get the second DW of statistics ;\n\t\t * two 16-bit words - first is length, second is count */\n\t\tfield_info =\n\t\t    ipw_read_reg32(priv,\n\t\t\t\t   priv->table2_addr + (ord << 3) +\n\t\t\t\t   sizeof(u32));\n\n\t\t/* get each entry length */\n\t\tfield_len = *((u16 *) & field_info);\n\n\t\t/* get number of entries */\n\t\tfield_count = *(((u16 *) & field_info) + 1);\n\n\t\t/* abort if not enough memory */\n\t\ttotal_len = field_len * field_count;\n\t\tif (total_len > *len) {\n\t\t\t*len = total_len;\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*len = total_len;\n\t\tif (!total_len)\n\t\t\treturn 0;\n\n\t\tIPW_DEBUG_ORD(\"addr = 0x%08x, total_len = %i, \"\n\t\t\t      \"field_info = 0x%08x\\n\",\n\t\t\t      addr, total_len, field_info);\n\t\tipw_read_indirect(priv, addr, val, total_len);\n\t\tbreak;\n\n\tdefault:\n\t\tIPW_DEBUG_ORD(\"Invalid ordinal!\\n\");\n\t\treturn -EINVAL;\n\n\t}\n\n\treturn 0;\n}\n\nstatic void ipw_init_ordinals(struct ipw_priv *priv)\n{\n\tpriv->table0_addr = IPW_ORDINALS_TABLE_LOWER;\n\tpriv->table0_len = ipw_read32(priv, priv->table0_addr);\n\n\tIPW_DEBUG_ORD(\"table 0 offset at 0x%08x, len = %i\\n\",\n\t\t      priv->table0_addr, priv->table0_len);\n\n\tpriv->table1_addr = ipw_read32(priv, IPW_ORDINALS_TABLE_1);\n\tpriv->table1_len = ipw_read_reg32(priv, priv->table1_addr);\n\n\tIPW_DEBUG_ORD(\"table 1 offset at 0x%08x, len = %i\\n\",\n\t\t      priv->table1_addr, priv->table1_len);\n\n\tpriv->table2_addr = ipw_read32(priv, IPW_ORDINALS_TABLE_2);\n\tpriv->table2_len = ipw_read_reg32(priv, priv->table2_addr);\n\tpriv->table2_len &= 0x0000ffff;\t/* use first two bytes */\n\n\tIPW_DEBUG_ORD(\"table 2 offset at 0x%08x, len = %i\\n\",\n\t\t      priv->table2_addr, priv->table2_len);\n\n}\n\nstatic u32 ipw_register_toggle(u32 reg)\n{\n\treg &= ~IPW_START_STANDBY;\n\tif (reg & IPW_GATE_ODMA)\n\t\treg &= ~IPW_GATE_ODMA;\n\tif (reg & IPW_GATE_IDMA)\n\t\treg &= ~IPW_GATE_IDMA;\n\tif (reg & IPW_GATE_ADMA)\n\t\treg &= ~IPW_GATE_ADMA;\n\treturn reg;\n}\n\n/*\n * LED behavior:\n * - On radio ON, turn on any LEDs that require to be on during start\n * - On initialization, start unassociated blink\n * - On association, disable unassociated blink\n * - On disassociation, start unassociated blink\n * - On radio OFF, turn off any LEDs started during radio on\n *\n */\n#define LD_TIME_LINK_ON msecs_to_jiffies(300)\n#define LD_TIME_LINK_OFF msecs_to_jiffies(2700)\n#define LD_TIME_ACT_ON msecs_to_jiffies(250)\n\nstatic void ipw_led_link_on(struct ipw_priv *priv)\n{\n\tunsigned long flags;\n\tu32 led;\n\n\t/* If configured to not use LEDs, or nic_type is 1,\n\t * then we don't toggle a LINK led */\n\tif (priv->config & CFG_NO_LED || priv->nic_type == EEPROM_NIC_TYPE_1)\n\t\treturn;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (!(priv->status & STATUS_RF_KILL_MASK) &&\n\t    !(priv->status & STATUS_LED_LINK_ON)) {\n\t\tIPW_DEBUG_LED(\"Link LED On\\n\");\n\t\tled = ipw_read_reg32(priv, IPW_EVENT_REG);\n\t\tled |= priv->led_association_on;\n\n\t\tled = ipw_register_toggle(led);\n\n\t\tIPW_DEBUG_LED(\"Reg: 0x%08X\\n\", led);\n\t\tipw_write_reg32(priv, IPW_EVENT_REG, led);\n\n\t\tpriv->status |= STATUS_LED_LINK_ON;\n\n\t\t/* If we aren't associated, schedule turning the LED off */\n\t\tif (!(priv->status & STATUS_ASSOCIATED))\n\t\t\tschedule_delayed_work(&priv->led_link_off,\n\t\t\t\t\t      LD_TIME_LINK_ON);\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void ipw_bg_led_link_on(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, led_link_on.work);\n\tmutex_lock(&priv->mutex);\n\tipw_led_link_on(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_led_link_off(struct ipw_priv *priv)\n{\n\tunsigned long flags;\n\tu32 led;\n\n\t/* If configured not to use LEDs, or nic type is 1,\n\t * then we don't goggle the LINK led. */\n\tif (priv->config & CFG_NO_LED || priv->nic_type == EEPROM_NIC_TYPE_1)\n\t\treturn;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (priv->status & STATUS_LED_LINK_ON) {\n\t\tled = ipw_read_reg32(priv, IPW_EVENT_REG);\n\t\tled &= priv->led_association_off;\n\t\tled = ipw_register_toggle(led);\n\n\t\tIPW_DEBUG_LED(\"Reg: 0x%08X\\n\", led);\n\t\tipw_write_reg32(priv, IPW_EVENT_REG, led);\n\n\t\tIPW_DEBUG_LED(\"Link LED Off\\n\");\n\n\t\tpriv->status &= ~STATUS_LED_LINK_ON;\n\n\t\t/* If we aren't associated and the radio is on, schedule\n\t\t * turning the LED on (blink while unassociated) */\n\t\tif (!(priv->status & STATUS_RF_KILL_MASK) &&\n\t\t    !(priv->status & STATUS_ASSOCIATED))\n\t\t\tschedule_delayed_work(&priv->led_link_on,\n\t\t\t\t\t      LD_TIME_LINK_OFF);\n\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void ipw_bg_led_link_off(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, led_link_off.work);\n\tmutex_lock(&priv->mutex);\n\tipw_led_link_off(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void __ipw_led_activity_on(struct ipw_priv *priv)\n{\n\tu32 led;\n\n\tif (priv->config & CFG_NO_LED)\n\t\treturn;\n\n\tif (priv->status & STATUS_RF_KILL_MASK)\n\t\treturn;\n\n\tif (!(priv->status & STATUS_LED_ACT_ON)) {\n\t\tled = ipw_read_reg32(priv, IPW_EVENT_REG);\n\t\tled |= priv->led_activity_on;\n\n\t\tled = ipw_register_toggle(led);\n\n\t\tIPW_DEBUG_LED(\"Reg: 0x%08X\\n\", led);\n\t\tipw_write_reg32(priv, IPW_EVENT_REG, led);\n\n\t\tIPW_DEBUG_LED(\"Activity LED On\\n\");\n\n\t\tpriv->status |= STATUS_LED_ACT_ON;\n\n\t\tcancel_delayed_work(&priv->led_act_off);\n\t\tschedule_delayed_work(&priv->led_act_off, LD_TIME_ACT_ON);\n\t} else {\n\t\t/* Reschedule LED off for full time period */\n\t\tcancel_delayed_work(&priv->led_act_off);\n\t\tschedule_delayed_work(&priv->led_act_off, LD_TIME_ACT_ON);\n\t}\n}\n\n#if 0\nvoid ipw_led_activity_on(struct ipw_priv *priv)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&priv->lock, flags);\n\t__ipw_led_activity_on(priv);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n#endif  /*  0  */\n\nstatic void ipw_led_activity_off(struct ipw_priv *priv)\n{\n\tunsigned long flags;\n\tu32 led;\n\n\tif (priv->config & CFG_NO_LED)\n\t\treturn;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (priv->status & STATUS_LED_ACT_ON) {\n\t\tled = ipw_read_reg32(priv, IPW_EVENT_REG);\n\t\tled &= priv->led_activity_off;\n\n\t\tled = ipw_register_toggle(led);\n\n\t\tIPW_DEBUG_LED(\"Reg: 0x%08X\\n\", led);\n\t\tipw_write_reg32(priv, IPW_EVENT_REG, led);\n\n\t\tIPW_DEBUG_LED(\"Activity LED Off\\n\");\n\n\t\tpriv->status &= ~STATUS_LED_ACT_ON;\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void ipw_bg_led_activity_off(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, led_act_off.work);\n\tmutex_lock(&priv->mutex);\n\tipw_led_activity_off(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_led_band_on(struct ipw_priv *priv)\n{\n\tunsigned long flags;\n\tu32 led;\n\n\t/* Only nic type 1 supports mode LEDs */\n\tif (priv->config & CFG_NO_LED ||\n\t    priv->nic_type != EEPROM_NIC_TYPE_1 || !priv->assoc_network)\n\t\treturn;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tled = ipw_read_reg32(priv, IPW_EVENT_REG);\n\tif (priv->assoc_network->mode == IEEE_A) {\n\t\tled |= priv->led_ofdm_on;\n\t\tled &= priv->led_association_off;\n\t\tIPW_DEBUG_LED(\"Mode LED On: 802.11a\\n\");\n\t} else if (priv->assoc_network->mode == IEEE_G) {\n\t\tled |= priv->led_ofdm_on;\n\t\tled |= priv->led_association_on;\n\t\tIPW_DEBUG_LED(\"Mode LED On: 802.11g\\n\");\n\t} else {\n\t\tled &= priv->led_ofdm_off;\n\t\tled |= priv->led_association_on;\n\t\tIPW_DEBUG_LED(\"Mode LED On: 802.11b\\n\");\n\t}\n\n\tled = ipw_register_toggle(led);\n\n\tIPW_DEBUG_LED(\"Reg: 0x%08X\\n\", led);\n\tipw_write_reg32(priv, IPW_EVENT_REG, led);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void ipw_led_band_off(struct ipw_priv *priv)\n{\n\tunsigned long flags;\n\tu32 led;\n\n\t/* Only nic type 1 supports mode LEDs */\n\tif (priv->config & CFG_NO_LED || priv->nic_type != EEPROM_NIC_TYPE_1)\n\t\treturn;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tled = ipw_read_reg32(priv, IPW_EVENT_REG);\n\tled &= priv->led_ofdm_off;\n\tled &= priv->led_association_off;\n\n\tled = ipw_register_toggle(led);\n\n\tIPW_DEBUG_LED(\"Reg: 0x%08X\\n\", led);\n\tipw_write_reg32(priv, IPW_EVENT_REG, led);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void ipw_led_radio_on(struct ipw_priv *priv)\n{\n\tipw_led_link_on(priv);\n}\n\nstatic void ipw_led_radio_off(struct ipw_priv *priv)\n{\n\tipw_led_activity_off(priv);\n\tipw_led_link_off(priv);\n}\n\nstatic void ipw_led_link_up(struct ipw_priv *priv)\n{\n\t/* Set the Link Led on for all nic types */\n\tipw_led_link_on(priv);\n}\n\nstatic void ipw_led_link_down(struct ipw_priv *priv)\n{\n\tipw_led_activity_off(priv);\n\tipw_led_link_off(priv);\n\n\tif (priv->status & STATUS_RF_KILL_MASK)\n\t\tipw_led_radio_off(priv);\n}\n\nstatic void ipw_led_init(struct ipw_priv *priv)\n{\n\tpriv->nic_type = priv->eeprom[EEPROM_NIC_TYPE];\n\n\t/* Set the default PINs for the link and activity leds */\n\tpriv->led_activity_on = IPW_ACTIVITY_LED;\n\tpriv->led_activity_off = ~(IPW_ACTIVITY_LED);\n\n\tpriv->led_association_on = IPW_ASSOCIATED_LED;\n\tpriv->led_association_off = ~(IPW_ASSOCIATED_LED);\n\n\t/* Set the default PINs for the OFDM leds */\n\tpriv->led_ofdm_on = IPW_OFDM_LED;\n\tpriv->led_ofdm_off = ~(IPW_OFDM_LED);\n\n\tswitch (priv->nic_type) {\n\tcase EEPROM_NIC_TYPE_1:\n\t\t/* In this NIC type, the LEDs are reversed.... */\n\t\tpriv->led_activity_on = IPW_ASSOCIATED_LED;\n\t\tpriv->led_activity_off = ~(IPW_ASSOCIATED_LED);\n\t\tpriv->led_association_on = IPW_ACTIVITY_LED;\n\t\tpriv->led_association_off = ~(IPW_ACTIVITY_LED);\n\n\t\tif (!(priv->config & CFG_NO_LED))\n\t\t\tipw_led_band_on(priv);\n\n\t\t/* And we don't blink link LEDs for this nic, so\n\t\t * just return here */\n\t\treturn;\n\n\tcase EEPROM_NIC_TYPE_3:\n\tcase EEPROM_NIC_TYPE_2:\n\tcase EEPROM_NIC_TYPE_4:\n\tcase EEPROM_NIC_TYPE_0:\n\t\tbreak;\n\n\tdefault:\n\t\tIPW_DEBUG_INFO(\"Unknown NIC type from EEPROM: %d\\n\",\n\t\t\t       priv->nic_type);\n\t\tpriv->nic_type = EEPROM_NIC_TYPE_0;\n\t\tbreak;\n\t}\n\n\tif (!(priv->config & CFG_NO_LED)) {\n\t\tif (priv->status & STATUS_ASSOCIATED)\n\t\t\tipw_led_link_on(priv);\n\t\telse\n\t\t\tipw_led_link_off(priv);\n\t}\n}\n\nstatic void ipw_led_shutdown(struct ipw_priv *priv)\n{\n\tipw_led_activity_off(priv);\n\tipw_led_link_off(priv);\n\tipw_led_band_off(priv);\n\tcancel_delayed_work(&priv->led_link_on);\n\tcancel_delayed_work(&priv->led_link_off);\n\tcancel_delayed_work(&priv->led_act_off);\n}\n\n/*\n * The following adds a new attribute to the sysfs representation\n * of this device driver (i.e. a new file in /sys/bus/pci/drivers/ipw/)\n * used for controlling the debug level.\n *\n * See the level definitions in ipw for details.\n */\nstatic ssize_t debug_level_show(struct device_driver *d, char *buf)\n{\n\treturn sprintf(buf, \"0x%08X\\n\", ipw_debug_level);\n}\n\nstatic ssize_t debug_level_store(struct device_driver *d, const char *buf,\n\t\t\t\t size_t count)\n{\n\tchar *p = (char *)buf;\n\tu32 val;\n\n\tif (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {\n\t\tp++;\n\t\tif (p[0] == 'x' || p[0] == 'X')\n\t\t\tp++;\n\t\tval = simple_strtoul(p, &p, 16);\n\t} else\n\t\tval = simple_strtoul(p, &p, 10);\n\tif (p == buf)\n\t\tprintk(KERN_INFO DRV_NAME\n\t\t       \": %s is not in hex or decimal form.\\n\", buf);\n\telse\n\t\tipw_debug_level = val;\n\n\treturn strnlen(buf, count);\n}\nstatic DRIVER_ATTR_RW(debug_level);\n\nstatic inline u32 ipw_get_event_log_len(struct ipw_priv *priv)\n{\n\t/* length = 1st dword in log */\n\treturn ipw_read_reg32(priv, ipw_read32(priv, IPW_EVENT_LOG));\n}\n\nstatic void ipw_capture_event_log(struct ipw_priv *priv,\n\t\t\t\t  u32 log_len, struct ipw_event *log)\n{\n\tu32 base;\n\n\tif (log_len) {\n\t\tbase = ipw_read32(priv, IPW_EVENT_LOG);\n\t\tipw_read_indirect(priv, base + sizeof(base) + sizeof(u32),\n\t\t\t\t  (u8 *) log, sizeof(*log) * log_len);\n\t}\n}\n\nstatic struct ipw_fw_error *ipw_alloc_error_log(struct ipw_priv *priv)\n{\n\tstruct ipw_fw_error *error;\n\tu32 log_len = ipw_get_event_log_len(priv);\n\tu32 base = ipw_read32(priv, IPW_ERROR_LOG);\n\tu32 elem_len = ipw_read_reg32(priv, base);\n\n\terror = kmalloc(sizeof(*error) +\n\t\t\tsizeof(*error->elem) * elem_len +\n\t\t\tsizeof(*error->log) * log_len, GFP_ATOMIC);\n\tif (!error) {\n\t\tIPW_ERROR(\"Memory allocation for firmware error log \"\n\t\t\t  \"failed.\\n\");\n\t\treturn NULL;\n\t}\n\terror->jiffies = jiffies;\n\terror->status = priv->status;\n\terror->config = priv->config;\n\terror->elem_len = elem_len;\n\terror->log_len = log_len;\n\terror->elem = (struct ipw_error_elem *)error->payload;\n\terror->log = (struct ipw_event *)(error->elem + elem_len);\n\n\tipw_capture_event_log(priv, log_len, error->log);\n\n\tif (elem_len)\n\t\tipw_read_indirect(priv, base + sizeof(base), (u8 *) error->elem,\n\t\t\t\t  sizeof(*error->elem) * elem_len);\n\n\treturn error;\n}\n\nstatic ssize_t show_event_log(struct device *d,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tu32 log_len = ipw_get_event_log_len(priv);\n\tu32 log_size;\n\tstruct ipw_event *log;\n\tu32 len = 0, i;\n\n\t/* not using min() because of its strict type checking */\n\tlog_size = PAGE_SIZE / sizeof(*log) > log_len ?\n\t\t\tsizeof(*log) * log_len : PAGE_SIZE;\n\tlog = kzalloc(log_size, GFP_KERNEL);\n\tif (!log) {\n\t\tIPW_ERROR(\"Unable to allocate memory for log\\n\");\n\t\treturn 0;\n\t}\n\tlog_len = log_size / sizeof(*log);\n\tipw_capture_event_log(priv, log_len, log);\n\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%08X\", log_len);\n\tfor (i = 0; i < log_len; i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"\\n%08X%08X%08X\",\n\t\t\t\tlog[i].time, log[i].event, log[i].data);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"\\n\");\n\tkfree(log);\n\treturn len;\n}\n\nstatic DEVICE_ATTR(event_log, 0444, show_event_log, NULL);\n\nstatic ssize_t show_error(struct device *d,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tu32 len = 0, i;\n\tif (!priv->error)\n\t\treturn 0;\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"%08lX%08X%08X%08X\",\n\t\t\tpriv->error->jiffies,\n\t\t\tpriv->error->status,\n\t\t\tpriv->error->config, priv->error->elem_len);\n\tfor (i = 0; i < priv->error->elem_len; i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"\\n%08X%08X%08X%08X%08X%08X%08X\",\n\t\t\t\tpriv->error->elem[i].time,\n\t\t\t\tpriv->error->elem[i].desc,\n\t\t\t\tpriv->error->elem[i].blink1,\n\t\t\t\tpriv->error->elem[i].blink2,\n\t\t\t\tpriv->error->elem[i].link1,\n\t\t\t\tpriv->error->elem[i].link2,\n\t\t\t\tpriv->error->elem[i].data);\n\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"\\n%08X\", priv->error->log_len);\n\tfor (i = 0; i < priv->error->log_len; i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"\\n%08X%08X%08X\",\n\t\t\t\tpriv->error->log[i].time,\n\t\t\t\tpriv->error->log[i].event,\n\t\t\t\tpriv->error->log[i].data);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"\\n\");\n\treturn len;\n}\n\nstatic ssize_t clear_error(struct device *d,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tkfree(priv->error);\n\tpriv->error = NULL;\n\treturn count;\n}\n\nstatic DEVICE_ATTR(error, 0644, show_error, clear_error);\n\nstatic ssize_t show_cmd_log(struct device *d,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tu32 len = 0, i;\n\tif (!priv->cmdlog)\n\t\treturn 0;\n\tfor (i = (priv->cmdlog_pos + 1) % priv->cmdlog_len;\n\t     (i != priv->cmdlog_pos) && (len < PAGE_SIZE);\n\t     i = (i + 1) % priv->cmdlog_len) {\n\t\tlen +=\n\t\t    scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t     \"\\n%08lX%08X%08X%08X\\n\", priv->cmdlog[i].jiffies,\n\t\t\t     priv->cmdlog[i].retcode, priv->cmdlog[i].cmd.cmd,\n\t\t\t     priv->cmdlog[i].cmd.len);\n\t\tlen +=\n\t\t    snprintk_buf(buf + len, PAGE_SIZE - len,\n\t\t\t\t (u8 *) priv->cmdlog[i].cmd.param,\n\t\t\t\t priv->cmdlog[i].cmd.len);\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"\\n\");\n\t}\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"\\n\");\n\treturn len;\n}\n\nstatic DEVICE_ATTR(cmd_log, 0444, show_cmd_log, NULL);\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\nstatic void ipw_prom_free(struct ipw_priv *priv);\nstatic int ipw_prom_alloc(struct ipw_priv *priv);\nstatic ssize_t store_rtap_iface(struct device *d,\n\t\t\t struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tint rc = 0;\n\n\tif (count < 1)\n\t\treturn -EINVAL;\n\n\tswitch (buf[0]) {\n\tcase '0':\n\t\tif (!rtap_iface)\n\t\t\treturn count;\n\n\t\tif (netif_running(priv->prom_net_dev)) {\n\t\t\tIPW_WARNING(\"Interface is up.  Cannot unregister.\\n\");\n\t\t\treturn count;\n\t\t}\n\n\t\tipw_prom_free(priv);\n\t\trtap_iface = 0;\n\t\tbreak;\n\n\tcase '1':\n\t\tif (rtap_iface)\n\t\t\treturn count;\n\n\t\trc = ipw_prom_alloc(priv);\n\t\tif (!rc)\n\t\t\trtap_iface = 1;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (rc) {\n\t\tIPW_ERROR(\"Failed to register promiscuous network \"\n\t\t\t  \"device (error %d).\\n\", rc);\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t show_rtap_iface(struct device *d,\n\t\t\tstruct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tif (rtap_iface)\n\t\treturn sprintf(buf, \"%s\", priv->prom_net_dev->name);\n\telse {\n\t\tbuf[0] = '-';\n\t\tbuf[1] = '1';\n\t\tbuf[2] = '\\0';\n\t\treturn 3;\n\t}\n}\n\nstatic DEVICE_ATTR(rtap_iface, 0600, show_rtap_iface, store_rtap_iface);\n\nstatic ssize_t store_rtap_filter(struct device *d,\n\t\t\t struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tif (!priv->prom_priv) {\n\t\tIPW_ERROR(\"Attempting to set filter without \"\n\t\t\t  \"rtap_iface enabled.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tpriv->prom_priv->filter = simple_strtol(buf, NULL, 0);\n\n\tIPW_DEBUG_INFO(\"Setting rtap filter to \" BIT_FMT16 \"\\n\",\n\t\t       BIT_ARG16(priv->prom_priv->filter));\n\n\treturn count;\n}\n\nstatic ssize_t show_rtap_filter(struct device *d,\n\t\t\tstruct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\treturn sprintf(buf, \"0x%04X\",\n\t\t       priv->prom_priv ? priv->prom_priv->filter : 0);\n}\n\nstatic DEVICE_ATTR(rtap_filter, 0600, show_rtap_filter, store_rtap_filter);\n#endif\n\nstatic ssize_t show_scan_age(struct device *d, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\treturn sprintf(buf, \"%d\\n\", priv->ieee->scan_age);\n}\n\nstatic ssize_t store_scan_age(struct device *d, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tstruct net_device *dev = priv->net_dev;\n\tchar buffer[] = \"00000000\";\n\tunsigned long len =\n\t    (sizeof(buffer) - 1) > count ? count : sizeof(buffer) - 1;\n\tunsigned long val;\n\tchar *p = buffer;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tstrncpy(buffer, buf, len);\n\tbuffer[len] = 0;\n\n\tif (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {\n\t\tp++;\n\t\tif (p[0] == 'x' || p[0] == 'X')\n\t\t\tp++;\n\t\tval = simple_strtoul(p, &p, 16);\n\t} else\n\t\tval = simple_strtoul(p, &p, 10);\n\tif (p == buffer) {\n\t\tIPW_DEBUG_INFO(\"%s: user supplied invalid value.\\n\", dev->name);\n\t} else {\n\t\tpriv->ieee->scan_age = val;\n\t\tIPW_DEBUG_INFO(\"set scan_age = %u\\n\", priv->ieee->scan_age);\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\treturn len;\n}\n\nstatic DEVICE_ATTR(scan_age, 0644, show_scan_age, store_scan_age);\n\nstatic ssize_t show_led(struct device *d, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\treturn sprintf(buf, \"%d\\n\", (priv->config & CFG_NO_LED) ? 0 : 1);\n}\n\nstatic ssize_t store_led(struct device *d, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tif (count == 0)\n\t\treturn 0;\n\n\tif (*buf == 0) {\n\t\tIPW_DEBUG_LED(\"Disabling LED control.\\n\");\n\t\tpriv->config |= CFG_NO_LED;\n\t\tipw_led_shutdown(priv);\n\t} else {\n\t\tIPW_DEBUG_LED(\"Enabling LED control.\\n\");\n\t\tpriv->config &= ~CFG_NO_LED;\n\t\tipw_led_init(priv);\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\treturn count;\n}\n\nstatic DEVICE_ATTR(led, 0644, show_led, store_led);\n\nstatic ssize_t show_status(struct device *d,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\treturn sprintf(buf, \"0x%08x\\n\", (int)p->status);\n}\n\nstatic DEVICE_ATTR(status, 0444, show_status, NULL);\n\nstatic ssize_t show_cfg(struct device *d, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\treturn sprintf(buf, \"0x%08x\\n\", (int)p->config);\n}\n\nstatic DEVICE_ATTR(cfg, 0444, show_cfg, NULL);\n\nstatic ssize_t show_nic_type(struct device *d,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\treturn sprintf(buf, \"TYPE: %d\\n\", priv->nic_type);\n}\n\nstatic DEVICE_ATTR(nic_type, 0444, show_nic_type, NULL);\n\nstatic ssize_t show_ucode_version(struct device *d,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tu32 len = sizeof(u32), tmp = 0;\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\n\tif (ipw_get_ordinal(p, IPW_ORD_STAT_UCODE_VERSION, &tmp, &len))\n\t\treturn 0;\n\n\treturn sprintf(buf, \"0x%08x\\n\", tmp);\n}\n\nstatic DEVICE_ATTR(ucode_version, 0644, show_ucode_version, NULL);\n\nstatic ssize_t show_rtc(struct device *d, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tu32 len = sizeof(u32), tmp = 0;\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\n\tif (ipw_get_ordinal(p, IPW_ORD_STAT_RTC, &tmp, &len))\n\t\treturn 0;\n\n\treturn sprintf(buf, \"0x%08x\\n\", tmp);\n}\n\nstatic DEVICE_ATTR(rtc, 0644, show_rtc, NULL);\n\n/*\n * Add a device attribute to view/control the delay between eeprom\n * operations.\n */\nstatic ssize_t show_eeprom_delay(struct device *d,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\tint n = p->eeprom_delay;\n\treturn sprintf(buf, \"%i\\n\", n);\n}\nstatic ssize_t store_eeprom_delay(struct device *d,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\tsscanf(buf, \"%i\", &p->eeprom_delay);\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(eeprom_delay, 0644, show_eeprom_delay, store_eeprom_delay);\n\nstatic ssize_t show_command_event_reg(struct device *d,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tu32 reg = 0;\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\n\treg = ipw_read_reg32(p, IPW_INTERNAL_CMD_EVENT);\n\treturn sprintf(buf, \"0x%08x\\n\", reg);\n}\nstatic ssize_t store_command_event_reg(struct device *d,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tu32 reg;\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\n\tsscanf(buf, \"%x\", &reg);\n\tipw_write_reg32(p, IPW_INTERNAL_CMD_EVENT, reg);\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(command_event_reg, 0644,\n\t\t   show_command_event_reg, store_command_event_reg);\n\nstatic ssize_t show_mem_gpio_reg(struct device *d,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tu32 reg = 0;\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\n\treg = ipw_read_reg32(p, 0x301100);\n\treturn sprintf(buf, \"0x%08x\\n\", reg);\n}\nstatic ssize_t store_mem_gpio_reg(struct device *d,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tu32 reg;\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\n\tsscanf(buf, \"%x\", &reg);\n\tipw_write_reg32(p, 0x301100, reg);\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(mem_gpio_reg, 0644, show_mem_gpio_reg, store_mem_gpio_reg);\n\nstatic ssize_t show_indirect_dword(struct device *d,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tu32 reg = 0;\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tif (priv->status & STATUS_INDIRECT_DWORD)\n\t\treg = ipw_read_reg32(priv, priv->indirect_dword);\n\telse\n\t\treg = 0;\n\n\treturn sprintf(buf, \"0x%08x\\n\", reg);\n}\nstatic ssize_t store_indirect_dword(struct device *d,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tsscanf(buf, \"%x\", &priv->indirect_dword);\n\tpriv->status |= STATUS_INDIRECT_DWORD;\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(indirect_dword, 0644,\n\t\t   show_indirect_dword, store_indirect_dword);\n\nstatic ssize_t show_indirect_byte(struct device *d,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tu8 reg = 0;\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tif (priv->status & STATUS_INDIRECT_BYTE)\n\t\treg = ipw_read_reg8(priv, priv->indirect_byte);\n\telse\n\t\treg = 0;\n\n\treturn sprintf(buf, \"0x%02x\\n\", reg);\n}\nstatic ssize_t store_indirect_byte(struct device *d,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tsscanf(buf, \"%x\", &priv->indirect_byte);\n\tpriv->status |= STATUS_INDIRECT_BYTE;\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(indirect_byte, 0644,\n\t\t   show_indirect_byte, store_indirect_byte);\n\nstatic ssize_t show_direct_dword(struct device *d,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tu32 reg = 0;\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tif (priv->status & STATUS_DIRECT_DWORD)\n\t\treg = ipw_read32(priv, priv->direct_dword);\n\telse\n\t\treg = 0;\n\n\treturn sprintf(buf, \"0x%08x\\n\", reg);\n}\nstatic ssize_t store_direct_dword(struct device *d,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tsscanf(buf, \"%x\", &priv->direct_dword);\n\tpriv->status |= STATUS_DIRECT_DWORD;\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(direct_dword, 0644, show_direct_dword, store_direct_dword);\n\nstatic int rf_kill_active(struct ipw_priv *priv)\n{\n\tif (0 == (ipw_read32(priv, 0x30) & 0x10000)) {\n\t\tpriv->status |= STATUS_RF_KILL_HW;\n\t\twiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, true);\n\t} else {\n\t\tpriv->status &= ~STATUS_RF_KILL_HW;\n\t\twiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, false);\n\t}\n\n\treturn (priv->status & STATUS_RF_KILL_HW) ? 1 : 0;\n}\n\nstatic ssize_t show_rf_kill(struct device *d, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\t/* 0 - RF kill not enabled\n\t   1 - SW based RF kill active (sysfs)\n\t   2 - HW based RF kill active\n\t   3 - Both HW and SW baed RF kill active */\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tint val = ((priv->status & STATUS_RF_KILL_SW) ? 0x1 : 0x0) |\n\t    (rf_kill_active(priv) ? 0x2 : 0x0);\n\treturn sprintf(buf, \"%i\\n\", val);\n}\n\nstatic int ipw_radio_kill_sw(struct ipw_priv *priv, int disable_radio)\n{\n\tif ((disable_radio ? 1 : 0) ==\n\t    ((priv->status & STATUS_RF_KILL_SW) ? 1 : 0))\n\t\treturn 0;\n\n\tIPW_DEBUG_RF_KILL(\"Manual SW RF Kill set to: RADIO  %s\\n\",\n\t\t\t  disable_radio ? \"OFF\" : \"ON\");\n\n\tif (disable_radio) {\n\t\tpriv->status |= STATUS_RF_KILL_SW;\n\n\t\tcancel_delayed_work(&priv->request_scan);\n\t\tcancel_delayed_work(&priv->request_direct_scan);\n\t\tcancel_delayed_work(&priv->request_passive_scan);\n\t\tcancel_delayed_work(&priv->scan_event);\n\t\tschedule_work(&priv->down);\n\t} else {\n\t\tpriv->status &= ~STATUS_RF_KILL_SW;\n\t\tif (rf_kill_active(priv)) {\n\t\t\tIPW_DEBUG_RF_KILL(\"Can not turn radio back on - \"\n\t\t\t\t\t  \"disabled by HW switch\\n\");\n\t\t\t/* Make sure the RF_KILL check timer is running */\n\t\t\tcancel_delayed_work(&priv->rf_kill);\n\t\t\tschedule_delayed_work(&priv->rf_kill,\n\t\t\t\t\t      round_jiffies_relative(2 * HZ));\n\t\t} else\n\t\t\tschedule_work(&priv->up);\n\t}\n\n\treturn 1;\n}\n\nstatic ssize_t store_rf_kill(struct device *d, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tipw_radio_kill_sw(priv, buf[0] == '1');\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(rf_kill, 0644, show_rf_kill, store_rf_kill);\n\nstatic ssize_t show_speed_scan(struct device *d, struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tint pos = 0, len = 0;\n\tif (priv->config & CFG_SPEED_SCAN) {\n\t\twhile (priv->speed_scan[pos] != 0)\n\t\t\tlen += sprintf(&buf[len], \"%d \",\n\t\t\t\t       priv->speed_scan[pos++]);\n\t\treturn len + sprintf(&buf[len], \"\\n\");\n\t}\n\n\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic ssize_t store_speed_scan(struct device *d, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tint channel, pos = 0;\n\tconst char *p = buf;\n\n\t/* list of space separated channels to scan, optionally ending with 0 */\n\twhile ((channel = simple_strtol(p, NULL, 0))) {\n\t\tif (pos == MAX_SPEED_SCAN - 1) {\n\t\t\tpriv->speed_scan[pos] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (libipw_is_valid_channel(priv->ieee, channel))\n\t\t\tpriv->speed_scan[pos++] = channel;\n\t\telse\n\t\t\tIPW_WARNING(\"Skipping invalid channel request: %d\\n\",\n\t\t\t\t    channel);\n\t\tp = strchr(p, ' ');\n\t\tif (!p)\n\t\t\tbreak;\n\t\twhile (*p == ' ' || *p == '\\t')\n\t\t\tp++;\n\t}\n\n\tif (pos == 0)\n\t\tpriv->config &= ~CFG_SPEED_SCAN;\n\telse {\n\t\tpriv->speed_scan_pos = 0;\n\t\tpriv->config |= CFG_SPEED_SCAN;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(speed_scan, 0644, show_speed_scan, store_speed_scan);\n\nstatic ssize_t show_net_stats(struct device *d, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\treturn sprintf(buf, \"%c\\n\", (priv->config & CFG_NET_STATS) ? '1' : '0');\n}\n\nstatic ssize_t store_net_stats(struct device *d, struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tif (buf[0] == '1')\n\t\tpriv->config |= CFG_NET_STATS;\n\telse\n\t\tpriv->config &= ~CFG_NET_STATS;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(net_stats, 0644, show_net_stats, store_net_stats);\n\nstatic ssize_t show_channels(struct device *d,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\n\tint len = 0, i;\n\n\tlen = sprintf(&buf[len],\n\t\t      \"Displaying %d channels in 2.4Ghz band \"\n\t\t      \"(802.11bg):\\n\", geo->bg_channels);\n\n\tfor (i = 0; i < geo->bg_channels; i++) {\n\t\tlen += sprintf(&buf[len], \"%d: BSS%s%s, %s, Band %s.\\n\",\n\t\t\t       geo->bg[i].channel,\n\t\t\t       geo->bg[i].flags & LIBIPW_CH_RADAR_DETECT ?\n\t\t\t       \" (radar spectrum)\" : \"\",\n\t\t\t       ((geo->bg[i].flags & LIBIPW_CH_NO_IBSS) ||\n\t\t\t\t(geo->bg[i].flags & LIBIPW_CH_RADAR_DETECT))\n\t\t\t       ? \"\" : \", IBSS\",\n\t\t\t       geo->bg[i].flags & LIBIPW_CH_PASSIVE_ONLY ?\n\t\t\t       \"passive only\" : \"active/passive\",\n\t\t\t       geo->bg[i].flags & LIBIPW_CH_B_ONLY ?\n\t\t\t       \"B\" : \"B/G\");\n\t}\n\n\tlen += sprintf(&buf[len],\n\t\t       \"Displaying %d channels in 5.2Ghz band \"\n\t\t       \"(802.11a):\\n\", geo->a_channels);\n\tfor (i = 0; i < geo->a_channels; i++) {\n\t\tlen += sprintf(&buf[len], \"%d: BSS%s%s, %s.\\n\",\n\t\t\t       geo->a[i].channel,\n\t\t\t       geo->a[i].flags & LIBIPW_CH_RADAR_DETECT ?\n\t\t\t       \" (radar spectrum)\" : \"\",\n\t\t\t       ((geo->a[i].flags & LIBIPW_CH_NO_IBSS) ||\n\t\t\t\t(geo->a[i].flags & LIBIPW_CH_RADAR_DETECT))\n\t\t\t       ? \"\" : \", IBSS\",\n\t\t\t       geo->a[i].flags & LIBIPW_CH_PASSIVE_ONLY ?\n\t\t\t       \"passive only\" : \"active/passive\");\n\t}\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(channels, 0400, show_channels, NULL);\n\nstatic void notify_wx_assoc_event(struct ipw_priv *priv)\n{\n\tunion iwreq_data wrqu;\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\tif (priv->status & STATUS_ASSOCIATED)\n\t\tmemcpy(wrqu.ap_addr.sa_data, priv->bssid, ETH_ALEN);\n\telse\n\t\teth_zero_addr(wrqu.ap_addr.sa_data);\n\twireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);\n}\n\nstatic void ipw_irq_tasklet(struct tasklet_struct *t)\n{\n\tstruct ipw_priv *priv = from_tasklet(priv, t, irq_tasklet);\n\tu32 inta, inta_mask, handled = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->irq_lock, flags);\n\n\tinta = ipw_read32(priv, IPW_INTA_RW);\n\tinta_mask = ipw_read32(priv, IPW_INTA_MASK_R);\n\n\tif (inta == 0xFFFFFFFF) {\n\t\t/* Hardware disappeared */\n\t\tIPW_WARNING(\"TASKLET INTA == 0xFFFFFFFF\\n\");\n\t\t/* Only handle the cached INTA values */\n\t\tinta = 0;\n\t}\n\tinta &= (IPW_INTA_MASK_ALL & inta_mask);\n\n\t/* Add any cached INTA values that need to be handled */\n\tinta |= priv->isr_inta;\n\n\tspin_unlock_irqrestore(&priv->irq_lock, flags);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\t/* handle all the justifications for the interrupt */\n\tif (inta & IPW_INTA_BIT_RX_TRANSFER) {\n\t\tipw_rx(priv);\n\t\thandled |= IPW_INTA_BIT_RX_TRANSFER;\n\t}\n\n\tif (inta & IPW_INTA_BIT_TX_CMD_QUEUE) {\n\t\tIPW_DEBUG_HC(\"Command completed.\\n\");\n\t\tipw_queue_tx_reclaim(priv, &priv->txq_cmd, -1);\n\t\tpriv->status &= ~STATUS_HCMD_ACTIVE;\n\t\twake_up_interruptible(&priv->wait_command_queue);\n\t\thandled |= IPW_INTA_BIT_TX_CMD_QUEUE;\n\t}\n\n\tif (inta & IPW_INTA_BIT_TX_QUEUE_1) {\n\t\tIPW_DEBUG_TX(\"TX_QUEUE_1\\n\");\n\t\tipw_queue_tx_reclaim(priv, &priv->txq[0], 0);\n\t\thandled |= IPW_INTA_BIT_TX_QUEUE_1;\n\t}\n\n\tif (inta & IPW_INTA_BIT_TX_QUEUE_2) {\n\t\tIPW_DEBUG_TX(\"TX_QUEUE_2\\n\");\n\t\tipw_queue_tx_reclaim(priv, &priv->txq[1], 1);\n\t\thandled |= IPW_INTA_BIT_TX_QUEUE_2;\n\t}\n\n\tif (inta & IPW_INTA_BIT_TX_QUEUE_3) {\n\t\tIPW_DEBUG_TX(\"TX_QUEUE_3\\n\");\n\t\tipw_queue_tx_reclaim(priv, &priv->txq[2], 2);\n\t\thandled |= IPW_INTA_BIT_TX_QUEUE_3;\n\t}\n\n\tif (inta & IPW_INTA_BIT_TX_QUEUE_4) {\n\t\tIPW_DEBUG_TX(\"TX_QUEUE_4\\n\");\n\t\tipw_queue_tx_reclaim(priv, &priv->txq[3], 3);\n\t\thandled |= IPW_INTA_BIT_TX_QUEUE_4;\n\t}\n\n\tif (inta & IPW_INTA_BIT_STATUS_CHANGE) {\n\t\tIPW_WARNING(\"STATUS_CHANGE\\n\");\n\t\thandled |= IPW_INTA_BIT_STATUS_CHANGE;\n\t}\n\n\tif (inta & IPW_INTA_BIT_BEACON_PERIOD_EXPIRED) {\n\t\tIPW_WARNING(\"TX_PERIOD_EXPIRED\\n\");\n\t\thandled |= IPW_INTA_BIT_BEACON_PERIOD_EXPIRED;\n\t}\n\n\tif (inta & IPW_INTA_BIT_SLAVE_MODE_HOST_CMD_DONE) {\n\t\tIPW_WARNING(\"HOST_CMD_DONE\\n\");\n\t\thandled |= IPW_INTA_BIT_SLAVE_MODE_HOST_CMD_DONE;\n\t}\n\n\tif (inta & IPW_INTA_BIT_FW_INITIALIZATION_DONE) {\n\t\tIPW_WARNING(\"FW_INITIALIZATION_DONE\\n\");\n\t\thandled |= IPW_INTA_BIT_FW_INITIALIZATION_DONE;\n\t}\n\n\tif (inta & IPW_INTA_BIT_FW_CARD_DISABLE_PHY_OFF_DONE) {\n\t\tIPW_WARNING(\"PHY_OFF_DONE\\n\");\n\t\thandled |= IPW_INTA_BIT_FW_CARD_DISABLE_PHY_OFF_DONE;\n\t}\n\n\tif (inta & IPW_INTA_BIT_RF_KILL_DONE) {\n\t\tIPW_DEBUG_RF_KILL(\"RF_KILL_DONE\\n\");\n\t\tpriv->status |= STATUS_RF_KILL_HW;\n\t\twiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, true);\n\t\twake_up_interruptible(&priv->wait_command_queue);\n\t\tpriv->status &= ~(STATUS_ASSOCIATED | STATUS_ASSOCIATING);\n\t\tcancel_delayed_work(&priv->request_scan);\n\t\tcancel_delayed_work(&priv->request_direct_scan);\n\t\tcancel_delayed_work(&priv->request_passive_scan);\n\t\tcancel_delayed_work(&priv->scan_event);\n\t\tschedule_work(&priv->link_down);\n\t\tschedule_delayed_work(&priv->rf_kill, 2 * HZ);\n\t\thandled |= IPW_INTA_BIT_RF_KILL_DONE;\n\t}\n\n\tif (inta & IPW_INTA_BIT_FATAL_ERROR) {\n\t\tIPW_WARNING(\"Firmware error detected.  Restarting.\\n\");\n\t\tif (priv->error) {\n\t\t\tIPW_DEBUG_FW(\"Sysfs 'error' log already exists.\\n\");\n\t\t\tif (ipw_debug_level & IPW_DL_FW_ERRORS) {\n\t\t\t\tstruct ipw_fw_error *error =\n\t\t\t\t    ipw_alloc_error_log(priv);\n\t\t\t\tipw_dump_error_log(priv, error);\n\t\t\t\tkfree(error);\n\t\t\t}\n\t\t} else {\n\t\t\tpriv->error = ipw_alloc_error_log(priv);\n\t\t\tif (priv->error)\n\t\t\t\tIPW_DEBUG_FW(\"Sysfs 'error' log captured.\\n\");\n\t\t\telse\n\t\t\t\tIPW_DEBUG_FW(\"Error allocating sysfs 'error' \"\n\t\t\t\t\t     \"log.\\n\");\n\t\t\tif (ipw_debug_level & IPW_DL_FW_ERRORS)\n\t\t\t\tipw_dump_error_log(priv, priv->error);\n\t\t}\n\n\t\t/* XXX: If hardware encryption is for WPA/WPA2,\n\t\t * we have to notify the supplicant. */\n\t\tif (priv->ieee->sec.encrypt) {\n\t\t\tpriv->status &= ~STATUS_ASSOCIATED;\n\t\t\tnotify_wx_assoc_event(priv);\n\t\t}\n\n\t\t/* Keep the restart process from trying to send host\n\t\t * commands by clearing the INIT status bit */\n\t\tpriv->status &= ~STATUS_INIT;\n\n\t\t/* Cancel currently queued command. */\n\t\tpriv->status &= ~STATUS_HCMD_ACTIVE;\n\t\twake_up_interruptible(&priv->wait_command_queue);\n\n\t\tschedule_work(&priv->adapter_restart);\n\t\thandled |= IPW_INTA_BIT_FATAL_ERROR;\n\t}\n\n\tif (inta & IPW_INTA_BIT_PARITY_ERROR) {\n\t\tIPW_ERROR(\"Parity error\\n\");\n\t\thandled |= IPW_INTA_BIT_PARITY_ERROR;\n\t}\n\n\tif (handled != inta) {\n\t\tIPW_ERROR(\"Unhandled INTA bits 0x%08x\\n\", inta & ~handled);\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t/* enable all interrupts */\n\tipw_enable_interrupts(priv);\n}\n\n#define IPW_CMD(x) case IPW_CMD_ ## x : return #x\nstatic char *get_cmd_string(u8 cmd)\n{\n\tswitch (cmd) {\n\t\tIPW_CMD(HOST_COMPLETE);\n\t\tIPW_CMD(POWER_DOWN);\n\t\tIPW_CMD(SYSTEM_CONFIG);\n\t\tIPW_CMD(MULTICAST_ADDRESS);\n\t\tIPW_CMD(SSID);\n\t\tIPW_CMD(ADAPTER_ADDRESS);\n\t\tIPW_CMD(PORT_TYPE);\n\t\tIPW_CMD(RTS_THRESHOLD);\n\t\tIPW_CMD(FRAG_THRESHOLD);\n\t\tIPW_CMD(POWER_MODE);\n\t\tIPW_CMD(WEP_KEY);\n\t\tIPW_CMD(TGI_TX_KEY);\n\t\tIPW_CMD(SCAN_REQUEST);\n\t\tIPW_CMD(SCAN_REQUEST_EXT);\n\t\tIPW_CMD(ASSOCIATE);\n\t\tIPW_CMD(SUPPORTED_RATES);\n\t\tIPW_CMD(SCAN_ABORT);\n\t\tIPW_CMD(TX_FLUSH);\n\t\tIPW_CMD(QOS_PARAMETERS);\n\t\tIPW_CMD(DINO_CONFIG);\n\t\tIPW_CMD(RSN_CAPABILITIES);\n\t\tIPW_CMD(RX_KEY);\n\t\tIPW_CMD(CARD_DISABLE);\n\t\tIPW_CMD(SEED_NUMBER);\n\t\tIPW_CMD(TX_POWER);\n\t\tIPW_CMD(COUNTRY_INFO);\n\t\tIPW_CMD(AIRONET_INFO);\n\t\tIPW_CMD(AP_TX_POWER);\n\t\tIPW_CMD(CCKM_INFO);\n\t\tIPW_CMD(CCX_VER_INFO);\n\t\tIPW_CMD(SET_CALIBRATION);\n\t\tIPW_CMD(SENSITIVITY_CALIB);\n\t\tIPW_CMD(RETRY_LIMIT);\n\t\tIPW_CMD(IPW_PRE_POWER_DOWN);\n\t\tIPW_CMD(VAP_BEACON_TEMPLATE);\n\t\tIPW_CMD(VAP_DTIM_PERIOD);\n\t\tIPW_CMD(EXT_SUPPORTED_RATES);\n\t\tIPW_CMD(VAP_LOCAL_TX_PWR_CONSTRAINT);\n\t\tIPW_CMD(VAP_QUIET_INTERVALS);\n\t\tIPW_CMD(VAP_CHANNEL_SWITCH);\n\t\tIPW_CMD(VAP_MANDATORY_CHANNELS);\n\t\tIPW_CMD(VAP_CELL_PWR_LIMIT);\n\t\tIPW_CMD(VAP_CF_PARAM_SET);\n\t\tIPW_CMD(VAP_SET_BEACONING_STATE);\n\t\tIPW_CMD(MEASUREMENT);\n\t\tIPW_CMD(POWER_CAPABILITY);\n\t\tIPW_CMD(SUPPORTED_CHANNELS);\n\t\tIPW_CMD(TPC_REPORT);\n\t\tIPW_CMD(WME_INFO);\n\t\tIPW_CMD(PRODUCTION_COMMAND);\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\n#define HOST_COMPLETE_TIMEOUT HZ\n\nstatic int __ipw_send_cmd(struct ipw_priv *priv, struct host_cmd *cmd)\n{\n\tint rc = 0;\n\tunsigned long flags;\n\tunsigned long now, end;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (priv->status & STATUS_HCMD_ACTIVE) {\n\t\tIPW_ERROR(\"Failed to send %s: Already sending a command.\\n\",\n\t\t\t  get_cmd_string(cmd->cmd));\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\n\tpriv->status |= STATUS_HCMD_ACTIVE;\n\n\tif (priv->cmdlog) {\n\t\tpriv->cmdlog[priv->cmdlog_pos].jiffies = jiffies;\n\t\tpriv->cmdlog[priv->cmdlog_pos].cmd.cmd = cmd->cmd;\n\t\tpriv->cmdlog[priv->cmdlog_pos].cmd.len = cmd->len;\n\t\tmemcpy(priv->cmdlog[priv->cmdlog_pos].cmd.param, cmd->param,\n\t\t       cmd->len);\n\t\tpriv->cmdlog[priv->cmdlog_pos].retcode = -1;\n\t}\n\n\tIPW_DEBUG_HC(\"%s command (#%d) %d bytes: 0x%08X\\n\",\n\t\t     get_cmd_string(cmd->cmd), cmd->cmd, cmd->len,\n\t\t     priv->status);\n\n#ifndef DEBUG_CMD_WEP_KEY\n\tif (cmd->cmd == IPW_CMD_WEP_KEY)\n\t\tIPW_DEBUG_HC(\"WEP_KEY command masked out for secure.\\n\");\n\telse\n#endif\n\t\tprintk_buf(IPW_DL_HOST_COMMAND, (u8 *) cmd->param, cmd->len);\n\n\trc = ipw_queue_tx_hcmd(priv, cmd->cmd, cmd->param, cmd->len, 0);\n\tif (rc) {\n\t\tpriv->status &= ~STATUS_HCMD_ACTIVE;\n\t\tIPW_ERROR(\"Failed to send %s: Reason %d\\n\",\n\t\t\t  get_cmd_string(cmd->cmd), rc);\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tgoto exit;\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tnow = jiffies;\n\tend = now + HOST_COMPLETE_TIMEOUT;\nagain:\n\trc = wait_event_interruptible_timeout(priv->wait_command_queue,\n\t\t\t\t\t      !(priv->\n\t\t\t\t\t\tstatus & STATUS_HCMD_ACTIVE),\n\t\t\t\t\t      end - now);\n\tif (rc < 0) {\n\t\tnow = jiffies;\n\t\tif (time_before(now, end))\n\t\t\tgoto again;\n\t\trc = 0;\n\t}\n\n\tif (rc == 0) {\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\tif (priv->status & STATUS_HCMD_ACTIVE) {\n\t\t\tIPW_ERROR(\"Failed to send %s: Command timed out.\\n\",\n\t\t\t\t  get_cmd_string(cmd->cmd));\n\t\t\tpriv->status &= ~STATUS_HCMD_ACTIVE;\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\trc = -EIO;\n\t\t\tgoto exit;\n\t\t}\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t} else\n\t\trc = 0;\n\n\tif (priv->status & STATUS_RF_KILL_HW) {\n\t\tIPW_ERROR(\"Failed to send %s: Aborted due to RF kill switch.\\n\",\n\t\t\t  get_cmd_string(cmd->cmd));\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n      exit:\n\tif (priv->cmdlog) {\n\t\tpriv->cmdlog[priv->cmdlog_pos++].retcode = rc;\n\t\tpriv->cmdlog_pos %= priv->cmdlog_len;\n\t}\n\treturn rc;\n}\n\nstatic int ipw_send_cmd_simple(struct ipw_priv *priv, u8 command)\n{\n\tstruct host_cmd cmd = {\n\t\t.cmd = command,\n\t};\n\n\treturn __ipw_send_cmd(priv, &cmd);\n}\n\nstatic int ipw_send_cmd_pdu(struct ipw_priv *priv, u8 command, u8 len,\n\t\t\t    void *data)\n{\n\tstruct host_cmd cmd = {\n\t\t.cmd = command,\n\t\t.len = len,\n\t\t.param = data,\n\t};\n\n\treturn __ipw_send_cmd(priv, &cmd);\n}\n\nstatic int ipw_send_host_complete(struct ipw_priv *priv)\n{\n\tif (!priv) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_simple(priv, IPW_CMD_HOST_COMPLETE);\n}\n\nstatic int ipw_send_system_config(struct ipw_priv *priv)\n{\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_SYSTEM_CONFIG,\n\t\t\t\tsizeof(priv->sys_config),\n\t\t\t\t&priv->sys_config);\n}\n\nstatic int ipw_send_ssid(struct ipw_priv *priv, u8 * ssid, int len)\n{\n\tif (!priv || !ssid) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_SSID, min(len, IW_ESSID_MAX_SIZE),\n\t\t\t\tssid);\n}\n\nstatic int ipw_send_adapter_address(struct ipw_priv *priv, u8 * mac)\n{\n\tif (!priv || !mac) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\tIPW_DEBUG_INFO(\"%s: Setting MAC to %pM\\n\",\n\t\t       priv->net_dev->name, mac);\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_ADAPTER_ADDRESS, ETH_ALEN, mac);\n}\n\nstatic void ipw_adapter_restart(void *adapter)\n{\n\tstruct ipw_priv *priv = adapter;\n\n\tif (priv->status & STATUS_RF_KILL_MASK)\n\t\treturn;\n\n\tipw_down(priv);\n\n\tif (priv->assoc_network &&\n\t    (priv->assoc_network->capability & WLAN_CAPABILITY_IBSS))\n\t\tipw_remove_current_network(priv);\n\n\tif (ipw_up(priv)) {\n\t\tIPW_ERROR(\"Failed to up device\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void ipw_bg_adapter_restart(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, adapter_restart);\n\tmutex_lock(&priv->mutex);\n\tipw_adapter_restart(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_abort_scan(struct ipw_priv *priv);\n\n#define IPW_SCAN_CHECK_WATCHDOG\t(5 * HZ)\n\nstatic void ipw_scan_check(void *data)\n{\n\tstruct ipw_priv *priv = data;\n\n\tif (priv->status & STATUS_SCAN_ABORTING) {\n\t\tIPW_DEBUG_SCAN(\"Scan completion watchdog resetting \"\n\t\t\t       \"adapter after (%dms).\\n\",\n\t\t\t       jiffies_to_msecs(IPW_SCAN_CHECK_WATCHDOG));\n\t\tschedule_work(&priv->adapter_restart);\n\t} else if (priv->status & STATUS_SCANNING) {\n\t\tIPW_DEBUG_SCAN(\"Scan completion watchdog aborting scan \"\n\t\t\t       \"after (%dms).\\n\",\n\t\t\t       jiffies_to_msecs(IPW_SCAN_CHECK_WATCHDOG));\n\t\tipw_abort_scan(priv);\n\t\tschedule_delayed_work(&priv->scan_check, HZ);\n\t}\n}\n\nstatic void ipw_bg_scan_check(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, scan_check.work);\n\tmutex_lock(&priv->mutex);\n\tipw_scan_check(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int ipw_send_scan_request_ext(struct ipw_priv *priv,\n\t\t\t\t     struct ipw_scan_request_ext *request)\n{\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_SCAN_REQUEST_EXT,\n\t\t\t\tsizeof(*request), request);\n}\n\nstatic int ipw_send_scan_abort(struct ipw_priv *priv)\n{\n\tif (!priv) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_simple(priv, IPW_CMD_SCAN_ABORT);\n}\n\nstatic int ipw_set_sensitivity(struct ipw_priv *priv, u16 sens)\n{\n\tstruct ipw_sensitivity_calib calib = {\n\t\t.beacon_rssi_raw = cpu_to_le16(sens),\n\t};\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_SENSITIVITY_CALIB, sizeof(calib),\n\t\t\t\t&calib);\n}\n\nstatic int ipw_send_associate(struct ipw_priv *priv,\n\t\t\t      struct ipw_associate *associate)\n{\n\tif (!priv || !associate) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_ASSOCIATE, sizeof(*associate),\n\t\t\t\tassociate);\n}\n\nstatic int ipw_send_supported_rates(struct ipw_priv *priv,\n\t\t\t\t    struct ipw_supported_rates *rates)\n{\n\tif (!priv || !rates) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_SUPPORTED_RATES, sizeof(*rates),\n\t\t\t\trates);\n}\n\nstatic int ipw_set_random_seed(struct ipw_priv *priv)\n{\n\tu32 val;\n\n\tif (!priv) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\tget_random_bytes(&val, sizeof(val));\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_SEED_NUMBER, sizeof(val), &val);\n}\n\nstatic int ipw_send_card_disable(struct ipw_priv *priv, u32 phy_off)\n{\n\t__le32 v = cpu_to_le32(phy_off);\n\tif (!priv) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_CARD_DISABLE, sizeof(v), &v);\n}\n\nstatic int ipw_send_tx_power(struct ipw_priv *priv, struct ipw_tx_power *power)\n{\n\tif (!priv || !power) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_TX_POWER, sizeof(*power), power);\n}\n\nstatic int ipw_set_tx_power(struct ipw_priv *priv)\n{\n\tconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\n\tstruct ipw_tx_power tx_power;\n\ts8 max_power;\n\tint i;\n\n\tmemset(&tx_power, 0, sizeof(tx_power));\n\n\t/* configure device for 'G' band */\n\ttx_power.ieee_mode = IPW_G_MODE;\n\ttx_power.num_channels = geo->bg_channels;\n\tfor (i = 0; i < geo->bg_channels; i++) {\n\t\tmax_power = geo->bg[i].max_power;\n\t\ttx_power.channels_tx_power[i].channel_number =\n\t\t    geo->bg[i].channel;\n\t\ttx_power.channels_tx_power[i].tx_power = max_power ?\n\t\t    min(max_power, priv->tx_power) : priv->tx_power;\n\t}\n\tif (ipw_send_tx_power(priv, &tx_power))\n\t\treturn -EIO;\n\n\t/* configure device to also handle 'B' band */\n\ttx_power.ieee_mode = IPW_B_MODE;\n\tif (ipw_send_tx_power(priv, &tx_power))\n\t\treturn -EIO;\n\n\t/* configure device to also handle 'A' band */\n\tif (priv->ieee->abg_true) {\n\t\ttx_power.ieee_mode = IPW_A_MODE;\n\t\ttx_power.num_channels = geo->a_channels;\n\t\tfor (i = 0; i < tx_power.num_channels; i++) {\n\t\t\tmax_power = geo->a[i].max_power;\n\t\t\ttx_power.channels_tx_power[i].channel_number =\n\t\t\t    geo->a[i].channel;\n\t\t\ttx_power.channels_tx_power[i].tx_power = max_power ?\n\t\t\t    min(max_power, priv->tx_power) : priv->tx_power;\n\t\t}\n\t\tif (ipw_send_tx_power(priv, &tx_power))\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int ipw_send_rts_threshold(struct ipw_priv *priv, u16 rts)\n{\n\tstruct ipw_rts_threshold rts_threshold = {\n\t\t.rts_threshold = cpu_to_le16(rts),\n\t};\n\n\tif (!priv) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_RTS_THRESHOLD,\n\t\t\t\tsizeof(rts_threshold), &rts_threshold);\n}\n\nstatic int ipw_send_frag_threshold(struct ipw_priv *priv, u16 frag)\n{\n\tstruct ipw_frag_threshold frag_threshold = {\n\t\t.frag_threshold = cpu_to_le16(frag),\n\t};\n\n\tif (!priv) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_FRAG_THRESHOLD,\n\t\t\t\tsizeof(frag_threshold), &frag_threshold);\n}\n\nstatic int ipw_send_power_mode(struct ipw_priv *priv, u32 mode)\n{\n\t__le32 param;\n\n\tif (!priv) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\t/* If on battery, set to 3, if AC set to CAM, else user\n\t * level */\n\tswitch (mode) {\n\tcase IPW_POWER_BATTERY:\n\t\tparam = cpu_to_le32(IPW_POWER_INDEX_3);\n\t\tbreak;\n\tcase IPW_POWER_AC:\n\t\tparam = cpu_to_le32(IPW_POWER_MODE_CAM);\n\t\tbreak;\n\tdefault:\n\t\tparam = cpu_to_le32(mode);\n\t\tbreak;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_POWER_MODE, sizeof(param),\n\t\t\t\t&param);\n}\n\nstatic int ipw_send_retry_limit(struct ipw_priv *priv, u8 slimit, u8 llimit)\n{\n\tstruct ipw_retry_limit retry_limit = {\n\t\t.short_retry_limit = slimit,\n\t\t.long_retry_limit = llimit\n\t};\n\n\tif (!priv) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_RETRY_LIMIT, sizeof(retry_limit),\n\t\t\t\t&retry_limit);\n}\n\n/*\n * The IPW device contains a Microwire compatible EEPROM that stores\n * various data like the MAC address.  Usually the firmware has exclusive\n * access to the eeprom, but during device initialization (before the\n * device driver has sent the HostComplete command to the firmware) the\n * device driver has read access to the EEPROM by way of indirect addressing\n * through a couple of memory mapped registers.\n *\n * The following is a simplified implementation for pulling data out of the\n * the eeprom, along with some helper functions to find information in\n * the per device private data's copy of the eeprom.\n *\n * NOTE: To better understand how these functions work (i.e what is a chip\n *       select and why do have to keep driving the eeprom clock?), read\n *       just about any data sheet for a Microwire compatible EEPROM.\n */\n\n/* write a 32 bit value into the indirect accessor register */\nstatic inline void eeprom_write_reg(struct ipw_priv *p, u32 data)\n{\n\tipw_write_reg32(p, FW_MEM_REG_EEPROM_ACCESS, data);\n\n\t/* the eeprom requires some time to complete the operation */\n\tudelay(p->eeprom_delay);\n}\n\n/* perform a chip select operation */\nstatic void eeprom_cs(struct ipw_priv *priv)\n{\n\teeprom_write_reg(priv, 0);\n\teeprom_write_reg(priv, EEPROM_BIT_CS);\n\teeprom_write_reg(priv, EEPROM_BIT_CS | EEPROM_BIT_SK);\n\teeprom_write_reg(priv, EEPROM_BIT_CS);\n}\n\n/* perform a chip select operation */\nstatic void eeprom_disable_cs(struct ipw_priv *priv)\n{\n\teeprom_write_reg(priv, EEPROM_BIT_CS);\n\teeprom_write_reg(priv, 0);\n\teeprom_write_reg(priv, EEPROM_BIT_SK);\n}\n\n/* push a single bit down to the eeprom */\nstatic inline void eeprom_write_bit(struct ipw_priv *p, u8 bit)\n{\n\tint d = (bit ? EEPROM_BIT_DI : 0);\n\teeprom_write_reg(p, EEPROM_BIT_CS | d);\n\teeprom_write_reg(p, EEPROM_BIT_CS | d | EEPROM_BIT_SK);\n}\n\n/* push an opcode followed by an address down to the eeprom */\nstatic void eeprom_op(struct ipw_priv *priv, u8 op, u8 addr)\n{\n\tint i;\n\n\teeprom_cs(priv);\n\teeprom_write_bit(priv, 1);\n\teeprom_write_bit(priv, op & 2);\n\teeprom_write_bit(priv, op & 1);\n\tfor (i = 7; i >= 0; i--) {\n\t\teeprom_write_bit(priv, addr & (1 << i));\n\t}\n}\n\n/* pull 16 bits off the eeprom, one bit at a time */\nstatic u16 eeprom_read_u16(struct ipw_priv *priv, u8 addr)\n{\n\tint i;\n\tu16 r = 0;\n\n\t/* Send READ Opcode */\n\teeprom_op(priv, EEPROM_CMD_READ, addr);\n\n\t/* Send dummy bit */\n\teeprom_write_reg(priv, EEPROM_BIT_CS);\n\n\t/* Read the byte off the eeprom one bit at a time */\n\tfor (i = 0; i < 16; i++) {\n\t\tu32 data = 0;\n\t\teeprom_write_reg(priv, EEPROM_BIT_CS | EEPROM_BIT_SK);\n\t\teeprom_write_reg(priv, EEPROM_BIT_CS);\n\t\tdata = ipw_read_reg32(priv, FW_MEM_REG_EEPROM_ACCESS);\n\t\tr = (r << 1) | ((data & EEPROM_BIT_DO) ? 1 : 0);\n\t}\n\n\t/* Send another dummy bit */\n\teeprom_write_reg(priv, 0);\n\teeprom_disable_cs(priv);\n\n\treturn r;\n}\n\n/* helper function for pulling the mac address out of the private */\n/* data's copy of the eeprom data                                 */\nstatic void eeprom_parse_mac(struct ipw_priv *priv, u8 * mac)\n{\n\tmemcpy(mac, &priv->eeprom[EEPROM_MAC_ADDRESS], ETH_ALEN);\n}\n\nstatic void ipw_read_eeprom(struct ipw_priv *priv)\n{\n\tint i;\n\t__le16 *eeprom = (__le16 *) priv->eeprom;\n\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\n\t/* read entire contents of eeprom into private buffer */\n\tfor (i = 0; i < 128; i++)\n\t\teeprom[i] = cpu_to_le16(eeprom_read_u16(priv, (u8) i));\n\n\tIPW_DEBUG_TRACE(\"<<\\n\");\n}\n\n/*\n * Either the device driver (i.e. the host) or the firmware can\n * load eeprom data into the designated region in SRAM.  If neither\n * happens then the FW will shutdown with a fatal error.\n *\n * In order to signal the FW to load the EEPROM, the EEPROM_LOAD_DISABLE\n * bit needs region of shared SRAM needs to be non-zero.\n */\nstatic void ipw_eeprom_init_sram(struct ipw_priv *priv)\n{\n\tint i;\n\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\n\t/*\n\t   If the data looks correct, then copy it to our private\n\t   copy.  Otherwise let the firmware know to perform the operation\n\t   on its own.\n\t */\n\tif (priv->eeprom[EEPROM_VERSION] != 0) {\n\t\tIPW_DEBUG_INFO(\"Writing EEPROM data into SRAM\\n\");\n\n\t\t/* write the eeprom data to sram */\n\t\tfor (i = 0; i < IPW_EEPROM_IMAGE_SIZE; i++)\n\t\t\tipw_write8(priv, IPW_EEPROM_DATA + i, priv->eeprom[i]);\n\n\t\t/* Do not load eeprom data on fatal error or suspend */\n\t\tipw_write32(priv, IPW_EEPROM_LOAD_DISABLE, 0);\n\t} else {\n\t\tIPW_DEBUG_INFO(\"Enabling FW initialization of SRAM\\n\");\n\n\t\t/* Load eeprom data on fatal error or suspend */\n\t\tipw_write32(priv, IPW_EEPROM_LOAD_DISABLE, 1);\n\t}\n\n\tIPW_DEBUG_TRACE(\"<<\\n\");\n}\n\nstatic void ipw_zero_memory(struct ipw_priv *priv, u32 start, u32 count)\n{\n\tcount >>= 2;\n\tif (!count)\n\t\treturn;\n\t_ipw_write32(priv, IPW_AUTOINC_ADDR, start);\n\twhile (count--)\n\t\t_ipw_write32(priv, IPW_AUTOINC_DATA, 0);\n}\n\nstatic inline void ipw_fw_dma_reset_command_blocks(struct ipw_priv *priv)\n{\n\tipw_zero_memory(priv, IPW_SHARED_SRAM_DMA_CONTROL,\n\t\t\tCB_NUMBER_OF_ELEMENTS_SMALL *\n\t\t\tsizeof(struct command_block));\n}\n\nstatic int ipw_fw_dma_enable(struct ipw_priv *priv)\n{\t\t\t\t/* start dma engine but no transfers yet */\n\n\tIPW_DEBUG_FW(\">> :\\n\");\n\n\t/* Start the dma */\n\tipw_fw_dma_reset_command_blocks(priv);\n\n\t/* Write CB base address */\n\tipw_write_reg32(priv, IPW_DMA_I_CB_BASE, IPW_SHARED_SRAM_DMA_CONTROL);\n\n\tIPW_DEBUG_FW(\"<< :\\n\");\n\treturn 0;\n}\n\nstatic void ipw_fw_dma_abort(struct ipw_priv *priv)\n{\n\tu32 control = 0;\n\n\tIPW_DEBUG_FW(\">> :\\n\");\n\n\t/* set the Stop and Abort bit */\n\tcontrol = DMA_CONTROL_SMALL_CB_CONST_VALUE | DMA_CB_STOP_AND_ABORT;\n\tipw_write_reg32(priv, IPW_DMA_I_DMA_CONTROL, control);\n\tpriv->sram_desc.last_cb_index = 0;\n\n\tIPW_DEBUG_FW(\"<<\\n\");\n}\n\nstatic int ipw_fw_dma_write_command_block(struct ipw_priv *priv, int index,\n\t\t\t\t\t  struct command_block *cb)\n{\n\tu32 address =\n\t    IPW_SHARED_SRAM_DMA_CONTROL +\n\t    (sizeof(struct command_block) * index);\n\tIPW_DEBUG_FW(\">> :\\n\");\n\n\tipw_write_indirect(priv, address, (u8 *) cb,\n\t\t\t   (int)sizeof(struct command_block));\n\n\tIPW_DEBUG_FW(\"<< :\\n\");\n\treturn 0;\n\n}\n\nstatic int ipw_fw_dma_kick(struct ipw_priv *priv)\n{\n\tu32 control = 0;\n\tu32 index = 0;\n\n\tIPW_DEBUG_FW(\">> :\\n\");\n\n\tfor (index = 0; index < priv->sram_desc.last_cb_index; index++)\n\t\tipw_fw_dma_write_command_block(priv, index,\n\t\t\t\t\t       &priv->sram_desc.cb_list[index]);\n\n\t/* Enable the DMA in the CSR register */\n\tipw_clear_bit(priv, IPW_RESET_REG,\n\t\t      IPW_RESET_REG_MASTER_DISABLED |\n\t\t      IPW_RESET_REG_STOP_MASTER);\n\n\t/* Set the Start bit. */\n\tcontrol = DMA_CONTROL_SMALL_CB_CONST_VALUE | DMA_CB_START;\n\tipw_write_reg32(priv, IPW_DMA_I_DMA_CONTROL, control);\n\n\tIPW_DEBUG_FW(\"<< :\\n\");\n\treturn 0;\n}\n\nstatic void ipw_fw_dma_dump_command_block(struct ipw_priv *priv)\n{\n\tu32 address;\n\tu32 register_value = 0;\n\tu32 cb_fields_address = 0;\n\n\tIPW_DEBUG_FW(\">> :\\n\");\n\taddress = ipw_read_reg32(priv, IPW_DMA_I_CURRENT_CB);\n\tIPW_DEBUG_FW_INFO(\"Current CB is 0x%x\\n\", address);\n\n\t/* Read the DMA Controlor register */\n\tregister_value = ipw_read_reg32(priv, IPW_DMA_I_DMA_CONTROL);\n\tIPW_DEBUG_FW_INFO(\"IPW_DMA_I_DMA_CONTROL is 0x%x\\n\", register_value);\n\n\t/* Print the CB values */\n\tcb_fields_address = address;\n\tregister_value = ipw_read_reg32(priv, cb_fields_address);\n\tIPW_DEBUG_FW_INFO(\"Current CB Control Field is 0x%x\\n\", register_value);\n\n\tcb_fields_address += sizeof(u32);\n\tregister_value = ipw_read_reg32(priv, cb_fields_address);\n\tIPW_DEBUG_FW_INFO(\"Current CB Source Field is 0x%x\\n\", register_value);\n\n\tcb_fields_address += sizeof(u32);\n\tregister_value = ipw_read_reg32(priv, cb_fields_address);\n\tIPW_DEBUG_FW_INFO(\"Current CB Destination Field is 0x%x\\n\",\n\t\t\t  register_value);\n\n\tcb_fields_address += sizeof(u32);\n\tregister_value = ipw_read_reg32(priv, cb_fields_address);\n\tIPW_DEBUG_FW_INFO(\"Current CB Status Field is 0x%x\\n\", register_value);\n\n\tIPW_DEBUG_FW(\">> :\\n\");\n}\n\nstatic int ipw_fw_dma_command_block_index(struct ipw_priv *priv)\n{\n\tu32 current_cb_address = 0;\n\tu32 current_cb_index = 0;\n\n\tIPW_DEBUG_FW(\"<< :\\n\");\n\tcurrent_cb_address = ipw_read_reg32(priv, IPW_DMA_I_CURRENT_CB);\n\n\tcurrent_cb_index = (current_cb_address - IPW_SHARED_SRAM_DMA_CONTROL) /\n\t    sizeof(struct command_block);\n\n\tIPW_DEBUG_FW_INFO(\"Current CB index 0x%x address = 0x%X\\n\",\n\t\t\t  current_cb_index, current_cb_address);\n\n\tIPW_DEBUG_FW(\">> :\\n\");\n\treturn current_cb_index;\n\n}\n\nstatic int ipw_fw_dma_add_command_block(struct ipw_priv *priv,\n\t\t\t\t\tu32 src_address,\n\t\t\t\t\tu32 dest_address,\n\t\t\t\t\tu32 length,\n\t\t\t\t\tint interrupt_enabled, int is_last)\n{\n\n\tu32 control = CB_VALID | CB_SRC_LE | CB_DEST_LE | CB_SRC_AUTOINC |\n\t    CB_SRC_IO_GATED | CB_DEST_AUTOINC | CB_SRC_SIZE_LONG |\n\t    CB_DEST_SIZE_LONG;\n\tstruct command_block *cb;\n\tu32 last_cb_element = 0;\n\n\tIPW_DEBUG_FW_INFO(\"src_address=0x%x dest_address=0x%x length=0x%x\\n\",\n\t\t\t  src_address, dest_address, length);\n\n\tif (priv->sram_desc.last_cb_index >= CB_NUMBER_OF_ELEMENTS_SMALL)\n\t\treturn -1;\n\n\tlast_cb_element = priv->sram_desc.last_cb_index;\n\tcb = &priv->sram_desc.cb_list[last_cb_element];\n\tpriv->sram_desc.last_cb_index++;\n\n\t/* Calculate the new CB control word */\n\tif (interrupt_enabled)\n\t\tcontrol |= CB_INT_ENABLED;\n\n\tif (is_last)\n\t\tcontrol |= CB_LAST_VALID;\n\n\tcontrol |= length;\n\n\t/* Calculate the CB Element's checksum value */\n\tcb->status = control ^ src_address ^ dest_address;\n\n\t/* Copy the Source and Destination addresses */\n\tcb->dest_addr = dest_address;\n\tcb->source_addr = src_address;\n\n\t/* Copy the Control Word last */\n\tcb->control = control;\n\n\treturn 0;\n}\n\nstatic int ipw_fw_dma_add_buffer(struct ipw_priv *priv, dma_addr_t *src_address,\n\t\t\t\t int nr, u32 dest_address, u32 len)\n{\n\tint ret, i;\n\tu32 size;\n\n\tIPW_DEBUG_FW(\">>\\n\");\n\tIPW_DEBUG_FW_INFO(\"nr=%d dest_address=0x%x len=0x%x\\n\",\n\t\t\t  nr, dest_address, len);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tsize = min_t(u32, len - i * CB_MAX_LENGTH, CB_MAX_LENGTH);\n\t\tret = ipw_fw_dma_add_command_block(priv, src_address[i],\n\t\t\t\t\t\t   dest_address +\n\t\t\t\t\t\t   i * CB_MAX_LENGTH, size,\n\t\t\t\t\t\t   0, 0);\n\t\tif (ret) {\n\t\t\tIPW_DEBUG_FW_INFO(\": Failed\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tIPW_DEBUG_FW_INFO(\": Added new cb\\n\");\n\t}\n\n\tIPW_DEBUG_FW(\"<<\\n\");\n\treturn 0;\n}\n\nstatic int ipw_fw_dma_wait(struct ipw_priv *priv)\n{\n\tu32 current_index = 0, previous_index;\n\tu32 watchdog = 0;\n\n\tIPW_DEBUG_FW(\">> :\\n\");\n\n\tcurrent_index = ipw_fw_dma_command_block_index(priv);\n\tIPW_DEBUG_FW_INFO(\"sram_desc.last_cb_index:0x%08X\\n\",\n\t\t\t  (int)priv->sram_desc.last_cb_index);\n\n\twhile (current_index < priv->sram_desc.last_cb_index) {\n\t\tudelay(50);\n\t\tprevious_index = current_index;\n\t\tcurrent_index = ipw_fw_dma_command_block_index(priv);\n\n\t\tif (previous_index < current_index) {\n\t\t\twatchdog = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (++watchdog > 400) {\n\t\t\tIPW_DEBUG_FW_INFO(\"Timeout\\n\");\n\t\t\tipw_fw_dma_dump_command_block(priv);\n\t\t\tipw_fw_dma_abort(priv);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tipw_fw_dma_abort(priv);\n\n\t/*Disable the DMA in the CSR register */\n\tipw_set_bit(priv, IPW_RESET_REG,\n\t\t    IPW_RESET_REG_MASTER_DISABLED | IPW_RESET_REG_STOP_MASTER);\n\n\tIPW_DEBUG_FW(\"<< dmaWaitSync\\n\");\n\treturn 0;\n}\n\nstatic void ipw_remove_current_network(struct ipw_priv *priv)\n{\n\tstruct list_head *element, *safe;\n\tstruct libipw_network *network = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->ieee->lock, flags);\n\tlist_for_each_safe(element, safe, &priv->ieee->network_list) {\n\t\tnetwork = list_entry(element, struct libipw_network, list);\n\t\tif (ether_addr_equal(network->bssid, priv->bssid)) {\n\t\t\tlist_del(element);\n\t\t\tlist_add_tail(&network->list,\n\t\t\t\t      &priv->ieee->network_free_list);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->ieee->lock, flags);\n}\n\n/*\n * Check that card is still alive.\n * Reads debug register from domain0.\n * If card is present, pre-defined value should\n * be found there.\n *\n * @param priv\n * @return 1 if card is present, 0 otherwise\n */\nstatic inline int ipw_alive(struct ipw_priv *priv)\n{\n\treturn ipw_read32(priv, 0x90) == 0xd55555d5;\n}\n\n/* timeout in msec, attempted in 10-msec quanta */\nstatic int ipw_poll_bit(struct ipw_priv *priv, u32 addr, u32 mask,\n\t\t\t       int timeout)\n{\n\tint i = 0;\n\n\tdo {\n\t\tif ((ipw_read32(priv, addr) & mask) == mask)\n\t\t\treturn i;\n\t\tmdelay(10);\n\t\ti += 10;\n\t} while (i < timeout);\n\n\treturn -ETIME;\n}\n\n/* These functions load the firmware and micro code for the operation of\n * the ipw hardware.  It assumes the buffer has all the bits for the\n * image and the caller is handling the memory allocation and clean up.\n */\n\nstatic int ipw_stop_master(struct ipw_priv *priv)\n{\n\tint rc;\n\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\t/* stop master. typical delay - 0 */\n\tipw_set_bit(priv, IPW_RESET_REG, IPW_RESET_REG_STOP_MASTER);\n\n\t/* timeout is in msec, polled in 10-msec quanta */\n\trc = ipw_poll_bit(priv, IPW_RESET_REG,\n\t\t\t  IPW_RESET_REG_MASTER_DISABLED, 100);\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"wait for stop master failed after 100ms\\n\");\n\t\treturn -1;\n\t}\n\n\tIPW_DEBUG_INFO(\"stop master %dms\\n\", rc);\n\n\treturn rc;\n}\n\nstatic void ipw_arc_release(struct ipw_priv *priv)\n{\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\tmdelay(5);\n\n\tipw_clear_bit(priv, IPW_RESET_REG, CBD_RESET_REG_PRINCETON_RESET);\n\n\t/* no one knows timing, for safety add some delay */\n\tmdelay(5);\n}\n\nstruct fw_chunk {\n\t__le32 address;\n\t__le32 length;\n};\n\nstatic int ipw_load_ucode(struct ipw_priv *priv, u8 * data, size_t len)\n{\n\tint rc = 0, i, addr;\n\tu8 cr = 0;\n\t__le16 *image;\n\n\timage = (__le16 *) data;\n\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\n\trc = ipw_stop_master(priv);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\tfor (addr = IPW_SHARED_LOWER_BOUND;\n\t     addr < IPW_REGISTER_DOMAIN1_END; addr += 4) {\n\t\tipw_write32(priv, addr, 0);\n\t}\n\n\t/* no ucode (yet) */\n\tmemset(&priv->dino_alive, 0, sizeof(priv->dino_alive));\n\t/* destroy DMA queues */\n\t/* reset sequence */\n\n\tipw_write_reg32(priv, IPW_MEM_HALT_AND_RESET, IPW_BIT_HALT_RESET_ON);\n\tipw_arc_release(priv);\n\tipw_write_reg32(priv, IPW_MEM_HALT_AND_RESET, IPW_BIT_HALT_RESET_OFF);\n\tmdelay(1);\n\n\t/* reset PHY */\n\tipw_write_reg32(priv, IPW_INTERNAL_CMD_EVENT, IPW_BASEBAND_POWER_DOWN);\n\tmdelay(1);\n\n\tipw_write_reg32(priv, IPW_INTERNAL_CMD_EVENT, 0);\n\tmdelay(1);\n\n\t/* enable ucode store */\n\tipw_write_reg8(priv, IPW_BASEBAND_CONTROL_STATUS, 0x0);\n\tipw_write_reg8(priv, IPW_BASEBAND_CONTROL_STATUS, DINO_ENABLE_CS);\n\tmdelay(1);\n\n\t/* write ucode */\n\t/*\n\t * @bug\n\t * Do NOT set indirect address register once and then\n\t * store data to indirect data register in the loop.\n\t * It seems very reasonable, but in this case DINO do not\n\t * accept ucode. It is essential to set address each time.\n\t */\n\t/* load new ipw uCode */\n\tfor (i = 0; i < len / 2; i++)\n\t\tipw_write_reg16(priv, IPW_BASEBAND_CONTROL_STORE,\n\t\t\t\tle16_to_cpu(image[i]));\n\n\t/* enable DINO */\n\tipw_write_reg8(priv, IPW_BASEBAND_CONTROL_STATUS, 0);\n\tipw_write_reg8(priv, IPW_BASEBAND_CONTROL_STATUS, DINO_ENABLE_SYSTEM);\n\n\t/* this is where the igx / win driver deveates from the VAP driver. */\n\n\t/* wait for alive response */\n\tfor (i = 0; i < 100; i++) {\n\t\t/* poll for incoming data */\n\t\tcr = ipw_read_reg8(priv, IPW_BASEBAND_CONTROL_STATUS);\n\t\tif (cr & DINO_RXFIFO_DATA)\n\t\t\tbreak;\n\t\tmdelay(1);\n\t}\n\n\tif (cr & DINO_RXFIFO_DATA) {\n\t\t/* alive_command_responce size is NOT multiple of 4 */\n\t\t__le32 response_buffer[(sizeof(priv->dino_alive) + 3) / 4];\n\n\t\tfor (i = 0; i < ARRAY_SIZE(response_buffer); i++)\n\t\t\tresponse_buffer[i] =\n\t\t\t    cpu_to_le32(ipw_read_reg32(priv,\n\t\t\t\t\t\t       IPW_BASEBAND_RX_FIFO_READ));\n\t\tmemcpy(&priv->dino_alive, response_buffer,\n\t\t       sizeof(priv->dino_alive));\n\t\tif (priv->dino_alive.alive_command == 1\n\t\t    && priv->dino_alive.ucode_valid == 1) {\n\t\t\trc = 0;\n\t\t\tIPW_DEBUG_INFO\n\t\t\t    (\"Microcode OK, rev. %d (0x%x) dev. %d (0x%x) \"\n\t\t\t     \"of %02d/%02d/%02d %02d:%02d\\n\",\n\t\t\t     priv->dino_alive.software_revision,\n\t\t\t     priv->dino_alive.software_revision,\n\t\t\t     priv->dino_alive.device_identifier,\n\t\t\t     priv->dino_alive.device_identifier,\n\t\t\t     priv->dino_alive.time_stamp[0],\n\t\t\t     priv->dino_alive.time_stamp[1],\n\t\t\t     priv->dino_alive.time_stamp[2],\n\t\t\t     priv->dino_alive.time_stamp[3],\n\t\t\t     priv->dino_alive.time_stamp[4]);\n\t\t} else {\n\t\t\tIPW_DEBUG_INFO(\"Microcode is not alive\\n\");\n\t\t\trc = -EINVAL;\n\t\t}\n\t} else {\n\t\tIPW_DEBUG_INFO(\"No alive response from DINO\\n\");\n\t\trc = -ETIME;\n\t}\n\n\t/* disable DINO, otherwise for some reason\n\t   firmware have problem getting alive resp. */\n\tipw_write_reg8(priv, IPW_BASEBAND_CONTROL_STATUS, 0);\n\n\treturn rc;\n}\n\nstatic int ipw_load_firmware(struct ipw_priv *priv, u8 * data, size_t len)\n{\n\tint ret = -1;\n\tint offset = 0;\n\tstruct fw_chunk *chunk;\n\tint total_nr = 0;\n\tint i;\n\tstruct dma_pool *pool;\n\tvoid **virts;\n\tdma_addr_t *phys;\n\n\tIPW_DEBUG_TRACE(\"<< :\\n\");\n\n\tvirts = kmalloc_array(CB_NUMBER_OF_ELEMENTS_SMALL, sizeof(void *),\n\t\t\t      GFP_KERNEL);\n\tif (!virts)\n\t\treturn -ENOMEM;\n\n\tphys = kmalloc_array(CB_NUMBER_OF_ELEMENTS_SMALL, sizeof(dma_addr_t),\n\t\t\t     GFP_KERNEL);\n\tif (!phys) {\n\t\tkfree(virts);\n\t\treturn -ENOMEM;\n\t}\n\tpool = dma_pool_create(\"ipw2200\", &priv->pci_dev->dev, CB_MAX_LENGTH, 0,\n\t\t\t       0);\n\tif (!pool) {\n\t\tIPW_ERROR(\"dma_pool_create failed\\n\");\n\t\tkfree(phys);\n\t\tkfree(virts);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Start the Dma */\n\tret = ipw_fw_dma_enable(priv);\n\n\t/* the DMA is already ready this would be a bug. */\n\tBUG_ON(priv->sram_desc.last_cb_index > 0);\n\n\tdo {\n\t\tu32 chunk_len;\n\t\tu8 *start;\n\t\tint size;\n\t\tint nr = 0;\n\n\t\tchunk = (struct fw_chunk *)(data + offset);\n\t\toffset += sizeof(struct fw_chunk);\n\t\tchunk_len = le32_to_cpu(chunk->length);\n\t\tstart = data + offset;\n\n\t\tnr = (chunk_len + CB_MAX_LENGTH - 1) / CB_MAX_LENGTH;\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\tvirts[total_nr] = dma_pool_alloc(pool, GFP_KERNEL,\n\t\t\t\t\t\t\t &phys[total_nr]);\n\t\t\tif (!virts[total_nr]) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsize = min_t(u32, chunk_len - i * CB_MAX_LENGTH,\n\t\t\t\t     CB_MAX_LENGTH);\n\t\t\tmemcpy(virts[total_nr], start, size);\n\t\t\tstart += size;\n\t\t\ttotal_nr++;\n\t\t\t/* We don't support fw chunk larger than 64*8K */\n\t\t\tBUG_ON(total_nr > CB_NUMBER_OF_ELEMENTS_SMALL);\n\t\t}\n\n\t\t/* build DMA packet and queue up for sending */\n\t\t/* dma to chunk->address, the chunk->length bytes from data +\n\t\t * offeset*/\n\t\t/* Dma loading */\n\t\tret = ipw_fw_dma_add_buffer(priv, &phys[total_nr - nr],\n\t\t\t\t\t    nr, le32_to_cpu(chunk->address),\n\t\t\t\t\t    chunk_len);\n\t\tif (ret) {\n\t\t\tIPW_DEBUG_INFO(\"dmaAddBuffer Failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\toffset += chunk_len;\n\t} while (offset < len);\n\n\t/* Run the DMA and wait for the answer */\n\tret = ipw_fw_dma_kick(priv);\n\tif (ret) {\n\t\tIPW_ERROR(\"dmaKick Failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = ipw_fw_dma_wait(priv);\n\tif (ret) {\n\t\tIPW_ERROR(\"dmaWaitSync Failed\\n\");\n\t\tgoto out;\n\t}\n out:\n\tfor (i = 0; i < total_nr; i++)\n\t\tdma_pool_free(pool, virts[i], phys[i]);\n\n\tdma_pool_destroy(pool);\n\tkfree(phys);\n\tkfree(virts);\n\n\treturn ret;\n}\n\n/* stop nic */\nstatic int ipw_stop_nic(struct ipw_priv *priv)\n{\n\tint rc = 0;\n\n\t/* stop */\n\tipw_write32(priv, IPW_RESET_REG, IPW_RESET_REG_STOP_MASTER);\n\n\trc = ipw_poll_bit(priv, IPW_RESET_REG,\n\t\t\t  IPW_RESET_REG_MASTER_DISABLED, 500);\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"wait for reg master disabled failed after 500ms\\n\");\n\t\treturn rc;\n\t}\n\n\tipw_set_bit(priv, IPW_RESET_REG, CBD_RESET_REG_PRINCETON_RESET);\n\n\treturn rc;\n}\n\nstatic void ipw_start_nic(struct ipw_priv *priv)\n{\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\n\t/* prvHwStartNic  release ARC */\n\tipw_clear_bit(priv, IPW_RESET_REG,\n\t\t      IPW_RESET_REG_MASTER_DISABLED |\n\t\t      IPW_RESET_REG_STOP_MASTER |\n\t\t      CBD_RESET_REG_PRINCETON_RESET);\n\n\t/* enable power management */\n\tipw_set_bit(priv, IPW_GP_CNTRL_RW,\n\t\t    IPW_GP_CNTRL_BIT_HOST_ALLOWS_STANDBY);\n\n\tIPW_DEBUG_TRACE(\"<<\\n\");\n}\n\nstatic int ipw_init_nic(struct ipw_priv *priv)\n{\n\tint rc;\n\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\t/* reset */\n\t/*prvHwInitNic */\n\t/* set \"initialization complete\" bit to move adapter to D0 state */\n\tipw_set_bit(priv, IPW_GP_CNTRL_RW, IPW_GP_CNTRL_BIT_INIT_DONE);\n\n\t/* low-level PLL activation */\n\tipw_write32(priv, IPW_READ_INT_REGISTER,\n\t\t    IPW_BIT_INT_HOST_SRAM_READ_INT_REGISTER);\n\n\t/* wait for clock stabilization */\n\trc = ipw_poll_bit(priv, IPW_GP_CNTRL_RW,\n\t\t\t  IPW_GP_CNTRL_BIT_CLOCK_READY, 250);\n\tif (rc < 0)\n\t\tIPW_DEBUG_INFO(\"FAILED wait for clock stablization\\n\");\n\n\t/* assert SW reset */\n\tipw_set_bit(priv, IPW_RESET_REG, IPW_RESET_REG_SW_RESET);\n\n\tudelay(10);\n\n\t/* set \"initialization complete\" bit to move adapter to D0 state */\n\tipw_set_bit(priv, IPW_GP_CNTRL_RW, IPW_GP_CNTRL_BIT_INIT_DONE);\n\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\treturn 0;\n}\n\n/* Call this function from process context, it will sleep in request_firmware.\n * Probe is an ok place to call this from.\n */\nstatic int ipw_reset_nic(struct ipw_priv *priv)\n{\n\tint rc = 0;\n\tunsigned long flags;\n\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\n\trc = ipw_init_nic(priv);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\t/* Clear the 'host command active' bit... */\n\tpriv->status &= ~STATUS_HCMD_ACTIVE;\n\twake_up_interruptible(&priv->wait_command_queue);\n\tpriv->status &= ~(STATUS_SCANNING | STATUS_SCAN_ABORTING);\n\twake_up_interruptible(&priv->wait_state);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tIPW_DEBUG_TRACE(\"<<\\n\");\n\treturn rc;\n}\n\n\nstruct ipw_fw {\n\t__le32 ver;\n\t__le32 boot_size;\n\t__le32 ucode_size;\n\t__le32 fw_size;\n\tu8 data[];\n};\n\nstatic int ipw_get_fw(struct ipw_priv *priv,\n\t\t      const struct firmware **raw, const char *name)\n{\n\tstruct ipw_fw *fw;\n\tint rc;\n\n\t/* ask firmware_class module to get the boot firmware off disk */\n\trc = request_firmware(raw, name, &priv->pci_dev->dev);\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"%s request_firmware failed: Reason %d\\n\", name, rc);\n\t\treturn rc;\n\t}\n\n\tif ((*raw)->size < sizeof(*fw)) {\n\t\tIPW_ERROR(\"%s is too small (%zd)\\n\", name, (*raw)->size);\n\t\treturn -EINVAL;\n\t}\n\n\tfw = (void *)(*raw)->data;\n\n\tif ((*raw)->size < sizeof(*fw) + le32_to_cpu(fw->boot_size) +\n\t    le32_to_cpu(fw->ucode_size) + le32_to_cpu(fw->fw_size)) {\n\t\tIPW_ERROR(\"%s is too small or corrupt (%zd)\\n\",\n\t\t\t  name, (*raw)->size);\n\t\treturn -EINVAL;\n\t}\n\n\tIPW_DEBUG_INFO(\"Read firmware '%s' image v%d.%d (%zd bytes)\\n\",\n\t\t       name,\n\t\t       le32_to_cpu(fw->ver) >> 16,\n\t\t       le32_to_cpu(fw->ver) & 0xff,\n\t\t       (*raw)->size - sizeof(*fw));\n\treturn 0;\n}\n\n#define IPW_RX_BUF_SIZE (3000)\n\nstatic void ipw_rx_queue_reset(struct ipw_priv *priv,\n\t\t\t\t      struct ipw_rx_queue *rxq)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&rxq->lock, flags);\n\n\tINIT_LIST_HEAD(&rxq->rx_free);\n\tINIT_LIST_HEAD(&rxq->rx_used);\n\n\t/* Fill the rx_used queue with _all_ of the Rx buffers */\n\tfor (i = 0; i < RX_FREE_BUFFERS + RX_QUEUE_SIZE; i++) {\n\t\t/* In the reset function, these buffers may have been allocated\n\t\t * to an SKB, so we need to unmap and free potential storage */\n\t\tif (rxq->pool[i].skb != NULL) {\n\t\t\tdma_unmap_single(&priv->pci_dev->dev,\n\t\t\t\t\t rxq->pool[i].dma_addr,\n\t\t\t\t\t IPW_RX_BUF_SIZE, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(rxq->pool[i].skb);\n\t\t\trxq->pool[i].skb = NULL;\n\t\t}\n\t\tlist_add_tail(&rxq->pool[i].list, &rxq->rx_used);\n\t}\n\n\t/* Set us so that we have processed and used all buffers, but have\n\t * not restocked the Rx queue with fresh buffers */\n\trxq->read = rxq->write = 0;\n\trxq->free_count = 0;\n\tspin_unlock_irqrestore(&rxq->lock, flags);\n}\n\n#ifdef CONFIG_PM\nstatic int fw_loaded = 0;\nstatic const struct firmware *raw = NULL;\n\nstatic void free_firmware(void)\n{\n\tif (fw_loaded) {\n\t\trelease_firmware(raw);\n\t\traw = NULL;\n\t\tfw_loaded = 0;\n\t}\n}\n#else\n#define free_firmware() do {} while (0)\n#endif\n\nstatic int ipw_load(struct ipw_priv *priv)\n{\n#ifndef CONFIG_PM\n\tconst struct firmware *raw = NULL;\n#endif\n\tstruct ipw_fw *fw;\n\tu8 *boot_img, *ucode_img, *fw_img;\n\tu8 *name = NULL;\n\tint rc = 0, retries = 3;\n\n\tswitch (priv->ieee->iw_mode) {\n\tcase IW_MODE_ADHOC:\n\t\tname = \"ipw2200-ibss.fw\";\n\t\tbreak;\n#ifdef CONFIG_IPW2200_MONITOR\n\tcase IW_MODE_MONITOR:\n\t\tname = \"ipw2200-sniffer.fw\";\n\t\tbreak;\n#endif\n\tcase IW_MODE_INFRA:\n\t\tname = \"ipw2200-bss.fw\";\n\t\tbreak;\n\t}\n\n\tif (!name) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n#ifdef CONFIG_PM\n\tif (!fw_loaded) {\n#endif\n\t\trc = ipw_get_fw(priv, &raw, name);\n\t\tif (rc < 0)\n\t\t\tgoto error;\n#ifdef CONFIG_PM\n\t}\n#endif\n\n\tfw = (void *)raw->data;\n\tboot_img = &fw->data[0];\n\tucode_img = &fw->data[le32_to_cpu(fw->boot_size)];\n\tfw_img = &fw->data[le32_to_cpu(fw->boot_size) +\n\t\t\t   le32_to_cpu(fw->ucode_size)];\n\n\tif (!priv->rxq)\n\t\tpriv->rxq = ipw_rx_queue_alloc(priv);\n\telse\n\t\tipw_rx_queue_reset(priv, priv->rxq);\n\tif (!priv->rxq) {\n\t\tIPW_ERROR(\"Unable to initialize Rx queue\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto error;\n\t}\n\n      retry:\n\t/* Ensure interrupts are disabled */\n\tipw_write32(priv, IPW_INTA_MASK_R, ~IPW_INTA_MASK_ALL);\n\tpriv->status &= ~STATUS_INT_ENABLED;\n\n\t/* ack pending interrupts */\n\tipw_write32(priv, IPW_INTA_RW, IPW_INTA_MASK_ALL);\n\n\tipw_stop_nic(priv);\n\n\trc = ipw_reset_nic(priv);\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"Unable to reset NIC\\n\");\n\t\tgoto error;\n\t}\n\n\tipw_zero_memory(priv, IPW_NIC_SRAM_LOWER_BOUND,\n\t\t\tIPW_NIC_SRAM_UPPER_BOUND - IPW_NIC_SRAM_LOWER_BOUND);\n\n\t/* DMA the initial boot firmware into the device */\n\trc = ipw_load_firmware(priv, boot_img, le32_to_cpu(fw->boot_size));\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"Unable to load boot firmware: %d\\n\", rc);\n\t\tgoto error;\n\t}\n\n\t/* kick start the device */\n\tipw_start_nic(priv);\n\n\t/* wait for the device to finish its initial startup sequence */\n\trc = ipw_poll_bit(priv, IPW_INTA_RW,\n\t\t\t  IPW_INTA_BIT_FW_INITIALIZATION_DONE, 500);\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"device failed to boot initial fw image\\n\");\n\t\tgoto error;\n\t}\n\tIPW_DEBUG_INFO(\"initial device response after %dms\\n\", rc);\n\n\t/* ack fw init done interrupt */\n\tipw_write32(priv, IPW_INTA_RW, IPW_INTA_BIT_FW_INITIALIZATION_DONE);\n\n\t/* DMA the ucode into the device */\n\trc = ipw_load_ucode(priv, ucode_img, le32_to_cpu(fw->ucode_size));\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"Unable to load ucode: %d\\n\", rc);\n\t\tgoto error;\n\t}\n\n\t/* stop nic */\n\tipw_stop_nic(priv);\n\n\t/* DMA bss firmware into the device */\n\trc = ipw_load_firmware(priv, fw_img, le32_to_cpu(fw->fw_size));\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"Unable to load firmware: %d\\n\", rc);\n\t\tgoto error;\n\t}\n#ifdef CONFIG_PM\n\tfw_loaded = 1;\n#endif\n\n\tipw_write32(priv, IPW_EEPROM_LOAD_DISABLE, 0);\n\n\trc = ipw_queue_reset(priv);\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"Unable to initialize queues\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure interrupts are disabled */\n\tipw_write32(priv, IPW_INTA_MASK_R, ~IPW_INTA_MASK_ALL);\n\t/* ack pending interrupts */\n\tipw_write32(priv, IPW_INTA_RW, IPW_INTA_MASK_ALL);\n\n\t/* kick start the device */\n\tipw_start_nic(priv);\n\n\tif (ipw_read32(priv, IPW_INTA_RW) & IPW_INTA_BIT_PARITY_ERROR) {\n\t\tif (retries > 0) {\n\t\t\tIPW_WARNING(\"Parity error.  Retrying init.\\n\");\n\t\t\tretries--;\n\t\t\tgoto retry;\n\t\t}\n\n\t\tIPW_ERROR(\"TODO: Handle parity error -- schedule restart?\\n\");\n\t\trc = -EIO;\n\t\tgoto error;\n\t}\n\n\t/* wait for the device */\n\trc = ipw_poll_bit(priv, IPW_INTA_RW,\n\t\t\t  IPW_INTA_BIT_FW_INITIALIZATION_DONE, 500);\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"device failed to start within 500ms\\n\");\n\t\tgoto error;\n\t}\n\tIPW_DEBUG_INFO(\"device response after %dms\\n\", rc);\n\n\t/* ack fw init done interrupt */\n\tipw_write32(priv, IPW_INTA_RW, IPW_INTA_BIT_FW_INITIALIZATION_DONE);\n\n\t/* read eeprom data */\n\tpriv->eeprom_delay = 1;\n\tipw_read_eeprom(priv);\n\t/* initialize the eeprom region of sram */\n\tipw_eeprom_init_sram(priv);\n\n\t/* enable interrupts */\n\tipw_enable_interrupts(priv);\n\n\t/* Ensure our queue has valid packets */\n\tipw_rx_queue_replenish(priv);\n\n\tipw_write32(priv, IPW_RX_READ_INDEX, priv->rxq->read);\n\n\t/* ack pending interrupts */\n\tipw_write32(priv, IPW_INTA_RW, IPW_INTA_MASK_ALL);\n\n#ifndef CONFIG_PM\n\trelease_firmware(raw);\n#endif\n\treturn 0;\n\n      error:\n\tif (priv->rxq) {\n\t\tipw_rx_queue_free(priv, priv->rxq);\n\t\tpriv->rxq = NULL;\n\t}\n\tipw_tx_queue_free(priv);\n\trelease_firmware(raw);\n#ifdef CONFIG_PM\n\tfw_loaded = 0;\n\traw = NULL;\n#endif\n\n\treturn rc;\n}\n\n/*\n * DMA services\n *\n * Theory of operation\n *\n * A queue is a circular buffers with 'Read' and 'Write' pointers.\n * 2 empty entries always kept in the buffer to protect from overflow.\n *\n * For Tx queue, there are low mark and high mark limits. If, after queuing\n * the packet for Tx, free space become < low mark, Tx queue stopped. When\n * reclaiming packets (on 'tx done IRQ), if free space become > high mark,\n * Tx queue resumed.\n *\n * The IPW operates with six queues, one receive queue in the device's\n * sram, one transmit queue for sending commands to the device firmware,\n * and four transmit queues for data.\n *\n * The four transmit queues allow for performing quality of service (qos)\n * transmissions as per the 802.11 protocol.  Currently Linux does not\n * provide a mechanism to the user for utilizing prioritized queues, so\n * we only utilize the first data transmit queue (queue1).\n */\n\n/*\n * Driver allocates buffers of this size for Rx\n */\n\n/*\n * ipw_rx_queue_space - Return number of free slots available in queue.\n */\nstatic int ipw_rx_queue_space(const struct ipw_rx_queue *q)\n{\n\tint s = q->read - q->write;\n\tif (s <= 0)\n\t\ts += RX_QUEUE_SIZE;\n\t/* keep some buffer to not confuse full and empty queue */\n\ts -= 2;\n\tif (s < 0)\n\t\ts = 0;\n\treturn s;\n}\n\nstatic inline int ipw_tx_queue_space(const struct clx2_queue *q)\n{\n\tint s = q->last_used - q->first_empty;\n\tif (s <= 0)\n\t\ts += q->n_bd;\n\ts -= 2;\t\t\t/* keep some reserve to not confuse empty and full situations */\n\tif (s < 0)\n\t\ts = 0;\n\treturn s;\n}\n\nstatic inline int ipw_queue_inc_wrap(int index, int n_bd)\n{\n\treturn (++index == n_bd) ? 0 : index;\n}\n\n/*\n * Initialize common DMA queue structure\n *\n * @param q                queue to init\n * @param count            Number of BD's to allocate. Should be power of 2\n * @param read_register    Address for 'read' register\n *                         (not offset within BAR, full address)\n * @param write_register   Address for 'write' register\n *                         (not offset within BAR, full address)\n * @param base_register    Address for 'base' register\n *                         (not offset within BAR, full address)\n * @param size             Address for 'size' register\n *                         (not offset within BAR, full address)\n */\nstatic void ipw_queue_init(struct ipw_priv *priv, struct clx2_queue *q,\n\t\t\t   int count, u32 read, u32 write, u32 base, u32 size)\n{\n\tq->n_bd = count;\n\n\tq->low_mark = q->n_bd / 4;\n\tif (q->low_mark < 4)\n\t\tq->low_mark = 4;\n\n\tq->high_mark = q->n_bd / 8;\n\tif (q->high_mark < 2)\n\t\tq->high_mark = 2;\n\n\tq->first_empty = q->last_used = 0;\n\tq->reg_r = read;\n\tq->reg_w = write;\n\n\tipw_write32(priv, base, q->dma_addr);\n\tipw_write32(priv, size, count);\n\tipw_write32(priv, read, 0);\n\tipw_write32(priv, write, 0);\n\n\t_ipw_read32(priv, 0x90);\n}\n\nstatic int ipw_queue_tx_init(struct ipw_priv *priv,\n\t\t\t     struct clx2_tx_queue *q,\n\t\t\t     int count, u32 read, u32 write, u32 base, u32 size)\n{\n\tstruct pci_dev *dev = priv->pci_dev;\n\n\tq->txb = kmalloc_array(count, sizeof(q->txb[0]), GFP_KERNEL);\n\tif (!q->txb)\n\t\treturn -ENOMEM;\n\n\tq->bd =\n\t    dma_alloc_coherent(&dev->dev, sizeof(q->bd[0]) * count,\n\t\t\t       &q->q.dma_addr, GFP_KERNEL);\n\tif (!q->bd) {\n\t\tIPW_ERROR(\"pci_alloc_consistent(%zd) failed\\n\",\n\t\t\t  sizeof(q->bd[0]) * count);\n\t\tkfree(q->txb);\n\t\tq->txb = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tipw_queue_init(priv, &q->q, count, read, write, base, size);\n\treturn 0;\n}\n\n/*\n * Free one TFD, those at index [txq->q.last_used].\n * Do NOT advance any indexes\n *\n * @param dev\n * @param txq\n */\nstatic void ipw_queue_tx_free_tfd(struct ipw_priv *priv,\n\t\t\t\t  struct clx2_tx_queue *txq)\n{\n\tstruct tfd_frame *bd = &txq->bd[txq->q.last_used];\n\tstruct pci_dev *dev = priv->pci_dev;\n\tint i;\n\n\t/* classify bd */\n\tif (bd->control_flags.message_type == TX_HOST_COMMAND_TYPE)\n\t\t/* nothing to cleanup after for host commands */\n\t\treturn;\n\n\t/* sanity check */\n\tif (le32_to_cpu(bd->u.data.num_chunks) > NUM_TFD_CHUNKS) {\n\t\tIPW_ERROR(\"Too many chunks: %i\\n\",\n\t\t\t  le32_to_cpu(bd->u.data.num_chunks));\n\t\t/* @todo issue fatal error, it is quite serious situation */\n\t\treturn;\n\t}\n\n\t/* unmap chunks if any */\n\tfor (i = 0; i < le32_to_cpu(bd->u.data.num_chunks); i++) {\n\t\tdma_unmap_single(&dev->dev,\n\t\t\t\t le32_to_cpu(bd->u.data.chunk_ptr[i]),\n\t\t\t\t le16_to_cpu(bd->u.data.chunk_len[i]),\n\t\t\t\t DMA_TO_DEVICE);\n\t\tif (txq->txb[txq->q.last_used]) {\n\t\t\tlibipw_txb_free(txq->txb[txq->q.last_used]);\n\t\t\ttxq->txb[txq->q.last_used] = NULL;\n\t\t}\n\t}\n}\n\n/*\n * Deallocate DMA queue.\n *\n * Empty queue by removing and destroying all BD's.\n * Free all buffers.\n *\n * @param dev\n * @param q\n */\nstatic void ipw_queue_tx_free(struct ipw_priv *priv, struct clx2_tx_queue *txq)\n{\n\tstruct clx2_queue *q = &txq->q;\n\tstruct pci_dev *dev = priv->pci_dev;\n\n\tif (q->n_bd == 0)\n\t\treturn;\n\n\t/* first, empty all BD's */\n\tfor (; q->first_empty != q->last_used;\n\t     q->last_used = ipw_queue_inc_wrap(q->last_used, q->n_bd)) {\n\t\tipw_queue_tx_free_tfd(priv, txq);\n\t}\n\n\t/* free buffers belonging to queue itself */\n\tdma_free_coherent(&dev->dev, sizeof(txq->bd[0]) * q->n_bd, txq->bd,\n\t\t\t  q->dma_addr);\n\tkfree(txq->txb);\n\n\t/* 0 fill whole structure */\n\tmemset(txq, 0, sizeof(*txq));\n}\n\n/*\n * Destroy all DMA queues and structures\n *\n * @param priv\n */\nstatic void ipw_tx_queue_free(struct ipw_priv *priv)\n{\n\t/* Tx CMD queue */\n\tipw_queue_tx_free(priv, &priv->txq_cmd);\n\n\t/* Tx queues */\n\tipw_queue_tx_free(priv, &priv->txq[0]);\n\tipw_queue_tx_free(priv, &priv->txq[1]);\n\tipw_queue_tx_free(priv, &priv->txq[2]);\n\tipw_queue_tx_free(priv, &priv->txq[3]);\n}\n\nstatic void ipw_create_bssid(struct ipw_priv *priv, u8 * bssid)\n{\n\t/* First 3 bytes are manufacturer */\n\tbssid[0] = priv->mac_addr[0];\n\tbssid[1] = priv->mac_addr[1];\n\tbssid[2] = priv->mac_addr[2];\n\n\t/* Last bytes are random */\n\tget_random_bytes(&bssid[3], ETH_ALEN - 3);\n\n\tbssid[0] &= 0xfe;\t/* clear multicast bit */\n\tbssid[0] |= 0x02;\t/* set local assignment bit (IEEE802) */\n}\n\nstatic u8 ipw_add_station(struct ipw_priv *priv, u8 * bssid)\n{\n\tstruct ipw_station_entry entry;\n\tint i;\n\n\tfor (i = 0; i < priv->num_stations; i++) {\n\t\tif (ether_addr_equal(priv->stations[i], bssid)) {\n\t\t\t/* Another node is active in network */\n\t\t\tpriv->missed_adhoc_beacons = 0;\n\t\t\tif (!(priv->config & CFG_STATIC_CHANNEL))\n\t\t\t\t/* when other nodes drop out, we drop out */\n\t\t\t\tpriv->config &= ~CFG_ADHOC_PERSIST;\n\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tif (i == MAX_STATIONS)\n\t\treturn IPW_INVALID_STATION;\n\n\tIPW_DEBUG_SCAN(\"Adding AdHoc station: %pM\\n\", bssid);\n\n\tentry.reserved = 0;\n\tentry.support_mode = 0;\n\tmemcpy(entry.mac_addr, bssid, ETH_ALEN);\n\tmemcpy(priv->stations[i], bssid, ETH_ALEN);\n\tipw_write_direct(priv, IPW_STATION_TABLE_LOWER + i * sizeof(entry),\n\t\t\t &entry, sizeof(entry));\n\tpriv->num_stations++;\n\n\treturn i;\n}\n\nstatic u8 ipw_find_station(struct ipw_priv *priv, u8 * bssid)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->num_stations; i++)\n\t\tif (ether_addr_equal(priv->stations[i], bssid))\n\t\t\treturn i;\n\n\treturn IPW_INVALID_STATION;\n}\n\nstatic void ipw_send_disassociate(struct ipw_priv *priv, int quiet)\n{\n\tint err;\n\n\tif (priv->status & STATUS_ASSOCIATING) {\n\t\tIPW_DEBUG_ASSOC(\"Disassociating while associating.\\n\");\n\t\tschedule_work(&priv->disassociate);\n\t\treturn;\n\t}\n\n\tif (!(priv->status & STATUS_ASSOCIATED)) {\n\t\tIPW_DEBUG_ASSOC(\"Disassociating while not associated.\\n\");\n\t\treturn;\n\t}\n\n\tIPW_DEBUG_ASSOC(\"Disassociation attempt from %pM \"\n\t\t\t\"on channel %d.\\n\",\n\t\t\tpriv->assoc_request.bssid,\n\t\t\tpriv->assoc_request.channel);\n\n\tpriv->status &= ~(STATUS_ASSOCIATING | STATUS_ASSOCIATED);\n\tpriv->status |= STATUS_DISASSOCIATING;\n\n\tif (quiet)\n\t\tpriv->assoc_request.assoc_type = HC_DISASSOC_QUIET;\n\telse\n\t\tpriv->assoc_request.assoc_type = HC_DISASSOCIATE;\n\n\terr = ipw_send_associate(priv, &priv->assoc_request);\n\tif (err) {\n\t\tIPW_DEBUG_HC(\"Attempt to send [dis]associate command \"\n\t\t\t     \"failed.\\n\");\n\t\treturn;\n\t}\n\n}\n\nstatic int ipw_disassociate(void *data)\n{\n\tstruct ipw_priv *priv = data;\n\tif (!(priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)))\n\t\treturn 0;\n\tipw_send_disassociate(data, 0);\n\tnetif_carrier_off(priv->net_dev);\n\treturn 1;\n}\n\nstatic void ipw_bg_disassociate(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, disassociate);\n\tmutex_lock(&priv->mutex);\n\tipw_disassociate(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_system_config(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, system_config);\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n\tif (priv->prom_net_dev && netif_running(priv->prom_net_dev)) {\n\t\tpriv->sys_config.accept_all_data_frames = 1;\n\t\tpriv->sys_config.accept_non_directed_frames = 1;\n\t\tpriv->sys_config.accept_all_mgmt_bcpr = 1;\n\t\tpriv->sys_config.accept_all_mgmt_frames = 1;\n\t}\n#endif\n\n\tipw_send_system_config(priv);\n}\n\nstruct ipw_status_code {\n\tu16 status;\n\tconst char *reason;\n};\n\nstatic const struct ipw_status_code ipw_status_codes[] = {\n\t{0x00, \"Successful\"},\n\t{0x01, \"Unspecified failure\"},\n\t{0x0A, \"Cannot support all requested capabilities in the \"\n\t \"Capability information field\"},\n\t{0x0B, \"Reassociation denied due to inability to confirm that \"\n\t \"association exists\"},\n\t{0x0C, \"Association denied due to reason outside the scope of this \"\n\t \"standard\"},\n\t{0x0D,\n\t \"Responding station does not support the specified authentication \"\n\t \"algorithm\"},\n\t{0x0E,\n\t \"Received an Authentication frame with authentication sequence \"\n\t \"transaction sequence number out of expected sequence\"},\n\t{0x0F, \"Authentication rejected because of challenge failure\"},\n\t{0x10, \"Authentication rejected due to timeout waiting for next \"\n\t \"frame in sequence\"},\n\t{0x11, \"Association denied because AP is unable to handle additional \"\n\t \"associated stations\"},\n\t{0x12,\n\t \"Association denied due to requesting station not supporting all \"\n\t \"of the datarates in the BSSBasicServiceSet Parameter\"},\n\t{0x13,\n\t \"Association denied due to requesting station not supporting \"\n\t \"short preamble operation\"},\n\t{0x14,\n\t \"Association denied due to requesting station not supporting \"\n\t \"PBCC encoding\"},\n\t{0x15,\n\t \"Association denied due to requesting station not supporting \"\n\t \"channel agility\"},\n\t{0x19,\n\t \"Association denied due to requesting station not supporting \"\n\t \"short slot operation\"},\n\t{0x1A,\n\t \"Association denied due to requesting station not supporting \"\n\t \"DSSS-OFDM operation\"},\n\t{0x28, \"Invalid Information Element\"},\n\t{0x29, \"Group Cipher is not valid\"},\n\t{0x2A, \"Pairwise Cipher is not valid\"},\n\t{0x2B, \"AKMP is not valid\"},\n\t{0x2C, \"Unsupported RSN IE version\"},\n\t{0x2D, \"Invalid RSN IE Capabilities\"},\n\t{0x2E, \"Cipher suite is rejected per security policy\"},\n};\n\nstatic const char *ipw_get_status_code(u16 status)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(ipw_status_codes); i++)\n\t\tif (ipw_status_codes[i].status == (status & 0xff))\n\t\t\treturn ipw_status_codes[i].reason;\n\treturn \"Unknown status value.\";\n}\n\nstatic inline void average_init(struct average *avg)\n{\n\tmemset(avg, 0, sizeof(*avg));\n}\n\n#define DEPTH_RSSI 8\n#define DEPTH_NOISE 16\nstatic s16 exponential_average(s16 prev_avg, s16 val, u8 depth)\n{\n\treturn ((depth-1)*prev_avg +  val)/depth;\n}\n\nstatic void average_add(struct average *avg, s16 val)\n{\n\tavg->sum -= avg->entries[avg->pos];\n\tavg->sum += val;\n\tavg->entries[avg->pos++] = val;\n\tif (unlikely(avg->pos == AVG_ENTRIES)) {\n\t\tavg->init = 1;\n\t\tavg->pos = 0;\n\t}\n}\n\nstatic s16 average_value(struct average *avg)\n{\n\tif (!unlikely(avg->init)) {\n\t\tif (avg->pos)\n\t\t\treturn avg->sum / avg->pos;\n\t\treturn 0;\n\t}\n\n\treturn avg->sum / AVG_ENTRIES;\n}\n\nstatic void ipw_reset_stats(struct ipw_priv *priv)\n{\n\tu32 len = sizeof(u32);\n\n\tpriv->quality = 0;\n\n\taverage_init(&priv->average_missed_beacons);\n\tpriv->exp_avg_rssi = -60;\n\tpriv->exp_avg_noise = -85 + 0x100;\n\n\tpriv->last_rate = 0;\n\tpriv->last_missed_beacons = 0;\n\tpriv->last_rx_packets = 0;\n\tpriv->last_tx_packets = 0;\n\tpriv->last_tx_failures = 0;\n\n\t/* Firmware managed, reset only when NIC is restarted, so we have to\n\t * normalize on the current value */\n\tipw_get_ordinal(priv, IPW_ORD_STAT_RX_ERR_CRC,\n\t\t\t&priv->last_rx_err, &len);\n\tipw_get_ordinal(priv, IPW_ORD_STAT_TX_FAILURE,\n\t\t\t&priv->last_tx_failures, &len);\n\n\t/* Driver managed, reset with each association */\n\tpriv->missed_adhoc_beacons = 0;\n\tpriv->missed_beacons = 0;\n\tpriv->tx_packets = 0;\n\tpriv->rx_packets = 0;\n\n}\n\nstatic u32 ipw_get_max_rate(struct ipw_priv *priv)\n{\n\tu32 i = 0x80000000;\n\tu32 mask = priv->rates_mask;\n\t/* If currently associated in B mode, restrict the maximum\n\t * rate match to B rates */\n\tif (priv->assoc_request.ieee_mode == IPW_B_MODE)\n\t\tmask &= LIBIPW_CCK_RATES_MASK;\n\n\t/* TODO: Verify that the rate is supported by the current rates\n\t * list. */\n\n\twhile (i && !(mask & i))\n\t\ti >>= 1;\n\tswitch (i) {\n\tcase LIBIPW_CCK_RATE_1MB_MASK:\n\t\treturn 1000000;\n\tcase LIBIPW_CCK_RATE_2MB_MASK:\n\t\treturn 2000000;\n\tcase LIBIPW_CCK_RATE_5MB_MASK:\n\t\treturn 5500000;\n\tcase LIBIPW_OFDM_RATE_6MB_MASK:\n\t\treturn 6000000;\n\tcase LIBIPW_OFDM_RATE_9MB_MASK:\n\t\treturn 9000000;\n\tcase LIBIPW_CCK_RATE_11MB_MASK:\n\t\treturn 11000000;\n\tcase LIBIPW_OFDM_RATE_12MB_MASK:\n\t\treturn 12000000;\n\tcase LIBIPW_OFDM_RATE_18MB_MASK:\n\t\treturn 18000000;\n\tcase LIBIPW_OFDM_RATE_24MB_MASK:\n\t\treturn 24000000;\n\tcase LIBIPW_OFDM_RATE_36MB_MASK:\n\t\treturn 36000000;\n\tcase LIBIPW_OFDM_RATE_48MB_MASK:\n\t\treturn 48000000;\n\tcase LIBIPW_OFDM_RATE_54MB_MASK:\n\t\treturn 54000000;\n\t}\n\n\tif (priv->ieee->mode == IEEE_B)\n\t\treturn 11000000;\n\telse\n\t\treturn 54000000;\n}\n\nstatic u32 ipw_get_current_rate(struct ipw_priv *priv)\n{\n\tu32 rate, len = sizeof(rate);\n\tint err;\n\n\tif (!(priv->status & STATUS_ASSOCIATED))\n\t\treturn 0;\n\n\tif (priv->tx_packets > IPW_REAL_RATE_RX_PACKET_THRESHOLD) {\n\t\terr = ipw_get_ordinal(priv, IPW_ORD_STAT_TX_CURR_RATE, &rate,\n\t\t\t\t      &len);\n\t\tif (err) {\n\t\t\tIPW_DEBUG_INFO(\"failed querying ordinals.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\treturn ipw_get_max_rate(priv);\n\n\tswitch (rate) {\n\tcase IPW_TX_RATE_1MB:\n\t\treturn 1000000;\n\tcase IPW_TX_RATE_2MB:\n\t\treturn 2000000;\n\tcase IPW_TX_RATE_5MB:\n\t\treturn 5500000;\n\tcase IPW_TX_RATE_6MB:\n\t\treturn 6000000;\n\tcase IPW_TX_RATE_9MB:\n\t\treturn 9000000;\n\tcase IPW_TX_RATE_11MB:\n\t\treturn 11000000;\n\tcase IPW_TX_RATE_12MB:\n\t\treturn 12000000;\n\tcase IPW_TX_RATE_18MB:\n\t\treturn 18000000;\n\tcase IPW_TX_RATE_24MB:\n\t\treturn 24000000;\n\tcase IPW_TX_RATE_36MB:\n\t\treturn 36000000;\n\tcase IPW_TX_RATE_48MB:\n\t\treturn 48000000;\n\tcase IPW_TX_RATE_54MB:\n\t\treturn 54000000;\n\t}\n\n\treturn 0;\n}\n\n#define IPW_STATS_INTERVAL (2 * HZ)\nstatic void ipw_gather_stats(struct ipw_priv *priv)\n{\n\tu32 rx_err, rx_err_delta, rx_packets_delta;\n\tu32 tx_failures, tx_failures_delta, tx_packets_delta;\n\tu32 missed_beacons_percent, missed_beacons_delta;\n\tu32 quality = 0;\n\tu32 len = sizeof(u32);\n\ts16 rssi;\n\tu32 beacon_quality, signal_quality, tx_quality, rx_quality,\n\t    rate_quality;\n\tu32 max_rate;\n\n\tif (!(priv->status & STATUS_ASSOCIATED)) {\n\t\tpriv->quality = 0;\n\t\treturn;\n\t}\n\n\t/* Update the statistics */\n\tipw_get_ordinal(priv, IPW_ORD_STAT_MISSED_BEACONS,\n\t\t\t&priv->missed_beacons, &len);\n\tmissed_beacons_delta = priv->missed_beacons - priv->last_missed_beacons;\n\tpriv->last_missed_beacons = priv->missed_beacons;\n\tif (priv->assoc_request.beacon_interval) {\n\t\tmissed_beacons_percent = missed_beacons_delta *\n\t\t    (HZ * le16_to_cpu(priv->assoc_request.beacon_interval)) /\n\t\t    (IPW_STATS_INTERVAL * 10);\n\t} else {\n\t\tmissed_beacons_percent = 0;\n\t}\n\taverage_add(&priv->average_missed_beacons, missed_beacons_percent);\n\n\tipw_get_ordinal(priv, IPW_ORD_STAT_RX_ERR_CRC, &rx_err, &len);\n\trx_err_delta = rx_err - priv->last_rx_err;\n\tpriv->last_rx_err = rx_err;\n\n\tipw_get_ordinal(priv, IPW_ORD_STAT_TX_FAILURE, &tx_failures, &len);\n\ttx_failures_delta = tx_failures - priv->last_tx_failures;\n\tpriv->last_tx_failures = tx_failures;\n\n\trx_packets_delta = priv->rx_packets - priv->last_rx_packets;\n\tpriv->last_rx_packets = priv->rx_packets;\n\n\ttx_packets_delta = priv->tx_packets - priv->last_tx_packets;\n\tpriv->last_tx_packets = priv->tx_packets;\n\n\t/* Calculate quality based on the following:\n\t *\n\t * Missed beacon: 100% = 0, 0% = 70% missed\n\t * Rate: 60% = 1Mbs, 100% = Max\n\t * Rx and Tx errors represent a straight % of total Rx/Tx\n\t * RSSI: 100% = > -50,  0% = < -80\n\t * Rx errors: 100% = 0, 0% = 50% missed\n\t *\n\t * The lowest computed quality is used.\n\t *\n\t */\n#define BEACON_THRESHOLD 5\n\tbeacon_quality = 100 - missed_beacons_percent;\n\tif (beacon_quality < BEACON_THRESHOLD)\n\t\tbeacon_quality = 0;\n\telse\n\t\tbeacon_quality = (beacon_quality - BEACON_THRESHOLD) * 100 /\n\t\t    (100 - BEACON_THRESHOLD);\n\tIPW_DEBUG_STATS(\"Missed beacon: %3d%% (%d%%)\\n\",\n\t\t\tbeacon_quality, missed_beacons_percent);\n\n\tpriv->last_rate = ipw_get_current_rate(priv);\n\tmax_rate = ipw_get_max_rate(priv);\n\trate_quality = priv->last_rate * 40 / max_rate + 60;\n\tIPW_DEBUG_STATS(\"Rate quality : %3d%% (%dMbs)\\n\",\n\t\t\trate_quality, priv->last_rate / 1000000);\n\n\tif (rx_packets_delta > 100 && rx_packets_delta + rx_err_delta)\n\t\trx_quality = 100 - (rx_err_delta * 100) /\n\t\t    (rx_packets_delta + rx_err_delta);\n\telse\n\t\trx_quality = 100;\n\tIPW_DEBUG_STATS(\"Rx quality   : %3d%% (%u errors, %u packets)\\n\",\n\t\t\trx_quality, rx_err_delta, rx_packets_delta);\n\n\tif (tx_packets_delta > 100 && tx_packets_delta + tx_failures_delta)\n\t\ttx_quality = 100 - (tx_failures_delta * 100) /\n\t\t    (tx_packets_delta + tx_failures_delta);\n\telse\n\t\ttx_quality = 100;\n\tIPW_DEBUG_STATS(\"Tx quality   : %3d%% (%u errors, %u packets)\\n\",\n\t\t\ttx_quality, tx_failures_delta, tx_packets_delta);\n\n\trssi = priv->exp_avg_rssi;\n\tsignal_quality =\n\t    (100 *\n\t     (priv->ieee->perfect_rssi - priv->ieee->worst_rssi) *\n\t     (priv->ieee->perfect_rssi - priv->ieee->worst_rssi) -\n\t     (priv->ieee->perfect_rssi - rssi) *\n\t     (15 * (priv->ieee->perfect_rssi - priv->ieee->worst_rssi) +\n\t      62 * (priv->ieee->perfect_rssi - rssi))) /\n\t    ((priv->ieee->perfect_rssi - priv->ieee->worst_rssi) *\n\t     (priv->ieee->perfect_rssi - priv->ieee->worst_rssi));\n\tif (signal_quality > 100)\n\t\tsignal_quality = 100;\n\telse if (signal_quality < 1)\n\t\tsignal_quality = 0;\n\n\tIPW_DEBUG_STATS(\"Signal level : %3d%% (%d dBm)\\n\",\n\t\t\tsignal_quality, rssi);\n\n\tquality = min(rx_quality, signal_quality);\n\tquality = min(tx_quality, quality);\n\tquality = min(rate_quality, quality);\n\tquality = min(beacon_quality, quality);\n\tif (quality == beacon_quality)\n\t\tIPW_DEBUG_STATS(\"Quality (%d%%): Clamped to missed beacons.\\n\",\n\t\t\t\tquality);\n\tif (quality == rate_quality)\n\t\tIPW_DEBUG_STATS(\"Quality (%d%%): Clamped to rate quality.\\n\",\n\t\t\t\tquality);\n\tif (quality == tx_quality)\n\t\tIPW_DEBUG_STATS(\"Quality (%d%%): Clamped to Tx quality.\\n\",\n\t\t\t\tquality);\n\tif (quality == rx_quality)\n\t\tIPW_DEBUG_STATS(\"Quality (%d%%): Clamped to Rx quality.\\n\",\n\t\t\t\tquality);\n\tif (quality == signal_quality)\n\t\tIPW_DEBUG_STATS(\"Quality (%d%%): Clamped to signal quality.\\n\",\n\t\t\t\tquality);\n\n\tpriv->quality = quality;\n\n\tschedule_delayed_work(&priv->gather_stats, IPW_STATS_INTERVAL);\n}\n\nstatic void ipw_bg_gather_stats(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, gather_stats.work);\n\tmutex_lock(&priv->mutex);\n\tipw_gather_stats(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\n/* Missed beacon behavior:\n * 1st missed -> roaming_threshold, just wait, don't do any scan/roam.\n * roaming_threshold -> disassociate_threshold, scan and roam for better signal.\n * Above disassociate threshold, give up and stop scanning.\n * Roaming is disabled if disassociate_threshold <= roaming_threshold  */\nstatic void ipw_handle_missed_beacon(struct ipw_priv *priv,\n\t\t\t\t\t    int missed_count)\n{\n\tpriv->notif_missed_beacons = missed_count;\n\n\tif (missed_count > priv->disassociate_threshold &&\n\t    priv->status & STATUS_ASSOCIATED) {\n\t\t/* If associated and we've hit the missed\n\t\t * beacon threshold, disassociate, turn\n\t\t * off roaming, and abort any active scans */\n\t\tIPW_DEBUG(IPW_DL_INFO | IPW_DL_NOTIF |\n\t\t\t  IPW_DL_STATE | IPW_DL_ASSOC,\n\t\t\t  \"Missed beacon: %d - disassociate\\n\", missed_count);\n\t\tpriv->status &= ~STATUS_ROAMING;\n\t\tif (priv->status & STATUS_SCANNING) {\n\t\t\tIPW_DEBUG(IPW_DL_INFO | IPW_DL_NOTIF |\n\t\t\t\t  IPW_DL_STATE,\n\t\t\t\t  \"Aborting scan with missed beacon.\\n\");\n\t\t\tschedule_work(&priv->abort_scan);\n\t\t}\n\n\t\tschedule_work(&priv->disassociate);\n\t\treturn;\n\t}\n\n\tif (priv->status & STATUS_ROAMING) {\n\t\t/* If we are currently roaming, then just\n\t\t * print a debug statement... */\n\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE,\n\t\t\t  \"Missed beacon: %d - roam in progress\\n\",\n\t\t\t  missed_count);\n\t\treturn;\n\t}\n\n\tif (roaming &&\n\t    (missed_count > priv->roaming_threshold &&\n\t     missed_count <= priv->disassociate_threshold)) {\n\t\t/* If we are not already roaming, set the ROAM\n\t\t * bit in the status and kick off a scan.\n\t\t * This can happen several times before we reach\n\t\t * disassociate_threshold. */\n\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE,\n\t\t\t  \"Missed beacon: %d - initiate \"\n\t\t\t  \"roaming\\n\", missed_count);\n\t\tif (!(priv->status & STATUS_ROAMING)) {\n\t\t\tpriv->status |= STATUS_ROAMING;\n\t\t\tif (!(priv->status & STATUS_SCANNING))\n\t\t\t\tschedule_delayed_work(&priv->request_scan, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (priv->status & STATUS_SCANNING &&\n\t    missed_count > IPW_MB_SCAN_CANCEL_THRESHOLD) {\n\t\t/* Stop scan to keep fw from getting\n\t\t * stuck (only if we aren't roaming --\n\t\t * otherwise we'll never scan more than 2 or 3\n\t\t * channels..) */\n\t\tIPW_DEBUG(IPW_DL_INFO | IPW_DL_NOTIF | IPW_DL_STATE,\n\t\t\t  \"Aborting scan with missed beacon.\\n\");\n\t\tschedule_work(&priv->abort_scan);\n\t}\n\n\tIPW_DEBUG_NOTIF(\"Missed beacon: %d\\n\", missed_count);\n}\n\nstatic void ipw_scan_event(struct work_struct *work)\n{\n\tunion iwreq_data wrqu;\n\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, scan_event.work);\n\n\twrqu.data.length = 0;\n\twrqu.data.flags = 0;\n\twireless_send_event(priv->net_dev, SIOCGIWSCAN, &wrqu, NULL);\n}\n\nstatic void handle_scan_event(struct ipw_priv *priv)\n{\n\t/* Only userspace-requested scan completion events go out immediately */\n\tif (!priv->user_requested_scan) {\n\t\tschedule_delayed_work(&priv->scan_event,\n\t\t\t\t      round_jiffies_relative(msecs_to_jiffies(4000)));\n\t} else {\n\t\tpriv->user_requested_scan = 0;\n\t\tmod_delayed_work(system_wq, &priv->scan_event, 0);\n\t}\n}\n\n/*\n * Handle host notification packet.\n * Called from interrupt routine\n */\nstatic void ipw_rx_notification(struct ipw_priv *priv,\n\t\t\t\t       struct ipw_rx_notification *notif)\n{\n\tu16 size = le16_to_cpu(notif->size);\n\n\tIPW_DEBUG_NOTIF(\"type = %i (%d bytes)\\n\", notif->subtype, size);\n\n\tswitch (notif->subtype) {\n\tcase HOST_NOTIFICATION_STATUS_ASSOCIATED:{\n\t\t\tstruct notif_association *assoc = &notif->u.assoc;\n\n\t\t\tswitch (assoc->state) {\n\t\t\tcase CMAS_ASSOCIATED:{\n\t\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t\t  IPW_DL_ASSOC,\n\t\t\t\t\t\t  \"associated: '%*pE' %pM\\n\",\n\t\t\t\t\t\t  priv->essid_len, priv->essid,\n\t\t\t\t\t\t  priv->bssid);\n\n\t\t\t\t\tswitch (priv->ieee->iw_mode) {\n\t\t\t\t\tcase IW_MODE_INFRA:\n\t\t\t\t\t\tmemcpy(priv->ieee->bssid,\n\t\t\t\t\t\t       priv->bssid, ETH_ALEN);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IW_MODE_ADHOC:\n\t\t\t\t\t\tmemcpy(priv->ieee->bssid,\n\t\t\t\t\t\t       priv->bssid, ETH_ALEN);\n\n\t\t\t\t\t\t/* clear out the station table */\n\t\t\t\t\t\tpriv->num_stations = 0;\n\n\t\t\t\t\t\tIPW_DEBUG_ASSOC\n\t\t\t\t\t\t    (\"queueing adhoc check\\n\");\n\t\t\t\t\t\tschedule_delayed_work(\n\t\t\t\t\t\t\t&priv->adhoc_check,\n\t\t\t\t\t\t\tle16_to_cpu(priv->\n\t\t\t\t\t\t\tassoc_request.\n\t\t\t\t\t\t\tbeacon_interval));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tpriv->status &= ~STATUS_ASSOCIATING;\n\t\t\t\t\tpriv->status |= STATUS_ASSOCIATED;\n\t\t\t\t\tschedule_work(&priv->system_config);\n\n#ifdef CONFIG_IPW2200_QOS\n#define IPW_GET_PACKET_STYPE(x) WLAN_FC_GET_STYPE( \\\n\t\t\t le16_to_cpu(((struct ieee80211_hdr *)(x))->frame_control))\n\t\t\t\t\tif ((priv->status & STATUS_AUTH) &&\n\t\t\t\t\t    (IPW_GET_PACKET_STYPE(&notif->u.raw)\n\t\t\t\t\t     == IEEE80211_STYPE_ASSOC_RESP)) {\n\t\t\t\t\t\tif ((sizeof\n\t\t\t\t\t\t     (struct\n\t\t\t\t\t\t      libipw_assoc_response)\n\t\t\t\t\t\t     <= size)\n\t\t\t\t\t\t    && (size <= 2314)) {\n\t\t\t\t\t\t\tstruct\n\t\t\t\t\t\t\tlibipw_rx_stats\n\t\t\t\t\t\t\t    stats = {\n\t\t\t\t\t\t\t\t.len = size - 1,\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tIPW_DEBUG_QOS\n\t\t\t\t\t\t\t    (\"QoS Associate \"\n\t\t\t\t\t\t\t     \"size %d\\n\", size);\n\t\t\t\t\t\t\tlibipw_rx_mgt(priv->\n\t\t\t\t\t\t\t\t\t ieee,\n\t\t\t\t\t\t\t\t\t (struct\n\t\t\t\t\t\t\t\t\t  libipw_hdr_4addr\n\t\t\t\t\t\t\t\t\t  *)\n\t\t\t\t\t\t\t\t\t &notif->u.raw, &stats);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\n\t\t\t\t\tschedule_work(&priv->link_up);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase CMAS_AUTHENTICATED:{\n\t\t\t\t\tif (priv->\n\t\t\t\t\t    status & (STATUS_ASSOCIATED |\n\t\t\t\t\t\t      STATUS_AUTH)) {\n\t\t\t\t\t\tstruct notif_authenticate *auth\n\t\t\t\t\t\t    = &notif->u.auth;\n\t\t\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF |\n\t\t\t\t\t\t\t  IPW_DL_STATE |\n\t\t\t\t\t\t\t  IPW_DL_ASSOC,\n\t\t\t\t\t\t\t  \"deauthenticated: '%*pE' %pM: (0x%04X) - %s\\n\",\n\t\t\t\t\t\t\t  priv->essid_len,\n\t\t\t\t\t\t\t  priv->essid,\n\t\t\t\t\t\t\t  priv->bssid,\n\t\t\t\t\t\t\t  le16_to_cpu(auth->status),\n\t\t\t\t\t\t\t  ipw_get_status_code\n\t\t\t\t\t\t\t  (le16_to_cpu\n\t\t\t\t\t\t\t   (auth->status)));\n\n\t\t\t\t\t\tpriv->status &=\n\t\t\t\t\t\t    ~(STATUS_ASSOCIATING |\n\t\t\t\t\t\t      STATUS_AUTH |\n\t\t\t\t\t\t      STATUS_ASSOCIATED);\n\n\t\t\t\t\t\tschedule_work(&priv->link_down);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t\t  IPW_DL_ASSOC,\n\t\t\t\t\t\t  \"authenticated: '%*pE' %pM\\n\",\n\t\t\t\t\t\t  priv->essid_len, priv->essid,\n\t\t\t\t\t\t  priv->bssid);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase CMAS_INIT:{\n\t\t\t\t\tif (priv->status & STATUS_AUTH) {\n\t\t\t\t\t\tstruct\n\t\t\t\t\t\t    libipw_assoc_response\n\t\t\t\t\t\t*resp;\n\t\t\t\t\t\tresp =\n\t\t\t\t\t\t    (struct\n\t\t\t\t\t\t     libipw_assoc_response\n\t\t\t\t\t\t     *)&notif->u.raw;\n\t\t\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF |\n\t\t\t\t\t\t\t  IPW_DL_STATE |\n\t\t\t\t\t\t\t  IPW_DL_ASSOC,\n\t\t\t\t\t\t\t  \"association failed (0x%04X): %s\\n\",\n\t\t\t\t\t\t\t  le16_to_cpu(resp->status),\n\t\t\t\t\t\t\t  ipw_get_status_code\n\t\t\t\t\t\t\t  (le16_to_cpu\n\t\t\t\t\t\t\t   (resp->status)));\n\t\t\t\t\t}\n\n\t\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t\t  IPW_DL_ASSOC,\n\t\t\t\t\t\t  \"disassociated: '%*pE' %pM\\n\",\n\t\t\t\t\t\t  priv->essid_len, priv->essid,\n\t\t\t\t\t\t  priv->bssid);\n\n\t\t\t\t\tpriv->status &=\n\t\t\t\t\t    ~(STATUS_DISASSOCIATING |\n\t\t\t\t\t      STATUS_ASSOCIATING |\n\t\t\t\t\t      STATUS_ASSOCIATED | STATUS_AUTH);\n\t\t\t\t\tif (priv->assoc_network\n\t\t\t\t\t    && (priv->assoc_network->\n\t\t\t\t\t\tcapability &\n\t\t\t\t\t\tWLAN_CAPABILITY_IBSS))\n\t\t\t\t\t\tipw_remove_current_network\n\t\t\t\t\t\t    (priv);\n\n\t\t\t\t\tschedule_work(&priv->link_down);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase CMAS_RX_ASSOC_RESP:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tIPW_ERROR(\"assoc: unknown (%d)\\n\",\n\t\t\t\t\t  assoc->state);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_STATUS_AUTHENTICATE:{\n\t\t\tstruct notif_authenticate *auth = &notif->u.auth;\n\t\t\tswitch (auth->state) {\n\t\t\tcase CMAS_AUTHENTICATED:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE,\n\t\t\t\t\t  \"authenticated: '%*pE' %pM\\n\",\n\t\t\t\t\t  priv->essid_len, priv->essid,\n\t\t\t\t\t  priv->bssid);\n\t\t\t\tpriv->status |= STATUS_AUTH;\n\t\t\t\tbreak;\n\n\t\t\tcase CMAS_INIT:\n\t\t\t\tif (priv->status & STATUS_AUTH) {\n\t\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t\t  IPW_DL_ASSOC,\n\t\t\t\t\t\t  \"authentication failed (0x%04X): %s\\n\",\n\t\t\t\t\t\t  le16_to_cpu(auth->status),\n\t\t\t\t\t\t  ipw_get_status_code(le16_to_cpu\n\t\t\t\t\t\t\t\t      (auth->\n\t\t\t\t\t\t\t\t       status)));\n\t\t\t\t}\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC,\n\t\t\t\t\t  \"deauthenticated: '%*pE' %pM\\n\",\n\t\t\t\t\t  priv->essid_len, priv->essid,\n\t\t\t\t\t  priv->bssid);\n\n\t\t\t\tpriv->status &= ~(STATUS_ASSOCIATING |\n\t\t\t\t\t\t  STATUS_AUTH |\n\t\t\t\t\t\t  STATUS_ASSOCIATED);\n\n\t\t\t\tschedule_work(&priv->link_down);\n\t\t\t\tbreak;\n\n\t\t\tcase CMAS_TX_AUTH_SEQ_1:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"AUTH_SEQ_1\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_RX_AUTH_SEQ_2:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"AUTH_SEQ_2\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_AUTH_SEQ_1_PASS:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"AUTH_SEQ_1_PASS\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_AUTH_SEQ_1_FAIL:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"AUTH_SEQ_1_FAIL\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_TX_AUTH_SEQ_3:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"AUTH_SEQ_3\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_RX_AUTH_SEQ_4:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"RX_AUTH_SEQ_4\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_AUTH_SEQ_2_PASS:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"AUTH_SEQ_2_PASS\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_AUTH_SEQ_2_FAIL:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"AUT_SEQ_2_FAIL\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_TX_ASSOC:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"TX_ASSOC\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_RX_ASSOC_RESP:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"RX_ASSOC_RESP\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase CMAS_ASSOCIATED:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"ASSOCIATED\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tIPW_DEBUG_NOTIF(\"auth: failure - %d\\n\",\n\t\t\t\t\t\tauth->state);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_STATUS_SCAN_CHANNEL_RESULT:{\n\t\t\tstruct notif_channel_result *x =\n\t\t\t    &notif->u.channel_result;\n\n\t\t\tif (size == sizeof(*x)) {\n\t\t\t\tIPW_DEBUG_SCAN(\"Scan result for channel %d\\n\",\n\t\t\t\t\t       x->channel_num);\n\t\t\t} else {\n\t\t\t\tIPW_DEBUG_SCAN(\"Scan result of wrong size %d \"\n\t\t\t\t\t       \"(should be %zd)\\n\",\n\t\t\t\t\t       size, sizeof(*x));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_STATUS_SCAN_COMPLETED:{\n\t\t\tstruct notif_scan_complete *x = &notif->u.scan_complete;\n\t\t\tif (size == sizeof(*x)) {\n\t\t\t\tIPW_DEBUG_SCAN\n\t\t\t\t    (\"Scan completed: type %d, %d channels, \"\n\t\t\t\t     \"%d status\\n\", x->scan_type,\n\t\t\t\t     x->num_channels, x->status);\n\t\t\t} else {\n\t\t\t\tIPW_ERROR(\"Scan completed of wrong size %d \"\n\t\t\t\t\t  \"(should be %zd)\\n\",\n\t\t\t\t\t  size, sizeof(*x));\n\t\t\t}\n\n\t\t\tpriv->status &=\n\t\t\t    ~(STATUS_SCANNING | STATUS_SCAN_ABORTING);\n\n\t\t\twake_up_interruptible(&priv->wait_state);\n\t\t\tcancel_delayed_work(&priv->scan_check);\n\n\t\t\tif (priv->status & STATUS_EXIT_PENDING)\n\t\t\t\tbreak;\n\n\t\t\tpriv->ieee->scans++;\n\n#ifdef CONFIG_IPW2200_MONITOR\n\t\t\tif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\n\t\t\t\tpriv->status |= STATUS_SCAN_FORCED;\n\t\t\t\tschedule_delayed_work(&priv->request_scan, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpriv->status &= ~STATUS_SCAN_FORCED;\n#endif\t\t\t\t/* CONFIG_IPW2200_MONITOR */\n\n\t\t\t/* Do queued direct scans first */\n\t\t\tif (priv->status & STATUS_DIRECT_SCAN_PENDING)\n\t\t\t\tschedule_delayed_work(&priv->request_direct_scan, 0);\n\n\t\t\tif (!(priv->status & (STATUS_ASSOCIATED |\n\t\t\t\t\t      STATUS_ASSOCIATING |\n\t\t\t\t\t      STATUS_ROAMING |\n\t\t\t\t\t      STATUS_DISASSOCIATING)))\n\t\t\t\tschedule_work(&priv->associate);\n\t\t\telse if (priv->status & STATUS_ROAMING) {\n\t\t\t\tif (x->status == SCAN_COMPLETED_STATUS_COMPLETE)\n\t\t\t\t\t/* If a scan completed and we are in roam mode, then\n\t\t\t\t\t * the scan that completed was the one requested as a\n\t\t\t\t\t * result of entering roam... so, schedule the\n\t\t\t\t\t * roam work */\n\t\t\t\t\tschedule_work(&priv->roam);\n\t\t\t\telse\n\t\t\t\t\t/* Don't schedule if we aborted the scan */\n\t\t\t\t\tpriv->status &= ~STATUS_ROAMING;\n\t\t\t} else if (priv->status & STATUS_SCAN_PENDING)\n\t\t\t\tschedule_delayed_work(&priv->request_scan, 0);\n\t\t\telse if (priv->config & CFG_BACKGROUND_SCAN\n\t\t\t\t && priv->status & STATUS_ASSOCIATED)\n\t\t\t\tschedule_delayed_work(&priv->request_scan,\n\t\t\t\t\t\t      round_jiffies_relative(HZ));\n\n\t\t\t/* Send an empty event to user space.\n\t\t\t * We don't send the received data on the event because\n\t\t\t * it would require us to do complex transcoding, and\n\t\t\t * we want to minimise the work done in the irq handler\n\t\t\t * Use a request to extract the data.\n\t\t\t * Also, we generate this even for any scan, regardless\n\t\t\t * on how the scan was initiated. User space can just\n\t\t\t * sync on periodic scan to get fresh data...\n\t\t\t * Jean II */\n\t\t\tif (x->status == SCAN_COMPLETED_STATUS_COMPLETE)\n\t\t\t\thandle_scan_event(priv);\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_STATUS_FRAG_LENGTH:{\n\t\t\tstruct notif_frag_length *x = &notif->u.frag_len;\n\n\t\t\tif (size == sizeof(*x))\n\t\t\t\tIPW_ERROR(\"Frag length: %d\\n\",\n\t\t\t\t\t  le16_to_cpu(x->frag_length));\n\t\t\telse\n\t\t\t\tIPW_ERROR(\"Frag length of wrong size %d \"\n\t\t\t\t\t  \"(should be %zd)\\n\",\n\t\t\t\t\t  size, sizeof(*x));\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_STATUS_LINK_DETERIORATION:{\n\t\t\tstruct notif_link_deterioration *x =\n\t\t\t    &notif->u.link_deterioration;\n\n\t\t\tif (size == sizeof(*x)) {\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE,\n\t\t\t\t\t\"link deterioration: type %d, cnt %d\\n\",\n\t\t\t\t\tx->silence_notification_type,\n\t\t\t\t\tx->silence_count);\n\t\t\t\tmemcpy(&priv->last_link_deterioration, x,\n\t\t\t\t       sizeof(*x));\n\t\t\t} else {\n\t\t\t\tIPW_ERROR(\"Link Deterioration of wrong size %d \"\n\t\t\t\t\t  \"(should be %zd)\\n\",\n\t\t\t\t\t  size, sizeof(*x));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_DINO_CONFIG_RESPONSE:{\n\t\t\tIPW_ERROR(\"Dino config\\n\");\n\t\t\tif (priv->hcmd\n\t\t\t    && priv->hcmd->cmd != HOST_CMD_DINO_CONFIG)\n\t\t\t\tIPW_ERROR(\"Unexpected DINO_CONFIG_RESPONSE\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_STATUS_BEACON_STATE:{\n\t\t\tstruct notif_beacon_state *x = &notif->u.beacon_state;\n\t\t\tif (size != sizeof(*x)) {\n\t\t\t\tIPW_ERROR\n\t\t\t\t    (\"Beacon state of wrong size %d (should \"\n\t\t\t\t     \"be %zd)\\n\", size, sizeof(*x));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (le32_to_cpu(x->state) ==\n\t\t\t    HOST_NOTIFICATION_STATUS_BEACON_MISSING)\n\t\t\t\tipw_handle_missed_beacon(priv,\n\t\t\t\t\t\t\t le32_to_cpu(x->\n\t\t\t\t\t\t\t\t     number));\n\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_STATUS_TGI_TX_KEY:{\n\t\t\tstruct notif_tgi_tx_key *x = &notif->u.tgi_tx_key;\n\t\t\tif (size == sizeof(*x)) {\n\t\t\t\tIPW_ERROR(\"TGi Tx Key: state 0x%02x sec type \"\n\t\t\t\t\t  \"0x%02x station %d\\n\",\n\t\t\t\t\t  x->key_state, x->security_type,\n\t\t\t\t\t  x->station_index);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tIPW_ERROR\n\t\t\t    (\"TGi Tx Key of wrong size %d (should be %zd)\\n\",\n\t\t\t     size, sizeof(*x));\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_CALIB_KEEP_RESULTS:{\n\t\t\tstruct notif_calibration *x = &notif->u.calibration;\n\n\t\t\tif (size == sizeof(*x)) {\n\t\t\t\tmemcpy(&priv->calib, x, sizeof(*x));\n\t\t\t\tIPW_DEBUG_INFO(\"TODO: Calibration\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tIPW_ERROR\n\t\t\t    (\"Calibration of wrong size %d (should be %zd)\\n\",\n\t\t\t     size, sizeof(*x));\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_NOISE_STATS:{\n\t\t\tif (size == sizeof(u32)) {\n\t\t\t\tpriv->exp_avg_noise =\n\t\t\t\t    exponential_average(priv->exp_avg_noise,\n\t\t\t\t    (u8) (le32_to_cpu(notif->u.noise.value) & 0xff),\n\t\t\t\t    DEPTH_NOISE);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tIPW_ERROR\n\t\t\t    (\"Noise stat is wrong size %d (should be %zd)\\n\",\n\t\t\t     size, sizeof(u32));\n\t\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tIPW_DEBUG_NOTIF(\"Unknown notification: \"\n\t\t\t\t\"subtype=%d,flags=0x%2x,size=%d\\n\",\n\t\t\t\tnotif->subtype, notif->flags, size);\n\t}\n}\n\n/*\n * Destroys all DMA structures and initialise them again\n *\n * @param priv\n * @return error code\n */\nstatic int ipw_queue_reset(struct ipw_priv *priv)\n{\n\tint rc = 0;\n\t/* @todo customize queue sizes */\n\tint nTx = 64, nTxCmd = 8;\n\tipw_tx_queue_free(priv);\n\t/* Tx CMD queue */\n\trc = ipw_queue_tx_init(priv, &priv->txq_cmd, nTxCmd,\n\t\t\t       IPW_TX_CMD_QUEUE_READ_INDEX,\n\t\t\t       IPW_TX_CMD_QUEUE_WRITE_INDEX,\n\t\t\t       IPW_TX_CMD_QUEUE_BD_BASE,\n\t\t\t       IPW_TX_CMD_QUEUE_BD_SIZE);\n\tif (rc) {\n\t\tIPW_ERROR(\"Tx Cmd queue init failed\\n\");\n\t\tgoto error;\n\t}\n\t/* Tx queue(s) */\n\trc = ipw_queue_tx_init(priv, &priv->txq[0], nTx,\n\t\t\t       IPW_TX_QUEUE_0_READ_INDEX,\n\t\t\t       IPW_TX_QUEUE_0_WRITE_INDEX,\n\t\t\t       IPW_TX_QUEUE_0_BD_BASE, IPW_TX_QUEUE_0_BD_SIZE);\n\tif (rc) {\n\t\tIPW_ERROR(\"Tx 0 queue init failed\\n\");\n\t\tgoto error;\n\t}\n\trc = ipw_queue_tx_init(priv, &priv->txq[1], nTx,\n\t\t\t       IPW_TX_QUEUE_1_READ_INDEX,\n\t\t\t       IPW_TX_QUEUE_1_WRITE_INDEX,\n\t\t\t       IPW_TX_QUEUE_1_BD_BASE, IPW_TX_QUEUE_1_BD_SIZE);\n\tif (rc) {\n\t\tIPW_ERROR(\"Tx 1 queue init failed\\n\");\n\t\tgoto error;\n\t}\n\trc = ipw_queue_tx_init(priv, &priv->txq[2], nTx,\n\t\t\t       IPW_TX_QUEUE_2_READ_INDEX,\n\t\t\t       IPW_TX_QUEUE_2_WRITE_INDEX,\n\t\t\t       IPW_TX_QUEUE_2_BD_BASE, IPW_TX_QUEUE_2_BD_SIZE);\n\tif (rc) {\n\t\tIPW_ERROR(\"Tx 2 queue init failed\\n\");\n\t\tgoto error;\n\t}\n\trc = ipw_queue_tx_init(priv, &priv->txq[3], nTx,\n\t\t\t       IPW_TX_QUEUE_3_READ_INDEX,\n\t\t\t       IPW_TX_QUEUE_3_WRITE_INDEX,\n\t\t\t       IPW_TX_QUEUE_3_BD_BASE, IPW_TX_QUEUE_3_BD_SIZE);\n\tif (rc) {\n\t\tIPW_ERROR(\"Tx 3 queue init failed\\n\");\n\t\tgoto error;\n\t}\n\t/* statistics */\n\tpriv->rx_bufs_min = 0;\n\tpriv->rx_pend_max = 0;\n\treturn rc;\n\n      error:\n\tipw_tx_queue_free(priv);\n\treturn rc;\n}\n\n/*\n * Reclaim Tx queue entries no more used by NIC.\n *\n * When FW advances 'R' index, all entries between old and\n * new 'R' index need to be reclaimed. As result, some free space\n * forms. If there is enough free space (> low mark), wake Tx queue.\n *\n * @note Need to protect against garbage in 'R' index\n * @param priv\n * @param txq\n * @param qindex\n * @return Number of used entries remains in the queue\n */\nstatic int ipw_queue_tx_reclaim(struct ipw_priv *priv,\n\t\t\t\tstruct clx2_tx_queue *txq, int qindex)\n{\n\tu32 hw_tail;\n\tint used;\n\tstruct clx2_queue *q = &txq->q;\n\n\thw_tail = ipw_read32(priv, q->reg_r);\n\tif (hw_tail >= q->n_bd) {\n\t\tIPW_ERROR\n\t\t    (\"Read index for DMA queue (%d) is out of range [0-%d)\\n\",\n\t\t     hw_tail, q->n_bd);\n\t\tgoto done;\n\t}\n\tfor (; q->last_used != hw_tail;\n\t     q->last_used = ipw_queue_inc_wrap(q->last_used, q->n_bd)) {\n\t\tipw_queue_tx_free_tfd(priv, txq);\n\t\tpriv->tx_packets++;\n\t}\n      done:\n\tif ((ipw_tx_queue_space(q) > q->low_mark) &&\n\t    (qindex >= 0))\n\t\tnetif_wake_queue(priv->net_dev);\n\tused = q->first_empty - q->last_used;\n\tif (used < 0)\n\t\tused += q->n_bd;\n\n\treturn used;\n}\n\nstatic int ipw_queue_tx_hcmd(struct ipw_priv *priv, int hcmd, void *buf,\n\t\t\t     int len, int sync)\n{\n\tstruct clx2_tx_queue *txq = &priv->txq_cmd;\n\tstruct clx2_queue *q = &txq->q;\n\tstruct tfd_frame *tfd;\n\n\tif (ipw_tx_queue_space(q) < (sync ? 1 : 2)) {\n\t\tIPW_ERROR(\"No space for Tx\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\ttfd = &txq->bd[q->first_empty];\n\ttxq->txb[q->first_empty] = NULL;\n\n\tmemset(tfd, 0, sizeof(*tfd));\n\ttfd->control_flags.message_type = TX_HOST_COMMAND_TYPE;\n\ttfd->control_flags.control_bits = TFD_NEED_IRQ_MASK;\n\tpriv->hcmd_seq++;\n\ttfd->u.cmd.index = hcmd;\n\ttfd->u.cmd.length = len;\n\tmemcpy(tfd->u.cmd.payload, buf, len);\n\tq->first_empty = ipw_queue_inc_wrap(q->first_empty, q->n_bd);\n\tipw_write32(priv, q->reg_w, q->first_empty);\n\t_ipw_read32(priv, 0x90);\n\n\treturn 0;\n}\n\n/*\n * Rx theory of operation\n *\n * The host allocates 32 DMA target addresses and passes the host address\n * to the firmware at register IPW_RFDS_TABLE_LOWER + N * RFD_SIZE where N is\n * 0 to 31\n *\n * Rx Queue Indexes\n * The host/firmware share two index registers for managing the Rx buffers.\n *\n * The READ index maps to the first position that the firmware may be writing\n * to -- the driver can read up to (but not including) this position and get\n * good data.\n * The READ index is managed by the firmware once the card is enabled.\n *\n * The WRITE index maps to the last position the driver has read from -- the\n * position preceding WRITE is the last slot the firmware can place a packet.\n *\n * The queue is empty (no good data) if WRITE = READ - 1, and is full if\n * WRITE = READ.\n *\n * During initialization the host sets up the READ queue position to the first\n * INDEX position, and WRITE to the last (READ - 1 wrapped)\n *\n * When the firmware places a packet in a buffer it will advance the READ index\n * and fire the RX interrupt.  The driver can then query the READ index and\n * process as many packets as possible, moving the WRITE index forward as it\n * resets the Rx queue buffers with new memory.\n *\n * The management in the driver is as follows:\n * + A list of pre-allocated SKBs is stored in ipw->rxq->rx_free.  When\n *   ipw->rxq->free_count drops to or below RX_LOW_WATERMARK, work is scheduled\n *   to replensish the ipw->rxq->rx_free.\n * + In ipw_rx_queue_replenish (scheduled) if 'processed' != 'read' then the\n *   ipw->rxq is replenished and the READ INDEX is updated (updating the\n *   'processed' and 'read' driver indexes as well)\n * + A received packet is processed and handed to the kernel network stack,\n *   detached from the ipw->rxq.  The driver 'processed' index is updated.\n * + The Host/Firmware ipw->rxq is replenished at tasklet time from the rx_free\n *   list. If there are no allocated buffers in ipw->rxq->rx_free, the READ\n *   INDEX is not incremented and ipw->status(RX_STALLED) is set.  If there\n *   were enough free buffers and RX_STALLED is set it is cleared.\n *\n *\n * Driver sequence:\n *\n * ipw_rx_queue_alloc()       Allocates rx_free\n * ipw_rx_queue_replenish()   Replenishes rx_free list from rx_used, and calls\n *                            ipw_rx_queue_restock\n * ipw_rx_queue_restock()     Moves available buffers from rx_free into Rx\n *                            queue, updates firmware pointers, and updates\n *                            the WRITE index.  If insufficient rx_free buffers\n *                            are available, schedules ipw_rx_queue_replenish\n *\n * -- enable interrupts --\n * ISR - ipw_rx()             Detach ipw_rx_mem_buffers from pool up to the\n *                            READ INDEX, detaching the SKB from the pool.\n *                            Moves the packet buffer from queue to rx_used.\n *                            Calls ipw_rx_queue_restock to refill any empty\n *                            slots.\n * ...\n *\n */\n\n/*\n * If there are slots in the RX queue that  need to be restocked,\n * and we have free pre-allocated buffers, fill the ranks as much\n * as we can pulling from rx_free.\n *\n * This moves the 'write' index forward to catch up with 'processed', and\n * also updates the memory address in the firmware to reference the new\n * target buffer.\n */\nstatic void ipw_rx_queue_restock(struct ipw_priv *priv)\n{\n\tstruct ipw_rx_queue *rxq = priv->rxq;\n\tstruct list_head *element;\n\tstruct ipw_rx_mem_buffer *rxb;\n\tunsigned long flags;\n\tint write;\n\n\tspin_lock_irqsave(&rxq->lock, flags);\n\twrite = rxq->write;\n\twhile ((ipw_rx_queue_space(rxq) > 0) && (rxq->free_count)) {\n\t\telement = rxq->rx_free.next;\n\t\trxb = list_entry(element, struct ipw_rx_mem_buffer, list);\n\t\tlist_del(element);\n\n\t\tipw_write32(priv, IPW_RFDS_TABLE_LOWER + rxq->write * RFD_SIZE,\n\t\t\t    rxb->dma_addr);\n\t\trxq->queue[rxq->write] = rxb;\n\t\trxq->write = (rxq->write + 1) % RX_QUEUE_SIZE;\n\t\trxq->free_count--;\n\t}\n\tspin_unlock_irqrestore(&rxq->lock, flags);\n\n\t/* If the pre-allocated buffer pool is dropping low, schedule to\n\t * refill it */\n\tif (rxq->free_count <= RX_LOW_WATERMARK)\n\t\tschedule_work(&priv->rx_replenish);\n\n\t/* If we've added more space for the firmware to place data, tell it */\n\tif (write != rxq->write)\n\t\tipw_write32(priv, IPW_RX_WRITE_INDEX, rxq->write);\n}\n\n/*\n * Move all used packet from rx_used to rx_free, allocating a new SKB for each.\n * Also restock the Rx queue via ipw_rx_queue_restock.\n *\n * This is called as a scheduled work item (except for during initialization)\n */\nstatic void ipw_rx_queue_replenish(void *data)\n{\n\tstruct ipw_priv *priv = data;\n\tstruct ipw_rx_queue *rxq = priv->rxq;\n\tstruct list_head *element;\n\tstruct ipw_rx_mem_buffer *rxb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rxq->lock, flags);\n\twhile (!list_empty(&rxq->rx_used)) {\n\t\telement = rxq->rx_used.next;\n\t\trxb = list_entry(element, struct ipw_rx_mem_buffer, list);\n\t\trxb->skb = alloc_skb(IPW_RX_BUF_SIZE, GFP_ATOMIC);\n\t\tif (!rxb->skb) {\n\t\t\tprintk(KERN_CRIT \"%s: Can not allocate SKB buffers.\\n\",\n\t\t\t       priv->net_dev->name);\n\t\t\t/* We don't reschedule replenish work here -- we will\n\t\t\t * call the restock method and if it still needs\n\t\t\t * more buffers it will schedule replenish */\n\t\t\tbreak;\n\t\t}\n\t\tlist_del(element);\n\n\t\trxb->dma_addr =\n\t\t    dma_map_single(&priv->pci_dev->dev, rxb->skb->data,\n\t\t\t\t   IPW_RX_BUF_SIZE, DMA_FROM_DEVICE);\n\n\t\tlist_add_tail(&rxb->list, &rxq->rx_free);\n\t\trxq->free_count++;\n\t}\n\tspin_unlock_irqrestore(&rxq->lock, flags);\n\n\tipw_rx_queue_restock(priv);\n}\n\nstatic void ipw_bg_rx_queue_replenish(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, rx_replenish);\n\tmutex_lock(&priv->mutex);\n\tipw_rx_queue_replenish(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\n/* Assumes that the skb field of the buffers in 'pool' is kept accurate.\n * If an SKB has been detached, the POOL needs to have its SKB set to NULL\n * This free routine walks the list of POOL entries and if SKB is set to\n * non NULL it is unmapped and freed\n */\nstatic void ipw_rx_queue_free(struct ipw_priv *priv, struct ipw_rx_queue *rxq)\n{\n\tint i;\n\n\tif (!rxq)\n\t\treturn;\n\n\tfor (i = 0; i < RX_QUEUE_SIZE + RX_FREE_BUFFERS; i++) {\n\t\tif (rxq->pool[i].skb != NULL) {\n\t\t\tdma_unmap_single(&priv->pci_dev->dev,\n\t\t\t\t\t rxq->pool[i].dma_addr,\n\t\t\t\t\t IPW_RX_BUF_SIZE, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(rxq->pool[i].skb);\n\t\t}\n\t}\n\n\tkfree(rxq);\n}\n\nstatic struct ipw_rx_queue *ipw_rx_queue_alloc(struct ipw_priv *priv)\n{\n\tstruct ipw_rx_queue *rxq;\n\tint i;\n\n\trxq = kzalloc(sizeof(*rxq), GFP_KERNEL);\n\tif (unlikely(!rxq)) {\n\t\tIPW_ERROR(\"memory allocation failed\\n\");\n\t\treturn NULL;\n\t}\n\tspin_lock_init(&rxq->lock);\n\tINIT_LIST_HEAD(&rxq->rx_free);\n\tINIT_LIST_HEAD(&rxq->rx_used);\n\n\t/* Fill the rx_used queue with _all_ of the Rx buffers */\n\tfor (i = 0; i < RX_FREE_BUFFERS + RX_QUEUE_SIZE; i++)\n\t\tlist_add_tail(&rxq->pool[i].list, &rxq->rx_used);\n\n\t/* Set us so that we have processed and used all buffers, but have\n\t * not restocked the Rx queue with fresh buffers */\n\trxq->read = rxq->write = 0;\n\trxq->free_count = 0;\n\n\treturn rxq;\n}\n\nstatic int ipw_is_rate_in_mask(struct ipw_priv *priv, int ieee_mode, u8 rate)\n{\n\trate &= ~LIBIPW_BASIC_RATE_MASK;\n\tif (ieee_mode == IEEE_A) {\n\t\tswitch (rate) {\n\t\tcase LIBIPW_OFDM_RATE_6MB:\n\t\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_6MB_MASK ?\n\t\t\t    1 : 0;\n\t\tcase LIBIPW_OFDM_RATE_9MB:\n\t\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_9MB_MASK ?\n\t\t\t    1 : 0;\n\t\tcase LIBIPW_OFDM_RATE_12MB:\n\t\t\treturn priv->\n\t\t\t    rates_mask & LIBIPW_OFDM_RATE_12MB_MASK ? 1 : 0;\n\t\tcase LIBIPW_OFDM_RATE_18MB:\n\t\t\treturn priv->\n\t\t\t    rates_mask & LIBIPW_OFDM_RATE_18MB_MASK ? 1 : 0;\n\t\tcase LIBIPW_OFDM_RATE_24MB:\n\t\t\treturn priv->\n\t\t\t    rates_mask & LIBIPW_OFDM_RATE_24MB_MASK ? 1 : 0;\n\t\tcase LIBIPW_OFDM_RATE_36MB:\n\t\t\treturn priv->\n\t\t\t    rates_mask & LIBIPW_OFDM_RATE_36MB_MASK ? 1 : 0;\n\t\tcase LIBIPW_OFDM_RATE_48MB:\n\t\t\treturn priv->\n\t\t\t    rates_mask & LIBIPW_OFDM_RATE_48MB_MASK ? 1 : 0;\n\t\tcase LIBIPW_OFDM_RATE_54MB:\n\t\t\treturn priv->\n\t\t\t    rates_mask & LIBIPW_OFDM_RATE_54MB_MASK ? 1 : 0;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* B and G mixed */\n\tswitch (rate) {\n\tcase LIBIPW_CCK_RATE_1MB:\n\t\treturn priv->rates_mask & LIBIPW_CCK_RATE_1MB_MASK ? 1 : 0;\n\tcase LIBIPW_CCK_RATE_2MB:\n\t\treturn priv->rates_mask & LIBIPW_CCK_RATE_2MB_MASK ? 1 : 0;\n\tcase LIBIPW_CCK_RATE_5MB:\n\t\treturn priv->rates_mask & LIBIPW_CCK_RATE_5MB_MASK ? 1 : 0;\n\tcase LIBIPW_CCK_RATE_11MB:\n\t\treturn priv->rates_mask & LIBIPW_CCK_RATE_11MB_MASK ? 1 : 0;\n\t}\n\n\t/* If we are limited to B modulations, bail at this point */\n\tif (ieee_mode == IEEE_B)\n\t\treturn 0;\n\n\t/* G */\n\tswitch (rate) {\n\tcase LIBIPW_OFDM_RATE_6MB:\n\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_6MB_MASK ? 1 : 0;\n\tcase LIBIPW_OFDM_RATE_9MB:\n\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_9MB_MASK ? 1 : 0;\n\tcase LIBIPW_OFDM_RATE_12MB:\n\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_12MB_MASK ? 1 : 0;\n\tcase LIBIPW_OFDM_RATE_18MB:\n\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_18MB_MASK ? 1 : 0;\n\tcase LIBIPW_OFDM_RATE_24MB:\n\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_24MB_MASK ? 1 : 0;\n\tcase LIBIPW_OFDM_RATE_36MB:\n\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_36MB_MASK ? 1 : 0;\n\tcase LIBIPW_OFDM_RATE_48MB:\n\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_48MB_MASK ? 1 : 0;\n\tcase LIBIPW_OFDM_RATE_54MB:\n\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_54MB_MASK ? 1 : 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int ipw_compatible_rates(struct ipw_priv *priv,\n\t\t\t\tconst struct libipw_network *network,\n\t\t\t\tstruct ipw_supported_rates *rates)\n{\n\tint num_rates, i;\n\n\tmemset(rates, 0, sizeof(*rates));\n\tnum_rates = min(network->rates_len, (u8) IPW_MAX_RATES);\n\trates->num_rates = 0;\n\tfor (i = 0; i < num_rates; i++) {\n\t\tif (!ipw_is_rate_in_mask(priv, network->mode,\n\t\t\t\t\t network->rates[i])) {\n\n\t\t\tif (network->rates[i] & LIBIPW_BASIC_RATE_MASK) {\n\t\t\t\tIPW_DEBUG_SCAN(\"Adding masked mandatory \"\n\t\t\t\t\t       \"rate %02X\\n\",\n\t\t\t\t\t       network->rates[i]);\n\t\t\t\trates->supported_rates[rates->num_rates++] =\n\t\t\t\t    network->rates[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tIPW_DEBUG_SCAN(\"Rate %02X masked : 0x%08X\\n\",\n\t\t\t\t       network->rates[i], priv->rates_mask);\n\t\t\tcontinue;\n\t\t}\n\n\t\trates->supported_rates[rates->num_rates++] = network->rates[i];\n\t}\n\n\tnum_rates = min(network->rates_ex_len,\n\t\t\t(u8) (IPW_MAX_RATES - num_rates));\n\tfor (i = 0; i < num_rates; i++) {\n\t\tif (!ipw_is_rate_in_mask(priv, network->mode,\n\t\t\t\t\t network->rates_ex[i])) {\n\t\t\tif (network->rates_ex[i] & LIBIPW_BASIC_RATE_MASK) {\n\t\t\t\tIPW_DEBUG_SCAN(\"Adding masked mandatory \"\n\t\t\t\t\t       \"rate %02X\\n\",\n\t\t\t\t\t       network->rates_ex[i]);\n\t\t\t\trates->supported_rates[rates->num_rates++] =\n\t\t\t\t    network->rates[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tIPW_DEBUG_SCAN(\"Rate %02X masked : 0x%08X\\n\",\n\t\t\t\t       network->rates_ex[i], priv->rates_mask);\n\t\t\tcontinue;\n\t\t}\n\n\t\trates->supported_rates[rates->num_rates++] =\n\t\t    network->rates_ex[i];\n\t}\n\n\treturn 1;\n}\n\nstatic void ipw_copy_rates(struct ipw_supported_rates *dest,\n\t\t\t\t  const struct ipw_supported_rates *src)\n{\n\tu8 i;\n\tfor (i = 0; i < src->num_rates; i++)\n\t\tdest->supported_rates[i] = src->supported_rates[i];\n\tdest->num_rates = src->num_rates;\n}\n\n/* TODO: Look at sniffed packets in the air to determine if the basic rate\n * mask should ever be used -- right now all callers to add the scan rates are\n * set with the modulation = CCK, so BASIC_RATE_MASK is never set... */\nstatic void ipw_add_cck_scan_rates(struct ipw_supported_rates *rates,\n\t\t\t\t   u8 modulation, u32 rate_mask)\n{\n\tu8 basic_mask = (LIBIPW_OFDM_MODULATION == modulation) ?\n\t    LIBIPW_BASIC_RATE_MASK : 0;\n\n\tif (rate_mask & LIBIPW_CCK_RATE_1MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] =\n\t\t    LIBIPW_BASIC_RATE_MASK | LIBIPW_CCK_RATE_1MB;\n\n\tif (rate_mask & LIBIPW_CCK_RATE_2MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] =\n\t\t    LIBIPW_BASIC_RATE_MASK | LIBIPW_CCK_RATE_2MB;\n\n\tif (rate_mask & LIBIPW_CCK_RATE_5MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] = basic_mask |\n\t\t    LIBIPW_CCK_RATE_5MB;\n\n\tif (rate_mask & LIBIPW_CCK_RATE_11MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] = basic_mask |\n\t\t    LIBIPW_CCK_RATE_11MB;\n}\n\nstatic void ipw_add_ofdm_scan_rates(struct ipw_supported_rates *rates,\n\t\t\t\t    u8 modulation, u32 rate_mask)\n{\n\tu8 basic_mask = (LIBIPW_OFDM_MODULATION == modulation) ?\n\t    LIBIPW_BASIC_RATE_MASK : 0;\n\n\tif (rate_mask & LIBIPW_OFDM_RATE_6MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] = basic_mask |\n\t\t    LIBIPW_OFDM_RATE_6MB;\n\n\tif (rate_mask & LIBIPW_OFDM_RATE_9MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] =\n\t\t    LIBIPW_OFDM_RATE_9MB;\n\n\tif (rate_mask & LIBIPW_OFDM_RATE_12MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] = basic_mask |\n\t\t    LIBIPW_OFDM_RATE_12MB;\n\n\tif (rate_mask & LIBIPW_OFDM_RATE_18MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] =\n\t\t    LIBIPW_OFDM_RATE_18MB;\n\n\tif (rate_mask & LIBIPW_OFDM_RATE_24MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] = basic_mask |\n\t\t    LIBIPW_OFDM_RATE_24MB;\n\n\tif (rate_mask & LIBIPW_OFDM_RATE_36MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] =\n\t\t    LIBIPW_OFDM_RATE_36MB;\n\n\tif (rate_mask & LIBIPW_OFDM_RATE_48MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] =\n\t\t    LIBIPW_OFDM_RATE_48MB;\n\n\tif (rate_mask & LIBIPW_OFDM_RATE_54MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] =\n\t\t    LIBIPW_OFDM_RATE_54MB;\n}\n\nstruct ipw_network_match {\n\tstruct libipw_network *network;\n\tstruct ipw_supported_rates rates;\n};\n\nstatic int ipw_find_adhoc_network(struct ipw_priv *priv,\n\t\t\t\t  struct ipw_network_match *match,\n\t\t\t\t  struct libipw_network *network,\n\t\t\t\t  int roaming)\n{\n\tstruct ipw_supported_rates rates;\n\n\t/* Verify that this network's capability is compatible with the\n\t * current mode (AdHoc or Infrastructure) */\n\tif ((priv->ieee->iw_mode == IW_MODE_ADHOC &&\n\t     !(network->capability & WLAN_CAPABILITY_IBSS))) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded due to capability mismatch.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\tif (unlikely(roaming)) {\n\t\t/* If we are roaming, then ensure check if this is a valid\n\t\t * network to try and roam to */\n\t\tif ((network->ssid_len != match->network->ssid_len) ||\n\t\t    memcmp(network->ssid, match->network->ssid,\n\t\t\t   network->ssid_len)) {\n\t\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because of non-network ESSID.\\n\",\n\t\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\t\tnetwork->bssid);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t/* If an ESSID has been configured then compare the broadcast\n\t\t * ESSID to ours */\n\t\tif ((priv->config & CFG_STATIC_ESSID) &&\n\t\t    ((network->ssid_len != priv->essid_len) ||\n\t\t     memcmp(network->ssid, priv->essid,\n\t\t\t    min(network->ssid_len, priv->essid_len)))) {\n\t\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because of ESSID mismatch: '%*pE'.\\n\",\n\t\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\t\tnetwork->bssid, priv->essid_len,\n\t\t\t\t\tpriv->essid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* If the old network rate is better than this one, don't bother\n\t * testing everything else. */\n\n\tif (network->time_stamp[0] < match->network->time_stamp[0]) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE excluded because newer than current network.\\n\",\n\t\t\t\tmatch->network->ssid_len, match->network->ssid);\n\t\treturn 0;\n\t} else if (network->time_stamp[1] < match->network->time_stamp[1]) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE excluded because newer than current network.\\n\",\n\t\t\t\tmatch->network->ssid_len, match->network->ssid);\n\t\treturn 0;\n\t}\n\n\t/* Now go through and see if the requested network is valid... */\n\tif (priv->ieee->scan_age != 0 &&\n\t    time_after(jiffies, network->last_scanned + priv->ieee->scan_age)) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because of age: %ums.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid,\n\t\t\t\tjiffies_to_msecs(jiffies -\n\t\t\t\t\t\t network->last_scanned));\n\t\treturn 0;\n\t}\n\n\tif ((priv->config & CFG_STATIC_CHANNEL) &&\n\t    (network->channel != priv->channel)) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because of channel mismatch: %d != %d.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid,\n\t\t\t\tnetwork->channel, priv->channel);\n\t\treturn 0;\n\t}\n\n\t/* Verify privacy compatibility */\n\tif (((priv->capability & CAP_PRIVACY_ON) ? 1 : 0) !=\n\t    ((network->capability & WLAN_CAPABILITY_PRIVACY) ? 1 : 0)) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because of privacy mismatch: %s != %s.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid,\n\t\t\t\tpriv->\n\t\t\t\tcapability & CAP_PRIVACY_ON ? \"on\" : \"off\",\n\t\t\t\tnetwork->\n\t\t\t\tcapability & WLAN_CAPABILITY_PRIVACY ? \"on\" :\n\t\t\t\t\"off\");\n\t\treturn 0;\n\t}\n\n\tif (ether_addr_equal(network->bssid, priv->bssid)) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because of the same BSSID match: %pM.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid, priv->bssid);\n\t\treturn 0;\n\t}\n\n\t/* Filter out any incompatible freq / mode combinations */\n\tif (!libipw_is_valid_mode(priv->ieee, network->mode)) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because of invalid frequency/mode combination.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\t/* Ensure that the rates supported by the driver are compatible with\n\t * this AP, including verification of basic rates (mandatory) */\n\tif (!ipw_compatible_rates(priv, network, &rates)) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because configured rate mask excludes AP mandatory rate.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\tif (rates.num_rates == 0) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because of no compatible rates.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\t/* TODO: Perform any further minimal comparititive tests.  We do not\n\t * want to put too much policy logic here; intelligent scan selection\n\t * should occur within a generic IEEE 802.11 user space tool.  */\n\n\t/* Set up 'new' AP to this network */\n\tipw_copy_rates(&match->rates, &rates);\n\tmatch->network = network;\n\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' is a viable match.\\n\",\n\t\t\tnetwork->ssid_len, network->ssid, network->bssid);\n\n\treturn 1;\n}\n\nstatic void ipw_merge_adhoc_network(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, merge_networks);\n\tstruct libipw_network *network = NULL;\n\tstruct ipw_network_match match = {\n\t\t.network = priv->assoc_network\n\t};\n\n\tif ((priv->status & STATUS_ASSOCIATED) &&\n\t    (priv->ieee->iw_mode == IW_MODE_ADHOC)) {\n\t\t/* First pass through ROAM process -- look for a better\n\t\t * network */\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&priv->ieee->lock, flags);\n\t\tlist_for_each_entry(network, &priv->ieee->network_list, list) {\n\t\t\tif (network != priv->assoc_network)\n\t\t\t\tipw_find_adhoc_network(priv, &match, network,\n\t\t\t\t\t\t       1);\n\t\t}\n\t\tspin_unlock_irqrestore(&priv->ieee->lock, flags);\n\n\t\tif (match.network == priv->assoc_network) {\n\t\t\tIPW_DEBUG_MERGE(\"No better ADHOC in this network to \"\n\t\t\t\t\t\"merge to.\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tmutex_lock(&priv->mutex);\n\t\tif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\t\tIPW_DEBUG_MERGE(\"remove network %*pE\\n\",\n\t\t\t\t\tpriv->essid_len, priv->essid);\n\t\t\tipw_remove_current_network(priv);\n\t\t}\n\n\t\tipw_disassociate(priv);\n\t\tpriv->assoc_network = match.network;\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn;\n\t}\n}\n\nstatic int ipw_best_network(struct ipw_priv *priv,\n\t\t\t    struct ipw_network_match *match,\n\t\t\t    struct libipw_network *network, int roaming)\n{\n\tstruct ipw_supported_rates rates;\n\n\t/* Verify that this network's capability is compatible with the\n\t * current mode (AdHoc or Infrastructure) */\n\tif ((priv->ieee->iw_mode == IW_MODE_INFRA &&\n\t     !(network->capability & WLAN_CAPABILITY_ESS)) ||\n\t    (priv->ieee->iw_mode == IW_MODE_ADHOC &&\n\t     !(network->capability & WLAN_CAPABILITY_IBSS))) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded due to capability mismatch.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\tif (unlikely(roaming)) {\n\t\t/* If we are roaming, then ensure check if this is a valid\n\t\t * network to try and roam to */\n\t\tif ((network->ssid_len != match->network->ssid_len) ||\n\t\t    memcmp(network->ssid, match->network->ssid,\n\t\t\t   network->ssid_len)) {\n\t\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of non-network ESSID.\\n\",\n\t\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\t\tnetwork->bssid);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t/* If an ESSID has been configured then compare the broadcast\n\t\t * ESSID to ours */\n\t\tif ((priv->config & CFG_STATIC_ESSID) &&\n\t\t    ((network->ssid_len != priv->essid_len) ||\n\t\t     memcmp(network->ssid, priv->essid,\n\t\t\t    min(network->ssid_len, priv->essid_len)))) {\n\t\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of ESSID mismatch: '%*pE'.\\n\",\n\t\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\t\tnetwork->bssid, priv->essid_len,\n\t\t\t\t\tpriv->essid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* If the old network rate is better than this one, don't bother\n\t * testing everything else. */\n\tif (match->network && match->network->stats.rssi > network->stats.rssi) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because '%*pE (%pM)' has a stronger signal.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid, match->network->ssid_len,\n\t\t\t\tmatch->network->ssid, match->network->bssid);\n\t\treturn 0;\n\t}\n\n\t/* If this network has already had an association attempt within the\n\t * last 3 seconds, do not try and associate again... */\n\tif (network->last_associate &&\n\t    time_after(network->last_associate + (HZ * 3UL), jiffies)) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of storming (%ums since last assoc attempt).\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid,\n\t\t\t\tjiffies_to_msecs(jiffies -\n\t\t\t\t\t\t network->last_associate));\n\t\treturn 0;\n\t}\n\n\t/* Now go through and see if the requested network is valid... */\n\tif (priv->ieee->scan_age != 0 &&\n\t    time_after(jiffies, network->last_scanned + priv->ieee->scan_age)) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of age: %ums.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid,\n\t\t\t\tjiffies_to_msecs(jiffies -\n\t\t\t\t\t\t network->last_scanned));\n\t\treturn 0;\n\t}\n\n\tif ((priv->config & CFG_STATIC_CHANNEL) &&\n\t    (network->channel != priv->channel)) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of channel mismatch: %d != %d.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid,\n\t\t\t\tnetwork->channel, priv->channel);\n\t\treturn 0;\n\t}\n\n\t/* Verify privacy compatibility */\n\tif (((priv->capability & CAP_PRIVACY_ON) ? 1 : 0) !=\n\t    ((network->capability & WLAN_CAPABILITY_PRIVACY) ? 1 : 0)) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of privacy mismatch: %s != %s.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid,\n\t\t\t\tpriv->capability & CAP_PRIVACY_ON ? \"on\" :\n\t\t\t\t\"off\",\n\t\t\t\tnetwork->capability &\n\t\t\t\tWLAN_CAPABILITY_PRIVACY ? \"on\" : \"off\");\n\t\treturn 0;\n\t}\n\n\tif ((priv->config & CFG_STATIC_BSSID) &&\n\t    !ether_addr_equal(network->bssid, priv->bssid)) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of BSSID mismatch: %pM.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid, priv->bssid);\n\t\treturn 0;\n\t}\n\n\t/* Filter out any incompatible freq / mode combinations */\n\tif (!libipw_is_valid_mode(priv->ieee, network->mode)) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of invalid frequency/mode combination.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\t/* Filter out invalid channel in current GEO */\n\tif (!libipw_is_valid_channel(priv->ieee, network->channel)) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of invalid channel in current GEO\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\t/* Ensure that the rates supported by the driver are compatible with\n\t * this AP, including verification of basic rates (mandatory) */\n\tif (!ipw_compatible_rates(priv, network, &rates)) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because configured rate mask excludes AP mandatory rate.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\tif (rates.num_rates == 0) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of no compatible rates.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\t/* TODO: Perform any further minimal comparititive tests.  We do not\n\t * want to put too much policy logic here; intelligent scan selection\n\t * should occur within a generic IEEE 802.11 user space tool.  */\n\n\t/* Set up 'new' AP to this network */\n\tipw_copy_rates(&match->rates, &rates);\n\tmatch->network = network;\n\n\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' is a viable match.\\n\",\n\t\t\tnetwork->ssid_len, network->ssid, network->bssid);\n\n\treturn 1;\n}\n\nstatic void ipw_adhoc_create(struct ipw_priv *priv,\n\t\t\t     struct libipw_network *network)\n{\n\tconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\n\tint i;\n\n\t/*\n\t * For the purposes of scanning, we can set our wireless mode\n\t * to trigger scans across combinations of bands, but when it\n\t * comes to creating a new ad-hoc network, we have tell the FW\n\t * exactly which band to use.\n\t *\n\t * We also have the possibility of an invalid channel for the\n\t * chossen band.  Attempting to create a new ad-hoc network\n\t * with an invalid channel for wireless mode will trigger a\n\t * FW fatal error.\n\t *\n\t */\n\tswitch (libipw_is_valid_channel(priv->ieee, priv->channel)) {\n\tcase LIBIPW_52GHZ_BAND:\n\t\tnetwork->mode = IEEE_A;\n\t\ti = libipw_channel_to_index(priv->ieee, priv->channel);\n\t\tBUG_ON(i == -1);\n\t\tif (geo->a[i].flags & LIBIPW_CH_PASSIVE_ONLY) {\n\t\t\tIPW_WARNING(\"Overriding invalid channel\\n\");\n\t\t\tpriv->channel = geo->a[0].channel;\n\t\t}\n\t\tbreak;\n\n\tcase LIBIPW_24GHZ_BAND:\n\t\tif (priv->ieee->mode & IEEE_G)\n\t\t\tnetwork->mode = IEEE_G;\n\t\telse\n\t\t\tnetwork->mode = IEEE_B;\n\t\ti = libipw_channel_to_index(priv->ieee, priv->channel);\n\t\tBUG_ON(i == -1);\n\t\tif (geo->bg[i].flags & LIBIPW_CH_PASSIVE_ONLY) {\n\t\t\tIPW_WARNING(\"Overriding invalid channel\\n\");\n\t\t\tpriv->channel = geo->bg[0].channel;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tIPW_WARNING(\"Overriding invalid channel\\n\");\n\t\tif (priv->ieee->mode & IEEE_A) {\n\t\t\tnetwork->mode = IEEE_A;\n\t\t\tpriv->channel = geo->a[0].channel;\n\t\t} else if (priv->ieee->mode & IEEE_G) {\n\t\t\tnetwork->mode = IEEE_G;\n\t\t\tpriv->channel = geo->bg[0].channel;\n\t\t} else {\n\t\t\tnetwork->mode = IEEE_B;\n\t\t\tpriv->channel = geo->bg[0].channel;\n\t\t}\n\t\tbreak;\n\t}\n\n\tnetwork->channel = priv->channel;\n\tpriv->config |= CFG_ADHOC_PERSIST;\n\tipw_create_bssid(priv, network->bssid);\n\tnetwork->ssid_len = priv->essid_len;\n\tmemcpy(network->ssid, priv->essid, priv->essid_len);\n\tmemset(&network->stats, 0, sizeof(network->stats));\n\tnetwork->capability = WLAN_CAPABILITY_IBSS;\n\tif (!(priv->config & CFG_PREAMBLE_LONG))\n\t\tnetwork->capability |= WLAN_CAPABILITY_SHORT_PREAMBLE;\n\tif (priv->capability & CAP_PRIVACY_ON)\n\t\tnetwork->capability |= WLAN_CAPABILITY_PRIVACY;\n\tnetwork->rates_len = min(priv->rates.num_rates, MAX_RATES_LENGTH);\n\tmemcpy(network->rates, priv->rates.supported_rates, network->rates_len);\n\tnetwork->rates_ex_len = priv->rates.num_rates - network->rates_len;\n\tmemcpy(network->rates_ex,\n\t       &priv->rates.supported_rates[network->rates_len],\n\t       network->rates_ex_len);\n\tnetwork->last_scanned = 0;\n\tnetwork->flags = 0;\n\tnetwork->last_associate = 0;\n\tnetwork->time_stamp[0] = 0;\n\tnetwork->time_stamp[1] = 0;\n\tnetwork->beacon_interval = 100;\t/* Default */\n\tnetwork->listen_interval = 10;\t/* Default */\n\tnetwork->atim_window = 0;\t/* Default */\n\tnetwork->wpa_ie_len = 0;\n\tnetwork->rsn_ie_len = 0;\n}\n\nstatic void ipw_send_tgi_tx_key(struct ipw_priv *priv, int type, int index)\n{\n\tstruct ipw_tgi_tx_key key;\n\n\tif (!(priv->ieee->sec.flags & (1 << index)))\n\t\treturn;\n\n\tkey.key_id = index;\n\tmemcpy(key.key, priv->ieee->sec.keys[index], SCM_TEMPORAL_KEY_LENGTH);\n\tkey.security_type = type;\n\tkey.station_index = 0;\t/* always 0 for BSS */\n\tkey.flags = 0;\n\t/* 0 for new key; previous value of counter (after fatal error) */\n\tkey.tx_counter[0] = cpu_to_le32(0);\n\tkey.tx_counter[1] = cpu_to_le32(0);\n\n\tipw_send_cmd_pdu(priv, IPW_CMD_TGI_TX_KEY, sizeof(key), &key);\n}\n\nstatic void ipw_send_wep_keys(struct ipw_priv *priv, int type)\n{\n\tstruct ipw_wep_key key;\n\tint i;\n\n\tkey.cmd_id = DINO_CMD_WEP_KEY;\n\tkey.seq_num = 0;\n\n\t/* Note: AES keys cannot be set for multiple times.\n\t * Only set it at the first time. */\n\tfor (i = 0; i < 4; i++) {\n\t\tkey.key_index = i | type;\n\t\tif (!(priv->ieee->sec.flags & (1 << i))) {\n\t\t\tkey.key_size = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey.key_size = priv->ieee->sec.key_sizes[i];\n\t\tmemcpy(key.key, priv->ieee->sec.keys[i], key.key_size);\n\n\t\tipw_send_cmd_pdu(priv, IPW_CMD_WEP_KEY, sizeof(key), &key);\n\t}\n}\n\nstatic void ipw_set_hw_decrypt_unicast(struct ipw_priv *priv, int level)\n{\n\tif (priv->ieee->host_encrypt)\n\t\treturn;\n\n\tswitch (level) {\n\tcase SEC_LEVEL_3:\n\t\tpriv->sys_config.disable_unicast_decryption = 0;\n\t\tpriv->ieee->host_decrypt = 0;\n\t\tbreak;\n\tcase SEC_LEVEL_2:\n\t\tpriv->sys_config.disable_unicast_decryption = 1;\n\t\tpriv->ieee->host_decrypt = 1;\n\t\tbreak;\n\tcase SEC_LEVEL_1:\n\t\tpriv->sys_config.disable_unicast_decryption = 0;\n\t\tpriv->ieee->host_decrypt = 0;\n\t\tbreak;\n\tcase SEC_LEVEL_0:\n\t\tpriv->sys_config.disable_unicast_decryption = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ipw_set_hw_decrypt_multicast(struct ipw_priv *priv, int level)\n{\n\tif (priv->ieee->host_encrypt)\n\t\treturn;\n\n\tswitch (level) {\n\tcase SEC_LEVEL_3:\n\t\tpriv->sys_config.disable_multicast_decryption = 0;\n\t\tbreak;\n\tcase SEC_LEVEL_2:\n\t\tpriv->sys_config.disable_multicast_decryption = 1;\n\t\tbreak;\n\tcase SEC_LEVEL_1:\n\t\tpriv->sys_config.disable_multicast_decryption = 0;\n\t\tbreak;\n\tcase SEC_LEVEL_0:\n\t\tpriv->sys_config.disable_multicast_decryption = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ipw_set_hwcrypto_keys(struct ipw_priv *priv)\n{\n\tswitch (priv->ieee->sec.level) {\n\tcase SEC_LEVEL_3:\n\t\tif (priv->ieee->sec.flags & SEC_ACTIVE_KEY)\n\t\t\tipw_send_tgi_tx_key(priv,\n\t\t\t\t\t    DCT_FLAG_EXT_SECURITY_CCM,\n\t\t\t\t\t    priv->ieee->sec.active_key);\n\n\t\tif (!priv->ieee->host_mc_decrypt)\n\t\t\tipw_send_wep_keys(priv, DCW_WEP_KEY_SEC_TYPE_CCM);\n\t\tbreak;\n\tcase SEC_LEVEL_2:\n\t\tif (priv->ieee->sec.flags & SEC_ACTIVE_KEY)\n\t\t\tipw_send_tgi_tx_key(priv,\n\t\t\t\t\t    DCT_FLAG_EXT_SECURITY_TKIP,\n\t\t\t\t\t    priv->ieee->sec.active_key);\n\t\tbreak;\n\tcase SEC_LEVEL_1:\n\t\tipw_send_wep_keys(priv, DCW_WEP_KEY_SEC_TYPE_WEP);\n\t\tipw_set_hw_decrypt_unicast(priv, priv->ieee->sec.level);\n\t\tipw_set_hw_decrypt_multicast(priv, priv->ieee->sec.level);\n\t\tbreak;\n\tcase SEC_LEVEL_0:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ipw_adhoc_check(void *data)\n{\n\tstruct ipw_priv *priv = data;\n\n\tif (priv->missed_adhoc_beacons++ > priv->disassociate_threshold &&\n\t    !(priv->config & CFG_ADHOC_PERSIST)) {\n\t\tIPW_DEBUG(IPW_DL_INFO | IPW_DL_NOTIF |\n\t\t\t  IPW_DL_STATE | IPW_DL_ASSOC,\n\t\t\t  \"Missed beacon: %d - disassociate\\n\",\n\t\t\t  priv->missed_adhoc_beacons);\n\t\tipw_remove_current_network(priv);\n\t\tipw_disassociate(priv);\n\t\treturn;\n\t}\n\n\tschedule_delayed_work(&priv->adhoc_check,\n\t\t\t      le16_to_cpu(priv->assoc_request.beacon_interval));\n}\n\nstatic void ipw_bg_adhoc_check(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, adhoc_check.work);\n\tmutex_lock(&priv->mutex);\n\tipw_adhoc_check(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_debug_config(struct ipw_priv *priv)\n{\n\tIPW_DEBUG_INFO(\"Scan completed, no valid APs matched \"\n\t\t       \"[CFG 0x%08X]\\n\", priv->config);\n\tif (priv->config & CFG_STATIC_CHANNEL)\n\t\tIPW_DEBUG_INFO(\"Channel locked to %d\\n\", priv->channel);\n\telse\n\t\tIPW_DEBUG_INFO(\"Channel unlocked.\\n\");\n\tif (priv->config & CFG_STATIC_ESSID)\n\t\tIPW_DEBUG_INFO(\"ESSID locked to '%*pE'\\n\",\n\t\t\t       priv->essid_len, priv->essid);\n\telse\n\t\tIPW_DEBUG_INFO(\"ESSID unlocked.\\n\");\n\tif (priv->config & CFG_STATIC_BSSID)\n\t\tIPW_DEBUG_INFO(\"BSSID locked to %pM\\n\", priv->bssid);\n\telse\n\t\tIPW_DEBUG_INFO(\"BSSID unlocked.\\n\");\n\tif (priv->capability & CAP_PRIVACY_ON)\n\t\tIPW_DEBUG_INFO(\"PRIVACY on\\n\");\n\telse\n\t\tIPW_DEBUG_INFO(\"PRIVACY off\\n\");\n\tIPW_DEBUG_INFO(\"RATE MASK: 0x%08X\\n\", priv->rates_mask);\n}\n\nstatic void ipw_set_fixed_rate(struct ipw_priv *priv, int mode)\n{\n\t/* TODO: Verify that this works... */\n\tstruct ipw_fixed_rate fr;\n\tu32 reg;\n\tu16 mask = 0;\n\tu16 new_tx_rates = priv->rates_mask;\n\n\t/* Identify 'current FW band' and match it with the fixed\n\t * Tx rates */\n\n\tswitch (priv->ieee->freq_band) {\n\tcase LIBIPW_52GHZ_BAND:\t/* A only */\n\t\t/* IEEE_A */\n\t\tif (priv->rates_mask & ~LIBIPW_OFDM_RATES_MASK) {\n\t\t\t/* Invalid fixed rate mask */\n\t\t\tIPW_DEBUG_WX\n\t\t\t    (\"invalid fixed rate mask in ipw_set_fixed_rate\\n\");\n\t\t\tnew_tx_rates = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tnew_tx_rates >>= LIBIPW_OFDM_SHIFT_MASK_A;\n\t\tbreak;\n\n\tdefault:\t\t/* 2.4Ghz or Mixed */\n\t\t/* IEEE_B */\n\t\tif (mode == IEEE_B) {\n\t\t\tif (new_tx_rates & ~LIBIPW_CCK_RATES_MASK) {\n\t\t\t\t/* Invalid fixed rate mask */\n\t\t\t\tIPW_DEBUG_WX\n\t\t\t\t    (\"invalid fixed rate mask in ipw_set_fixed_rate\\n\");\n\t\t\t\tnew_tx_rates = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* IEEE_G */\n\t\tif (new_tx_rates & ~(LIBIPW_CCK_RATES_MASK |\n\t\t\t\t    LIBIPW_OFDM_RATES_MASK)) {\n\t\t\t/* Invalid fixed rate mask */\n\t\t\tIPW_DEBUG_WX\n\t\t\t    (\"invalid fixed rate mask in ipw_set_fixed_rate\\n\");\n\t\t\tnew_tx_rates = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (LIBIPW_OFDM_RATE_6MB_MASK & new_tx_rates) {\n\t\t\tmask |= (LIBIPW_OFDM_RATE_6MB_MASK >> 1);\n\t\t\tnew_tx_rates &= ~LIBIPW_OFDM_RATE_6MB_MASK;\n\t\t}\n\n\t\tif (LIBIPW_OFDM_RATE_9MB_MASK & new_tx_rates) {\n\t\t\tmask |= (LIBIPW_OFDM_RATE_9MB_MASK >> 1);\n\t\t\tnew_tx_rates &= ~LIBIPW_OFDM_RATE_9MB_MASK;\n\t\t}\n\n\t\tif (LIBIPW_OFDM_RATE_12MB_MASK & new_tx_rates) {\n\t\t\tmask |= (LIBIPW_OFDM_RATE_12MB_MASK >> 1);\n\t\t\tnew_tx_rates &= ~LIBIPW_OFDM_RATE_12MB_MASK;\n\t\t}\n\n\t\tnew_tx_rates |= mask;\n\t\tbreak;\n\t}\n\n\tfr.tx_rates = cpu_to_le16(new_tx_rates);\n\n\treg = ipw_read32(priv, IPW_MEM_FIXED_OVERRIDE);\n\tipw_write_reg32(priv, reg, *(u32 *) & fr);\n}\n\nstatic void ipw_abort_scan(struct ipw_priv *priv)\n{\n\tint err;\n\n\tif (priv->status & STATUS_SCAN_ABORTING) {\n\t\tIPW_DEBUG_HC(\"Ignoring concurrent scan abort request.\\n\");\n\t\treturn;\n\t}\n\tpriv->status |= STATUS_SCAN_ABORTING;\n\n\terr = ipw_send_scan_abort(priv);\n\tif (err)\n\t\tIPW_DEBUG_HC(\"Request to abort scan failed.\\n\");\n}\n\nstatic void ipw_add_scan_channels(struct ipw_priv *priv,\n\t\t\t\t  struct ipw_scan_request_ext *scan,\n\t\t\t\t  int scan_type)\n{\n\tint channel_index = 0;\n\tconst struct libipw_geo *geo;\n\tint i;\n\n\tgeo = libipw_get_geo(priv->ieee);\n\n\tif (priv->ieee->freq_band & LIBIPW_52GHZ_BAND) {\n\t\tint start = channel_index;\n\t\tfor (i = 0; i < geo->a_channels; i++) {\n\t\t\tif ((priv->status & STATUS_ASSOCIATED) &&\n\t\t\t    geo->a[i].channel == priv->channel)\n\t\t\t\tcontinue;\n\t\t\tchannel_index++;\n\t\t\tscan->channels_list[channel_index] = geo->a[i].channel;\n\t\t\tipw_set_scan_type(scan, channel_index,\n\t\t\t\t\t  geo->a[i].\n\t\t\t\t\t  flags & LIBIPW_CH_PASSIVE_ONLY ?\n\t\t\t\t\t  IPW_SCAN_PASSIVE_FULL_DWELL_SCAN :\n\t\t\t\t\t  scan_type);\n\t\t}\n\n\t\tif (start != channel_index) {\n\t\t\tscan->channels_list[start] = (u8) (IPW_A_MODE << 6) |\n\t\t\t    (channel_index - start);\n\t\t\tchannel_index++;\n\t\t}\n\t}\n\n\tif (priv->ieee->freq_band & LIBIPW_24GHZ_BAND) {\n\t\tint start = channel_index;\n\t\tif (priv->config & CFG_SPEED_SCAN) {\n\t\t\tint index;\n\t\t\tu8 channels[LIBIPW_24GHZ_CHANNELS] = {\n\t\t\t\t/* nop out the list */\n\t\t\t\t[0] = 0\n\t\t\t};\n\n\t\t\tu8 channel;\n\t\t\twhile (channel_index < IPW_SCAN_CHANNELS - 1) {\n\t\t\t\tchannel =\n\t\t\t\t    priv->speed_scan[priv->speed_scan_pos];\n\t\t\t\tif (channel == 0) {\n\t\t\t\t\tpriv->speed_scan_pos = 0;\n\t\t\t\t\tchannel = priv->speed_scan[0];\n\t\t\t\t}\n\t\t\t\tif ((priv->status & STATUS_ASSOCIATED) &&\n\t\t\t\t    channel == priv->channel) {\n\t\t\t\t\tpriv->speed_scan_pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* If this channel has already been\n\t\t\t\t * added in scan, break from loop\n\t\t\t\t * and this will be the first channel\n\t\t\t\t * in the next scan.\n\t\t\t\t */\n\t\t\t\tif (channels[channel - 1] != 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tchannels[channel - 1] = 1;\n\t\t\t\tpriv->speed_scan_pos++;\n\t\t\t\tchannel_index++;\n\t\t\t\tscan->channels_list[channel_index] = channel;\n\t\t\t\tindex =\n\t\t\t\t    libipw_channel_to_index(priv->ieee, channel);\n\t\t\t\tipw_set_scan_type(scan, channel_index,\n\t\t\t\t\t\t  geo->bg[index].\n\t\t\t\t\t\t  flags &\n\t\t\t\t\t\t  LIBIPW_CH_PASSIVE_ONLY ?\n\t\t\t\t\t\t  IPW_SCAN_PASSIVE_FULL_DWELL_SCAN\n\t\t\t\t\t\t  : scan_type);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < geo->bg_channels; i++) {\n\t\t\t\tif ((priv->status & STATUS_ASSOCIATED) &&\n\t\t\t\t    geo->bg[i].channel == priv->channel)\n\t\t\t\t\tcontinue;\n\t\t\t\tchannel_index++;\n\t\t\t\tscan->channels_list[channel_index] =\n\t\t\t\t    geo->bg[i].channel;\n\t\t\t\tipw_set_scan_type(scan, channel_index,\n\t\t\t\t\t\t  geo->bg[i].\n\t\t\t\t\t\t  flags &\n\t\t\t\t\t\t  LIBIPW_CH_PASSIVE_ONLY ?\n\t\t\t\t\t\t  IPW_SCAN_PASSIVE_FULL_DWELL_SCAN\n\t\t\t\t\t\t  : scan_type);\n\t\t\t}\n\t\t}\n\n\t\tif (start != channel_index) {\n\t\t\tscan->channels_list[start] = (u8) (IPW_B_MODE << 6) |\n\t\t\t    (channel_index - start);\n\t\t}\n\t}\n}\n\nstatic int ipw_passive_dwell_time(struct ipw_priv *priv)\n{\n\t/* staying on passive channels longer than the DTIM interval during a\n\t * scan, while associated, causes the firmware to cancel the scan\n\t * without notification. Hence, don't stay on passive channels longer\n\t * than the beacon interval.\n\t */\n\tif (priv->status & STATUS_ASSOCIATED\n\t    && priv->assoc_network->beacon_interval > 10)\n\t\treturn priv->assoc_network->beacon_interval - 10;\n\telse\n\t\treturn 120;\n}\n\nstatic int ipw_request_scan_helper(struct ipw_priv *priv, int type, int direct)\n{\n\tstruct ipw_scan_request_ext scan;\n\tint err = 0, scan_type;\n\n\tif (!(priv->status & STATUS_INIT) ||\n\t    (priv->status & STATUS_EXIT_PENDING))\n\t\treturn 0;\n\n\tmutex_lock(&priv->mutex);\n\n\tif (direct && (priv->direct_scan_ssid_len == 0)) {\n\t\tIPW_DEBUG_HC(\"Direct scan requested but no SSID to scan for\\n\");\n\t\tpriv->status &= ~STATUS_DIRECT_SCAN_PENDING;\n\t\tgoto done;\n\t}\n\n\tif (priv->status & STATUS_SCANNING) {\n\t\tIPW_DEBUG_HC(\"Concurrent scan requested.  Queuing.\\n\");\n\t\tpriv->status |= direct ? STATUS_DIRECT_SCAN_PENDING :\n\t\t\t\t\tSTATUS_SCAN_PENDING;\n\t\tgoto done;\n\t}\n\n\tif (!(priv->status & STATUS_SCAN_FORCED) &&\n\t    priv->status & STATUS_SCAN_ABORTING) {\n\t\tIPW_DEBUG_HC(\"Scan request while abort pending.  Queuing.\\n\");\n\t\tpriv->status |= direct ? STATUS_DIRECT_SCAN_PENDING :\n\t\t\t\t\tSTATUS_SCAN_PENDING;\n\t\tgoto done;\n\t}\n\n\tif (priv->status & STATUS_RF_KILL_MASK) {\n\t\tIPW_DEBUG_HC(\"Queuing scan due to RF Kill activation\\n\");\n\t\tpriv->status |= direct ? STATUS_DIRECT_SCAN_PENDING :\n\t\t\t\t\tSTATUS_SCAN_PENDING;\n\t\tgoto done;\n\t}\n\n\tmemset(&scan, 0, sizeof(scan));\n\tscan.full_scan_index = cpu_to_le32(libipw_get_scans(priv->ieee));\n\n\tif (type == IW_SCAN_TYPE_PASSIVE) {\n\t\tIPW_DEBUG_WX(\"use passive scanning\\n\");\n\t\tscan_type = IPW_SCAN_PASSIVE_FULL_DWELL_SCAN;\n\t\tscan.dwell_time[IPW_SCAN_PASSIVE_FULL_DWELL_SCAN] =\n\t\t\tcpu_to_le16(ipw_passive_dwell_time(priv));\n\t\tipw_add_scan_channels(priv, &scan, scan_type);\n\t\tgoto send_request;\n\t}\n\n\t/* Use active scan by default. */\n\tif (priv->config & CFG_SPEED_SCAN)\n\t\tscan.dwell_time[IPW_SCAN_ACTIVE_BROADCAST_SCAN] =\n\t\t\tcpu_to_le16(30);\n\telse\n\t\tscan.dwell_time[IPW_SCAN_ACTIVE_BROADCAST_SCAN] =\n\t\t\tcpu_to_le16(20);\n\n\tscan.dwell_time[IPW_SCAN_ACTIVE_BROADCAST_AND_DIRECT_SCAN] =\n\t\tcpu_to_le16(20);\n\n\tscan.dwell_time[IPW_SCAN_PASSIVE_FULL_DWELL_SCAN] =\n\t\tcpu_to_le16(ipw_passive_dwell_time(priv));\n\tscan.dwell_time[IPW_SCAN_ACTIVE_DIRECT_SCAN] = cpu_to_le16(20);\n\n#ifdef CONFIG_IPW2200_MONITOR\n\tif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tu8 channel;\n\t\tu8 band = 0;\n\n\t\tswitch (libipw_is_valid_channel(priv->ieee, priv->channel)) {\n\t\tcase LIBIPW_52GHZ_BAND:\n\t\t\tband = (u8) (IPW_A_MODE << 6) | 1;\n\t\t\tchannel = priv->channel;\n\t\t\tbreak;\n\n\t\tcase LIBIPW_24GHZ_BAND:\n\t\t\tband = (u8) (IPW_B_MODE << 6) | 1;\n\t\t\tchannel = priv->channel;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tband = (u8) (IPW_B_MODE << 6) | 1;\n\t\t\tchannel = 9;\n\t\t\tbreak;\n\t\t}\n\n\t\tscan.channels_list[0] = band;\n\t\tscan.channels_list[1] = channel;\n\t\tipw_set_scan_type(&scan, 1, IPW_SCAN_PASSIVE_FULL_DWELL_SCAN);\n\n\t\t/* NOTE:  The card will sit on this channel for this time\n\t\t * period.  Scan aborts are timing sensitive and frequently\n\t\t * result in firmware restarts.  As such, it is best to\n\t\t * set a small dwell_time here and just keep re-issuing\n\t\t * scans.  Otherwise fast channel hopping will not actually\n\t\t * hop channels.\n\t\t *\n\t\t * TODO: Move SPEED SCAN support to all modes and bands */\n\t\tscan.dwell_time[IPW_SCAN_PASSIVE_FULL_DWELL_SCAN] =\n\t\t\tcpu_to_le16(2000);\n\t} else {\n#endif\t\t\t\t/* CONFIG_IPW2200_MONITOR */\n\t\t/* Honor direct scans first, otherwise if we are roaming make\n\t\t * this a direct scan for the current network.  Finally,\n\t\t * ensure that every other scan is a fast channel hop scan */\n\t\tif (direct) {\n\t\t\terr = ipw_send_ssid(priv, priv->direct_scan_ssid,\n\t\t\t                    priv->direct_scan_ssid_len);\n\t\t\tif (err) {\n\t\t\t\tIPW_DEBUG_HC(\"Attempt to send SSID command  \"\n\t\t\t\t\t     \"failed\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tscan_type = IPW_SCAN_ACTIVE_BROADCAST_AND_DIRECT_SCAN;\n\t\t} else if ((priv->status & STATUS_ROAMING)\n\t\t\t   || (!(priv->status & STATUS_ASSOCIATED)\n\t\t\t       && (priv->config & CFG_STATIC_ESSID)\n\t\t\t       && (le32_to_cpu(scan.full_scan_index) % 2))) {\n\t\t\terr = ipw_send_ssid(priv, priv->essid, priv->essid_len);\n\t\t\tif (err) {\n\t\t\t\tIPW_DEBUG_HC(\"Attempt to send SSID command \"\n\t\t\t\t\t     \"failed.\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tscan_type = IPW_SCAN_ACTIVE_BROADCAST_AND_DIRECT_SCAN;\n\t\t} else\n\t\t\tscan_type = IPW_SCAN_ACTIVE_BROADCAST_SCAN;\n\n\t\tipw_add_scan_channels(priv, &scan, scan_type);\n#ifdef CONFIG_IPW2200_MONITOR\n\t}\n#endif\n\nsend_request:\n\terr = ipw_send_scan_request_ext(priv, &scan);\n\tif (err) {\n\t\tIPW_DEBUG_HC(\"Sending scan command failed: %08X\\n\", err);\n\t\tgoto done;\n\t}\n\n\tpriv->status |= STATUS_SCANNING;\n\tif (direct) {\n\t\tpriv->status &= ~STATUS_DIRECT_SCAN_PENDING;\n\t\tpriv->direct_scan_ssid_len = 0;\n\t} else\n\t\tpriv->status &= ~STATUS_SCAN_PENDING;\n\n\tschedule_delayed_work(&priv->scan_check, IPW_SCAN_CHECK_WATCHDOG);\ndone:\n\tmutex_unlock(&priv->mutex);\n\treturn err;\n}\n\nstatic void ipw_request_passive_scan(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, request_passive_scan.work);\n\tipw_request_scan_helper(priv, IW_SCAN_TYPE_PASSIVE, 0);\n}\n\nstatic void ipw_request_scan(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, request_scan.work);\n\tipw_request_scan_helper(priv, IW_SCAN_TYPE_ACTIVE, 0);\n}\n\nstatic void ipw_request_direct_scan(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, request_direct_scan.work);\n\tipw_request_scan_helper(priv, IW_SCAN_TYPE_ACTIVE, 1);\n}\n\nstatic void ipw_bg_abort_scan(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, abort_scan);\n\tmutex_lock(&priv->mutex);\n\tipw_abort_scan(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int ipw_wpa_enable(struct ipw_priv *priv, int value)\n{\n\t/* This is called when wpa_supplicant loads and closes the driver\n\t * interface. */\n\tpriv->ieee->wpa_enabled = value;\n\treturn 0;\n}\n\nstatic int ipw_wpa_set_auth_algs(struct ipw_priv *priv, int value)\n{\n\tstruct libipw_device *ieee = priv->ieee;\n\tstruct libipw_security sec = {\n\t\t.flags = SEC_AUTH_MODE,\n\t};\n\tint ret = 0;\n\n\tif (value & IW_AUTH_ALG_SHARED_KEY) {\n\t\tsec.auth_mode = WLAN_AUTH_SHARED_KEY;\n\t\tieee->open_wep = 0;\n\t} else if (value & IW_AUTH_ALG_OPEN_SYSTEM) {\n\t\tsec.auth_mode = WLAN_AUTH_OPEN;\n\t\tieee->open_wep = 1;\n\t} else if (value & IW_AUTH_ALG_LEAP) {\n\t\tsec.auth_mode = WLAN_AUTH_LEAP;\n\t\tieee->open_wep = 1;\n\t} else\n\t\treturn -EINVAL;\n\n\tif (ieee->set_security)\n\t\tieee->set_security(ieee->dev, &sec);\n\telse\n\t\tret = -EOPNOTSUPP;\n\n\treturn ret;\n}\n\nstatic void ipw_wpa_assoc_frame(struct ipw_priv *priv, char *wpa_ie,\n\t\t\t\tint wpa_ie_len)\n{\n\t/* make sure WPA is enabled */\n\tipw_wpa_enable(priv, 1);\n}\n\nstatic int ipw_set_rsn_capa(struct ipw_priv *priv,\n\t\t\t    char *capabilities, int length)\n{\n\tIPW_DEBUG_HC(\"HOST_CMD_RSN_CAPABILITIES\\n\");\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_RSN_CAPABILITIES, length,\n\t\t\t\tcapabilities);\n}\n\n/*\n * WE-18 support\n */\n\n/* SIOCSIWGENIE */\nstatic int ipw_wx_set_genie(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct libipw_device *ieee = priv->ieee;\n\tu8 *buf;\n\tint err = 0;\n\n\tif (wrqu->data.length > MAX_WPA_IE_LEN ||\n\t    (wrqu->data.length && extra == NULL))\n\t\treturn -EINVAL;\n\n\tif (wrqu->data.length) {\n\t\tbuf = kmemdup(extra, wrqu->data.length, GFP_KERNEL);\n\t\tif (buf == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkfree(ieee->wpa_ie);\n\t\tieee->wpa_ie = buf;\n\t\tieee->wpa_ie_len = wrqu->data.length;\n\t} else {\n\t\tkfree(ieee->wpa_ie);\n\t\tieee->wpa_ie = NULL;\n\t\tieee->wpa_ie_len = 0;\n\t}\n\n\tipw_wpa_assoc_frame(priv, ieee->wpa_ie, ieee->wpa_ie_len);\n      out:\n\treturn err;\n}\n\n/* SIOCGIWGENIE */\nstatic int ipw_wx_get_genie(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct libipw_device *ieee = priv->ieee;\n\tint err = 0;\n\n\tif (ieee->wpa_ie_len == 0 || ieee->wpa_ie == NULL) {\n\t\twrqu->data.length = 0;\n\t\tgoto out;\n\t}\n\n\tif (wrqu->data.length < ieee->wpa_ie_len) {\n\t\terr = -E2BIG;\n\t\tgoto out;\n\t}\n\n\twrqu->data.length = ieee->wpa_ie_len;\n\tmemcpy(extra, ieee->wpa_ie, ieee->wpa_ie_len);\n\n      out:\n\treturn err;\n}\n\nstatic int wext_cipher2level(int cipher)\n{\n\tswitch (cipher) {\n\tcase IW_AUTH_CIPHER_NONE:\n\t\treturn SEC_LEVEL_0;\n\tcase IW_AUTH_CIPHER_WEP40:\n\tcase IW_AUTH_CIPHER_WEP104:\n\t\treturn SEC_LEVEL_1;\n\tcase IW_AUTH_CIPHER_TKIP:\n\t\treturn SEC_LEVEL_2;\n\tcase IW_AUTH_CIPHER_CCMP:\n\t\treturn SEC_LEVEL_3;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n/* SIOCSIWAUTH */\nstatic int ipw_wx_set_auth(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct libipw_device *ieee = priv->ieee;\n\tstruct iw_param *param = &wrqu->param;\n\tstruct lib80211_crypt_data *crypt;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\t\tbreak;\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\t\tipw_set_hw_decrypt_unicast(priv,\n\t\t\t\t\t   wext_cipher2level(param->value));\n\t\tbreak;\n\tcase IW_AUTH_CIPHER_GROUP:\n\t\tipw_set_hw_decrypt_multicast(priv,\n\t\t\t\t\t     wext_cipher2level(param->value));\n\t\tbreak;\n\tcase IW_AUTH_KEY_MGMT:\n\t\t/*\n\t\t * ipw2200 does not use these parameters\n\t\t */\n\t\tbreak;\n\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tcrypt = priv->ieee->crypt_info.crypt[priv->ieee->crypt_info.tx_keyidx];\n\t\tif (!crypt || !crypt->ops->set_flags || !crypt->ops->get_flags)\n\t\t\tbreak;\n\n\t\tflags = crypt->ops->get_flags(crypt->priv);\n\n\t\tif (param->value)\n\t\t\tflags |= IEEE80211_CRYPTO_TKIP_COUNTERMEASURES;\n\t\telse\n\t\t\tflags &= ~IEEE80211_CRYPTO_TKIP_COUNTERMEASURES;\n\n\t\tcrypt->ops->set_flags(flags, crypt->priv);\n\n\t\tbreak;\n\n\tcase IW_AUTH_DROP_UNENCRYPTED:{\n\t\t\t/* HACK:\n\t\t\t *\n\t\t\t * wpa_supplicant calls set_wpa_enabled when the driver\n\t\t\t * is loaded and unloaded, regardless of if WPA is being\n\t\t\t * used.  No other calls are made which can be used to\n\t\t\t * determine if encryption will be used or not prior to\n\t\t\t * association being expected.  If encryption is not being\n\t\t\t * used, drop_unencrypted is set to false, else true -- we\n\t\t\t * can use this to determine if the CAP_PRIVACY_ON bit should\n\t\t\t * be set.\n\t\t\t */\n\t\t\tstruct libipw_security sec = {\n\t\t\t\t.flags = SEC_ENABLED,\n\t\t\t\t.enabled = param->value,\n\t\t\t};\n\t\t\tpriv->ieee->drop_unencrypted = param->value;\n\t\t\t/* We only change SEC_LEVEL for open mode. Others\n\t\t\t * are set by ipw_wpa_set_encryption.\n\t\t\t */\n\t\t\tif (!param->value) {\n\t\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\t\tsec.level = SEC_LEVEL_0;\n\t\t\t} else {\n\t\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\t\tsec.level = SEC_LEVEL_1;\n\t\t\t}\n\t\t\tif (priv->ieee->set_security)\n\t\t\t\tpriv->ieee->set_security(priv->ieee->dev, &sec);\n\t\t\tbreak;\n\t\t}\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tret = ipw_wpa_set_auth_algs(priv, param->value);\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tret = ipw_wpa_enable(priv, param->value);\n\t\tipw_disassociate(priv);\n\t\tbreak;\n\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\t\tieee->ieee802_1x = param->value;\n\t\tbreak;\n\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\t\tieee->privacy_invoked = param->value;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn ret;\n}\n\n/* SIOCGIWAUTH */\nstatic int ipw_wx_get_auth(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct libipw_device *ieee = priv->ieee;\n\tstruct lib80211_crypt_data *crypt;\n\tstruct iw_param *param = &wrqu->param;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_KEY_MGMT:\n\t\t/*\n\t\t * wpa_supplicant will control these internally\n\t\t */\n\t\treturn -EOPNOTSUPP;\n\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tcrypt = priv->ieee->crypt_info.crypt[priv->ieee->crypt_info.tx_keyidx];\n\t\tif (!crypt || !crypt->ops->get_flags)\n\t\t\tbreak;\n\n\t\tparam->value = (crypt->ops->get_flags(crypt->priv) &\n\t\t\t\tIEEE80211_CRYPTO_TKIP_COUNTERMEASURES) ? 1 : 0;\n\n\t\tbreak;\n\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tparam->value = ieee->drop_unencrypted;\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tparam->value = ieee->sec.auth_mode;\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tparam->value = ieee->wpa_enabled;\n\t\tbreak;\n\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\t\tparam->value = ieee->ieee802_1x;\n\t\tbreak;\n\n\tcase IW_AUTH_ROAMING_CONTROL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\t\tparam->value = ieee->privacy_invoked;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n/* SIOCSIWENCODEEXT */\nstatic int ipw_wx_set_encodeext(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\n\tif (hwcrypto) {\n\t\tif (ext->alg == IW_ENCODE_ALG_TKIP) {\n\t\t\t/* IPW HW can't build TKIP MIC,\n\t\t\t   host decryption still needed */\n\t\t\tif (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)\n\t\t\t\tpriv->ieee->host_mc_decrypt = 1;\n\t\t\telse {\n\t\t\t\tpriv->ieee->host_encrypt = 0;\n\t\t\t\tpriv->ieee->host_encrypt_msdu = 1;\n\t\t\t\tpriv->ieee->host_decrypt = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tpriv->ieee->host_encrypt = 0;\n\t\t\tpriv->ieee->host_encrypt_msdu = 0;\n\t\t\tpriv->ieee->host_decrypt = 0;\n\t\t\tpriv->ieee->host_mc_decrypt = 0;\n\t\t}\n\t}\n\n\treturn libipw_wx_set_encodeext(priv->ieee, info, wrqu, extra);\n}\n\n/* SIOCGIWENCODEEXT */\nstatic int ipw_wx_get_encodeext(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\treturn libipw_wx_get_encodeext(priv->ieee, info, wrqu, extra);\n}\n\n/* SIOCSIWMLME */\nstatic int ipw_wx_set_mlme(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct iw_mlme *mlme = (struct iw_mlme *)extra;\n\n\tswitch (mlme->cmd) {\n\tcase IW_MLME_DEAUTH:\n\t\t/* silently ignore */\n\t\tbreak;\n\n\tcase IW_MLME_DISASSOC:\n\t\tipw_disassociate(priv);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_IPW2200_QOS\n\n/* QoS */\n/*\n* get the modulation type of the current network or\n* the card current mode\n*/\nstatic u8 ipw_qos_current_mode(struct ipw_priv * priv)\n{\n\tu8 mode = 0;\n\n\tif (priv->status & STATUS_ASSOCIATED) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&priv->ieee->lock, flags);\n\t\tmode = priv->assoc_network->mode;\n\t\tspin_unlock_irqrestore(&priv->ieee->lock, flags);\n\t} else {\n\t\tmode = priv->ieee->mode;\n\t}\n\tIPW_DEBUG_QOS(\"QoS network/card mode %d\\n\", mode);\n\treturn mode;\n}\n\n/*\n* Handle management frame beacon and probe response\n*/\nstatic int ipw_qos_handle_probe_response(struct ipw_priv *priv,\n\t\t\t\t\t int active_network,\n\t\t\t\t\t struct libipw_network *network)\n{\n\tu32 size = sizeof(struct libipw_qos_parameters);\n\n\tif (network->capability & WLAN_CAPABILITY_IBSS)\n\t\tnetwork->qos_data.active = network->qos_data.supported;\n\n\tif (network->flags & NETWORK_HAS_QOS_MASK) {\n\t\tif (active_network &&\n\t\t    (network->flags & NETWORK_HAS_QOS_PARAMETERS))\n\t\t\tnetwork->qos_data.active = network->qos_data.supported;\n\n\t\tif ((network->qos_data.active == 1) && (active_network == 1) &&\n\t\t    (network->flags & NETWORK_HAS_QOS_PARAMETERS) &&\n\t\t    (network->qos_data.old_param_count !=\n\t\t     network->qos_data.param_count)) {\n\t\t\tnetwork->qos_data.old_param_count =\n\t\t\t    network->qos_data.param_count;\n\t\t\tschedule_work(&priv->qos_activate);\n\t\t\tIPW_DEBUG_QOS(\"QoS parameters change call \"\n\t\t\t\t      \"qos_activate\\n\");\n\t\t}\n\t} else {\n\t\tif ((priv->ieee->mode == IEEE_B) || (network->mode == IEEE_B))\n\t\t\tmemcpy(&network->qos_data.parameters,\n\t\t\t       &def_parameters_CCK, size);\n\t\telse\n\t\t\tmemcpy(&network->qos_data.parameters,\n\t\t\t       &def_parameters_OFDM, size);\n\n\t\tif ((network->qos_data.active == 1) && (active_network == 1)) {\n\t\t\tIPW_DEBUG_QOS(\"QoS was disabled call qos_activate\\n\");\n\t\t\tschedule_work(&priv->qos_activate);\n\t\t}\n\n\t\tnetwork->qos_data.active = 0;\n\t\tnetwork->qos_data.supported = 0;\n\t}\n\tif ((priv->status & STATUS_ASSOCIATED) &&\n\t    (priv->ieee->iw_mode == IW_MODE_ADHOC) && (active_network == 0)) {\n\t\tif (!ether_addr_equal(network->bssid, priv->bssid))\n\t\t\tif (network->capability & WLAN_CAPABILITY_IBSS)\n\t\t\t\tif ((network->ssid_len ==\n\t\t\t\t     priv->assoc_network->ssid_len) &&\n\t\t\t\t    !memcmp(network->ssid,\n\t\t\t\t\t    priv->assoc_network->ssid,\n\t\t\t\t\t    network->ssid_len)) {\n\t\t\t\t\tschedule_work(&priv->merge_networks);\n\t\t\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n* This function set up the firmware to support QoS. It sends\n* IPW_CMD_QOS_PARAMETERS and IPW_CMD_WME_INFO\n*/\nstatic int ipw_qos_activate(struct ipw_priv *priv,\n\t\t\t    struct libipw_qos_data *qos_network_data)\n{\n\tint err;\n\tstruct libipw_qos_parameters qos_parameters[QOS_QOS_SETS];\n\tstruct libipw_qos_parameters *active_one = NULL;\n\tu32 size = sizeof(struct libipw_qos_parameters);\n\tu32 burst_duration;\n\tint i;\n\tu8 type;\n\n\ttype = ipw_qos_current_mode(priv);\n\n\tactive_one = &(qos_parameters[QOS_PARAM_SET_DEF_CCK]);\n\tmemcpy(active_one, priv->qos_data.def_qos_parm_CCK, size);\n\tactive_one = &(qos_parameters[QOS_PARAM_SET_DEF_OFDM]);\n\tmemcpy(active_one, priv->qos_data.def_qos_parm_OFDM, size);\n\n\tif (qos_network_data == NULL) {\n\t\tif (type == IEEE_B) {\n\t\t\tIPW_DEBUG_QOS(\"QoS activate network mode %d\\n\", type);\n\t\t\tactive_one = &def_parameters_CCK;\n\t\t} else\n\t\t\tactive_one = &def_parameters_OFDM;\n\n\t\tmemcpy(&qos_parameters[QOS_PARAM_SET_ACTIVE], active_one, size);\n\t\tburst_duration = ipw_qos_get_burst_duration(priv);\n\t\tfor (i = 0; i < QOS_QUEUE_NUM; i++)\n\t\t\tqos_parameters[QOS_PARAM_SET_ACTIVE].tx_op_limit[i] =\n\t\t\t    cpu_to_le16(burst_duration);\n\t} else if (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\tif (type == IEEE_B) {\n\t\t\tIPW_DEBUG_QOS(\"QoS activate IBSS network mode %d\\n\",\n\t\t\t\t      type);\n\t\t\tif (priv->qos_data.qos_enable == 0)\n\t\t\t\tactive_one = &def_parameters_CCK;\n\t\t\telse\n\t\t\t\tactive_one = priv->qos_data.def_qos_parm_CCK;\n\t\t} else {\n\t\t\tif (priv->qos_data.qos_enable == 0)\n\t\t\t\tactive_one = &def_parameters_OFDM;\n\t\t\telse\n\t\t\t\tactive_one = priv->qos_data.def_qos_parm_OFDM;\n\t\t}\n\t\tmemcpy(&qos_parameters[QOS_PARAM_SET_ACTIVE], active_one, size);\n\t} else {\n\t\tunsigned long flags;\n\t\tint active;\n\n\t\tspin_lock_irqsave(&priv->ieee->lock, flags);\n\t\tactive_one = &(qos_network_data->parameters);\n\t\tqos_network_data->old_param_count =\n\t\t    qos_network_data->param_count;\n\t\tmemcpy(&qos_parameters[QOS_PARAM_SET_ACTIVE], active_one, size);\n\t\tactive = qos_network_data->supported;\n\t\tspin_unlock_irqrestore(&priv->ieee->lock, flags);\n\n\t\tif (active == 0) {\n\t\t\tburst_duration = ipw_qos_get_burst_duration(priv);\n\t\t\tfor (i = 0; i < QOS_QUEUE_NUM; i++)\n\t\t\t\tqos_parameters[QOS_PARAM_SET_ACTIVE].\n\t\t\t\t    tx_op_limit[i] = cpu_to_le16(burst_duration);\n\t\t}\n\t}\n\n\tIPW_DEBUG_QOS(\"QoS sending IPW_CMD_QOS_PARAMETERS\\n\");\n\terr = ipw_send_qos_params_command(priv, &qos_parameters[0]);\n\tif (err)\n\t\tIPW_DEBUG_QOS(\"QoS IPW_CMD_QOS_PARAMETERS failed\\n\");\n\n\treturn err;\n}\n\n/*\n* send IPW_CMD_WME_INFO to the firmware\n*/\nstatic int ipw_qos_set_info_element(struct ipw_priv *priv)\n{\n\tint ret = 0;\n\tstruct libipw_qos_information_element qos_info;\n\n\tif (priv == NULL)\n\t\treturn -1;\n\n\tqos_info.elementID = QOS_ELEMENT_ID;\n\tqos_info.length = sizeof(struct libipw_qos_information_element) - 2;\n\n\tqos_info.version = QOS_VERSION_1;\n\tqos_info.ac_info = 0;\n\n\tmemcpy(qos_info.qui, qos_oui, QOS_OUI_LEN);\n\tqos_info.qui_type = QOS_OUI_TYPE;\n\tqos_info.qui_subtype = QOS_OUI_INFO_SUB_TYPE;\n\n\tret = ipw_send_qos_info_command(priv, &qos_info);\n\tif (ret != 0) {\n\t\tIPW_DEBUG_QOS(\"QoS error calling ipw_send_qos_info_command\\n\");\n\t}\n\treturn ret;\n}\n\n/*\n* Set the QoS parameter with the association request structure\n*/\nstatic int ipw_qos_association(struct ipw_priv *priv,\n\t\t\t       struct libipw_network *network)\n{\n\tint err = 0;\n\tstruct libipw_qos_data *qos_data = NULL;\n\tstruct libipw_qos_data ibss_data = {\n\t\t.supported = 1,\n\t\t.active = 1,\n\t};\n\n\tswitch (priv->ieee->iw_mode) {\n\tcase IW_MODE_ADHOC:\n\t\tBUG_ON(!(network->capability & WLAN_CAPABILITY_IBSS));\n\n\t\tqos_data = &ibss_data;\n\t\tbreak;\n\n\tcase IW_MODE_INFRA:\n\t\tqos_data = &network->qos_data;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\terr = ipw_qos_activate(priv, qos_data);\n\tif (err) {\n\t\tpriv->assoc_request.policy_support &= ~HC_QOS_SUPPORT_ASSOC;\n\t\treturn err;\n\t}\n\n\tif (priv->qos_data.qos_enable && qos_data->supported) {\n\t\tIPW_DEBUG_QOS(\"QoS will be enabled for this association\\n\");\n\t\tpriv->assoc_request.policy_support |= HC_QOS_SUPPORT_ASSOC;\n\t\treturn ipw_qos_set_info_element(priv);\n\t}\n\n\treturn 0;\n}\n\n/*\n* handling the beaconing responses. if we get different QoS setting\n* off the network from the associated setting, adjust the QoS\n* setting\n*/\nstatic void ipw_qos_association_resp(struct ipw_priv *priv,\n\t\t\t\t    struct libipw_network *network)\n{\n\tunsigned long flags;\n\tu32 size = sizeof(struct libipw_qos_parameters);\n\tint set_qos_param = 0;\n\n\tif ((priv == NULL) || (network == NULL) ||\n\t    (priv->assoc_network == NULL))\n\t\treturn;\n\n\tif (!(priv->status & STATUS_ASSOCIATED))\n\t\treturn;\n\n\tif ((priv->ieee->iw_mode != IW_MODE_INFRA))\n\t\treturn;\n\n\tspin_lock_irqsave(&priv->ieee->lock, flags);\n\tif (network->flags & NETWORK_HAS_QOS_PARAMETERS) {\n\t\tmemcpy(&priv->assoc_network->qos_data, &network->qos_data,\n\t\t       sizeof(struct libipw_qos_data));\n\t\tpriv->assoc_network->qos_data.active = 1;\n\t\tif ((network->qos_data.old_param_count !=\n\t\t     network->qos_data.param_count)) {\n\t\t\tset_qos_param = 1;\n\t\t\tnetwork->qos_data.old_param_count =\n\t\t\t    network->qos_data.param_count;\n\t\t}\n\n\t} else {\n\t\tif ((network->mode == IEEE_B) || (priv->ieee->mode == IEEE_B))\n\t\t\tmemcpy(&priv->assoc_network->qos_data.parameters,\n\t\t\t       &def_parameters_CCK, size);\n\t\telse\n\t\t\tmemcpy(&priv->assoc_network->qos_data.parameters,\n\t\t\t       &def_parameters_OFDM, size);\n\t\tpriv->assoc_network->qos_data.active = 0;\n\t\tpriv->assoc_network->qos_data.supported = 0;\n\t\tset_qos_param = 1;\n\t}\n\n\tspin_unlock_irqrestore(&priv->ieee->lock, flags);\n\n\tif (set_qos_param == 1)\n\t\tschedule_work(&priv->qos_activate);\n}\n\nstatic u32 ipw_qos_get_burst_duration(struct ipw_priv *priv)\n{\n\tu32 ret = 0;\n\n\tif (!priv)\n\t\treturn 0;\n\n\tif (!(priv->ieee->modulation & LIBIPW_OFDM_MODULATION))\n\t\tret = priv->qos_data.burst_duration_CCK;\n\telse\n\t\tret = priv->qos_data.burst_duration_OFDM;\n\n\treturn ret;\n}\n\n/*\n* Initialize the setting of QoS global\n*/\nstatic void ipw_qos_init(struct ipw_priv *priv, int enable,\n\t\t\t int burst_enable, u32 burst_duration_CCK,\n\t\t\t u32 burst_duration_OFDM)\n{\n\tpriv->qos_data.qos_enable = enable;\n\n\tif (priv->qos_data.qos_enable) {\n\t\tpriv->qos_data.def_qos_parm_CCK = &def_qos_parameters_CCK;\n\t\tpriv->qos_data.def_qos_parm_OFDM = &def_qos_parameters_OFDM;\n\t\tIPW_DEBUG_QOS(\"QoS is enabled\\n\");\n\t} else {\n\t\tpriv->qos_data.def_qos_parm_CCK = &def_parameters_CCK;\n\t\tpriv->qos_data.def_qos_parm_OFDM = &def_parameters_OFDM;\n\t\tIPW_DEBUG_QOS(\"QoS is not enabled\\n\");\n\t}\n\n\tpriv->qos_data.burst_enable = burst_enable;\n\n\tif (burst_enable) {\n\t\tpriv->qos_data.burst_duration_CCK = burst_duration_CCK;\n\t\tpriv->qos_data.burst_duration_OFDM = burst_duration_OFDM;\n\t} else {\n\t\tpriv->qos_data.burst_duration_CCK = 0;\n\t\tpriv->qos_data.burst_duration_OFDM = 0;\n\t}\n}\n\n/*\n* map the packet priority to the right TX Queue\n*/\nstatic int ipw_get_tx_queue_number(struct ipw_priv *priv, u16 priority)\n{\n\tif (priority > 7 || !priv->qos_data.qos_enable)\n\t\tpriority = 0;\n\n\treturn from_priority_to_tx_queue[priority] - 1;\n}\n\nstatic int ipw_is_qos_active(struct net_device *dev,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct libipw_qos_data *qos_data = NULL;\n\tint active, supported;\n\tu8 *daddr = skb->data + ETH_ALEN;\n\tint unicast = !is_multicast_ether_addr(daddr);\n\n\tif (!(priv->status & STATUS_ASSOCIATED))\n\t\treturn 0;\n\n\tqos_data = &priv->assoc_network->qos_data;\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\tif (unicast == 0)\n\t\t\tqos_data->active = 0;\n\t\telse\n\t\t\tqos_data->active = qos_data->supported;\n\t}\n\tactive = qos_data->active;\n\tsupported = qos_data->supported;\n\tIPW_DEBUG_QOS(\"QoS  %d network is QoS active %d  supported %d  \"\n\t\t      \"unicast %d\\n\",\n\t\t      priv->qos_data.qos_enable, active, supported, unicast);\n\tif (active && priv->qos_data.qos_enable)\n\t\treturn 1;\n\n\treturn 0;\n\n}\n/*\n* add QoS parameter to the TX command\n*/\nstatic int ipw_qos_set_tx_queue_command(struct ipw_priv *priv,\n\t\t\t\t\tu16 priority,\n\t\t\t\t\tstruct tfd_data *tfd)\n{\n\tint tx_queue_id = 0;\n\n\n\ttx_queue_id = from_priority_to_tx_queue[priority] - 1;\n\ttfd->tx_flags_ext |= DCT_FLAG_EXT_QOS_ENABLED;\n\n\tif (priv->qos_data.qos_no_ack_mask & (1UL << tx_queue_id)) {\n\t\ttfd->tx_flags &= ~DCT_FLAG_ACK_REQD;\n\t\ttfd->tfd.tfd_26.mchdr.qos_ctrl |= cpu_to_le16(CTRL_QOS_NO_ACK);\n\t}\n\treturn 0;\n}\n\n/*\n* background support to run QoS activate functionality\n*/\nstatic void ipw_bg_qos_activate(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, qos_activate);\n\n\tmutex_lock(&priv->mutex);\n\n\tif (priv->status & STATUS_ASSOCIATED)\n\t\tipw_qos_activate(priv, &(priv->assoc_network->qos_data));\n\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int ipw_handle_probe_response(struct net_device *dev,\n\t\t\t\t     struct libipw_probe_response *resp,\n\t\t\t\t     struct libipw_network *network)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint active_network = ((priv->status & STATUS_ASSOCIATED) &&\n\t\t\t      (network == priv->assoc_network));\n\n\tipw_qos_handle_probe_response(priv, active_network, network);\n\n\treturn 0;\n}\n\nstatic int ipw_handle_beacon(struct net_device *dev,\n\t\t\t     struct libipw_beacon *resp,\n\t\t\t     struct libipw_network *network)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint active_network = ((priv->status & STATUS_ASSOCIATED) &&\n\t\t\t      (network == priv->assoc_network));\n\n\tipw_qos_handle_probe_response(priv, active_network, network);\n\n\treturn 0;\n}\n\nstatic int ipw_handle_assoc_response(struct net_device *dev,\n\t\t\t\t     struct libipw_assoc_response *resp,\n\t\t\t\t     struct libipw_network *network)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tipw_qos_association_resp(priv, network);\n\treturn 0;\n}\n\nstatic int ipw_send_qos_params_command(struct ipw_priv *priv, struct libipw_qos_parameters\n\t\t\t\t       *qos_param)\n{\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_QOS_PARAMETERS,\n\t\t\t\tsizeof(*qos_param) * 3, qos_param);\n}\n\nstatic int ipw_send_qos_info_command(struct ipw_priv *priv, struct libipw_qos_information_element\n\t\t\t\t     *qos_param)\n{\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_WME_INFO, sizeof(*qos_param),\n\t\t\t\tqos_param);\n}\n\n#endif\t\t\t\t/* CONFIG_IPW2200_QOS */\n\nstatic int ipw_associate_network(struct ipw_priv *priv,\n\t\t\t\t struct libipw_network *network,\n\t\t\t\t struct ipw_supported_rates *rates, int roaming)\n{\n\tint err;\n\n\tif (priv->config & CFG_FIXED_RATE)\n\t\tipw_set_fixed_rate(priv, network->mode);\n\n\tif (!(priv->config & CFG_STATIC_ESSID)) {\n\t\tpriv->essid_len = min(network->ssid_len,\n\t\t\t\t      (u8) IW_ESSID_MAX_SIZE);\n\t\tmemcpy(priv->essid, network->ssid, priv->essid_len);\n\t}\n\n\tnetwork->last_associate = jiffies;\n\n\tmemset(&priv->assoc_request, 0, sizeof(priv->assoc_request));\n\tpriv->assoc_request.channel = network->channel;\n\tpriv->assoc_request.auth_key = 0;\n\n\tif ((priv->capability & CAP_PRIVACY_ON) &&\n\t    (priv->ieee->sec.auth_mode == WLAN_AUTH_SHARED_KEY)) {\n\t\tpriv->assoc_request.auth_type = AUTH_SHARED_KEY;\n\t\tpriv->assoc_request.auth_key = priv->ieee->sec.active_key;\n\n\t\tif (priv->ieee->sec.level == SEC_LEVEL_1)\n\t\t\tipw_send_wep_keys(priv, DCW_WEP_KEY_SEC_TYPE_WEP);\n\n\t} else if ((priv->capability & CAP_PRIVACY_ON) &&\n\t\t   (priv->ieee->sec.auth_mode == WLAN_AUTH_LEAP))\n\t\tpriv->assoc_request.auth_type = AUTH_LEAP;\n\telse\n\t\tpriv->assoc_request.auth_type = AUTH_OPEN;\n\n\tif (priv->ieee->wpa_ie_len) {\n\t\tpriv->assoc_request.policy_support = cpu_to_le16(0x02);\t/* RSN active */\n\t\tipw_set_rsn_capa(priv, priv->ieee->wpa_ie,\n\t\t\t\t priv->ieee->wpa_ie_len);\n\t}\n\n\t/*\n\t * It is valid for our ieee device to support multiple modes, but\n\t * when it comes to associating to a given network we have to choose\n\t * just one mode.\n\t */\n\tif (network->mode & priv->ieee->mode & IEEE_A)\n\t\tpriv->assoc_request.ieee_mode = IPW_A_MODE;\n\telse if (network->mode & priv->ieee->mode & IEEE_G)\n\t\tpriv->assoc_request.ieee_mode = IPW_G_MODE;\n\telse if (network->mode & priv->ieee->mode & IEEE_B)\n\t\tpriv->assoc_request.ieee_mode = IPW_B_MODE;\n\n\tpriv->assoc_request.capability = cpu_to_le16(network->capability);\n\tif ((network->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\n\t    && !(priv->config & CFG_PREAMBLE_LONG)) {\n\t\tpriv->assoc_request.preamble_length = DCT_FLAG_SHORT_PREAMBLE;\n\t} else {\n\t\tpriv->assoc_request.preamble_length = DCT_FLAG_LONG_PREAMBLE;\n\n\t\t/* Clear the short preamble if we won't be supporting it */\n\t\tpriv->assoc_request.capability &=\n\t\t    ~cpu_to_le16(WLAN_CAPABILITY_SHORT_PREAMBLE);\n\t}\n\n\t/* Clear capability bits that aren't used in Ad Hoc */\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC)\n\t\tpriv->assoc_request.capability &=\n\t\t    ~cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT_TIME);\n\n\tIPW_DEBUG_ASSOC(\"%ssociation attempt: '%*pE', channel %d, 802.11%c [%d], %s[:%s], enc=%s%s%s%c%c\\n\",\n\t\t\troaming ? \"Rea\" : \"A\",\n\t\t\tpriv->essid_len, priv->essid,\n\t\t\tnetwork->channel,\n\t\t\tipw_modes[priv->assoc_request.ieee_mode],\n\t\t\trates->num_rates,\n\t\t\t(priv->assoc_request.preamble_length ==\n\t\t\t DCT_FLAG_LONG_PREAMBLE) ? \"long\" : \"short\",\n\t\t\tnetwork->capability &\n\t\t\tWLAN_CAPABILITY_SHORT_PREAMBLE ? \"short\" : \"long\",\n\t\t\tpriv->capability & CAP_PRIVACY_ON ? \"on \" : \"off\",\n\t\t\tpriv->capability & CAP_PRIVACY_ON ?\n\t\t\t(priv->capability & CAP_SHARED_KEY ? \"(shared)\" :\n\t\t\t \"(open)\") : \"\",\n\t\t\tpriv->capability & CAP_PRIVACY_ON ? \" key=\" : \"\",\n\t\t\tpriv->capability & CAP_PRIVACY_ON ?\n\t\t\t'1' + priv->ieee->sec.active_key : '.',\n\t\t\tpriv->capability & CAP_PRIVACY_ON ? '.' : ' ');\n\n\tpriv->assoc_request.beacon_interval = cpu_to_le16(network->beacon_interval);\n\tif ((priv->ieee->iw_mode == IW_MODE_ADHOC) &&\n\t    (network->time_stamp[0] == 0) && (network->time_stamp[1] == 0)) {\n\t\tpriv->assoc_request.assoc_type = HC_IBSS_START;\n\t\tpriv->assoc_request.assoc_tsf_msw = 0;\n\t\tpriv->assoc_request.assoc_tsf_lsw = 0;\n\t} else {\n\t\tif (unlikely(roaming))\n\t\t\tpriv->assoc_request.assoc_type = HC_REASSOCIATE;\n\t\telse\n\t\t\tpriv->assoc_request.assoc_type = HC_ASSOCIATE;\n\t\tpriv->assoc_request.assoc_tsf_msw = cpu_to_le32(network->time_stamp[1]);\n\t\tpriv->assoc_request.assoc_tsf_lsw = cpu_to_le32(network->time_stamp[0]);\n\t}\n\n\tmemcpy(priv->assoc_request.bssid, network->bssid, ETH_ALEN);\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\teth_broadcast_addr(priv->assoc_request.dest);\n\t\tpriv->assoc_request.atim_window = cpu_to_le16(network->atim_window);\n\t} else {\n\t\tmemcpy(priv->assoc_request.dest, network->bssid, ETH_ALEN);\n\t\tpriv->assoc_request.atim_window = 0;\n\t}\n\n\tpriv->assoc_request.listen_interval = cpu_to_le16(network->listen_interval);\n\n\terr = ipw_send_ssid(priv, priv->essid, priv->essid_len);\n\tif (err) {\n\t\tIPW_DEBUG_HC(\"Attempt to send SSID command failed.\\n\");\n\t\treturn err;\n\t}\n\n\trates->ieee_mode = priv->assoc_request.ieee_mode;\n\trates->purpose = IPW_RATE_CONNECT;\n\tipw_send_supported_rates(priv, rates);\n\n\tif (priv->assoc_request.ieee_mode == IPW_G_MODE)\n\t\tpriv->sys_config.dot11g_auto_detection = 1;\n\telse\n\t\tpriv->sys_config.dot11g_auto_detection = 0;\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC)\n\t\tpriv->sys_config.answer_broadcast_ssid_probe = 1;\n\telse\n\t\tpriv->sys_config.answer_broadcast_ssid_probe = 0;\n\n\terr = ipw_send_system_config(priv);\n\tif (err) {\n\t\tIPW_DEBUG_HC(\"Attempt to send sys config command failed.\\n\");\n\t\treturn err;\n\t}\n\n\tIPW_DEBUG_ASSOC(\"Association sensitivity: %d\\n\", network->stats.rssi);\n\terr = ipw_set_sensitivity(priv, network->stats.rssi + IPW_RSSI_TO_DBM);\n\tif (err) {\n\t\tIPW_DEBUG_HC(\"Attempt to send associate command failed.\\n\");\n\t\treturn err;\n\t}\n\n\t/*\n\t * If preemption is enabled, it is possible for the association\n\t * to complete before we return from ipw_send_associate.  Therefore\n\t * we have to be sure and update our priviate data first.\n\t */\n\tpriv->channel = network->channel;\n\tmemcpy(priv->bssid, network->bssid, ETH_ALEN);\n\tpriv->status |= STATUS_ASSOCIATING;\n\tpriv->status &= ~STATUS_SECURITY_UPDATED;\n\n\tpriv->assoc_network = network;\n\n#ifdef CONFIG_IPW2200_QOS\n\tipw_qos_association(priv, network);\n#endif\n\n\terr = ipw_send_associate(priv, &priv->assoc_request);\n\tif (err) {\n\t\tIPW_DEBUG_HC(\"Attempt to send associate command failed.\\n\");\n\t\treturn err;\n\t}\n\n\tIPW_DEBUG(IPW_DL_STATE, \"associating: '%*pE' %pM\\n\",\n\t\t  priv->essid_len, priv->essid, priv->bssid);\n\n\treturn 0;\n}\n\nstatic void ipw_roam(void *data)\n{\n\tstruct ipw_priv *priv = data;\n\tstruct libipw_network *network = NULL;\n\tstruct ipw_network_match match = {\n\t\t.network = priv->assoc_network\n\t};\n\n\t/* The roaming process is as follows:\n\t *\n\t * 1.  Missed beacon threshold triggers the roaming process by\n\t *     setting the status ROAM bit and requesting a scan.\n\t * 2.  When the scan completes, it schedules the ROAM work\n\t * 3.  The ROAM work looks at all of the known networks for one that\n\t *     is a better network than the currently associated.  If none\n\t *     found, the ROAM process is over (ROAM bit cleared)\n\t * 4.  If a better network is found, a disassociation request is\n\t *     sent.\n\t * 5.  When the disassociation completes, the roam work is again\n\t *     scheduled.  The second time through, the driver is no longer\n\t *     associated, and the newly selected network is sent an\n\t *     association request.\n\t * 6.  At this point ,the roaming process is complete and the ROAM\n\t *     status bit is cleared.\n\t */\n\n\t/* If we are no longer associated, and the roaming bit is no longer\n\t * set, then we are not actively roaming, so just return */\n\tif (!(priv->status & (STATUS_ASSOCIATED | STATUS_ROAMING)))\n\t\treturn;\n\n\tif (priv->status & STATUS_ASSOCIATED) {\n\t\t/* First pass through ROAM process -- look for a better\n\t\t * network */\n\t\tunsigned long flags;\n\t\tu8 rssi = priv->assoc_network->stats.rssi;\n\t\tpriv->assoc_network->stats.rssi = -128;\n\t\tspin_lock_irqsave(&priv->ieee->lock, flags);\n\t\tlist_for_each_entry(network, &priv->ieee->network_list, list) {\n\t\t\tif (network != priv->assoc_network)\n\t\t\t\tipw_best_network(priv, &match, network, 1);\n\t\t}\n\t\tspin_unlock_irqrestore(&priv->ieee->lock, flags);\n\t\tpriv->assoc_network->stats.rssi = rssi;\n\n\t\tif (match.network == priv->assoc_network) {\n\t\t\tIPW_DEBUG_ASSOC(\"No better APs in this network to \"\n\t\t\t\t\t\"roam to.\\n\");\n\t\t\tpriv->status &= ~STATUS_ROAMING;\n\t\t\tipw_debug_config(priv);\n\t\t\treturn;\n\t\t}\n\n\t\tipw_send_disassociate(priv, 1);\n\t\tpriv->assoc_network = match.network;\n\n\t\treturn;\n\t}\n\n\t/* Second pass through ROAM process -- request association */\n\tipw_compatible_rates(priv, priv->assoc_network, &match.rates);\n\tipw_associate_network(priv, priv->assoc_network, &match.rates, 1);\n\tpriv->status &= ~STATUS_ROAMING;\n}\n\nstatic void ipw_bg_roam(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, roam);\n\tmutex_lock(&priv->mutex);\n\tipw_roam(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int ipw_associate(void *data)\n{\n\tstruct ipw_priv *priv = data;\n\n\tstruct libipw_network *network = NULL;\n\tstruct ipw_network_match match = {\n\t\t.network = NULL\n\t};\n\tstruct ipw_supported_rates *rates;\n\tstruct list_head *element;\n\tunsigned long flags;\n\n\tif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tIPW_DEBUG_ASSOC(\"Not attempting association (monitor mode)\\n\");\n\t\treturn 0;\n\t}\n\n\tif (priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)) {\n\t\tIPW_DEBUG_ASSOC(\"Not attempting association (already in \"\n\t\t\t\t\"progress)\\n\");\n\t\treturn 0;\n\t}\n\n\tif (priv->status & STATUS_DISASSOCIATING) {\n\t\tIPW_DEBUG_ASSOC(\"Not attempting association (in disassociating)\\n\");\n\t\tschedule_work(&priv->associate);\n\t\treturn 0;\n\t}\n\n\tif (!ipw_is_init(priv) || (priv->status & STATUS_SCANNING)) {\n\t\tIPW_DEBUG_ASSOC(\"Not attempting association (scanning or not \"\n\t\t\t\t\"initialized)\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!(priv->config & CFG_ASSOCIATE) &&\n\t    !(priv->config & (CFG_STATIC_ESSID | CFG_STATIC_BSSID))) {\n\t\tIPW_DEBUG_ASSOC(\"Not attempting association (associate=0)\\n\");\n\t\treturn 0;\n\t}\n\n\t/* Protect our use of the network_list */\n\tspin_lock_irqsave(&priv->ieee->lock, flags);\n\tlist_for_each_entry(network, &priv->ieee->network_list, list)\n\t    ipw_best_network(priv, &match, network, 0);\n\n\tnetwork = match.network;\n\trates = &match.rates;\n\n\tif (network == NULL &&\n\t    priv->ieee->iw_mode == IW_MODE_ADHOC &&\n\t    priv->config & CFG_ADHOC_CREATE &&\n\t    priv->config & CFG_STATIC_ESSID &&\n\t    priv->config & CFG_STATIC_CHANNEL) {\n\t\t/* Use oldest network if the free list is empty */\n\t\tif (list_empty(&priv->ieee->network_free_list)) {\n\t\t\tstruct libipw_network *oldest = NULL;\n\t\t\tstruct libipw_network *target;\n\n\t\t\tlist_for_each_entry(target, &priv->ieee->network_list, list) {\n\t\t\t\tif ((oldest == NULL) ||\n\t\t\t\t    (target->last_scanned < oldest->last_scanned))\n\t\t\t\t\toldest = target;\n\t\t\t}\n\n\t\t\t/* If there are no more slots, expire the oldest */\n\t\t\tlist_del(&oldest->list);\n\t\t\ttarget = oldest;\n\t\t\tIPW_DEBUG_ASSOC(\"Expired '%*pE' (%pM) from network list.\\n\",\n\t\t\t\t\ttarget->ssid_len, target->ssid,\n\t\t\t\t\ttarget->bssid);\n\t\t\tlist_add_tail(&target->list,\n\t\t\t\t      &priv->ieee->network_free_list);\n\t\t}\n\n\t\telement = priv->ieee->network_free_list.next;\n\t\tnetwork = list_entry(element, struct libipw_network, list);\n\t\tipw_adhoc_create(priv, network);\n\t\trates = &priv->rates;\n\t\tlist_del(element);\n\t\tlist_add_tail(&network->list, &priv->ieee->network_list);\n\t}\n\tspin_unlock_irqrestore(&priv->ieee->lock, flags);\n\n\t/* If we reached the end of the list, then we don't have any valid\n\t * matching APs */\n\tif (!network) {\n\t\tipw_debug_config(priv);\n\n\t\tif (!(priv->status & STATUS_SCANNING)) {\n\t\t\tif (!(priv->config & CFG_SPEED_SCAN))\n\t\t\t\tschedule_delayed_work(&priv->request_scan,\n\t\t\t\t\t\t      SCAN_INTERVAL);\n\t\t\telse\n\t\t\t\tschedule_delayed_work(&priv->request_scan, 0);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tipw_associate_network(priv, network, rates, 0);\n\n\treturn 1;\n}\n\nstatic void ipw_bg_associate(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, associate);\n\tmutex_lock(&priv->mutex);\n\tipw_associate(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_rebuild_decrypted_skb(struct ipw_priv *priv,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr;\n\tu16 fc;\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tfc = le16_to_cpu(hdr->frame_control);\n\tif (!(fc & IEEE80211_FCTL_PROTECTED))\n\t\treturn;\n\n\tfc &= ~IEEE80211_FCTL_PROTECTED;\n\thdr->frame_control = cpu_to_le16(fc);\n\tswitch (priv->ieee->sec.level) {\n\tcase SEC_LEVEL_3:\n\t\t/* Remove CCMP HDR */\n\t\tmemmove(skb->data + LIBIPW_3ADDR_LEN,\n\t\t\tskb->data + LIBIPW_3ADDR_LEN + 8,\n\t\t\tskb->len - LIBIPW_3ADDR_LEN - 8);\n\t\tskb_trim(skb, skb->len - 16);\t/* CCMP_HDR_LEN + CCMP_MIC_LEN */\n\t\tbreak;\n\tcase SEC_LEVEL_2:\n\t\tbreak;\n\tcase SEC_LEVEL_1:\n\t\t/* Remove IV */\n\t\tmemmove(skb->data + LIBIPW_3ADDR_LEN,\n\t\t\tskb->data + LIBIPW_3ADDR_LEN + 4,\n\t\t\tskb->len - LIBIPW_3ADDR_LEN - 4);\n\t\tskb_trim(skb, skb->len - 8);\t/* IV + ICV */\n\t\tbreak;\n\tcase SEC_LEVEL_0:\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Unknown security level %d\\n\",\n\t\t       priv->ieee->sec.level);\n\t\tbreak;\n\t}\n}\n\nstatic void ipw_handle_data_packet(struct ipw_priv *priv,\n\t\t\t\t   struct ipw_rx_mem_buffer *rxb,\n\t\t\t\t   struct libipw_rx_stats *stats)\n{\n\tstruct net_device *dev = priv->net_dev;\n\tstruct libipw_hdr_4addr *hdr;\n\tstruct ipw_rx_packet *pkt = (struct ipw_rx_packet *)rxb->skb->data;\n\n\t/* We received data from the HW, so stop the watchdog */\n\tnetif_trans_update(dev);\n\n\t/* We only process data packets if the\n\t * interface is open */\n\tif (unlikely((le16_to_cpu(pkt->u.frame.length) + IPW_RX_FRAME_SIZE) >\n\t\t     skb_tailroom(rxb->skb))) {\n\t\tdev->stats.rx_errors++;\n\t\tpriv->wstats.discard.misc++;\n\t\tIPW_DEBUG_DROP(\"Corruption detected! Oh no!\\n\");\n\t\treturn;\n\t} else if (unlikely(!netif_running(priv->net_dev))) {\n\t\tdev->stats.rx_dropped++;\n\t\tpriv->wstats.discard.misc++;\n\t\tIPW_DEBUG_DROP(\"Dropping packet while interface is not up.\\n\");\n\t\treturn;\n\t}\n\n\t/* Advance skb->data to the start of the actual payload */\n\tskb_reserve(rxb->skb, offsetof(struct ipw_rx_packet, u.frame.data));\n\n\t/* Set the size of the skb to the size of the frame */\n\tskb_put(rxb->skb, le16_to_cpu(pkt->u.frame.length));\n\n\tIPW_DEBUG_RX(\"Rx packet of %d bytes.\\n\", rxb->skb->len);\n\n\t/* HW decrypt will not clear the WEP bit, MIC, PN, etc. */\n\thdr = (struct libipw_hdr_4addr *)rxb->skb->data;\n\tif (priv->ieee->iw_mode != IW_MODE_MONITOR &&\n\t    (is_multicast_ether_addr(hdr->addr1) ?\n\t     !priv->ieee->host_mc_decrypt : !priv->ieee->host_decrypt))\n\t\tipw_rebuild_decrypted_skb(priv, rxb->skb);\n\n\tif (!libipw_rx(priv->ieee, rxb->skb, stats))\n\t\tdev->stats.rx_errors++;\n\telse {\t\t\t/* libipw_rx succeeded, so it now owns the SKB */\n\t\trxb->skb = NULL;\n\t\t__ipw_led_activity_on(priv);\n\t}\n}\n\n#ifdef CONFIG_IPW2200_RADIOTAP\nstatic void ipw_handle_data_packet_monitor(struct ipw_priv *priv,\n\t\t\t\t\t   struct ipw_rx_mem_buffer *rxb,\n\t\t\t\t\t   struct libipw_rx_stats *stats)\n{\n\tstruct net_device *dev = priv->net_dev;\n\tstruct ipw_rx_packet *pkt = (struct ipw_rx_packet *)rxb->skb->data;\n\tstruct ipw_rx_frame *frame = &pkt->u.frame;\n\n\t/* initial pull of some data */\n\tu16 received_channel = frame->received_channel;\n\tu8 antennaAndPhy = frame->antennaAndPhy;\n\ts8 antsignal = frame->rssi_dbm - IPW_RSSI_TO_DBM;\t/* call it signed anyhow */\n\tu16 pktrate = frame->rate;\n\n\t/* Magic struct that slots into the radiotap header -- no reason\n\t * to build this manually element by element, we can write it much\n\t * more efficiently than we can parse it. ORDER MATTERS HERE */\n\tstruct ipw_rt_hdr *ipw_rt;\n\n\tunsigned short len = le16_to_cpu(pkt->u.frame.length);\n\n\t/* We received data from the HW, so stop the watchdog */\n\tnetif_trans_update(dev);\n\n\t/* We only process data packets if the\n\t * interface is open */\n\tif (unlikely((le16_to_cpu(pkt->u.frame.length) + IPW_RX_FRAME_SIZE) >\n\t\t     skb_tailroom(rxb->skb))) {\n\t\tdev->stats.rx_errors++;\n\t\tpriv->wstats.discard.misc++;\n\t\tIPW_DEBUG_DROP(\"Corruption detected! Oh no!\\n\");\n\t\treturn;\n\t} else if (unlikely(!netif_running(priv->net_dev))) {\n\t\tdev->stats.rx_dropped++;\n\t\tpriv->wstats.discard.misc++;\n\t\tIPW_DEBUG_DROP(\"Dropping packet while interface is not up.\\n\");\n\t\treturn;\n\t}\n\n\t/* Libpcap 0.9.3+ can handle variable length radiotap, so we'll use\n\t * that now */\n\tif (len > IPW_RX_BUF_SIZE - sizeof(struct ipw_rt_hdr)) {\n\t\t/* FIXME: Should alloc bigger skb instead */\n\t\tdev->stats.rx_dropped++;\n\t\tpriv->wstats.discard.misc++;\n\t\tIPW_DEBUG_DROP(\"Dropping too large packet in monitor\\n\");\n\t\treturn;\n\t}\n\n\t/* copy the frame itself */\n\tmemmove(rxb->skb->data + sizeof(struct ipw_rt_hdr),\n\t\trxb->skb->data + IPW_RX_FRAME_SIZE, len);\n\n\tipw_rt = (struct ipw_rt_hdr *)rxb->skb->data;\n\n\tipw_rt->rt_hdr.it_version = PKTHDR_RADIOTAP_VERSION;\n\tipw_rt->rt_hdr.it_pad = 0;\t/* always good to zero */\n\tipw_rt->rt_hdr.it_len = cpu_to_le16(sizeof(struct ipw_rt_hdr));\t/* total header+data */\n\n\t/* Big bitfield of all the fields we provide in radiotap */\n\tipw_rt->rt_hdr.it_present = cpu_to_le32(\n\t     (1 << IEEE80211_RADIOTAP_TSFT) |\n\t     (1 << IEEE80211_RADIOTAP_FLAGS) |\n\t     (1 << IEEE80211_RADIOTAP_RATE) |\n\t     (1 << IEEE80211_RADIOTAP_CHANNEL) |\n\t     (1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL) |\n\t     (1 << IEEE80211_RADIOTAP_DBM_ANTNOISE) |\n\t     (1 << IEEE80211_RADIOTAP_ANTENNA));\n\n\t/* Zero the flags, we'll add to them as we go */\n\tipw_rt->rt_flags = 0;\n\tipw_rt->rt_tsf = (u64)(frame->parent_tsf[3] << 24 |\n\t\t\t       frame->parent_tsf[2] << 16 |\n\t\t\t       frame->parent_tsf[1] << 8  |\n\t\t\t       frame->parent_tsf[0]);\n\n\t/* Convert signal to DBM */\n\tipw_rt->rt_dbmsignal = antsignal;\n\tipw_rt->rt_dbmnoise = (s8) le16_to_cpu(frame->noise);\n\n\t/* Convert the channel data and set the flags */\n\tipw_rt->rt_channel = cpu_to_le16(ieee80211chan2mhz(received_channel));\n\tif (received_channel > 14) {\t/* 802.11a */\n\t\tipw_rt->rt_chbitmask =\n\t\t    cpu_to_le16((IEEE80211_CHAN_OFDM | IEEE80211_CHAN_5GHZ));\n\t} else if (antennaAndPhy & 32) {\t/* 802.11b */\n\t\tipw_rt->rt_chbitmask =\n\t\t    cpu_to_le16((IEEE80211_CHAN_CCK | IEEE80211_CHAN_2GHZ));\n\t} else {\t\t/* 802.11g */\n\t\tipw_rt->rt_chbitmask =\n\t\t    cpu_to_le16(IEEE80211_CHAN_OFDM | IEEE80211_CHAN_2GHZ);\n\t}\n\n\t/* set the rate in multiples of 500k/s */\n\tswitch (pktrate) {\n\tcase IPW_TX_RATE_1MB:\n\t\tipw_rt->rt_rate = 2;\n\t\tbreak;\n\tcase IPW_TX_RATE_2MB:\n\t\tipw_rt->rt_rate = 4;\n\t\tbreak;\n\tcase IPW_TX_RATE_5MB:\n\t\tipw_rt->rt_rate = 10;\n\t\tbreak;\n\tcase IPW_TX_RATE_6MB:\n\t\tipw_rt->rt_rate = 12;\n\t\tbreak;\n\tcase IPW_TX_RATE_9MB:\n\t\tipw_rt->rt_rate = 18;\n\t\tbreak;\n\tcase IPW_TX_RATE_11MB:\n\t\tipw_rt->rt_rate = 22;\n\t\tbreak;\n\tcase IPW_TX_RATE_12MB:\n\t\tipw_rt->rt_rate = 24;\n\t\tbreak;\n\tcase IPW_TX_RATE_18MB:\n\t\tipw_rt->rt_rate = 36;\n\t\tbreak;\n\tcase IPW_TX_RATE_24MB:\n\t\tipw_rt->rt_rate = 48;\n\t\tbreak;\n\tcase IPW_TX_RATE_36MB:\n\t\tipw_rt->rt_rate = 72;\n\t\tbreak;\n\tcase IPW_TX_RATE_48MB:\n\t\tipw_rt->rt_rate = 96;\n\t\tbreak;\n\tcase IPW_TX_RATE_54MB:\n\t\tipw_rt->rt_rate = 108;\n\t\tbreak;\n\tdefault:\n\t\tipw_rt->rt_rate = 0;\n\t\tbreak;\n\t}\n\n\t/* antenna number */\n\tipw_rt->rt_antenna = (antennaAndPhy & 3);\t/* Is this right? */\n\n\t/* set the preamble flag if we have it */\n\tif ((antennaAndPhy & 64))\n\t\tipw_rt->rt_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;\n\n\t/* Set the size of the skb to the size of the frame */\n\tskb_put(rxb->skb, len + sizeof(struct ipw_rt_hdr));\n\n\tIPW_DEBUG_RX(\"Rx packet of %d bytes.\\n\", rxb->skb->len);\n\n\tif (!libipw_rx(priv->ieee, rxb->skb, stats))\n\t\tdev->stats.rx_errors++;\n\telse {\t\t\t/* libipw_rx succeeded, so it now owns the SKB */\n\t\trxb->skb = NULL;\n\t\t/* no LED during capture */\n\t}\n}\n#endif\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n#define libipw_is_probe_response(fc) \\\n   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_MGMT && \\\n    (fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_PROBE_RESP )\n\n#define libipw_is_management(fc) \\\n   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_MGMT)\n\n#define libipw_is_control(fc) \\\n   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_CTL)\n\n#define libipw_is_data(fc) \\\n   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_DATA)\n\n#define libipw_is_assoc_request(fc) \\\n   ((fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_ASSOC_REQ)\n\n#define libipw_is_reassoc_request(fc) \\\n   ((fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_REASSOC_REQ)\n\nstatic void ipw_handle_promiscuous_rx(struct ipw_priv *priv,\n\t\t\t\t      struct ipw_rx_mem_buffer *rxb,\n\t\t\t\t      struct libipw_rx_stats *stats)\n{\n\tstruct net_device *dev = priv->prom_net_dev;\n\tstruct ipw_rx_packet *pkt = (struct ipw_rx_packet *)rxb->skb->data;\n\tstruct ipw_rx_frame *frame = &pkt->u.frame;\n\tstruct ipw_rt_hdr *ipw_rt;\n\n\t/* First cache any information we need before we overwrite\n\t * the information provided in the skb from the hardware */\n\tstruct ieee80211_hdr *hdr;\n\tu16 channel = frame->received_channel;\n\tu8 phy_flags = frame->antennaAndPhy;\n\ts8 signal = frame->rssi_dbm - IPW_RSSI_TO_DBM;\n\ts8 noise = (s8) le16_to_cpu(frame->noise);\n\tu8 rate = frame->rate;\n\tunsigned short len = le16_to_cpu(pkt->u.frame.length);\n\tstruct sk_buff *skb;\n\tint hdr_only = 0;\n\tu16 filter = priv->prom_priv->filter;\n\n\t/* If the filter is set to not include Rx frames then return */\n\tif (filter & IPW_PROM_NO_RX)\n\t\treturn;\n\n\t/* We received data from the HW, so stop the watchdog */\n\tnetif_trans_update(dev);\n\n\tif (unlikely((len + IPW_RX_FRAME_SIZE) > skb_tailroom(rxb->skb))) {\n\t\tdev->stats.rx_errors++;\n\t\tIPW_DEBUG_DROP(\"Corruption detected! Oh no!\\n\");\n\t\treturn;\n\t}\n\n\t/* We only process data packets if the interface is open */\n\tif (unlikely(!netif_running(dev))) {\n\t\tdev->stats.rx_dropped++;\n\t\tIPW_DEBUG_DROP(\"Dropping packet while interface is not up.\\n\");\n\t\treturn;\n\t}\n\n\t/* Libpcap 0.9.3+ can handle variable length radiotap, so we'll use\n\t * that now */\n\tif (len > IPW_RX_BUF_SIZE - sizeof(struct ipw_rt_hdr)) {\n\t\t/* FIXME: Should alloc bigger skb instead */\n\t\tdev->stats.rx_dropped++;\n\t\tIPW_DEBUG_DROP(\"Dropping too large packet in monitor\\n\");\n\t\treturn;\n\t}\n\n\thdr = (void *)rxb->skb->data + IPW_RX_FRAME_SIZE;\n\tif (libipw_is_management(le16_to_cpu(hdr->frame_control))) {\n\t\tif (filter & IPW_PROM_NO_MGMT)\n\t\t\treturn;\n\t\tif (filter & IPW_PROM_MGMT_HEADER_ONLY)\n\t\t\thdr_only = 1;\n\t} else if (libipw_is_control(le16_to_cpu(hdr->frame_control))) {\n\t\tif (filter & IPW_PROM_NO_CTL)\n\t\t\treturn;\n\t\tif (filter & IPW_PROM_CTL_HEADER_ONLY)\n\t\t\thdr_only = 1;\n\t} else if (libipw_is_data(le16_to_cpu(hdr->frame_control))) {\n\t\tif (filter & IPW_PROM_NO_DATA)\n\t\t\treturn;\n\t\tif (filter & IPW_PROM_DATA_HEADER_ONLY)\n\t\t\thdr_only = 1;\n\t}\n\n\t/* Copy the SKB since this is for the promiscuous side */\n\tskb = skb_copy(rxb->skb, GFP_ATOMIC);\n\tif (skb == NULL) {\n\t\tIPW_ERROR(\"skb_clone failed for promiscuous copy.\\n\");\n\t\treturn;\n\t}\n\n\t/* copy the frame data to write after where the radiotap header goes */\n\tipw_rt = (void *)skb->data;\n\n\tif (hdr_only)\n\t\tlen = libipw_get_hdrlen(le16_to_cpu(hdr->frame_control));\n\n\tmemcpy(ipw_rt->payload, hdr, len);\n\n\tipw_rt->rt_hdr.it_version = PKTHDR_RADIOTAP_VERSION;\n\tipw_rt->rt_hdr.it_pad = 0;\t/* always good to zero */\n\tipw_rt->rt_hdr.it_len = cpu_to_le16(sizeof(*ipw_rt));\t/* total header+data */\n\n\t/* Set the size of the skb to the size of the frame */\n\tskb_put(skb, sizeof(*ipw_rt) + len);\n\n\t/* Big bitfield of all the fields we provide in radiotap */\n\tipw_rt->rt_hdr.it_present = cpu_to_le32(\n\t     (1 << IEEE80211_RADIOTAP_TSFT) |\n\t     (1 << IEEE80211_RADIOTAP_FLAGS) |\n\t     (1 << IEEE80211_RADIOTAP_RATE) |\n\t     (1 << IEEE80211_RADIOTAP_CHANNEL) |\n\t     (1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL) |\n\t     (1 << IEEE80211_RADIOTAP_DBM_ANTNOISE) |\n\t     (1 << IEEE80211_RADIOTAP_ANTENNA));\n\n\t/* Zero the flags, we'll add to them as we go */\n\tipw_rt->rt_flags = 0;\n\tipw_rt->rt_tsf = (u64)(frame->parent_tsf[3] << 24 |\n\t\t\t       frame->parent_tsf[2] << 16 |\n\t\t\t       frame->parent_tsf[1] << 8  |\n\t\t\t       frame->parent_tsf[0]);\n\n\t/* Convert to DBM */\n\tipw_rt->rt_dbmsignal = signal;\n\tipw_rt->rt_dbmnoise = noise;\n\n\t/* Convert the channel data and set the flags */\n\tipw_rt->rt_channel = cpu_to_le16(ieee80211chan2mhz(channel));\n\tif (channel > 14) {\t/* 802.11a */\n\t\tipw_rt->rt_chbitmask =\n\t\t    cpu_to_le16((IEEE80211_CHAN_OFDM | IEEE80211_CHAN_5GHZ));\n\t} else if (phy_flags & (1 << 5)) {\t/* 802.11b */\n\t\tipw_rt->rt_chbitmask =\n\t\t    cpu_to_le16((IEEE80211_CHAN_CCK | IEEE80211_CHAN_2GHZ));\n\t} else {\t\t/* 802.11g */\n\t\tipw_rt->rt_chbitmask =\n\t\t    cpu_to_le16(IEEE80211_CHAN_OFDM | IEEE80211_CHAN_2GHZ);\n\t}\n\n\t/* set the rate in multiples of 500k/s */\n\tswitch (rate) {\n\tcase IPW_TX_RATE_1MB:\n\t\tipw_rt->rt_rate = 2;\n\t\tbreak;\n\tcase IPW_TX_RATE_2MB:\n\t\tipw_rt->rt_rate = 4;\n\t\tbreak;\n\tcase IPW_TX_RATE_5MB:\n\t\tipw_rt->rt_rate = 10;\n\t\tbreak;\n\tcase IPW_TX_RATE_6MB:\n\t\tipw_rt->rt_rate = 12;\n\t\tbreak;\n\tcase IPW_TX_RATE_9MB:\n\t\tipw_rt->rt_rate = 18;\n\t\tbreak;\n\tcase IPW_TX_RATE_11MB:\n\t\tipw_rt->rt_rate = 22;\n\t\tbreak;\n\tcase IPW_TX_RATE_12MB:\n\t\tipw_rt->rt_rate = 24;\n\t\tbreak;\n\tcase IPW_TX_RATE_18MB:\n\t\tipw_rt->rt_rate = 36;\n\t\tbreak;\n\tcase IPW_TX_RATE_24MB:\n\t\tipw_rt->rt_rate = 48;\n\t\tbreak;\n\tcase IPW_TX_RATE_36MB:\n\t\tipw_rt->rt_rate = 72;\n\t\tbreak;\n\tcase IPW_TX_RATE_48MB:\n\t\tipw_rt->rt_rate = 96;\n\t\tbreak;\n\tcase IPW_TX_RATE_54MB:\n\t\tipw_rt->rt_rate = 108;\n\t\tbreak;\n\tdefault:\n\t\tipw_rt->rt_rate = 0;\n\t\tbreak;\n\t}\n\n\t/* antenna number */\n\tipw_rt->rt_antenna = (phy_flags & 3);\n\n\t/* set the preamble flag if we have it */\n\tif (phy_flags & (1 << 6))\n\t\tipw_rt->rt_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;\n\n\tIPW_DEBUG_RX(\"Rx packet of %d bytes.\\n\", skb->len);\n\n\tif (!libipw_rx(priv->prom_priv->ieee, skb, stats)) {\n\t\tdev->stats.rx_errors++;\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n#endif\n\nstatic int is_network_packet(struct ipw_priv *priv,\n\t\t\t\t    struct libipw_hdr_4addr *header)\n{\n\t/* Filter incoming packets to determine if they are targeted toward\n\t * this network, discarding packets coming from ourselves */\n\tswitch (priv->ieee->iw_mode) {\n\tcase IW_MODE_ADHOC:\t/* Header: Dest. | Source    | BSSID */\n\t\t/* packets from our adapter are dropped (echo) */\n\t\tif (ether_addr_equal(header->addr2, priv->net_dev->dev_addr))\n\t\t\treturn 0;\n\n\t\t/* {broad,multi}cast packets to our BSSID go through */\n\t\tif (is_multicast_ether_addr(header->addr1))\n\t\t\treturn ether_addr_equal(header->addr3, priv->bssid);\n\n\t\t/* packets to our adapter go through */\n\t\treturn ether_addr_equal(header->addr1,\n\t\t\t\t\tpriv->net_dev->dev_addr);\n\n\tcase IW_MODE_INFRA:\t/* Header: Dest. | BSSID | Source */\n\t\t/* packets from our adapter are dropped (echo) */\n\t\tif (ether_addr_equal(header->addr3, priv->net_dev->dev_addr))\n\t\t\treturn 0;\n\n\t\t/* {broad,multi}cast packets to our BSS go through */\n\t\tif (is_multicast_ether_addr(header->addr1))\n\t\t\treturn ether_addr_equal(header->addr2, priv->bssid);\n\n\t\t/* packets to our adapter go through */\n\t\treturn ether_addr_equal(header->addr1,\n\t\t\t\t\tpriv->net_dev->dev_addr);\n\t}\n\n\treturn 1;\n}\n\n#define IPW_PACKET_RETRY_TIME HZ\n\nstatic  int is_duplicate_packet(struct ipw_priv *priv,\n\t\t\t\t      struct libipw_hdr_4addr *header)\n{\n\tu16 sc = le16_to_cpu(header->seq_ctl);\n\tu16 seq = WLAN_GET_SEQ_SEQ(sc);\n\tu16 frag = WLAN_GET_SEQ_FRAG(sc);\n\tu16 *last_seq, *last_frag;\n\tunsigned long *last_time;\n\n\tswitch (priv->ieee->iw_mode) {\n\tcase IW_MODE_ADHOC:\n\t\t{\n\t\t\tstruct list_head *p;\n\t\t\tstruct ipw_ibss_seq *entry = NULL;\n\t\t\tu8 *mac = header->addr2;\n\t\t\tint index = mac[5] % IPW_IBSS_MAC_HASH_SIZE;\n\n\t\t\tlist_for_each(p, &priv->ibss_mac_hash[index]) {\n\t\t\t\tentry =\n\t\t\t\t    list_entry(p, struct ipw_ibss_seq, list);\n\t\t\t\tif (ether_addr_equal(entry->mac, mac))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p == &priv->ibss_mac_hash[index]) {\n\t\t\t\tentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\n\t\t\t\tif (!entry) {\n\t\t\t\t\tIPW_ERROR\n\t\t\t\t\t    (\"Cannot malloc new mac entry\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tmemcpy(entry->mac, mac, ETH_ALEN);\n\t\t\t\tentry->seq_num = seq;\n\t\t\t\tentry->frag_num = frag;\n\t\t\t\tentry->packet_time = jiffies;\n\t\t\t\tlist_add(&entry->list,\n\t\t\t\t\t &priv->ibss_mac_hash[index]);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tlast_seq = &entry->seq_num;\n\t\t\tlast_frag = &entry->frag_num;\n\t\t\tlast_time = &entry->packet_time;\n\t\t\tbreak;\n\t\t}\n\tcase IW_MODE_INFRA:\n\t\tlast_seq = &priv->last_seq_num;\n\t\tlast_frag = &priv->last_frag_num;\n\t\tlast_time = &priv->last_packet_time;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif ((*last_seq == seq) &&\n\t    time_after(*last_time + IPW_PACKET_RETRY_TIME, jiffies)) {\n\t\tif (*last_frag == frag)\n\t\t\tgoto drop;\n\t\tif (*last_frag + 1 != frag)\n\t\t\t/* out-of-order fragment */\n\t\t\tgoto drop;\n\t} else\n\t\t*last_seq = seq;\n\n\t*last_frag = frag;\n\t*last_time = jiffies;\n\treturn 0;\n\n      drop:\n\t/* Comment this line now since we observed the card receives\n\t * duplicate packets but the FCTL_RETRY bit is not set in the\n\t * IBSS mode with fragmentation enabled.\n\t BUG_ON(!(le16_to_cpu(header->frame_control) & IEEE80211_FCTL_RETRY)); */\n\treturn 1;\n}\n\nstatic void ipw_handle_mgmt_packet(struct ipw_priv *priv,\n\t\t\t\t   struct ipw_rx_mem_buffer *rxb,\n\t\t\t\t   struct libipw_rx_stats *stats)\n{\n\tstruct sk_buff *skb = rxb->skb;\n\tstruct ipw_rx_packet *pkt = (struct ipw_rx_packet *)skb->data;\n\tstruct libipw_hdr_4addr *header = (struct libipw_hdr_4addr *)\n\t    (skb->data + IPW_RX_FRAME_SIZE);\n\n\tlibipw_rx_mgt(priv->ieee, header, stats);\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC &&\n\t    ((WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)) ==\n\t      IEEE80211_STYPE_PROBE_RESP) ||\n\t     (WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)) ==\n\t      IEEE80211_STYPE_BEACON))) {\n\t\tif (ether_addr_equal(header->addr3, priv->bssid))\n\t\t\tipw_add_station(priv, header->addr2);\n\t}\n\n\tif (priv->config & CFG_NET_STATS) {\n\t\tIPW_DEBUG_HC(\"sending stat packet\\n\");\n\n\t\t/* Set the size of the skb to the size of the full\n\t\t * ipw header and 802.11 frame */\n\t\tskb_put(skb, le16_to_cpu(pkt->u.frame.length) +\n\t\t\tIPW_RX_FRAME_SIZE);\n\n\t\t/* Advance past the ipw packet header to the 802.11 frame */\n\t\tskb_pull(skb, IPW_RX_FRAME_SIZE);\n\n\t\t/* Push the libipw_rx_stats before the 802.11 frame */\n\t\tmemcpy(skb_push(skb, sizeof(*stats)), stats, sizeof(*stats));\n\n\t\tskb->dev = priv->ieee->dev;\n\n\t\t/* Point raw at the libipw_stats */\n\t\tskb_reset_mac_header(skb);\n\n\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\tskb->protocol = cpu_to_be16(ETH_P_80211_STATS);\n\t\tmemset(skb->cb, 0, sizeof(rxb->skb->cb));\n\t\tnetif_rx(skb);\n\t\trxb->skb = NULL;\n\t}\n}\n\n/*\n * Main entry function for receiving a packet with 80211 headers.  This\n * should be called when ever the FW has notified us that there is a new\n * skb in the receive queue.\n */\nstatic void ipw_rx(struct ipw_priv *priv)\n{\n\tstruct ipw_rx_mem_buffer *rxb;\n\tstruct ipw_rx_packet *pkt;\n\tstruct libipw_hdr_4addr *header;\n\tu32 r, i;\n\tu8 network_packet;\n\tu8 fill_rx = 0;\n\n\tr = ipw_read32(priv, IPW_RX_READ_INDEX);\n\tipw_read32(priv, IPW_RX_WRITE_INDEX);\n\ti = priv->rxq->read;\n\n\tif (ipw_rx_queue_space (priv->rxq) > (RX_QUEUE_SIZE / 2))\n\t\tfill_rx = 1;\n\n\twhile (i != r) {\n\t\trxb = priv->rxq->queue[i];\n\t\tif (unlikely(rxb == NULL)) {\n\t\t\tprintk(KERN_CRIT \"Queue not allocated!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tpriv->rxq->queue[i] = NULL;\n\n\t\tdma_sync_single_for_cpu(&priv->pci_dev->dev, rxb->dma_addr,\n\t\t\t\t\tIPW_RX_BUF_SIZE, DMA_FROM_DEVICE);\n\n\t\tpkt = (struct ipw_rx_packet *)rxb->skb->data;\n\t\tIPW_DEBUG_RX(\"Packet: type=%02X seq=%02X bits=%02X\\n\",\n\t\t\t     pkt->header.message_type,\n\t\t\t     pkt->header.rx_seq_num, pkt->header.control_bits);\n\n\t\tswitch (pkt->header.message_type) {\n\t\tcase RX_FRAME_TYPE:\t/* 802.11 frame */  {\n\t\t\t\tstruct libipw_rx_stats stats = {\n\t\t\t\t\t.rssi = pkt->u.frame.rssi_dbm -\n\t\t\t\t\t    IPW_RSSI_TO_DBM,\n\t\t\t\t\t.signal =\n\t\t\t\t\t    pkt->u.frame.rssi_dbm -\n\t\t\t\t\t    IPW_RSSI_TO_DBM + 0x100,\n\t\t\t\t\t.noise =\n\t\t\t\t\t    le16_to_cpu(pkt->u.frame.noise),\n\t\t\t\t\t.rate = pkt->u.frame.rate,\n\t\t\t\t\t.mac_time = jiffies,\n\t\t\t\t\t.received_channel =\n\t\t\t\t\t    pkt->u.frame.received_channel,\n\t\t\t\t\t.freq =\n\t\t\t\t\t    (pkt->u.frame.\n\t\t\t\t\t     control & (1 << 0)) ?\n\t\t\t\t\t    LIBIPW_24GHZ_BAND :\n\t\t\t\t\t    LIBIPW_52GHZ_BAND,\n\t\t\t\t\t.len = le16_to_cpu(pkt->u.frame.length),\n\t\t\t\t};\n\n\t\t\t\tif (stats.rssi != 0)\n\t\t\t\t\tstats.mask |= LIBIPW_STATMASK_RSSI;\n\t\t\t\tif (stats.signal != 0)\n\t\t\t\t\tstats.mask |= LIBIPW_STATMASK_SIGNAL;\n\t\t\t\tif (stats.noise != 0)\n\t\t\t\t\tstats.mask |= LIBIPW_STATMASK_NOISE;\n\t\t\t\tif (stats.rate != 0)\n\t\t\t\t\tstats.mask |= LIBIPW_STATMASK_RATE;\n\n\t\t\t\tpriv->rx_packets++;\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n\tif (priv->prom_net_dev && netif_running(priv->prom_net_dev))\n\t\tipw_handle_promiscuous_rx(priv, rxb, &stats);\n#endif\n\n#ifdef CONFIG_IPW2200_MONITOR\n\t\t\t\tif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\n#ifdef CONFIG_IPW2200_RADIOTAP\n\n                ipw_handle_data_packet_monitor(priv,\n\t\t\t\t\t       rxb,\n\t\t\t\t\t       &stats);\n#else\n\t\tipw_handle_data_packet(priv, rxb,\n\t\t\t\t       &stats);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\n\t\t\t\theader =\n\t\t\t\t    (struct libipw_hdr_4addr *)(rxb->skb->\n\t\t\t\t\t\t\t\t   data +\n\t\t\t\t\t\t\t\t   IPW_RX_FRAME_SIZE);\n\t\t\t\t/* TODO: Check Ad-Hoc dest/source and make sure\n\t\t\t\t * that we are actually parsing these packets\n\t\t\t\t * correctly -- we should probably use the\n\t\t\t\t * frame control of the packet and disregard\n\t\t\t\t * the current iw_mode */\n\n\t\t\t\tnetwork_packet =\n\t\t\t\t    is_network_packet(priv, header);\n\t\t\t\tif (network_packet && priv->assoc_network) {\n\t\t\t\t\tpriv->assoc_network->stats.rssi =\n\t\t\t\t\t    stats.rssi;\n\t\t\t\t\tpriv->exp_avg_rssi =\n\t\t\t\t\t    exponential_average(priv->exp_avg_rssi,\n\t\t\t\t\t    stats.rssi, DEPTH_RSSI);\n\t\t\t\t}\n\n\t\t\t\tIPW_DEBUG_RX(\"Frame: len=%u\\n\",\n\t\t\t\t\t     le16_to_cpu(pkt->u.frame.length));\n\n\t\t\t\tif (le16_to_cpu(pkt->u.frame.length) <\n\t\t\t\t    libipw_get_hdrlen(le16_to_cpu(\n\t\t\t\t\t\t    header->frame_ctl))) {\n\t\t\t\t\tIPW_DEBUG_DROP\n\t\t\t\t\t    (\"Received packet is too small. \"\n\t\t\t\t\t     \"Dropping.\\n\");\n\t\t\t\t\tpriv->net_dev->stats.rx_errors++;\n\t\t\t\t\tpriv->wstats.discard.misc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tswitch (WLAN_FC_GET_TYPE\n\t\t\t\t\t(le16_to_cpu(header->frame_ctl))) {\n\n\t\t\t\tcase IEEE80211_FTYPE_MGMT:\n\t\t\t\t\tipw_handle_mgmt_packet(priv, rxb,\n\t\t\t\t\t\t\t       &stats);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase IEEE80211_FTYPE_CTL:\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase IEEE80211_FTYPE_DATA:\n\t\t\t\t\tif (unlikely(!network_packet ||\n\t\t\t\t\t\t     is_duplicate_packet(priv,\n\t\t\t\t\t\t\t\t\t header)))\n\t\t\t\t\t{\n\t\t\t\t\t\tIPW_DEBUG_DROP(\"Dropping: \"\n\t\t\t\t\t\t\t       \"%pM, \"\n\t\t\t\t\t\t\t       \"%pM, \"\n\t\t\t\t\t\t\t       \"%pM\\n\",\n\t\t\t\t\t\t\t       header->addr1,\n\t\t\t\t\t\t\t       header->addr2,\n\t\t\t\t\t\t\t       header->addr3);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tipw_handle_data_packet(priv, rxb,\n\t\t\t\t\t\t\t       &stats);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase RX_HOST_NOTIFICATION_TYPE:{\n\t\t\t\tIPW_DEBUG_RX\n\t\t\t\t    (\"Notification: subtype=%02X flags=%02X size=%d\\n\",\n\t\t\t\t     pkt->u.notification.subtype,\n\t\t\t\t     pkt->u.notification.flags,\n\t\t\t\t     le16_to_cpu(pkt->u.notification.size));\n\t\t\t\tipw_rx_notification(priv, &pkt->u.notification);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tIPW_DEBUG_RX(\"Bad Rx packet of type %d\\n\",\n\t\t\t\t     pkt->header.message_type);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* For now we just don't re-use anything.  We can tweak this\n\t\t * later to try and re-use notification packets and SKBs that\n\t\t * fail to Rx correctly */\n\t\tif (rxb->skb != NULL) {\n\t\t\tdev_kfree_skb_any(rxb->skb);\n\t\t\trxb->skb = NULL;\n\t\t}\n\n\t\tdma_unmap_single(&priv->pci_dev->dev, rxb->dma_addr,\n\t\t\t\t IPW_RX_BUF_SIZE, DMA_FROM_DEVICE);\n\t\tlist_add_tail(&rxb->list, &priv->rxq->rx_used);\n\n\t\ti = (i + 1) % RX_QUEUE_SIZE;\n\n\t\t/* If there are a lot of unsued frames, restock the Rx queue\n\t\t * so the ucode won't assert */\n\t\tif (fill_rx) {\n\t\t\tpriv->rxq->read = i;\n\t\t\tipw_rx_queue_replenish(priv);\n\t\t}\n\t}\n\n\t/* Backtrack one entry */\n\tpriv->rxq->read = i;\n\tipw_rx_queue_restock(priv);\n}\n\n#define DEFAULT_RTS_THRESHOLD     2304U\n#define MIN_RTS_THRESHOLD         1U\n#define MAX_RTS_THRESHOLD         2304U\n#define DEFAULT_BEACON_INTERVAL   100U\n#define\tDEFAULT_SHORT_RETRY_LIMIT 7U\n#define\tDEFAULT_LONG_RETRY_LIMIT  4U\n\n/*\n * ipw_sw_reset\n * @option: options to control different reset behaviour\n * \t    0 = reset everything except the 'disable' module_param\n * \t    1 = reset everything and print out driver info (for probe only)\n * \t    2 = reset everything\n */\nstatic int ipw_sw_reset(struct ipw_priv *priv, int option)\n{\n\tint band, modulation;\n\tint old_mode = priv->ieee->iw_mode;\n\n\t/* Initialize module parameter values here */\n\tpriv->config = 0;\n\n\t/* We default to disabling the LED code as right now it causes\n\t * too many systems to lock up... */\n\tif (!led_support)\n\t\tpriv->config |= CFG_NO_LED;\n\n\tif (associate)\n\t\tpriv->config |= CFG_ASSOCIATE;\n\telse\n\t\tIPW_DEBUG_INFO(\"Auto associate disabled.\\n\");\n\n\tif (auto_create)\n\t\tpriv->config |= CFG_ADHOC_CREATE;\n\telse\n\t\tIPW_DEBUG_INFO(\"Auto adhoc creation disabled.\\n\");\n\n\tpriv->config &= ~CFG_STATIC_ESSID;\n\tpriv->essid_len = 0;\n\tmemset(priv->essid, 0, IW_ESSID_MAX_SIZE);\n\n\tif (disable && option) {\n\t\tpriv->status |= STATUS_RF_KILL_SW;\n\t\tIPW_DEBUG_INFO(\"Radio disabled.\\n\");\n\t}\n\n\tif (default_channel != 0) {\n\t\tpriv->config |= CFG_STATIC_CHANNEL;\n\t\tpriv->channel = default_channel;\n\t\tIPW_DEBUG_INFO(\"Bind to static channel %d\\n\", default_channel);\n\t\t/* TODO: Validate that provided channel is in range */\n\t}\n#ifdef CONFIG_IPW2200_QOS\n\tipw_qos_init(priv, qos_enable, qos_burst_enable,\n\t\t     burst_duration_CCK, burst_duration_OFDM);\n#endif\t\t\t\t/* CONFIG_IPW2200_QOS */\n\n\tswitch (network_mode) {\n\tcase 1:\n\t\tpriv->ieee->iw_mode = IW_MODE_ADHOC;\n\t\tpriv->net_dev->type = ARPHRD_ETHER;\n\n\t\tbreak;\n#ifdef CONFIG_IPW2200_MONITOR\n\tcase 2:\n\t\tpriv->ieee->iw_mode = IW_MODE_MONITOR;\n#ifdef CONFIG_IPW2200_RADIOTAP\n\t\tpriv->net_dev->type = ARPHRD_IEEE80211_RADIOTAP;\n#else\n\t\tpriv->net_dev->type = ARPHRD_IEEE80211;\n#endif\n\t\tbreak;\n#endif\n\tdefault:\n\tcase 0:\n\t\tpriv->net_dev->type = ARPHRD_ETHER;\n\t\tpriv->ieee->iw_mode = IW_MODE_INFRA;\n\t\tbreak;\n\t}\n\n\tif (hwcrypto) {\n\t\tpriv->ieee->host_encrypt = 0;\n\t\tpriv->ieee->host_encrypt_msdu = 0;\n\t\tpriv->ieee->host_decrypt = 0;\n\t\tpriv->ieee->host_mc_decrypt = 0;\n\t}\n\tIPW_DEBUG_INFO(\"Hardware crypto [%s]\\n\", hwcrypto ? \"on\" : \"off\");\n\n\t/* IPW2200/2915 is abled to do hardware fragmentation. */\n\tpriv->ieee->host_open_frag = 0;\n\n\tif ((priv->pci_dev->device == 0x4223) ||\n\t    (priv->pci_dev->device == 0x4224)) {\n\t\tif (option == 1)\n\t\t\tprintk(KERN_INFO DRV_NAME\n\t\t\t       \": Detected Intel PRO/Wireless 2915ABG Network \"\n\t\t\t       \"Connection\\n\");\n\t\tpriv->ieee->abg_true = 1;\n\t\tband = LIBIPW_52GHZ_BAND | LIBIPW_24GHZ_BAND;\n\t\tmodulation = LIBIPW_OFDM_MODULATION |\n\t\t    LIBIPW_CCK_MODULATION;\n\t\tpriv->adapter = IPW_2915ABG;\n\t\tpriv->ieee->mode = IEEE_A | IEEE_G | IEEE_B;\n\t} else {\n\t\tif (option == 1)\n\t\t\tprintk(KERN_INFO DRV_NAME\n\t\t\t       \": Detected Intel PRO/Wireless 2200BG Network \"\n\t\t\t       \"Connection\\n\");\n\n\t\tpriv->ieee->abg_true = 0;\n\t\tband = LIBIPW_24GHZ_BAND;\n\t\tmodulation = LIBIPW_OFDM_MODULATION |\n\t\t    LIBIPW_CCK_MODULATION;\n\t\tpriv->adapter = IPW_2200BG;\n\t\tpriv->ieee->mode = IEEE_G | IEEE_B;\n\t}\n\n\tpriv->ieee->freq_band = band;\n\tpriv->ieee->modulation = modulation;\n\n\tpriv->rates_mask = LIBIPW_DEFAULT_RATES_MASK;\n\n\tpriv->disassociate_threshold = IPW_MB_DISASSOCIATE_THRESHOLD_DEFAULT;\n\tpriv->roaming_threshold = IPW_MB_ROAMING_THRESHOLD_DEFAULT;\n\n\tpriv->rts_threshold = DEFAULT_RTS_THRESHOLD;\n\tpriv->short_retry_limit = DEFAULT_SHORT_RETRY_LIMIT;\n\tpriv->long_retry_limit = DEFAULT_LONG_RETRY_LIMIT;\n\n\t/* If power management is turned on, default to AC mode */\n\tpriv->power_mode = IPW_POWER_AC;\n\tpriv->tx_power = IPW_TX_POWER_DEFAULT;\n\n\treturn old_mode == priv->ieee->iw_mode;\n}\n\n/*\n * This file defines the Wireless Extension handlers.  It does not\n * define any methods of hardware manipulation and relies on the\n * functions defined in ipw_main to provide the HW interaction.\n *\n * The exception to this is the use of the ipw_get_ordinal()\n * function used to poll the hardware vs. making unnecessary calls.\n *\n */\n\nstatic int ipw_set_channel(struct ipw_priv *priv, u8 channel)\n{\n\tif (channel == 0) {\n\t\tIPW_DEBUG_INFO(\"Setting channel to ANY (0)\\n\");\n\t\tpriv->config &= ~CFG_STATIC_CHANNEL;\n\t\tIPW_DEBUG_ASSOC(\"Attempting to associate with new \"\n\t\t\t\t\"parameters.\\n\");\n\t\tipw_associate(priv);\n\t\treturn 0;\n\t}\n\n\tpriv->config |= CFG_STATIC_CHANNEL;\n\n\tif (priv->channel == channel) {\n\t\tIPW_DEBUG_INFO(\"Request to set channel to current value (%d)\\n\",\n\t\t\t       channel);\n\t\treturn 0;\n\t}\n\n\tIPW_DEBUG_INFO(\"Setting channel to %i\\n\", (int)channel);\n\tpriv->channel = channel;\n\n#ifdef CONFIG_IPW2200_MONITOR\n\tif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tint i;\n\t\tif (priv->status & STATUS_SCANNING) {\n\t\t\tIPW_DEBUG_SCAN(\"Scan abort triggered due to \"\n\t\t\t\t       \"channel change.\\n\");\n\t\t\tipw_abort_scan(priv);\n\t\t}\n\n\t\tfor (i = 1000; i && (priv->status & STATUS_SCANNING); i--)\n\t\t\tudelay(10);\n\n\t\tif (priv->status & STATUS_SCANNING)\n\t\t\tIPW_DEBUG_SCAN(\"Still scanning...\\n\");\n\t\telse\n\t\t\tIPW_DEBUG_SCAN(\"Took %dms to abort current scan\\n\",\n\t\t\t\t       1000 - i);\n\n\t\treturn 0;\n\t}\n#endif\t\t\t\t/* CONFIG_IPW2200_MONITOR */\n\n\t/* Network configuration changed -- force [re]association */\n\tIPW_DEBUG_ASSOC(\"[re]association triggered due to channel change.\\n\");\n\tif (!ipw_disassociate(priv))\n\t\tipw_associate(priv);\n\n\treturn 0;\n}\n\nstatic int ipw_wx_set_freq(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\n\tstruct iw_freq *fwrq = &wrqu->freq;\n\tint ret = 0, i;\n\tu8 channel, flags;\n\tint band;\n\n\tif (fwrq->m == 0) {\n\t\tIPW_DEBUG_WX(\"SET Freq/Channel -> any\\n\");\n\t\tmutex_lock(&priv->mutex);\n\t\tret = ipw_set_channel(priv, 0);\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn ret;\n\t}\n\t/* if setting by freq convert to channel */\n\tif (fwrq->e == 1) {\n\t\tchannel = libipw_freq_to_channel(priv->ieee, fwrq->m);\n\t\tif (channel == 0)\n\t\t\treturn -EINVAL;\n\t} else\n\t\tchannel = fwrq->m;\n\n\tif (!(band = libipw_is_valid_channel(priv->ieee, channel)))\n\t\treturn -EINVAL;\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\ti = libipw_channel_to_index(priv->ieee, channel);\n\t\tif (i == -1)\n\t\t\treturn -EINVAL;\n\n\t\tflags = (band == LIBIPW_24GHZ_BAND) ?\n\t\t    geo->bg[i].flags : geo->a[i].flags;\n\t\tif (flags & LIBIPW_CH_PASSIVE_ONLY) {\n\t\t\tIPW_DEBUG_WX(\"Invalid Ad-Hoc channel for 802.11a\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tIPW_DEBUG_WX(\"SET Freq/Channel -> %d\\n\", fwrq->m);\n\tmutex_lock(&priv->mutex);\n\tret = ipw_set_channel(priv, channel);\n\tmutex_unlock(&priv->mutex);\n\treturn ret;\n}\n\nstatic int ipw_wx_get_freq(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\n\twrqu->freq.e = 0;\n\n\t/* If we are associated, trying to associate, or have a statically\n\t * configured CHANNEL then return that; otherwise return ANY */\n\tmutex_lock(&priv->mutex);\n\tif (priv->config & CFG_STATIC_CHANNEL ||\n\t    priv->status & (STATUS_ASSOCIATING | STATUS_ASSOCIATED)) {\n\t\tint i;\n\n\t\ti = libipw_channel_to_index(priv->ieee, priv->channel);\n\t\tBUG_ON(i == -1);\n\t\twrqu->freq.e = 1;\n\n\t\tswitch (libipw_is_valid_channel(priv->ieee, priv->channel)) {\n\t\tcase LIBIPW_52GHZ_BAND:\n\t\t\twrqu->freq.m = priv->ieee->geo.a[i].freq * 100000;\n\t\t\tbreak;\n\n\t\tcase LIBIPW_24GHZ_BAND:\n\t\t\twrqu->freq.m = priv->ieee->geo.bg[i].freq * 100000;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t} else\n\t\twrqu->freq.m = 0;\n\n\tmutex_unlock(&priv->mutex);\n\tIPW_DEBUG_WX(\"GET Freq/Channel -> %d\\n\", priv->channel);\n\treturn 0;\n}\n\nstatic int ipw_wx_set_mode(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint err = 0;\n\n\tIPW_DEBUG_WX(\"Set MODE: %d\\n\", wrqu->mode);\n\n\tswitch (wrqu->mode) {\n#ifdef CONFIG_IPW2200_MONITOR\n\tcase IW_MODE_MONITOR:\n#endif\n\tcase IW_MODE_ADHOC:\n\tcase IW_MODE_INFRA:\n\t\tbreak;\n\tcase IW_MODE_AUTO:\n\t\twrqu->mode = IW_MODE_INFRA;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (wrqu->mode == priv->ieee->iw_mode)\n\t\treturn 0;\n\n\tmutex_lock(&priv->mutex);\n\n\tipw_sw_reset(priv, 0);\n\n#ifdef CONFIG_IPW2200_MONITOR\n\tif (priv->ieee->iw_mode == IW_MODE_MONITOR)\n\t\tpriv->net_dev->type = ARPHRD_ETHER;\n\n\tif (wrqu->mode == IW_MODE_MONITOR)\n#ifdef CONFIG_IPW2200_RADIOTAP\n\t\tpriv->net_dev->type = ARPHRD_IEEE80211_RADIOTAP;\n#else\n\t\tpriv->net_dev->type = ARPHRD_IEEE80211;\n#endif\n#endif\t\t\t\t/* CONFIG_IPW2200_MONITOR */\n\n\t/* Free the existing firmware and reset the fw_loaded\n\t * flag so ipw_load() will bring in the new firmware */\n\tfree_firmware();\n\n\tpriv->ieee->iw_mode = wrqu->mode;\n\n\tschedule_work(&priv->adapter_restart);\n\tmutex_unlock(&priv->mutex);\n\treturn err;\n}\n\nstatic int ipw_wx_get_mode(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\twrqu->mode = priv->ieee->iw_mode;\n\tIPW_DEBUG_WX(\"Get MODE -> %d\\n\", wrqu->mode);\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\n/* Values are in microsecond */\nstatic const s32 timeout_duration[] = {\n\t350000,\n\t250000,\n\t75000,\n\t37000,\n\t25000,\n};\n\nstatic const s32 period_duration[] = {\n\t400000,\n\t700000,\n\t1000000,\n\t1000000,\n\t1000000\n};\n\nstatic int ipw_wx_get_range(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct iw_range *range = (struct iw_range *)extra;\n\tconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\n\tint i = 0, j;\n\n\twrqu->data.length = sizeof(*range);\n\tmemset(range, 0, sizeof(*range));\n\n\t/* 54Mbs == ~27 Mb/s real (802.11g) */\n\trange->throughput = 27 * 1000 * 1000;\n\n\trange->max_qual.qual = 100;\n\t/* TODO: Find real max RSSI and stick here */\n\trange->max_qual.level = 0;\n\trange->max_qual.noise = 0;\n\trange->max_qual.updated = 7;\t/* Updated all three */\n\n\trange->avg_qual.qual = 70;\n\t/* TODO: Find real 'good' to 'bad' threshold value for RSSI */\n\trange->avg_qual.level = 0;\t/* FIXME to real average level */\n\trange->avg_qual.noise = 0;\n\trange->avg_qual.updated = 7;\t/* Updated all three */\n\tmutex_lock(&priv->mutex);\n\trange->num_bitrates = min(priv->rates.num_rates, (u8) IW_MAX_BITRATES);\n\n\tfor (i = 0; i < range->num_bitrates; i++)\n\t\trange->bitrate[i] = (priv->rates.supported_rates[i] & 0x7F) *\n\t\t    500000;\n\n\trange->max_rts = DEFAULT_RTS_THRESHOLD;\n\trange->min_frag = MIN_FRAG_THRESHOLD;\n\trange->max_frag = MAX_FRAG_THRESHOLD;\n\n\trange->encoding_size[0] = 5;\n\trange->encoding_size[1] = 13;\n\trange->num_encoding_sizes = 2;\n\trange->max_encoding_tokens = WEP_KEYS;\n\n\t/* Set the Wireless Extension versions */\n\trange->we_version_compiled = WIRELESS_EXT;\n\trange->we_version_source = 18;\n\n\ti = 0;\n\tif (priv->ieee->mode & (IEEE_B | IEEE_G)) {\n\t\tfor (j = 0; j < geo->bg_channels && i < IW_MAX_FREQUENCIES; j++) {\n\t\t\tif ((priv->ieee->iw_mode == IW_MODE_ADHOC) &&\n\t\t\t    (geo->bg[j].flags & LIBIPW_CH_PASSIVE_ONLY))\n\t\t\t\tcontinue;\n\n\t\t\trange->freq[i].i = geo->bg[j].channel;\n\t\t\trange->freq[i].m = geo->bg[j].freq * 100000;\n\t\t\trange->freq[i].e = 1;\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (priv->ieee->mode & IEEE_A) {\n\t\tfor (j = 0; j < geo->a_channels && i < IW_MAX_FREQUENCIES; j++) {\n\t\t\tif ((priv->ieee->iw_mode == IW_MODE_ADHOC) &&\n\t\t\t    (geo->a[j].flags & LIBIPW_CH_PASSIVE_ONLY))\n\t\t\t\tcontinue;\n\n\t\t\trange->freq[i].i = geo->a[j].channel;\n\t\t\trange->freq[i].m = geo->a[j].freq * 100000;\n\t\t\trange->freq[i].e = 1;\n\t\t\ti++;\n\t\t}\n\t}\n\n\trange->num_channels = i;\n\trange->num_frequency = i;\n\n\tmutex_unlock(&priv->mutex);\n\n\t/* Event capability (kernel + driver) */\n\trange->event_capa[0] = (IW_EVENT_CAPA_K_0 |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWTHRSPY) |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWAP) |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWSCAN));\n\trange->event_capa[1] = IW_EVENT_CAPA_K_1;\n\n\trange->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |\n\t\tIW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;\n\n\trange->scan_capa = IW_SCAN_CAPA_ESSID | IW_SCAN_CAPA_TYPE;\n\n\tIPW_DEBUG_WX(\"GET Range\\n\");\n\treturn 0;\n}\n\nstatic int ipw_wx_set_wap(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\n\tif (wrqu->ap_addr.sa_family != ARPHRD_ETHER)\n\t\treturn -EINVAL;\n\tmutex_lock(&priv->mutex);\n\tif (is_broadcast_ether_addr(wrqu->ap_addr.sa_data) ||\n\t    is_zero_ether_addr(wrqu->ap_addr.sa_data)) {\n\t\t/* we disable mandatory BSSID association */\n\t\tIPW_DEBUG_WX(\"Setting AP BSSID to ANY\\n\");\n\t\tpriv->config &= ~CFG_STATIC_BSSID;\n\t\tIPW_DEBUG_ASSOC(\"Attempting to associate with new \"\n\t\t\t\t\"parameters.\\n\");\n\t\tipw_associate(priv);\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn 0;\n\t}\n\n\tpriv->config |= CFG_STATIC_BSSID;\n\tif (ether_addr_equal(priv->bssid, wrqu->ap_addr.sa_data)) {\n\t\tIPW_DEBUG_WX(\"BSSID set to current BSSID.\\n\");\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn 0;\n\t}\n\n\tIPW_DEBUG_WX(\"Setting mandatory BSSID to %pM\\n\",\n\t\t     wrqu->ap_addr.sa_data);\n\n\tmemcpy(priv->bssid, wrqu->ap_addr.sa_data, ETH_ALEN);\n\n\t/* Network configuration changed -- force [re]association */\n\tIPW_DEBUG_ASSOC(\"[re]association triggered due to BSSID change.\\n\");\n\tif (!ipw_disassociate(priv))\n\t\tipw_associate(priv);\n\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_wap(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\n\t/* If we are associated, trying to associate, or have a statically\n\t * configured BSSID then return that; otherwise return ANY */\n\tmutex_lock(&priv->mutex);\n\tif (priv->config & CFG_STATIC_BSSID ||\n\t    priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)) {\n\t\twrqu->ap_addr.sa_family = ARPHRD_ETHER;\n\t\tmemcpy(wrqu->ap_addr.sa_data, priv->bssid, ETH_ALEN);\n\t} else\n\t\teth_zero_addr(wrqu->ap_addr.sa_data);\n\n\tIPW_DEBUG_WX(\"Getting WAP BSSID: %pM\\n\",\n\t\t     wrqu->ap_addr.sa_data);\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_set_essid(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n        int length;\n\n        mutex_lock(&priv->mutex);\n\n        if (!wrqu->essid.flags)\n        {\n                IPW_DEBUG_WX(\"Setting ESSID to ANY\\n\");\n                ipw_disassociate(priv);\n                priv->config &= ~CFG_STATIC_ESSID;\n                ipw_associate(priv);\n                mutex_unlock(&priv->mutex);\n                return 0;\n        }\n\n\tlength = min((int)wrqu->essid.length, IW_ESSID_MAX_SIZE);\n\n\tpriv->config |= CFG_STATIC_ESSID;\n\n\tif (priv->essid_len == length && !memcmp(priv->essid, extra, length)\n\t    && (priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING))) {\n\t\tIPW_DEBUG_WX(\"ESSID set to current ESSID.\\n\");\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn 0;\n\t}\n\n\tIPW_DEBUG_WX(\"Setting ESSID: '%*pE' (%d)\\n\", length, extra, length);\n\n\tpriv->essid_len = length;\n\tmemcpy(priv->essid, extra, priv->essid_len);\n\n\t/* Network configuration changed -- force [re]association */\n\tIPW_DEBUG_ASSOC(\"[re]association triggered due to ESSID change.\\n\");\n\tif (!ipw_disassociate(priv))\n\t\tipw_associate(priv);\n\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_essid(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\n\t/* If we are associated, trying to associate, or have a statically\n\t * configured ESSID then return that; otherwise return ANY */\n\tmutex_lock(&priv->mutex);\n\tif (priv->config & CFG_STATIC_ESSID ||\n\t    priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)) {\n\t\tIPW_DEBUG_WX(\"Getting essid: '%*pE'\\n\",\n\t\t\t     priv->essid_len, priv->essid);\n\t\tmemcpy(extra, priv->essid, priv->essid_len);\n\t\twrqu->essid.length = priv->essid_len;\n\t\twrqu->essid.flags = 1;\t/* active */\n\t} else {\n\t\tIPW_DEBUG_WX(\"Getting essid: ANY\\n\");\n\t\twrqu->essid.length = 0;\n\t\twrqu->essid.flags = 0;\t/* active */\n\t}\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_set_nick(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\n\tIPW_DEBUG_WX(\"Setting nick to '%s'\\n\", extra);\n\tif (wrqu->data.length > IW_ESSID_MAX_SIZE)\n\t\treturn -E2BIG;\n\tmutex_lock(&priv->mutex);\n\twrqu->data.length = min_t(size_t, wrqu->data.length, sizeof(priv->nick));\n\tmemset(priv->nick, 0, sizeof(priv->nick));\n\tmemcpy(priv->nick, extra, wrqu->data.length);\n\tIPW_DEBUG_TRACE(\"<<\\n\");\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n\n}\n\nstatic int ipw_wx_get_nick(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tIPW_DEBUG_WX(\"Getting nick\\n\");\n\tmutex_lock(&priv->mutex);\n\twrqu->data.length = strlen(priv->nick);\n\tmemcpy(extra, priv->nick, wrqu->data.length);\n\twrqu->data.flags = 1;\t/* active */\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_set_sens(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint err = 0;\n\n\tIPW_DEBUG_WX(\"Setting roaming threshold to %d\\n\", wrqu->sens.value);\n\tIPW_DEBUG_WX(\"Setting disassociate threshold to %d\\n\", 3*wrqu->sens.value);\n\tmutex_lock(&priv->mutex);\n\n\tif (wrqu->sens.fixed == 0)\n\t{\n\t\tpriv->roaming_threshold = IPW_MB_ROAMING_THRESHOLD_DEFAULT;\n\t\tpriv->disassociate_threshold = IPW_MB_DISASSOCIATE_THRESHOLD_DEFAULT;\n\t\tgoto out;\n\t}\n\tif ((wrqu->sens.value > IPW_MB_ROAMING_THRESHOLD_MAX) ||\n\t    (wrqu->sens.value < IPW_MB_ROAMING_THRESHOLD_MIN)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpriv->roaming_threshold = wrqu->sens.value;\n\tpriv->disassociate_threshold = 3*wrqu->sens.value;\n      out:\n\tmutex_unlock(&priv->mutex);\n\treturn err;\n}\n\nstatic int ipw_wx_get_sens(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\twrqu->sens.fixed = 1;\n\twrqu->sens.value = priv->roaming_threshold;\n\tmutex_unlock(&priv->mutex);\n\n\tIPW_DEBUG_WX(\"GET roaming threshold -> %s %d\\n\",\n\t\t     wrqu->power.disabled ? \"OFF\" : \"ON\", wrqu->power.value);\n\n\treturn 0;\n}\n\nstatic int ipw_wx_set_rate(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\t/* TODO: We should use semaphores or locks for access to priv */\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tu32 target_rate = wrqu->bitrate.value;\n\tu32 fixed, mask;\n\n\t/* value = -1, fixed = 0 means auto only, so we should use all rates offered by AP */\n\t/* value = X, fixed = 1 means only rate X */\n\t/* value = X, fixed = 0 means all rates lower equal X */\n\n\tif (target_rate == -1) {\n\t\tfixed = 0;\n\t\tmask = LIBIPW_DEFAULT_RATES_MASK;\n\t\t/* Now we should reassociate */\n\t\tgoto apply;\n\t}\n\n\tmask = 0;\n\tfixed = wrqu->bitrate.fixed;\n\n\tif (target_rate == 1000000 || !fixed)\n\t\tmask |= LIBIPW_CCK_RATE_1MB_MASK;\n\tif (target_rate == 1000000)\n\t\tgoto apply;\n\n\tif (target_rate == 2000000 || !fixed)\n\t\tmask |= LIBIPW_CCK_RATE_2MB_MASK;\n\tif (target_rate == 2000000)\n\t\tgoto apply;\n\n\tif (target_rate == 5500000 || !fixed)\n\t\tmask |= LIBIPW_CCK_RATE_5MB_MASK;\n\tif (target_rate == 5500000)\n\t\tgoto apply;\n\n\tif (target_rate == 6000000 || !fixed)\n\t\tmask |= LIBIPW_OFDM_RATE_6MB_MASK;\n\tif (target_rate == 6000000)\n\t\tgoto apply;\n\n\tif (target_rate == 9000000 || !fixed)\n\t\tmask |= LIBIPW_OFDM_RATE_9MB_MASK;\n\tif (target_rate == 9000000)\n\t\tgoto apply;\n\n\tif (target_rate == 11000000 || !fixed)\n\t\tmask |= LIBIPW_CCK_RATE_11MB_MASK;\n\tif (target_rate == 11000000)\n\t\tgoto apply;\n\n\tif (target_rate == 12000000 || !fixed)\n\t\tmask |= LIBIPW_OFDM_RATE_12MB_MASK;\n\tif (target_rate == 12000000)\n\t\tgoto apply;\n\n\tif (target_rate == 18000000 || !fixed)\n\t\tmask |= LIBIPW_OFDM_RATE_18MB_MASK;\n\tif (target_rate == 18000000)\n\t\tgoto apply;\n\n\tif (target_rate == 24000000 || !fixed)\n\t\tmask |= LIBIPW_OFDM_RATE_24MB_MASK;\n\tif (target_rate == 24000000)\n\t\tgoto apply;\n\n\tif (target_rate == 36000000 || !fixed)\n\t\tmask |= LIBIPW_OFDM_RATE_36MB_MASK;\n\tif (target_rate == 36000000)\n\t\tgoto apply;\n\n\tif (target_rate == 48000000 || !fixed)\n\t\tmask |= LIBIPW_OFDM_RATE_48MB_MASK;\n\tif (target_rate == 48000000)\n\t\tgoto apply;\n\n\tif (target_rate == 54000000 || !fixed)\n\t\tmask |= LIBIPW_OFDM_RATE_54MB_MASK;\n\tif (target_rate == 54000000)\n\t\tgoto apply;\n\n\tIPW_DEBUG_WX(\"invalid rate specified, returning error\\n\");\n\treturn -EINVAL;\n\n      apply:\n\tIPW_DEBUG_WX(\"Setting rate mask to 0x%08X [%s]\\n\",\n\t\t     mask, fixed ? \"fixed\" : \"sub-rates\");\n\tmutex_lock(&priv->mutex);\n\tif (mask == LIBIPW_DEFAULT_RATES_MASK) {\n\t\tpriv->config &= ~CFG_FIXED_RATE;\n\t\tipw_set_fixed_rate(priv, priv->ieee->mode);\n\t} else\n\t\tpriv->config |= CFG_FIXED_RATE;\n\n\tif (priv->rates_mask == mask) {\n\t\tIPW_DEBUG_WX(\"Mask set to current mask.\\n\");\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn 0;\n\t}\n\n\tpriv->rates_mask = mask;\n\n\t/* Network configuration changed -- force [re]association */\n\tIPW_DEBUG_ASSOC(\"[re]association triggered due to rates change.\\n\");\n\tif (!ipw_disassociate(priv))\n\t\tipw_associate(priv);\n\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_rate(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\twrqu->bitrate.value = priv->last_rate;\n\twrqu->bitrate.fixed = (priv->config & CFG_FIXED_RATE) ? 1 : 0;\n\tmutex_unlock(&priv->mutex);\n\tIPW_DEBUG_WX(\"GET Rate -> %d\\n\", wrqu->bitrate.value);\n\treturn 0;\n}\n\nstatic int ipw_wx_set_rts(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\tif (wrqu->rts.disabled || !wrqu->rts.fixed)\n\t\tpriv->rts_threshold = DEFAULT_RTS_THRESHOLD;\n\telse {\n\t\tif (wrqu->rts.value < MIN_RTS_THRESHOLD ||\n\t\t    wrqu->rts.value > MAX_RTS_THRESHOLD) {\n\t\t\tmutex_unlock(&priv->mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->rts_threshold = wrqu->rts.value;\n\t}\n\n\tipw_send_rts_threshold(priv, priv->rts_threshold);\n\tmutex_unlock(&priv->mutex);\n\tIPW_DEBUG_WX(\"SET RTS Threshold -> %d\\n\", priv->rts_threshold);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_rts(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\twrqu->rts.value = priv->rts_threshold;\n\twrqu->rts.fixed = 0;\t/* no auto select */\n\twrqu->rts.disabled = (wrqu->rts.value == DEFAULT_RTS_THRESHOLD);\n\tmutex_unlock(&priv->mutex);\n\tIPW_DEBUG_WX(\"GET RTS Threshold -> %d\\n\", wrqu->rts.value);\n\treturn 0;\n}\n\nstatic int ipw_wx_set_txpow(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint err = 0;\n\n\tmutex_lock(&priv->mutex);\n\tif (ipw_radio_kill_sw(priv, wrqu->power.disabled)) {\n\t\terr = -EINPROGRESS;\n\t\tgoto out;\n\t}\n\n\tif (!wrqu->power.fixed)\n\t\twrqu->power.value = IPW_TX_POWER_DEFAULT;\n\n\tif (wrqu->power.flags != IW_TXPOW_DBM) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((wrqu->power.value > IPW_TX_POWER_MAX) ||\n\t    (wrqu->power.value < IPW_TX_POWER_MIN)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpriv->tx_power = wrqu->power.value;\n\terr = ipw_set_tx_power(priv);\n      out:\n\tmutex_unlock(&priv->mutex);\n\treturn err;\n}\n\nstatic int ipw_wx_get_txpow(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\twrqu->power.value = priv->tx_power;\n\twrqu->power.fixed = 1;\n\twrqu->power.flags = IW_TXPOW_DBM;\n\twrqu->power.disabled = (priv->status & STATUS_RF_KILL_MASK) ? 1 : 0;\n\tmutex_unlock(&priv->mutex);\n\n\tIPW_DEBUG_WX(\"GET TX Power -> %s %d\\n\",\n\t\t     wrqu->power.disabled ? \"OFF\" : \"ON\", wrqu->power.value);\n\n\treturn 0;\n}\n\nstatic int ipw_wx_set_frag(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\tif (wrqu->frag.disabled || !wrqu->frag.fixed)\n\t\tpriv->ieee->fts = DEFAULT_FTS;\n\telse {\n\t\tif (wrqu->frag.value < MIN_FRAG_THRESHOLD ||\n\t\t    wrqu->frag.value > MAX_FRAG_THRESHOLD) {\n\t\t\tmutex_unlock(&priv->mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpriv->ieee->fts = wrqu->frag.value & ~0x1;\n\t}\n\n\tipw_send_frag_threshold(priv, wrqu->frag.value);\n\tmutex_unlock(&priv->mutex);\n\tIPW_DEBUG_WX(\"SET Frag Threshold -> %d\\n\", wrqu->frag.value);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_frag(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\twrqu->frag.value = priv->ieee->fts;\n\twrqu->frag.fixed = 0;\t/* no auto select */\n\twrqu->frag.disabled = (wrqu->frag.value == DEFAULT_FTS);\n\tmutex_unlock(&priv->mutex);\n\tIPW_DEBUG_WX(\"GET Frag Threshold -> %d\\n\", wrqu->frag.value);\n\n\treturn 0;\n}\n\nstatic int ipw_wx_set_retry(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\n\tif (wrqu->retry.flags & IW_RETRY_LIFETIME || wrqu->retry.disabled)\n\t\treturn -EINVAL;\n\n\tif (!(wrqu->retry.flags & IW_RETRY_LIMIT))\n\t\treturn 0;\n\n\tif (wrqu->retry.value < 0 || wrqu->retry.value >= 255)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->mutex);\n\tif (wrqu->retry.flags & IW_RETRY_SHORT)\n\t\tpriv->short_retry_limit = (u8) wrqu->retry.value;\n\telse if (wrqu->retry.flags & IW_RETRY_LONG)\n\t\tpriv->long_retry_limit = (u8) wrqu->retry.value;\n\telse {\n\t\tpriv->short_retry_limit = (u8) wrqu->retry.value;\n\t\tpriv->long_retry_limit = (u8) wrqu->retry.value;\n\t}\n\n\tipw_send_retry_limit(priv, priv->short_retry_limit,\n\t\t\t     priv->long_retry_limit);\n\tmutex_unlock(&priv->mutex);\n\tIPW_DEBUG_WX(\"SET retry limit -> short:%d long:%d\\n\",\n\t\t     priv->short_retry_limit, priv->long_retry_limit);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_retry(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\n\tmutex_lock(&priv->mutex);\n\twrqu->retry.disabled = 0;\n\n\tif ((wrqu->retry.flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME) {\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tif (wrqu->retry.flags & IW_RETRY_LONG) {\n\t\twrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\n\t\twrqu->retry.value = priv->long_retry_limit;\n\t} else if (wrqu->retry.flags & IW_RETRY_SHORT) {\n\t\twrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_SHORT;\n\t\twrqu->retry.value = priv->short_retry_limit;\n\t} else {\n\t\twrqu->retry.flags = IW_RETRY_LIMIT;\n\t\twrqu->retry.value = priv->short_retry_limit;\n\t}\n\tmutex_unlock(&priv->mutex);\n\n\tIPW_DEBUG_WX(\"GET retry -> %d\\n\", wrqu->retry.value);\n\n\treturn 0;\n}\n\nstatic int ipw_wx_set_scan(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct iw_scan_req *req = (struct iw_scan_req *)extra;\n\tstruct delayed_work *work = NULL;\n\n\tmutex_lock(&priv->mutex);\n\n\tpriv->user_requested_scan = 1;\n\n\tif (wrqu->data.length == sizeof(struct iw_scan_req)) {\n\t\tif (wrqu->data.flags & IW_SCAN_THIS_ESSID) {\n\t\t\tint len = min((int)req->essid_len,\n\t\t\t              (int)sizeof(priv->direct_scan_ssid));\n\t\t\tmemcpy(priv->direct_scan_ssid, req->essid, len);\n\t\t\tpriv->direct_scan_ssid_len = len;\n\t\t\twork = &priv->request_direct_scan;\n\t\t} else if (req->scan_type == IW_SCAN_TYPE_PASSIVE) {\n\t\t\twork = &priv->request_passive_scan;\n\t\t}\n\t} else {\n\t\t/* Normal active broadcast scan */\n\t\twork = &priv->request_scan;\n\t}\n\n\tmutex_unlock(&priv->mutex);\n\n\tIPW_DEBUG_WX(\"Start scan\\n\");\n\n\tschedule_delayed_work(work, 0);\n\n\treturn 0;\n}\n\nstatic int ipw_wx_get_scan(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\treturn libipw_wx_get_scan(priv->ieee, info, wrqu, extra);\n}\n\nstatic int ipw_wx_set_encode(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *key)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint ret;\n\tu32 cap = priv->capability;\n\n\tmutex_lock(&priv->mutex);\n\tret = libipw_wx_set_encode(priv->ieee, info, wrqu, key);\n\n\t/* In IBSS mode, we need to notify the firmware to update\n\t * the beacon info after we changed the capability. */\n\tif (cap != priv->capability &&\n\t    priv->ieee->iw_mode == IW_MODE_ADHOC &&\n\t    priv->status & STATUS_ASSOCIATED)\n\t\tipw_disassociate(priv);\n\n\tmutex_unlock(&priv->mutex);\n\treturn ret;\n}\n\nstatic int ipw_wx_get_encode(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *key)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\treturn libipw_wx_get_encode(priv->ieee, info, wrqu, key);\n}\n\nstatic int ipw_wx_set_power(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint err;\n\tmutex_lock(&priv->mutex);\n\tif (wrqu->power.disabled) {\n\t\tpriv->power_mode = IPW_POWER_LEVEL(priv->power_mode);\n\t\terr = ipw_send_power_mode(priv, IPW_POWER_MODE_CAM);\n\t\tif (err) {\n\t\t\tIPW_DEBUG_WX(\"failed setting power mode.\\n\");\n\t\t\tmutex_unlock(&priv->mutex);\n\t\t\treturn err;\n\t\t}\n\t\tIPW_DEBUG_WX(\"SET Power Management Mode -> off\\n\");\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn 0;\n\t}\n\n\tswitch (wrqu->power.flags & IW_POWER_MODE) {\n\tcase IW_POWER_ON:\t/* If not specified */\n\tcase IW_POWER_MODE:\t/* If set all mask */\n\tcase IW_POWER_ALL_R:\t/* If explicitly state all */\n\t\tbreak;\n\tdefault:\t\t/* Otherwise we don't support it */\n\t\tIPW_DEBUG_WX(\"SET PM Mode: %X not supported.\\n\",\n\t\t\t     wrqu->power.flags);\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* If the user hasn't specified a power management mode yet, default\n\t * to BATTERY */\n\tif (IPW_POWER_LEVEL(priv->power_mode) == IPW_POWER_AC)\n\t\tpriv->power_mode = IPW_POWER_ENABLED | IPW_POWER_BATTERY;\n\telse\n\t\tpriv->power_mode = IPW_POWER_ENABLED | priv->power_mode;\n\n\terr = ipw_send_power_mode(priv, IPW_POWER_LEVEL(priv->power_mode));\n\tif (err) {\n\t\tIPW_DEBUG_WX(\"failed setting power mode.\\n\");\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn err;\n\t}\n\n\tIPW_DEBUG_WX(\"SET Power Management Mode -> 0x%02X\\n\", priv->power_mode);\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_power(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\tif (!(priv->power_mode & IPW_POWER_ENABLED))\n\t\twrqu->power.disabled = 1;\n\telse\n\t\twrqu->power.disabled = 0;\n\n\tmutex_unlock(&priv->mutex);\n\tIPW_DEBUG_WX(\"GET Power Management Mode -> %02X\\n\", priv->power_mode);\n\n\treturn 0;\n}\n\nstatic int ipw_wx_set_powermode(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint mode = *(int *)extra;\n\tint err;\n\n\tmutex_lock(&priv->mutex);\n\tif ((mode < 1) || (mode > IPW_POWER_LIMIT))\n\t\tmode = IPW_POWER_AC;\n\n\tif (IPW_POWER_LEVEL(priv->power_mode) != mode) {\n\t\terr = ipw_send_power_mode(priv, mode);\n\t\tif (err) {\n\t\t\tIPW_DEBUG_WX(\"failed setting power mode.\\n\");\n\t\t\tmutex_unlock(&priv->mutex);\n\t\t\treturn err;\n\t\t}\n\t\tpriv->power_mode = IPW_POWER_ENABLED | mode;\n\t}\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\n#define MAX_WX_STRING 80\nstatic int ipw_wx_get_powermode(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint level = IPW_POWER_LEVEL(priv->power_mode);\n\tchar *p = extra;\n\n\tp += scnprintf(p, MAX_WX_STRING, \"Power save level: %d \", level);\n\n\tswitch (level) {\n\tcase IPW_POWER_AC:\n\t\tp += scnprintf(p, MAX_WX_STRING - (p - extra), \"(AC)\");\n\t\tbreak;\n\tcase IPW_POWER_BATTERY:\n\t\tp += scnprintf(p, MAX_WX_STRING - (p - extra), \"(BATTERY)\");\n\t\tbreak;\n\tdefault:\n\t\tp += scnprintf(p, MAX_WX_STRING - (p - extra),\n\t\t\t      \"(Timeout %dms, Period %dms)\",\n\t\t\t      timeout_duration[level - 1] / 1000,\n\t\t\t      period_duration[level - 1] / 1000);\n\t}\n\n\tif (!(priv->power_mode & IPW_POWER_ENABLED))\n\t\tp += scnprintf(p, MAX_WX_STRING - (p - extra), \" OFF\");\n\n\twrqu->data.length = p - extra + 1;\n\n\treturn 0;\n}\n\nstatic int ipw_wx_set_wireless_mode(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint mode = *(int *)extra;\n\tu8 band = 0, modulation = 0;\n\n\tif (mode == 0 || mode & ~IEEE_MODE_MASK) {\n\t\tIPW_WARNING(\"Attempt to set invalid wireless mode: %d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&priv->mutex);\n\tif (priv->adapter == IPW_2915ABG) {\n\t\tpriv->ieee->abg_true = 1;\n\t\tif (mode & IEEE_A) {\n\t\t\tband |= LIBIPW_52GHZ_BAND;\n\t\t\tmodulation |= LIBIPW_OFDM_MODULATION;\n\t\t} else\n\t\t\tpriv->ieee->abg_true = 0;\n\t} else {\n\t\tif (mode & IEEE_A) {\n\t\t\tIPW_WARNING(\"Attempt to set 2200BG into \"\n\t\t\t\t    \"802.11a mode\\n\");\n\t\t\tmutex_unlock(&priv->mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpriv->ieee->abg_true = 0;\n\t}\n\n\tif (mode & IEEE_B) {\n\t\tband |= LIBIPW_24GHZ_BAND;\n\t\tmodulation |= LIBIPW_CCK_MODULATION;\n\t} else\n\t\tpriv->ieee->abg_true = 0;\n\n\tif (mode & IEEE_G) {\n\t\tband |= LIBIPW_24GHZ_BAND;\n\t\tmodulation |= LIBIPW_OFDM_MODULATION;\n\t} else\n\t\tpriv->ieee->abg_true = 0;\n\n\tpriv->ieee->mode = mode;\n\tpriv->ieee->freq_band = band;\n\tpriv->ieee->modulation = modulation;\n\tinit_supported_rates(priv, &priv->rates);\n\n\t/* Network configuration changed -- force [re]association */\n\tIPW_DEBUG_ASSOC(\"[re]association triggered due to mode change.\\n\");\n\tif (!ipw_disassociate(priv)) {\n\t\tipw_send_supported_rates(priv, &priv->rates);\n\t\tipw_associate(priv);\n\t}\n\n\t/* Update the band LEDs */\n\tipw_led_band_on(priv);\n\n\tIPW_DEBUG_WX(\"PRIV SET MODE: %c%c%c\\n\",\n\t\t     mode & IEEE_A ? 'a' : '.',\n\t\t     mode & IEEE_B ? 'b' : '.', mode & IEEE_G ? 'g' : '.');\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_wireless_mode(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\tswitch (priv->ieee->mode) {\n\tcase IEEE_A:\n\t\tstrncpy(extra, \"802.11a (1)\", MAX_WX_STRING);\n\t\tbreak;\n\tcase IEEE_B:\n\t\tstrncpy(extra, \"802.11b (2)\", MAX_WX_STRING);\n\t\tbreak;\n\tcase IEEE_A | IEEE_B:\n\t\tstrncpy(extra, \"802.11ab (3)\", MAX_WX_STRING);\n\t\tbreak;\n\tcase IEEE_G:\n\t\tstrncpy(extra, \"802.11g (4)\", MAX_WX_STRING);\n\t\tbreak;\n\tcase IEEE_A | IEEE_G:\n\t\tstrncpy(extra, \"802.11ag (5)\", MAX_WX_STRING);\n\t\tbreak;\n\tcase IEEE_B | IEEE_G:\n\t\tstrncpy(extra, \"802.11bg (6)\", MAX_WX_STRING);\n\t\tbreak;\n\tcase IEEE_A | IEEE_B | IEEE_G:\n\t\tstrncpy(extra, \"802.11abg (7)\", MAX_WX_STRING);\n\t\tbreak;\n\tdefault:\n\t\tstrncpy(extra, \"unknown\", MAX_WX_STRING);\n\t\tbreak;\n\t}\n\textra[MAX_WX_STRING - 1] = '\\0';\n\n\tIPW_DEBUG_WX(\"PRIV GET MODE: %s\\n\", extra);\n\n\twrqu->data.length = strlen(extra) + 1;\n\tmutex_unlock(&priv->mutex);\n\n\treturn 0;\n}\n\nstatic int ipw_wx_set_preamble(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint mode = *(int *)extra;\n\tmutex_lock(&priv->mutex);\n\t/* Switching from SHORT -> LONG requires a disassociation */\n\tif (mode == 1) {\n\t\tif (!(priv->config & CFG_PREAMBLE_LONG)) {\n\t\t\tpriv->config |= CFG_PREAMBLE_LONG;\n\n\t\t\t/* Network configuration changed -- force [re]association */\n\t\t\tIPW_DEBUG_ASSOC\n\t\t\t    (\"[re]association triggered due to preamble change.\\n\");\n\t\t\tif (!ipw_disassociate(priv))\n\t\t\t\tipw_associate(priv);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tif (mode == 0) {\n\t\tpriv->config &= ~CFG_PREAMBLE_LONG;\n\t\tgoto done;\n\t}\n\tmutex_unlock(&priv->mutex);\n\treturn -EINVAL;\n\n      done:\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_preamble(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\tif (priv->config & CFG_PREAMBLE_LONG)\n\t\tsnprintf(wrqu->name, IFNAMSIZ, \"long (1)\");\n\telse\n\t\tsnprintf(wrqu->name, IFNAMSIZ, \"auto (0)\");\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\n#ifdef CONFIG_IPW2200_MONITOR\nstatic int ipw_wx_set_monitor(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint *parms = (int *)extra;\n\tint enable = (parms[0] > 0);\n\tmutex_lock(&priv->mutex);\n\tIPW_DEBUG_WX(\"SET MONITOR: %d %d\\n\", enable, parms[1]);\n\tif (enable) {\n\t\tif (priv->ieee->iw_mode != IW_MODE_MONITOR) {\n#ifdef CONFIG_IPW2200_RADIOTAP\n\t\t\tpriv->net_dev->type = ARPHRD_IEEE80211_RADIOTAP;\n#else\n\t\t\tpriv->net_dev->type = ARPHRD_IEEE80211;\n#endif\n\t\t\tschedule_work(&priv->adapter_restart);\n\t\t}\n\n\t\tipw_set_channel(priv, parms[1]);\n\t} else {\n\t\tif (priv->ieee->iw_mode != IW_MODE_MONITOR) {\n\t\t\tmutex_unlock(&priv->mutex);\n\t\t\treturn 0;\n\t\t}\n\t\tpriv->net_dev->type = ARPHRD_ETHER;\n\t\tschedule_work(&priv->adapter_restart);\n\t}\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\n#endif\t\t\t\t/* CONFIG_IPW2200_MONITOR */\n\nstatic int ipw_wx_reset(struct net_device *dev,\n\t\t\tstruct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tIPW_DEBUG_WX(\"RESET\\n\");\n\tschedule_work(&priv->adapter_restart);\n\treturn 0;\n}\n\nstatic int ipw_wx_sw_reset(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tunion iwreq_data wrqu_sec = {\n\t\t.encoding = {\n\t\t\t     .flags = IW_ENCODE_DISABLED,\n\t\t\t     },\n\t};\n\tint ret;\n\n\tIPW_DEBUG_WX(\"SW_RESET\\n\");\n\n\tmutex_lock(&priv->mutex);\n\n\tret = ipw_sw_reset(priv, 2);\n\tif (!ret) {\n\t\tfree_firmware();\n\t\tipw_adapter_restart(priv);\n\t}\n\n\t/* The SW reset bit might have been toggled on by the 'disable'\n\t * module parameter, so take appropriate action */\n\tipw_radio_kill_sw(priv, priv->status & STATUS_RF_KILL_SW);\n\n\tmutex_unlock(&priv->mutex);\n\tlibipw_wx_set_encode(priv->ieee, info, &wrqu_sec, NULL);\n\tmutex_lock(&priv->mutex);\n\n\tif (!(priv->status & STATUS_RF_KILL_MASK)) {\n\t\t/* Configuration likely changed -- force [re]association */\n\t\tIPW_DEBUG_ASSOC(\"[re]association triggered due to sw \"\n\t\t\t\t\"reset.\\n\");\n\t\tif (!ipw_disassociate(priv))\n\t\t\tipw_associate(priv);\n\t}\n\n\tmutex_unlock(&priv->mutex);\n\n\treturn 0;\n}\n\n/* Rebase the WE IOCTLs to zero for the handler array */\nstatic iw_handler ipw_wx_handlers[] = {\n\tIW_HANDLER(SIOCGIWNAME, (iw_handler)cfg80211_wext_giwname),\n\tIW_HANDLER(SIOCSIWFREQ, ipw_wx_set_freq),\n\tIW_HANDLER(SIOCGIWFREQ, ipw_wx_get_freq),\n\tIW_HANDLER(SIOCSIWMODE, ipw_wx_set_mode),\n\tIW_HANDLER(SIOCGIWMODE, ipw_wx_get_mode),\n\tIW_HANDLER(SIOCSIWSENS, ipw_wx_set_sens),\n\tIW_HANDLER(SIOCGIWSENS, ipw_wx_get_sens),\n\tIW_HANDLER(SIOCGIWRANGE, ipw_wx_get_range),\n\tIW_HANDLER(SIOCSIWAP, ipw_wx_set_wap),\n\tIW_HANDLER(SIOCGIWAP, ipw_wx_get_wap),\n\tIW_HANDLER(SIOCSIWSCAN, ipw_wx_set_scan),\n\tIW_HANDLER(SIOCGIWSCAN, ipw_wx_get_scan),\n\tIW_HANDLER(SIOCSIWESSID, ipw_wx_set_essid),\n\tIW_HANDLER(SIOCGIWESSID, ipw_wx_get_essid),\n\tIW_HANDLER(SIOCSIWNICKN, ipw_wx_set_nick),\n\tIW_HANDLER(SIOCGIWNICKN, ipw_wx_get_nick),\n\tIW_HANDLER(SIOCSIWRATE, ipw_wx_set_rate),\n\tIW_HANDLER(SIOCGIWRATE, ipw_wx_get_rate),\n\tIW_HANDLER(SIOCSIWRTS, ipw_wx_set_rts),\n\tIW_HANDLER(SIOCGIWRTS, ipw_wx_get_rts),\n\tIW_HANDLER(SIOCSIWFRAG, ipw_wx_set_frag),\n\tIW_HANDLER(SIOCGIWFRAG, ipw_wx_get_frag),\n\tIW_HANDLER(SIOCSIWTXPOW, ipw_wx_set_txpow),\n\tIW_HANDLER(SIOCGIWTXPOW, ipw_wx_get_txpow),\n\tIW_HANDLER(SIOCSIWRETRY, ipw_wx_set_retry),\n\tIW_HANDLER(SIOCGIWRETRY, ipw_wx_get_retry),\n\tIW_HANDLER(SIOCSIWENCODE, ipw_wx_set_encode),\n\tIW_HANDLER(SIOCGIWENCODE, ipw_wx_get_encode),\n\tIW_HANDLER(SIOCSIWPOWER, ipw_wx_set_power),\n\tIW_HANDLER(SIOCGIWPOWER, ipw_wx_get_power),\n\tIW_HANDLER(SIOCSIWSPY, iw_handler_set_spy),\n\tIW_HANDLER(SIOCGIWSPY, iw_handler_get_spy),\n\tIW_HANDLER(SIOCSIWTHRSPY, iw_handler_set_thrspy),\n\tIW_HANDLER(SIOCGIWTHRSPY, iw_handler_get_thrspy),\n\tIW_HANDLER(SIOCSIWGENIE, ipw_wx_set_genie),\n\tIW_HANDLER(SIOCGIWGENIE, ipw_wx_get_genie),\n\tIW_HANDLER(SIOCSIWMLME, ipw_wx_set_mlme),\n\tIW_HANDLER(SIOCSIWAUTH, ipw_wx_set_auth),\n\tIW_HANDLER(SIOCGIWAUTH, ipw_wx_get_auth),\n\tIW_HANDLER(SIOCSIWENCODEEXT, ipw_wx_set_encodeext),\n\tIW_HANDLER(SIOCGIWENCODEEXT, ipw_wx_get_encodeext),\n};\n\nenum {\n\tIPW_PRIV_SET_POWER = SIOCIWFIRSTPRIV,\n\tIPW_PRIV_GET_POWER,\n\tIPW_PRIV_SET_MODE,\n\tIPW_PRIV_GET_MODE,\n\tIPW_PRIV_SET_PREAMBLE,\n\tIPW_PRIV_GET_PREAMBLE,\n\tIPW_PRIV_RESET,\n\tIPW_PRIV_SW_RESET,\n#ifdef CONFIG_IPW2200_MONITOR\n\tIPW_PRIV_SET_MONITOR,\n#endif\n};\n\nstatic struct iw_priv_args ipw_priv_args[] = {\n\t{\n\t .cmd = IPW_PRIV_SET_POWER,\n\t .set_args = IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t .name = \"set_power\"},\n\t{\n\t .cmd = IPW_PRIV_GET_POWER,\n\t .get_args = IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | MAX_WX_STRING,\n\t .name = \"get_power\"},\n\t{\n\t .cmd = IPW_PRIV_SET_MODE,\n\t .set_args = IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t .name = \"set_mode\"},\n\t{\n\t .cmd = IPW_PRIV_GET_MODE,\n\t .get_args = IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | MAX_WX_STRING,\n\t .name = \"get_mode\"},\n\t{\n\t .cmd = IPW_PRIV_SET_PREAMBLE,\n\t .set_args = IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t .name = \"set_preamble\"},\n\t{\n\t .cmd = IPW_PRIV_GET_PREAMBLE,\n\t .get_args = IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ,\n\t .name = \"get_preamble\"},\n\t{\n\t IPW_PRIV_RESET,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 0, 0, \"reset\"},\n\t{\n\t IPW_PRIV_SW_RESET,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 0, 0, \"sw_reset\"},\n#ifdef CONFIG_IPW2200_MONITOR\n\t{\n\t IPW_PRIV_SET_MONITOR,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, \"monitor\"},\n#endif\t\t\t\t/* CONFIG_IPW2200_MONITOR */\n};\n\nstatic iw_handler ipw_priv_handler[] = {\n\tipw_wx_set_powermode,\n\tipw_wx_get_powermode,\n\tipw_wx_set_wireless_mode,\n\tipw_wx_get_wireless_mode,\n\tipw_wx_set_preamble,\n\tipw_wx_get_preamble,\n\tipw_wx_reset,\n\tipw_wx_sw_reset,\n#ifdef CONFIG_IPW2200_MONITOR\n\tipw_wx_set_monitor,\n#endif\n};\n\nstatic const struct iw_handler_def ipw_wx_handler_def = {\n\t.standard = ipw_wx_handlers,\n\t.num_standard = ARRAY_SIZE(ipw_wx_handlers),\n\t.num_private = ARRAY_SIZE(ipw_priv_handler),\n\t.num_private_args = ARRAY_SIZE(ipw_priv_args),\n\t.private = ipw_priv_handler,\n\t.private_args = ipw_priv_args,\n\t.get_wireless_stats = ipw_get_wireless_stats,\n};\n\n/*\n * Get wireless statistics.\n * Called by /proc/net/wireless\n * Also called by SIOCGIWSTATS\n */\nstatic struct iw_statistics *ipw_get_wireless_stats(struct net_device *dev)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct iw_statistics *wstats;\n\n\twstats = &priv->wstats;\n\n\t/* if hw is disabled, then ipw_get_ordinal() can't be called.\n\t * netdev->get_wireless_stats seems to be called before fw is\n\t * initialized.  STATUS_ASSOCIATED will only be set if the hw is up\n\t * and associated; if not associcated, the values are all meaningless\n\t * anyway, so set them all to NULL and INVALID */\n\tif (!(priv->status & STATUS_ASSOCIATED)) {\n\t\twstats->miss.beacon = 0;\n\t\twstats->discard.retries = 0;\n\t\twstats->qual.qual = 0;\n\t\twstats->qual.level = 0;\n\t\twstats->qual.noise = 0;\n\t\twstats->qual.updated = 7;\n\t\twstats->qual.updated |= IW_QUAL_NOISE_INVALID |\n\t\t    IW_QUAL_QUAL_INVALID | IW_QUAL_LEVEL_INVALID;\n\t\treturn wstats;\n\t}\n\n\twstats->qual.qual = priv->quality;\n\twstats->qual.level = priv->exp_avg_rssi;\n\twstats->qual.noise = priv->exp_avg_noise;\n\twstats->qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED |\n\t    IW_QUAL_NOISE_UPDATED | IW_QUAL_DBM;\n\n\twstats->miss.beacon = average_value(&priv->average_missed_beacons);\n\twstats->discard.retries = priv->last_tx_failures;\n\twstats->discard.code = priv->ieee->ieee_stats.rx_discards_undecryptable;\n\n/*\tif (ipw_get_ordinal(priv, IPW_ORD_STAT_TX_RETRY, &tx_retry, &len))\n\tgoto fail_get_ordinal;\n\twstats->discard.retries += tx_retry; */\n\n\treturn wstats;\n}\n\n/* net device stuff */\n\nstatic  void init_sys_config(struct ipw_sys_config *sys_config)\n{\n\tmemset(sys_config, 0, sizeof(struct ipw_sys_config));\n\tsys_config->bt_coexistence = 0;\n\tsys_config->answer_broadcast_ssid_probe = 0;\n\tsys_config->accept_all_data_frames = 0;\n\tsys_config->accept_non_directed_frames = 1;\n\tsys_config->exclude_unicast_unencrypted = 0;\n\tsys_config->disable_unicast_decryption = 1;\n\tsys_config->exclude_multicast_unencrypted = 0;\n\tsys_config->disable_multicast_decryption = 1;\n\tif (antenna < CFG_SYS_ANTENNA_BOTH || antenna > CFG_SYS_ANTENNA_B)\n\t\tantenna = CFG_SYS_ANTENNA_BOTH;\n\tsys_config->antenna_diversity = antenna;\n\tsys_config->pass_crc_to_host = 0;\t/* TODO: See if 1 gives us FCS */\n\tsys_config->dot11g_auto_detection = 0;\n\tsys_config->enable_cts_to_self = 0;\n\tsys_config->bt_coexist_collision_thr = 0;\n\tsys_config->pass_noise_stats_to_host = 1;\t/* 1 -- fix for 256 */\n\tsys_config->silence_threshold = 0x1e;\n}\n\nstatic int ipw_net_open(struct net_device *dev)\n{\n\tIPW_DEBUG_INFO(\"dev->open\\n\");\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\nstatic int ipw_net_stop(struct net_device *dev)\n{\n\tIPW_DEBUG_INFO(\"dev->close\\n\");\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\n/*\ntodo:\n\nmodify to send one tfd per fragment instead of using chunking.  otherwise\nwe need to heavily modify the libipw_skb_to_txb.\n*/\n\nstatic int ipw_tx_skb(struct ipw_priv *priv, struct libipw_txb *txb,\n\t\t\t     int pri)\n{\n\tstruct libipw_hdr_3addrqos *hdr = (struct libipw_hdr_3addrqos *)\n\t    txb->fragments[0]->data;\n\tint i = 0;\n\tstruct tfd_frame *tfd;\n#ifdef CONFIG_IPW2200_QOS\n\tint tx_id = ipw_get_tx_queue_number(priv, pri);\n\tstruct clx2_tx_queue *txq = &priv->txq[tx_id];\n#else\n\tstruct clx2_tx_queue *txq = &priv->txq[0];\n#endif\n\tstruct clx2_queue *q = &txq->q;\n\tu8 id, hdr_len, unicast;\n\tint fc;\n\n\tif (!(priv->status & STATUS_ASSOCIATED))\n\t\tgoto drop;\n\n\thdr_len = libipw_get_hdrlen(le16_to_cpu(hdr->frame_ctl));\n\tswitch (priv->ieee->iw_mode) {\n\tcase IW_MODE_ADHOC:\n\t\tunicast = !is_multicast_ether_addr(hdr->addr1);\n\t\tid = ipw_find_station(priv, hdr->addr1);\n\t\tif (id == IPW_INVALID_STATION) {\n\t\t\tid = ipw_add_station(priv, hdr->addr1);\n\t\t\tif (id == IPW_INVALID_STATION) {\n\t\t\t\tIPW_WARNING(\"Attempt to send data to \"\n\t\t\t\t\t    \"invalid cell: %pM\\n\",\n\t\t\t\t\t    hdr->addr1);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IW_MODE_INFRA:\n\tdefault:\n\t\tunicast = !is_multicast_ether_addr(hdr->addr3);\n\t\tid = 0;\n\t\tbreak;\n\t}\n\n\ttfd = &txq->bd[q->first_empty];\n\ttxq->txb[q->first_empty] = txb;\n\tmemset(tfd, 0, sizeof(*tfd));\n\ttfd->u.data.station_number = id;\n\n\ttfd->control_flags.message_type = TX_FRAME_TYPE;\n\ttfd->control_flags.control_bits = TFD_NEED_IRQ_MASK;\n\n\ttfd->u.data.cmd_id = DINO_CMD_TX;\n\ttfd->u.data.len = cpu_to_le16(txb->payload_size);\n\n\tif (priv->assoc_request.ieee_mode == IPW_B_MODE)\n\t\ttfd->u.data.tx_flags_ext |= DCT_FLAG_EXT_MODE_CCK;\n\telse\n\t\ttfd->u.data.tx_flags_ext |= DCT_FLAG_EXT_MODE_OFDM;\n\n\tif (priv->assoc_request.preamble_length == DCT_FLAG_SHORT_PREAMBLE)\n\t\ttfd->u.data.tx_flags |= DCT_FLAG_SHORT_PREAMBLE;\n\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\thdr->frame_ctl = cpu_to_le16(fc & ~IEEE80211_FCTL_MOREFRAGS);\n\n\tmemcpy(&tfd->u.data.tfd.tfd_24.mchdr, hdr, hdr_len);\n\n\tif (likely(unicast))\n\t\ttfd->u.data.tx_flags |= DCT_FLAG_ACK_REQD;\n\n\tif (txb->encrypted && !priv->ieee->host_encrypt) {\n\t\tswitch (priv->ieee->sec.level) {\n\t\tcase SEC_LEVEL_3:\n\t\t\ttfd->u.data.tfd.tfd_24.mchdr.frame_ctl |=\n\t\t\t    cpu_to_le16(IEEE80211_FCTL_PROTECTED);\n\t\t\t/* XXX: ACK flag must be set for CCMP even if it\n\t\t\t * is a multicast/broadcast packet, because CCMP\n\t\t\t * group communication encrypted by GTK is\n\t\t\t * actually done by the AP. */\n\t\t\tif (!unicast)\n\t\t\t\ttfd->u.data.tx_flags |= DCT_FLAG_ACK_REQD;\n\n\t\t\ttfd->u.data.tx_flags &= ~DCT_FLAG_NO_WEP;\n\t\t\ttfd->u.data.tx_flags_ext |= DCT_FLAG_EXT_SECURITY_CCM;\n\t\t\ttfd->u.data.key_index = 0;\n\t\t\ttfd->u.data.key_index |= DCT_WEP_INDEX_USE_IMMEDIATE;\n\t\t\tbreak;\n\t\tcase SEC_LEVEL_2:\n\t\t\ttfd->u.data.tfd.tfd_24.mchdr.frame_ctl |=\n\t\t\t    cpu_to_le16(IEEE80211_FCTL_PROTECTED);\n\t\t\ttfd->u.data.tx_flags &= ~DCT_FLAG_NO_WEP;\n\t\t\ttfd->u.data.tx_flags_ext |= DCT_FLAG_EXT_SECURITY_TKIP;\n\t\t\ttfd->u.data.key_index = DCT_WEP_INDEX_USE_IMMEDIATE;\n\t\t\tbreak;\n\t\tcase SEC_LEVEL_1:\n\t\t\ttfd->u.data.tfd.tfd_24.mchdr.frame_ctl |=\n\t\t\t    cpu_to_le16(IEEE80211_FCTL_PROTECTED);\n\t\t\ttfd->u.data.key_index = priv->ieee->crypt_info.tx_keyidx;\n\t\t\tif (priv->ieee->sec.key_sizes[priv->ieee->crypt_info.tx_keyidx] <=\n\t\t\t    40)\n\t\t\t\ttfd->u.data.key_index |= DCT_WEP_KEY_64Bit;\n\t\t\telse\n\t\t\t\ttfd->u.data.key_index |= DCT_WEP_KEY_128Bit;\n\t\t\tbreak;\n\t\tcase SEC_LEVEL_0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"Unknown security level %d\\n\",\n\t\t\t       priv->ieee->sec.level);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\t/* No hardware encryption */\n\t\ttfd->u.data.tx_flags |= DCT_FLAG_NO_WEP;\n\n#ifdef CONFIG_IPW2200_QOS\n\tif (fc & IEEE80211_STYPE_QOS_DATA)\n\t\tipw_qos_set_tx_queue_command(priv, pri, &(tfd->u.data));\n#endif\t\t\t\t/* CONFIG_IPW2200_QOS */\n\n\t/* payload */\n\ttfd->u.data.num_chunks = cpu_to_le32(min((u8) (NUM_TFD_CHUNKS - 2),\n\t\t\t\t\t\t txb->nr_frags));\n\tIPW_DEBUG_FRAG(\"%i fragments being sent as %i chunks.\\n\",\n\t\t       txb->nr_frags, le32_to_cpu(tfd->u.data.num_chunks));\n\tfor (i = 0; i < le32_to_cpu(tfd->u.data.num_chunks); i++) {\n\t\tIPW_DEBUG_FRAG(\"Adding fragment %i of %i (%d bytes).\\n\",\n\t\t\t       i, le32_to_cpu(tfd->u.data.num_chunks),\n\t\t\t       txb->fragments[i]->len - hdr_len);\n\t\tIPW_DEBUG_TX(\"Dumping TX packet frag %i of %i (%d bytes):\\n\",\n\t\t\t     i, tfd->u.data.num_chunks,\n\t\t\t     txb->fragments[i]->len - hdr_len);\n\t\tprintk_buf(IPW_DL_TX, txb->fragments[i]->data + hdr_len,\n\t\t\t   txb->fragments[i]->len - hdr_len);\n\n\t\ttfd->u.data.chunk_ptr[i] =\n\t\t    cpu_to_le32(dma_map_single(&priv->pci_dev->dev,\n\t\t\t\t\t       txb->fragments[i]->data + hdr_len,\n\t\t\t\t\t       txb->fragments[i]->len - hdr_len,\n\t\t\t\t\t       DMA_TO_DEVICE));\n\t\ttfd->u.data.chunk_len[i] =\n\t\t    cpu_to_le16(txb->fragments[i]->len - hdr_len);\n\t}\n\n\tif (i != txb->nr_frags) {\n\t\tstruct sk_buff *skb;\n\t\tu16 remaining_bytes = 0;\n\t\tint j;\n\n\t\tfor (j = i; j < txb->nr_frags; j++)\n\t\t\tremaining_bytes += txb->fragments[j]->len - hdr_len;\n\n\t\tprintk(KERN_INFO \"Trying to reallocate for %d bytes\\n\",\n\t\t       remaining_bytes);\n\t\tskb = alloc_skb(remaining_bytes, GFP_ATOMIC);\n\t\tif (skb != NULL) {\n\t\t\ttfd->u.data.chunk_len[i] = cpu_to_le16(remaining_bytes);\n\t\t\tfor (j = i; j < txb->nr_frags; j++) {\n\t\t\t\tint size = txb->fragments[j]->len - hdr_len;\n\n\t\t\t\tprintk(KERN_INFO \"Adding frag %d %d...\\n\",\n\t\t\t\t       j, size);\n\t\t\t\tskb_put_data(skb,\n\t\t\t\t\t     txb->fragments[j]->data + hdr_len,\n\t\t\t\t\t     size);\n\t\t\t}\n\t\t\tdev_kfree_skb_any(txb->fragments[i]);\n\t\t\ttxb->fragments[i] = skb;\n\t\t\ttfd->u.data.chunk_ptr[i] =\n\t\t\t    cpu_to_le32(dma_map_single(&priv->pci_dev->dev,\n\t\t\t\t\t\t       skb->data,\n\t\t\t\t\t\t       remaining_bytes,\n\t\t\t\t\t\t       DMA_TO_DEVICE));\n\n\t\t\tle32_add_cpu(&tfd->u.data.num_chunks, 1);\n\t\t}\n\t}\n\n\t/* kick DMA */\n\tq->first_empty = ipw_queue_inc_wrap(q->first_empty, q->n_bd);\n\tipw_write32(priv, q->reg_w, q->first_empty);\n\n\tif (ipw_tx_queue_space(q) < q->high_mark)\n\t\tnetif_stop_queue(priv->net_dev);\n\n\treturn NETDEV_TX_OK;\n\n      drop:\n\tIPW_DEBUG_DROP(\"Silently dropping Tx packet.\\n\");\n\tlibipw_txb_free(txb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int ipw_net_is_queue_full(struct net_device *dev, int pri)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n#ifdef CONFIG_IPW2200_QOS\n\tint tx_id = ipw_get_tx_queue_number(priv, pri);\n\tstruct clx2_tx_queue *txq = &priv->txq[tx_id];\n#else\n\tstruct clx2_tx_queue *txq = &priv->txq[0];\n#endif\t\t\t\t/* CONFIG_IPW2200_QOS */\n\n\tif (ipw_tx_queue_space(&txq->q) < txq->q.high_mark)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\nstatic void ipw_handle_promiscuous_tx(struct ipw_priv *priv,\n\t\t\t\t      struct libipw_txb *txb)\n{\n\tstruct libipw_rx_stats dummystats;\n\tstruct ieee80211_hdr *hdr;\n\tu8 n;\n\tu16 filter = priv->prom_priv->filter;\n\tint hdr_only = 0;\n\n\tif (filter & IPW_PROM_NO_TX)\n\t\treturn;\n\n\tmemset(&dummystats, 0, sizeof(dummystats));\n\n\t/* Filtering of fragment chains is done against the first fragment */\n\thdr = (void *)txb->fragments[0]->data;\n\tif (libipw_is_management(le16_to_cpu(hdr->frame_control))) {\n\t\tif (filter & IPW_PROM_NO_MGMT)\n\t\t\treturn;\n\t\tif (filter & IPW_PROM_MGMT_HEADER_ONLY)\n\t\t\thdr_only = 1;\n\t} else if (libipw_is_control(le16_to_cpu(hdr->frame_control))) {\n\t\tif (filter & IPW_PROM_NO_CTL)\n\t\t\treturn;\n\t\tif (filter & IPW_PROM_CTL_HEADER_ONLY)\n\t\t\thdr_only = 1;\n\t} else if (libipw_is_data(le16_to_cpu(hdr->frame_control))) {\n\t\tif (filter & IPW_PROM_NO_DATA)\n\t\t\treturn;\n\t\tif (filter & IPW_PROM_DATA_HEADER_ONLY)\n\t\t\thdr_only = 1;\n\t}\n\n\tfor(n=0; n<txb->nr_frags; ++n) {\n\t\tstruct sk_buff *src = txb->fragments[n];\n\t\tstruct sk_buff *dst;\n\t\tstruct ieee80211_radiotap_header *rt_hdr;\n\t\tint len;\n\n\t\tif (hdr_only) {\n\t\t\thdr = (void *)src->data;\n\t\t\tlen = libipw_get_hdrlen(le16_to_cpu(hdr->frame_control));\n\t\t} else\n\t\t\tlen = src->len;\n\n\t\tdst = alloc_skb(len + sizeof(*rt_hdr) + sizeof(u16)*2, GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\trt_hdr = skb_put(dst, sizeof(*rt_hdr));\n\n\t\trt_hdr->it_version = PKTHDR_RADIOTAP_VERSION;\n\t\trt_hdr->it_pad = 0;\n\t\trt_hdr->it_present = 0; /* after all, it's just an idea */\n\t\trt_hdr->it_present |=  cpu_to_le32(1 << IEEE80211_RADIOTAP_CHANNEL);\n\n\t\t*(__le16*)skb_put(dst, sizeof(u16)) = cpu_to_le16(\n\t\t\tieee80211chan2mhz(priv->channel));\n\t\tif (priv->channel > 14) \t/* 802.11a */\n\t\t\t*(__le16*)skb_put(dst, sizeof(u16)) =\n\t\t\t\tcpu_to_le16(IEEE80211_CHAN_OFDM |\n\t\t\t\t\t     IEEE80211_CHAN_5GHZ);\n\t\telse if (priv->ieee->mode == IEEE_B) /* 802.11b */\n\t\t\t*(__le16*)skb_put(dst, sizeof(u16)) =\n\t\t\t\tcpu_to_le16(IEEE80211_CHAN_CCK |\n\t\t\t\t\t     IEEE80211_CHAN_2GHZ);\n\t\telse \t\t/* 802.11g */\n\t\t\t*(__le16*)skb_put(dst, sizeof(u16)) =\n\t\t\t\tcpu_to_le16(IEEE80211_CHAN_OFDM |\n\t\t\t\t IEEE80211_CHAN_2GHZ);\n\n\t\trt_hdr->it_len = cpu_to_le16(dst->len);\n\n\t\tskb_copy_from_linear_data(src, skb_put(dst, len), len);\n\n\t\tif (!libipw_rx(priv->prom_priv->ieee, dst, &dummystats))\n\t\t\tdev_kfree_skb_any(dst);\n\t}\n}\n#endif\n\nstatic netdev_tx_t ipw_net_hard_start_xmit(struct libipw_txb *txb,\n\t\t\t\t\t   struct net_device *dev, int pri)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tunsigned long flags;\n\tnetdev_tx_t ret;\n\n\tIPW_DEBUG_TX(\"dev->xmit(%d bytes)\\n\", txb->payload_size);\n\tspin_lock_irqsave(&priv->lock, flags);\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n\tif (rtap_iface && netif_running(priv->prom_net_dev))\n\t\tipw_handle_promiscuous_tx(priv, txb);\n#endif\n\n\tret = ipw_tx_skb(priv, txb, pri);\n\tif (ret == NETDEV_TX_OK)\n\t\t__ipw_led_activity_on(priv);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn ret;\n}\n\nstatic void ipw_net_set_multicast_list(struct net_device *dev)\n{\n\n}\n\nstatic int ipw_net_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\tmutex_lock(&priv->mutex);\n\tpriv->config |= CFG_CUSTOM_MAC;\n\tmemcpy(priv->mac_addr, addr->sa_data, ETH_ALEN);\n\tprintk(KERN_INFO \"%s: Setting MAC to %pM\\n\",\n\t       priv->net_dev->name, priv->mac_addr);\n\tschedule_work(&priv->adapter_restart);\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic void ipw_ethtool_get_drvinfo(struct net_device *dev,\n\t\t\t\t    struct ethtool_drvinfo *info)\n{\n\tstruct ipw_priv *p = libipw_priv(dev);\n\tchar vers[64];\n\tchar date[32];\n\tu32 len;\n\n\tstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\n\n\tlen = sizeof(vers);\n\tipw_get_ordinal(p, IPW_ORD_STAT_FW_VERSION, vers, &len);\n\tlen = sizeof(date);\n\tipw_get_ordinal(p, IPW_ORD_STAT_FW_DATE, date, &len);\n\n\tsnprintf(info->fw_version, sizeof(info->fw_version), \"%s (%s)\",\n\t\t vers, date);\n\tstrlcpy(info->bus_info, pci_name(p->pci_dev),\n\t\tsizeof(info->bus_info));\n}\n\nstatic u32 ipw_ethtool_get_link(struct net_device *dev)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\treturn (priv->status & STATUS_ASSOCIATED) != 0;\n}\n\nstatic int ipw_ethtool_get_eeprom_len(struct net_device *dev)\n{\n\treturn IPW_EEPROM_IMAGE_SIZE;\n}\n\nstatic int ipw_ethtool_get_eeprom(struct net_device *dev,\n\t\t\t\t  struct ethtool_eeprom *eeprom, u8 * bytes)\n{\n\tstruct ipw_priv *p = libipw_priv(dev);\n\n\tif (eeprom->offset + eeprom->len > IPW_EEPROM_IMAGE_SIZE)\n\t\treturn -EINVAL;\n\tmutex_lock(&p->mutex);\n\tmemcpy(bytes, &p->eeprom[eeprom->offset], eeprom->len);\n\tmutex_unlock(&p->mutex);\n\treturn 0;\n}\n\nstatic int ipw_ethtool_set_eeprom(struct net_device *dev,\n\t\t\t\t  struct ethtool_eeprom *eeprom, u8 * bytes)\n{\n\tstruct ipw_priv *p = libipw_priv(dev);\n\tint i;\n\n\tif (eeprom->offset + eeprom->len > IPW_EEPROM_IMAGE_SIZE)\n\t\treturn -EINVAL;\n\tmutex_lock(&p->mutex);\n\tmemcpy(&p->eeprom[eeprom->offset], bytes, eeprom->len);\n\tfor (i = 0; i < IPW_EEPROM_IMAGE_SIZE; i++)\n\t\tipw_write8(p, i + IPW_EEPROM_DATA, p->eeprom[i]);\n\tmutex_unlock(&p->mutex);\n\treturn 0;\n}\n\nstatic const struct ethtool_ops ipw_ethtool_ops = {\n\t.get_link = ipw_ethtool_get_link,\n\t.get_drvinfo = ipw_ethtool_get_drvinfo,\n\t.get_eeprom_len = ipw_ethtool_get_eeprom_len,\n\t.get_eeprom = ipw_ethtool_get_eeprom,\n\t.set_eeprom = ipw_ethtool_set_eeprom,\n};\n\nstatic irqreturn_t ipw_isr(int irq, void *data)\n{\n\tstruct ipw_priv *priv = data;\n\tu32 inta, inta_mask;\n\n\tif (!priv)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&priv->irq_lock);\n\n\tif (!(priv->status & STATUS_INT_ENABLED)) {\n\t\t/* IRQ is disabled */\n\t\tgoto none;\n\t}\n\n\tinta = ipw_read32(priv, IPW_INTA_RW);\n\tinta_mask = ipw_read32(priv, IPW_INTA_MASK_R);\n\n\tif (inta == 0xFFFFFFFF) {\n\t\t/* Hardware disappeared */\n\t\tIPW_WARNING(\"IRQ INTA == 0xFFFFFFFF\\n\");\n\t\tgoto none;\n\t}\n\n\tif (!(inta & (IPW_INTA_MASK_ALL & inta_mask))) {\n\t\t/* Shared interrupt */\n\t\tgoto none;\n\t}\n\n\t/* tell the device to stop sending interrupts */\n\t__ipw_disable_interrupts(priv);\n\n\t/* ack current interrupts */\n\tinta &= (IPW_INTA_MASK_ALL & inta_mask);\n\tipw_write32(priv, IPW_INTA_RW, inta);\n\n\t/* Cache INTA value for our tasklet */\n\tpriv->isr_inta = inta;\n\n\ttasklet_schedule(&priv->irq_tasklet);\n\n\tspin_unlock(&priv->irq_lock);\n\n\treturn IRQ_HANDLED;\n      none:\n\tspin_unlock(&priv->irq_lock);\n\treturn IRQ_NONE;\n}\n\nstatic void ipw_rf_kill(void *adapter)\n{\n\tstruct ipw_priv *priv = adapter;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (rf_kill_active(priv)) {\n\t\tIPW_DEBUG_RF_KILL(\"RF Kill active, rescheduling GPIO check\\n\");\n\t\tschedule_delayed_work(&priv->rf_kill, 2 * HZ);\n\t\tgoto exit_unlock;\n\t}\n\n\t/* RF Kill is now disabled, so bring the device back up */\n\n\tif (!(priv->status & STATUS_RF_KILL_MASK)) {\n\t\tIPW_DEBUG_RF_KILL(\"HW RF Kill no longer active, restarting \"\n\t\t\t\t  \"device\\n\");\n\n\t\t/* we can not do an adapter restart while inside an irq lock */\n\t\tschedule_work(&priv->adapter_restart);\n\t} else\n\t\tIPW_DEBUG_RF_KILL(\"HW RF Kill deactivated.  SW RF Kill still \"\n\t\t\t\t  \"enabled\\n\");\n\n      exit_unlock:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void ipw_bg_rf_kill(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, rf_kill.work);\n\tmutex_lock(&priv->mutex);\n\tipw_rf_kill(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_link_up(struct ipw_priv *priv)\n{\n\tpriv->last_seq_num = -1;\n\tpriv->last_frag_num = -1;\n\tpriv->last_packet_time = 0;\n\n\tnetif_carrier_on(priv->net_dev);\n\n\tcancel_delayed_work(&priv->request_scan);\n\tcancel_delayed_work(&priv->request_direct_scan);\n\tcancel_delayed_work(&priv->request_passive_scan);\n\tcancel_delayed_work(&priv->scan_event);\n\tipw_reset_stats(priv);\n\t/* Ensure the rate is updated immediately */\n\tpriv->last_rate = ipw_get_current_rate(priv);\n\tipw_gather_stats(priv);\n\tipw_led_link_up(priv);\n\tnotify_wx_assoc_event(priv);\n\n\tif (priv->config & CFG_BACKGROUND_SCAN)\n\t\tschedule_delayed_work(&priv->request_scan, HZ);\n}\n\nstatic void ipw_bg_link_up(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, link_up);\n\tmutex_lock(&priv->mutex);\n\tipw_link_up(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_link_down(struct ipw_priv *priv)\n{\n\tipw_led_link_down(priv);\n\tnetif_carrier_off(priv->net_dev);\n\tnotify_wx_assoc_event(priv);\n\n\t/* Cancel any queued work ... */\n\tcancel_delayed_work(&priv->request_scan);\n\tcancel_delayed_work(&priv->request_direct_scan);\n\tcancel_delayed_work(&priv->request_passive_scan);\n\tcancel_delayed_work(&priv->adhoc_check);\n\tcancel_delayed_work(&priv->gather_stats);\n\n\tipw_reset_stats(priv);\n\n\tif (!(priv->status & STATUS_EXIT_PENDING)) {\n\t\t/* Queue up another scan... */\n\t\tschedule_delayed_work(&priv->request_scan, 0);\n\t} else\n\t\tcancel_delayed_work(&priv->scan_event);\n}\n\nstatic void ipw_bg_link_down(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, link_down);\n\tmutex_lock(&priv->mutex);\n\tipw_link_down(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_setup_deferred_work(struct ipw_priv *priv)\n{\n\tinit_waitqueue_head(&priv->wait_command_queue);\n\tinit_waitqueue_head(&priv->wait_state);\n\n\tINIT_DELAYED_WORK(&priv->adhoc_check, ipw_bg_adhoc_check);\n\tINIT_WORK(&priv->associate, ipw_bg_associate);\n\tINIT_WORK(&priv->disassociate, ipw_bg_disassociate);\n\tINIT_WORK(&priv->system_config, ipw_system_config);\n\tINIT_WORK(&priv->rx_replenish, ipw_bg_rx_queue_replenish);\n\tINIT_WORK(&priv->adapter_restart, ipw_bg_adapter_restart);\n\tINIT_DELAYED_WORK(&priv->rf_kill, ipw_bg_rf_kill);\n\tINIT_WORK(&priv->up, ipw_bg_up);\n\tINIT_WORK(&priv->down, ipw_bg_down);\n\tINIT_DELAYED_WORK(&priv->request_scan, ipw_request_scan);\n\tINIT_DELAYED_WORK(&priv->request_direct_scan, ipw_request_direct_scan);\n\tINIT_DELAYED_WORK(&priv->request_passive_scan, ipw_request_passive_scan);\n\tINIT_DELAYED_WORK(&priv->scan_event, ipw_scan_event);\n\tINIT_DELAYED_WORK(&priv->gather_stats, ipw_bg_gather_stats);\n\tINIT_WORK(&priv->abort_scan, ipw_bg_abort_scan);\n\tINIT_WORK(&priv->roam, ipw_bg_roam);\n\tINIT_DELAYED_WORK(&priv->scan_check, ipw_bg_scan_check);\n\tINIT_WORK(&priv->link_up, ipw_bg_link_up);\n\tINIT_WORK(&priv->link_down, ipw_bg_link_down);\n\tINIT_DELAYED_WORK(&priv->led_link_on, ipw_bg_led_link_on);\n\tINIT_DELAYED_WORK(&priv->led_link_off, ipw_bg_led_link_off);\n\tINIT_DELAYED_WORK(&priv->led_act_off, ipw_bg_led_activity_off);\n\tINIT_WORK(&priv->merge_networks, ipw_merge_adhoc_network);\n\n#ifdef CONFIG_IPW2200_QOS\n\tINIT_WORK(&priv->qos_activate, ipw_bg_qos_activate);\n#endif\t\t\t\t/* CONFIG_IPW2200_QOS */\n\n\ttasklet_setup(&priv->irq_tasklet, ipw_irq_tasklet);\n}\n\nstatic void shim__set_security(struct net_device *dev,\n\t\t\t       struct libipw_security *sec)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint i;\n\tfor (i = 0; i < 4; i++) {\n\t\tif (sec->flags & (1 << i)) {\n\t\t\tpriv->ieee->sec.encode_alg[i] = sec->encode_alg[i];\n\t\t\tpriv->ieee->sec.key_sizes[i] = sec->key_sizes[i];\n\t\t\tif (sec->key_sizes[i] == 0)\n\t\t\t\tpriv->ieee->sec.flags &= ~(1 << i);\n\t\t\telse {\n\t\t\t\tmemcpy(priv->ieee->sec.keys[i], sec->keys[i],\n\t\t\t\t       sec->key_sizes[i]);\n\t\t\t\tpriv->ieee->sec.flags |= (1 << i);\n\t\t\t}\n\t\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t\t} else if (sec->level != SEC_LEVEL_1)\n\t\t\tpriv->ieee->sec.flags &= ~(1 << i);\n\t}\n\n\tif (sec->flags & SEC_ACTIVE_KEY) {\n\t\tpriv->ieee->sec.active_key = sec->active_key;\n\t\tpriv->ieee->sec.flags |= SEC_ACTIVE_KEY;\n\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t} else\n\t\tpriv->ieee->sec.flags &= ~SEC_ACTIVE_KEY;\n\n\tif ((sec->flags & SEC_AUTH_MODE) &&\n\t    (priv->ieee->sec.auth_mode != sec->auth_mode)) {\n\t\tpriv->ieee->sec.auth_mode = sec->auth_mode;\n\t\tpriv->ieee->sec.flags |= SEC_AUTH_MODE;\n\t\tif (sec->auth_mode == WLAN_AUTH_SHARED_KEY)\n\t\t\tpriv->capability |= CAP_SHARED_KEY;\n\t\telse\n\t\t\tpriv->capability &= ~CAP_SHARED_KEY;\n\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t}\n\n\tif (sec->flags & SEC_ENABLED && priv->ieee->sec.enabled != sec->enabled) {\n\t\tpriv->ieee->sec.flags |= SEC_ENABLED;\n\t\tpriv->ieee->sec.enabled = sec->enabled;\n\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t\tif (sec->enabled)\n\t\t\tpriv->capability |= CAP_PRIVACY_ON;\n\t\telse\n\t\t\tpriv->capability &= ~CAP_PRIVACY_ON;\n\t}\n\n\tif (sec->flags & SEC_ENCRYPT)\n\t\tpriv->ieee->sec.encrypt = sec->encrypt;\n\n\tif (sec->flags & SEC_LEVEL && priv->ieee->sec.level != sec->level) {\n\t\tpriv->ieee->sec.level = sec->level;\n\t\tpriv->ieee->sec.flags |= SEC_LEVEL;\n\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t}\n\n\tif (!priv->ieee->host_encrypt && (sec->flags & SEC_ENCRYPT))\n\t\tipw_set_hwcrypto_keys(priv);\n\n\t/* To match current functionality of ipw2100 (which works well w/\n\t * various supplicants, we don't force a disassociate if the\n\t * privacy capability changes ... */\n#if 0\n\tif ((priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)) &&\n\t    (((priv->assoc_request.capability &\n\t       cpu_to_le16(WLAN_CAPABILITY_PRIVACY)) && !sec->enabled) ||\n\t     (!(priv->assoc_request.capability &\n\t\tcpu_to_le16(WLAN_CAPABILITY_PRIVACY)) && sec->enabled))) {\n\t\tIPW_DEBUG_ASSOC(\"Disassociating due to capability \"\n\t\t\t\t\"change.\\n\");\n\t\tipw_disassociate(priv);\n\t}\n#endif\n}\n\nstatic int init_supported_rates(struct ipw_priv *priv,\n\t\t\t\tstruct ipw_supported_rates *rates)\n{\n\t/* TODO: Mask out rates based on priv->rates_mask */\n\n\tmemset(rates, 0, sizeof(*rates));\n\t/* configure supported rates */\n\tswitch (priv->ieee->freq_band) {\n\tcase LIBIPW_52GHZ_BAND:\n\t\trates->ieee_mode = IPW_A_MODE;\n\t\trates->purpose = IPW_RATE_CAPABILITIES;\n\t\tipw_add_ofdm_scan_rates(rates, LIBIPW_CCK_MODULATION,\n\t\t\t\t\tLIBIPW_OFDM_DEFAULT_RATES_MASK);\n\t\tbreak;\n\n\tdefault:\t\t/* Mixed or 2.4Ghz */\n\t\trates->ieee_mode = IPW_G_MODE;\n\t\trates->purpose = IPW_RATE_CAPABILITIES;\n\t\tipw_add_cck_scan_rates(rates, LIBIPW_CCK_MODULATION,\n\t\t\t\t       LIBIPW_CCK_DEFAULT_RATES_MASK);\n\t\tif (priv->ieee->modulation & LIBIPW_OFDM_MODULATION) {\n\t\t\tipw_add_ofdm_scan_rates(rates, LIBIPW_CCK_MODULATION,\n\t\t\t\t\t\tLIBIPW_OFDM_DEFAULT_RATES_MASK);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ipw_config(struct ipw_priv *priv)\n{\n\t/* This is only called from ipw_up, which resets/reloads the firmware\n\t   so, we don't need to first disable the card before we configure\n\t   it */\n\tif (ipw_set_tx_power(priv))\n\t\tgoto error;\n\n\t/* initialize adapter address */\n\tif (ipw_send_adapter_address(priv, priv->net_dev->dev_addr))\n\t\tgoto error;\n\n\t/* set basic system config settings */\n\tinit_sys_config(&priv->sys_config);\n\n\t/* Support Bluetooth if we have BT h/w on board, and user wants to.\n\t * Does not support BT priority yet (don't abort or defer our Tx) */\n\tif (bt_coexist) {\n\t\tunsigned char bt_caps = priv->eeprom[EEPROM_SKU_CAPABILITY];\n\n\t\tif (bt_caps & EEPROM_SKU_CAP_BT_CHANNEL_SIG)\n\t\t\tpriv->sys_config.bt_coexistence\n\t\t\t    |= CFG_BT_COEXISTENCE_SIGNAL_CHNL;\n\t\tif (bt_caps & EEPROM_SKU_CAP_BT_OOB)\n\t\t\tpriv->sys_config.bt_coexistence\n\t\t\t    |= CFG_BT_COEXISTENCE_OOB;\n\t}\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n\tif (priv->prom_net_dev && netif_running(priv->prom_net_dev)) {\n\t\tpriv->sys_config.accept_all_data_frames = 1;\n\t\tpriv->sys_config.accept_non_directed_frames = 1;\n\t\tpriv->sys_config.accept_all_mgmt_bcpr = 1;\n\t\tpriv->sys_config.accept_all_mgmt_frames = 1;\n\t}\n#endif\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC)\n\t\tpriv->sys_config.answer_broadcast_ssid_probe = 1;\n\telse\n\t\tpriv->sys_config.answer_broadcast_ssid_probe = 0;\n\n\tif (ipw_send_system_config(priv))\n\t\tgoto error;\n\n\tinit_supported_rates(priv, &priv->rates);\n\tif (ipw_send_supported_rates(priv, &priv->rates))\n\t\tgoto error;\n\n\t/* Set request-to-send threshold */\n\tif (priv->rts_threshold) {\n\t\tif (ipw_send_rts_threshold(priv, priv->rts_threshold))\n\t\t\tgoto error;\n\t}\n#ifdef CONFIG_IPW2200_QOS\n\tIPW_DEBUG_QOS(\"QoS: call ipw_qos_activate\\n\");\n\tipw_qos_activate(priv, NULL);\n#endif\t\t\t\t/* CONFIG_IPW2200_QOS */\n\n\tif (ipw_set_random_seed(priv))\n\t\tgoto error;\n\n\t/* final state transition to the RUN state */\n\tif (ipw_send_host_complete(priv))\n\t\tgoto error;\n\n\tpriv->status |= STATUS_INIT;\n\n\tipw_led_init(priv);\n\tipw_led_radio_on(priv);\n\tpriv->notif_missed_beacons = 0;\n\n\t/* Set hardware WEP key if it is configured. */\n\tif ((priv->capability & CAP_PRIVACY_ON) &&\n\t    (priv->ieee->sec.level == SEC_LEVEL_1) &&\n\t    !(priv->ieee->host_encrypt || priv->ieee->host_decrypt))\n\t\tipw_set_hwcrypto_keys(priv);\n\n\treturn 0;\n\n      error:\n\treturn -EIO;\n}\n\n/*\n * NOTE:\n *\n * These tables have been tested in conjunction with the\n * Intel PRO/Wireless 2200BG and 2915ABG Network Connection Adapters.\n *\n * Altering this values, using it on other hardware, or in geographies\n * not intended for resale of the above mentioned Intel adapters has\n * not been tested.\n *\n * Remember to update the table in README.ipw2200 when changing this\n * table.\n *\n */\nstatic const struct libipw_geo ipw_geos[] = {\n\t{\t\t\t/* Restricted */\n\t \"---\",\n\t .bg_channels = 11,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}},\n\t },\n\n\t{\t\t\t/* Custom US/Canada */\n\t \"ZZF\",\n\t .bg_channels = 11,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}},\n\t .a_channels = 8,\n\t .a = {{5180, 36},\n\t       {5200, 40},\n\t       {5220, 44},\n\t       {5240, 48},\n\t       {5260, 52, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5280, 56, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5300, 60, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5320, 64, LIBIPW_CH_PASSIVE_ONLY}},\n\t },\n\n\t{\t\t\t/* Rest of World */\n\t \"ZZD\",\n\t .bg_channels = 13,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}, {2467, 12},\n\t\t{2472, 13}},\n\t },\n\n\t{\t\t\t/* Custom USA & Europe & High */\n\t \"ZZA\",\n\t .bg_channels = 11,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}},\n\t .a_channels = 13,\n\t .a = {{5180, 36},\n\t       {5200, 40},\n\t       {5220, 44},\n\t       {5240, 48},\n\t       {5260, 52, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5280, 56, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5300, 60, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5320, 64, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5745, 149},\n\t       {5765, 153},\n\t       {5785, 157},\n\t       {5805, 161},\n\t       {5825, 165}},\n\t },\n\n\t{\t\t\t/* Custom NA & Europe */\n\t \"ZZB\",\n\t .bg_channels = 11,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}},\n\t .a_channels = 13,\n\t .a = {{5180, 36},\n\t       {5200, 40},\n\t       {5220, 44},\n\t       {5240, 48},\n\t       {5260, 52, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5280, 56, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5300, 60, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5320, 64, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5745, 149, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5765, 153, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5785, 157, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5805, 161, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5825, 165, LIBIPW_CH_PASSIVE_ONLY}},\n\t },\n\n\t{\t\t\t/* Custom Japan */\n\t \"ZZC\",\n\t .bg_channels = 11,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}},\n\t .a_channels = 4,\n\t .a = {{5170, 34}, {5190, 38},\n\t       {5210, 42}, {5230, 46}},\n\t },\n\n\t{\t\t\t/* Custom */\n\t \"ZZM\",\n\t .bg_channels = 11,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}},\n\t },\n\n\t{\t\t\t/* Europe */\n\t \"ZZE\",\n\t .bg_channels = 13,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}, {2467, 12},\n\t\t{2472, 13}},\n\t .a_channels = 19,\n\t .a = {{5180, 36},\n\t       {5200, 40},\n\t       {5220, 44},\n\t       {5240, 48},\n\t       {5260, 52, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5280, 56, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5300, 60, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5320, 64, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5500, 100, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5520, 104, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5540, 108, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5560, 112, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5580, 116, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5600, 120, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5620, 124, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5640, 128, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5660, 132, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5680, 136, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5700, 140, LIBIPW_CH_PASSIVE_ONLY}},\n\t },\n\n\t{\t\t\t/* Custom Japan */\n\t \"ZZJ\",\n\t .bg_channels = 14,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}, {2467, 12},\n\t\t{2472, 13}, {2484, 14, LIBIPW_CH_B_ONLY}},\n\t .a_channels = 4,\n\t .a = {{5170, 34}, {5190, 38},\n\t       {5210, 42}, {5230, 46}},\n\t },\n\n\t{\t\t\t/* Rest of World */\n\t \"ZZR\",\n\t .bg_channels = 14,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}, {2467, 12},\n\t\t{2472, 13}, {2484, 14, LIBIPW_CH_B_ONLY |\n\t\t\t     LIBIPW_CH_PASSIVE_ONLY}},\n\t },\n\n\t{\t\t\t/* High Band */\n\t \"ZZH\",\n\t .bg_channels = 13,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11},\n\t\t{2467, 12, LIBIPW_CH_PASSIVE_ONLY},\n\t\t{2472, 13, LIBIPW_CH_PASSIVE_ONLY}},\n\t .a_channels = 4,\n\t .a = {{5745, 149}, {5765, 153},\n\t       {5785, 157}, {5805, 161}},\n\t },\n\n\t{\t\t\t/* Custom Europe */\n\t \"ZZG\",\n\t .bg_channels = 13,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11},\n\t\t{2467, 12}, {2472, 13}},\n\t .a_channels = 4,\n\t .a = {{5180, 36}, {5200, 40},\n\t       {5220, 44}, {5240, 48}},\n\t },\n\n\t{\t\t\t/* Europe */\n\t \"ZZK\",\n\t .bg_channels = 13,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11},\n\t\t{2467, 12, LIBIPW_CH_PASSIVE_ONLY},\n\t\t{2472, 13, LIBIPW_CH_PASSIVE_ONLY}},\n\t .a_channels = 24,\n\t .a = {{5180, 36, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5200, 40, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5220, 44, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5240, 48, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5260, 52, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5280, 56, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5300, 60, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5320, 64, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5500, 100, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5520, 104, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5540, 108, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5560, 112, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5580, 116, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5600, 120, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5620, 124, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5640, 128, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5660, 132, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5680, 136, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5700, 140, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5745, 149, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5765, 153, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5785, 157, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5805, 161, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5825, 165, LIBIPW_CH_PASSIVE_ONLY}},\n\t },\n\n\t{\t\t\t/* Europe */\n\t \"ZZL\",\n\t .bg_channels = 11,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}},\n\t .a_channels = 13,\n\t .a = {{5180, 36, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5200, 40, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5220, 44, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5240, 48, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5260, 52, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5280, 56, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5300, 60, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5320, 64, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5745, 149, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5765, 153, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5785, 157, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5805, 161, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5825, 165, LIBIPW_CH_PASSIVE_ONLY}},\n\t }\n};\n\nstatic void ipw_set_geo(struct ipw_priv *priv)\n{\n\tint j;\n\n\tfor (j = 0; j < ARRAY_SIZE(ipw_geos); j++) {\n\t\tif (!memcmp(&priv->eeprom[EEPROM_COUNTRY_CODE],\n\t\t\t    ipw_geos[j].name, 3))\n\t\t\tbreak;\n\t}\n\n\tif (j == ARRAY_SIZE(ipw_geos)) {\n\t\tIPW_WARNING(\"SKU [%c%c%c] not recognized.\\n\",\n\t\t\t    priv->eeprom[EEPROM_COUNTRY_CODE + 0],\n\t\t\t    priv->eeprom[EEPROM_COUNTRY_CODE + 1],\n\t\t\t    priv->eeprom[EEPROM_COUNTRY_CODE + 2]);\n\t\tj = 0;\n\t}\n\n\tlibipw_set_geo(priv->ieee, &ipw_geos[j]);\n}\n\n#define MAX_HW_RESTARTS 5\nstatic int ipw_up(struct ipw_priv *priv)\n{\n\tint rc, i;\n\n\t/* Age scan list entries found before suspend */\n\tif (priv->suspend_time) {\n\t\tlibipw_networks_age(priv->ieee, priv->suspend_time);\n\t\tpriv->suspend_time = 0;\n\t}\n\n\tif (priv->status & STATUS_EXIT_PENDING)\n\t\treturn -EIO;\n\n\tif (cmdlog && !priv->cmdlog) {\n\t\tpriv->cmdlog = kcalloc(cmdlog, sizeof(*priv->cmdlog),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (priv->cmdlog == NULL) {\n\t\t\tIPW_ERROR(\"Error allocating %d command log entries.\\n\",\n\t\t\t\t  cmdlog);\n\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\tpriv->cmdlog_len = cmdlog;\n\t\t}\n\t}\n\n\tfor (i = 0; i < MAX_HW_RESTARTS; i++) {\n\t\t/* Load the microcode, firmware, and eeprom.\n\t\t * Also start the clocks. */\n\t\trc = ipw_load(priv);\n\t\tif (rc) {\n\t\t\tIPW_ERROR(\"Unable to load firmware: %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tipw_init_ordinals(priv);\n\t\tif (!(priv->config & CFG_CUSTOM_MAC))\n\t\t\teeprom_parse_mac(priv, priv->mac_addr);\n\t\tmemcpy(priv->net_dev->dev_addr, priv->mac_addr, ETH_ALEN);\n\n\t\tipw_set_geo(priv);\n\n\t\tif (priv->status & STATUS_RF_KILL_SW) {\n\t\t\tIPW_WARNING(\"Radio disabled by module parameter.\\n\");\n\t\t\treturn 0;\n\t\t} else if (rf_kill_active(priv)) {\n\t\t\tIPW_WARNING(\"Radio Frequency Kill Switch is On:\\n\"\n\t\t\t\t    \"Kill switch must be turned off for \"\n\t\t\t\t    \"wireless networking to work.\\n\");\n\t\t\tschedule_delayed_work(&priv->rf_kill, 2 * HZ);\n\t\t\treturn 0;\n\t\t}\n\n\t\trc = ipw_config(priv);\n\t\tif (!rc) {\n\t\t\tIPW_DEBUG_INFO(\"Configured device on count %i\\n\", i);\n\n\t\t\t/* If configure to try and auto-associate, kick\n\t\t\t * off a scan. */\n\t\t\tschedule_delayed_work(&priv->request_scan, 0);\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tIPW_DEBUG_INFO(\"Device configuration failed: 0x%08X\\n\", rc);\n\t\tIPW_DEBUG_INFO(\"Failed to config device on retry %d of %d\\n\",\n\t\t\t       i, MAX_HW_RESTARTS);\n\n\t\t/* We had an error bringing up the hardware, so take it\n\t\t * all the way back down so we can try again */\n\t\tipw_down(priv);\n\t}\n\n\t/* tried to restart and config the device for as long as our\n\t * patience could withstand */\n\tIPW_ERROR(\"Unable to initialize device after %d attempts.\\n\", i);\n\n\treturn -EIO;\n}\n\nstatic void ipw_bg_up(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, up);\n\tmutex_lock(&priv->mutex);\n\tipw_up(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_deinit(struct ipw_priv *priv)\n{\n\tint i;\n\n\tif (priv->status & STATUS_SCANNING) {\n\t\tIPW_DEBUG_INFO(\"Aborting scan during shutdown.\\n\");\n\t\tipw_abort_scan(priv);\n\t}\n\n\tif (priv->status & STATUS_ASSOCIATED) {\n\t\tIPW_DEBUG_INFO(\"Disassociating during shutdown.\\n\");\n\t\tipw_disassociate(priv);\n\t}\n\n\tipw_led_shutdown(priv);\n\n\t/* Wait up to 1s for status to change to not scanning and not\n\t * associated (disassociation can take a while for a ful 802.11\n\t * exchange */\n\tfor (i = 1000; i && (priv->status &\n\t\t\t     (STATUS_DISASSOCIATING |\n\t\t\t      STATUS_ASSOCIATED | STATUS_SCANNING)); i--)\n\t\tudelay(10);\n\n\tif (priv->status & (STATUS_DISASSOCIATING |\n\t\t\t    STATUS_ASSOCIATED | STATUS_SCANNING))\n\t\tIPW_DEBUG_INFO(\"Still associated or scanning...\\n\");\n\telse\n\t\tIPW_DEBUG_INFO(\"Took %dms to de-init\\n\", 1000 - i);\n\n\t/* Attempt to disable the card */\n\tipw_send_card_disable(priv, 0);\n\n\tpriv->status &= ~STATUS_INIT;\n}\n\nstatic void ipw_down(struct ipw_priv *priv)\n{\n\tint exit_pending = priv->status & STATUS_EXIT_PENDING;\n\n\tpriv->status |= STATUS_EXIT_PENDING;\n\n\tif (ipw_is_init(priv))\n\t\tipw_deinit(priv);\n\n\t/* Wipe out the EXIT_PENDING status bit if we are not actually\n\t * exiting the module */\n\tif (!exit_pending)\n\t\tpriv->status &= ~STATUS_EXIT_PENDING;\n\n\t/* tell the device to stop sending interrupts */\n\tipw_disable_interrupts(priv);\n\n\t/* Clear all bits but the RF Kill */\n\tpriv->status &= STATUS_RF_KILL_MASK | STATUS_EXIT_PENDING;\n\tnetif_carrier_off(priv->net_dev);\n\n\tipw_stop_nic(priv);\n\n\tipw_led_radio_off(priv);\n}\n\nstatic void ipw_bg_down(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, down);\n\tmutex_lock(&priv->mutex);\n\tipw_down(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int ipw_wdev_init(struct net_device *dev)\n{\n\tint i, rc = 0;\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\n\tstruct wireless_dev *wdev = &priv->ieee->wdev;\n\n\tmemcpy(wdev->wiphy->perm_addr, priv->mac_addr, ETH_ALEN);\n\n\t/* fill-out priv->ieee->bg_band */\n\tif (geo->bg_channels) {\n\t\tstruct ieee80211_supported_band *bg_band = &priv->ieee->bg_band;\n\n\t\tbg_band->band = NL80211_BAND_2GHZ;\n\t\tbg_band->n_channels = geo->bg_channels;\n\t\tbg_band->channels = kcalloc(geo->bg_channels,\n\t\t\t\t\t    sizeof(struct ieee80211_channel),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!bg_band->channels) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/* translate geo->bg to bg_band.channels */\n\t\tfor (i = 0; i < geo->bg_channels; i++) {\n\t\t\tbg_band->channels[i].band = NL80211_BAND_2GHZ;\n\t\t\tbg_band->channels[i].center_freq = geo->bg[i].freq;\n\t\t\tbg_band->channels[i].hw_value = geo->bg[i].channel;\n\t\t\tbg_band->channels[i].max_power = geo->bg[i].max_power;\n\t\t\tif (geo->bg[i].flags & LIBIPW_CH_PASSIVE_ONLY)\n\t\t\t\tbg_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_NO_IR;\n\t\t\tif (geo->bg[i].flags & LIBIPW_CH_NO_IBSS)\n\t\t\t\tbg_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_NO_IR;\n\t\t\tif (geo->bg[i].flags & LIBIPW_CH_RADAR_DETECT)\n\t\t\t\tbg_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_RADAR;\n\t\t\t/* No equivalent for LIBIPW_CH_80211H_RULES,\n\t\t\t   LIBIPW_CH_UNIFORM_SPREADING, or\n\t\t\t   LIBIPW_CH_B_ONLY... */\n\t\t}\n\t\t/* point at bitrate info */\n\t\tbg_band->bitrates = ipw2200_bg_rates;\n\t\tbg_band->n_bitrates = ipw2200_num_bg_rates;\n\n\t\twdev->wiphy->bands[NL80211_BAND_2GHZ] = bg_band;\n\t}\n\n\t/* fill-out priv->ieee->a_band */\n\tif (geo->a_channels) {\n\t\tstruct ieee80211_supported_band *a_band = &priv->ieee->a_band;\n\n\t\ta_band->band = NL80211_BAND_5GHZ;\n\t\ta_band->n_channels = geo->a_channels;\n\t\ta_band->channels = kcalloc(geo->a_channels,\n\t\t\t\t\t   sizeof(struct ieee80211_channel),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!a_band->channels) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/* translate geo->a to a_band.channels */\n\t\tfor (i = 0; i < geo->a_channels; i++) {\n\t\t\ta_band->channels[i].band = NL80211_BAND_5GHZ;\n\t\t\ta_band->channels[i].center_freq = geo->a[i].freq;\n\t\t\ta_band->channels[i].hw_value = geo->a[i].channel;\n\t\t\ta_band->channels[i].max_power = geo->a[i].max_power;\n\t\t\tif (geo->a[i].flags & LIBIPW_CH_PASSIVE_ONLY)\n\t\t\t\ta_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_NO_IR;\n\t\t\tif (geo->a[i].flags & LIBIPW_CH_NO_IBSS)\n\t\t\t\ta_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_NO_IR;\n\t\t\tif (geo->a[i].flags & LIBIPW_CH_RADAR_DETECT)\n\t\t\t\ta_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_RADAR;\n\t\t\t/* No equivalent for LIBIPW_CH_80211H_RULES,\n\t\t\t   LIBIPW_CH_UNIFORM_SPREADING, or\n\t\t\t   LIBIPW_CH_B_ONLY... */\n\t\t}\n\t\t/* point at bitrate info */\n\t\ta_band->bitrates = ipw2200_a_rates;\n\t\ta_band->n_bitrates = ipw2200_num_a_rates;\n\n\t\twdev->wiphy->bands[NL80211_BAND_5GHZ] = a_band;\n\t}\n\n\twdev->wiphy->cipher_suites = ipw_cipher_suites;\n\twdev->wiphy->n_cipher_suites = ARRAY_SIZE(ipw_cipher_suites);\n\n\tset_wiphy_dev(wdev->wiphy, &priv->pci_dev->dev);\n\n\t/* With that information in place, we can now register the wiphy... */\n\tif (wiphy_register(wdev->wiphy))\n\t\trc = -EIO;\nout:\n\treturn rc;\n}\n\n/* PCI driver stuff */\nstatic const struct pci_device_id card_ids[] = {\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2701, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2702, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2711, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2712, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2721, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2722, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2731, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2732, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2741, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x103c, 0x2741, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2742, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2751, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2752, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2753, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2754, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2761, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2762, 0, 0, 0},\n\t{PCI_VDEVICE(INTEL, 0x104f), 0},\n\t{PCI_VDEVICE(INTEL, 0x4220), 0},\t/* BG */\n\t{PCI_VDEVICE(INTEL, 0x4221), 0},\t/* BG */\n\t{PCI_VDEVICE(INTEL, 0x4223), 0},\t/* ABG */\n\t{PCI_VDEVICE(INTEL, 0x4224), 0},\t/* ABG */\n\n\t/* required last entry */\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, card_ids);\n\nstatic struct attribute *ipw_sysfs_entries[] = {\n\t&dev_attr_rf_kill.attr,\n\t&dev_attr_direct_dword.attr,\n\t&dev_attr_indirect_byte.attr,\n\t&dev_attr_indirect_dword.attr,\n\t&dev_attr_mem_gpio_reg.attr,\n\t&dev_attr_command_event_reg.attr,\n\t&dev_attr_nic_type.attr,\n\t&dev_attr_status.attr,\n\t&dev_attr_cfg.attr,\n\t&dev_attr_error.attr,\n\t&dev_attr_event_log.attr,\n\t&dev_attr_cmd_log.attr,\n\t&dev_attr_eeprom_delay.attr,\n\t&dev_attr_ucode_version.attr,\n\t&dev_attr_rtc.attr,\n\t&dev_attr_scan_age.attr,\n\t&dev_attr_led.attr,\n\t&dev_attr_speed_scan.attr,\n\t&dev_attr_net_stats.attr,\n\t&dev_attr_channels.attr,\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n\t&dev_attr_rtap_iface.attr,\n\t&dev_attr_rtap_filter.attr,\n#endif\n\tNULL\n};\n\nstatic const struct attribute_group ipw_attribute_group = {\n\t.name = NULL,\t\t/* put in device directory */\n\t.attrs = ipw_sysfs_entries,\n};\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\nstatic int ipw_prom_open(struct net_device *dev)\n{\n\tstruct ipw_prom_priv *prom_priv = libipw_priv(dev);\n\tstruct ipw_priv *priv = prom_priv->priv;\n\n\tIPW_DEBUG_INFO(\"prom dev->open\\n\");\n\tnetif_carrier_off(dev);\n\n\tif (priv->ieee->iw_mode != IW_MODE_MONITOR) {\n\t\tpriv->sys_config.accept_all_data_frames = 1;\n\t\tpriv->sys_config.accept_non_directed_frames = 1;\n\t\tpriv->sys_config.accept_all_mgmt_bcpr = 1;\n\t\tpriv->sys_config.accept_all_mgmt_frames = 1;\n\n\t\tipw_send_system_config(priv);\n\t}\n\n\treturn 0;\n}\n\nstatic int ipw_prom_stop(struct net_device *dev)\n{\n\tstruct ipw_prom_priv *prom_priv = libipw_priv(dev);\n\tstruct ipw_priv *priv = prom_priv->priv;\n\n\tIPW_DEBUG_INFO(\"prom dev->stop\\n\");\n\n\tif (priv->ieee->iw_mode != IW_MODE_MONITOR) {\n\t\tpriv->sys_config.accept_all_data_frames = 0;\n\t\tpriv->sys_config.accept_non_directed_frames = 0;\n\t\tpriv->sys_config.accept_all_mgmt_bcpr = 0;\n\t\tpriv->sys_config.accept_all_mgmt_frames = 0;\n\n\t\tipw_send_system_config(priv);\n\t}\n\n\treturn 0;\n}\n\nstatic netdev_tx_t ipw_prom_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev)\n{\n\tIPW_DEBUG_INFO(\"prom dev->xmit\\n\");\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops ipw_prom_netdev_ops = {\n\t.ndo_open \t\t= ipw_prom_open,\n\t.ndo_stop\t\t= ipw_prom_stop,\n\t.ndo_start_xmit\t\t= ipw_prom_hard_start_xmit,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int ipw_prom_alloc(struct ipw_priv *priv)\n{\n\tint rc = 0;\n\n\tif (priv->prom_net_dev)\n\t\treturn -EPERM;\n\n\tpriv->prom_net_dev = alloc_libipw(sizeof(struct ipw_prom_priv), 1);\n\tif (priv->prom_net_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tpriv->prom_priv = libipw_priv(priv->prom_net_dev);\n\tpriv->prom_priv->ieee = netdev_priv(priv->prom_net_dev);\n\tpriv->prom_priv->priv = priv;\n\n\tstrcpy(priv->prom_net_dev->name, \"rtap%d\");\n\tmemcpy(priv->prom_net_dev->dev_addr, priv->mac_addr, ETH_ALEN);\n\n\tpriv->prom_net_dev->type = ARPHRD_IEEE80211_RADIOTAP;\n\tpriv->prom_net_dev->netdev_ops = &ipw_prom_netdev_ops;\n\n\tpriv->prom_net_dev->min_mtu = 68;\n\tpriv->prom_net_dev->max_mtu = LIBIPW_DATA_LEN;\n\n\tpriv->prom_priv->ieee->iw_mode = IW_MODE_MONITOR;\n\tSET_NETDEV_DEV(priv->prom_net_dev, &priv->pci_dev->dev);\n\n\trc = register_netdev(priv->prom_net_dev);\n\tif (rc) {\n\t\tfree_libipw(priv->prom_net_dev, 1);\n\t\tpriv->prom_net_dev = NULL;\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void ipw_prom_free(struct ipw_priv *priv)\n{\n\tif (!priv->prom_net_dev)\n\t\treturn;\n\n\tunregister_netdev(priv->prom_net_dev);\n\tfree_libipw(priv->prom_net_dev, 1);\n\n\tpriv->prom_net_dev = NULL;\n}\n\n#endif\n\nstatic const struct net_device_ops ipw_netdev_ops = {\n\t.ndo_open\t\t= ipw_net_open,\n\t.ndo_stop\t\t= ipw_net_stop,\n\t.ndo_set_rx_mode\t= ipw_net_set_multicast_list,\n\t.ndo_set_mac_address\t= ipw_net_set_mac_address,\n\t.ndo_start_xmit\t\t= libipw_xmit,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int ipw_pci_probe(struct pci_dev *pdev,\n\t\t\t\t   const struct pci_device_id *ent)\n{\n\tint err = 0;\n\tstruct net_device *net_dev;\n\tvoid __iomem *base;\n\tu32 length, val;\n\tstruct ipw_priv *priv;\n\tint i;\n\n\tnet_dev = alloc_libipw(sizeof(struct ipw_priv), 0);\n\tif (net_dev == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpriv = libipw_priv(net_dev);\n\tpriv->ieee = netdev_priv(net_dev);\n\n\tpriv->net_dev = net_dev;\n\tpriv->pci_dev = pdev;\n\tipw_debug_level = debug;\n\tspin_lock_init(&priv->irq_lock);\n\tspin_lock_init(&priv->lock);\n\tfor (i = 0; i < IPW_IBSS_MAC_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&priv->ibss_mac_hash[i]);\n\n\tmutex_init(&priv->mutex);\n\tif (pci_enable_device(pdev)) {\n\t\terr = -ENODEV;\n\t\tgoto out_free_libipw;\n\t}\n\n\tpci_set_master(pdev);\n\n\terr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (!err)\n\t\terr = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tprintk(KERN_WARNING DRV_NAME \": No suitable DMA available.\\n\");\n\t\tgoto out_pci_disable_device;\n\t}\n\n\tpci_set_drvdata(pdev, priv);\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err)\n\t\tgoto out_pci_disable_device;\n\n\t/* We disable the RETRY_TIMEOUT register (0x41) to keep\n\t * PCI Tx retries from interfering with C3 CPU state */\n\tpci_read_config_dword(pdev, 0x40, &val);\n\tif ((val & 0x0000ff00) != 0)\n\t\tpci_write_config_dword(pdev, 0x40, val & 0xffff00ff);\n\n\tlength = pci_resource_len(pdev, 0);\n\tpriv->hw_len = length;\n\n\tbase = pci_ioremap_bar(pdev, 0);\n\tif (!base) {\n\t\terr = -ENODEV;\n\t\tgoto out_pci_release_regions;\n\t}\n\n\tpriv->hw_base = base;\n\tIPW_DEBUG_INFO(\"pci_resource_len = 0x%08x\\n\", length);\n\tIPW_DEBUG_INFO(\"pci_resource_base = %p\\n\", base);\n\n\tipw_setup_deferred_work(priv);\n\n\tipw_sw_reset(priv, 1);\n\n\terr = request_irq(pdev->irq, ipw_isr, IRQF_SHARED, DRV_NAME, priv);\n\tif (err) {\n\t\tIPW_ERROR(\"Error allocating IRQ %d\\n\", pdev->irq);\n\t\tgoto out_iounmap;\n\t}\n\n\tSET_NETDEV_DEV(net_dev, &pdev->dev);\n\n\tmutex_lock(&priv->mutex);\n\n\tpriv->ieee->hard_start_xmit = ipw_net_hard_start_xmit;\n\tpriv->ieee->set_security = shim__set_security;\n\tpriv->ieee->is_queue_full = ipw_net_is_queue_full;\n\n#ifdef CONFIG_IPW2200_QOS\n\tpriv->ieee->is_qos_active = ipw_is_qos_active;\n\tpriv->ieee->handle_probe_response = ipw_handle_beacon;\n\tpriv->ieee->handle_beacon = ipw_handle_probe_response;\n\tpriv->ieee->handle_assoc_response = ipw_handle_assoc_response;\n#endif\t\t\t\t/* CONFIG_IPW2200_QOS */\n\n\tpriv->ieee->perfect_rssi = -20;\n\tpriv->ieee->worst_rssi = -85;\n\n\tnet_dev->netdev_ops = &ipw_netdev_ops;\n\tpriv->wireless_data.spy_data = &priv->ieee->spy_data;\n\tnet_dev->wireless_data = &priv->wireless_data;\n\tnet_dev->wireless_handlers = &ipw_wx_handler_def;\n\tnet_dev->ethtool_ops = &ipw_ethtool_ops;\n\n\tnet_dev->min_mtu = 68;\n\tnet_dev->max_mtu = LIBIPW_DATA_LEN;\n\n\terr = sysfs_create_group(&pdev->dev.kobj, &ipw_attribute_group);\n\tif (err) {\n\t\tIPW_ERROR(\"failed to create sysfs device attributes\\n\");\n\t\tmutex_unlock(&priv->mutex);\n\t\tgoto out_release_irq;\n\t}\n\n\tif (ipw_up(priv)) {\n\t\tmutex_unlock(&priv->mutex);\n\t\terr = -EIO;\n\t\tgoto out_remove_sysfs;\n\t}\n\n\tmutex_unlock(&priv->mutex);\n\n\terr = ipw_wdev_init(net_dev);\n\tif (err) {\n\t\tIPW_ERROR(\"failed to register wireless device\\n\");\n\t\tgoto out_remove_sysfs;\n\t}\n\n\terr = register_netdev(net_dev);\n\tif (err) {\n\t\tIPW_ERROR(\"failed to register network device\\n\");\n\t\tgoto out_unregister_wiphy;\n\t}\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n\tif (rtap_iface) {\n\t        err = ipw_prom_alloc(priv);\n\t\tif (err) {\n\t\t\tIPW_ERROR(\"Failed to register promiscuous network \"\n\t\t\t\t  \"device (error %d).\\n\", err);\n\t\t\tunregister_netdev(priv->net_dev);\n\t\t\tgoto out_unregister_wiphy;\n\t\t}\n\t}\n#endif\n\n\tprintk(KERN_INFO DRV_NAME \": Detected geography %s (%d 802.11bg \"\n\t       \"channels, %d 802.11a channels)\\n\",\n\t       priv->ieee->geo.name, priv->ieee->geo.bg_channels,\n\t       priv->ieee->geo.a_channels);\n\n\treturn 0;\n\n      out_unregister_wiphy:\n\twiphy_unregister(priv->ieee->wdev.wiphy);\n\tkfree(priv->ieee->a_band.channels);\n\tkfree(priv->ieee->bg_band.channels);\n      out_remove_sysfs:\n\tsysfs_remove_group(&pdev->dev.kobj, &ipw_attribute_group);\n      out_release_irq:\n\tfree_irq(pdev->irq, priv);\n      out_iounmap:\n\tiounmap(priv->hw_base);\n      out_pci_release_regions:\n\tpci_release_regions(pdev);\n      out_pci_disable_device:\n\tpci_disable_device(pdev);\n      out_free_libipw:\n\tfree_libipw(priv->net_dev, 0);\n      out:\n\treturn err;\n}\n\nstatic void ipw_pci_remove(struct pci_dev *pdev)\n{\n\tstruct ipw_priv *priv = pci_get_drvdata(pdev);\n\tstruct list_head *p, *q;\n\tint i;\n\n\tif (!priv)\n\t\treturn;\n\n\tmutex_lock(&priv->mutex);\n\n\tpriv->status |= STATUS_EXIT_PENDING;\n\tipw_down(priv);\n\tsysfs_remove_group(&pdev->dev.kobj, &ipw_attribute_group);\n\n\tmutex_unlock(&priv->mutex);\n\n\tunregister_netdev(priv->net_dev);\n\n\tif (priv->rxq) {\n\t\tipw_rx_queue_free(priv, priv->rxq);\n\t\tpriv->rxq = NULL;\n\t}\n\tipw_tx_queue_free(priv);\n\n\tif (priv->cmdlog) {\n\t\tkfree(priv->cmdlog);\n\t\tpriv->cmdlog = NULL;\n\t}\n\n\t/* make sure all works are inactive */\n\tcancel_delayed_work_sync(&priv->adhoc_check);\n\tcancel_work_sync(&priv->associate);\n\tcancel_work_sync(&priv->disassociate);\n\tcancel_work_sync(&priv->system_config);\n\tcancel_work_sync(&priv->rx_replenish);\n\tcancel_work_sync(&priv->adapter_restart);\n\tcancel_delayed_work_sync(&priv->rf_kill);\n\tcancel_work_sync(&priv->up);\n\tcancel_work_sync(&priv->down);\n\tcancel_delayed_work_sync(&priv->request_scan);\n\tcancel_delayed_work_sync(&priv->request_direct_scan);\n\tcancel_delayed_work_sync(&priv->request_passive_scan);\n\tcancel_delayed_work_sync(&priv->scan_event);\n\tcancel_delayed_work_sync(&priv->gather_stats);\n\tcancel_work_sync(&priv->abort_scan);\n\tcancel_work_sync(&priv->roam);\n\tcancel_delayed_work_sync(&priv->scan_check);\n\tcancel_work_sync(&priv->link_up);\n\tcancel_work_sync(&priv->link_down);\n\tcancel_delayed_work_sync(&priv->led_link_on);\n\tcancel_delayed_work_sync(&priv->led_link_off);\n\tcancel_delayed_work_sync(&priv->led_act_off);\n\tcancel_work_sync(&priv->merge_networks);\n\n\t/* Free MAC hash list for ADHOC */\n\tfor (i = 0; i < IPW_IBSS_MAC_HASH_SIZE; i++) {\n\t\tlist_for_each_safe(p, q, &priv->ibss_mac_hash[i]) {\n\t\t\tlist_del(p);\n\t\t\tkfree(list_entry(p, struct ipw_ibss_seq, list));\n\t\t}\n\t}\n\n\tkfree(priv->error);\n\tpriv->error = NULL;\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n\tipw_prom_free(priv);\n#endif\n\n\tfree_irq(pdev->irq, priv);\n\tiounmap(priv->hw_base);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\t/* wiphy_unregister needs to be here, before free_libipw */\n\twiphy_unregister(priv->ieee->wdev.wiphy);\n\tkfree(priv->ieee->a_band.channels);\n\tkfree(priv->ieee->bg_band.channels);\n\tfree_libipw(priv->net_dev, 0);\n\tfree_firmware();\n}\n\nstatic int __maybe_unused ipw_pci_suspend(struct device *dev_d)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(dev_d);\n\tstruct net_device *dev = priv->net_dev;\n\n\tprintk(KERN_INFO \"%s: Going into suspend...\\n\", dev->name);\n\n\t/* Take down the device; powers it off, etc. */\n\tipw_down(priv);\n\n\t/* Remove the PRESENT state of the device */\n\tnetif_device_detach(dev);\n\n\tpriv->suspend_at = ktime_get_boottime_seconds();\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ipw_pci_resume(struct device *dev_d)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_d);\n\tstruct ipw_priv *priv = pci_get_drvdata(pdev);\n\tstruct net_device *dev = priv->net_dev;\n\tu32 val;\n\n\tprintk(KERN_INFO \"%s: Coming out of suspend...\\n\", dev->name);\n\n\t/*\n\t * Suspend/Resume resets the PCI configuration space, so we have to\n\t * re-disable the RETRY_TIMEOUT register (0x41) to keep PCI Tx retries\n\t * from interfering with C3 CPU state. pci_restore_state won't help\n\t * here since it only restores the first 64 bytes pci config header.\n\t */\n\tpci_read_config_dword(pdev, 0x40, &val);\n\tif ((val & 0x0000ff00) != 0)\n\t\tpci_write_config_dword(pdev, 0x40, val & 0xffff00ff);\n\n\t/* Set the device back into the PRESENT state; this will also wake\n\t * the queue of needed */\n\tnetif_device_attach(dev);\n\n\tpriv->suspend_time = ktime_get_boottime_seconds() - priv->suspend_at;\n\n\t/* Bring the device back up */\n\tschedule_work(&priv->up);\n\n\treturn 0;\n}\n\nstatic void ipw_pci_shutdown(struct pci_dev *pdev)\n{\n\tstruct ipw_priv *priv = pci_get_drvdata(pdev);\n\n\t/* Take down the device; powers it off, etc. */\n\tipw_down(priv);\n\n\tpci_disable_device(pdev);\n}\n\nstatic SIMPLE_DEV_PM_OPS(ipw_pci_pm_ops, ipw_pci_suspend, ipw_pci_resume);\n\n/* driver initialization stuff */\nstatic struct pci_driver ipw_driver = {\n\t.name = DRV_NAME,\n\t.id_table = card_ids,\n\t.probe = ipw_pci_probe,\n\t.remove = ipw_pci_remove,\n\t.driver.pm = &ipw_pci_pm_ops,\n\t.shutdown = ipw_pci_shutdown,\n};\n\nstatic int __init ipw_init(void)\n{\n\tint ret;\n\n\tprintk(KERN_INFO DRV_NAME \": \" DRV_DESCRIPTION \", \" DRV_VERSION \"\\n\");\n\tprintk(KERN_INFO DRV_NAME \": \" DRV_COPYRIGHT \"\\n\");\n\n\tret = pci_register_driver(&ipw_driver);\n\tif (ret) {\n\t\tIPW_ERROR(\"Unable to initialize PCI module\\n\");\n\t\treturn ret;\n\t}\n\n\tret = driver_create_file(&ipw_driver.driver, &driver_attr_debug_level);\n\tif (ret) {\n\t\tIPW_ERROR(\"Unable to create driver sysfs file\\n\");\n\t\tpci_unregister_driver(&ipw_driver);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit ipw_exit(void)\n{\n\tdriver_remove_file(&ipw_driver.driver, &driver_attr_debug_level);\n\tpci_unregister_driver(&ipw_driver);\n}\n\nmodule_param(disable, int, 0444);\nMODULE_PARM_DESC(disable, \"manually disable the radio (default 0 [radio on])\");\n\nmodule_param(associate, int, 0444);\nMODULE_PARM_DESC(associate, \"auto associate when scanning (default off)\");\n\nmodule_param(auto_create, int, 0444);\nMODULE_PARM_DESC(auto_create, \"auto create adhoc network (default on)\");\n\nmodule_param_named(led, led_support, int, 0444);\nMODULE_PARM_DESC(led, \"enable led control on some systems (default 1 on)\");\n\nmodule_param(debug, int, 0444);\nMODULE_PARM_DESC(debug, \"debug output mask\");\n\nmodule_param_named(channel, default_channel, int, 0444);\nMODULE_PARM_DESC(channel, \"channel to limit associate to (default 0 [ANY])\");\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\nmodule_param(rtap_iface, int, 0444);\nMODULE_PARM_DESC(rtap_iface, \"create the rtap interface (1 - create, default 0)\");\n#endif\n\n#ifdef CONFIG_IPW2200_QOS\nmodule_param(qos_enable, int, 0444);\nMODULE_PARM_DESC(qos_enable, \"enable all QoS functionalities\");\n\nmodule_param(qos_burst_enable, int, 0444);\nMODULE_PARM_DESC(qos_burst_enable, \"enable QoS burst mode\");\n\nmodule_param(qos_no_ack_mask, int, 0444);\nMODULE_PARM_DESC(qos_no_ack_mask, \"mask Tx_Queue to no ack\");\n\nmodule_param(burst_duration_CCK, int, 0444);\nMODULE_PARM_DESC(burst_duration_CCK, \"set CCK burst value\");\n\nmodule_param(burst_duration_OFDM, int, 0444);\nMODULE_PARM_DESC(burst_duration_OFDM, \"set OFDM burst value\");\n#endif\t\t\t\t/* CONFIG_IPW2200_QOS */\n\n#ifdef CONFIG_IPW2200_MONITOR\nmodule_param_named(mode, network_mode, int, 0444);\nMODULE_PARM_DESC(mode, \"network mode (0=BSS,1=IBSS,2=Monitor)\");\n#else\nmodule_param_named(mode, network_mode, int, 0444);\nMODULE_PARM_DESC(mode, \"network mode (0=BSS,1=IBSS)\");\n#endif\n\nmodule_param(bt_coexist, int, 0444);\nMODULE_PARM_DESC(bt_coexist, \"enable bluetooth coexistence (default off)\");\n\nmodule_param(hwcrypto, int, 0444);\nMODULE_PARM_DESC(hwcrypto, \"enable hardware crypto (default off)\");\n\nmodule_param(cmdlog, int, 0444);\nMODULE_PARM_DESC(cmdlog,\n\t\t \"allocate a ring buffer for logging firmware commands\");\n\nmodule_param(roaming, int, 0444);\nMODULE_PARM_DESC(roaming, \"enable roaming support (default on)\");\n\nmodule_param(antenna, int, 0444);\nMODULE_PARM_DESC(antenna, \"select antenna 1=Main, 3=Aux, default 0 [both], 2=slow_diversity (choose the one with lower background noise)\");\n\nmodule_exit(ipw_exit);\nmodule_init(ipw_init);\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 8311}, "message": "warn: inconsistent indenting"}], "macros": [], "notes": [], "path": "/src/drivers/net/wireless/intel/ipw2x00/ipw2200.c", "reportHash": "e7ebbef4030d17e44f34d2409ca8ab68", "checkerName": "smatch.check_indenting", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
