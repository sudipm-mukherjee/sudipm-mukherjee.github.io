<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/block/rbd.c", "content": "\n/*\n   rbd.c -- Export ceph rados objects as a Linux block device\n\n\n   based on drivers/block/osdblk.c:\n\n   Copyright 2009 Red Hat, Inc.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.  If not, write to\n   the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n\n\n\n   For usage instructions, please refer to:\n\n                 Documentation/ABI/testing/sysfs-bus-rbd\n\n */\n\n#include <linux/ceph/libceph.h>\n#include <linux/ceph/osd_client.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/cls_lock_client.h>\n#include <linux/ceph/striper.h>\n#include <linux/ceph/decode.h>\n#include <linux/fs_parser.h>\n#include <linux/bsearch.h>\n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/blk-mq.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/workqueue.h>\n\n#include \"rbd_types.h\"\n\n#define RBD_DEBUG\t/* Activate rbd_assert() calls */\n\n/*\n * Increment the given counter and return its updated value.\n * If the counter is already 0 it will not be incremented.\n * If the counter is already at its maximum value returns\n * -EINVAL without updating it.\n */\nstatic int atomic_inc_return_safe(atomic_t *v)\n{\n\tunsigned int counter;\n\n\tcounter = (unsigned int)atomic_fetch_add_unless(v, 1, 0);\n\tif (counter <= (unsigned int)INT_MAX)\n\t\treturn (int)counter;\n\n\tatomic_dec(v);\n\n\treturn -EINVAL;\n}\n\n/* Decrement the counter.  Return the resulting value, or -EINVAL */\nstatic int atomic_dec_return_safe(atomic_t *v)\n{\n\tint counter;\n\n\tcounter = atomic_dec_return(v);\n\tif (counter >= 0)\n\t\treturn counter;\n\n\tatomic_inc(v);\n\n\treturn -EINVAL;\n}\n\n#define RBD_DRV_NAME \"rbd\"\n\n#define RBD_MINORS_PER_MAJOR\t\t256\n#define RBD_SINGLE_MAJOR_PART_SHIFT\t4\n\n#define RBD_MAX_PARENT_CHAIN_LEN\t16\n\n#define RBD_SNAP_DEV_NAME_PREFIX\t\"snap_\"\n#define RBD_MAX_SNAP_NAME_LEN\t\\\n\t\t\t(NAME_MAX - (sizeof (RBD_SNAP_DEV_NAME_PREFIX) - 1))\n\n#define RBD_MAX_SNAP_COUNT\t510\t/* allows max snapc to fit in 4KB */\n\n#define RBD_SNAP_HEAD_NAME\t\"-\"\n\n#define\tBAD_SNAP_INDEX\tU32_MAX\t\t/* invalid index into snap array */\n\n/* This allows a single page to hold an image name sent by OSD */\n#define RBD_IMAGE_NAME_LEN_MAX\t(PAGE_SIZE - sizeof (__le32) - 1)\n#define RBD_IMAGE_ID_LEN_MAX\t64\n\n#define RBD_OBJ_PREFIX_LEN_MAX\t64\n\n#define RBD_NOTIFY_TIMEOUT\t5\t/* seconds */\n#define RBD_RETRY_DELAY\t\tmsecs_to_jiffies(1000)\n\n/* Feature bits */\n\n#define RBD_FEATURE_LAYERING\t\t(1ULL<<0)\n#define RBD_FEATURE_STRIPINGV2\t\t(1ULL<<1)\n#define RBD_FEATURE_EXCLUSIVE_LOCK\t(1ULL<<2)\n#define RBD_FEATURE_OBJECT_MAP\t\t(1ULL<<3)\n#define RBD_FEATURE_FAST_DIFF\t\t(1ULL<<4)\n#define RBD_FEATURE_DEEP_FLATTEN\t(1ULL<<5)\n#define RBD_FEATURE_DATA_POOL\t\t(1ULL<<7)\n#define RBD_FEATURE_OPERATIONS\t\t(1ULL<<8)\n\n#define RBD_FEATURES_ALL\t(RBD_FEATURE_LAYERING |\t\t\\\n\t\t\t\t RBD_FEATURE_STRIPINGV2 |\t\\\n\t\t\t\t RBD_FEATURE_EXCLUSIVE_LOCK |\t\\\n\t\t\t\t RBD_FEATURE_OBJECT_MAP |\t\\\n\t\t\t\t RBD_FEATURE_FAST_DIFF |\t\\\n\t\t\t\t RBD_FEATURE_DEEP_FLATTEN |\t\\\n\t\t\t\t RBD_FEATURE_DATA_POOL |\t\\\n\t\t\t\t RBD_FEATURE_OPERATIONS)\n\n/* Features supported by this (client software) implementation. */\n\n#define RBD_FEATURES_SUPPORTED\t(RBD_FEATURES_ALL)\n\n/*\n * An RBD device name will be \"rbd#\", where the \"rbd\" comes from\n * RBD_DRV_NAME above, and # is a unique integer identifier.\n */\n#define DEV_NAME_LEN\t\t32\n\n/*\n * block device image metadata (in-memory version)\n */\nstruct rbd_image_header {\n\t/* These six fields never change for a given rbd image */\n\tchar *object_prefix;\n\t__u8 obj_order;\n\tu64 stripe_unit;\n\tu64 stripe_count;\n\ts64 data_pool_id;\n\tu64 features;\t\t/* Might be changeable someday? */\n\n\t/* The remaining fields need to be updated occasionally */\n\tu64 image_size;\n\tstruct ceph_snap_context *snapc;\n\tchar *snap_names;\t/* format 1 only */\n\tu64 *snap_sizes;\t/* format 1 only */\n};\n\n/*\n * An rbd image specification.\n *\n * The tuple (pool_id, image_id, snap_id) is sufficient to uniquely\n * identify an image.  Each rbd_dev structure includes a pointer to\n * an rbd_spec structure that encapsulates this identity.\n *\n * Each of the id's in an rbd_spec has an associated name.  For a\n * user-mapped image, the names are supplied and the id's associated\n * with them are looked up.  For a layered image, a parent image is\n * defined by the tuple, and the names are looked up.\n *\n * An rbd_dev structure contains a parent_spec pointer which is\n * non-null if the image it represents is a child in a layered\n * image.  This pointer will refer to the rbd_spec structure used\n * by the parent rbd_dev for its own identity (i.e., the structure\n * is shared between the parent and child).\n *\n * Since these structures are populated once, during the discovery\n * phase of image construction, they are effectively immutable so\n * we make no effort to synchronize access to them.\n *\n * Note that code herein does not assume the image name is known (it\n * could be a null pointer).\n */\nstruct rbd_spec {\n\tu64\t\tpool_id;\n\tconst char\t*pool_name;\n\tconst char\t*pool_ns;\t/* NULL if default, never \"\" */\n\n\tconst char\t*image_id;\n\tconst char\t*image_name;\n\n\tu64\t\tsnap_id;\n\tconst char\t*snap_name;\n\n\tstruct kref\tkref;\n};\n\n/*\n * an instance of the client.  multiple devices may share an rbd client.\n */\nstruct rbd_client {\n\tstruct ceph_client\t*client;\n\tstruct kref\t\tkref;\n\tstruct list_head\tnode;\n};\n\nstruct pending_result {\n\tint\t\t\tresult;\t\t/* first nonzero result */\n\tint\t\t\tnum_pending;\n};\n\nstruct rbd_img_request;\n\nenum obj_request_type {\n\tOBJ_REQUEST_NODATA = 1,\n\tOBJ_REQUEST_BIO,\t/* pointer into provided bio (list) */\n\tOBJ_REQUEST_BVECS,\t/* pointer into provided bio_vec array */\n\tOBJ_REQUEST_OWN_BVECS,\t/* private bio_vec array, doesn't own pages */\n};\n\nenum obj_operation_type {\n\tOBJ_OP_READ = 1,\n\tOBJ_OP_WRITE,\n\tOBJ_OP_DISCARD,\n\tOBJ_OP_ZEROOUT,\n};\n\n#define RBD_OBJ_FLAG_DELETION\t\t\t(1U << 0)\n#define RBD_OBJ_FLAG_COPYUP_ENABLED\t\t(1U << 1)\n#define RBD_OBJ_FLAG_COPYUP_ZEROS\t\t(1U << 2)\n#define RBD_OBJ_FLAG_MAY_EXIST\t\t\t(1U << 3)\n#define RBD_OBJ_FLAG_NOOP_FOR_NONEXISTENT\t(1U << 4)\n\nenum rbd_obj_read_state {\n\tRBD_OBJ_READ_START = 1,\n\tRBD_OBJ_READ_OBJECT,\n\tRBD_OBJ_READ_PARENT,\n};\n\n/*\n * Writes go through the following state machine to deal with\n * layering:\n *\n *            . . . . . RBD_OBJ_WRITE_GUARD. . . . . . . . . . . . . .\n *            .                 |                                    .\n *            .                 v                                    .\n *            .    RBD_OBJ_WRITE_READ_FROM_PARENT. . .               .\n *            .                 |                    .               .\n *            .                 v                    v (deep-copyup  .\n *    (image  .   RBD_OBJ_WRITE_COPYUP_EMPTY_SNAPC   .  not needed)  .\n * flattened) v                 |                    .               .\n *            .                 v                    .               .\n *            . . . .RBD_OBJ_WRITE_COPYUP_OPS. . . . .      (copyup  .\n *                              |                        not needed) v\n *                              v                                    .\n *                            done . . . . . . . . . . . . . . . . . .\n *                              ^\n *                              |\n *                     RBD_OBJ_WRITE_FLAT\n *\n * Writes start in RBD_OBJ_WRITE_GUARD or _FLAT, depending on whether\n * assert_exists guard is needed or not (in some cases it's not needed\n * even if there is a parent).\n */\nenum rbd_obj_write_state {\n\tRBD_OBJ_WRITE_START = 1,\n\tRBD_OBJ_WRITE_PRE_OBJECT_MAP,\n\tRBD_OBJ_WRITE_OBJECT,\n\t__RBD_OBJ_WRITE_COPYUP,\n\tRBD_OBJ_WRITE_COPYUP,\n\tRBD_OBJ_WRITE_POST_OBJECT_MAP,\n};\n\nenum rbd_obj_copyup_state {\n\tRBD_OBJ_COPYUP_START = 1,\n\tRBD_OBJ_COPYUP_READ_PARENT,\n\t__RBD_OBJ_COPYUP_OBJECT_MAPS,\n\tRBD_OBJ_COPYUP_OBJECT_MAPS,\n\t__RBD_OBJ_COPYUP_WRITE_OBJECT,\n\tRBD_OBJ_COPYUP_WRITE_OBJECT,\n};\n\nstruct rbd_obj_request {\n\tstruct ceph_object_extent ex;\n\tunsigned int\t\tflags;\t/* RBD_OBJ_FLAG_* */\n\tunion {\n\t\tenum rbd_obj_read_state\t read_state;\t/* for reads */\n\t\tenum rbd_obj_write_state write_state;\t/* for writes */\n\t};\n\n\tstruct rbd_img_request\t*img_request;\n\tstruct ceph_file_extent\t*img_extents;\n\tu32\t\t\tnum_img_extents;\n\n\tunion {\n\t\tstruct ceph_bio_iter\tbio_pos;\n\t\tstruct {\n\t\t\tstruct ceph_bvec_iter\tbvec_pos;\n\t\t\tu32\t\t\tbvec_count;\n\t\t\tu32\t\t\tbvec_idx;\n\t\t};\n\t};\n\n\tenum rbd_obj_copyup_state copyup_state;\n\tstruct bio_vec\t\t*copyup_bvecs;\n\tu32\t\t\tcopyup_bvec_count;\n\n\tstruct list_head\tosd_reqs;\t/* w/ r_private_item */\n\n\tstruct mutex\t\tstate_mutex;\n\tstruct pending_result\tpending;\n\tstruct kref\t\tkref;\n};\n\nenum img_req_flags {\n\tIMG_REQ_CHILD,\t\t/* initiator: block = 0, child image = 1 */\n\tIMG_REQ_LAYERED,\t/* ENOENT handling: normal = 0, layered = 1 */\n};\n\nenum rbd_img_state {\n\tRBD_IMG_START = 1,\n\tRBD_IMG_EXCLUSIVE_LOCK,\n\t__RBD_IMG_OBJECT_REQUESTS,\n\tRBD_IMG_OBJECT_REQUESTS,\n};\n\nstruct rbd_img_request {\n\tstruct rbd_device\t*rbd_dev;\n\tenum obj_operation_type\top_type;\n\tenum obj_request_type\tdata_type;\n\tunsigned long\t\tflags;\n\tenum rbd_img_state\tstate;\n\tunion {\n\t\tu64\t\t\tsnap_id;\t/* for reads */\n\t\tstruct ceph_snap_context *snapc;\t/* for writes */\n\t};\n\tstruct rbd_obj_request\t*obj_request;\t/* obj req initiator */\n\n\tstruct list_head\tlock_item;\n\tstruct list_head\tobject_extents;\t/* obj_req.ex structs */\n\n\tstruct mutex\t\tstate_mutex;\n\tstruct pending_result\tpending;\n\tstruct work_struct\twork;\n\tint\t\t\twork_result;\n};\n\n#define for_each_obj_request(ireq, oreq) \\\n\tlist_for_each_entry(oreq, &(ireq)->object_extents, ex.oe_item)\n#define for_each_obj_request_safe(ireq, oreq, n) \\\n\tlist_for_each_entry_safe(oreq, n, &(ireq)->object_extents, ex.oe_item)\n\nenum rbd_watch_state {\n\tRBD_WATCH_STATE_UNREGISTERED,\n\tRBD_WATCH_STATE_REGISTERED,\n\tRBD_WATCH_STATE_ERROR,\n};\n\nenum rbd_lock_state {\n\tRBD_LOCK_STATE_UNLOCKED,\n\tRBD_LOCK_STATE_LOCKED,\n\tRBD_LOCK_STATE_RELEASING,\n};\n\n/* WatchNotify::ClientId */\nstruct rbd_client_id {\n\tu64 gid;\n\tu64 handle;\n};\n\nstruct rbd_mapping {\n\tu64                     size;\n};\n\n/*\n * a single device\n */\nstruct rbd_device {\n\tint\t\t\tdev_id;\t\t/* blkdev unique id */\n\n\tint\t\t\tmajor;\t\t/* blkdev assigned major */\n\tint\t\t\tminor;\n\tstruct gendisk\t\t*disk;\t\t/* blkdev's gendisk and rq */\n\n\tu32\t\t\timage_format;\t/* Either 1 or 2 */\n\tstruct rbd_client\t*rbd_client;\n\n\tchar\t\t\tname[DEV_NAME_LEN]; /* blkdev name, e.g. rbd3 */\n\n\tspinlock_t\t\tlock;\t\t/* queue, flags, open_count */\n\n\tstruct rbd_image_header\theader;\n\tunsigned long\t\tflags;\t\t/* possibly lock protected */\n\tstruct rbd_spec\t\t*spec;\n\tstruct rbd_options\t*opts;\n\tchar\t\t\t*config_info;\t/* add{,_single_major} string */\n\n\tstruct ceph_object_id\theader_oid;\n\tstruct ceph_object_locator header_oloc;\n\n\tstruct ceph_file_layout\tlayout;\t\t/* used for all rbd requests */\n\n\tstruct mutex\t\twatch_mutex;\n\tenum rbd_watch_state\twatch_state;\n\tstruct ceph_osd_linger_request *watch_handle;\n\tu64\t\t\twatch_cookie;\n\tstruct delayed_work\twatch_dwork;\n\n\tstruct rw_semaphore\tlock_rwsem;\n\tenum rbd_lock_state\tlock_state;\n\tchar\t\t\tlock_cookie[32];\n\tstruct rbd_client_id\towner_cid;\n\tstruct work_struct\tacquired_lock_work;\n\tstruct work_struct\treleased_lock_work;\n\tstruct delayed_work\tlock_dwork;\n\tstruct work_struct\tunlock_work;\n\tspinlock_t\t\tlock_lists_lock;\n\tstruct list_head\tacquiring_list;\n\tstruct list_head\trunning_list;\n\tstruct completion\tacquire_wait;\n\tint\t\t\tacquire_err;\n\tstruct completion\treleasing_wait;\n\n\tspinlock_t\t\tobject_map_lock;\n\tu8\t\t\t*object_map;\n\tu64\t\t\tobject_map_size;\t/* in objects */\n\tu64\t\t\tobject_map_flags;\n\n\tstruct workqueue_struct\t*task_wq;\n\n\tstruct rbd_spec\t\t*parent_spec;\n\tu64\t\t\tparent_overlap;\n\tatomic_t\t\tparent_ref;\n\tstruct rbd_device\t*parent;\n\n\t/* Block layer tags. */\n\tstruct blk_mq_tag_set\ttag_set;\n\n\t/* protects updating the header */\n\tstruct rw_semaphore     header_rwsem;\n\n\tstruct rbd_mapping\tmapping;\n\n\tstruct list_head\tnode;\n\n\t/* sysfs related */\n\tstruct device\t\tdev;\n\tunsigned long\t\topen_count;\t/* protected by lock */\n};\n\n/*\n * Flag bits for rbd_dev->flags:\n * - REMOVING (which is coupled with rbd_dev->open_count) is protected\n *   by rbd_dev->lock\n */\nenum rbd_dev_flags {\n\tRBD_DEV_FLAG_EXISTS,\t/* rbd_dev_device_setup() ran */\n\tRBD_DEV_FLAG_REMOVING,\t/* this mapping is being removed */\n\tRBD_DEV_FLAG_READONLY,  /* -o ro or snapshot */\n};\n\nstatic DEFINE_MUTEX(client_mutex);\t/* Serialize client creation */\n\nstatic LIST_HEAD(rbd_dev_list);    /* devices */\nstatic DEFINE_SPINLOCK(rbd_dev_list_lock);\n\nstatic LIST_HEAD(rbd_client_list);\t\t/* clients */\nstatic DEFINE_SPINLOCK(rbd_client_list_lock);\n\n/* Slab caches for frequently-allocated structures */\n\nstatic struct kmem_cache\t*rbd_img_request_cache;\nstatic struct kmem_cache\t*rbd_obj_request_cache;\n\nstatic int rbd_major;\nstatic DEFINE_IDA(rbd_dev_id_ida);\n\nstatic struct workqueue_struct *rbd_wq;\n\nstatic struct ceph_snap_context rbd_empty_snapc = {\n\t.nref = REFCOUNT_INIT(1),\n};\n\n/*\n * single-major requires >= 0.75 version of userspace rbd utility.\n */\nstatic bool single_major = true;\nmodule_param(single_major, bool, 0444);\nMODULE_PARM_DESC(single_major, \"Use a single major number for all rbd devices (default: true)\");\n\nstatic ssize_t add_store(struct bus_type *bus, const char *buf, size_t count);\nstatic ssize_t remove_store(struct bus_type *bus, const char *buf,\n\t\t\t    size_t count);\nstatic ssize_t add_single_major_store(struct bus_type *bus, const char *buf,\n\t\t\t\t      size_t count);\nstatic ssize_t remove_single_major_store(struct bus_type *bus, const char *buf,\n\t\t\t\t\t size_t count);\nstatic int rbd_dev_image_probe(struct rbd_device *rbd_dev, int depth);\n\nstatic int rbd_dev_id_to_minor(int dev_id)\n{\n\treturn dev_id << RBD_SINGLE_MAJOR_PART_SHIFT;\n}\n\nstatic int minor_to_rbd_dev_id(int minor)\n{\n\treturn minor >> RBD_SINGLE_MAJOR_PART_SHIFT;\n}\n\nstatic bool rbd_is_ro(struct rbd_device *rbd_dev)\n{\n\treturn test_bit(RBD_DEV_FLAG_READONLY, &rbd_dev->flags);\n}\n\nstatic bool rbd_is_snap(struct rbd_device *rbd_dev)\n{\n\treturn rbd_dev->spec->snap_id != CEPH_NOSNAP;\n}\n\nstatic bool __rbd_is_lock_owner(struct rbd_device *rbd_dev)\n{\n\tlockdep_assert_held(&rbd_dev->lock_rwsem);\n\n\treturn rbd_dev->lock_state == RBD_LOCK_STATE_LOCKED ||\n\t       rbd_dev->lock_state == RBD_LOCK_STATE_RELEASING;\n}\n\nstatic bool rbd_is_lock_owner(struct rbd_device *rbd_dev)\n{\n\tbool is_lock_owner;\n\n\tdown_read(&rbd_dev->lock_rwsem);\n\tis_lock_owner = __rbd_is_lock_owner(rbd_dev);\n\tup_read(&rbd_dev->lock_rwsem);\n\treturn is_lock_owner;\n}\n\nstatic ssize_t supported_features_show(struct bus_type *bus, char *buf)\n{\n\treturn sprintf(buf, \"0x%llx\\n\", RBD_FEATURES_SUPPORTED);\n}\n\nstatic BUS_ATTR_WO(add);\nstatic BUS_ATTR_WO(remove);\nstatic BUS_ATTR_WO(add_single_major);\nstatic BUS_ATTR_WO(remove_single_major);\nstatic BUS_ATTR_RO(supported_features);\n\nstatic struct attribute *rbd_bus_attrs[] = {\n\t&bus_attr_add.attr,\n\t&bus_attr_remove.attr,\n\t&bus_attr_add_single_major.attr,\n\t&bus_attr_remove_single_major.attr,\n\t&bus_attr_supported_features.attr,\n\tNULL,\n};\n\nstatic umode_t rbd_bus_is_visible(struct kobject *kobj,\n\t\t\t\t  struct attribute *attr, int index)\n{\n\tif (!single_major &&\n\t    (attr == &bus_attr_add_single_major.attr ||\n\t     attr == &bus_attr_remove_single_major.attr))\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group rbd_bus_group = {\n\t.attrs = rbd_bus_attrs,\n\t.is_visible = rbd_bus_is_visible,\n};\n__ATTRIBUTE_GROUPS(rbd_bus);\n\nstatic struct bus_type rbd_bus_type = {\n\t.name\t\t= \"rbd\",\n\t.bus_groups\t= rbd_bus_groups,\n};\n\nstatic void rbd_root_dev_release(struct device *dev)\n{\n}\n\nstatic struct device rbd_root_dev = {\n\t.init_name =    \"rbd\",\n\t.release =      rbd_root_dev_release,\n};\n\nstatic __printf(2, 3)\nvoid rbd_warn(struct rbd_device *rbd_dev, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (!rbd_dev)\n\t\tprintk(KERN_WARNING \"%s: %pV\\n\", RBD_DRV_NAME, &vaf);\n\telse if (rbd_dev->disk)\n\t\tprintk(KERN_WARNING \"%s: %s: %pV\\n\",\n\t\t\tRBD_DRV_NAME, rbd_dev->disk->disk_name, &vaf);\n\telse if (rbd_dev->spec && rbd_dev->spec->image_name)\n\t\tprintk(KERN_WARNING \"%s: image %s: %pV\\n\",\n\t\t\tRBD_DRV_NAME, rbd_dev->spec->image_name, &vaf);\n\telse if (rbd_dev->spec && rbd_dev->spec->image_id)\n\t\tprintk(KERN_WARNING \"%s: id %s: %pV\\n\",\n\t\t\tRBD_DRV_NAME, rbd_dev->spec->image_id, &vaf);\n\telse\t/* punt */\n\t\tprintk(KERN_WARNING \"%s: rbd_dev %p: %pV\\n\",\n\t\t\tRBD_DRV_NAME, rbd_dev, &vaf);\n\tva_end(args);\n}\n\n#ifdef RBD_DEBUG\n#define rbd_assert(expr)\t\t\t\t\t\t\\\n\t\tif (unlikely(!(expr))) {\t\t\t\t\\\n\t\t\tprintk(KERN_ERR \"\\nAssertion failure in %s() \"\t\\\n\t\t\t\t\t\t\"at line %d:\\n\\n\"\t\\\n\t\t\t\t\t\"\\trbd_assert(%s);\\n\\n\",\t\\\n\t\t\t\t\t__func__, __LINE__, #expr);\t\\\n\t\t\tBUG();\t\t\t\t\t\t\\\n\t\t}\n#else /* !RBD_DEBUG */\n#  define rbd_assert(expr)\t((void) 0)\n#endif /* !RBD_DEBUG */\n\nstatic void rbd_dev_remove_parent(struct rbd_device *rbd_dev);\n\nstatic int rbd_dev_refresh(struct rbd_device *rbd_dev);\nstatic int rbd_dev_v2_header_onetime(struct rbd_device *rbd_dev);\nstatic int rbd_dev_header_info(struct rbd_device *rbd_dev);\nstatic int rbd_dev_v2_parent_info(struct rbd_device *rbd_dev);\nstatic const char *rbd_dev_v2_snap_name(struct rbd_device *rbd_dev,\n\t\t\t\t\tu64 snap_id);\nstatic int _rbd_dev_v2_snap_size(struct rbd_device *rbd_dev, u64 snap_id,\n\t\t\t\tu8 *order, u64 *snap_size);\nstatic int rbd_dev_v2_get_flags(struct rbd_device *rbd_dev);\n\nstatic void rbd_obj_handle_request(struct rbd_obj_request *obj_req, int result);\nstatic void rbd_img_handle_request(struct rbd_img_request *img_req, int result);\n\n/*\n * Return true if nothing else is pending.\n */\nstatic bool pending_result_dec(struct pending_result *pending, int *result)\n{\n\trbd_assert(pending->num_pending > 0);\n\n\tif (*result && !pending->result)\n\t\tpending->result = *result;\n\tif (--pending->num_pending)\n\t\treturn false;\n\n\t*result = pending->result;\n\treturn true;\n}\n\nstatic int rbd_open(struct block_device *bdev, fmode_t mode)\n{\n\tstruct rbd_device *rbd_dev = bdev->bd_disk->private_data;\n\tbool removing = false;\n\n\tspin_lock_irq(&rbd_dev->lock);\n\tif (test_bit(RBD_DEV_FLAG_REMOVING, &rbd_dev->flags))\n\t\tremoving = true;\n\telse\n\t\trbd_dev->open_count++;\n\tspin_unlock_irq(&rbd_dev->lock);\n\tif (removing)\n\t\treturn -ENOENT;\n\n\t(void) get_device(&rbd_dev->dev);\n\n\treturn 0;\n}\n\nstatic void rbd_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct rbd_device *rbd_dev = disk->private_data;\n\tunsigned long open_count_before;\n\n\tspin_lock_irq(&rbd_dev->lock);\n\topen_count_before = rbd_dev->open_count--;\n\tspin_unlock_irq(&rbd_dev->lock);\n\trbd_assert(open_count_before > 0);\n\n\tput_device(&rbd_dev->dev);\n}\n\nstatic int rbd_set_read_only(struct block_device *bdev, bool ro)\n{\n\tstruct rbd_device *rbd_dev = bdev->bd_disk->private_data;\n\n\t/*\n\t * Both images mapped read-only and snapshots can't be marked\n\t * read-write.\n\t */\n\tif (!ro) {\n\t\tif (rbd_is_ro(rbd_dev))\n\t\t\treturn -EROFS;\n\n\t\trbd_assert(!rbd_is_snap(rbd_dev));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct block_device_operations rbd_bd_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= rbd_open,\n\t.release\t\t= rbd_release,\n\t.set_read_only\t\t= rbd_set_read_only,\n};\n\n/*\n * Initialize an rbd client instance.  Success or not, this function\n * consumes ceph_opts.  Caller holds client_mutex.\n */\nstatic struct rbd_client *rbd_client_create(struct ceph_options *ceph_opts)\n{\n\tstruct rbd_client *rbdc;\n\tint ret = -ENOMEM;\n\n\tdout(\"%s:\\n\", __func__);\n\trbdc = kmalloc(sizeof(struct rbd_client), GFP_KERNEL);\n\tif (!rbdc)\n\t\tgoto out_opt;\n\n\tkref_init(&rbdc->kref);\n\tINIT_LIST_HEAD(&rbdc->node);\n\n\trbdc->client = ceph_create_client(ceph_opts, rbdc);\n\tif (IS_ERR(rbdc->client))\n\t\tgoto out_rbdc;\n\tceph_opts = NULL; /* Now rbdc->client is responsible for ceph_opts */\n\n\tret = ceph_open_session(rbdc->client);\n\tif (ret < 0)\n\t\tgoto out_client;\n\n\tspin_lock(&rbd_client_list_lock);\n\tlist_add_tail(&rbdc->node, &rbd_client_list);\n\tspin_unlock(&rbd_client_list_lock);\n\n\tdout(\"%s: rbdc %p\\n\", __func__, rbdc);\n\n\treturn rbdc;\nout_client:\n\tceph_destroy_client(rbdc->client);\nout_rbdc:\n\tkfree(rbdc);\nout_opt:\n\tif (ceph_opts)\n\t\tceph_destroy_options(ceph_opts);\n\tdout(\"%s: error %d\\n\", __func__, ret);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic struct rbd_client *__rbd_get_client(struct rbd_client *rbdc)\n{\n\tkref_get(&rbdc->kref);\n\n\treturn rbdc;\n}\n\n/*\n * Find a ceph client with specific addr and configuration.  If\n * found, bump its reference count.\n */\nstatic struct rbd_client *rbd_client_find(struct ceph_options *ceph_opts)\n{\n\tstruct rbd_client *client_node;\n\tbool found = false;\n\n\tif (ceph_opts->flags & CEPH_OPT_NOSHARE)\n\t\treturn NULL;\n\n\tspin_lock(&rbd_client_list_lock);\n\tlist_for_each_entry(client_node, &rbd_client_list, node) {\n\t\tif (!ceph_compare_options(ceph_opts, client_node->client)) {\n\t\t\t__rbd_get_client(client_node);\n\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&rbd_client_list_lock);\n\n\treturn found ? client_node : NULL;\n}\n\n/*\n * (Per device) rbd map options\n */\nenum {\n\tOpt_queue_depth,\n\tOpt_alloc_size,\n\tOpt_lock_timeout,\n\t/* int args above */\n\tOpt_pool_ns,\n\tOpt_compression_hint,\n\t/* string args above */\n\tOpt_read_only,\n\tOpt_read_write,\n\tOpt_lock_on_read,\n\tOpt_exclusive,\n\tOpt_notrim,\n};\n\nenum {\n\tOpt_compression_hint_none,\n\tOpt_compression_hint_compressible,\n\tOpt_compression_hint_incompressible,\n};\n\nstatic const struct constant_table rbd_param_compression_hint[] = {\n\t{\"none\",\t\tOpt_compression_hint_none},\n\t{\"compressible\",\tOpt_compression_hint_compressible},\n\t{\"incompressible\",\tOpt_compression_hint_incompressible},\n\t{}\n};\n\nstatic const struct fs_parameter_spec rbd_parameters[] = {\n\tfsparam_u32\t(\"alloc_size\",\t\t\tOpt_alloc_size),\n\tfsparam_enum\t(\"compression_hint\",\t\tOpt_compression_hint,\n\t\t\t rbd_param_compression_hint),\n\tfsparam_flag\t(\"exclusive\",\t\t\tOpt_exclusive),\n\tfsparam_flag\t(\"lock_on_read\",\t\tOpt_lock_on_read),\n\tfsparam_u32\t(\"lock_timeout\",\t\tOpt_lock_timeout),\n\tfsparam_flag\t(\"notrim\",\t\t\tOpt_notrim),\n\tfsparam_string\t(\"_pool_ns\",\t\t\tOpt_pool_ns),\n\tfsparam_u32\t(\"queue_depth\",\t\t\tOpt_queue_depth),\n\tfsparam_flag\t(\"read_only\",\t\t\tOpt_read_only),\n\tfsparam_flag\t(\"read_write\",\t\t\tOpt_read_write),\n\tfsparam_flag\t(\"ro\",\t\t\t\tOpt_read_only),\n\tfsparam_flag\t(\"rw\",\t\t\t\tOpt_read_write),\n\t{}\n};\n\nstruct rbd_options {\n\tint\tqueue_depth;\n\tint\talloc_size;\n\tunsigned long\tlock_timeout;\n\tbool\tread_only;\n\tbool\tlock_on_read;\n\tbool\texclusive;\n\tbool\ttrim;\n\n\tu32 alloc_hint_flags;  /* CEPH_OSD_OP_ALLOC_HINT_FLAG_* */\n};\n\n#define RBD_QUEUE_DEPTH_DEFAULT\tBLKDEV_MAX_RQ\n#define RBD_ALLOC_SIZE_DEFAULT\t(64 * 1024)\n#define RBD_LOCK_TIMEOUT_DEFAULT 0  /* no timeout */\n#define RBD_READ_ONLY_DEFAULT\tfalse\n#define RBD_LOCK_ON_READ_DEFAULT false\n#define RBD_EXCLUSIVE_DEFAULT\tfalse\n#define RBD_TRIM_DEFAULT\ttrue\n\nstruct rbd_parse_opts_ctx {\n\tstruct rbd_spec\t\t*spec;\n\tstruct ceph_options\t*copts;\n\tstruct rbd_options\t*opts;\n};\n\nstatic char* obj_op_name(enum obj_operation_type op_type)\n{\n\tswitch (op_type) {\n\tcase OBJ_OP_READ:\n\t\treturn \"read\";\n\tcase OBJ_OP_WRITE:\n\t\treturn \"write\";\n\tcase OBJ_OP_DISCARD:\n\t\treturn \"discard\";\n\tcase OBJ_OP_ZEROOUT:\n\t\treturn \"zeroout\";\n\tdefault:\n\t\treturn \"???\";\n\t}\n}\n\n/*\n * Destroy ceph client\n *\n * Caller must hold rbd_client_list_lock.\n */\nstatic void rbd_client_release(struct kref *kref)\n{\n\tstruct rbd_client *rbdc = container_of(kref, struct rbd_client, kref);\n\n\tdout(\"%s: rbdc %p\\n\", __func__, rbdc);\n\tspin_lock(&rbd_client_list_lock);\n\tlist_del(&rbdc->node);\n\tspin_unlock(&rbd_client_list_lock);\n\n\tceph_destroy_client(rbdc->client);\n\tkfree(rbdc);\n}\n\n/*\n * Drop reference to ceph client node. If it's not referenced anymore, release\n * it.\n */\nstatic void rbd_put_client(struct rbd_client *rbdc)\n{\n\tif (rbdc)\n\t\tkref_put(&rbdc->kref, rbd_client_release);\n}\n\n/*\n * Get a ceph client with specific addr and configuration, if one does\n * not exist create it.  Either way, ceph_opts is consumed by this\n * function.\n */\nstatic struct rbd_client *rbd_get_client(struct ceph_options *ceph_opts)\n{\n\tstruct rbd_client *rbdc;\n\tint ret;\n\n\tmutex_lock(&client_mutex);\n\trbdc = rbd_client_find(ceph_opts);\n\tif (rbdc) {\n\t\tceph_destroy_options(ceph_opts);\n\n\t\t/*\n\t\t * Using an existing client.  Make sure ->pg_pools is up to\n\t\t * date before we look up the pool id in do_rbd_add().\n\t\t */\n\t\tret = ceph_wait_for_latest_osdmap(rbdc->client,\n\t\t\t\t\trbdc->client->options->mount_timeout);\n\t\tif (ret) {\n\t\t\trbd_warn(NULL, \"failed to get latest osdmap: %d\", ret);\n\t\t\trbd_put_client(rbdc);\n\t\t\trbdc = ERR_PTR(ret);\n\t\t}\n\t} else {\n\t\trbdc = rbd_client_create(ceph_opts);\n\t}\n\tmutex_unlock(&client_mutex);\n\n\treturn rbdc;\n}\n\nstatic bool rbd_image_format_valid(u32 image_format)\n{\n\treturn image_format == 1 || image_format == 2;\n}\n\nstatic bool rbd_dev_ondisk_valid(struct rbd_image_header_ondisk *ondisk)\n{\n\tsize_t size;\n\tu32 snap_count;\n\n\t/* The header has to start with the magic rbd header text */\n\tif (memcmp(&ondisk->text, RBD_HEADER_TEXT, sizeof (RBD_HEADER_TEXT)))\n\t\treturn false;\n\n\t/* The bio layer requires at least sector-sized I/O */\n\n\tif (ondisk->options.order < SECTOR_SHIFT)\n\t\treturn false;\n\n\t/* If we use u64 in a few spots we may be able to loosen this */\n\n\tif (ondisk->options.order > 8 * sizeof (int) - 1)\n\t\treturn false;\n\n\t/*\n\t * The size of a snapshot header has to fit in a size_t, and\n\t * that limits the number of snapshots.\n\t */\n\tsnap_count = le32_to_cpu(ondisk->snap_count);\n\tsize = SIZE_MAX - sizeof (struct ceph_snap_context);\n\tif (snap_count > size / sizeof (__le64))\n\t\treturn false;\n\n\t/*\n\t * Not only that, but the size of the entire the snapshot\n\t * header must also be representable in a size_t.\n\t */\n\tsize -= snap_count * sizeof (__le64);\n\tif ((u64) size < le64_to_cpu(ondisk->snap_names_len))\n\t\treturn false;\n\n\treturn true;\n}\n\n/*\n * returns the size of an object in the image\n */\nstatic u32 rbd_obj_bytes(struct rbd_image_header *header)\n{\n\treturn 1U << header->obj_order;\n}\n\nstatic void rbd_init_layout(struct rbd_device *rbd_dev)\n{\n\tif (rbd_dev->header.stripe_unit == 0 ||\n\t    rbd_dev->header.stripe_count == 0) {\n\t\trbd_dev->header.stripe_unit = rbd_obj_bytes(&rbd_dev->header);\n\t\trbd_dev->header.stripe_count = 1;\n\t}\n\n\trbd_dev->layout.stripe_unit = rbd_dev->header.stripe_unit;\n\trbd_dev->layout.stripe_count = rbd_dev->header.stripe_count;\n\trbd_dev->layout.object_size = rbd_obj_bytes(&rbd_dev->header);\n\trbd_dev->layout.pool_id = rbd_dev->header.data_pool_id == CEPH_NOPOOL ?\n\t\t\t  rbd_dev->spec->pool_id : rbd_dev->header.data_pool_id;\n\tRCU_INIT_POINTER(rbd_dev->layout.pool_ns, NULL);\n}\n\n/*\n * Fill an rbd image header with information from the given format 1\n * on-disk header.\n */\nstatic int rbd_header_from_disk(struct rbd_device *rbd_dev,\n\t\t\t\t struct rbd_image_header_ondisk *ondisk)\n{\n\tstruct rbd_image_header *header = &rbd_dev->header;\n\tbool first_time = header->object_prefix == NULL;\n\tstruct ceph_snap_context *snapc;\n\tchar *object_prefix = NULL;\n\tchar *snap_names = NULL;\n\tu64 *snap_sizes = NULL;\n\tu32 snap_count;\n\tint ret = -ENOMEM;\n\tu32 i;\n\n\t/* Allocate this now to avoid having to handle failure below */\n\n\tif (first_time) {\n\t\tobject_prefix = kstrndup(ondisk->object_prefix,\n\t\t\t\t\t sizeof(ondisk->object_prefix),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!object_prefix)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Allocate the snapshot context and fill it in */\n\n\tsnap_count = le32_to_cpu(ondisk->snap_count);\n\tsnapc = ceph_create_snap_context(snap_count, GFP_KERNEL);\n\tif (!snapc)\n\t\tgoto out_err;\n\tsnapc->seq = le64_to_cpu(ondisk->snap_seq);\n\tif (snap_count) {\n\t\tstruct rbd_image_snap_ondisk *snaps;\n\t\tu64 snap_names_len = le64_to_cpu(ondisk->snap_names_len);\n\n\t\t/* We'll keep a copy of the snapshot names... */\n\n\t\tif (snap_names_len > (u64)SIZE_MAX)\n\t\t\tgoto out_2big;\n\t\tsnap_names = kmalloc(snap_names_len, GFP_KERNEL);\n\t\tif (!snap_names)\n\t\t\tgoto out_err;\n\n\t\t/* ...as well as the array of their sizes. */\n\t\tsnap_sizes = kmalloc_array(snap_count,\n\t\t\t\t\t   sizeof(*header->snap_sizes),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!snap_sizes)\n\t\t\tgoto out_err;\n\n\t\t/*\n\t\t * Copy the names, and fill in each snapshot's id\n\t\t * and size.\n\t\t *\n\t\t * Note that rbd_dev_v1_header_info() guarantees the\n\t\t * ondisk buffer we're working with has\n\t\t * snap_names_len bytes beyond the end of the\n\t\t * snapshot id array, this memcpy() is safe.\n\t\t */\n\t\tmemcpy(snap_names, &ondisk->snaps[snap_count], snap_names_len);\n\t\tsnaps = ondisk->snaps;\n\t\tfor (i = 0; i < snap_count; i++) {\n\t\t\tsnapc->snaps[i] = le64_to_cpu(snaps[i].id);\n\t\t\tsnap_sizes[i] = le64_to_cpu(snaps[i].image_size);\n\t\t}\n\t}\n\n\t/* We won't fail any more, fill in the header */\n\n\tif (first_time) {\n\t\theader->object_prefix = object_prefix;\n\t\theader->obj_order = ondisk->options.order;\n\t\trbd_init_layout(rbd_dev);\n\t} else {\n\t\tceph_put_snap_context(header->snapc);\n\t\tkfree(header->snap_names);\n\t\tkfree(header->snap_sizes);\n\t}\n\n\t/* The remaining fields always get updated (when we refresh) */\n\n\theader->image_size = le64_to_cpu(ondisk->image_size);\n\theader->snapc = snapc;\n\theader->snap_names = snap_names;\n\theader->snap_sizes = snap_sizes;\n\n\treturn 0;\nout_2big:\n\tret = -EIO;\nout_err:\n\tkfree(snap_sizes);\n\tkfree(snap_names);\n\tceph_put_snap_context(snapc);\n\tkfree(object_prefix);\n\n\treturn ret;\n}\n\nstatic const char *_rbd_dev_v1_snap_name(struct rbd_device *rbd_dev, u32 which)\n{\n\tconst char *snap_name;\n\n\trbd_assert(which < rbd_dev->header.snapc->num_snaps);\n\n\t/* Skip over names until we find the one we are looking for */\n\n\tsnap_name = rbd_dev->header.snap_names;\n\twhile (which--)\n\t\tsnap_name += strlen(snap_name) + 1;\n\n\treturn kstrdup(snap_name, GFP_KERNEL);\n}\n\n/*\n * Snapshot id comparison function for use with qsort()/bsearch().\n * Note that result is for snapshots in *descending* order.\n */\nstatic int snapid_compare_reverse(const void *s1, const void *s2)\n{\n\tu64 snap_id1 = *(u64 *)s1;\n\tu64 snap_id2 = *(u64 *)s2;\n\n\tif (snap_id1 < snap_id2)\n\t\treturn 1;\n\treturn snap_id1 == snap_id2 ? 0 : -1;\n}\n\n/*\n * Search a snapshot context to see if the given snapshot id is\n * present.\n *\n * Returns the position of the snapshot id in the array if it's found,\n * or BAD_SNAP_INDEX otherwise.\n *\n * Note: The snapshot array is in kept sorted (by the osd) in\n * reverse order, highest snapshot id first.\n */\nstatic u32 rbd_dev_snap_index(struct rbd_device *rbd_dev, u64 snap_id)\n{\n\tstruct ceph_snap_context *snapc = rbd_dev->header.snapc;\n\tu64 *found;\n\n\tfound = bsearch(&snap_id, &snapc->snaps, snapc->num_snaps,\n\t\t\t\tsizeof (snap_id), snapid_compare_reverse);\n\n\treturn found ? (u32)(found - &snapc->snaps[0]) : BAD_SNAP_INDEX;\n}\n\nstatic const char *rbd_dev_v1_snap_name(struct rbd_device *rbd_dev,\n\t\t\t\t\tu64 snap_id)\n{\n\tu32 which;\n\tconst char *snap_name;\n\n\twhich = rbd_dev_snap_index(rbd_dev, snap_id);\n\tif (which == BAD_SNAP_INDEX)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tsnap_name = _rbd_dev_v1_snap_name(rbd_dev, which);\n\treturn snap_name ? snap_name : ERR_PTR(-ENOMEM);\n}\n\nstatic const char *rbd_snap_name(struct rbd_device *rbd_dev, u64 snap_id)\n{\n\tif (snap_id == CEPH_NOSNAP)\n\t\treturn RBD_SNAP_HEAD_NAME;\n\n\trbd_assert(rbd_image_format_valid(rbd_dev->image_format));\n\tif (rbd_dev->image_format == 1)\n\t\treturn rbd_dev_v1_snap_name(rbd_dev, snap_id);\n\n\treturn rbd_dev_v2_snap_name(rbd_dev, snap_id);\n}\n\nstatic int rbd_snap_size(struct rbd_device *rbd_dev, u64 snap_id,\n\t\t\t\tu64 *snap_size)\n{\n\trbd_assert(rbd_image_format_valid(rbd_dev->image_format));\n\tif (snap_id == CEPH_NOSNAP) {\n\t\t*snap_size = rbd_dev->header.image_size;\n\t} else if (rbd_dev->image_format == 1) {\n\t\tu32 which;\n\n\t\twhich = rbd_dev_snap_index(rbd_dev, snap_id);\n\t\tif (which == BAD_SNAP_INDEX)\n\t\t\treturn -ENOENT;\n\n\t\t*snap_size = rbd_dev->header.snap_sizes[which];\n\t} else {\n\t\tu64 size = 0;\n\t\tint ret;\n\n\t\tret = _rbd_dev_v2_snap_size(rbd_dev, snap_id, NULL, &size);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*snap_size = size;\n\t}\n\treturn 0;\n}\n\nstatic int rbd_dev_mapping_set(struct rbd_device *rbd_dev)\n{\n\tu64 snap_id = rbd_dev->spec->snap_id;\n\tu64 size = 0;\n\tint ret;\n\n\tret = rbd_snap_size(rbd_dev, snap_id, &size);\n\tif (ret)\n\t\treturn ret;\n\n\trbd_dev->mapping.size = size;\n\treturn 0;\n}\n\nstatic void rbd_dev_mapping_clear(struct rbd_device *rbd_dev)\n{\n\trbd_dev->mapping.size = 0;\n}\n\nstatic void zero_bvec(struct bio_vec *bv)\n{\n\tvoid *buf;\n\tunsigned long flags;\n\n\tbuf = bvec_kmap_irq(bv, &flags);\n\tmemset(buf, 0, bv->bv_len);\n\tflush_dcache_page(bv->bv_page);\n\tbvec_kunmap_irq(buf, &flags);\n}\n\nstatic void zero_bios(struct ceph_bio_iter *bio_pos, u32 off, u32 bytes)\n{\n\tstruct ceph_bio_iter it = *bio_pos;\n\n\tceph_bio_iter_advance(&it, off);\n\tceph_bio_iter_advance_step(&it, bytes, ({\n\t\tzero_bvec(&bv);\n\t}));\n}\n\nstatic void zero_bvecs(struct ceph_bvec_iter *bvec_pos, u32 off, u32 bytes)\n{\n\tstruct ceph_bvec_iter it = *bvec_pos;\n\n\tceph_bvec_iter_advance(&it, off);\n\tceph_bvec_iter_advance_step(&it, bytes, ({\n\t\tzero_bvec(&bv);\n\t}));\n}\n\n/*\n * Zero a range in @obj_req data buffer defined by a bio (list) or\n * (private) bio_vec array.\n *\n * @off is relative to the start of the data buffer.\n */\nstatic void rbd_obj_zero_range(struct rbd_obj_request *obj_req, u32 off,\n\t\t\t       u32 bytes)\n{\n\tdout(\"%s %p data buf %u~%u\\n\", __func__, obj_req, off, bytes);\n\n\tswitch (obj_req->img_request->data_type) {\n\tcase OBJ_REQUEST_BIO:\n\t\tzero_bios(&obj_req->bio_pos, off, bytes);\n\t\tbreak;\n\tcase OBJ_REQUEST_BVECS:\n\tcase OBJ_REQUEST_OWN_BVECS:\n\t\tzero_bvecs(&obj_req->bvec_pos, off, bytes);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic void rbd_obj_request_destroy(struct kref *kref);\nstatic void rbd_obj_request_put(struct rbd_obj_request *obj_request)\n{\n\trbd_assert(obj_request != NULL);\n\tdout(\"%s: obj %p (was %d)\\n\", __func__, obj_request,\n\t\tkref_read(&obj_request->kref));\n\tkref_put(&obj_request->kref, rbd_obj_request_destroy);\n}\n\nstatic inline void rbd_img_obj_request_add(struct rbd_img_request *img_request,\n\t\t\t\t\tstruct rbd_obj_request *obj_request)\n{\n\trbd_assert(obj_request->img_request == NULL);\n\n\t/* Image request now owns object's original reference */\n\tobj_request->img_request = img_request;\n\tdout(\"%s: img %p obj %p\\n\", __func__, img_request, obj_request);\n}\n\nstatic inline void rbd_img_obj_request_del(struct rbd_img_request *img_request,\n\t\t\t\t\tstruct rbd_obj_request *obj_request)\n{\n\tdout(\"%s: img %p obj %p\\n\", __func__, img_request, obj_request);\n\tlist_del(&obj_request->ex.oe_item);\n\trbd_assert(obj_request->img_request == img_request);\n\trbd_obj_request_put(obj_request);\n}\n\nstatic void rbd_osd_submit(struct ceph_osd_request *osd_req)\n{\n\tstruct rbd_obj_request *obj_req = osd_req->r_priv;\n\n\tdout(\"%s osd_req %p for obj_req %p objno %llu %llu~%llu\\n\",\n\t     __func__, osd_req, obj_req, obj_req->ex.oe_objno,\n\t     obj_req->ex.oe_off, obj_req->ex.oe_len);\n\tceph_osdc_start_request(osd_req->r_osdc, osd_req, false);\n}\n\n/*\n * The default/initial value for all image request flags is 0.  Each\n * is conditionally set to 1 at image request initialization time\n * and currently never change thereafter.\n */\nstatic void img_request_layered_set(struct rbd_img_request *img_request)\n{\n\tset_bit(IMG_REQ_LAYERED, &img_request->flags);\n}\n\nstatic bool img_request_layered_test(struct rbd_img_request *img_request)\n{\n\treturn test_bit(IMG_REQ_LAYERED, &img_request->flags) != 0;\n}\n\nstatic bool rbd_obj_is_entire(struct rbd_obj_request *obj_req)\n{\n\tstruct rbd_device *rbd_dev = obj_req->img_request->rbd_dev;\n\n\treturn !obj_req->ex.oe_off &&\n\t       obj_req->ex.oe_len == rbd_dev->layout.object_size;\n}\n\nstatic bool rbd_obj_is_tail(struct rbd_obj_request *obj_req)\n{\n\tstruct rbd_device *rbd_dev = obj_req->img_request->rbd_dev;\n\n\treturn obj_req->ex.oe_off + obj_req->ex.oe_len ==\n\t\t\t\t\trbd_dev->layout.object_size;\n}\n\n/*\n * Must be called after rbd_obj_calc_img_extents().\n */\nstatic bool rbd_obj_copyup_enabled(struct rbd_obj_request *obj_req)\n{\n\tif (!obj_req->num_img_extents ||\n\t    (rbd_obj_is_entire(obj_req) &&\n\t     !obj_req->img_request->snapc->num_snaps))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic u64 rbd_obj_img_extents_bytes(struct rbd_obj_request *obj_req)\n{\n\treturn ceph_file_extents_bytes(obj_req->img_extents,\n\t\t\t\t       obj_req->num_img_extents);\n}\n\nstatic bool rbd_img_is_write(struct rbd_img_request *img_req)\n{\n\tswitch (img_req->op_type) {\n\tcase OBJ_OP_READ:\n\t\treturn false;\n\tcase OBJ_OP_WRITE:\n\tcase OBJ_OP_DISCARD:\n\tcase OBJ_OP_ZEROOUT:\n\t\treturn true;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic void rbd_osd_req_callback(struct ceph_osd_request *osd_req)\n{\n\tstruct rbd_obj_request *obj_req = osd_req->r_priv;\n\tint result;\n\n\tdout(\"%s osd_req %p result %d for obj_req %p\\n\", __func__, osd_req,\n\t     osd_req->r_result, obj_req);\n\n\t/*\n\t * Writes aren't allowed to return a data payload.  In some\n\t * guarded write cases (e.g. stat + zero on an empty object)\n\t * a stat response makes it through, but we don't care.\n\t */\n\tif (osd_req->r_result > 0 && rbd_img_is_write(obj_req->img_request))\n\t\tresult = 0;\n\telse\n\t\tresult = osd_req->r_result;\n\n\trbd_obj_handle_request(obj_req, result);\n}\n\nstatic void rbd_osd_format_read(struct ceph_osd_request *osd_req)\n{\n\tstruct rbd_obj_request *obj_request = osd_req->r_priv;\n\tstruct rbd_device *rbd_dev = obj_request->img_request->rbd_dev;\n\tstruct ceph_options *opt = rbd_dev->rbd_client->client->options;\n\n\tosd_req->r_flags = CEPH_OSD_FLAG_READ | opt->read_from_replica;\n\tosd_req->r_snapid = obj_request->img_request->snap_id;\n}\n\nstatic void rbd_osd_format_write(struct ceph_osd_request *osd_req)\n{\n\tstruct rbd_obj_request *obj_request = osd_req->r_priv;\n\n\tosd_req->r_flags = CEPH_OSD_FLAG_WRITE;\n\tktime_get_real_ts64(&osd_req->r_mtime);\n\tosd_req->r_data_offset = obj_request->ex.oe_off;\n}\n\nstatic struct ceph_osd_request *\n__rbd_obj_add_osd_request(struct rbd_obj_request *obj_req,\n\t\t\t  struct ceph_snap_context *snapc, int num_ops)\n{\n\tstruct rbd_device *rbd_dev = obj_req->img_request->rbd_dev;\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tstruct ceph_osd_request *req;\n\tconst char *name_format = rbd_dev->image_format == 1 ?\n\t\t\t\t      RBD_V1_DATA_FORMAT : RBD_V2_DATA_FORMAT;\n\tint ret;\n\n\treq = ceph_osdc_alloc_request(osdc, snapc, num_ops, false, GFP_NOIO);\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlist_add_tail(&req->r_private_item, &obj_req->osd_reqs);\n\treq->r_callback = rbd_osd_req_callback;\n\treq->r_priv = obj_req;\n\n\t/*\n\t * Data objects may be stored in a separate pool, but always in\n\t * the same namespace in that pool as the header in its pool.\n\t */\n\tceph_oloc_copy(&req->r_base_oloc, &rbd_dev->header_oloc);\n\treq->r_base_oloc.pool = rbd_dev->layout.pool_id;\n\n\tret = ceph_oid_aprintf(&req->r_base_oid, GFP_NOIO, name_format,\n\t\t\t       rbd_dev->header.object_prefix,\n\t\t\t       obj_req->ex.oe_objno);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn req;\n}\n\nstatic struct ceph_osd_request *\nrbd_obj_add_osd_request(struct rbd_obj_request *obj_req, int num_ops)\n{\n\treturn __rbd_obj_add_osd_request(obj_req, obj_req->img_request->snapc,\n\t\t\t\t\t num_ops);\n}\n\nstatic struct rbd_obj_request *rbd_obj_request_create(void)\n{\n\tstruct rbd_obj_request *obj_request;\n\n\tobj_request = kmem_cache_zalloc(rbd_obj_request_cache, GFP_NOIO);\n\tif (!obj_request)\n\t\treturn NULL;\n\n\tceph_object_extent_init(&obj_request->ex);\n\tINIT_LIST_HEAD(&obj_request->osd_reqs);\n\tmutex_init(&obj_request->state_mutex);\n\tkref_init(&obj_request->kref);\n\n\tdout(\"%s %p\\n\", __func__, obj_request);\n\treturn obj_request;\n}\n\nstatic void rbd_obj_request_destroy(struct kref *kref)\n{\n\tstruct rbd_obj_request *obj_request;\n\tstruct ceph_osd_request *osd_req;\n\tu32 i;\n\n\tobj_request = container_of(kref, struct rbd_obj_request, kref);\n\n\tdout(\"%s: obj %p\\n\", __func__, obj_request);\n\n\twhile (!list_empty(&obj_request->osd_reqs)) {\n\t\tosd_req = list_first_entry(&obj_request->osd_reqs,\n\t\t\t\t    struct ceph_osd_request, r_private_item);\n\t\tlist_del_init(&osd_req->r_private_item);\n\t\tceph_osdc_put_request(osd_req);\n\t}\n\n\tswitch (obj_request->img_request->data_type) {\n\tcase OBJ_REQUEST_NODATA:\n\tcase OBJ_REQUEST_BIO:\n\tcase OBJ_REQUEST_BVECS:\n\t\tbreak;\t\t/* Nothing to do */\n\tcase OBJ_REQUEST_OWN_BVECS:\n\t\tkfree(obj_request->bvec_pos.bvecs);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tkfree(obj_request->img_extents);\n\tif (obj_request->copyup_bvecs) {\n\t\tfor (i = 0; i < obj_request->copyup_bvec_count; i++) {\n\t\t\tif (obj_request->copyup_bvecs[i].bv_page)\n\t\t\t\t__free_page(obj_request->copyup_bvecs[i].bv_page);\n\t\t}\n\t\tkfree(obj_request->copyup_bvecs);\n\t}\n\n\tkmem_cache_free(rbd_obj_request_cache, obj_request);\n}\n\n/* It's OK to call this for a device with no parent */\n\nstatic void rbd_spec_put(struct rbd_spec *spec);\nstatic void rbd_dev_unparent(struct rbd_device *rbd_dev)\n{\n\trbd_dev_remove_parent(rbd_dev);\n\trbd_spec_put(rbd_dev->parent_spec);\n\trbd_dev->parent_spec = NULL;\n\trbd_dev->parent_overlap = 0;\n}\n\n/*\n * Parent image reference counting is used to determine when an\n * image's parent fields can be safely torn down--after there are no\n * more in-flight requests to the parent image.  When the last\n * reference is dropped, cleaning them up is safe.\n */\nstatic void rbd_dev_parent_put(struct rbd_device *rbd_dev)\n{\n\tint counter;\n\n\tif (!rbd_dev->parent_spec)\n\t\treturn;\n\n\tcounter = atomic_dec_return_safe(&rbd_dev->parent_ref);\n\tif (counter > 0)\n\t\treturn;\n\n\t/* Last reference; clean up parent data structures */\n\n\tif (!counter)\n\t\trbd_dev_unparent(rbd_dev);\n\telse\n\t\trbd_warn(rbd_dev, \"parent reference underflow\");\n}\n\n/*\n * If an image has a non-zero parent overlap, get a reference to its\n * parent.\n *\n * Returns true if the rbd device has a parent with a non-zero\n * overlap and a reference for it was successfully taken, or\n * false otherwise.\n */\nstatic bool rbd_dev_parent_get(struct rbd_device *rbd_dev)\n{\n\tint counter = 0;\n\n\tif (!rbd_dev->parent_spec)\n\t\treturn false;\n\n\tif (rbd_dev->parent_overlap)\n\t\tcounter = atomic_inc_return_safe(&rbd_dev->parent_ref);\n\n\tif (counter < 0)\n\t\trbd_warn(rbd_dev, \"parent reference overflow\");\n\n\treturn counter > 0;\n}\n\nstatic void rbd_img_request_init(struct rbd_img_request *img_request,\n\t\t\t\t struct rbd_device *rbd_dev,\n\t\t\t\t enum obj_operation_type op_type)\n{\n\tmemset(img_request, 0, sizeof(*img_request));\n\n\timg_request->rbd_dev = rbd_dev;\n\timg_request->op_type = op_type;\n\n\tINIT_LIST_HEAD(&img_request->lock_item);\n\tINIT_LIST_HEAD(&img_request->object_extents);\n\tmutex_init(&img_request->state_mutex);\n}\n\nstatic void rbd_img_capture_header(struct rbd_img_request *img_req)\n{\n\tstruct rbd_device *rbd_dev = img_req->rbd_dev;\n\n\tlockdep_assert_held(&rbd_dev->header_rwsem);\n\n\tif (rbd_img_is_write(img_req))\n\t\timg_req->snapc = ceph_get_snap_context(rbd_dev->header.snapc);\n\telse\n\t\timg_req->snap_id = rbd_dev->spec->snap_id;\n\n\tif (rbd_dev_parent_get(rbd_dev))\n\t\timg_request_layered_set(img_req);\n}\n\nstatic void rbd_img_request_destroy(struct rbd_img_request *img_request)\n{\n\tstruct rbd_obj_request *obj_request;\n\tstruct rbd_obj_request *next_obj_request;\n\n\tdout(\"%s: img %p\\n\", __func__, img_request);\n\n\tWARN_ON(!list_empty(&img_request->lock_item));\n\tfor_each_obj_request_safe(img_request, obj_request, next_obj_request)\n\t\trbd_img_obj_request_del(img_request, obj_request);\n\n\tif (img_request_layered_test(img_request))\n\t\trbd_dev_parent_put(img_request->rbd_dev);\n\n\tif (rbd_img_is_write(img_request))\n\t\tceph_put_snap_context(img_request->snapc);\n\n\tif (test_bit(IMG_REQ_CHILD, &img_request->flags))\n\t\tkmem_cache_free(rbd_img_request_cache, img_request);\n}\n\n#define BITS_PER_OBJ\t2\n#define OBJS_PER_BYTE\t(BITS_PER_BYTE / BITS_PER_OBJ)\n#define OBJ_MASK\t((1 << BITS_PER_OBJ) - 1)\n\nstatic void __rbd_object_map_index(struct rbd_device *rbd_dev, u64 objno,\n\t\t\t\t   u64 *index, u8 *shift)\n{\n\tu32 off;\n\n\trbd_assert(objno < rbd_dev->object_map_size);\n\t*index = div_u64_rem(objno, OBJS_PER_BYTE, &off);\n\t*shift = (OBJS_PER_BYTE - off - 1) * BITS_PER_OBJ;\n}\n\nstatic u8 __rbd_object_map_get(struct rbd_device *rbd_dev, u64 objno)\n{\n\tu64 index;\n\tu8 shift;\n\n\tlockdep_assert_held(&rbd_dev->object_map_lock);\n\t__rbd_object_map_index(rbd_dev, objno, &index, &shift);\n\treturn (rbd_dev->object_map[index] >> shift) & OBJ_MASK;\n}\n\nstatic void __rbd_object_map_set(struct rbd_device *rbd_dev, u64 objno, u8 val)\n{\n\tu64 index;\n\tu8 shift;\n\tu8 *p;\n\n\tlockdep_assert_held(&rbd_dev->object_map_lock);\n\trbd_assert(!(val & ~OBJ_MASK));\n\n\t__rbd_object_map_index(rbd_dev, objno, &index, &shift);\n\tp = &rbd_dev->object_map[index];\n\t*p = (*p & ~(OBJ_MASK << shift)) | (val << shift);\n}\n\nstatic u8 rbd_object_map_get(struct rbd_device *rbd_dev, u64 objno)\n{\n\tu8 state;\n\n\tspin_lock(&rbd_dev->object_map_lock);\n\tstate = __rbd_object_map_get(rbd_dev, objno);\n\tspin_unlock(&rbd_dev->object_map_lock);\n\treturn state;\n}\n\nstatic bool use_object_map(struct rbd_device *rbd_dev)\n{\n\t/*\n\t * An image mapped read-only can't use the object map -- it isn't\n\t * loaded because the header lock isn't acquired.  Someone else can\n\t * write to the image and update the object map behind our back.\n\t *\n\t * A snapshot can't be written to, so using the object map is always\n\t * safe.\n\t */\n\tif (!rbd_is_snap(rbd_dev) && rbd_is_ro(rbd_dev))\n\t\treturn false;\n\n\treturn ((rbd_dev->header.features & RBD_FEATURE_OBJECT_MAP) &&\n\t\t!(rbd_dev->object_map_flags & RBD_FLAG_OBJECT_MAP_INVALID));\n}\n\nstatic bool rbd_object_map_may_exist(struct rbd_device *rbd_dev, u64 objno)\n{\n\tu8 state;\n\n\t/* fall back to default logic if object map is disabled or invalid */\n\tif (!use_object_map(rbd_dev))\n\t\treturn true;\n\n\tstate = rbd_object_map_get(rbd_dev, objno);\n\treturn state != OBJECT_NONEXISTENT;\n}\n\nstatic void rbd_object_map_name(struct rbd_device *rbd_dev, u64 snap_id,\n\t\t\t\tstruct ceph_object_id *oid)\n{\n\tif (snap_id == CEPH_NOSNAP)\n\t\tceph_oid_printf(oid, \"%s%s\", RBD_OBJECT_MAP_PREFIX,\n\t\t\t\trbd_dev->spec->image_id);\n\telse\n\t\tceph_oid_printf(oid, \"%s%s.%016llx\", RBD_OBJECT_MAP_PREFIX,\n\t\t\t\trbd_dev->spec->image_id, snap_id);\n}\n\nstatic int rbd_object_map_lock(struct rbd_device *rbd_dev)\n{\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tCEPH_DEFINE_OID_ONSTACK(oid);\n\tu8 lock_type;\n\tchar *lock_tag;\n\tstruct ceph_locker *lockers;\n\tu32 num_lockers;\n\tbool broke_lock = false;\n\tint ret;\n\n\trbd_object_map_name(rbd_dev, CEPH_NOSNAP, &oid);\n\nagain:\n\tret = ceph_cls_lock(osdc, &oid, &rbd_dev->header_oloc, RBD_LOCK_NAME,\n\t\t\t    CEPH_CLS_LOCK_EXCLUSIVE, \"\", \"\", \"\", 0);\n\tif (ret != -EBUSY || broke_lock) {\n\t\tif (ret == -EEXIST)\n\t\t\tret = 0; /* already locked by myself */\n\t\tif (ret)\n\t\t\trbd_warn(rbd_dev, \"failed to lock object map: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ceph_cls_lock_info(osdc, &oid, &rbd_dev->header_oloc,\n\t\t\t\t RBD_LOCK_NAME, &lock_type, &lock_tag,\n\t\t\t\t &lockers, &num_lockers);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tgoto again;\n\n\t\trbd_warn(rbd_dev, \"failed to get object map lockers: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tkfree(lock_tag);\n\tif (num_lockers == 0)\n\t\tgoto again;\n\n\trbd_warn(rbd_dev, \"breaking object map lock owned by %s%llu\",\n\t\t ENTITY_NAME(lockers[0].id.name));\n\n\tret = ceph_cls_break_lock(osdc, &oid, &rbd_dev->header_oloc,\n\t\t\t\t  RBD_LOCK_NAME, lockers[0].id.cookie,\n\t\t\t\t  &lockers[0].id.name);\n\tceph_free_lockers(lockers, num_lockers);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\tgoto again;\n\n\t\trbd_warn(rbd_dev, \"failed to break object map lock: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tbroke_lock = true;\n\tgoto again;\n}\n\nstatic void rbd_object_map_unlock(struct rbd_device *rbd_dev)\n{\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tCEPH_DEFINE_OID_ONSTACK(oid);\n\tint ret;\n\n\trbd_object_map_name(rbd_dev, CEPH_NOSNAP, &oid);\n\n\tret = ceph_cls_unlock(osdc, &oid, &rbd_dev->header_oloc, RBD_LOCK_NAME,\n\t\t\t      \"\");\n\tif (ret && ret != -ENOENT)\n\t\trbd_warn(rbd_dev, \"failed to unlock object map: %d\", ret);\n}\n\nstatic int decode_object_map_header(void **p, void *end, u64 *object_map_size)\n{\n\tu8 struct_v;\n\tu32 struct_len;\n\tu32 header_len;\n\tvoid *header_end;\n\tint ret;\n\n\tceph_decode_32_safe(p, end, header_len, e_inval);\n\theader_end = *p + header_len;\n\n\tret = ceph_start_decoding(p, end, 1, \"BitVector header\", &struct_v,\n\t\t\t\t  &struct_len);\n\tif (ret)\n\t\treturn ret;\n\n\tceph_decode_64_safe(p, end, *object_map_size, e_inval);\n\n\t*p = header_end;\n\treturn 0;\n\ne_inval:\n\treturn -EINVAL;\n}\n\nstatic int __rbd_object_map_load(struct rbd_device *rbd_dev)\n{\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tCEPH_DEFINE_OID_ONSTACK(oid);\n\tstruct page **pages;\n\tvoid *p, *end;\n\tsize_t reply_len;\n\tu64 num_objects;\n\tu64 object_map_bytes;\n\tu64 object_map_size;\n\tint num_pages;\n\tint ret;\n\n\trbd_assert(!rbd_dev->object_map && !rbd_dev->object_map_size);\n\n\tnum_objects = ceph_get_num_objects(&rbd_dev->layout,\n\t\t\t\t\t   rbd_dev->mapping.size);\n\tobject_map_bytes = DIV_ROUND_UP_ULL(num_objects * BITS_PER_OBJ,\n\t\t\t\t\t    BITS_PER_BYTE);\n\tnum_pages = calc_pages_for(0, object_map_bytes) + 1;\n\tpages = ceph_alloc_page_vector(num_pages, GFP_KERNEL);\n\tif (IS_ERR(pages))\n\t\treturn PTR_ERR(pages);\n\n\treply_len = num_pages * PAGE_SIZE;\n\trbd_object_map_name(rbd_dev, rbd_dev->spec->snap_id, &oid);\n\tret = ceph_osdc_call(osdc, &oid, &rbd_dev->header_oloc,\n\t\t\t     \"rbd\", \"object_map_load\", CEPH_OSD_FLAG_READ,\n\t\t\t     NULL, 0, pages, &reply_len);\n\tif (ret)\n\t\tgoto out;\n\n\tp = page_address(pages[0]);\n\tend = p + min(reply_len, (size_t)PAGE_SIZE);\n\tret = decode_object_map_header(&p, end, &object_map_size);\n\tif (ret)\n\t\tgoto out;\n\n\tif (object_map_size != num_objects) {\n\t\trbd_warn(rbd_dev, \"object map size mismatch: %llu vs %llu\",\n\t\t\t object_map_size, num_objects);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (offset_in_page(p) + object_map_bytes > reply_len) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trbd_dev->object_map = kvmalloc(object_map_bytes, GFP_KERNEL);\n\tif (!rbd_dev->object_map) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trbd_dev->object_map_size = object_map_size;\n\tceph_copy_from_page_vector(pages, rbd_dev->object_map,\n\t\t\t\t   offset_in_page(p), object_map_bytes);\n\nout:\n\tceph_release_page_vector(pages, num_pages);\n\treturn ret;\n}\n\nstatic void rbd_object_map_free(struct rbd_device *rbd_dev)\n{\n\tkvfree(rbd_dev->object_map);\n\trbd_dev->object_map = NULL;\n\trbd_dev->object_map_size = 0;\n}\n\nstatic int rbd_object_map_load(struct rbd_device *rbd_dev)\n{\n\tint ret;\n\n\tret = __rbd_object_map_load(rbd_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rbd_dev_v2_get_flags(rbd_dev);\n\tif (ret) {\n\t\trbd_object_map_free(rbd_dev);\n\t\treturn ret;\n\t}\n\n\tif (rbd_dev->object_map_flags & RBD_FLAG_OBJECT_MAP_INVALID)\n\t\trbd_warn(rbd_dev, \"object map is invalid\");\n\n\treturn 0;\n}\n\nstatic int rbd_object_map_open(struct rbd_device *rbd_dev)\n{\n\tint ret;\n\n\tret = rbd_object_map_lock(rbd_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rbd_object_map_load(rbd_dev);\n\tif (ret) {\n\t\trbd_object_map_unlock(rbd_dev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rbd_object_map_close(struct rbd_device *rbd_dev)\n{\n\trbd_object_map_free(rbd_dev);\n\trbd_object_map_unlock(rbd_dev);\n}\n\n/*\n * This function needs snap_id (or more precisely just something to\n * distinguish between HEAD and snapshot object maps), new_state and\n * current_state that were passed to rbd_object_map_update().\n *\n * To avoid allocating and stashing a context we piggyback on the OSD\n * request.  A HEAD update has two ops (assert_locked).  For new_state\n * and current_state we decode our own object_map_update op, encoded in\n * rbd_cls_object_map_update().\n */\nstatic int rbd_object_map_update_finish(struct rbd_obj_request *obj_req,\n\t\t\t\t\tstruct ceph_osd_request *osd_req)\n{\n\tstruct rbd_device *rbd_dev = obj_req->img_request->rbd_dev;\n\tstruct ceph_osd_data *osd_data;\n\tu64 objno;\n\tu8 state, new_state, current_state;\n\tbool has_current_state;\n\tvoid *p;\n\n\tif (osd_req->r_result)\n\t\treturn osd_req->r_result;\n\n\t/*\n\t * Nothing to do for a snapshot object map.\n\t */\n\tif (osd_req->r_num_ops == 1)\n\t\treturn 0;\n\n\t/*\n\t * Update in-memory HEAD object map.\n\t */\n\trbd_assert(osd_req->r_num_ops == 2);\n\tosd_data = osd_req_op_data(osd_req, 1, cls, request_data);\n\trbd_assert(osd_data->type == CEPH_OSD_DATA_TYPE_PAGES);\n\n\tp = page_address(osd_data->pages[0]);\n\tobjno = ceph_decode_64(&p);\n\trbd_assert(objno == obj_req->ex.oe_objno);\n\trbd_assert(ceph_decode_64(&p) == objno + 1);\n\tnew_state = ceph_decode_8(&p);\n\thas_current_state = ceph_decode_8(&p);\n\tif (has_current_state)\n\t\tcurrent_state = ceph_decode_8(&p);\n\n\tspin_lock(&rbd_dev->object_map_lock);\n\tstate = __rbd_object_map_get(rbd_dev, objno);\n\tif (!has_current_state || current_state == state ||\n\t    (current_state == OBJECT_EXISTS && state == OBJECT_EXISTS_CLEAN))\n\t\t__rbd_object_map_set(rbd_dev, objno, new_state);\n\tspin_unlock(&rbd_dev->object_map_lock);\n\n\treturn 0;\n}\n\nstatic void rbd_object_map_callback(struct ceph_osd_request *osd_req)\n{\n\tstruct rbd_obj_request *obj_req = osd_req->r_priv;\n\tint result;\n\n\tdout(\"%s osd_req %p result %d for obj_req %p\\n\", __func__, osd_req,\n\t     osd_req->r_result, obj_req);\n\n\tresult = rbd_object_map_update_finish(obj_req, osd_req);\n\trbd_obj_handle_request(obj_req, result);\n}\n\nstatic bool update_needed(struct rbd_device *rbd_dev, u64 objno, u8 new_state)\n{\n\tu8 state = rbd_object_map_get(rbd_dev, objno);\n\n\tif (state == new_state ||\n\t    (new_state == OBJECT_PENDING && state == OBJECT_NONEXISTENT) ||\n\t    (new_state == OBJECT_NONEXISTENT && state != OBJECT_PENDING))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int rbd_cls_object_map_update(struct ceph_osd_request *req,\n\t\t\t\t     int which, u64 objno, u8 new_state,\n\t\t\t\t     const u8 *current_state)\n{\n\tstruct page **pages;\n\tvoid *p, *start;\n\tint ret;\n\n\tret = osd_req_op_cls_init(req, which, \"rbd\", \"object_map_update\");\n\tif (ret)\n\t\treturn ret;\n\n\tpages = ceph_alloc_page_vector(1, GFP_NOIO);\n\tif (IS_ERR(pages))\n\t\treturn PTR_ERR(pages);\n\n\tp = start = page_address(pages[0]);\n\tceph_encode_64(&p, objno);\n\tceph_encode_64(&p, objno + 1);\n\tceph_encode_8(&p, new_state);\n\tif (current_state) {\n\t\tceph_encode_8(&p, 1);\n\t\tceph_encode_8(&p, *current_state);\n\t} else {\n\t\tceph_encode_8(&p, 0);\n\t}\n\n\tosd_req_op_cls_request_data_pages(req, which, pages, p - start, 0,\n\t\t\t\t\t  false, true);\n\treturn 0;\n}\n\n/*\n * Return:\n *   0 - object map update sent\n *   1 - object map update isn't needed\n *  <0 - error\n */\nstatic int rbd_object_map_update(struct rbd_obj_request *obj_req, u64 snap_id,\n\t\t\t\t u8 new_state, const u8 *current_state)\n{\n\tstruct rbd_device *rbd_dev = obj_req->img_request->rbd_dev;\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tstruct ceph_osd_request *req;\n\tint num_ops = 1;\n\tint which = 0;\n\tint ret;\n\n\tif (snap_id == CEPH_NOSNAP) {\n\t\tif (!update_needed(rbd_dev, obj_req->ex.oe_objno, new_state))\n\t\t\treturn 1;\n\n\t\tnum_ops++; /* assert_locked */\n\t}\n\n\treq = ceph_osdc_alloc_request(osdc, NULL, num_ops, false, GFP_NOIO);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tlist_add_tail(&req->r_private_item, &obj_req->osd_reqs);\n\treq->r_callback = rbd_object_map_callback;\n\treq->r_priv = obj_req;\n\n\trbd_object_map_name(rbd_dev, snap_id, &req->r_base_oid);\n\tceph_oloc_copy(&req->r_base_oloc, &rbd_dev->header_oloc);\n\treq->r_flags = CEPH_OSD_FLAG_WRITE;\n\tktime_get_real_ts64(&req->r_mtime);\n\n\tif (snap_id == CEPH_NOSNAP) {\n\t\t/*\n\t\t * Protect against possible race conditions during lock\n\t\t * ownership transitions.\n\t\t */\n\t\tret = ceph_cls_assert_locked(req, which++, RBD_LOCK_NAME,\n\t\t\t\t\t     CEPH_CLS_LOCK_EXCLUSIVE, \"\", \"\");\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = rbd_cls_object_map_update(req, which, obj_req->ex.oe_objno,\n\t\t\t\t\tnew_state, current_state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ceph_osdc_alloc_messages(req, GFP_NOIO);\n\tif (ret)\n\t\treturn ret;\n\n\tceph_osdc_start_request(osdc, req, false);\n\treturn 0;\n}\n\nstatic void prune_extents(struct ceph_file_extent *img_extents,\n\t\t\t  u32 *num_img_extents, u64 overlap)\n{\n\tu32 cnt = *num_img_extents;\n\n\t/* drop extents completely beyond the overlap */\n\twhile (cnt && img_extents[cnt - 1].fe_off >= overlap)\n\t\tcnt--;\n\n\tif (cnt) {\n\t\tstruct ceph_file_extent *ex = &img_extents[cnt - 1];\n\n\t\t/* trim final overlapping extent */\n\t\tif (ex->fe_off + ex->fe_len > overlap)\n\t\t\tex->fe_len = overlap - ex->fe_off;\n\t}\n\n\t*num_img_extents = cnt;\n}\n\n/*\n * Determine the byte range(s) covered by either just the object extent\n * or the entire object in the parent image.\n */\nstatic int rbd_obj_calc_img_extents(struct rbd_obj_request *obj_req,\n\t\t\t\t    bool entire)\n{\n\tstruct rbd_device *rbd_dev = obj_req->img_request->rbd_dev;\n\tint ret;\n\n\tif (!rbd_dev->parent_overlap)\n\t\treturn 0;\n\n\tret = ceph_extent_to_file(&rbd_dev->layout, obj_req->ex.oe_objno,\n\t\t\t\t  entire ? 0 : obj_req->ex.oe_off,\n\t\t\t\t  entire ? rbd_dev->layout.object_size :\n\t\t\t\t\t\t\tobj_req->ex.oe_len,\n\t\t\t\t  &obj_req->img_extents,\n\t\t\t\t  &obj_req->num_img_extents);\n\tif (ret)\n\t\treturn ret;\n\n\tprune_extents(obj_req->img_extents, &obj_req->num_img_extents,\n\t\t      rbd_dev->parent_overlap);\n\treturn 0;\n}\n\nstatic void rbd_osd_setup_data(struct ceph_osd_request *osd_req, int which)\n{\n\tstruct rbd_obj_request *obj_req = osd_req->r_priv;\n\n\tswitch (obj_req->img_request->data_type) {\n\tcase OBJ_REQUEST_BIO:\n\t\tosd_req_op_extent_osd_data_bio(osd_req, which,\n\t\t\t\t\t       &obj_req->bio_pos,\n\t\t\t\t\t       obj_req->ex.oe_len);\n\t\tbreak;\n\tcase OBJ_REQUEST_BVECS:\n\tcase OBJ_REQUEST_OWN_BVECS:\n\t\trbd_assert(obj_req->bvec_pos.iter.bi_size ==\n\t\t\t\t\t\t\tobj_req->ex.oe_len);\n\t\trbd_assert(obj_req->bvec_idx == obj_req->bvec_count);\n\t\tosd_req_op_extent_osd_data_bvec_pos(osd_req, which,\n\t\t\t\t\t\t    &obj_req->bvec_pos);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic int rbd_osd_setup_stat(struct ceph_osd_request *osd_req, int which)\n{\n\tstruct page **pages;\n\n\t/*\n\t * The response data for a STAT call consists of:\n\t *     le64 length;\n\t *     struct {\n\t *         le32 tv_sec;\n\t *         le32 tv_nsec;\n\t *     } mtime;\n\t */\n\tpages = ceph_alloc_page_vector(1, GFP_NOIO);\n\tif (IS_ERR(pages))\n\t\treturn PTR_ERR(pages);\n\n\tosd_req_op_init(osd_req, which, CEPH_OSD_OP_STAT, 0);\n\tosd_req_op_raw_data_in_pages(osd_req, which, pages,\n\t\t\t\t     8 + sizeof(struct ceph_timespec),\n\t\t\t\t     0, false, true);\n\treturn 0;\n}\n\nstatic int rbd_osd_setup_copyup(struct ceph_osd_request *osd_req, int which,\n\t\t\t\tu32 bytes)\n{\n\tstruct rbd_obj_request *obj_req = osd_req->r_priv;\n\tint ret;\n\n\tret = osd_req_op_cls_init(osd_req, which, \"rbd\", \"copyup\");\n\tif (ret)\n\t\treturn ret;\n\n\tosd_req_op_cls_request_data_bvecs(osd_req, which, obj_req->copyup_bvecs,\n\t\t\t\t\t  obj_req->copyup_bvec_count, bytes);\n\treturn 0;\n}\n\nstatic int rbd_obj_init_read(struct rbd_obj_request *obj_req)\n{\n\tobj_req->read_state = RBD_OBJ_READ_START;\n\treturn 0;\n}\n\nstatic void __rbd_osd_setup_write_ops(struct ceph_osd_request *osd_req,\n\t\t\t\t      int which)\n{\n\tstruct rbd_obj_request *obj_req = osd_req->r_priv;\n\tstruct rbd_device *rbd_dev = obj_req->img_request->rbd_dev;\n\tu16 opcode;\n\n\tif (!use_object_map(rbd_dev) ||\n\t    !(obj_req->flags & RBD_OBJ_FLAG_MAY_EXIST)) {\n\t\tosd_req_op_alloc_hint_init(osd_req, which++,\n\t\t\t\t\t   rbd_dev->layout.object_size,\n\t\t\t\t\t   rbd_dev->layout.object_size,\n\t\t\t\t\t   rbd_dev->opts->alloc_hint_flags);\n\t}\n\n\tif (rbd_obj_is_entire(obj_req))\n\t\topcode = CEPH_OSD_OP_WRITEFULL;\n\telse\n\t\topcode = CEPH_OSD_OP_WRITE;\n\n\tosd_req_op_extent_init(osd_req, which, opcode,\n\t\t\t       obj_req->ex.oe_off, obj_req->ex.oe_len, 0, 0);\n\trbd_osd_setup_data(osd_req, which);\n}\n\nstatic int rbd_obj_init_write(struct rbd_obj_request *obj_req)\n{\n\tint ret;\n\n\t/* reverse map the entire object onto the parent */\n\tret = rbd_obj_calc_img_extents(obj_req, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rbd_obj_copyup_enabled(obj_req))\n\t\tobj_req->flags |= RBD_OBJ_FLAG_COPYUP_ENABLED;\n\n\tobj_req->write_state = RBD_OBJ_WRITE_START;\n\treturn 0;\n}\n\nstatic u16 truncate_or_zero_opcode(struct rbd_obj_request *obj_req)\n{\n\treturn rbd_obj_is_tail(obj_req) ? CEPH_OSD_OP_TRUNCATE :\n\t\t\t\t\t  CEPH_OSD_OP_ZERO;\n}\n\nstatic void __rbd_osd_setup_discard_ops(struct ceph_osd_request *osd_req,\n\t\t\t\t\tint which)\n{\n\tstruct rbd_obj_request *obj_req = osd_req->r_priv;\n\n\tif (rbd_obj_is_entire(obj_req) && !obj_req->num_img_extents) {\n\t\trbd_assert(obj_req->flags & RBD_OBJ_FLAG_DELETION);\n\t\tosd_req_op_init(osd_req, which, CEPH_OSD_OP_DELETE, 0);\n\t} else {\n\t\tosd_req_op_extent_init(osd_req, which,\n\t\t\t\t       truncate_or_zero_opcode(obj_req),\n\t\t\t\t       obj_req->ex.oe_off, obj_req->ex.oe_len,\n\t\t\t\t       0, 0);\n\t}\n}\n\nstatic int rbd_obj_init_discard(struct rbd_obj_request *obj_req)\n{\n\tstruct rbd_device *rbd_dev = obj_req->img_request->rbd_dev;\n\tu64 off, next_off;\n\tint ret;\n\n\t/*\n\t * Align the range to alloc_size boundary and punt on discards\n\t * that are too small to free up any space.\n\t *\n\t * alloc_size == object_size && is_tail() is a special case for\n\t * filestore with filestore_punch_hole = false, needed to allow\n\t * truncate (in addition to delete).\n\t */\n\tif (rbd_dev->opts->alloc_size != rbd_dev->layout.object_size ||\n\t    !rbd_obj_is_tail(obj_req)) {\n\t\toff = round_up(obj_req->ex.oe_off, rbd_dev->opts->alloc_size);\n\t\tnext_off = round_down(obj_req->ex.oe_off + obj_req->ex.oe_len,\n\t\t\t\t      rbd_dev->opts->alloc_size);\n\t\tif (off >= next_off)\n\t\t\treturn 1;\n\n\t\tdout(\"%s %p %llu~%llu -> %llu~%llu\\n\", __func__,\n\t\t     obj_req, obj_req->ex.oe_off, obj_req->ex.oe_len,\n\t\t     off, next_off - off);\n\t\tobj_req->ex.oe_off = off;\n\t\tobj_req->ex.oe_len = next_off - off;\n\t}\n\n\t/* reverse map the entire object onto the parent */\n\tret = rbd_obj_calc_img_extents(obj_req, true);\n\tif (ret)\n\t\treturn ret;\n\n\tobj_req->flags |= RBD_OBJ_FLAG_NOOP_FOR_NONEXISTENT;\n\tif (rbd_obj_is_entire(obj_req) && !obj_req->num_img_extents)\n\t\tobj_req->flags |= RBD_OBJ_FLAG_DELETION;\n\n\tobj_req->write_state = RBD_OBJ_WRITE_START;\n\treturn 0;\n}\n\nstatic void __rbd_osd_setup_zeroout_ops(struct ceph_osd_request *osd_req,\n\t\t\t\t\tint which)\n{\n\tstruct rbd_obj_request *obj_req = osd_req->r_priv;\n\tu16 opcode;\n\n\tif (rbd_obj_is_entire(obj_req)) {\n\t\tif (obj_req->num_img_extents) {\n\t\t\tif (!(obj_req->flags & RBD_OBJ_FLAG_COPYUP_ENABLED))\n\t\t\t\tosd_req_op_init(osd_req, which++,\n\t\t\t\t\t\tCEPH_OSD_OP_CREATE, 0);\n\t\t\topcode = CEPH_OSD_OP_TRUNCATE;\n\t\t} else {\n\t\t\trbd_assert(obj_req->flags & RBD_OBJ_FLAG_DELETION);\n\t\t\tosd_req_op_init(osd_req, which++,\n\t\t\t\t\tCEPH_OSD_OP_DELETE, 0);\n\t\t\topcode = 0;\n\t\t}\n\t} else {\n\t\topcode = truncate_or_zero_opcode(obj_req);\n\t}\n\n\tif (opcode)\n\t\tosd_req_op_extent_init(osd_req, which, opcode,\n\t\t\t\t       obj_req->ex.oe_off, obj_req->ex.oe_len,\n\t\t\t\t       0, 0);\n}\n\nstatic int rbd_obj_init_zeroout(struct rbd_obj_request *obj_req)\n{\n\tint ret;\n\n\t/* reverse map the entire object onto the parent */\n\tret = rbd_obj_calc_img_extents(obj_req, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rbd_obj_copyup_enabled(obj_req))\n\t\tobj_req->flags |= RBD_OBJ_FLAG_COPYUP_ENABLED;\n\tif (!obj_req->num_img_extents) {\n\t\tobj_req->flags |= RBD_OBJ_FLAG_NOOP_FOR_NONEXISTENT;\n\t\tif (rbd_obj_is_entire(obj_req))\n\t\t\tobj_req->flags |= RBD_OBJ_FLAG_DELETION;\n\t}\n\n\tobj_req->write_state = RBD_OBJ_WRITE_START;\n\treturn 0;\n}\n\nstatic int count_write_ops(struct rbd_obj_request *obj_req)\n{\n\tstruct rbd_img_request *img_req = obj_req->img_request;\n\n\tswitch (img_req->op_type) {\n\tcase OBJ_OP_WRITE:\n\t\tif (!use_object_map(img_req->rbd_dev) ||\n\t\t    !(obj_req->flags & RBD_OBJ_FLAG_MAY_EXIST))\n\t\t\treturn 2; /* setallochint + write/writefull */\n\n\t\treturn 1; /* write/writefull */\n\tcase OBJ_OP_DISCARD:\n\t\treturn 1; /* delete/truncate/zero */\n\tcase OBJ_OP_ZEROOUT:\n\t\tif (rbd_obj_is_entire(obj_req) && obj_req->num_img_extents &&\n\t\t    !(obj_req->flags & RBD_OBJ_FLAG_COPYUP_ENABLED))\n\t\t\treturn 2; /* create + truncate */\n\n\t\treturn 1; /* delete/truncate/zero */\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic void rbd_osd_setup_write_ops(struct ceph_osd_request *osd_req,\n\t\t\t\t    int which)\n{\n\tstruct rbd_obj_request *obj_req = osd_req->r_priv;\n\n\tswitch (obj_req->img_request->op_type) {\n\tcase OBJ_OP_WRITE:\n\t\t__rbd_osd_setup_write_ops(osd_req, which);\n\t\tbreak;\n\tcase OBJ_OP_DISCARD:\n\t\t__rbd_osd_setup_discard_ops(osd_req, which);\n\t\tbreak;\n\tcase OBJ_OP_ZEROOUT:\n\t\t__rbd_osd_setup_zeroout_ops(osd_req, which);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n/*\n * Prune the list of object requests (adjust offset and/or length, drop\n * redundant requests).  Prepare object request state machines and image\n * request state machine for execution.\n */\nstatic int __rbd_img_fill_request(struct rbd_img_request *img_req)\n{\n\tstruct rbd_obj_request *obj_req, *next_obj_req;\n\tint ret;\n\n\tfor_each_obj_request_safe(img_req, obj_req, next_obj_req) {\n\t\tswitch (img_req->op_type) {\n\t\tcase OBJ_OP_READ:\n\t\t\tret = rbd_obj_init_read(obj_req);\n\t\t\tbreak;\n\t\tcase OBJ_OP_WRITE:\n\t\t\tret = rbd_obj_init_write(obj_req);\n\t\t\tbreak;\n\t\tcase OBJ_OP_DISCARD:\n\t\t\tret = rbd_obj_init_discard(obj_req);\n\t\t\tbreak;\n\t\tcase OBJ_OP_ZEROOUT:\n\t\t\tret = rbd_obj_init_zeroout(obj_req);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret > 0) {\n\t\t\trbd_img_obj_request_del(img_req, obj_req);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\timg_req->state = RBD_IMG_START;\n\treturn 0;\n}\n\nunion rbd_img_fill_iter {\n\tstruct ceph_bio_iter\tbio_iter;\n\tstruct ceph_bvec_iter\tbvec_iter;\n};\n\nstruct rbd_img_fill_ctx {\n\tenum obj_request_type\tpos_type;\n\tunion rbd_img_fill_iter\t*pos;\n\tunion rbd_img_fill_iter\titer;\n\tceph_object_extent_fn_t\tset_pos_fn;\n\tceph_object_extent_fn_t\tcount_fn;\n\tceph_object_extent_fn_t\tcopy_fn;\n};\n\nstatic struct ceph_object_extent *alloc_object_extent(void *arg)\n{\n\tstruct rbd_img_request *img_req = arg;\n\tstruct rbd_obj_request *obj_req;\n\n\tobj_req = rbd_obj_request_create();\n\tif (!obj_req)\n\t\treturn NULL;\n\n\trbd_img_obj_request_add(img_req, obj_req);\n\treturn &obj_req->ex;\n}\n\n/*\n * While su != os && sc == 1 is technically not fancy (it's the same\n * layout as su == os && sc == 1), we can't use the nocopy path for it\n * because ->set_pos_fn() should be called only once per object.\n * ceph_file_to_extents() invokes action_fn once per stripe unit, so\n * treat su != os && sc == 1 as fancy.\n */\nstatic bool rbd_layout_is_fancy(struct ceph_file_layout *l)\n{\n\treturn l->stripe_unit != l->object_size;\n}\n\nstatic int rbd_img_fill_request_nocopy(struct rbd_img_request *img_req,\n\t\t\t\t       struct ceph_file_extent *img_extents,\n\t\t\t\t       u32 num_img_extents,\n\t\t\t\t       struct rbd_img_fill_ctx *fctx)\n{\n\tu32 i;\n\tint ret;\n\n\timg_req->data_type = fctx->pos_type;\n\n\t/*\n\t * Create object requests and set each object request's starting\n\t * position in the provided bio (list) or bio_vec array.\n\t */\n\tfctx->iter = *fctx->pos;\n\tfor (i = 0; i < num_img_extents; i++) {\n\t\tret = ceph_file_to_extents(&img_req->rbd_dev->layout,\n\t\t\t\t\t   img_extents[i].fe_off,\n\t\t\t\t\t   img_extents[i].fe_len,\n\t\t\t\t\t   &img_req->object_extents,\n\t\t\t\t\t   alloc_object_extent, img_req,\n\t\t\t\t\t   fctx->set_pos_fn, &fctx->iter);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn __rbd_img_fill_request(img_req);\n}\n\n/*\n * Map a list of image extents to a list of object extents, create the\n * corresponding object requests (normally each to a different object,\n * but not always) and add them to @img_req.  For each object request,\n * set up its data descriptor to point to the corresponding chunk(s) of\n * @fctx->pos data buffer.\n *\n * Because ceph_file_to_extents() will merge adjacent object extents\n * together, each object request's data descriptor may point to multiple\n * different chunks of @fctx->pos data buffer.\n *\n * @fctx->pos data buffer is assumed to be large enough.\n */\nstatic int rbd_img_fill_request(struct rbd_img_request *img_req,\n\t\t\t\tstruct ceph_file_extent *img_extents,\n\t\t\t\tu32 num_img_extents,\n\t\t\t\tstruct rbd_img_fill_ctx *fctx)\n{\n\tstruct rbd_device *rbd_dev = img_req->rbd_dev;\n\tstruct rbd_obj_request *obj_req;\n\tu32 i;\n\tint ret;\n\n\tif (fctx->pos_type == OBJ_REQUEST_NODATA ||\n\t    !rbd_layout_is_fancy(&rbd_dev->layout))\n\t\treturn rbd_img_fill_request_nocopy(img_req, img_extents,\n\t\t\t\t\t\t   num_img_extents, fctx);\n\n\timg_req->data_type = OBJ_REQUEST_OWN_BVECS;\n\n\t/*\n\t * Create object requests and determine ->bvec_count for each object\n\t * request.  Note that ->bvec_count sum over all object requests may\n\t * be greater than the number of bio_vecs in the provided bio (list)\n\t * or bio_vec array because when mapped, those bio_vecs can straddle\n\t * stripe unit boundaries.\n\t */\n\tfctx->iter = *fctx->pos;\n\tfor (i = 0; i < num_img_extents; i++) {\n\t\tret = ceph_file_to_extents(&rbd_dev->layout,\n\t\t\t\t\t   img_extents[i].fe_off,\n\t\t\t\t\t   img_extents[i].fe_len,\n\t\t\t\t\t   &img_req->object_extents,\n\t\t\t\t\t   alloc_object_extent, img_req,\n\t\t\t\t\t   fctx->count_fn, &fctx->iter);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor_each_obj_request(img_req, obj_req) {\n\t\tobj_req->bvec_pos.bvecs = kmalloc_array(obj_req->bvec_count,\n\t\t\t\t\t      sizeof(*obj_req->bvec_pos.bvecs),\n\t\t\t\t\t      GFP_NOIO);\n\t\tif (!obj_req->bvec_pos.bvecs)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * Fill in each object request's private bio_vec array, splitting and\n\t * rearranging the provided bio_vecs in stripe unit chunks as needed.\n\t */\n\tfctx->iter = *fctx->pos;\n\tfor (i = 0; i < num_img_extents; i++) {\n\t\tret = ceph_iterate_extents(&rbd_dev->layout,\n\t\t\t\t\t   img_extents[i].fe_off,\n\t\t\t\t\t   img_extents[i].fe_len,\n\t\t\t\t\t   &img_req->object_extents,\n\t\t\t\t\t   fctx->copy_fn, &fctx->iter);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn __rbd_img_fill_request(img_req);\n}\n\nstatic int rbd_img_fill_nodata(struct rbd_img_request *img_req,\n\t\t\t       u64 off, u64 len)\n{\n\tstruct ceph_file_extent ex = { off, len };\n\tunion rbd_img_fill_iter dummy = {};\n\tstruct rbd_img_fill_ctx fctx = {\n\t\t.pos_type = OBJ_REQUEST_NODATA,\n\t\t.pos = &dummy,\n\t};\n\n\treturn rbd_img_fill_request(img_req, &ex, 1, &fctx);\n}\n\nstatic void set_bio_pos(struct ceph_object_extent *ex, u32 bytes, void *arg)\n{\n\tstruct rbd_obj_request *obj_req =\n\t    container_of(ex, struct rbd_obj_request, ex);\n\tstruct ceph_bio_iter *it = arg;\n\n\tdout(\"%s objno %llu bytes %u\\n\", __func__, ex->oe_objno, bytes);\n\tobj_req->bio_pos = *it;\n\tceph_bio_iter_advance(it, bytes);\n}\n\nstatic void count_bio_bvecs(struct ceph_object_extent *ex, u32 bytes, void *arg)\n{\n\tstruct rbd_obj_request *obj_req =\n\t    container_of(ex, struct rbd_obj_request, ex);\n\tstruct ceph_bio_iter *it = arg;\n\n\tdout(\"%s objno %llu bytes %u\\n\", __func__, ex->oe_objno, bytes);\n\tceph_bio_iter_advance_step(it, bytes, ({\n\t\tobj_req->bvec_count++;\n\t}));\n\n}\n\nstatic void copy_bio_bvecs(struct ceph_object_extent *ex, u32 bytes, void *arg)\n{\n\tstruct rbd_obj_request *obj_req =\n\t    container_of(ex, struct rbd_obj_request, ex);\n\tstruct ceph_bio_iter *it = arg;\n\n\tdout(\"%s objno %llu bytes %u\\n\", __func__, ex->oe_objno, bytes);\n\tceph_bio_iter_advance_step(it, bytes, ({\n\t\tobj_req->bvec_pos.bvecs[obj_req->bvec_idx++] = bv;\n\t\tobj_req->bvec_pos.iter.bi_size += bv.bv_len;\n\t}));\n}\n\nstatic int __rbd_img_fill_from_bio(struct rbd_img_request *img_req,\n\t\t\t\t   struct ceph_file_extent *img_extents,\n\t\t\t\t   u32 num_img_extents,\n\t\t\t\t   struct ceph_bio_iter *bio_pos)\n{\n\tstruct rbd_img_fill_ctx fctx = {\n\t\t.pos_type = OBJ_REQUEST_BIO,\n\t\t.pos = (union rbd_img_fill_iter *)bio_pos,\n\t\t.set_pos_fn = set_bio_pos,\n\t\t.count_fn = count_bio_bvecs,\n\t\t.copy_fn = copy_bio_bvecs,\n\t};\n\n\treturn rbd_img_fill_request(img_req, img_extents, num_img_extents,\n\t\t\t\t    &fctx);\n}\n\nstatic int rbd_img_fill_from_bio(struct rbd_img_request *img_req,\n\t\t\t\t u64 off, u64 len, struct bio *bio)\n{\n\tstruct ceph_file_extent ex = { off, len };\n\tstruct ceph_bio_iter it = { .bio = bio, .iter = bio->bi_iter };\n\n\treturn __rbd_img_fill_from_bio(img_req, &ex, 1, &it);\n}\n\nstatic void set_bvec_pos(struct ceph_object_extent *ex, u32 bytes, void *arg)\n{\n\tstruct rbd_obj_request *obj_req =\n\t    container_of(ex, struct rbd_obj_request, ex);\n\tstruct ceph_bvec_iter *it = arg;\n\n\tobj_req->bvec_pos = *it;\n\tceph_bvec_iter_shorten(&obj_req->bvec_pos, bytes);\n\tceph_bvec_iter_advance(it, bytes);\n}\n\nstatic void count_bvecs(struct ceph_object_extent *ex, u32 bytes, void *arg)\n{\n\tstruct rbd_obj_request *obj_req =\n\t    container_of(ex, struct rbd_obj_request, ex);\n\tstruct ceph_bvec_iter *it = arg;\n\n\tceph_bvec_iter_advance_step(it, bytes, ({\n\t\tobj_req->bvec_count++;\n\t}));\n}\n\nstatic void copy_bvecs(struct ceph_object_extent *ex, u32 bytes, void *arg)\n{\n\tstruct rbd_obj_request *obj_req =\n\t    container_of(ex, struct rbd_obj_request, ex);\n\tstruct ceph_bvec_iter *it = arg;\n\n\tceph_bvec_iter_advance_step(it, bytes, ({\n\t\tobj_req->bvec_pos.bvecs[obj_req->bvec_idx++] = bv;\n\t\tobj_req->bvec_pos.iter.bi_size += bv.bv_len;\n\t}));\n}\n\nstatic int __rbd_img_fill_from_bvecs(struct rbd_img_request *img_req,\n\t\t\t\t     struct ceph_file_extent *img_extents,\n\t\t\t\t     u32 num_img_extents,\n\t\t\t\t     struct ceph_bvec_iter *bvec_pos)\n{\n\tstruct rbd_img_fill_ctx fctx = {\n\t\t.pos_type = OBJ_REQUEST_BVECS,\n\t\t.pos = (union rbd_img_fill_iter *)bvec_pos,\n\t\t.set_pos_fn = set_bvec_pos,\n\t\t.count_fn = count_bvecs,\n\t\t.copy_fn = copy_bvecs,\n\t};\n\n\treturn rbd_img_fill_request(img_req, img_extents, num_img_extents,\n\t\t\t\t    &fctx);\n}\n\nstatic int rbd_img_fill_from_bvecs(struct rbd_img_request *img_req,\n\t\t\t\t   struct ceph_file_extent *img_extents,\n\t\t\t\t   u32 num_img_extents,\n\t\t\t\t   struct bio_vec *bvecs)\n{\n\tstruct ceph_bvec_iter it = {\n\t\t.bvecs = bvecs,\n\t\t.iter = { .bi_size = ceph_file_extents_bytes(img_extents,\n\t\t\t\t\t\t\t     num_img_extents) },\n\t};\n\n\treturn __rbd_img_fill_from_bvecs(img_req, img_extents, num_img_extents,\n\t\t\t\t\t &it);\n}\n\nstatic void rbd_img_handle_request_work(struct work_struct *work)\n{\n\tstruct rbd_img_request *img_req =\n\t    container_of(work, struct rbd_img_request, work);\n\n\trbd_img_handle_request(img_req, img_req->work_result);\n}\n\nstatic void rbd_img_schedule(struct rbd_img_request *img_req, int result)\n{\n\tINIT_WORK(&img_req->work, rbd_img_handle_request_work);\n\timg_req->work_result = result;\n\tqueue_work(rbd_wq, &img_req->work);\n}\n\nstatic bool rbd_obj_may_exist(struct rbd_obj_request *obj_req)\n{\n\tstruct rbd_device *rbd_dev = obj_req->img_request->rbd_dev;\n\n\tif (rbd_object_map_may_exist(rbd_dev, obj_req->ex.oe_objno)) {\n\t\tobj_req->flags |= RBD_OBJ_FLAG_MAY_EXIST;\n\t\treturn true;\n\t}\n\n\tdout(\"%s %p objno %llu assuming dne\\n\", __func__, obj_req,\n\t     obj_req->ex.oe_objno);\n\treturn false;\n}\n\nstatic int rbd_obj_read_object(struct rbd_obj_request *obj_req)\n{\n\tstruct ceph_osd_request *osd_req;\n\tint ret;\n\n\tosd_req = __rbd_obj_add_osd_request(obj_req, NULL, 1);\n\tif (IS_ERR(osd_req))\n\t\treturn PTR_ERR(osd_req);\n\n\tosd_req_op_extent_init(osd_req, 0, CEPH_OSD_OP_READ,\n\t\t\t       obj_req->ex.oe_off, obj_req->ex.oe_len, 0, 0);\n\trbd_osd_setup_data(osd_req, 0);\n\trbd_osd_format_read(osd_req);\n\n\tret = ceph_osdc_alloc_messages(osd_req, GFP_NOIO);\n\tif (ret)\n\t\treturn ret;\n\n\trbd_osd_submit(osd_req);\n\treturn 0;\n}\n\nstatic int rbd_obj_read_from_parent(struct rbd_obj_request *obj_req)\n{\n\tstruct rbd_img_request *img_req = obj_req->img_request;\n\tstruct rbd_device *parent = img_req->rbd_dev->parent;\n\tstruct rbd_img_request *child_img_req;\n\tint ret;\n\n\tchild_img_req = kmem_cache_alloc(rbd_img_request_cache, GFP_NOIO);\n\tif (!child_img_req)\n\t\treturn -ENOMEM;\n\n\trbd_img_request_init(child_img_req, parent, OBJ_OP_READ);\n\t__set_bit(IMG_REQ_CHILD, &child_img_req->flags);\n\tchild_img_req->obj_request = obj_req;\n\n\tdown_read(&parent->header_rwsem);\n\trbd_img_capture_header(child_img_req);\n\tup_read(&parent->header_rwsem);\n\n\tdout(\"%s child_img_req %p for obj_req %p\\n\", __func__, child_img_req,\n\t     obj_req);\n\n\tif (!rbd_img_is_write(img_req)) {\n\t\tswitch (img_req->data_type) {\n\t\tcase OBJ_REQUEST_BIO:\n\t\t\tret = __rbd_img_fill_from_bio(child_img_req,\n\t\t\t\t\t\t      obj_req->img_extents,\n\t\t\t\t\t\t      obj_req->num_img_extents,\n\t\t\t\t\t\t      &obj_req->bio_pos);\n\t\t\tbreak;\n\t\tcase OBJ_REQUEST_BVECS:\n\t\tcase OBJ_REQUEST_OWN_BVECS:\n\t\t\tret = __rbd_img_fill_from_bvecs(child_img_req,\n\t\t\t\t\t\t      obj_req->img_extents,\n\t\t\t\t\t\t      obj_req->num_img_extents,\n\t\t\t\t\t\t      &obj_req->bvec_pos);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t} else {\n\t\tret = rbd_img_fill_from_bvecs(child_img_req,\n\t\t\t\t\t      obj_req->img_extents,\n\t\t\t\t\t      obj_req->num_img_extents,\n\t\t\t\t\t      obj_req->copyup_bvecs);\n\t}\n\tif (ret) {\n\t\trbd_img_request_destroy(child_img_req);\n\t\treturn ret;\n\t}\n\n\t/* avoid parent chain recursion */\n\trbd_img_schedule(child_img_req, 0);\n\treturn 0;\n}\n\nstatic bool rbd_obj_advance_read(struct rbd_obj_request *obj_req, int *result)\n{\n\tstruct rbd_device *rbd_dev = obj_req->img_request->rbd_dev;\n\tint ret;\n\nagain:\n\tswitch (obj_req->read_state) {\n\tcase RBD_OBJ_READ_START:\n\t\trbd_assert(!*result);\n\n\t\tif (!rbd_obj_may_exist(obj_req)) {\n\t\t\t*result = -ENOENT;\n\t\t\tobj_req->read_state = RBD_OBJ_READ_OBJECT;\n\t\t\tgoto again;\n\t\t}\n\n\t\tret = rbd_obj_read_object(obj_req);\n\t\tif (ret) {\n\t\t\t*result = ret;\n\t\t\treturn true;\n\t\t}\n\t\tobj_req->read_state = RBD_OBJ_READ_OBJECT;\n\t\treturn false;\n\tcase RBD_OBJ_READ_OBJECT:\n\t\tif (*result == -ENOENT && rbd_dev->parent_overlap) {\n\t\t\t/* reverse map this object extent onto the parent */\n\t\t\tret = rbd_obj_calc_img_extents(obj_req, false);\n\t\t\tif (ret) {\n\t\t\t\t*result = ret;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (obj_req->num_img_extents) {\n\t\t\t\tret = rbd_obj_read_from_parent(obj_req);\n\t\t\t\tif (ret) {\n\t\t\t\t\t*result = ret;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tobj_req->read_state = RBD_OBJ_READ_PARENT;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * -ENOENT means a hole in the image -- zero-fill the entire\n\t\t * length of the request.  A short read also implies zero-fill\n\t\t * to the end of the request.\n\t\t */\n\t\tif (*result == -ENOENT) {\n\t\t\trbd_obj_zero_range(obj_req, 0, obj_req->ex.oe_len);\n\t\t\t*result = 0;\n\t\t} else if (*result >= 0) {\n\t\t\tif (*result < obj_req->ex.oe_len)\n\t\t\t\trbd_obj_zero_range(obj_req, *result,\n\t\t\t\t\t\tobj_req->ex.oe_len - *result);\n\t\t\telse\n\t\t\t\trbd_assert(*result == obj_req->ex.oe_len);\n\t\t\t*result = 0;\n\t\t}\n\t\treturn true;\n\tcase RBD_OBJ_READ_PARENT:\n\t\t/*\n\t\t * The parent image is read only up to the overlap -- zero-fill\n\t\t * from the overlap to the end of the request.\n\t\t */\n\t\tif (!*result) {\n\t\t\tu32 obj_overlap = rbd_obj_img_extents_bytes(obj_req);\n\n\t\t\tif (obj_overlap < obj_req->ex.oe_len)\n\t\t\t\trbd_obj_zero_range(obj_req, obj_overlap,\n\t\t\t\t\t    obj_req->ex.oe_len - obj_overlap);\n\t\t}\n\t\treturn true;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic bool rbd_obj_write_is_noop(struct rbd_obj_request *obj_req)\n{\n\tstruct rbd_device *rbd_dev = obj_req->img_request->rbd_dev;\n\n\tif (rbd_object_map_may_exist(rbd_dev, obj_req->ex.oe_objno))\n\t\tobj_req->flags |= RBD_OBJ_FLAG_MAY_EXIST;\n\n\tif (!(obj_req->flags & RBD_OBJ_FLAG_MAY_EXIST) &&\n\t    (obj_req->flags & RBD_OBJ_FLAG_NOOP_FOR_NONEXISTENT)) {\n\t\tdout(\"%s %p noop for nonexistent\\n\", __func__, obj_req);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * Return:\n *   0 - object map update sent\n *   1 - object map update isn't needed\n *  <0 - error\n */\nstatic int rbd_obj_write_pre_object_map(struct rbd_obj_request *obj_req)\n{\n\tstruct rbd_device *rbd_dev = obj_req->img_request->rbd_dev;\n\tu8 new_state;\n\n\tif (!(rbd_dev->header.features & RBD_FEATURE_OBJECT_MAP))\n\t\treturn 1;\n\n\tif (obj_req->flags & RBD_OBJ_FLAG_DELETION)\n\t\tnew_state = OBJECT_PENDING;\n\telse\n\t\tnew_state = OBJECT_EXISTS;\n\n\treturn rbd_object_map_update(obj_req, CEPH_NOSNAP, new_state, NULL);\n}\n\nstatic int rbd_obj_write_object(struct rbd_obj_request *obj_req)\n{\n\tstruct ceph_osd_request *osd_req;\n\tint num_ops = count_write_ops(obj_req);\n\tint which = 0;\n\tint ret;\n\n\tif (obj_req->flags & RBD_OBJ_FLAG_COPYUP_ENABLED)\n\t\tnum_ops++; /* stat */\n\n\tosd_req = rbd_obj_add_osd_request(obj_req, num_ops);\n\tif (IS_ERR(osd_req))\n\t\treturn PTR_ERR(osd_req);\n\n\tif (obj_req->flags & RBD_OBJ_FLAG_COPYUP_ENABLED) {\n\t\tret = rbd_osd_setup_stat(osd_req, which++);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\trbd_osd_setup_write_ops(osd_req, which);\n\trbd_osd_format_write(osd_req);\n\n\tret = ceph_osdc_alloc_messages(osd_req, GFP_NOIO);\n\tif (ret)\n\t\treturn ret;\n\n\trbd_osd_submit(osd_req);\n\treturn 0;\n}\n\n/*\n * copyup_bvecs pages are never highmem pages\n */\nstatic bool is_zero_bvecs(struct bio_vec *bvecs, u32 bytes)\n{\n\tstruct ceph_bvec_iter it = {\n\t\t.bvecs = bvecs,\n\t\t.iter = { .bi_size = bytes },\n\t};\n\n\tceph_bvec_iter_advance_step(&it, bytes, ({\n\t\tif (memchr_inv(page_address(bv.bv_page) + bv.bv_offset, 0,\n\t\t\t       bv.bv_len))\n\t\t\treturn false;\n\t}));\n\treturn true;\n}\n\n#define MODS_ONLY\tU32_MAX\n\nstatic int rbd_obj_copyup_empty_snapc(struct rbd_obj_request *obj_req,\n\t\t\t\t      u32 bytes)\n{\n\tstruct ceph_osd_request *osd_req;\n\tint ret;\n\n\tdout(\"%s obj_req %p bytes %u\\n\", __func__, obj_req, bytes);\n\trbd_assert(bytes > 0 && bytes != MODS_ONLY);\n\n\tosd_req = __rbd_obj_add_osd_request(obj_req, &rbd_empty_snapc, 1);\n\tif (IS_ERR(osd_req))\n\t\treturn PTR_ERR(osd_req);\n\n\tret = rbd_osd_setup_copyup(osd_req, 0, bytes);\n\tif (ret)\n\t\treturn ret;\n\n\trbd_osd_format_write(osd_req);\n\n\tret = ceph_osdc_alloc_messages(osd_req, GFP_NOIO);\n\tif (ret)\n\t\treturn ret;\n\n\trbd_osd_submit(osd_req);\n\treturn 0;\n}\n\nstatic int rbd_obj_copyup_current_snapc(struct rbd_obj_request *obj_req,\n\t\t\t\t\tu32 bytes)\n{\n\tstruct ceph_osd_request *osd_req;\n\tint num_ops = count_write_ops(obj_req);\n\tint which = 0;\n\tint ret;\n\n\tdout(\"%s obj_req %p bytes %u\\n\", __func__, obj_req, bytes);\n\n\tif (bytes != MODS_ONLY)\n\t\tnum_ops++; /* copyup */\n\n\tosd_req = rbd_obj_add_osd_request(obj_req, num_ops);\n\tif (IS_ERR(osd_req))\n\t\treturn PTR_ERR(osd_req);\n\n\tif (bytes != MODS_ONLY) {\n\t\tret = rbd_osd_setup_copyup(osd_req, which++, bytes);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\trbd_osd_setup_write_ops(osd_req, which);\n\trbd_osd_format_write(osd_req);\n\n\tret = ceph_osdc_alloc_messages(osd_req, GFP_NOIO);\n\tif (ret)\n\t\treturn ret;\n\n\trbd_osd_submit(osd_req);\n\treturn 0;\n}\n\nstatic int setup_copyup_bvecs(struct rbd_obj_request *obj_req, u64 obj_overlap)\n{\n\tu32 i;\n\n\trbd_assert(!obj_req->copyup_bvecs);\n\tobj_req->copyup_bvec_count = calc_pages_for(0, obj_overlap);\n\tobj_req->copyup_bvecs = kcalloc(obj_req->copyup_bvec_count,\n\t\t\t\t\tsizeof(*obj_req->copyup_bvecs),\n\t\t\t\t\tGFP_NOIO);\n\tif (!obj_req->copyup_bvecs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < obj_req->copyup_bvec_count; i++) {\n\t\tunsigned int len = min(obj_overlap, (u64)PAGE_SIZE);\n\n\t\tobj_req->copyup_bvecs[i].bv_page = alloc_page(GFP_NOIO);\n\t\tif (!obj_req->copyup_bvecs[i].bv_page)\n\t\t\treturn -ENOMEM;\n\n\t\tobj_req->copyup_bvecs[i].bv_offset = 0;\n\t\tobj_req->copyup_bvecs[i].bv_len = len;\n\t\tobj_overlap -= len;\n\t}\n\n\trbd_assert(!obj_overlap);\n\treturn 0;\n}\n\n/*\n * The target object doesn't exist.  Read the data for the entire\n * target object up to the overlap point (if any) from the parent,\n * so we can use it for a copyup.\n */\nstatic int rbd_obj_copyup_read_parent(struct rbd_obj_request *obj_req)\n{\n\tstruct rbd_device *rbd_dev = obj_req->img_request->rbd_dev;\n\tint ret;\n\n\trbd_assert(obj_req->num_img_extents);\n\tprune_extents(obj_req->img_extents, &obj_req->num_img_extents,\n\t\t      rbd_dev->parent_overlap);\n\tif (!obj_req->num_img_extents) {\n\t\t/*\n\t\t * The overlap has become 0 (most likely because the\n\t\t * image has been flattened).  Re-submit the original write\n\t\t * request -- pass MODS_ONLY since the copyup isn't needed\n\t\t * anymore.\n\t\t */\n\t\treturn rbd_obj_copyup_current_snapc(obj_req, MODS_ONLY);\n\t}\n\n\tret = setup_copyup_bvecs(obj_req, rbd_obj_img_extents_bytes(obj_req));\n\tif (ret)\n\t\treturn ret;\n\n\treturn rbd_obj_read_from_parent(obj_req);\n}\n\nstatic void rbd_obj_copyup_object_maps(struct rbd_obj_request *obj_req)\n{\n\tstruct rbd_device *rbd_dev = obj_req->img_request->rbd_dev;\n\tstruct ceph_snap_context *snapc = obj_req->img_request->snapc;\n\tu8 new_state;\n\tu32 i;\n\tint ret;\n\n\trbd_assert(!obj_req->pending.result && !obj_req->pending.num_pending);\n\n\tif (!(rbd_dev->header.features & RBD_FEATURE_OBJECT_MAP))\n\t\treturn;\n\n\tif (obj_req->flags & RBD_OBJ_FLAG_COPYUP_ZEROS)\n\t\treturn;\n\n\tfor (i = 0; i < snapc->num_snaps; i++) {\n\t\tif ((rbd_dev->header.features & RBD_FEATURE_FAST_DIFF) &&\n\t\t    i + 1 < snapc->num_snaps)\n\t\t\tnew_state = OBJECT_EXISTS_CLEAN;\n\t\telse\n\t\t\tnew_state = OBJECT_EXISTS;\n\n\t\tret = rbd_object_map_update(obj_req, snapc->snaps[i],\n\t\t\t\t\t    new_state, NULL);\n\t\tif (ret < 0) {\n\t\t\tobj_req->pending.result = ret;\n\t\t\treturn;\n\t\t}\n\n\t\trbd_assert(!ret);\n\t\tobj_req->pending.num_pending++;\n\t}\n}\n\nstatic void rbd_obj_copyup_write_object(struct rbd_obj_request *obj_req)\n{\n\tu32 bytes = rbd_obj_img_extents_bytes(obj_req);\n\tint ret;\n\n\trbd_assert(!obj_req->pending.result && !obj_req->pending.num_pending);\n\n\t/*\n\t * Only send non-zero copyup data to save some I/O and network\n\t * bandwidth -- zero copyup data is equivalent to the object not\n\t * existing.\n\t */\n\tif (obj_req->flags & RBD_OBJ_FLAG_COPYUP_ZEROS)\n\t\tbytes = 0;\n\n\tif (obj_req->img_request->snapc->num_snaps && bytes > 0) {\n\t\t/*\n\t\t * Send a copyup request with an empty snapshot context to\n\t\t * deep-copyup the object through all existing snapshots.\n\t\t * A second request with the current snapshot context will be\n\t\t * sent for the actual modification.\n\t\t */\n\t\tret = rbd_obj_copyup_empty_snapc(obj_req, bytes);\n\t\tif (ret) {\n\t\t\tobj_req->pending.result = ret;\n\t\t\treturn;\n\t\t}\n\n\t\tobj_req->pending.num_pending++;\n\t\tbytes = MODS_ONLY;\n\t}\n\n\tret = rbd_obj_copyup_current_snapc(obj_req, bytes);\n\tif (ret) {\n\t\tobj_req->pending.result = ret;\n\t\treturn;\n\t}\n\n\tobj_req->pending.num_pending++;\n}\n\nstatic bool rbd_obj_advance_copyup(struct rbd_obj_request *obj_req, int *result)\n{\n\tstruct rbd_device *rbd_dev = obj_req->img_request->rbd_dev;\n\tint ret;\n\nagain:\n\tswitch (obj_req->copyup_state) {\n\tcase RBD_OBJ_COPYUP_START:\n\t\trbd_assert(!*result);\n\n\t\tret = rbd_obj_copyup_read_parent(obj_req);\n\t\tif (ret) {\n\t\t\t*result = ret;\n\t\t\treturn true;\n\t\t}\n\t\tif (obj_req->num_img_extents)\n\t\t\tobj_req->copyup_state = RBD_OBJ_COPYUP_READ_PARENT;\n\t\telse\n\t\t\tobj_req->copyup_state = RBD_OBJ_COPYUP_WRITE_OBJECT;\n\t\treturn false;\n\tcase RBD_OBJ_COPYUP_READ_PARENT:\n\t\tif (*result)\n\t\t\treturn true;\n\n\t\tif (is_zero_bvecs(obj_req->copyup_bvecs,\n\t\t\t\t  rbd_obj_img_extents_bytes(obj_req))) {\n\t\t\tdout(\"%s %p detected zeros\\n\", __func__, obj_req);\n\t\t\tobj_req->flags |= RBD_OBJ_FLAG_COPYUP_ZEROS;\n\t\t}\n\n\t\trbd_obj_copyup_object_maps(obj_req);\n\t\tif (!obj_req->pending.num_pending) {\n\t\t\t*result = obj_req->pending.result;\n\t\t\tobj_req->copyup_state = RBD_OBJ_COPYUP_OBJECT_MAPS;\n\t\t\tgoto again;\n\t\t}\n\t\tobj_req->copyup_state = __RBD_OBJ_COPYUP_OBJECT_MAPS;\n\t\treturn false;\n\tcase __RBD_OBJ_COPYUP_OBJECT_MAPS:\n\t\tif (!pending_result_dec(&obj_req->pending, result))\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase RBD_OBJ_COPYUP_OBJECT_MAPS:\n\t\tif (*result) {\n\t\t\trbd_warn(rbd_dev, \"snap object map update failed: %d\",\n\t\t\t\t *result);\n\t\t\treturn true;\n\t\t}\n\n\t\trbd_obj_copyup_write_object(obj_req);\n\t\tif (!obj_req->pending.num_pending) {\n\t\t\t*result = obj_req->pending.result;\n\t\t\tobj_req->copyup_state = RBD_OBJ_COPYUP_WRITE_OBJECT;\n\t\t\tgoto again;\n\t\t}\n\t\tobj_req->copyup_state = __RBD_OBJ_COPYUP_WRITE_OBJECT;\n\t\treturn false;\n\tcase __RBD_OBJ_COPYUP_WRITE_OBJECT:\n\t\tif (!pending_result_dec(&obj_req->pending, result))\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase RBD_OBJ_COPYUP_WRITE_OBJECT:\n\t\treturn true;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n/*\n * Return:\n *   0 - object map update sent\n *   1 - object map update isn't needed\n *  <0 - error\n */\nstatic int rbd_obj_write_post_object_map(struct rbd_obj_request *obj_req)\n{\n\tstruct rbd_device *rbd_dev = obj_req->img_request->rbd_dev;\n\tu8 current_state = OBJECT_PENDING;\n\n\tif (!(rbd_dev->header.features & RBD_FEATURE_OBJECT_MAP))\n\t\treturn 1;\n\n\tif (!(obj_req->flags & RBD_OBJ_FLAG_DELETION))\n\t\treturn 1;\n\n\treturn rbd_object_map_update(obj_req, CEPH_NOSNAP, OBJECT_NONEXISTENT,\n\t\t\t\t     &current_state);\n}\n\nstatic bool rbd_obj_advance_write(struct rbd_obj_request *obj_req, int *result)\n{\n\tstruct rbd_device *rbd_dev = obj_req->img_request->rbd_dev;\n\tint ret;\n\nagain:\n\tswitch (obj_req->write_state) {\n\tcase RBD_OBJ_WRITE_START:\n\t\trbd_assert(!*result);\n\n\t\tif (rbd_obj_write_is_noop(obj_req))\n\t\t\treturn true;\n\n\t\tret = rbd_obj_write_pre_object_map(obj_req);\n\t\tif (ret < 0) {\n\t\t\t*result = ret;\n\t\t\treturn true;\n\t\t}\n\t\tobj_req->write_state = RBD_OBJ_WRITE_PRE_OBJECT_MAP;\n\t\tif (ret > 0)\n\t\t\tgoto again;\n\t\treturn false;\n\tcase RBD_OBJ_WRITE_PRE_OBJECT_MAP:\n\t\tif (*result) {\n\t\t\trbd_warn(rbd_dev, \"pre object map update failed: %d\",\n\t\t\t\t *result);\n\t\t\treturn true;\n\t\t}\n\t\tret = rbd_obj_write_object(obj_req);\n\t\tif (ret) {\n\t\t\t*result = ret;\n\t\t\treturn true;\n\t\t}\n\t\tobj_req->write_state = RBD_OBJ_WRITE_OBJECT;\n\t\treturn false;\n\tcase RBD_OBJ_WRITE_OBJECT:\n\t\tif (*result == -ENOENT) {\n\t\t\tif (obj_req->flags & RBD_OBJ_FLAG_COPYUP_ENABLED) {\n\t\t\t\t*result = 0;\n\t\t\t\tobj_req->copyup_state = RBD_OBJ_COPYUP_START;\n\t\t\t\tobj_req->write_state = __RBD_OBJ_WRITE_COPYUP;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\t/*\n\t\t\t * On a non-existent object:\n\t\t\t *   delete - -ENOENT, truncate/zero - 0\n\t\t\t */\n\t\t\tif (obj_req->flags & RBD_OBJ_FLAG_DELETION)\n\t\t\t\t*result = 0;\n\t\t}\n\t\tif (*result)\n\t\t\treturn true;\n\n\t\tobj_req->write_state = RBD_OBJ_WRITE_COPYUP;\n\t\tgoto again;\n\tcase __RBD_OBJ_WRITE_COPYUP:\n\t\tif (!rbd_obj_advance_copyup(obj_req, result))\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase RBD_OBJ_WRITE_COPYUP:\n\t\tif (*result) {\n\t\t\trbd_warn(rbd_dev, \"copyup failed: %d\", *result);\n\t\t\treturn true;\n\t\t}\n\t\tret = rbd_obj_write_post_object_map(obj_req);\n\t\tif (ret < 0) {\n\t\t\t*result = ret;\n\t\t\treturn true;\n\t\t}\n\t\tobj_req->write_state = RBD_OBJ_WRITE_POST_OBJECT_MAP;\n\t\tif (ret > 0)\n\t\t\tgoto again;\n\t\treturn false;\n\tcase RBD_OBJ_WRITE_POST_OBJECT_MAP:\n\t\tif (*result)\n\t\t\trbd_warn(rbd_dev, \"post object map update failed: %d\",\n\t\t\t\t *result);\n\t\treturn true;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n/*\n * Return true if @obj_req is completed.\n */\nstatic bool __rbd_obj_handle_request(struct rbd_obj_request *obj_req,\n\t\t\t\t     int *result)\n{\n\tstruct rbd_img_request *img_req = obj_req->img_request;\n\tstruct rbd_device *rbd_dev = img_req->rbd_dev;\n\tbool done;\n\n\tmutex_lock(&obj_req->state_mutex);\n\tif (!rbd_img_is_write(img_req))\n\t\tdone = rbd_obj_advance_read(obj_req, result);\n\telse\n\t\tdone = rbd_obj_advance_write(obj_req, result);\n\tmutex_unlock(&obj_req->state_mutex);\n\n\tif (done && *result) {\n\t\trbd_assert(*result < 0);\n\t\trbd_warn(rbd_dev, \"%s at objno %llu %llu~%llu result %d\",\n\t\t\t obj_op_name(img_req->op_type), obj_req->ex.oe_objno,\n\t\t\t obj_req->ex.oe_off, obj_req->ex.oe_len, *result);\n\t}\n\treturn done;\n}\n\n/*\n * This is open-coded in rbd_img_handle_request() to avoid parent chain\n * recursion.\n */\nstatic void rbd_obj_handle_request(struct rbd_obj_request *obj_req, int result)\n{\n\tif (__rbd_obj_handle_request(obj_req, &result))\n\t\trbd_img_handle_request(obj_req->img_request, result);\n}\n\nstatic bool need_exclusive_lock(struct rbd_img_request *img_req)\n{\n\tstruct rbd_device *rbd_dev = img_req->rbd_dev;\n\n\tif (!(rbd_dev->header.features & RBD_FEATURE_EXCLUSIVE_LOCK))\n\t\treturn false;\n\n\tif (rbd_is_ro(rbd_dev))\n\t\treturn false;\n\n\trbd_assert(!test_bit(IMG_REQ_CHILD, &img_req->flags));\n\tif (rbd_dev->opts->lock_on_read ||\n\t    (rbd_dev->header.features & RBD_FEATURE_OBJECT_MAP))\n\t\treturn true;\n\n\treturn rbd_img_is_write(img_req);\n}\n\nstatic bool rbd_lock_add_request(struct rbd_img_request *img_req)\n{\n\tstruct rbd_device *rbd_dev = img_req->rbd_dev;\n\tbool locked;\n\n\tlockdep_assert_held(&rbd_dev->lock_rwsem);\n\tlocked = rbd_dev->lock_state == RBD_LOCK_STATE_LOCKED;\n\tspin_lock(&rbd_dev->lock_lists_lock);\n\trbd_assert(list_empty(&img_req->lock_item));\n\tif (!locked)\n\t\tlist_add_tail(&img_req->lock_item, &rbd_dev->acquiring_list);\n\telse\n\t\tlist_add_tail(&img_req->lock_item, &rbd_dev->running_list);\n\tspin_unlock(&rbd_dev->lock_lists_lock);\n\treturn locked;\n}\n\nstatic void rbd_lock_del_request(struct rbd_img_request *img_req)\n{\n\tstruct rbd_device *rbd_dev = img_req->rbd_dev;\n\tbool need_wakeup;\n\n\tlockdep_assert_held(&rbd_dev->lock_rwsem);\n\tspin_lock(&rbd_dev->lock_lists_lock);\n\trbd_assert(!list_empty(&img_req->lock_item));\n\tlist_del_init(&img_req->lock_item);\n\tneed_wakeup = (rbd_dev->lock_state == RBD_LOCK_STATE_RELEASING &&\n\t\t       list_empty(&rbd_dev->running_list));\n\tspin_unlock(&rbd_dev->lock_lists_lock);\n\tif (need_wakeup)\n\t\tcomplete(&rbd_dev->releasing_wait);\n}\n\nstatic int rbd_img_exclusive_lock(struct rbd_img_request *img_req)\n{\n\tstruct rbd_device *rbd_dev = img_req->rbd_dev;\n\n\tif (!need_exclusive_lock(img_req))\n\t\treturn 1;\n\n\tif (rbd_lock_add_request(img_req))\n\t\treturn 1;\n\n\tif (rbd_dev->opts->exclusive) {\n\t\tWARN_ON(1); /* lock got released? */\n\t\treturn -EROFS;\n\t}\n\n\t/*\n\t * Note the use of mod_delayed_work() in rbd_acquire_lock()\n\t * and cancel_delayed_work() in wake_lock_waiters().\n\t */\n\tdout(\"%s rbd_dev %p queueing lock_dwork\\n\", __func__, rbd_dev);\n\tqueue_delayed_work(rbd_dev->task_wq, &rbd_dev->lock_dwork, 0);\n\treturn 0;\n}\n\nstatic void rbd_img_object_requests(struct rbd_img_request *img_req)\n{\n\tstruct rbd_obj_request *obj_req;\n\n\trbd_assert(!img_req->pending.result && !img_req->pending.num_pending);\n\n\tfor_each_obj_request(img_req, obj_req) {\n\t\tint result = 0;\n\n\t\tif (__rbd_obj_handle_request(obj_req, &result)) {\n\t\t\tif (result) {\n\t\t\t\timg_req->pending.result = result;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\timg_req->pending.num_pending++;\n\t\t}\n\t}\n}\n\nstatic bool rbd_img_advance(struct rbd_img_request *img_req, int *result)\n{\n\tstruct rbd_device *rbd_dev = img_req->rbd_dev;\n\tint ret;\n\nagain:\n\tswitch (img_req->state) {\n\tcase RBD_IMG_START:\n\t\trbd_assert(!*result);\n\n\t\tret = rbd_img_exclusive_lock(img_req);\n\t\tif (ret < 0) {\n\t\t\t*result = ret;\n\t\t\treturn true;\n\t\t}\n\t\timg_req->state = RBD_IMG_EXCLUSIVE_LOCK;\n\t\tif (ret > 0)\n\t\t\tgoto again;\n\t\treturn false;\n\tcase RBD_IMG_EXCLUSIVE_LOCK:\n\t\tif (*result)\n\t\t\treturn true;\n\n\t\trbd_assert(!need_exclusive_lock(img_req) ||\n\t\t\t   __rbd_is_lock_owner(rbd_dev));\n\n\t\trbd_img_object_requests(img_req);\n\t\tif (!img_req->pending.num_pending) {\n\t\t\t*result = img_req->pending.result;\n\t\t\timg_req->state = RBD_IMG_OBJECT_REQUESTS;\n\t\t\tgoto again;\n\t\t}\n\t\timg_req->state = __RBD_IMG_OBJECT_REQUESTS;\n\t\treturn false;\n\tcase __RBD_IMG_OBJECT_REQUESTS:\n\t\tif (!pending_result_dec(&img_req->pending, result))\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase RBD_IMG_OBJECT_REQUESTS:\n\t\treturn true;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n/*\n * Return true if @img_req is completed.\n */\nstatic bool __rbd_img_handle_request(struct rbd_img_request *img_req,\n\t\t\t\t     int *result)\n{\n\tstruct rbd_device *rbd_dev = img_req->rbd_dev;\n\tbool done;\n\n\tif (need_exclusive_lock(img_req)) {\n\t\tdown_read(&rbd_dev->lock_rwsem);\n\t\tmutex_lock(&img_req->state_mutex);\n\t\tdone = rbd_img_advance(img_req, result);\n\t\tif (done)\n\t\t\trbd_lock_del_request(img_req);\n\t\tmutex_unlock(&img_req->state_mutex);\n\t\tup_read(&rbd_dev->lock_rwsem);\n\t} else {\n\t\tmutex_lock(&img_req->state_mutex);\n\t\tdone = rbd_img_advance(img_req, result);\n\t\tmutex_unlock(&img_req->state_mutex);\n\t}\n\n\tif (done && *result) {\n\t\trbd_assert(*result < 0);\n\t\trbd_warn(rbd_dev, \"%s%s result %d\",\n\t\t      test_bit(IMG_REQ_CHILD, &img_req->flags) ? \"child \" : \"\",\n\t\t      obj_op_name(img_req->op_type), *result);\n\t}\n\treturn done;\n}\n\nstatic void rbd_img_handle_request(struct rbd_img_request *img_req, int result)\n{\nagain:\n\tif (!__rbd_img_handle_request(img_req, &result))\n\t\treturn;\n\n\tif (test_bit(IMG_REQ_CHILD, &img_req->flags)) {\n\t\tstruct rbd_obj_request *obj_req = img_req->obj_request;\n\n\t\trbd_img_request_destroy(img_req);\n\t\tif (__rbd_obj_handle_request(obj_req, &result)) {\n\t\t\timg_req = obj_req->img_request;\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tstruct request *rq = blk_mq_rq_from_pdu(img_req);\n\n\t\trbd_img_request_destroy(img_req);\n\t\tblk_mq_end_request(rq, errno_to_blk_status(result));\n\t}\n}\n\nstatic const struct rbd_client_id rbd_empty_cid;\n\nstatic bool rbd_cid_equal(const struct rbd_client_id *lhs,\n\t\t\t  const struct rbd_client_id *rhs)\n{\n\treturn lhs->gid == rhs->gid && lhs->handle == rhs->handle;\n}\n\nstatic struct rbd_client_id rbd_get_cid(struct rbd_device *rbd_dev)\n{\n\tstruct rbd_client_id cid;\n\n\tmutex_lock(&rbd_dev->watch_mutex);\n\tcid.gid = ceph_client_gid(rbd_dev->rbd_client->client);\n\tcid.handle = rbd_dev->watch_cookie;\n\tmutex_unlock(&rbd_dev->watch_mutex);\n\treturn cid;\n}\n\n/*\n * lock_rwsem must be held for write\n */\nstatic void rbd_set_owner_cid(struct rbd_device *rbd_dev,\n\t\t\t      const struct rbd_client_id *cid)\n{\n\tdout(\"%s rbd_dev %p %llu-%llu -> %llu-%llu\\n\", __func__, rbd_dev,\n\t     rbd_dev->owner_cid.gid, rbd_dev->owner_cid.handle,\n\t     cid->gid, cid->handle);\n\trbd_dev->owner_cid = *cid; /* struct */\n}\n\nstatic void format_lock_cookie(struct rbd_device *rbd_dev, char *buf)\n{\n\tmutex_lock(&rbd_dev->watch_mutex);\n\tsprintf(buf, \"%s %llu\", RBD_LOCK_COOKIE_PREFIX, rbd_dev->watch_cookie);\n\tmutex_unlock(&rbd_dev->watch_mutex);\n}\n\nstatic void __rbd_lock(struct rbd_device *rbd_dev, const char *cookie)\n{\n\tstruct rbd_client_id cid = rbd_get_cid(rbd_dev);\n\n\trbd_dev->lock_state = RBD_LOCK_STATE_LOCKED;\n\tstrcpy(rbd_dev->lock_cookie, cookie);\n\trbd_set_owner_cid(rbd_dev, &cid);\n\tqueue_work(rbd_dev->task_wq, &rbd_dev->acquired_lock_work);\n}\n\n/*\n * lock_rwsem must be held for write\n */\nstatic int rbd_lock(struct rbd_device *rbd_dev)\n{\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tchar cookie[32];\n\tint ret;\n\n\tWARN_ON(__rbd_is_lock_owner(rbd_dev) ||\n\t\trbd_dev->lock_cookie[0] != '\\0');\n\n\tformat_lock_cookie(rbd_dev, cookie);\n\tret = ceph_cls_lock(osdc, &rbd_dev->header_oid, &rbd_dev->header_oloc,\n\t\t\t    RBD_LOCK_NAME, CEPH_CLS_LOCK_EXCLUSIVE, cookie,\n\t\t\t    RBD_LOCK_TAG, \"\", 0);\n\tif (ret)\n\t\treturn ret;\n\n\t__rbd_lock(rbd_dev, cookie);\n\treturn 0;\n}\n\n/*\n * lock_rwsem must be held for write\n */\nstatic void rbd_unlock(struct rbd_device *rbd_dev)\n{\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tint ret;\n\n\tWARN_ON(!__rbd_is_lock_owner(rbd_dev) ||\n\t\trbd_dev->lock_cookie[0] == '\\0');\n\n\tret = ceph_cls_unlock(osdc, &rbd_dev->header_oid, &rbd_dev->header_oloc,\n\t\t\t      RBD_LOCK_NAME, rbd_dev->lock_cookie);\n\tif (ret && ret != -ENOENT)\n\t\trbd_warn(rbd_dev, \"failed to unlock header: %d\", ret);\n\n\t/* treat errors as the image is unlocked */\n\trbd_dev->lock_state = RBD_LOCK_STATE_UNLOCKED;\n\trbd_dev->lock_cookie[0] = '\\0';\n\trbd_set_owner_cid(rbd_dev, &rbd_empty_cid);\n\tqueue_work(rbd_dev->task_wq, &rbd_dev->released_lock_work);\n}\n\nstatic int __rbd_notify_op_lock(struct rbd_device *rbd_dev,\n\t\t\t\tenum rbd_notify_op notify_op,\n\t\t\t\tstruct page ***preply_pages,\n\t\t\t\tsize_t *preply_len)\n{\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tstruct rbd_client_id cid = rbd_get_cid(rbd_dev);\n\tchar buf[4 + 8 + 8 + CEPH_ENCODING_START_BLK_LEN];\n\tint buf_size = sizeof(buf);\n\tvoid *p = buf;\n\n\tdout(\"%s rbd_dev %p notify_op %d\\n\", __func__, rbd_dev, notify_op);\n\n\t/* encode *LockPayload NotifyMessage (op + ClientId) */\n\tceph_start_encoding(&p, 2, 1, buf_size - CEPH_ENCODING_START_BLK_LEN);\n\tceph_encode_32(&p, notify_op);\n\tceph_encode_64(&p, cid.gid);\n\tceph_encode_64(&p, cid.handle);\n\n\treturn ceph_osdc_notify(osdc, &rbd_dev->header_oid,\n\t\t\t\t&rbd_dev->header_oloc, buf, buf_size,\n\t\t\t\tRBD_NOTIFY_TIMEOUT, preply_pages, preply_len);\n}\n\nstatic void rbd_notify_op_lock(struct rbd_device *rbd_dev,\n\t\t\t       enum rbd_notify_op notify_op)\n{\n\t__rbd_notify_op_lock(rbd_dev, notify_op, NULL, NULL);\n}\n\nstatic void rbd_notify_acquired_lock(struct work_struct *work)\n{\n\tstruct rbd_device *rbd_dev = container_of(work, struct rbd_device,\n\t\t\t\t\t\t  acquired_lock_work);\n\n\trbd_notify_op_lock(rbd_dev, RBD_NOTIFY_OP_ACQUIRED_LOCK);\n}\n\nstatic void rbd_notify_released_lock(struct work_struct *work)\n{\n\tstruct rbd_device *rbd_dev = container_of(work, struct rbd_device,\n\t\t\t\t\t\t  released_lock_work);\n\n\trbd_notify_op_lock(rbd_dev, RBD_NOTIFY_OP_RELEASED_LOCK);\n}\n\nstatic int rbd_request_lock(struct rbd_device *rbd_dev)\n{\n\tstruct page **reply_pages;\n\tsize_t reply_len;\n\tbool lock_owner_responded = false;\n\tint ret;\n\n\tdout(\"%s rbd_dev %p\\n\", __func__, rbd_dev);\n\n\tret = __rbd_notify_op_lock(rbd_dev, RBD_NOTIFY_OP_REQUEST_LOCK,\n\t\t\t\t   &reply_pages, &reply_len);\n\tif (ret && ret != -ETIMEDOUT) {\n\t\trbd_warn(rbd_dev, \"failed to request lock: %d\", ret);\n\t\tgoto out;\n\t}\n\n\tif (reply_len > 0 && reply_len <= PAGE_SIZE) {\n\t\tvoid *p = page_address(reply_pages[0]);\n\t\tvoid *const end = p + reply_len;\n\t\tu32 n;\n\n\t\tceph_decode_32_safe(&p, end, n, e_inval); /* num_acks */\n\t\twhile (n--) {\n\t\t\tu8 struct_v;\n\t\t\tu32 len;\n\n\t\t\tceph_decode_need(&p, end, 8 + 8, e_inval);\n\t\t\tp += 8 + 8; /* skip gid and cookie */\n\n\t\t\tceph_decode_32_safe(&p, end, len, e_inval);\n\t\t\tif (!len)\n\t\t\t\tcontinue;\n\n\t\t\tif (lock_owner_responded) {\n\t\t\t\trbd_warn(rbd_dev,\n\t\t\t\t\t \"duplicate lock owners detected\");\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlock_owner_responded = true;\n\t\t\tret = ceph_start_decoding(&p, end, 1, \"ResponseMessage\",\n\t\t\t\t\t\t  &struct_v, &len);\n\t\t\tif (ret) {\n\t\t\t\trbd_warn(rbd_dev,\n\t\t\t\t\t \"failed to decode ResponseMessage: %d\",\n\t\t\t\t\t ret);\n\t\t\t\tgoto e_inval;\n\t\t\t}\n\n\t\t\tret = ceph_decode_32(&p);\n\t\t}\n\t}\n\n\tif (!lock_owner_responded) {\n\t\trbd_warn(rbd_dev, \"no lock owners detected\");\n\t\tret = -ETIMEDOUT;\n\t}\n\nout:\n\tceph_release_page_vector(reply_pages, calc_pages_for(0, reply_len));\n\treturn ret;\n\ne_inval:\n\tret = -EINVAL;\n\tgoto out;\n}\n\n/*\n * Either image request state machine(s) or rbd_add_acquire_lock()\n * (i.e. \"rbd map\").\n */\nstatic void wake_lock_waiters(struct rbd_device *rbd_dev, int result)\n{\n\tstruct rbd_img_request *img_req;\n\n\tdout(\"%s rbd_dev %p result %d\\n\", __func__, rbd_dev, result);\n\tlockdep_assert_held_write(&rbd_dev->lock_rwsem);\n\n\tcancel_delayed_work(&rbd_dev->lock_dwork);\n\tif (!completion_done(&rbd_dev->acquire_wait)) {\n\t\trbd_assert(list_empty(&rbd_dev->acquiring_list) &&\n\t\t\t   list_empty(&rbd_dev->running_list));\n\t\trbd_dev->acquire_err = result;\n\t\tcomplete_all(&rbd_dev->acquire_wait);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(img_req, &rbd_dev->acquiring_list, lock_item) {\n\t\tmutex_lock(&img_req->state_mutex);\n\t\trbd_assert(img_req->state == RBD_IMG_EXCLUSIVE_LOCK);\n\t\trbd_img_schedule(img_req, result);\n\t\tmutex_unlock(&img_req->state_mutex);\n\t}\n\n\tlist_splice_tail_init(&rbd_dev->acquiring_list, &rbd_dev->running_list);\n}\n\nstatic int get_lock_owner_info(struct rbd_device *rbd_dev,\n\t\t\t       struct ceph_locker **lockers, u32 *num_lockers)\n{\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tu8 lock_type;\n\tchar *lock_tag;\n\tint ret;\n\n\tdout(\"%s rbd_dev %p\\n\", __func__, rbd_dev);\n\n\tret = ceph_cls_lock_info(osdc, &rbd_dev->header_oid,\n\t\t\t\t &rbd_dev->header_oloc, RBD_LOCK_NAME,\n\t\t\t\t &lock_type, &lock_tag, lockers, num_lockers);\n\tif (ret)\n\t\treturn ret;\n\n\tif (*num_lockers == 0) {\n\t\tdout(\"%s rbd_dev %p no lockers detected\\n\", __func__, rbd_dev);\n\t\tgoto out;\n\t}\n\n\tif (strcmp(lock_tag, RBD_LOCK_TAG)) {\n\t\trbd_warn(rbd_dev, \"locked by external mechanism, tag %s\",\n\t\t\t lock_tag);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (lock_type == CEPH_CLS_LOCK_SHARED) {\n\t\trbd_warn(rbd_dev, \"shared lock type detected\");\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (strncmp((*lockers)[0].id.cookie, RBD_LOCK_COOKIE_PREFIX,\n\t\t    strlen(RBD_LOCK_COOKIE_PREFIX))) {\n\t\trbd_warn(rbd_dev, \"locked by external mechanism, cookie %s\",\n\t\t\t (*lockers)[0].id.cookie);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(lock_tag);\n\treturn ret;\n}\n\nstatic int find_watcher(struct rbd_device *rbd_dev,\n\t\t\tconst struct ceph_locker *locker)\n{\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tstruct ceph_watch_item *watchers;\n\tu32 num_watchers;\n\tu64 cookie;\n\tint i;\n\tint ret;\n\n\tret = ceph_osdc_list_watchers(osdc, &rbd_dev->header_oid,\n\t\t\t\t      &rbd_dev->header_oloc, &watchers,\n\t\t\t\t      &num_watchers);\n\tif (ret)\n\t\treturn ret;\n\n\tsscanf(locker->id.cookie, RBD_LOCK_COOKIE_PREFIX \" %llu\", &cookie);\n\tfor (i = 0; i < num_watchers; i++) {\n\t\tif (!memcmp(&watchers[i].addr, &locker->info.addr,\n\t\t\t    sizeof(locker->info.addr)) &&\n\t\t    watchers[i].cookie == cookie) {\n\t\t\tstruct rbd_client_id cid = {\n\t\t\t\t.gid = le64_to_cpu(watchers[i].name.num),\n\t\t\t\t.handle = cookie,\n\t\t\t};\n\n\t\t\tdout(\"%s rbd_dev %p found cid %llu-%llu\\n\", __func__,\n\t\t\t     rbd_dev, cid.gid, cid.handle);\n\t\t\trbd_set_owner_cid(rbd_dev, &cid);\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdout(\"%s rbd_dev %p no watchers\\n\", __func__, rbd_dev);\n\tret = 0;\nout:\n\tkfree(watchers);\n\treturn ret;\n}\n\n/*\n * lock_rwsem must be held for write\n */\nstatic int rbd_try_lock(struct rbd_device *rbd_dev)\n{\n\tstruct ceph_client *client = rbd_dev->rbd_client->client;\n\tstruct ceph_locker *lockers;\n\tu32 num_lockers;\n\tint ret;\n\n\tfor (;;) {\n\t\tret = rbd_lock(rbd_dev);\n\t\tif (ret != -EBUSY)\n\t\t\treturn ret;\n\n\t\t/* determine if the current lock holder is still alive */\n\t\tret = get_lock_owner_info(rbd_dev, &lockers, &num_lockers);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (num_lockers == 0)\n\t\t\tgoto again;\n\n\t\tret = find_watcher(rbd_dev, lockers);\n\t\tif (ret)\n\t\t\tgoto out; /* request lock or error */\n\n\t\trbd_warn(rbd_dev, \"breaking header lock owned by %s%llu\",\n\t\t\t ENTITY_NAME(lockers[0].id.name));\n\n\t\tret = ceph_monc_blocklist_add(&client->monc,\n\t\t\t\t\t      &lockers[0].info.addr);\n\t\tif (ret) {\n\t\t\trbd_warn(rbd_dev, \"blocklist of %s%llu failed: %d\",\n\t\t\t\t ENTITY_NAME(lockers[0].id.name), ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ceph_cls_break_lock(&client->osdc, &rbd_dev->header_oid,\n\t\t\t\t\t  &rbd_dev->header_oloc, RBD_LOCK_NAME,\n\t\t\t\t\t  lockers[0].id.cookie,\n\t\t\t\t\t  &lockers[0].id.name);\n\t\tif (ret && ret != -ENOENT)\n\t\t\tgoto out;\n\nagain:\n\t\tceph_free_lockers(lockers, num_lockers);\n\t}\n\nout:\n\tceph_free_lockers(lockers, num_lockers);\n\treturn ret;\n}\n\nstatic int rbd_post_acquire_action(struct rbd_device *rbd_dev)\n{\n\tint ret;\n\n\tif (rbd_dev->header.features & RBD_FEATURE_OBJECT_MAP) {\n\t\tret = rbd_object_map_open(rbd_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Return:\n *   0 - lock acquired\n *   1 - caller should call rbd_request_lock()\n *  <0 - error\n */\nstatic int rbd_try_acquire_lock(struct rbd_device *rbd_dev)\n{\n\tint ret;\n\n\tdown_read(&rbd_dev->lock_rwsem);\n\tdout(\"%s rbd_dev %p read lock_state %d\\n\", __func__, rbd_dev,\n\t     rbd_dev->lock_state);\n\tif (__rbd_is_lock_owner(rbd_dev)) {\n\t\tup_read(&rbd_dev->lock_rwsem);\n\t\treturn 0;\n\t}\n\n\tup_read(&rbd_dev->lock_rwsem);\n\tdown_write(&rbd_dev->lock_rwsem);\n\tdout(\"%s rbd_dev %p write lock_state %d\\n\", __func__, rbd_dev,\n\t     rbd_dev->lock_state);\n\tif (__rbd_is_lock_owner(rbd_dev)) {\n\t\tup_write(&rbd_dev->lock_rwsem);\n\t\treturn 0;\n\t}\n\n\tret = rbd_try_lock(rbd_dev);\n\tif (ret < 0) {\n\t\trbd_warn(rbd_dev, \"failed to lock header: %d\", ret);\n\t\tif (ret == -EBLOCKLISTED)\n\t\t\tgoto out;\n\n\t\tret = 1; /* request lock anyway */\n\t}\n\tif (ret > 0) {\n\t\tup_write(&rbd_dev->lock_rwsem);\n\t\treturn ret;\n\t}\n\n\trbd_assert(rbd_dev->lock_state == RBD_LOCK_STATE_LOCKED);\n\trbd_assert(list_empty(&rbd_dev->running_list));\n\n\tret = rbd_post_acquire_action(rbd_dev);\n\tif (ret) {\n\t\trbd_warn(rbd_dev, \"post-acquire action failed: %d\", ret);\n\t\t/*\n\t\t * Can't stay in RBD_LOCK_STATE_LOCKED because\n\t\t * rbd_lock_add_request() would let the request through,\n\t\t * assuming that e.g. object map is locked and loaded.\n\t\t */\n\t\trbd_unlock(rbd_dev);\n\t}\n\nout:\n\twake_lock_waiters(rbd_dev, ret);\n\tup_write(&rbd_dev->lock_rwsem);\n\treturn ret;\n}\n\nstatic void rbd_acquire_lock(struct work_struct *work)\n{\n\tstruct rbd_device *rbd_dev = container_of(to_delayed_work(work),\n\t\t\t\t\t    struct rbd_device, lock_dwork);\n\tint ret;\n\n\tdout(\"%s rbd_dev %p\\n\", __func__, rbd_dev);\nagain:\n\tret = rbd_try_acquire_lock(rbd_dev);\n\tif (ret <= 0) {\n\t\tdout(\"%s rbd_dev %p ret %d - done\\n\", __func__, rbd_dev, ret);\n\t\treturn;\n\t}\n\n\tret = rbd_request_lock(rbd_dev);\n\tif (ret == -ETIMEDOUT) {\n\t\tgoto again; /* treat this as a dead client */\n\t} else if (ret == -EROFS) {\n\t\trbd_warn(rbd_dev, \"peer will not release lock\");\n\t\tdown_write(&rbd_dev->lock_rwsem);\n\t\twake_lock_waiters(rbd_dev, ret);\n\t\tup_write(&rbd_dev->lock_rwsem);\n\t} else if (ret < 0) {\n\t\trbd_warn(rbd_dev, \"error requesting lock: %d\", ret);\n\t\tmod_delayed_work(rbd_dev->task_wq, &rbd_dev->lock_dwork,\n\t\t\t\t RBD_RETRY_DELAY);\n\t} else {\n\t\t/*\n\t\t * lock owner acked, but resend if we don't see them\n\t\t * release the lock\n\t\t */\n\t\tdout(\"%s rbd_dev %p requeuing lock_dwork\\n\", __func__,\n\t\t     rbd_dev);\n\t\tmod_delayed_work(rbd_dev->task_wq, &rbd_dev->lock_dwork,\n\t\t    msecs_to_jiffies(2 * RBD_NOTIFY_TIMEOUT * MSEC_PER_SEC));\n\t}\n}\n\nstatic bool rbd_quiesce_lock(struct rbd_device *rbd_dev)\n{\n\tbool need_wait;\n\n\tdout(\"%s rbd_dev %p\\n\", __func__, rbd_dev);\n\tlockdep_assert_held_write(&rbd_dev->lock_rwsem);\n\n\tif (rbd_dev->lock_state != RBD_LOCK_STATE_LOCKED)\n\t\treturn false;\n\n\t/*\n\t * Ensure that all in-flight IO is flushed.\n\t */\n\trbd_dev->lock_state = RBD_LOCK_STATE_RELEASING;\n\trbd_assert(!completion_done(&rbd_dev->releasing_wait));\n\tneed_wait = !list_empty(&rbd_dev->running_list);\n\tdowngrade_write(&rbd_dev->lock_rwsem);\n\tif (need_wait)\n\t\twait_for_completion(&rbd_dev->releasing_wait);\n\tup_read(&rbd_dev->lock_rwsem);\n\n\tdown_write(&rbd_dev->lock_rwsem);\n\tif (rbd_dev->lock_state != RBD_LOCK_STATE_RELEASING)\n\t\treturn false;\n\n\trbd_assert(list_empty(&rbd_dev->running_list));\n\treturn true;\n}\n\nstatic void rbd_pre_release_action(struct rbd_device *rbd_dev)\n{\n\tif (rbd_dev->header.features & RBD_FEATURE_OBJECT_MAP)\n\t\trbd_object_map_close(rbd_dev);\n}\n\nstatic void __rbd_release_lock(struct rbd_device *rbd_dev)\n{\n\trbd_assert(list_empty(&rbd_dev->running_list));\n\n\trbd_pre_release_action(rbd_dev);\n\trbd_unlock(rbd_dev);\n}\n\n/*\n * lock_rwsem must be held for write\n */\nstatic void rbd_release_lock(struct rbd_device *rbd_dev)\n{\n\tif (!rbd_quiesce_lock(rbd_dev))\n\t\treturn;\n\n\t__rbd_release_lock(rbd_dev);\n\n\t/*\n\t * Give others a chance to grab the lock - we would re-acquire\n\t * almost immediately if we got new IO while draining the running\n\t * list otherwise.  We need to ack our own notifications, so this\n\t * lock_dwork will be requeued from rbd_handle_released_lock() by\n\t * way of maybe_kick_acquire().\n\t */\n\tcancel_delayed_work(&rbd_dev->lock_dwork);\n}\n\nstatic void rbd_release_lock_work(struct work_struct *work)\n{\n\tstruct rbd_device *rbd_dev = container_of(work, struct rbd_device,\n\t\t\t\t\t\t  unlock_work);\n\n\tdown_write(&rbd_dev->lock_rwsem);\n\trbd_release_lock(rbd_dev);\n\tup_write(&rbd_dev->lock_rwsem);\n}\n\nstatic void maybe_kick_acquire(struct rbd_device *rbd_dev)\n{\n\tbool have_requests;\n\n\tdout(\"%s rbd_dev %p\\n\", __func__, rbd_dev);\n\tif (__rbd_is_lock_owner(rbd_dev))\n\t\treturn;\n\n\tspin_lock(&rbd_dev->lock_lists_lock);\n\thave_requests = !list_empty(&rbd_dev->acquiring_list);\n\tspin_unlock(&rbd_dev->lock_lists_lock);\n\tif (have_requests || delayed_work_pending(&rbd_dev->lock_dwork)) {\n\t\tdout(\"%s rbd_dev %p kicking lock_dwork\\n\", __func__, rbd_dev);\n\t\tmod_delayed_work(rbd_dev->task_wq, &rbd_dev->lock_dwork, 0);\n\t}\n}\n\nstatic void rbd_handle_acquired_lock(struct rbd_device *rbd_dev, u8 struct_v,\n\t\t\t\t     void **p)\n{\n\tstruct rbd_client_id cid = { 0 };\n\n\tif (struct_v >= 2) {\n\t\tcid.gid = ceph_decode_64(p);\n\t\tcid.handle = ceph_decode_64(p);\n\t}\n\n\tdout(\"%s rbd_dev %p cid %llu-%llu\\n\", __func__, rbd_dev, cid.gid,\n\t     cid.handle);\n\tif (!rbd_cid_equal(&cid, &rbd_empty_cid)) {\n\t\tdown_write(&rbd_dev->lock_rwsem);\n\t\tif (rbd_cid_equal(&cid, &rbd_dev->owner_cid)) {\n\t\t\t/*\n\t\t\t * we already know that the remote client is\n\t\t\t * the owner\n\t\t\t */\n\t\t\tup_write(&rbd_dev->lock_rwsem);\n\t\t\treturn;\n\t\t}\n\n\t\trbd_set_owner_cid(rbd_dev, &cid);\n\t\tdowngrade_write(&rbd_dev->lock_rwsem);\n\t} else {\n\t\tdown_read(&rbd_dev->lock_rwsem);\n\t}\n\n\tmaybe_kick_acquire(rbd_dev);\n\tup_read(&rbd_dev->lock_rwsem);\n}\n\nstatic void rbd_handle_released_lock(struct rbd_device *rbd_dev, u8 struct_v,\n\t\t\t\t     void **p)\n{\n\tstruct rbd_client_id cid = { 0 };\n\n\tif (struct_v >= 2) {\n\t\tcid.gid = ceph_decode_64(p);\n\t\tcid.handle = ceph_decode_64(p);\n\t}\n\n\tdout(\"%s rbd_dev %p cid %llu-%llu\\n\", __func__, rbd_dev, cid.gid,\n\t     cid.handle);\n\tif (!rbd_cid_equal(&cid, &rbd_empty_cid)) {\n\t\tdown_write(&rbd_dev->lock_rwsem);\n\t\tif (!rbd_cid_equal(&cid, &rbd_dev->owner_cid)) {\n\t\t\tdout(\"%s rbd_dev %p unexpected owner, cid %llu-%llu != owner_cid %llu-%llu\\n\",\n\t\t\t     __func__, rbd_dev, cid.gid, cid.handle,\n\t\t\t     rbd_dev->owner_cid.gid, rbd_dev->owner_cid.handle);\n\t\t\tup_write(&rbd_dev->lock_rwsem);\n\t\t\treturn;\n\t\t}\n\n\t\trbd_set_owner_cid(rbd_dev, &rbd_empty_cid);\n\t\tdowngrade_write(&rbd_dev->lock_rwsem);\n\t} else {\n\t\tdown_read(&rbd_dev->lock_rwsem);\n\t}\n\n\tmaybe_kick_acquire(rbd_dev);\n\tup_read(&rbd_dev->lock_rwsem);\n}\n\n/*\n * Returns result for ResponseMessage to be encoded (<= 0), or 1 if no\n * ResponseMessage is needed.\n */\nstatic int rbd_handle_request_lock(struct rbd_device *rbd_dev, u8 struct_v,\n\t\t\t\t   void **p)\n{\n\tstruct rbd_client_id my_cid = rbd_get_cid(rbd_dev);\n\tstruct rbd_client_id cid = { 0 };\n\tint result = 1;\n\n\tif (struct_v >= 2) {\n\t\tcid.gid = ceph_decode_64(p);\n\t\tcid.handle = ceph_decode_64(p);\n\t}\n\n\tdout(\"%s rbd_dev %p cid %llu-%llu\\n\", __func__, rbd_dev, cid.gid,\n\t     cid.handle);\n\tif (rbd_cid_equal(&cid, &my_cid))\n\t\treturn result;\n\n\tdown_read(&rbd_dev->lock_rwsem);\n\tif (__rbd_is_lock_owner(rbd_dev)) {\n\t\tif (rbd_dev->lock_state == RBD_LOCK_STATE_LOCKED &&\n\t\t    rbd_cid_equal(&rbd_dev->owner_cid, &rbd_empty_cid))\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * encode ResponseMessage(0) so the peer can detect\n\t\t * a missing owner\n\t\t */\n\t\tresult = 0;\n\n\t\tif (rbd_dev->lock_state == RBD_LOCK_STATE_LOCKED) {\n\t\t\tif (!rbd_dev->opts->exclusive) {\n\t\t\t\tdout(\"%s rbd_dev %p queueing unlock_work\\n\",\n\t\t\t\t     __func__, rbd_dev);\n\t\t\t\tqueue_work(rbd_dev->task_wq,\n\t\t\t\t\t   &rbd_dev->unlock_work);\n\t\t\t} else {\n\t\t\t\t/* refuse to release the lock */\n\t\t\t\tresult = -EROFS;\n\t\t\t}\n\t\t}\n\t}\n\nout_unlock:\n\tup_read(&rbd_dev->lock_rwsem);\n\treturn result;\n}\n\nstatic void __rbd_acknowledge_notify(struct rbd_device *rbd_dev,\n\t\t\t\t     u64 notify_id, u64 cookie, s32 *result)\n{\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tchar buf[4 + CEPH_ENCODING_START_BLK_LEN];\n\tint buf_size = sizeof(buf);\n\tint ret;\n\n\tif (result) {\n\t\tvoid *p = buf;\n\n\t\t/* encode ResponseMessage */\n\t\tceph_start_encoding(&p, 1, 1,\n\t\t\t\t    buf_size - CEPH_ENCODING_START_BLK_LEN);\n\t\tceph_encode_32(&p, *result);\n\t} else {\n\t\tbuf_size = 0;\n\t}\n\n\tret = ceph_osdc_notify_ack(osdc, &rbd_dev->header_oid,\n\t\t\t\t   &rbd_dev->header_oloc, notify_id, cookie,\n\t\t\t\t   buf, buf_size);\n\tif (ret)\n\t\trbd_warn(rbd_dev, \"acknowledge_notify failed: %d\", ret);\n}\n\nstatic void rbd_acknowledge_notify(struct rbd_device *rbd_dev, u64 notify_id,\n\t\t\t\t   u64 cookie)\n{\n\tdout(\"%s rbd_dev %p\\n\", __func__, rbd_dev);\n\t__rbd_acknowledge_notify(rbd_dev, notify_id, cookie, NULL);\n}\n\nstatic void rbd_acknowledge_notify_result(struct rbd_device *rbd_dev,\n\t\t\t\t\t  u64 notify_id, u64 cookie, s32 result)\n{\n\tdout(\"%s rbd_dev %p result %d\\n\", __func__, rbd_dev, result);\n\t__rbd_acknowledge_notify(rbd_dev, notify_id, cookie, &result);\n}\n\nstatic void rbd_watch_cb(void *arg, u64 notify_id, u64 cookie,\n\t\t\t u64 notifier_id, void *data, size_t data_len)\n{\n\tstruct rbd_device *rbd_dev = arg;\n\tvoid *p = data;\n\tvoid *const end = p + data_len;\n\tu8 struct_v = 0;\n\tu32 len;\n\tu32 notify_op;\n\tint ret;\n\n\tdout(\"%s rbd_dev %p cookie %llu notify_id %llu data_len %zu\\n\",\n\t     __func__, rbd_dev, cookie, notify_id, data_len);\n\tif (data_len) {\n\t\tret = ceph_start_decoding(&p, end, 1, \"NotifyMessage\",\n\t\t\t\t\t  &struct_v, &len);\n\t\tif (ret) {\n\t\t\trbd_warn(rbd_dev, \"failed to decode NotifyMessage: %d\",\n\t\t\t\t ret);\n\t\t\treturn;\n\t\t}\n\n\t\tnotify_op = ceph_decode_32(&p);\n\t} else {\n\t\t/* legacy notification for header updates */\n\t\tnotify_op = RBD_NOTIFY_OP_HEADER_UPDATE;\n\t\tlen = 0;\n\t}\n\n\tdout(\"%s rbd_dev %p notify_op %u\\n\", __func__, rbd_dev, notify_op);\n\tswitch (notify_op) {\n\tcase RBD_NOTIFY_OP_ACQUIRED_LOCK:\n\t\trbd_handle_acquired_lock(rbd_dev, struct_v, &p);\n\t\trbd_acknowledge_notify(rbd_dev, notify_id, cookie);\n\t\tbreak;\n\tcase RBD_NOTIFY_OP_RELEASED_LOCK:\n\t\trbd_handle_released_lock(rbd_dev, struct_v, &p);\n\t\trbd_acknowledge_notify(rbd_dev, notify_id, cookie);\n\t\tbreak;\n\tcase RBD_NOTIFY_OP_REQUEST_LOCK:\n\t\tret = rbd_handle_request_lock(rbd_dev, struct_v, &p);\n\t\tif (ret <= 0)\n\t\t\trbd_acknowledge_notify_result(rbd_dev, notify_id,\n\t\t\t\t\t\t      cookie, ret);\n\t\telse\n\t\t\trbd_acknowledge_notify(rbd_dev, notify_id, cookie);\n\t\tbreak;\n\tcase RBD_NOTIFY_OP_HEADER_UPDATE:\n\t\tret = rbd_dev_refresh(rbd_dev);\n\t\tif (ret)\n\t\t\trbd_warn(rbd_dev, \"refresh failed: %d\", ret);\n\n\t\trbd_acknowledge_notify(rbd_dev, notify_id, cookie);\n\t\tbreak;\n\tdefault:\n\t\tif (rbd_is_lock_owner(rbd_dev))\n\t\t\trbd_acknowledge_notify_result(rbd_dev, notify_id,\n\t\t\t\t\t\t      cookie, -EOPNOTSUPP);\n\t\telse\n\t\t\trbd_acknowledge_notify(rbd_dev, notify_id, cookie);\n\t\tbreak;\n\t}\n}\n\nstatic void __rbd_unregister_watch(struct rbd_device *rbd_dev);\n\nstatic void rbd_watch_errcb(void *arg, u64 cookie, int err)\n{\n\tstruct rbd_device *rbd_dev = arg;\n\n\trbd_warn(rbd_dev, \"encountered watch error: %d\", err);\n\n\tdown_write(&rbd_dev->lock_rwsem);\n\trbd_set_owner_cid(rbd_dev, &rbd_empty_cid);\n\tup_write(&rbd_dev->lock_rwsem);\n\n\tmutex_lock(&rbd_dev->watch_mutex);\n\tif (rbd_dev->watch_state == RBD_WATCH_STATE_REGISTERED) {\n\t\t__rbd_unregister_watch(rbd_dev);\n\t\trbd_dev->watch_state = RBD_WATCH_STATE_ERROR;\n\n\t\tqueue_delayed_work(rbd_dev->task_wq, &rbd_dev->watch_dwork, 0);\n\t}\n\tmutex_unlock(&rbd_dev->watch_mutex);\n}\n\n/*\n * watch_mutex must be locked\n */\nstatic int __rbd_register_watch(struct rbd_device *rbd_dev)\n{\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tstruct ceph_osd_linger_request *handle;\n\n\trbd_assert(!rbd_dev->watch_handle);\n\tdout(\"%s rbd_dev %p\\n\", __func__, rbd_dev);\n\n\thandle = ceph_osdc_watch(osdc, &rbd_dev->header_oid,\n\t\t\t\t &rbd_dev->header_oloc, rbd_watch_cb,\n\t\t\t\t rbd_watch_errcb, rbd_dev);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\trbd_dev->watch_handle = handle;\n\treturn 0;\n}\n\n/*\n * watch_mutex must be locked\n */\nstatic void __rbd_unregister_watch(struct rbd_device *rbd_dev)\n{\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tint ret;\n\n\trbd_assert(rbd_dev->watch_handle);\n\tdout(\"%s rbd_dev %p\\n\", __func__, rbd_dev);\n\n\tret = ceph_osdc_unwatch(osdc, rbd_dev->watch_handle);\n\tif (ret)\n\t\trbd_warn(rbd_dev, \"failed to unwatch: %d\", ret);\n\n\trbd_dev->watch_handle = NULL;\n}\n\nstatic int rbd_register_watch(struct rbd_device *rbd_dev)\n{\n\tint ret;\n\n\tmutex_lock(&rbd_dev->watch_mutex);\n\trbd_assert(rbd_dev->watch_state == RBD_WATCH_STATE_UNREGISTERED);\n\tret = __rbd_register_watch(rbd_dev);\n\tif (ret)\n\t\tgoto out;\n\n\trbd_dev->watch_state = RBD_WATCH_STATE_REGISTERED;\n\trbd_dev->watch_cookie = rbd_dev->watch_handle->linger_id;\n\nout:\n\tmutex_unlock(&rbd_dev->watch_mutex);\n\treturn ret;\n}\n\nstatic void cancel_tasks_sync(struct rbd_device *rbd_dev)\n{\n\tdout(\"%s rbd_dev %p\\n\", __func__, rbd_dev);\n\n\tcancel_work_sync(&rbd_dev->acquired_lock_work);\n\tcancel_work_sync(&rbd_dev->released_lock_work);\n\tcancel_delayed_work_sync(&rbd_dev->lock_dwork);\n\tcancel_work_sync(&rbd_dev->unlock_work);\n}\n\n/*\n * header_rwsem must not be held to avoid a deadlock with\n * rbd_dev_refresh() when flushing notifies.\n */\nstatic void rbd_unregister_watch(struct rbd_device *rbd_dev)\n{\n\tcancel_tasks_sync(rbd_dev);\n\n\tmutex_lock(&rbd_dev->watch_mutex);\n\tif (rbd_dev->watch_state == RBD_WATCH_STATE_REGISTERED)\n\t\t__rbd_unregister_watch(rbd_dev);\n\trbd_dev->watch_state = RBD_WATCH_STATE_UNREGISTERED;\n\tmutex_unlock(&rbd_dev->watch_mutex);\n\n\tcancel_delayed_work_sync(&rbd_dev->watch_dwork);\n\tceph_osdc_flush_notifies(&rbd_dev->rbd_client->client->osdc);\n}\n\n/*\n * lock_rwsem must be held for write\n */\nstatic void rbd_reacquire_lock(struct rbd_device *rbd_dev)\n{\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tchar cookie[32];\n\tint ret;\n\n\tif (!rbd_quiesce_lock(rbd_dev))\n\t\treturn;\n\n\tformat_lock_cookie(rbd_dev, cookie);\n\tret = ceph_cls_set_cookie(osdc, &rbd_dev->header_oid,\n\t\t\t\t  &rbd_dev->header_oloc, RBD_LOCK_NAME,\n\t\t\t\t  CEPH_CLS_LOCK_EXCLUSIVE, rbd_dev->lock_cookie,\n\t\t\t\t  RBD_LOCK_TAG, cookie);\n\tif (ret) {\n\t\tif (ret != -EOPNOTSUPP)\n\t\t\trbd_warn(rbd_dev, \"failed to update lock cookie: %d\",\n\t\t\t\t ret);\n\n\t\t/*\n\t\t * Lock cookie cannot be updated on older OSDs, so do\n\t\t * a manual release and queue an acquire.\n\t\t */\n\t\t__rbd_release_lock(rbd_dev);\n\t\tqueue_delayed_work(rbd_dev->task_wq, &rbd_dev->lock_dwork, 0);\n\t} else {\n\t\t__rbd_lock(rbd_dev, cookie);\n\t\twake_lock_waiters(rbd_dev, 0);\n\t}\n}\n\nstatic void rbd_reregister_watch(struct work_struct *work)\n{\n\tstruct rbd_device *rbd_dev = container_of(to_delayed_work(work),\n\t\t\t\t\t    struct rbd_device, watch_dwork);\n\tint ret;\n\n\tdout(\"%s rbd_dev %p\\n\", __func__, rbd_dev);\n\n\tmutex_lock(&rbd_dev->watch_mutex);\n\tif (rbd_dev->watch_state != RBD_WATCH_STATE_ERROR) {\n\t\tmutex_unlock(&rbd_dev->watch_mutex);\n\t\treturn;\n\t}\n\n\tret = __rbd_register_watch(rbd_dev);\n\tif (ret) {\n\t\trbd_warn(rbd_dev, \"failed to reregister watch: %d\", ret);\n\t\tif (ret != -EBLOCKLISTED && ret != -ENOENT) {\n\t\t\tqueue_delayed_work(rbd_dev->task_wq,\n\t\t\t\t\t   &rbd_dev->watch_dwork,\n\t\t\t\t\t   RBD_RETRY_DELAY);\n\t\t\tmutex_unlock(&rbd_dev->watch_mutex);\n\t\t\treturn;\n\t\t}\n\n\t\tmutex_unlock(&rbd_dev->watch_mutex);\n\t\tdown_write(&rbd_dev->lock_rwsem);\n\t\twake_lock_waiters(rbd_dev, ret);\n\t\tup_write(&rbd_dev->lock_rwsem);\n\t\treturn;\n\t}\n\n\trbd_dev->watch_state = RBD_WATCH_STATE_REGISTERED;\n\trbd_dev->watch_cookie = rbd_dev->watch_handle->linger_id;\n\tmutex_unlock(&rbd_dev->watch_mutex);\n\n\tdown_write(&rbd_dev->lock_rwsem);\n\tif (rbd_dev->lock_state == RBD_LOCK_STATE_LOCKED)\n\t\trbd_reacquire_lock(rbd_dev);\n\tup_write(&rbd_dev->lock_rwsem);\n\n\tret = rbd_dev_refresh(rbd_dev);\n\tif (ret)\n\t\trbd_warn(rbd_dev, \"reregistration refresh failed: %d\", ret);\n}\n\n/*\n * Synchronous osd object method call.  Returns the number of bytes\n * returned in the outbound buffer, or a negative error code.\n */\nstatic int rbd_obj_method_sync(struct rbd_device *rbd_dev,\n\t\t\t     struct ceph_object_id *oid,\n\t\t\t     struct ceph_object_locator *oloc,\n\t\t\t     const char *method_name,\n\t\t\t     const void *outbound,\n\t\t\t     size_t outbound_size,\n\t\t\t     void *inbound,\n\t\t\t     size_t inbound_size)\n{\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tstruct page *req_page = NULL;\n\tstruct page *reply_page;\n\tint ret;\n\n\t/*\n\t * Method calls are ultimately read operations.  The result\n\t * should placed into the inbound buffer provided.  They\n\t * also supply outbound data--parameters for the object\n\t * method.  Currently if this is present it will be a\n\t * snapshot id.\n\t */\n\tif (outbound) {\n\t\tif (outbound_size > PAGE_SIZE)\n\t\t\treturn -E2BIG;\n\n\t\treq_page = alloc_page(GFP_KERNEL);\n\t\tif (!req_page)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(page_address(req_page), outbound, outbound_size);\n\t}\n\n\treply_page = alloc_page(GFP_KERNEL);\n\tif (!reply_page) {\n\t\tif (req_page)\n\t\t\t__free_page(req_page);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = ceph_osdc_call(osdc, oid, oloc, RBD_DRV_NAME, method_name,\n\t\t\t     CEPH_OSD_FLAG_READ, req_page, outbound_size,\n\t\t\t     &reply_page, &inbound_size);\n\tif (!ret) {\n\t\tmemcpy(inbound, page_address(reply_page), inbound_size);\n\t\tret = inbound_size;\n\t}\n\n\tif (req_page)\n\t\t__free_page(req_page);\n\t__free_page(reply_page);\n\treturn ret;\n}\n\nstatic void rbd_queue_workfn(struct work_struct *work)\n{\n\tstruct rbd_img_request *img_request =\n\t    container_of(work, struct rbd_img_request, work);\n\tstruct rbd_device *rbd_dev = img_request->rbd_dev;\n\tenum obj_operation_type op_type = img_request->op_type;\n\tstruct request *rq = blk_mq_rq_from_pdu(img_request);\n\tu64 offset = (u64)blk_rq_pos(rq) << SECTOR_SHIFT;\n\tu64 length = blk_rq_bytes(rq);\n\tu64 mapping_size;\n\tint result;\n\n\t/* Ignore/skip any zero-length requests */\n\tif (!length) {\n\t\tdout(\"%s: zero-length request\\n\", __func__);\n\t\tresult = 0;\n\t\tgoto err_img_request;\n\t}\n\n\tblk_mq_start_request(rq);\n\n\tdown_read(&rbd_dev->header_rwsem);\n\tmapping_size = rbd_dev->mapping.size;\n\trbd_img_capture_header(img_request);\n\tup_read(&rbd_dev->header_rwsem);\n\n\tif (offset + length > mapping_size) {\n\t\trbd_warn(rbd_dev, \"beyond EOD (%llu~%llu > %llu)\", offset,\n\t\t\t length, mapping_size);\n\t\tresult = -EIO;\n\t\tgoto err_img_request;\n\t}\n\n\tdout(\"%s rbd_dev %p img_req %p %s %llu~%llu\\n\", __func__, rbd_dev,\n\t     img_request, obj_op_name(op_type), offset, length);\n\n\tif (op_type == OBJ_OP_DISCARD || op_type == OBJ_OP_ZEROOUT)\n\t\tresult = rbd_img_fill_nodata(img_request, offset, length);\n\telse\n\t\tresult = rbd_img_fill_from_bio(img_request, offset, length,\n\t\t\t\t\t       rq->bio);\n\tif (result)\n\t\tgoto err_img_request;\n\n\trbd_img_handle_request(img_request, 0);\n\treturn;\n\nerr_img_request:\n\trbd_img_request_destroy(img_request);\n\tif (result)\n\t\trbd_warn(rbd_dev, \"%s %llx at %llx result %d\",\n\t\t\t obj_op_name(op_type), length, offset, result);\n\tblk_mq_end_request(rq, errno_to_blk_status(result));\n}\n\nstatic blk_status_t rbd_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\tconst struct blk_mq_queue_data *bd)\n{\n\tstruct rbd_device *rbd_dev = hctx->queue->queuedata;\n\tstruct rbd_img_request *img_req = blk_mq_rq_to_pdu(bd->rq);\n\tenum obj_operation_type op_type;\n\n\tswitch (req_op(bd->rq)) {\n\tcase REQ_OP_DISCARD:\n\t\top_type = OBJ_OP_DISCARD;\n\t\tbreak;\n\tcase REQ_OP_WRITE_ZEROES:\n\t\top_type = OBJ_OP_ZEROOUT;\n\t\tbreak;\n\tcase REQ_OP_WRITE:\n\t\top_type = OBJ_OP_WRITE;\n\t\tbreak;\n\tcase REQ_OP_READ:\n\t\top_type = OBJ_OP_READ;\n\t\tbreak;\n\tdefault:\n\t\trbd_warn(rbd_dev, \"unknown req_op %d\", req_op(bd->rq));\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\trbd_img_request_init(img_req, rbd_dev, op_type);\n\n\tif (rbd_img_is_write(img_req)) {\n\t\tif (rbd_is_ro(rbd_dev)) {\n\t\t\trbd_warn(rbd_dev, \"%s on read-only mapping\",\n\t\t\t\t obj_op_name(img_req->op_type));\n\t\t\treturn BLK_STS_IOERR;\n\t\t}\n\t\trbd_assert(!rbd_is_snap(rbd_dev));\n\t}\n\n\tINIT_WORK(&img_req->work, rbd_queue_workfn);\n\tqueue_work(rbd_wq, &img_req->work);\n\treturn BLK_STS_OK;\n}\n\nstatic void rbd_free_disk(struct rbd_device *rbd_dev)\n{\n\tblk_cleanup_queue(rbd_dev->disk->queue);\n\tblk_mq_free_tag_set(&rbd_dev->tag_set);\n\tput_disk(rbd_dev->disk);\n\trbd_dev->disk = NULL;\n}\n\nstatic int rbd_obj_read_sync(struct rbd_device *rbd_dev,\n\t\t\t     struct ceph_object_id *oid,\n\t\t\t     struct ceph_object_locator *oloc,\n\t\t\t     void *buf, int buf_len)\n\n{\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tstruct ceph_osd_request *req;\n\tstruct page **pages;\n\tint num_pages = calc_pages_for(0, buf_len);\n\tint ret;\n\n\treq = ceph_osdc_alloc_request(osdc, NULL, 1, false, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tceph_oid_copy(&req->r_base_oid, oid);\n\tceph_oloc_copy(&req->r_base_oloc, oloc);\n\treq->r_flags = CEPH_OSD_FLAG_READ;\n\n\tpages = ceph_alloc_page_vector(num_pages, GFP_KERNEL);\n\tif (IS_ERR(pages)) {\n\t\tret = PTR_ERR(pages);\n\t\tgoto out_req;\n\t}\n\n\tosd_req_op_extent_init(req, 0, CEPH_OSD_OP_READ, 0, buf_len, 0, 0);\n\tosd_req_op_extent_osd_data_pages(req, 0, pages, buf_len, 0, false,\n\t\t\t\t\t true);\n\n\tret = ceph_osdc_alloc_messages(req, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out_req;\n\n\tceph_osdc_start_request(osdc, req, false);\n\tret = ceph_osdc_wait_request(osdc, req);\n\tif (ret >= 0)\n\t\tceph_copy_from_page_vector(pages, buf, 0, ret);\n\nout_req:\n\tceph_osdc_put_request(req);\n\treturn ret;\n}\n\n/*\n * Read the complete header for the given rbd device.  On successful\n * return, the rbd_dev->header field will contain up-to-date\n * information about the image.\n */\nstatic int rbd_dev_v1_header_info(struct rbd_device *rbd_dev)\n{\n\tstruct rbd_image_header_ondisk *ondisk = NULL;\n\tu32 snap_count = 0;\n\tu64 names_size = 0;\n\tu32 want_count;\n\tint ret;\n\n\t/*\n\t * The complete header will include an array of its 64-bit\n\t * snapshot ids, followed by the names of those snapshots as\n\t * a contiguous block of NUL-terminated strings.  Note that\n\t * the number of snapshots could change by the time we read\n\t * it in, in which case we re-read it.\n\t */\n\tdo {\n\t\tsize_t size;\n\n\t\tkfree(ondisk);\n\n\t\tsize = sizeof (*ondisk);\n\t\tsize += snap_count * sizeof (struct rbd_image_snap_ondisk);\n\t\tsize += names_size;\n\t\tondisk = kmalloc(size, GFP_KERNEL);\n\t\tif (!ondisk)\n\t\t\treturn -ENOMEM;\n\n\t\tret = rbd_obj_read_sync(rbd_dev, &rbd_dev->header_oid,\n\t\t\t\t\t&rbd_dev->header_oloc, ondisk, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif ((size_t)ret < size) {\n\t\t\tret = -ENXIO;\n\t\t\trbd_warn(rbd_dev, \"short header read (want %zd got %d)\",\n\t\t\t\tsize, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!rbd_dev_ondisk_valid(ondisk)) {\n\t\t\tret = -ENXIO;\n\t\t\trbd_warn(rbd_dev, \"invalid header\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tnames_size = le64_to_cpu(ondisk->snap_names_len);\n\t\twant_count = snap_count;\n\t\tsnap_count = le32_to_cpu(ondisk->snap_count);\n\t} while (snap_count != want_count);\n\n\tret = rbd_header_from_disk(rbd_dev, ondisk);\nout:\n\tkfree(ondisk);\n\n\treturn ret;\n}\n\nstatic void rbd_dev_update_size(struct rbd_device *rbd_dev)\n{\n\tsector_t size;\n\n\t/*\n\t * If EXISTS is not set, rbd_dev->disk may be NULL, so don't\n\t * try to update its size.  If REMOVING is set, updating size\n\t * is just useless work since the device can't be opened.\n\t */\n\tif (test_bit(RBD_DEV_FLAG_EXISTS, &rbd_dev->flags) &&\n\t    !test_bit(RBD_DEV_FLAG_REMOVING, &rbd_dev->flags)) {\n\t\tsize = (sector_t)rbd_dev->mapping.size / SECTOR_SIZE;\n\t\tdout(\"setting size to %llu sectors\", (unsigned long long)size);\n\t\tset_capacity_and_notify(rbd_dev->disk, size);\n\t}\n}\n\nstatic int rbd_dev_refresh(struct rbd_device *rbd_dev)\n{\n\tu64 mapping_size;\n\tint ret;\n\n\tdown_write(&rbd_dev->header_rwsem);\n\tmapping_size = rbd_dev->mapping.size;\n\n\tret = rbd_dev_header_info(rbd_dev);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * If there is a parent, see if it has disappeared due to the\n\t * mapped image getting flattened.\n\t */\n\tif (rbd_dev->parent) {\n\t\tret = rbd_dev_v2_parent_info(rbd_dev);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\trbd_assert(!rbd_is_snap(rbd_dev));\n\trbd_dev->mapping.size = rbd_dev->header.image_size;\n\nout:\n\tup_write(&rbd_dev->header_rwsem);\n\tif (!ret && mapping_size != rbd_dev->mapping.size)\n\t\trbd_dev_update_size(rbd_dev);\n\n\treturn ret;\n}\n\nstatic const struct blk_mq_ops rbd_mq_ops = {\n\t.queue_rq\t= rbd_queue_rq,\n};\n\nstatic int rbd_init_disk(struct rbd_device *rbd_dev)\n{\n\tstruct gendisk *disk;\n\tstruct request_queue *q;\n\tunsigned int objset_bytes =\n\t    rbd_dev->layout.object_size * rbd_dev->layout.stripe_count;\n\tint err;\n\n\t/* create gendisk info */\n\tdisk = alloc_disk(single_major ?\n\t\t\t  (1 << RBD_SINGLE_MAJOR_PART_SHIFT) :\n\t\t\t  RBD_MINORS_PER_MAJOR);\n\tif (!disk)\n\t\treturn -ENOMEM;\n\n\tsnprintf(disk->disk_name, sizeof(disk->disk_name), RBD_DRV_NAME \"%d\",\n\t\t rbd_dev->dev_id);\n\tdisk->major = rbd_dev->major;\n\tdisk->first_minor = rbd_dev->minor;\n\tif (single_major)\n\t\tdisk->flags |= GENHD_FL_EXT_DEVT;\n\tdisk->fops = &rbd_bd_ops;\n\tdisk->private_data = rbd_dev;\n\n\tmemset(&rbd_dev->tag_set, 0, sizeof(rbd_dev->tag_set));\n\trbd_dev->tag_set.ops = &rbd_mq_ops;\n\trbd_dev->tag_set.queue_depth = rbd_dev->opts->queue_depth;\n\trbd_dev->tag_set.numa_node = NUMA_NO_NODE;\n\trbd_dev->tag_set.flags = BLK_MQ_F_SHOULD_MERGE;\n\trbd_dev->tag_set.nr_hw_queues = num_present_cpus();\n\trbd_dev->tag_set.cmd_size = sizeof(struct rbd_img_request);\n\n\terr = blk_mq_alloc_tag_set(&rbd_dev->tag_set);\n\tif (err)\n\t\tgoto out_disk;\n\n\tq = blk_mq_init_queue(&rbd_dev->tag_set);\n\tif (IS_ERR(q)) {\n\t\terr = PTR_ERR(q);\n\t\tgoto out_tag_set;\n\t}\n\n\tblk_queue_flag_set(QUEUE_FLAG_NONROT, q);\n\t/* QUEUE_FLAG_ADD_RANDOM is off by default for blk-mq */\n\n\tblk_queue_max_hw_sectors(q, objset_bytes >> SECTOR_SHIFT);\n\tq->limits.max_sectors = queue_max_hw_sectors(q);\n\tblk_queue_max_segments(q, USHRT_MAX);\n\tblk_queue_max_segment_size(q, UINT_MAX);\n\tblk_queue_io_min(q, rbd_dev->opts->alloc_size);\n\tblk_queue_io_opt(q, rbd_dev->opts->alloc_size);\n\n\tif (rbd_dev->opts->trim) {\n\t\tblk_queue_flag_set(QUEUE_FLAG_DISCARD, q);\n\t\tq->limits.discard_granularity = rbd_dev->opts->alloc_size;\n\t\tblk_queue_max_discard_sectors(q, objset_bytes >> SECTOR_SHIFT);\n\t\tblk_queue_max_write_zeroes_sectors(q, objset_bytes >> SECTOR_SHIFT);\n\t}\n\n\tif (!ceph_test_opt(rbd_dev->rbd_client->client, NOCRC))\n\t\tblk_queue_flag_set(QUEUE_FLAG_STABLE_WRITES, q);\n\n\t/*\n\t * disk_release() expects a queue ref from add_disk() and will\n\t * put it.  Hold an extra ref until add_disk() is called.\n\t */\n\tWARN_ON(!blk_get_queue(q));\n\tdisk->queue = q;\n\tq->queuedata = rbd_dev;\n\n\trbd_dev->disk = disk;\n\n\treturn 0;\nout_tag_set:\n\tblk_mq_free_tag_set(&rbd_dev->tag_set);\nout_disk:\n\tput_disk(disk);\n\treturn err;\n}\n\n/*\n  sysfs\n*/\n\nstatic struct rbd_device *dev_to_rbd_dev(struct device *dev)\n{\n\treturn container_of(dev, struct rbd_device, dev);\n}\n\nstatic ssize_t rbd_size_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\n\treturn sprintf(buf, \"%llu\\n\",\n\t\t(unsigned long long)rbd_dev->mapping.size);\n}\n\nstatic ssize_t rbd_features_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\n\treturn sprintf(buf, \"0x%016llx\\n\", rbd_dev->header.features);\n}\n\nstatic ssize_t rbd_major_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\n\tif (rbd_dev->major)\n\t\treturn sprintf(buf, \"%d\\n\", rbd_dev->major);\n\n\treturn sprintf(buf, \"(none)\\n\");\n}\n\nstatic ssize_t rbd_minor_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\n\treturn sprintf(buf, \"%d\\n\", rbd_dev->minor);\n}\n\nstatic ssize_t rbd_client_addr_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\tstruct ceph_entity_addr *client_addr =\n\t    ceph_client_addr(rbd_dev->rbd_client->client);\n\n\treturn sprintf(buf, \"%pISpc/%u\\n\", &client_addr->in_addr,\n\t\t       le32_to_cpu(client_addr->nonce));\n}\n\nstatic ssize_t rbd_client_id_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\n\treturn sprintf(buf, \"client%lld\\n\",\n\t\t       ceph_client_gid(rbd_dev->rbd_client->client));\n}\n\nstatic ssize_t rbd_cluster_fsid_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\n\treturn sprintf(buf, \"%pU\\n\", &rbd_dev->rbd_client->client->fsid);\n}\n\nstatic ssize_t rbd_config_info_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn sprintf(buf, \"%s\\n\", rbd_dev->config_info);\n}\n\nstatic ssize_t rbd_pool_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\n\treturn sprintf(buf, \"%s\\n\", rbd_dev->spec->pool_name);\n}\n\nstatic ssize_t rbd_pool_id_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\n\treturn sprintf(buf, \"%llu\\n\",\n\t\t\t(unsigned long long) rbd_dev->spec->pool_id);\n}\n\nstatic ssize_t rbd_pool_ns_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\n\treturn sprintf(buf, \"%s\\n\", rbd_dev->spec->pool_ns ?: \"\");\n}\n\nstatic ssize_t rbd_name_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\n\tif (rbd_dev->spec->image_name)\n\t\treturn sprintf(buf, \"%s\\n\", rbd_dev->spec->image_name);\n\n\treturn sprintf(buf, \"(unknown)\\n\");\n}\n\nstatic ssize_t rbd_image_id_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\n\treturn sprintf(buf, \"%s\\n\", rbd_dev->spec->image_id);\n}\n\n/*\n * Shows the name of the currently-mapped snapshot (or\n * RBD_SNAP_HEAD_NAME for the base image).\n */\nstatic ssize_t rbd_snap_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\n\treturn sprintf(buf, \"%s\\n\", rbd_dev->spec->snap_name);\n}\n\nstatic ssize_t rbd_snap_id_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\n\treturn sprintf(buf, \"%llu\\n\", rbd_dev->spec->snap_id);\n}\n\n/*\n * For a v2 image, shows the chain of parent images, separated by empty\n * lines.  For v1 images or if there is no parent, shows \"(no parent\n * image)\".\n */\nstatic ssize_t rbd_parent_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\tssize_t count = 0;\n\n\tif (!rbd_dev->parent)\n\t\treturn sprintf(buf, \"(no parent image)\\n\");\n\n\tfor ( ; rbd_dev->parent; rbd_dev = rbd_dev->parent) {\n\t\tstruct rbd_spec *spec = rbd_dev->parent_spec;\n\n\t\tcount += sprintf(&buf[count], \"%s\"\n\t\t\t    \"pool_id %llu\\npool_name %s\\n\"\n\t\t\t    \"pool_ns %s\\n\"\n\t\t\t    \"image_id %s\\nimage_name %s\\n\"\n\t\t\t    \"snap_id %llu\\nsnap_name %s\\n\"\n\t\t\t    \"overlap %llu\\n\",\n\t\t\t    !count ? \"\" : \"\\n\", /* first? */\n\t\t\t    spec->pool_id, spec->pool_name,\n\t\t\t    spec->pool_ns ?: \"\",\n\t\t\t    spec->image_id, spec->image_name ?: \"(unknown)\",\n\t\t\t    spec->snap_id, spec->snap_name,\n\t\t\t    rbd_dev->parent_overlap);\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t rbd_image_refresh(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf,\n\t\t\t\t size_t size)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = rbd_dev_refresh(rbd_dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR(size, 0444, rbd_size_show, NULL);\nstatic DEVICE_ATTR(features, 0444, rbd_features_show, NULL);\nstatic DEVICE_ATTR(major, 0444, rbd_major_show, NULL);\nstatic DEVICE_ATTR(minor, 0444, rbd_minor_show, NULL);\nstatic DEVICE_ATTR(client_addr, 0444, rbd_client_addr_show, NULL);\nstatic DEVICE_ATTR(client_id, 0444, rbd_client_id_show, NULL);\nstatic DEVICE_ATTR(cluster_fsid, 0444, rbd_cluster_fsid_show, NULL);\nstatic DEVICE_ATTR(config_info, 0400, rbd_config_info_show, NULL);\nstatic DEVICE_ATTR(pool, 0444, rbd_pool_show, NULL);\nstatic DEVICE_ATTR(pool_id, 0444, rbd_pool_id_show, NULL);\nstatic DEVICE_ATTR(pool_ns, 0444, rbd_pool_ns_show, NULL);\nstatic DEVICE_ATTR(name, 0444, rbd_name_show, NULL);\nstatic DEVICE_ATTR(image_id, 0444, rbd_image_id_show, NULL);\nstatic DEVICE_ATTR(refresh, 0200, NULL, rbd_image_refresh);\nstatic DEVICE_ATTR(current_snap, 0444, rbd_snap_show, NULL);\nstatic DEVICE_ATTR(snap_id, 0444, rbd_snap_id_show, NULL);\nstatic DEVICE_ATTR(parent, 0444, rbd_parent_show, NULL);\n\nstatic struct attribute *rbd_attrs[] = {\n\t&dev_attr_size.attr,\n\t&dev_attr_features.attr,\n\t&dev_attr_major.attr,\n\t&dev_attr_minor.attr,\n\t&dev_attr_client_addr.attr,\n\t&dev_attr_client_id.attr,\n\t&dev_attr_cluster_fsid.attr,\n\t&dev_attr_config_info.attr,\n\t&dev_attr_pool.attr,\n\t&dev_attr_pool_id.attr,\n\t&dev_attr_pool_ns.attr,\n\t&dev_attr_name.attr,\n\t&dev_attr_image_id.attr,\n\t&dev_attr_current_snap.attr,\n\t&dev_attr_snap_id.attr,\n\t&dev_attr_parent.attr,\n\t&dev_attr_refresh.attr,\n\tNULL\n};\n\nstatic struct attribute_group rbd_attr_group = {\n\t.attrs = rbd_attrs,\n};\n\nstatic const struct attribute_group *rbd_attr_groups[] = {\n\t&rbd_attr_group,\n\tNULL\n};\n\nstatic void rbd_dev_release(struct device *dev);\n\nstatic const struct device_type rbd_device_type = {\n\t.name\t\t= \"rbd\",\n\t.groups\t\t= rbd_attr_groups,\n\t.release\t= rbd_dev_release,\n};\n\nstatic struct rbd_spec *rbd_spec_get(struct rbd_spec *spec)\n{\n\tkref_get(&spec->kref);\n\n\treturn spec;\n}\n\nstatic void rbd_spec_free(struct kref *kref);\nstatic void rbd_spec_put(struct rbd_spec *spec)\n{\n\tif (spec)\n\t\tkref_put(&spec->kref, rbd_spec_free);\n}\n\nstatic struct rbd_spec *rbd_spec_alloc(void)\n{\n\tstruct rbd_spec *spec;\n\n\tspec = kzalloc(sizeof (*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn NULL;\n\n\tspec->pool_id = CEPH_NOPOOL;\n\tspec->snap_id = CEPH_NOSNAP;\n\tkref_init(&spec->kref);\n\n\treturn spec;\n}\n\nstatic void rbd_spec_free(struct kref *kref)\n{\n\tstruct rbd_spec *spec = container_of(kref, struct rbd_spec, kref);\n\n\tkfree(spec->pool_name);\n\tkfree(spec->pool_ns);\n\tkfree(spec->image_id);\n\tkfree(spec->image_name);\n\tkfree(spec->snap_name);\n\tkfree(spec);\n}\n\nstatic void rbd_dev_free(struct rbd_device *rbd_dev)\n{\n\tWARN_ON(rbd_dev->watch_state != RBD_WATCH_STATE_UNREGISTERED);\n\tWARN_ON(rbd_dev->lock_state != RBD_LOCK_STATE_UNLOCKED);\n\n\tceph_oid_destroy(&rbd_dev->header_oid);\n\tceph_oloc_destroy(&rbd_dev->header_oloc);\n\tkfree(rbd_dev->config_info);\n\n\trbd_put_client(rbd_dev->rbd_client);\n\trbd_spec_put(rbd_dev->spec);\n\tkfree(rbd_dev->opts);\n\tkfree(rbd_dev);\n}\n\nstatic void rbd_dev_release(struct device *dev)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\tbool need_put = !!rbd_dev->opts;\n\n\tif (need_put) {\n\t\tdestroy_workqueue(rbd_dev->task_wq);\n\t\tida_simple_remove(&rbd_dev_id_ida, rbd_dev->dev_id);\n\t}\n\n\trbd_dev_free(rbd_dev);\n\n\t/*\n\t * This is racy, but way better than putting module outside of\n\t * the release callback.  The race window is pretty small, so\n\t * doing something similar to dm (dm-builtin.c) is overkill.\n\t */\n\tif (need_put)\n\t\tmodule_put(THIS_MODULE);\n}\n\nstatic struct rbd_device *__rbd_dev_create(struct rbd_client *rbdc,\n\t\t\t\t\t   struct rbd_spec *spec)\n{\n\tstruct rbd_device *rbd_dev;\n\n\trbd_dev = kzalloc(sizeof(*rbd_dev), GFP_KERNEL);\n\tif (!rbd_dev)\n\t\treturn NULL;\n\n\tspin_lock_init(&rbd_dev->lock);\n\tINIT_LIST_HEAD(&rbd_dev->node);\n\tinit_rwsem(&rbd_dev->header_rwsem);\n\n\trbd_dev->header.data_pool_id = CEPH_NOPOOL;\n\tceph_oid_init(&rbd_dev->header_oid);\n\trbd_dev->header_oloc.pool = spec->pool_id;\n\tif (spec->pool_ns) {\n\t\tWARN_ON(!*spec->pool_ns);\n\t\trbd_dev->header_oloc.pool_ns =\n\t\t    ceph_find_or_create_string(spec->pool_ns,\n\t\t\t\t\t       strlen(spec->pool_ns));\n\t}\n\n\tmutex_init(&rbd_dev->watch_mutex);\n\trbd_dev->watch_state = RBD_WATCH_STATE_UNREGISTERED;\n\tINIT_DELAYED_WORK(&rbd_dev->watch_dwork, rbd_reregister_watch);\n\n\tinit_rwsem(&rbd_dev->lock_rwsem);\n\trbd_dev->lock_state = RBD_LOCK_STATE_UNLOCKED;\n\tINIT_WORK(&rbd_dev->acquired_lock_work, rbd_notify_acquired_lock);\n\tINIT_WORK(&rbd_dev->released_lock_work, rbd_notify_released_lock);\n\tINIT_DELAYED_WORK(&rbd_dev->lock_dwork, rbd_acquire_lock);\n\tINIT_WORK(&rbd_dev->unlock_work, rbd_release_lock_work);\n\tspin_lock_init(&rbd_dev->lock_lists_lock);\n\tINIT_LIST_HEAD(&rbd_dev->acquiring_list);\n\tINIT_LIST_HEAD(&rbd_dev->running_list);\n\tinit_completion(&rbd_dev->acquire_wait);\n\tinit_completion(&rbd_dev->releasing_wait);\n\n\tspin_lock_init(&rbd_dev->object_map_lock);\n\n\trbd_dev->dev.bus = &rbd_bus_type;\n\trbd_dev->dev.type = &rbd_device_type;\n\trbd_dev->dev.parent = &rbd_root_dev;\n\tdevice_initialize(&rbd_dev->dev);\n\n\trbd_dev->rbd_client = rbdc;\n\trbd_dev->spec = spec;\n\n\treturn rbd_dev;\n}\n\n/*\n * Create a mapping rbd_dev.\n */\nstatic struct rbd_device *rbd_dev_create(struct rbd_client *rbdc,\n\t\t\t\t\t struct rbd_spec *spec,\n\t\t\t\t\t struct rbd_options *opts)\n{\n\tstruct rbd_device *rbd_dev;\n\n\trbd_dev = __rbd_dev_create(rbdc, spec);\n\tif (!rbd_dev)\n\t\treturn NULL;\n\n\trbd_dev->opts = opts;\n\n\t/* get an id and fill in device name */\n\trbd_dev->dev_id = ida_simple_get(&rbd_dev_id_ida, 0,\n\t\t\t\t\t minor_to_rbd_dev_id(1 << MINORBITS),\n\t\t\t\t\t GFP_KERNEL);\n\tif (rbd_dev->dev_id < 0)\n\t\tgoto fail_rbd_dev;\n\n\tsprintf(rbd_dev->name, RBD_DRV_NAME \"%d\", rbd_dev->dev_id);\n\trbd_dev->task_wq = alloc_ordered_workqueue(\"%s-tasks\", WQ_MEM_RECLAIM,\n\t\t\t\t\t\t   rbd_dev->name);\n\tif (!rbd_dev->task_wq)\n\t\tgoto fail_dev_id;\n\n\t/* we have a ref from do_rbd_add() */\n\t__module_get(THIS_MODULE);\n\n\tdout(\"%s rbd_dev %p dev_id %d\\n\", __func__, rbd_dev, rbd_dev->dev_id);\n\treturn rbd_dev;\n\nfail_dev_id:\n\tida_simple_remove(&rbd_dev_id_ida, rbd_dev->dev_id);\nfail_rbd_dev:\n\trbd_dev_free(rbd_dev);\n\treturn NULL;\n}\n\nstatic void rbd_dev_destroy(struct rbd_device *rbd_dev)\n{\n\tif (rbd_dev)\n\t\tput_device(&rbd_dev->dev);\n}\n\n/*\n * Get the size and object order for an image snapshot, or if\n * snap_id is CEPH_NOSNAP, gets this information for the base\n * image.\n */\nstatic int _rbd_dev_v2_snap_size(struct rbd_device *rbd_dev, u64 snap_id,\n\t\t\t\tu8 *order, u64 *snap_size)\n{\n\t__le64 snapid = cpu_to_le64(snap_id);\n\tint ret;\n\tstruct {\n\t\tu8 order;\n\t\t__le64 size;\n\t} __attribute__ ((packed)) size_buf = { 0 };\n\n\tret = rbd_obj_method_sync(rbd_dev, &rbd_dev->header_oid,\n\t\t\t\t  &rbd_dev->header_oloc, \"get_size\",\n\t\t\t\t  &snapid, sizeof(snapid),\n\t\t\t\t  &size_buf, sizeof(size_buf));\n\tdout(\"%s: rbd_obj_method_sync returned %d\\n\", __func__, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret < sizeof (size_buf))\n\t\treturn -ERANGE;\n\n\tif (order) {\n\t\t*order = size_buf.order;\n\t\tdout(\"  order %u\", (unsigned int)*order);\n\t}\n\t*snap_size = le64_to_cpu(size_buf.size);\n\n\tdout(\"  snap_id 0x%016llx snap_size = %llu\\n\",\n\t\t(unsigned long long)snap_id,\n\t\t(unsigned long long)*snap_size);\n\n\treturn 0;\n}\n\nstatic int rbd_dev_v2_image_size(struct rbd_device *rbd_dev)\n{\n\treturn _rbd_dev_v2_snap_size(rbd_dev, CEPH_NOSNAP,\n\t\t\t\t\t&rbd_dev->header.obj_order,\n\t\t\t\t\t&rbd_dev->header.image_size);\n}\n\nstatic int rbd_dev_v2_object_prefix(struct rbd_device *rbd_dev)\n{\n\tsize_t size;\n\tvoid *reply_buf;\n\tint ret;\n\tvoid *p;\n\n\t/* Response will be an encoded string, which includes a length */\n\tsize = sizeof(__le32) + RBD_OBJ_PREFIX_LEN_MAX;\n\treply_buf = kzalloc(size, GFP_KERNEL);\n\tif (!reply_buf)\n\t\treturn -ENOMEM;\n\n\tret = rbd_obj_method_sync(rbd_dev, &rbd_dev->header_oid,\n\t\t\t\t  &rbd_dev->header_oloc, \"get_object_prefix\",\n\t\t\t\t  NULL, 0, reply_buf, size);\n\tdout(\"%s: rbd_obj_method_sync returned %d\\n\", __func__, ret);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tp = reply_buf;\n\trbd_dev->header.object_prefix = ceph_extract_encoded_string(&p,\n\t\t\t\t\t\tp + ret, NULL, GFP_NOIO);\n\tret = 0;\n\n\tif (IS_ERR(rbd_dev->header.object_prefix)) {\n\t\tret = PTR_ERR(rbd_dev->header.object_prefix);\n\t\trbd_dev->header.object_prefix = NULL;\n\t} else {\n\t\tdout(\"  object_prefix = %s\\n\", rbd_dev->header.object_prefix);\n\t}\nout:\n\tkfree(reply_buf);\n\n\treturn ret;\n}\n\nstatic int _rbd_dev_v2_snap_features(struct rbd_device *rbd_dev, u64 snap_id,\n\t\t\t\t     bool read_only, u64 *snap_features)\n{\n\tstruct {\n\t\t__le64 snap_id;\n\t\tu8 read_only;\n\t} features_in;\n\tstruct {\n\t\t__le64 features;\n\t\t__le64 incompat;\n\t} __attribute__ ((packed)) features_buf = { 0 };\n\tu64 unsup;\n\tint ret;\n\n\tfeatures_in.snap_id = cpu_to_le64(snap_id);\n\tfeatures_in.read_only = read_only;\n\n\tret = rbd_obj_method_sync(rbd_dev, &rbd_dev->header_oid,\n\t\t\t\t  &rbd_dev->header_oloc, \"get_features\",\n\t\t\t\t  &features_in, sizeof(features_in),\n\t\t\t\t  &features_buf, sizeof(features_buf));\n\tdout(\"%s: rbd_obj_method_sync returned %d\\n\", __func__, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret < sizeof (features_buf))\n\t\treturn -ERANGE;\n\n\tunsup = le64_to_cpu(features_buf.incompat) & ~RBD_FEATURES_SUPPORTED;\n\tif (unsup) {\n\t\trbd_warn(rbd_dev, \"image uses unsupported features: 0x%llx\",\n\t\t\t unsup);\n\t\treturn -ENXIO;\n\t}\n\n\t*snap_features = le64_to_cpu(features_buf.features);\n\n\tdout(\"  snap_id 0x%016llx features = 0x%016llx incompat = 0x%016llx\\n\",\n\t\t(unsigned long long)snap_id,\n\t\t(unsigned long long)*snap_features,\n\t\t(unsigned long long)le64_to_cpu(features_buf.incompat));\n\n\treturn 0;\n}\n\nstatic int rbd_dev_v2_features(struct rbd_device *rbd_dev)\n{\n\treturn _rbd_dev_v2_snap_features(rbd_dev, CEPH_NOSNAP,\n\t\t\t\t\t rbd_is_ro(rbd_dev),\n\t\t\t\t\t &rbd_dev->header.features);\n}\n\n/*\n * These are generic image flags, but since they are used only for\n * object map, store them in rbd_dev->object_map_flags.\n *\n * For the same reason, this function is called only on object map\n * (re)load and not on header refresh.\n */\nstatic int rbd_dev_v2_get_flags(struct rbd_device *rbd_dev)\n{\n\t__le64 snapid = cpu_to_le64(rbd_dev->spec->snap_id);\n\t__le64 flags;\n\tint ret;\n\n\tret = rbd_obj_method_sync(rbd_dev, &rbd_dev->header_oid,\n\t\t\t\t  &rbd_dev->header_oloc, \"get_flags\",\n\t\t\t\t  &snapid, sizeof(snapid),\n\t\t\t\t  &flags, sizeof(flags));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret < sizeof(flags))\n\t\treturn -EBADMSG;\n\n\trbd_dev->object_map_flags = le64_to_cpu(flags);\n\treturn 0;\n}\n\nstruct parent_image_info {\n\tu64\t\tpool_id;\n\tconst char\t*pool_ns;\n\tconst char\t*image_id;\n\tu64\t\tsnap_id;\n\n\tbool\t\thas_overlap;\n\tu64\t\toverlap;\n};\n\n/*\n * The caller is responsible for @pii.\n */\nstatic int decode_parent_image_spec(void **p, void *end,\n\t\t\t\t    struct parent_image_info *pii)\n{\n\tu8 struct_v;\n\tu32 struct_len;\n\tint ret;\n\n\tret = ceph_start_decoding(p, end, 1, \"ParentImageSpec\",\n\t\t\t\t  &struct_v, &struct_len);\n\tif (ret)\n\t\treturn ret;\n\n\tceph_decode_64_safe(p, end, pii->pool_id, e_inval);\n\tpii->pool_ns = ceph_extract_encoded_string(p, end, NULL, GFP_KERNEL);\n\tif (IS_ERR(pii->pool_ns)) {\n\t\tret = PTR_ERR(pii->pool_ns);\n\t\tpii->pool_ns = NULL;\n\t\treturn ret;\n\t}\n\tpii->image_id = ceph_extract_encoded_string(p, end, NULL, GFP_KERNEL);\n\tif (IS_ERR(pii->image_id)) {\n\t\tret = PTR_ERR(pii->image_id);\n\t\tpii->image_id = NULL;\n\t\treturn ret;\n\t}\n\tceph_decode_64_safe(p, end, pii->snap_id, e_inval);\n\treturn 0;\n\ne_inval:\n\treturn -EINVAL;\n}\n\nstatic int __get_parent_info(struct rbd_device *rbd_dev,\n\t\t\t     struct page *req_page,\n\t\t\t     struct page *reply_page,\n\t\t\t     struct parent_image_info *pii)\n{\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tsize_t reply_len = PAGE_SIZE;\n\tvoid *p, *end;\n\tint ret;\n\n\tret = ceph_osdc_call(osdc, &rbd_dev->header_oid, &rbd_dev->header_oloc,\n\t\t\t     \"rbd\", \"parent_get\", CEPH_OSD_FLAG_READ,\n\t\t\t     req_page, sizeof(u64), &reply_page, &reply_len);\n\tif (ret)\n\t\treturn ret == -EOPNOTSUPP ? 1 : ret;\n\n\tp = page_address(reply_page);\n\tend = p + reply_len;\n\tret = decode_parent_image_spec(&p, end, pii);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ceph_osdc_call(osdc, &rbd_dev->header_oid, &rbd_dev->header_oloc,\n\t\t\t     \"rbd\", \"parent_overlap_get\", CEPH_OSD_FLAG_READ,\n\t\t\t     req_page, sizeof(u64), &reply_page, &reply_len);\n\tif (ret)\n\t\treturn ret;\n\n\tp = page_address(reply_page);\n\tend = p + reply_len;\n\tceph_decode_8_safe(&p, end, pii->has_overlap, e_inval);\n\tif (pii->has_overlap)\n\t\tceph_decode_64_safe(&p, end, pii->overlap, e_inval);\n\n\treturn 0;\n\ne_inval:\n\treturn -EINVAL;\n}\n\n/*\n * The caller is responsible for @pii.\n */\nstatic int __get_parent_info_legacy(struct rbd_device *rbd_dev,\n\t\t\t\t    struct page *req_page,\n\t\t\t\t    struct page *reply_page,\n\t\t\t\t    struct parent_image_info *pii)\n{\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tsize_t reply_len = PAGE_SIZE;\n\tvoid *p, *end;\n\tint ret;\n\n\tret = ceph_osdc_call(osdc, &rbd_dev->header_oid, &rbd_dev->header_oloc,\n\t\t\t     \"rbd\", \"get_parent\", CEPH_OSD_FLAG_READ,\n\t\t\t     req_page, sizeof(u64), &reply_page, &reply_len);\n\tif (ret)\n\t\treturn ret;\n\n\tp = page_address(reply_page);\n\tend = p + reply_len;\n\tceph_decode_64_safe(&p, end, pii->pool_id, e_inval);\n\tpii->image_id = ceph_extract_encoded_string(&p, end, NULL, GFP_KERNEL);\n\tif (IS_ERR(pii->image_id)) {\n\t\tret = PTR_ERR(pii->image_id);\n\t\tpii->image_id = NULL;\n\t\treturn ret;\n\t}\n\tceph_decode_64_safe(&p, end, pii->snap_id, e_inval);\n\tpii->has_overlap = true;\n\tceph_decode_64_safe(&p, end, pii->overlap, e_inval);\n\n\treturn 0;\n\ne_inval:\n\treturn -EINVAL;\n}\n\nstatic int get_parent_info(struct rbd_device *rbd_dev,\n\t\t\t   struct parent_image_info *pii)\n{\n\tstruct page *req_page, *reply_page;\n\tvoid *p;\n\tint ret;\n\n\treq_page = alloc_page(GFP_KERNEL);\n\tif (!req_page)\n\t\treturn -ENOMEM;\n\n\treply_page = alloc_page(GFP_KERNEL);\n\tif (!reply_page) {\n\t\t__free_page(req_page);\n\t\treturn -ENOMEM;\n\t}\n\n\tp = page_address(req_page);\n\tceph_encode_64(&p, rbd_dev->spec->snap_id);\n\tret = __get_parent_info(rbd_dev, req_page, reply_page, pii);\n\tif (ret > 0)\n\t\tret = __get_parent_info_legacy(rbd_dev, req_page, reply_page,\n\t\t\t\t\t       pii);\n\n\t__free_page(req_page);\n\t__free_page(reply_page);\n\treturn ret;\n}\n\nstatic int rbd_dev_v2_parent_info(struct rbd_device *rbd_dev)\n{\n\tstruct rbd_spec *parent_spec;\n\tstruct parent_image_info pii = { 0 };\n\tint ret;\n\n\tparent_spec = rbd_spec_alloc();\n\tif (!parent_spec)\n\t\treturn -ENOMEM;\n\n\tret = get_parent_info(rbd_dev, &pii);\n\tif (ret)\n\t\tgoto out_err;\n\n\tdout(\"%s pool_id %llu pool_ns %s image_id %s snap_id %llu has_overlap %d overlap %llu\\n\",\n\t     __func__, pii.pool_id, pii.pool_ns, pii.image_id, pii.snap_id,\n\t     pii.has_overlap, pii.overlap);\n\n\tif (pii.pool_id == CEPH_NOPOOL || !pii.has_overlap) {\n\t\t/*\n\t\t * Either the parent never existed, or we have\n\t\t * record of it but the image got flattened so it no\n\t\t * longer has a parent.  When the parent of a\n\t\t * layered image disappears we immediately set the\n\t\t * overlap to 0.  The effect of this is that all new\n\t\t * requests will be treated as if the image had no\n\t\t * parent.\n\t\t *\n\t\t * If !pii.has_overlap, the parent image spec is not\n\t\t * applicable.  It's there to avoid duplication in each\n\t\t * snapshot record.\n\t\t */\n\t\tif (rbd_dev->parent_overlap) {\n\t\t\trbd_dev->parent_overlap = 0;\n\t\t\trbd_dev_parent_put(rbd_dev);\n\t\t\tpr_info(\"%s: clone image has been flattened\\n\",\n\t\t\t\trbd_dev->disk->disk_name);\n\t\t}\n\n\t\tgoto out;\t/* No parent?  No problem. */\n\t}\n\n\t/* The ceph file layout needs to fit pool id in 32 bits */\n\n\tret = -EIO;\n\tif (pii.pool_id > (u64)U32_MAX) {\n\t\trbd_warn(NULL, \"parent pool id too large (%llu > %u)\",\n\t\t\t(unsigned long long)pii.pool_id, U32_MAX);\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * The parent won't change (except when the clone is\n\t * flattened, already handled that).  So we only need to\n\t * record the parent spec we have not already done so.\n\t */\n\tif (!rbd_dev->parent_spec) {\n\t\tparent_spec->pool_id = pii.pool_id;\n\t\tif (pii.pool_ns && *pii.pool_ns) {\n\t\t\tparent_spec->pool_ns = pii.pool_ns;\n\t\t\tpii.pool_ns = NULL;\n\t\t}\n\t\tparent_spec->image_id = pii.image_id;\n\t\tpii.image_id = NULL;\n\t\tparent_spec->snap_id = pii.snap_id;\n\n\t\trbd_dev->parent_spec = parent_spec;\n\t\tparent_spec = NULL;\t/* rbd_dev now owns this */\n\t}\n\n\t/*\n\t * We always update the parent overlap.  If it's zero we issue\n\t * a warning, as we will proceed as if there was no parent.\n\t */\n\tif (!pii.overlap) {\n\t\tif (parent_spec) {\n\t\t\t/* refresh, careful to warn just once */\n\t\t\tif (rbd_dev->parent_overlap)\n\t\t\t\trbd_warn(rbd_dev,\n\t\t\t\t    \"clone now standalone (overlap became 0)\");\n\t\t} else {\n\t\t\t/* initial probe */\n\t\t\trbd_warn(rbd_dev, \"clone is standalone (overlap 0)\");\n\t\t}\n\t}\n\trbd_dev->parent_overlap = pii.overlap;\n\nout:\n\tret = 0;\nout_err:\n\tkfree(pii.pool_ns);\n\tkfree(pii.image_id);\n\trbd_spec_put(parent_spec);\n\treturn ret;\n}\n\nstatic int rbd_dev_v2_striping_info(struct rbd_device *rbd_dev)\n{\n\tstruct {\n\t\t__le64 stripe_unit;\n\t\t__le64 stripe_count;\n\t} __attribute__ ((packed)) striping_info_buf = { 0 };\n\tsize_t size = sizeof (striping_info_buf);\n\tvoid *p;\n\tint ret;\n\n\tret = rbd_obj_method_sync(rbd_dev, &rbd_dev->header_oid,\n\t\t\t\t&rbd_dev->header_oloc, \"get_stripe_unit_count\",\n\t\t\t\tNULL, 0, &striping_info_buf, size);\n\tdout(\"%s: rbd_obj_method_sync returned %d\\n\", __func__, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret < size)\n\t\treturn -ERANGE;\n\n\tp = &striping_info_buf;\n\trbd_dev->header.stripe_unit = ceph_decode_64(&p);\n\trbd_dev->header.stripe_count = ceph_decode_64(&p);\n\treturn 0;\n}\n\nstatic int rbd_dev_v2_data_pool(struct rbd_device *rbd_dev)\n{\n\t__le64 data_pool_id;\n\tint ret;\n\n\tret = rbd_obj_method_sync(rbd_dev, &rbd_dev->header_oid,\n\t\t\t\t  &rbd_dev->header_oloc, \"get_data_pool\",\n\t\t\t\t  NULL, 0, &data_pool_id, sizeof(data_pool_id));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret < sizeof(data_pool_id))\n\t\treturn -EBADMSG;\n\n\trbd_dev->header.data_pool_id = le64_to_cpu(data_pool_id);\n\tWARN_ON(rbd_dev->header.data_pool_id == CEPH_NOPOOL);\n\treturn 0;\n}\n\nstatic char *rbd_dev_image_name(struct rbd_device *rbd_dev)\n{\n\tCEPH_DEFINE_OID_ONSTACK(oid);\n\tsize_t image_id_size;\n\tchar *image_id;\n\tvoid *p;\n\tvoid *end;\n\tsize_t size;\n\tvoid *reply_buf = NULL;\n\tsize_t len = 0;\n\tchar *image_name = NULL;\n\tint ret;\n\n\trbd_assert(!rbd_dev->spec->image_name);\n\n\tlen = strlen(rbd_dev->spec->image_id);\n\timage_id_size = sizeof (__le32) + len;\n\timage_id = kmalloc(image_id_size, GFP_KERNEL);\n\tif (!image_id)\n\t\treturn NULL;\n\n\tp = image_id;\n\tend = image_id + image_id_size;\n\tceph_encode_string(&p, end, rbd_dev->spec->image_id, (u32)len);\n\n\tsize = sizeof (__le32) + RBD_IMAGE_NAME_LEN_MAX;\n\treply_buf = kmalloc(size, GFP_KERNEL);\n\tif (!reply_buf)\n\t\tgoto out;\n\n\tceph_oid_printf(&oid, \"%s\", RBD_DIRECTORY);\n\tret = rbd_obj_method_sync(rbd_dev, &oid, &rbd_dev->header_oloc,\n\t\t\t\t  \"dir_get_name\", image_id, image_id_size,\n\t\t\t\t  reply_buf, size);\n\tif (ret < 0)\n\t\tgoto out;\n\tp = reply_buf;\n\tend = reply_buf + ret;\n\n\timage_name = ceph_extract_encoded_string(&p, end, &len, GFP_KERNEL);\n\tif (IS_ERR(image_name))\n\t\timage_name = NULL;\n\telse\n\t\tdout(\"%s: name is %s len is %zd\\n\", __func__, image_name, len);\nout:\n\tkfree(reply_buf);\n\tkfree(image_id);\n\n\treturn image_name;\n}\n\nstatic u64 rbd_v1_snap_id_by_name(struct rbd_device *rbd_dev, const char *name)\n{\n\tstruct ceph_snap_context *snapc = rbd_dev->header.snapc;\n\tconst char *snap_name;\n\tu32 which = 0;\n\n\t/* Skip over names until we find the one we are looking for */\n\n\tsnap_name = rbd_dev->header.snap_names;\n\twhile (which < snapc->num_snaps) {\n\t\tif (!strcmp(name, snap_name))\n\t\t\treturn snapc->snaps[which];\n\t\tsnap_name += strlen(snap_name) + 1;\n\t\twhich++;\n\t}\n\treturn CEPH_NOSNAP;\n}\n\nstatic u64 rbd_v2_snap_id_by_name(struct rbd_device *rbd_dev, const char *name)\n{\n\tstruct ceph_snap_context *snapc = rbd_dev->header.snapc;\n\tu32 which;\n\tbool found = false;\n\tu64 snap_id;\n\n\tfor (which = 0; !found && which < snapc->num_snaps; which++) {\n\t\tconst char *snap_name;\n\n\t\tsnap_id = snapc->snaps[which];\n\t\tsnap_name = rbd_dev_v2_snap_name(rbd_dev, snap_id);\n\t\tif (IS_ERR(snap_name)) {\n\t\t\t/* ignore no-longer existing snapshots */\n\t\t\tif (PTR_ERR(snap_name) == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tfound = !strcmp(name, snap_name);\n\t\tkfree(snap_name);\n\t}\n\treturn found ? snap_id : CEPH_NOSNAP;\n}\n\n/*\n * Assumes name is never RBD_SNAP_HEAD_NAME; returns CEPH_NOSNAP if\n * no snapshot by that name is found, or if an error occurs.\n */\nstatic u64 rbd_snap_id_by_name(struct rbd_device *rbd_dev, const char *name)\n{\n\tif (rbd_dev->image_format == 1)\n\t\treturn rbd_v1_snap_id_by_name(rbd_dev, name);\n\n\treturn rbd_v2_snap_id_by_name(rbd_dev, name);\n}\n\n/*\n * An image being mapped will have everything but the snap id.\n */\nstatic int rbd_spec_fill_snap_id(struct rbd_device *rbd_dev)\n{\n\tstruct rbd_spec *spec = rbd_dev->spec;\n\n\trbd_assert(spec->pool_id != CEPH_NOPOOL && spec->pool_name);\n\trbd_assert(spec->image_id && spec->image_name);\n\trbd_assert(spec->snap_name);\n\n\tif (strcmp(spec->snap_name, RBD_SNAP_HEAD_NAME)) {\n\t\tu64 snap_id;\n\n\t\tsnap_id = rbd_snap_id_by_name(rbd_dev, spec->snap_name);\n\t\tif (snap_id == CEPH_NOSNAP)\n\t\t\treturn -ENOENT;\n\n\t\tspec->snap_id = snap_id;\n\t} else {\n\t\tspec->snap_id = CEPH_NOSNAP;\n\t}\n\n\treturn 0;\n}\n\n/*\n * A parent image will have all ids but none of the names.\n *\n * All names in an rbd spec are dynamically allocated.  It's OK if we\n * can't figure out the name for an image id.\n */\nstatic int rbd_spec_fill_names(struct rbd_device *rbd_dev)\n{\n\tstruct ceph_osd_client *osdc = &rbd_dev->rbd_client->client->osdc;\n\tstruct rbd_spec *spec = rbd_dev->spec;\n\tconst char *pool_name;\n\tconst char *image_name;\n\tconst char *snap_name;\n\tint ret;\n\n\trbd_assert(spec->pool_id != CEPH_NOPOOL);\n\trbd_assert(spec->image_id);\n\trbd_assert(spec->snap_id != CEPH_NOSNAP);\n\n\t/* Get the pool name; we have to make our own copy of this */\n\n\tpool_name = ceph_pg_pool_name_by_id(osdc->osdmap, spec->pool_id);\n\tif (!pool_name) {\n\t\trbd_warn(rbd_dev, \"no pool with id %llu\", spec->pool_id);\n\t\treturn -EIO;\n\t}\n\tpool_name = kstrdup(pool_name, GFP_KERNEL);\n\tif (!pool_name)\n\t\treturn -ENOMEM;\n\n\t/* Fetch the image name; tolerate failure here */\n\n\timage_name = rbd_dev_image_name(rbd_dev);\n\tif (!image_name)\n\t\trbd_warn(rbd_dev, \"unable to get image name\");\n\n\t/* Fetch the snapshot name */\n\n\tsnap_name = rbd_snap_name(rbd_dev, spec->snap_id);\n\tif (IS_ERR(snap_name)) {\n\t\tret = PTR_ERR(snap_name);\n\t\tgoto out_err;\n\t}\n\n\tspec->pool_name = pool_name;\n\tspec->image_name = image_name;\n\tspec->snap_name = snap_name;\n\n\treturn 0;\n\nout_err:\n\tkfree(image_name);\n\tkfree(pool_name);\n\treturn ret;\n}\n\nstatic int rbd_dev_v2_snap_context(struct rbd_device *rbd_dev)\n{\n\tsize_t size;\n\tint ret;\n\tvoid *reply_buf;\n\tvoid *p;\n\tvoid *end;\n\tu64 seq;\n\tu32 snap_count;\n\tstruct ceph_snap_context *snapc;\n\tu32 i;\n\n\t/*\n\t * We'll need room for the seq value (maximum snapshot id),\n\t * snapshot count, and array of that many snapshot ids.\n\t * For now we have a fixed upper limit on the number we're\n\t * prepared to receive.\n\t */\n\tsize = sizeof (__le64) + sizeof (__le32) +\n\t\t\tRBD_MAX_SNAP_COUNT * sizeof (__le64);\n\treply_buf = kzalloc(size, GFP_KERNEL);\n\tif (!reply_buf)\n\t\treturn -ENOMEM;\n\n\tret = rbd_obj_method_sync(rbd_dev, &rbd_dev->header_oid,\n\t\t\t\t  &rbd_dev->header_oloc, \"get_snapcontext\",\n\t\t\t\t  NULL, 0, reply_buf, size);\n\tdout(\"%s: rbd_obj_method_sync returned %d\\n\", __func__, ret);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tp = reply_buf;\n\tend = reply_buf + ret;\n\tret = -ERANGE;\n\tceph_decode_64_safe(&p, end, seq, out);\n\tceph_decode_32_safe(&p, end, snap_count, out);\n\n\t/*\n\t * Make sure the reported number of snapshot ids wouldn't go\n\t * beyond the end of our buffer.  But before checking that,\n\t * make sure the computed size of the snapshot context we\n\t * allocate is representable in a size_t.\n\t */\n\tif (snap_count > (SIZE_MAX - sizeof (struct ceph_snap_context))\n\t\t\t\t / sizeof (u64)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!ceph_has_room(&p, end, snap_count * sizeof (__le64)))\n\t\tgoto out;\n\tret = 0;\n\n\tsnapc = ceph_create_snap_context(snap_count, GFP_KERNEL);\n\tif (!snapc) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsnapc->seq = seq;\n\tfor (i = 0; i < snap_count; i++)\n\t\tsnapc->snaps[i] = ceph_decode_64(&p);\n\n\tceph_put_snap_context(rbd_dev->header.snapc);\n\trbd_dev->header.snapc = snapc;\n\n\tdout(\"  snap context seq = %llu, snap_count = %u\\n\",\n\t\t(unsigned long long)seq, (unsigned int)snap_count);\nout:\n\tkfree(reply_buf);\n\n\treturn ret;\n}\n\nstatic const char *rbd_dev_v2_snap_name(struct rbd_device *rbd_dev,\n\t\t\t\t\tu64 snap_id)\n{\n\tsize_t size;\n\tvoid *reply_buf;\n\t__le64 snapid;\n\tint ret;\n\tvoid *p;\n\tvoid *end;\n\tchar *snap_name;\n\n\tsize = sizeof (__le32) + RBD_MAX_SNAP_NAME_LEN;\n\treply_buf = kmalloc(size, GFP_KERNEL);\n\tif (!reply_buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsnapid = cpu_to_le64(snap_id);\n\tret = rbd_obj_method_sync(rbd_dev, &rbd_dev->header_oid,\n\t\t\t\t  &rbd_dev->header_oloc, \"get_snapshot_name\",\n\t\t\t\t  &snapid, sizeof(snapid), reply_buf, size);\n\tdout(\"%s: rbd_obj_method_sync returned %d\\n\", __func__, ret);\n\tif (ret < 0) {\n\t\tsnap_name = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\tp = reply_buf;\n\tend = reply_buf + ret;\n\tsnap_name = ceph_extract_encoded_string(&p, end, NULL, GFP_KERNEL);\n\tif (IS_ERR(snap_name))\n\t\tgoto out;\n\n\tdout(\"  snap_id 0x%016llx snap_name = %s\\n\",\n\t\t(unsigned long long)snap_id, snap_name);\nout:\n\tkfree(reply_buf);\n\n\treturn snap_name;\n}\n\nstatic int rbd_dev_v2_header_info(struct rbd_device *rbd_dev)\n{\n\tbool first_time = rbd_dev->header.object_prefix == NULL;\n\tint ret;\n\n\tret = rbd_dev_v2_image_size(rbd_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (first_time) {\n\t\tret = rbd_dev_v2_header_onetime(rbd_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = rbd_dev_v2_snap_context(rbd_dev);\n\tif (ret && first_time) {\n\t\tkfree(rbd_dev->header.object_prefix);\n\t\trbd_dev->header.object_prefix = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int rbd_dev_header_info(struct rbd_device *rbd_dev)\n{\n\trbd_assert(rbd_image_format_valid(rbd_dev->image_format));\n\n\tif (rbd_dev->image_format == 1)\n\t\treturn rbd_dev_v1_header_info(rbd_dev);\n\n\treturn rbd_dev_v2_header_info(rbd_dev);\n}\n\n/*\n * Skips over white space at *buf, and updates *buf to point to the\n * first found non-space character (if any). Returns the length of\n * the token (string of non-white space characters) found.  Note\n * that *buf must be terminated with '\\0'.\n */\nstatic inline size_t next_token(const char **buf)\n{\n        /*\n        * These are the characters that produce nonzero for\n        * isspace() in the \"C\" and \"POSIX\" locales.\n        */\n        const char *spaces = \" \\f\\n\\r\\t\\v\";\n\n        *buf += strspn(*buf, spaces);\t/* Find start of token */\n\n\treturn strcspn(*buf, spaces);   /* Return token length */\n}\n\n/*\n * Finds the next token in *buf, dynamically allocates a buffer big\n * enough to hold a copy of it, and copies the token into the new\n * buffer.  The copy is guaranteed to be terminated with '\\0'.  Note\n * that a duplicate buffer is created even for a zero-length token.\n *\n * Returns a pointer to the newly-allocated duplicate, or a null\n * pointer if memory for the duplicate was not available.  If\n * the lenp argument is a non-null pointer, the length of the token\n * (not including the '\\0') is returned in *lenp.\n *\n * If successful, the *buf pointer will be updated to point beyond\n * the end of the found token.\n *\n * Note: uses GFP_KERNEL for allocation.\n */\nstatic inline char *dup_token(const char **buf, size_t *lenp)\n{\n\tchar *dup;\n\tsize_t len;\n\n\tlen = next_token(buf);\n\tdup = kmemdup(*buf, len + 1, GFP_KERNEL);\n\tif (!dup)\n\t\treturn NULL;\n\t*(dup + len) = '\\0';\n\t*buf += len;\n\n\tif (lenp)\n\t\t*lenp = len;\n\n\treturn dup;\n}\n\nstatic int rbd_parse_param(struct fs_parameter *param,\n\t\t\t    struct rbd_parse_opts_ctx *pctx)\n{\n\tstruct rbd_options *opt = pctx->opts;\n\tstruct fs_parse_result result;\n\tstruct p_log log = {.prefix = \"rbd\"};\n\tint token, ret;\n\n\tret = ceph_parse_param(param, pctx->copts, NULL);\n\tif (ret != -ENOPARAM)\n\t\treturn ret;\n\n\ttoken = __fs_parse(&log, rbd_parameters, param, &result);\n\tdout(\"%s fs_parse '%s' token %d\\n\", __func__, param->key, token);\n\tif (token < 0) {\n\t\tif (token == -ENOPARAM)\n\t\t\treturn inval_plog(&log, \"Unknown parameter '%s'\",\n\t\t\t\t\t  param->key);\n\t\treturn token;\n\t}\n\n\tswitch (token) {\n\tcase Opt_queue_depth:\n\t\tif (result.uint_32 < 1)\n\t\t\tgoto out_of_range;\n\t\topt->queue_depth = result.uint_32;\n\t\tbreak;\n\tcase Opt_alloc_size:\n\t\tif (result.uint_32 < SECTOR_SIZE)\n\t\t\tgoto out_of_range;\n\t\tif (!is_power_of_2(result.uint_32))\n\t\t\treturn inval_plog(&log, \"alloc_size must be a power of 2\");\n\t\topt->alloc_size = result.uint_32;\n\t\tbreak;\n\tcase Opt_lock_timeout:\n\t\t/* 0 is \"wait forever\" (i.e. infinite timeout) */\n\t\tif (result.uint_32 > INT_MAX / 1000)\n\t\t\tgoto out_of_range;\n\t\topt->lock_timeout = msecs_to_jiffies(result.uint_32 * 1000);\n\t\tbreak;\n\tcase Opt_pool_ns:\n\t\tkfree(pctx->spec->pool_ns);\n\t\tpctx->spec->pool_ns = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\tcase Opt_compression_hint:\n\t\tswitch (result.uint_32) {\n\t\tcase Opt_compression_hint_none:\n\t\t\topt->alloc_hint_flags &=\n\t\t\t    ~(CEPH_OSD_ALLOC_HINT_FLAG_COMPRESSIBLE |\n\t\t\t      CEPH_OSD_ALLOC_HINT_FLAG_INCOMPRESSIBLE);\n\t\t\tbreak;\n\t\tcase Opt_compression_hint_compressible:\n\t\t\topt->alloc_hint_flags |=\n\t\t\t    CEPH_OSD_ALLOC_HINT_FLAG_COMPRESSIBLE;\n\t\t\topt->alloc_hint_flags &=\n\t\t\t    ~CEPH_OSD_ALLOC_HINT_FLAG_INCOMPRESSIBLE;\n\t\t\tbreak;\n\t\tcase Opt_compression_hint_incompressible:\n\t\t\topt->alloc_hint_flags |=\n\t\t\t    CEPH_OSD_ALLOC_HINT_FLAG_INCOMPRESSIBLE;\n\t\t\topt->alloc_hint_flags &=\n\t\t\t    ~CEPH_OSD_ALLOC_HINT_FLAG_COMPRESSIBLE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tbreak;\n\tcase Opt_read_only:\n\t\topt->read_only = true;\n\t\tbreak;\n\tcase Opt_read_write:\n\t\topt->read_only = false;\n\t\tbreak;\n\tcase Opt_lock_on_read:\n\t\topt->lock_on_read = true;\n\t\tbreak;\n\tcase Opt_exclusive:\n\t\topt->exclusive = true;\n\t\tbreak;\n\tcase Opt_notrim:\n\t\topt->trim = false;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn 0;\n\nout_of_range:\n\treturn inval_plog(&log, \"%s out of range\", param->key);\n}\n\n/*\n * This duplicates most of generic_parse_monolithic(), untying it from\n * fs_context and skipping standard superblock and security options.\n */\nstatic int rbd_parse_options(char *options, struct rbd_parse_opts_ctx *pctx)\n{\n\tchar *key;\n\tint ret = 0;\n\n\tdout(\"%s '%s'\\n\", __func__, options);\n\twhile ((key = strsep(&options, \",\")) != NULL) {\n\t\tif (*key) {\n\t\t\tstruct fs_parameter param = {\n\t\t\t\t.key\t= key,\n\t\t\t\t.type\t= fs_value_is_flag,\n\t\t\t};\n\t\t\tchar *value = strchr(key, '=');\n\t\t\tsize_t v_len = 0;\n\n\t\t\tif (value) {\n\t\t\t\tif (value == key)\n\t\t\t\t\tcontinue;\n\t\t\t\t*value++ = 0;\n\t\t\t\tv_len = strlen(value);\n\t\t\t\tparam.string = kmemdup_nul(value, v_len,\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\t\tif (!param.string)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tparam.type = fs_value_is_string;\n\t\t\t}\n\t\t\tparam.size = v_len;\n\n\t\t\tret = rbd_parse_param(&param, pctx);\n\t\t\tkfree(param.string);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/*\n * Parse the options provided for an \"rbd add\" (i.e., rbd image\n * mapping) request.  These arrive via a write to /sys/bus/rbd/add,\n * and the data written is passed here via a NUL-terminated buffer.\n * Returns 0 if successful or an error code otherwise.\n *\n * The information extracted from these options is recorded in\n * the other parameters which return dynamically-allocated\n * structures:\n *  ceph_opts\n *      The address of a pointer that will refer to a ceph options\n *      structure.  Caller must release the returned pointer using\n *      ceph_destroy_options() when it is no longer needed.\n *  rbd_opts\n *\tAddress of an rbd options pointer.  Fully initialized by\n *\tthis function; caller must release with kfree().\n *  spec\n *\tAddress of an rbd image specification pointer.  Fully\n *\tinitialized by this function based on parsed options.\n *\tCaller must release with rbd_spec_put().\n *\n * The options passed take this form:\n *  <mon_addrs> <options> <pool_name> <image_name> [<snap_id>]\n * where:\n *  <mon_addrs>\n *      A comma-separated list of one or more monitor addresses.\n *      A monitor address is an ip address, optionally followed\n *      by a port number (separated by a colon).\n *        I.e.:  ip1[:port1][,ip2[:port2]...]\n *  <options>\n *      A comma-separated list of ceph and/or rbd options.\n *  <pool_name>\n *      The name of the rados pool containing the rbd image.\n *  <image_name>\n *      The name of the image in that pool to map.\n *  <snap_id>\n *      An optional snapshot id.  If provided, the mapping will\n *      present data from the image at the time that snapshot was\n *      created.  The image head is used if no snapshot id is\n *      provided.  Snapshot mappings are always read-only.\n */\nstatic int rbd_add_parse_args(const char *buf,\n\t\t\t\tstruct ceph_options **ceph_opts,\n\t\t\t\tstruct rbd_options **opts,\n\t\t\t\tstruct rbd_spec **rbd_spec)\n{\n\tsize_t len;\n\tchar *options;\n\tconst char *mon_addrs;\n\tchar *snap_name;\n\tsize_t mon_addrs_size;\n\tstruct rbd_parse_opts_ctx pctx = { 0 };\n\tint ret;\n\n\t/* The first four tokens are required */\n\n\tlen = next_token(&buf);\n\tif (!len) {\n\t\trbd_warn(NULL, \"no monitor address(es) provided\");\n\t\treturn -EINVAL;\n\t}\n\tmon_addrs = buf;\n\tmon_addrs_size = len;\n\tbuf += len;\n\n\tret = -EINVAL;\n\toptions = dup_token(&buf, NULL);\n\tif (!options)\n\t\treturn -ENOMEM;\n\tif (!*options) {\n\t\trbd_warn(NULL, \"no options provided\");\n\t\tgoto out_err;\n\t}\n\n\tpctx.spec = rbd_spec_alloc();\n\tif (!pctx.spec)\n\t\tgoto out_mem;\n\n\tpctx.spec->pool_name = dup_token(&buf, NULL);\n\tif (!pctx.spec->pool_name)\n\t\tgoto out_mem;\n\tif (!*pctx.spec->pool_name) {\n\t\trbd_warn(NULL, \"no pool name provided\");\n\t\tgoto out_err;\n\t}\n\n\tpctx.spec->image_name = dup_token(&buf, NULL);\n\tif (!pctx.spec->image_name)\n\t\tgoto out_mem;\n\tif (!*pctx.spec->image_name) {\n\t\trbd_warn(NULL, \"no image name provided\");\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Snapshot name is optional; default is to use \"-\"\n\t * (indicating the head/no snapshot).\n\t */\n\tlen = next_token(&buf);\n\tif (!len) {\n\t\tbuf = RBD_SNAP_HEAD_NAME; /* No snapshot supplied */\n\t\tlen = sizeof (RBD_SNAP_HEAD_NAME) - 1;\n\t} else if (len > RBD_MAX_SNAP_NAME_LEN) {\n\t\tret = -ENAMETOOLONG;\n\t\tgoto out_err;\n\t}\n\tsnap_name = kmemdup(buf, len + 1, GFP_KERNEL);\n\tif (!snap_name)\n\t\tgoto out_mem;\n\t*(snap_name + len) = '\\0';\n\tpctx.spec->snap_name = snap_name;\n\n\tpctx.copts = ceph_alloc_options();\n\tif (!pctx.copts)\n\t\tgoto out_mem;\n\n\t/* Initialize all rbd options to the defaults */\n\n\tpctx.opts = kzalloc(sizeof(*pctx.opts), GFP_KERNEL);\n\tif (!pctx.opts)\n\t\tgoto out_mem;\n\n\tpctx.opts->read_only = RBD_READ_ONLY_DEFAULT;\n\tpctx.opts->queue_depth = RBD_QUEUE_DEPTH_DEFAULT;\n\tpctx.opts->alloc_size = RBD_ALLOC_SIZE_DEFAULT;\n\tpctx.opts->lock_timeout = RBD_LOCK_TIMEOUT_DEFAULT;\n\tpctx.opts->lock_on_read = RBD_LOCK_ON_READ_DEFAULT;\n\tpctx.opts->exclusive = RBD_EXCLUSIVE_DEFAULT;\n\tpctx.opts->trim = RBD_TRIM_DEFAULT;\n\n\tret = ceph_parse_mon_ips(mon_addrs, mon_addrs_size, pctx.copts, NULL);\n\tif (ret)\n\t\tgoto out_err;\n\n\tret = rbd_parse_options(options, &pctx);\n\tif (ret)\n\t\tgoto out_err;\n\n\t*ceph_opts = pctx.copts;\n\t*opts = pctx.opts;\n\t*rbd_spec = pctx.spec;\n\tkfree(options);\n\treturn 0;\n\nout_mem:\n\tret = -ENOMEM;\nout_err:\n\tkfree(pctx.opts);\n\tceph_destroy_options(pctx.copts);\n\trbd_spec_put(pctx.spec);\n\tkfree(options);\n\treturn ret;\n}\n\nstatic void rbd_dev_image_unlock(struct rbd_device *rbd_dev)\n{\n\tdown_write(&rbd_dev->lock_rwsem);\n\tif (__rbd_is_lock_owner(rbd_dev))\n\t\t__rbd_release_lock(rbd_dev);\n\tup_write(&rbd_dev->lock_rwsem);\n}\n\n/*\n * If the wait is interrupted, an error is returned even if the lock\n * was successfully acquired.  rbd_dev_image_unlock() will release it\n * if needed.\n */\nstatic int rbd_add_acquire_lock(struct rbd_device *rbd_dev)\n{\n\tlong ret;\n\n\tif (!(rbd_dev->header.features & RBD_FEATURE_EXCLUSIVE_LOCK)) {\n\t\tif (!rbd_dev->opts->exclusive && !rbd_dev->opts->lock_on_read)\n\t\t\treturn 0;\n\n\t\trbd_warn(rbd_dev, \"exclusive-lock feature is not enabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rbd_is_ro(rbd_dev))\n\t\treturn 0;\n\n\trbd_assert(!rbd_is_lock_owner(rbd_dev));\n\tqueue_delayed_work(rbd_dev->task_wq, &rbd_dev->lock_dwork, 0);\n\tret = wait_for_completion_killable_timeout(&rbd_dev->acquire_wait,\n\t\t\t    ceph_timeout_jiffies(rbd_dev->opts->lock_timeout));\n\tif (ret > 0) {\n\t\tret = rbd_dev->acquire_err;\n\t} else {\n\t\tcancel_delayed_work_sync(&rbd_dev->lock_dwork);\n\t\tif (!ret)\n\t\t\tret = -ETIMEDOUT;\n\t}\n\n\tif (ret) {\n\t\trbd_warn(rbd_dev, \"failed to acquire exclusive lock: %ld\", ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * The lock may have been released by now, unless automatic lock\n\t * transitions are disabled.\n\t */\n\trbd_assert(!rbd_dev->opts->exclusive || rbd_is_lock_owner(rbd_dev));\n\treturn 0;\n}\n\n/*\n * An rbd format 2 image has a unique identifier, distinct from the\n * name given to it by the user.  Internally, that identifier is\n * what's used to specify the names of objects related to the image.\n *\n * A special \"rbd id\" object is used to map an rbd image name to its\n * id.  If that object doesn't exist, then there is no v2 rbd image\n * with the supplied name.\n *\n * This function will record the given rbd_dev's image_id field if\n * it can be determined, and in that case will return 0.  If any\n * errors occur a negative errno will be returned and the rbd_dev's\n * image_id field will be unchanged (and should be NULL).\n */\nstatic int rbd_dev_image_id(struct rbd_device *rbd_dev)\n{\n\tint ret;\n\tsize_t size;\n\tCEPH_DEFINE_OID_ONSTACK(oid);\n\tvoid *response;\n\tchar *image_id;\n\n\t/*\n\t * When probing a parent image, the image id is already\n\t * known (and the image name likely is not).  There's no\n\t * need to fetch the image id again in this case.  We\n\t * do still need to set the image format though.\n\t */\n\tif (rbd_dev->spec->image_id) {\n\t\trbd_dev->image_format = *rbd_dev->spec->image_id ? 2 : 1;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * First, see if the format 2 image id file exists, and if\n\t * so, get the image's persistent id from it.\n\t */\n\tret = ceph_oid_aprintf(&oid, GFP_KERNEL, \"%s%s\", RBD_ID_PREFIX,\n\t\t\t       rbd_dev->spec->image_name);\n\tif (ret)\n\t\treturn ret;\n\n\tdout(\"rbd id object name is %s\\n\", oid.name);\n\n\t/* Response will be an encoded string, which includes a length */\n\tsize = sizeof (__le32) + RBD_IMAGE_ID_LEN_MAX;\n\tresponse = kzalloc(size, GFP_NOIO);\n\tif (!response) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* If it doesn't exist we'll assume it's a format 1 image */\n\n\tret = rbd_obj_method_sync(rbd_dev, &oid, &rbd_dev->header_oloc,\n\t\t\t\t  \"get_id\", NULL, 0,\n\t\t\t\t  response, size);\n\tdout(\"%s: rbd_obj_method_sync returned %d\\n\", __func__, ret);\n\tif (ret == -ENOENT) {\n\t\timage_id = kstrdup(\"\", GFP_KERNEL);\n\t\tret = image_id ? 0 : -ENOMEM;\n\t\tif (!ret)\n\t\t\trbd_dev->image_format = 1;\n\t} else if (ret >= 0) {\n\t\tvoid *p = response;\n\n\t\timage_id = ceph_extract_encoded_string(&p, p + ret,\n\t\t\t\t\t\tNULL, GFP_NOIO);\n\t\tret = PTR_ERR_OR_ZERO(image_id);\n\t\tif (!ret)\n\t\t\trbd_dev->image_format = 2;\n\t}\n\n\tif (!ret) {\n\t\trbd_dev->spec->image_id = image_id;\n\t\tdout(\"image_id is %s\\n\", image_id);\n\t}\nout:\n\tkfree(response);\n\tceph_oid_destroy(&oid);\n\treturn ret;\n}\n\n/*\n * Undo whatever state changes are made by v1 or v2 header info\n * call.\n */\nstatic void rbd_dev_unprobe(struct rbd_device *rbd_dev)\n{\n\tstruct rbd_image_header\t*header;\n\n\trbd_dev_parent_put(rbd_dev);\n\trbd_object_map_free(rbd_dev);\n\trbd_dev_mapping_clear(rbd_dev);\n\n\t/* Free dynamic fields from the header, then zero it out */\n\n\theader = &rbd_dev->header;\n\tceph_put_snap_context(header->snapc);\n\tkfree(header->snap_sizes);\n\tkfree(header->snap_names);\n\tkfree(header->object_prefix);\n\tmemset(header, 0, sizeof (*header));\n}\n\nstatic int rbd_dev_v2_header_onetime(struct rbd_device *rbd_dev)\n{\n\tint ret;\n\n\tret = rbd_dev_v2_object_prefix(rbd_dev);\n\tif (ret)\n\t\tgoto out_err;\n\n\t/*\n\t * Get the and check features for the image.  Currently the\n\t * features are assumed to never change.\n\t */\n\tret = rbd_dev_v2_features(rbd_dev);\n\tif (ret)\n\t\tgoto out_err;\n\n\t/* If the image supports fancy striping, get its parameters */\n\n\tif (rbd_dev->header.features & RBD_FEATURE_STRIPINGV2) {\n\t\tret = rbd_dev_v2_striping_info(rbd_dev);\n\t\tif (ret < 0)\n\t\t\tgoto out_err;\n\t}\n\n\tif (rbd_dev->header.features & RBD_FEATURE_DATA_POOL) {\n\t\tret = rbd_dev_v2_data_pool(rbd_dev);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\t}\n\n\trbd_init_layout(rbd_dev);\n\treturn 0;\n\nout_err:\n\trbd_dev->header.features = 0;\n\tkfree(rbd_dev->header.object_prefix);\n\trbd_dev->header.object_prefix = NULL;\n\treturn ret;\n}\n\n/*\n * @depth is rbd_dev_image_probe() -> rbd_dev_probe_parent() ->\n * rbd_dev_image_probe() recursion depth, which means it's also the\n * length of the already discovered part of the parent chain.\n */\nstatic int rbd_dev_probe_parent(struct rbd_device *rbd_dev, int depth)\n{\n\tstruct rbd_device *parent = NULL;\n\tint ret;\n\n\tif (!rbd_dev->parent_spec)\n\t\treturn 0;\n\n\tif (++depth > RBD_MAX_PARENT_CHAIN_LEN) {\n\t\tpr_info(\"parent chain is too long (%d)\\n\", depth);\n\t\tret = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tparent = __rbd_dev_create(rbd_dev->rbd_client, rbd_dev->parent_spec);\n\tif (!parent) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * Images related by parent/child relationships always share\n\t * rbd_client and spec/parent_spec, so bump their refcounts.\n\t */\n\t__rbd_get_client(rbd_dev->rbd_client);\n\trbd_spec_get(rbd_dev->parent_spec);\n\n\t__set_bit(RBD_DEV_FLAG_READONLY, &parent->flags);\n\n\tret = rbd_dev_image_probe(parent, depth);\n\tif (ret < 0)\n\t\tgoto out_err;\n\n\trbd_dev->parent = parent;\n\tatomic_set(&rbd_dev->parent_ref, 1);\n\treturn 0;\n\nout_err:\n\trbd_dev_unparent(rbd_dev);\n\trbd_dev_destroy(parent);\n\treturn ret;\n}\n\nstatic void rbd_dev_device_release(struct rbd_device *rbd_dev)\n{\n\tclear_bit(RBD_DEV_FLAG_EXISTS, &rbd_dev->flags);\n\trbd_free_disk(rbd_dev);\n\tif (!single_major)\n\t\tunregister_blkdev(rbd_dev->major, rbd_dev->name);\n}\n\n/*\n * rbd_dev->header_rwsem must be locked for write and will be unlocked\n * upon return.\n */\nstatic int rbd_dev_device_setup(struct rbd_device *rbd_dev)\n{\n\tint ret;\n\n\t/* Record our major and minor device numbers. */\n\n\tif (!single_major) {\n\t\tret = register_blkdev(0, rbd_dev->name);\n\t\tif (ret < 0)\n\t\t\tgoto err_out_unlock;\n\n\t\trbd_dev->major = ret;\n\t\trbd_dev->minor = 0;\n\t} else {\n\t\trbd_dev->major = rbd_major;\n\t\trbd_dev->minor = rbd_dev_id_to_minor(rbd_dev->dev_id);\n\t}\n\n\t/* Set up the blkdev mapping. */\n\n\tret = rbd_init_disk(rbd_dev);\n\tif (ret)\n\t\tgoto err_out_blkdev;\n\n\tset_capacity(rbd_dev->disk, rbd_dev->mapping.size / SECTOR_SIZE);\n\tset_disk_ro(rbd_dev->disk, rbd_is_ro(rbd_dev));\n\n\tret = dev_set_name(&rbd_dev->dev, \"%d\", rbd_dev->dev_id);\n\tif (ret)\n\t\tgoto err_out_disk;\n\n\tset_bit(RBD_DEV_FLAG_EXISTS, &rbd_dev->flags);\n\tup_write(&rbd_dev->header_rwsem);\n\treturn 0;\n\nerr_out_disk:\n\trbd_free_disk(rbd_dev);\nerr_out_blkdev:\n\tif (!single_major)\n\t\tunregister_blkdev(rbd_dev->major, rbd_dev->name);\nerr_out_unlock:\n\tup_write(&rbd_dev->header_rwsem);\n\treturn ret;\n}\n\nstatic int rbd_dev_header_name(struct rbd_device *rbd_dev)\n{\n\tstruct rbd_spec *spec = rbd_dev->spec;\n\tint ret;\n\n\t/* Record the header object name for this rbd image. */\n\n\trbd_assert(rbd_image_format_valid(rbd_dev->image_format));\n\tif (rbd_dev->image_format == 1)\n\t\tret = ceph_oid_aprintf(&rbd_dev->header_oid, GFP_KERNEL, \"%s%s\",\n\t\t\t\t       spec->image_name, RBD_SUFFIX);\n\telse\n\t\tret = ceph_oid_aprintf(&rbd_dev->header_oid, GFP_KERNEL, \"%s%s\",\n\t\t\t\t       RBD_HEADER_PREFIX, spec->image_id);\n\n\treturn ret;\n}\n\nstatic void rbd_print_dne(struct rbd_device *rbd_dev, bool is_snap)\n{\n\tif (!is_snap) {\n\t\tpr_info(\"image %s/%s%s%s does not exist\\n\",\n\t\t\trbd_dev->spec->pool_name,\n\t\t\trbd_dev->spec->pool_ns ?: \"\",\n\t\t\trbd_dev->spec->pool_ns ? \"/\" : \"\",\n\t\t\trbd_dev->spec->image_name);\n\t} else {\n\t\tpr_info(\"snap %s/%s%s%s@%s does not exist\\n\",\n\t\t\trbd_dev->spec->pool_name,\n\t\t\trbd_dev->spec->pool_ns ?: \"\",\n\t\t\trbd_dev->spec->pool_ns ? \"/\" : \"\",\n\t\t\trbd_dev->spec->image_name,\n\t\t\trbd_dev->spec->snap_name);\n\t}\n}\n\nstatic void rbd_dev_image_release(struct rbd_device *rbd_dev)\n{\n\tif (!rbd_is_ro(rbd_dev))\n\t\trbd_unregister_watch(rbd_dev);\n\n\trbd_dev_unprobe(rbd_dev);\n\trbd_dev->image_format = 0;\n\tkfree(rbd_dev->spec->image_id);\n\trbd_dev->spec->image_id = NULL;\n}\n\n/*\n * Probe for the existence of the header object for the given rbd\n * device.  If this image is the one being mapped (i.e., not a\n * parent), initiate a watch on its header object before using that\n * object to get detailed information about the rbd image.\n *\n * On success, returns with header_rwsem held for write if called\n * with @depth == 0.\n */\nstatic int rbd_dev_image_probe(struct rbd_device *rbd_dev, int depth)\n{\n\tbool need_watch = !rbd_is_ro(rbd_dev);\n\tint ret;\n\n\t/*\n\t * Get the id from the image id object.  Unless there's an\n\t * error, rbd_dev->spec->image_id will be filled in with\n\t * a dynamically-allocated string, and rbd_dev->image_format\n\t * will be set to either 1 or 2.\n\t */\n\tret = rbd_dev_image_id(rbd_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rbd_dev_header_name(rbd_dev);\n\tif (ret)\n\t\tgoto err_out_format;\n\n\tif (need_watch) {\n\t\tret = rbd_register_watch(rbd_dev);\n\t\tif (ret) {\n\t\t\tif (ret == -ENOENT)\n\t\t\t\trbd_print_dne(rbd_dev, false);\n\t\t\tgoto err_out_format;\n\t\t}\n\t}\n\n\tif (!depth)\n\t\tdown_write(&rbd_dev->header_rwsem);\n\n\tret = rbd_dev_header_info(rbd_dev);\n\tif (ret) {\n\t\tif (ret == -ENOENT && !need_watch)\n\t\t\trbd_print_dne(rbd_dev, false);\n\t\tgoto err_out_probe;\n\t}\n\n\t/*\n\t * If this image is the one being mapped, we have pool name and\n\t * id, image name and id, and snap name - need to fill snap id.\n\t * Otherwise this is a parent image, identified by pool, image\n\t * and snap ids - need to fill in names for those ids.\n\t */\n\tif (!depth)\n\t\tret = rbd_spec_fill_snap_id(rbd_dev);\n\telse\n\t\tret = rbd_spec_fill_names(rbd_dev);\n\tif (ret) {\n\t\tif (ret == -ENOENT)\n\t\t\trbd_print_dne(rbd_dev, true);\n\t\tgoto err_out_probe;\n\t}\n\n\tret = rbd_dev_mapping_set(rbd_dev);\n\tif (ret)\n\t\tgoto err_out_probe;\n\n\tif (rbd_is_snap(rbd_dev) &&\n\t    (rbd_dev->header.features & RBD_FEATURE_OBJECT_MAP)) {\n\t\tret = rbd_object_map_load(rbd_dev);\n\t\tif (ret)\n\t\t\tgoto err_out_probe;\n\t}\n\n\tif (rbd_dev->header.features & RBD_FEATURE_LAYERING) {\n\t\tret = rbd_dev_v2_parent_info(rbd_dev);\n\t\tif (ret)\n\t\t\tgoto err_out_probe;\n\t}\n\n\tret = rbd_dev_probe_parent(rbd_dev, depth);\n\tif (ret)\n\t\tgoto err_out_probe;\n\n\tdout(\"discovered format %u image, header name is %s\\n\",\n\t\trbd_dev->image_format, rbd_dev->header_oid.name);\n\treturn 0;\n\nerr_out_probe:\n\tif (!depth)\n\t\tup_write(&rbd_dev->header_rwsem);\n\tif (need_watch)\n\t\trbd_unregister_watch(rbd_dev);\n\trbd_dev_unprobe(rbd_dev);\nerr_out_format:\n\trbd_dev->image_format = 0;\n\tkfree(rbd_dev->spec->image_id);\n\trbd_dev->spec->image_id = NULL;\n\treturn ret;\n}\n\nstatic ssize_t do_rbd_add(struct bus_type *bus,\n\t\t\t  const char *buf,\n\t\t\t  size_t count)\n{\n\tstruct rbd_device *rbd_dev = NULL;\n\tstruct ceph_options *ceph_opts = NULL;\n\tstruct rbd_options *rbd_opts = NULL;\n\tstruct rbd_spec *spec = NULL;\n\tstruct rbd_client *rbdc;\n\tint rc;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn -ENODEV;\n\n\t/* parse add command */\n\trc = rbd_add_parse_args(buf, &ceph_opts, &rbd_opts, &spec);\n\tif (rc < 0)\n\t\tgoto out;\n\n\trbdc = rbd_get_client(ceph_opts);\n\tif (IS_ERR(rbdc)) {\n\t\trc = PTR_ERR(rbdc);\n\t\tgoto err_out_args;\n\t}\n\n\t/* pick the pool */\n\trc = ceph_pg_poolid_by_name(rbdc->client->osdc.osdmap, spec->pool_name);\n\tif (rc < 0) {\n\t\tif (rc == -ENOENT)\n\t\t\tpr_info(\"pool %s does not exist\\n\", spec->pool_name);\n\t\tgoto err_out_client;\n\t}\n\tspec->pool_id = (u64)rc;\n\n\trbd_dev = rbd_dev_create(rbdc, spec, rbd_opts);\n\tif (!rbd_dev) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_client;\n\t}\n\trbdc = NULL;\t\t/* rbd_dev now owns this */\n\tspec = NULL;\t\t/* rbd_dev now owns this */\n\trbd_opts = NULL;\t/* rbd_dev now owns this */\n\n\t/* if we are mapping a snapshot it will be a read-only mapping */\n\tif (rbd_dev->opts->read_only ||\n\t    strcmp(rbd_dev->spec->snap_name, RBD_SNAP_HEAD_NAME))\n\t\t__set_bit(RBD_DEV_FLAG_READONLY, &rbd_dev->flags);\n\n\trbd_dev->config_info = kstrdup(buf, GFP_KERNEL);\n\tif (!rbd_dev->config_info) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_rbd_dev;\n\t}\n\n\trc = rbd_dev_image_probe(rbd_dev, 0);\n\tif (rc < 0)\n\t\tgoto err_out_rbd_dev;\n\n\tif (rbd_dev->opts->alloc_size > rbd_dev->layout.object_size) {\n\t\trbd_warn(rbd_dev, \"alloc_size adjusted to %u\",\n\t\t\t rbd_dev->layout.object_size);\n\t\trbd_dev->opts->alloc_size = rbd_dev->layout.object_size;\n\t}\n\n\trc = rbd_dev_device_setup(rbd_dev);\n\tif (rc)\n\t\tgoto err_out_image_probe;\n\n\trc = rbd_add_acquire_lock(rbd_dev);\n\tif (rc)\n\t\tgoto err_out_image_lock;\n\n\t/* Everything's ready.  Announce the disk to the world. */\n\n\trc = device_add(&rbd_dev->dev);\n\tif (rc)\n\t\tgoto err_out_image_lock;\n\n\tdevice_add_disk(&rbd_dev->dev, rbd_dev->disk, NULL);\n\t/* see rbd_init_disk() */\n\tblk_put_queue(rbd_dev->disk->queue);\n\n\tspin_lock(&rbd_dev_list_lock);\n\tlist_add_tail(&rbd_dev->node, &rbd_dev_list);\n\tspin_unlock(&rbd_dev_list_lock);\n\n\tpr_info(\"%s: capacity %llu features 0x%llx\\n\", rbd_dev->disk->disk_name,\n\t\t(unsigned long long)get_capacity(rbd_dev->disk) << SECTOR_SHIFT,\n\t\trbd_dev->header.features);\n\trc = count;\nout:\n\tmodule_put(THIS_MODULE);\n\treturn rc;\n\nerr_out_image_lock:\n\trbd_dev_image_unlock(rbd_dev);\n\trbd_dev_device_release(rbd_dev);\nerr_out_image_probe:\n\trbd_dev_image_release(rbd_dev);\nerr_out_rbd_dev:\n\trbd_dev_destroy(rbd_dev);\nerr_out_client:\n\trbd_put_client(rbdc);\nerr_out_args:\n\trbd_spec_put(spec);\n\tkfree(rbd_opts);\n\tgoto out;\n}\n\nstatic ssize_t add_store(struct bus_type *bus, const char *buf, size_t count)\n{\n\tif (single_major)\n\t\treturn -EINVAL;\n\n\treturn do_rbd_add(bus, buf, count);\n}\n\nstatic ssize_t add_single_major_store(struct bus_type *bus, const char *buf,\n\t\t\t\t      size_t count)\n{\n\treturn do_rbd_add(bus, buf, count);\n}\n\nstatic void rbd_dev_remove_parent(struct rbd_device *rbd_dev)\n{\n\twhile (rbd_dev->parent) {\n\t\tstruct rbd_device *first = rbd_dev;\n\t\tstruct rbd_device *second = first->parent;\n\t\tstruct rbd_device *third;\n\n\t\t/*\n\t\t * Follow to the parent with no grandparent and\n\t\t * remove it.\n\t\t */\n\t\twhile (second && (third = second->parent)) {\n\t\t\tfirst = second;\n\t\t\tsecond = third;\n\t\t}\n\t\trbd_assert(second);\n\t\trbd_dev_image_release(second);\n\t\trbd_dev_destroy(second);\n\t\tfirst->parent = NULL;\n\t\tfirst->parent_overlap = 0;\n\n\t\trbd_assert(first->parent_spec);\n\t\trbd_spec_put(first->parent_spec);\n\t\tfirst->parent_spec = NULL;\n\t}\n}\n\nstatic ssize_t do_rbd_remove(struct bus_type *bus,\n\t\t\t     const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct rbd_device *rbd_dev = NULL;\n\tstruct list_head *tmp;\n\tint dev_id;\n\tchar opt_buf[6];\n\tbool force = false;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tdev_id = -1;\n\topt_buf[0] = '\\0';\n\tsscanf(buf, \"%d %5s\", &dev_id, opt_buf);\n\tif (dev_id < 0) {\n\t\tpr_err(\"dev_id out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (opt_buf[0] != '\\0') {\n\t\tif (!strcmp(opt_buf, \"force\")) {\n\t\t\tforce = true;\n\t\t} else {\n\t\t\tpr_err(\"bad remove option at '%s'\\n\", opt_buf);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = -ENOENT;\n\tspin_lock(&rbd_dev_list_lock);\n\tlist_for_each(tmp, &rbd_dev_list) {\n\t\trbd_dev = list_entry(tmp, struct rbd_device, node);\n\t\tif (rbd_dev->dev_id == dev_id) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!ret) {\n\t\tspin_lock_irq(&rbd_dev->lock);\n\t\tif (rbd_dev->open_count && !force)\n\t\t\tret = -EBUSY;\n\t\telse if (test_and_set_bit(RBD_DEV_FLAG_REMOVING,\n\t\t\t\t\t  &rbd_dev->flags))\n\t\t\tret = -EINPROGRESS;\n\t\tspin_unlock_irq(&rbd_dev->lock);\n\t}\n\tspin_unlock(&rbd_dev_list_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (force) {\n\t\t/*\n\t\t * Prevent new IO from being queued and wait for existing\n\t\t * IO to complete/fail.\n\t\t */\n\t\tblk_mq_freeze_queue(rbd_dev->disk->queue);\n\t\tblk_set_queue_dying(rbd_dev->disk->queue);\n\t}\n\n\tdel_gendisk(rbd_dev->disk);\n\tspin_lock(&rbd_dev_list_lock);\n\tlist_del_init(&rbd_dev->node);\n\tspin_unlock(&rbd_dev_list_lock);\n\tdevice_del(&rbd_dev->dev);\n\n\trbd_dev_image_unlock(rbd_dev);\n\trbd_dev_device_release(rbd_dev);\n\trbd_dev_image_release(rbd_dev);\n\trbd_dev_destroy(rbd_dev);\n\treturn count;\n}\n\nstatic ssize_t remove_store(struct bus_type *bus, const char *buf, size_t count)\n{\n\tif (single_major)\n\t\treturn -EINVAL;\n\n\treturn do_rbd_remove(bus, buf, count);\n}\n\nstatic ssize_t remove_single_major_store(struct bus_type *bus, const char *buf,\n\t\t\t\t\t size_t count)\n{\n\treturn do_rbd_remove(bus, buf, count);\n}\n\n/*\n * create control files in sysfs\n * /sys/bus/rbd/...\n */\nstatic int __init rbd_sysfs_init(void)\n{\n\tint ret;\n\n\tret = device_register(&rbd_root_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bus_register(&rbd_bus_type);\n\tif (ret < 0)\n\t\tdevice_unregister(&rbd_root_dev);\n\n\treturn ret;\n}\n\nstatic void __exit rbd_sysfs_cleanup(void)\n{\n\tbus_unregister(&rbd_bus_type);\n\tdevice_unregister(&rbd_root_dev);\n}\n\nstatic int __init rbd_slab_init(void)\n{\n\trbd_assert(!rbd_img_request_cache);\n\trbd_img_request_cache = KMEM_CACHE(rbd_img_request, 0);\n\tif (!rbd_img_request_cache)\n\t\treturn -ENOMEM;\n\n\trbd_assert(!rbd_obj_request_cache);\n\trbd_obj_request_cache = KMEM_CACHE(rbd_obj_request, 0);\n\tif (!rbd_obj_request_cache)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tkmem_cache_destroy(rbd_img_request_cache);\n\trbd_img_request_cache = NULL;\n\treturn -ENOMEM;\n}\n\nstatic void rbd_slab_exit(void)\n{\n\trbd_assert(rbd_obj_request_cache);\n\tkmem_cache_destroy(rbd_obj_request_cache);\n\trbd_obj_request_cache = NULL;\n\n\trbd_assert(rbd_img_request_cache);\n\tkmem_cache_destroy(rbd_img_request_cache);\n\trbd_img_request_cache = NULL;\n}\n\nstatic int __init rbd_init(void)\n{\n\tint rc;\n\n\tif (!libceph_compatible(NULL)) {\n\t\trbd_warn(NULL, \"libceph incompatibility (quitting)\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = rbd_slab_init();\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * The number of active work items is limited by the number of\n\t * rbd devices * queue depth, so leave @max_active at default.\n\t */\n\trbd_wq = alloc_workqueue(RBD_DRV_NAME, WQ_MEM_RECLAIM, 0);\n\tif (!rbd_wq) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_slab;\n\t}\n\n\tif (single_major) {\n\t\trbd_major = register_blkdev(0, RBD_DRV_NAME);\n\t\tif (rbd_major < 0) {\n\t\t\trc = rbd_major;\n\t\t\tgoto err_out_wq;\n\t\t}\n\t}\n\n\trc = rbd_sysfs_init();\n\tif (rc)\n\t\tgoto err_out_blkdev;\n\n\tif (single_major)\n\t\tpr_info(\"loaded (major %d)\\n\", rbd_major);\n\telse\n\t\tpr_info(\"loaded\\n\");\n\n\treturn 0;\n\nerr_out_blkdev:\n\tif (single_major)\n\t\tunregister_blkdev(rbd_major, RBD_DRV_NAME);\nerr_out_wq:\n\tdestroy_workqueue(rbd_wq);\nerr_out_slab:\n\trbd_slab_exit();\n\treturn rc;\n}\n\nstatic void __exit rbd_exit(void)\n{\n\tida_destroy(&rbd_dev_id_ida);\n\trbd_sysfs_cleanup();\n\tif (single_major)\n\t\tunregister_blkdev(rbd_major, RBD_DRV_NAME);\n\tdestroy_workqueue(rbd_wq);\n\trbd_slab_exit();\n}\n\nmodule_init(rbd_init);\nmodule_exit(rbd_exit);\n\nMODULE_AUTHOR(\"Alex Elder <elder@inktank.com>\");\nMODULE_AUTHOR(\"Sage Weil <sage@newdream.net>\");\nMODULE_AUTHOR(\"Yehuda Sadeh <yehuda@hq.newdream.net>\");\n/* following authorship retained from original osdblk.c */\nMODULE_AUTHOR(\"Jeff Garzik <jeff@garzik.org>\");\n\nMODULE_DESCRIPTION(\"RADOS Block Device (RBD) driver\");\nMODULE_LICENSE(\"GPL\");\n"}}, "reports": [{"events": [{"location": {"col": 16, "file": 0, "line": 795}, "message": "ERROR: invalid reference to the index variable of the iterator on line 785"}], "macros": [], "notes": [], "path": "/src/drivers/block/rbd.c", "reportHash": "f7ac54b59390499141ca3d0cf482a4b6", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
