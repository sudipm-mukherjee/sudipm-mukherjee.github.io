<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/fs/namei.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n *  linux/fs/namei.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n/*\n * Some corrections by tytso.\n */\n\n/* [Feb 1997 T. Schoebel-Theuer] Complete rewrite of the pathname\n * lookup logic.\n */\n/* [Feb-Apr 2000, AV] Rewrite to the new namespace architecture.\n */\n\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/personality.h>\n#include <linux/security.h>\n#include <linux/ima.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/device_cgroup.h>\n#include <linux/fs_struct.h>\n#include <linux/posix_acl.h>\n#include <linux/hash.h>\n#include <linux/bitops.h>\n#include <linux/init_task.h>\n#include <linux/uaccess.h>\n\n#include \"internal.h\"\n#include \"mount.h\"\n\n/* [Feb-1997 T. Schoebel-Theuer]\n * Fundamental changes in the pathname lookup mechanisms (namei)\n * were necessary because of omirr.  The reason is that omirr needs\n * to know the _real_ pathname, not the user-supplied one, in case\n * of symlinks (and also when transname replacements occur).\n *\n * The new code replaces the old recursive symlink resolution with\n * an iterative one (in case of non-nested symlink chains).  It does\n * this with calls to <fs>_follow_link().\n * As a side effect, dir_namei(), _namei() and follow_link() are now \n * replaced with a single function lookup_dentry() that can handle all \n * the special cases of the former code.\n *\n * With the new dcache, the pathname is stored at each inode, at least as\n * long as the refcount of the inode is positive.  As a side effect, the\n * size of the dcache depends on the inode cache and thus is dynamic.\n *\n * [29-Apr-1998 C. Scott Ananian] Updated above description of symlink\n * resolution to correspond with current state of the code.\n *\n * Note that the symlink resolution is not *completely* iterative.\n * There is still a significant amount of tail- and mid- recursion in\n * the algorithm.  Also, note that <fs>_readlink() is not used in\n * lookup_dentry(): lookup_dentry() on the result of <fs>_readlink()\n * may return different results than <fs>_follow_link().  Many virtual\n * filesystems (including /proc) exhibit this behavior.\n */\n\n/* [24-Feb-97 T. Schoebel-Theuer] Side effects caused by new implementation:\n * New symlink semantics: when open() is called with flags O_CREAT | O_EXCL\n * and the name already exists in form of a symlink, try to create the new\n * name indicated by the symlink. The old code always complained that the\n * name already exists, due to not following the symlink even if its target\n * is nonexistent.  The new semantics affects also mknod() and link() when\n * the name is a symlink pointing to a non-existent name.\n *\n * I don't know which semantics is the right one, since I have no access\n * to standards. But I found by trial that HP-UX 9.0 has the full \"new\"\n * semantics implemented, while SunOS 4.1.1 and Solaris (SunOS 5.4) have the\n * \"old\" one. Personally, I think the new semantics is much more logical.\n * Note that \"ln old new\" where \"new\" is a symlink pointing to a non-existing\n * file does succeed in both HP-UX and SunOs, but not in Solaris\n * and in the old Linux semantics.\n */\n\n/* [16-Dec-97 Kevin Buhr] For security reasons, we change some symlink\n * semantics.  See the comments in \"open_namei\" and \"do_link\" below.\n *\n * [10-Sep-98 Alan Modra] Another symlink change.\n */\n\n/* [Feb-Apr 2000 AV] Complete rewrite. Rules for symlinks:\n *\tinside the path - always follow.\n *\tin the last component in creation/removal/renaming - never follow.\n *\tif LOOKUP_FOLLOW passed - follow.\n *\tif the pathname has trailing slashes - follow.\n *\totherwise - don't follow.\n * (applied in that order).\n *\n * [Jun 2000 AV] Inconsistent behaviour of open() in case if flags==O_CREAT\n * restored for 2.4. This is the last surviving part of old 4.2BSD bug.\n * During the 2.4 we need to fix the userland stuff depending on it -\n * hopefully we will be able to get rid of that wart in 2.5. So far only\n * XEmacs seems to be relying on it...\n */\n/*\n * [Sep 2001 AV] Single-semaphore locking scheme (kudos to David Holland)\n * implemented.  Let's see if raised priority of ->s_vfs_rename_mutex gives\n * any extra contention...\n */\n\n/* In order to reduce some races, while at the same time doing additional\n * checking and hopefully speeding things up, we copy filenames to the\n * kernel data space before using them..\n *\n * POSIX.1 2.4: an empty pathname is invalid (ENOENT).\n * PATH_MAX includes the nul terminator --RR.\n */\n\n#define EMBEDDED_NAME_MAX\t(PATH_MAX - offsetof(struct filename, iname))\n\nstruct filename *\ngetname_flags(const char __user *filename, int flags, int *empty)\n{\n\tstruct filename *result;\n\tchar *kname;\n\tint len;\n\n\tresult = audit_reusename(filename);\n\tif (result)\n\t\treturn result;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/*\n\t * First, try to embed the struct filename inside the names_cache\n\t * allocation\n\t */\n\tkname = (char *)result->iname;\n\tresult->name = kname;\n\n\tlen = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX);\n\tif (unlikely(len < 0)) {\n\t\t__putname(result);\n\t\treturn ERR_PTR(len);\n\t}\n\n\t/*\n\t * Uh-oh. We have a name that's approaching PATH_MAX. Allocate a\n\t * separate struct filename so we can dedicate the entire\n\t * names_cache allocation for the pathname, and re-do the copy from\n\t * userland.\n\t */\n\tif (unlikely(len == EMBEDDED_NAME_MAX)) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tkname = (char *)result;\n\n\t\t/*\n\t\t * size is chosen that way we to guarantee that\n\t\t * result->iname[0] is within the same object and that\n\t\t * kname can't be equal to result->iname, no matter what.\n\t\t */\n\t\tresult = kzalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!result)) {\n\t\t\t__putname(kname);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tresult->name = kname;\n\t\tlen = strncpy_from_user(kname, filename, PATH_MAX);\n\t\tif (unlikely(len < 0)) {\n\t\t\t__putname(kname);\n\t\t\tkfree(result);\n\t\t\treturn ERR_PTR(len);\n\t\t}\n\t\tif (unlikely(len == PATH_MAX)) {\n\t\t\t__putname(kname);\n\t\t\tkfree(result);\n\t\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\t}\n\t}\n\n\tresult->refcnt = 1;\n\t/* The empty path is special. */\n\tif (unlikely(!len)) {\n\t\tif (empty)\n\t\t\t*empty = 1;\n\t\tif (!(flags & LOOKUP_EMPTY)) {\n\t\t\tputname(result);\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t}\n\n\tresult->uptr = filename;\n\tresult->aname = NULL;\n\taudit_getname(result);\n\treturn result;\n}\n\nstruct filename *\ngetname(const char __user * filename)\n{\n\treturn getname_flags(filename, 0, NULL);\n}\n\nstruct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)result->iname;\n\t} else if (len <= PATH_MAX) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->refcnt = 1;\n\taudit_getname(result);\n\n\treturn result;\n}\n\nvoid putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->name != name->iname) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}\n\nstatic int check_acl(struct inode *inode, int mask)\n{\n#ifdef CONFIG_FS_POSIX_ACL\n\tstruct posix_acl *acl;\n\n\tif (mask & MAY_NOT_BLOCK) {\n\t\tacl = get_cached_acl_rcu(inode, ACL_TYPE_ACCESS);\n\t        if (!acl)\n\t                return -EAGAIN;\n\t\t/* no ->get_acl() calls in RCU mode... */\n\t\tif (is_uncached_acl(acl))\n\t\t\treturn -ECHILD;\n\t        return posix_acl_permission(inode, acl, mask);\n\t}\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl) {\n\t        int error = posix_acl_permission(inode, acl, mask);\n\t        posix_acl_release(acl);\n\t        return error;\n\t}\n#endif\n\n\treturn -EAGAIN;\n}\n\n/*\n * This does the basic UNIX permission checking.\n *\n * Note that the POSIX ACL check cares about the MAY_NOT_BLOCK bit,\n * for RCU walking.\n */\nstatic int acl_permission_check(struct inode *inode, int mask)\n{\n\tunsigned int mode = inode->i_mode;\n\n\t/* Are we the owner? If so, ACL's don't matter */\n\tif (likely(uid_eq(current_fsuid(), inode->i_uid))) {\n\t\tmask &= 7;\n\t\tmode >>= 6;\n\t\treturn (mask & ~mode) ? -EACCES : 0;\n\t}\n\n\t/* Do we have ACL's? */\n\tif (IS_POSIXACL(inode) && (mode & S_IRWXG)) {\n\t\tint error = check_acl(inode, mask);\n\t\tif (error != -EAGAIN)\n\t\t\treturn error;\n\t}\n\n\t/* Only RWX matters for group/other mode bits */\n\tmask &= 7;\n\n\t/*\n\t * Are the group permissions different from\n\t * the other permissions in the bits we care\n\t * about? Need to check group ownership if so.\n\t */\n\tif (mask & (mode ^ (mode >> 3))) {\n\t\tif (in_group_p(inode->i_gid))\n\t\t\tmode >>= 3;\n\t}\n\n\t/* Bits in 'mode' clear that we require? */\n\treturn (mask & ~mode) ? -EACCES : 0;\n}\n\n/**\n * generic_permission -  check for access rights on a Posix-like filesystem\n * @inode:\tinode to check access rights for\n * @mask:\tright to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC,\n *\t\t%MAY_NOT_BLOCK ...)\n *\n * Used to check for read/write/execute permissions on a file.\n * We use \"fsuid\" for this, letting us set arbitrary permissions\n * for filesystem access without changing the \"normal\" uids which\n * are used for other things.\n *\n * generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk\n * request cannot be satisfied (eg. requires blocking or too much complexity).\n * It would then be called again in ref-walk mode.\n */\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}\nEXPORT_SYMBOL(generic_permission);\n\n/*\n * We _really_ want to just do \"generic_permission()\" without\n * even looking at the inode->i_op values. So we keep a cache\n * flag in inode->i_opflags, that says \"this has not special\n * permission function, use the fast case\".\n */\nstatic inline int do_inode_permission(struct inode *inode, int mask)\n{\n\tif (unlikely(!(inode->i_opflags & IOP_FASTPERM))) {\n\t\tif (likely(inode->i_op->permission))\n\t\t\treturn inode->i_op->permission(inode, mask);\n\n\t\t/* This gets set once for the inode lifetime */\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_opflags |= IOP_FASTPERM;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn generic_permission(inode, mask);\n}\n\n/**\n * sb_permission - Check superblock-level permissions\n * @sb: Superblock of inode to check permission on\n * @inode: Inode to check permission on\n * @mask: Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Separate out file-system wide checks from inode-specific permission checks.\n */\nstatic int sb_permission(struct super_block *sb, struct inode *inode, int mask)\n{\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\tumode_t mode = inode->i_mode;\n\n\t\t/* Nobody gets write access to a read-only fs. */\n\t\tif (sb_rdonly(sb) && (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))\n\t\t\treturn -EROFS;\n\t}\n\treturn 0;\n}\n\n/**\n * inode_permission - Check for access rights to a given inode\n * @inode: Inode to check permission on\n * @mask: Right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Check for read/write/execute permissions on an inode.  We use fs[ug]id for\n * this, letting us set arbitrary permissions for filesystem access without\n * changing the \"normal\" UIDs which are used for other things.\n *\n * When checking for MAY_APPEND, MAY_WRITE must also be set in @mask.\n */\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}\nEXPORT_SYMBOL(inode_permission);\n\n/**\n * path_get - get a reference to a path\n * @path: path to get the reference to\n *\n * Given a path increment the reference count to the dentry and the vfsmount.\n */\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}\nEXPORT_SYMBOL(path_get);\n\n/**\n * path_put - put a reference to a path\n * @path: path to put the reference to\n *\n * Given a path decrement the reference count to the dentry and the vfsmount.\n */\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}\nEXPORT_SYMBOL(path_put);\n\n#define EMBEDDED_LEVELS 2\nstruct nameidata {\n\tstruct path\tpath;\n\tstruct qstr\tlast;\n\tstruct path\troot;\n\tstruct inode\t*inode; /* path.dentry.d_inode */\n\tunsigned int\tflags;\n\tunsigned\tseq, m_seq, r_seq;\n\tint\t\tlast_type;\n\tunsigned\tdepth;\n\tint\t\ttotal_link_count;\n\tstruct saved {\n\t\tstruct path link;\n\t\tstruct delayed_call done;\n\t\tconst char *name;\n\t\tunsigned seq;\n\t} *stack, internal[EMBEDDED_LEVELS];\n\tstruct filename\t*name;\n\tstruct nameidata *saved;\n\tunsigned\troot_seq;\n\tint\t\tdfd;\n\tkuid_t\t\tdir_uid;\n\tumode_t\t\tdir_mode;\n} __randomize_layout;\n\nstatic void set_nameidata(struct nameidata *p, int dfd, struct filename *name)\n{\n\tstruct nameidata *old = current->nameidata;\n\tp->stack = p->internal;\n\tp->dfd = dfd;\n\tp->name = name;\n\tp->total_link_count = old ? old->total_link_count : 0;\n\tp->saved = old;\n\tcurrent->nameidata = p;\n}\n\nstatic void restore_nameidata(void)\n{\n\tstruct nameidata *now = current->nameidata, *old = now->saved;\n\n\tcurrent->nameidata = old;\n\tif (old)\n\t\told->total_link_count = now->total_link_count;\n\tif (now->stack != now->internal)\n\t\tkfree(now->stack);\n}\n\nstatic bool nd_alloc_stack(struct nameidata *nd)\n{\n\tstruct saved *p;\n\n\tp= kmalloc_array(MAXSYMLINKS, sizeof(struct saved),\n\t\t\t nd->flags & LOOKUP_RCU ? GFP_ATOMIC : GFP_KERNEL);\n\tif (unlikely(!p))\n\t\treturn false;\n\tmemcpy(p, nd->internal, sizeof(nd->internal));\n\tnd->stack = p;\n\treturn true;\n}\n\n/**\n * path_connected - Verify that a dentry is below mnt.mnt_root\n *\n * Rename can sometimes move a file or directory outside of a bind\n * mount, path_connected allows those cases to be detected.\n */\nstatic bool path_connected(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct super_block *sb = mnt->mnt_sb;\n\n\t/* Bind mounts can have disconnected paths */\n\tif (mnt->mnt_root == sb->s_root)\n\t\treturn true;\n\n\treturn is_subdir(dentry, mnt->mnt_root);\n}\n\nstatic void drop_links(struct nameidata *nd)\n{\n\tint i = nd->depth;\n\twhile (i--) {\n\t\tstruct saved *last = nd->stack + i;\n\t\tdo_delayed_call(&last->done);\n\t\tclear_delayed_call(&last->done);\n\t}\n}\n\nstatic void terminate_walk(struct nameidata *nd)\n{\n\tdrop_links(nd);\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\tint i;\n\t\tpath_put(&nd->path);\n\t\tfor (i = 0; i < nd->depth; i++)\n\t\t\tpath_put(&nd->stack[i].link);\n\t\tif (nd->flags & LOOKUP_ROOT_GRABBED) {\n\t\t\tpath_put(&nd->root);\n\t\t\tnd->flags &= ~LOOKUP_ROOT_GRABBED;\n\t\t}\n\t} else {\n\t\tnd->flags &= ~LOOKUP_RCU;\n\t\trcu_read_unlock();\n\t}\n\tnd->depth = 0;\n}\n\n/* path_put is needed afterwards regardless of success or failure */\nstatic bool __legitimize_path(struct path *path, unsigned seq, unsigned mseq)\n{\n\tint res = __legitimize_mnt(path->mnt, mseq);\n\tif (unlikely(res)) {\n\t\tif (res > 0)\n\t\t\tpath->mnt = NULL;\n\t\tpath->dentry = NULL;\n\t\treturn false;\n\t}\n\tif (unlikely(!lockref_get_not_dead(&path->dentry->d_lockref))) {\n\t\tpath->dentry = NULL;\n\t\treturn false;\n\t}\n\treturn !read_seqcount_retry(&path->dentry->d_seq, seq);\n}\n\nstatic inline bool legitimize_path(struct nameidata *nd,\n\t\t\t    struct path *path, unsigned seq)\n{\n\treturn __legitimize_path(path, seq, nd->m_seq);\n}\n\nstatic bool legitimize_links(struct nameidata *nd)\n{\n\tint i;\n\tfor (i = 0; i < nd->depth; i++) {\n\t\tstruct saved *last = nd->stack + i;\n\t\tif (unlikely(!legitimize_path(nd, &last->link, last->seq))) {\n\t\t\tdrop_links(nd);\n\t\t\tnd->depth = i + 1;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool legitimize_root(struct nameidata *nd)\n{\n\t/*\n\t * For scoped-lookups (where nd->root has been zeroed), we need to\n\t * restart the whole lookup from scratch -- because set_root() is wrong\n\t * for these lookups (nd->dfd is the root, not the filesystem root).\n\t */\n\tif (!nd->root.mnt && (nd->flags & LOOKUP_IS_SCOPED))\n\t\treturn false;\n\t/* Nothing to do if nd->root is zero or is managed by the VFS user. */\n\tif (!nd->root.mnt || (nd->flags & LOOKUP_ROOT))\n\t\treturn true;\n\tnd->flags |= LOOKUP_ROOT_GRABBED;\n\treturn legitimize_path(nd, &nd->root, nd->root_seq);\n}\n\n/*\n * Path walking has 2 modes, rcu-walk and ref-walk (see\n * Documentation/filesystems/path-lookup.txt).  In situations when we can't\n * continue in RCU mode, we attempt to drop out of rcu-walk mode and grab\n * normal reference counts on dentries and vfsmounts to transition to ref-walk\n * mode.  Refcounts are grabbed at the last known good point before rcu-walk\n * got stuck, so ref-walk may continue from there. If this is not successful\n * (eg. a seqcount has changed), then failure is returned and it's up to caller\n * to restart the path walk from the beginning in ref-walk mode.\n */\n\n/**\n * unlazy_walk - try to switch to ref-walk mode.\n * @nd: nameidata pathwalk data\n * Returns: 0 on success, -ECHILD on failure\n *\n * unlazy_walk attempts to legitimize the current nd->path and nd->root\n * for ref-walk mode.\n * Must be called from rcu-walk context.\n * Nothing should touch nameidata between unlazy_walk() failure and\n * terminate_walk().\n */\nstatic int unlazy_walk(struct nameidata *nd)\n{\n\tstruct dentry *parent = nd->path.dentry;\n\n\tBUG_ON(!(nd->flags & LOOKUP_RCU));\n\n\tnd->flags &= ~LOOKUP_RCU;\n\tif (unlikely(!legitimize_links(nd)))\n\t\tgoto out1;\n\tif (unlikely(!legitimize_path(nd, &nd->path, nd->seq)))\n\t\tgoto out;\n\tif (unlikely(!legitimize_root(nd)))\n\t\tgoto out;\n\trcu_read_unlock();\n\tBUG_ON(nd->inode != parent->d_inode);\n\treturn 0;\n\nout1:\n\tnd->path.mnt = NULL;\n\tnd->path.dentry = NULL;\nout:\n\trcu_read_unlock();\n\treturn -ECHILD;\n}\n\n/**\n * unlazy_child - try to switch to ref-walk mode.\n * @nd: nameidata pathwalk data\n * @dentry: child of nd->path.dentry\n * @seq: seq number to check dentry against\n * Returns: 0 on success, -ECHILD on failure\n *\n * unlazy_child attempts to legitimize the current nd->path, nd->root and dentry\n * for ref-walk mode.  @dentry must be a path found by a do_lookup call on\n * @nd.  Must be called from rcu-walk context.\n * Nothing should touch nameidata between unlazy_child() failure and\n * terminate_walk().\n */\nstatic int unlazy_child(struct nameidata *nd, struct dentry *dentry, unsigned seq)\n{\n\tBUG_ON(!(nd->flags & LOOKUP_RCU));\n\n\tnd->flags &= ~LOOKUP_RCU;\n\tif (unlikely(!legitimize_links(nd)))\n\t\tgoto out2;\n\tif (unlikely(!legitimize_mnt(nd->path.mnt, nd->m_seq)))\n\t\tgoto out2;\n\tif (unlikely(!lockref_get_not_dead(&nd->path.dentry->d_lockref)))\n\t\tgoto out1;\n\n\t/*\n\t * We need to move both the parent and the dentry from the RCU domain\n\t * to be properly refcounted. And the sequence number in the dentry\n\t * validates *both* dentry counters, since we checked the sequence\n\t * number of the parent after we got the child sequence number. So we\n\t * know the parent must still be valid if the child sequence number is\n\t */\n\tif (unlikely(!lockref_get_not_dead(&dentry->d_lockref)))\n\t\tgoto out;\n\tif (unlikely(read_seqcount_retry(&dentry->d_seq, seq)))\n\t\tgoto out_dput;\n\t/*\n\t * Sequence counts matched. Now make sure that the root is\n\t * still valid and get it if required.\n\t */\n\tif (unlikely(!legitimize_root(nd)))\n\t\tgoto out_dput;\n\trcu_read_unlock();\n\treturn 0;\n\nout2:\n\tnd->path.mnt = NULL;\nout1:\n\tnd->path.dentry = NULL;\nout:\n\trcu_read_unlock();\n\treturn -ECHILD;\nout_dput:\n\trcu_read_unlock();\n\tdput(dentry);\n\treturn -ECHILD;\n}\n\nstatic inline int d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tif (unlikely(dentry->d_flags & DCACHE_OP_REVALIDATE))\n\t\treturn dentry->d_op->d_revalidate(dentry, flags);\n\telse\n\t\treturn 1;\n}\n\n/**\n * complete_walk - successful completion of path walk\n * @nd:  pointer nameidata\n *\n * If we had been in RCU mode, drop out of it and legitimize nd->path.\n * Revalidate the final result, unless we'd already done that during\n * the path walk or the filesystem doesn't ask for it.  Return 0 on\n * success, -error on failure.  In case of failure caller does not\n * need to drop nd->path.\n */\nstatic int complete_walk(struct nameidata *nd)\n{\n\tstruct dentry *dentry = nd->path.dentry;\n\tint status;\n\n\tif (nd->flags & LOOKUP_RCU) {\n\t\t/*\n\t\t * We don't want to zero nd->root for scoped-lookups or\n\t\t * externally-managed nd->root.\n\t\t */\n\t\tif (!(nd->flags & (LOOKUP_ROOT | LOOKUP_IS_SCOPED)))\n\t\t\tnd->root.mnt = NULL;\n\t\tif (unlikely(unlazy_walk(nd)))\n\t\t\treturn -ECHILD;\n\t}\n\n\tif (unlikely(nd->flags & LOOKUP_IS_SCOPED)) {\n\t\t/*\n\t\t * While the guarantee of LOOKUP_IS_SCOPED is (roughly) \"don't\n\t\t * ever step outside the root during lookup\" and should already\n\t\t * be guaranteed by the rest of namei, we want to avoid a namei\n\t\t * BUG resulting in userspace being given a path that was not\n\t\t * scoped within the root at some point during the lookup.\n\t\t *\n\t\t * So, do a final sanity-check to make sure that in the\n\t\t * worst-case scenario (a complete bypass of LOOKUP_IS_SCOPED)\n\t\t * we won't silently return an fd completely outside of the\n\t\t * requested root to userspace.\n\t\t *\n\t\t * Userspace could move the path outside the root after this\n\t\t * check, but as discussed elsewhere this is not a concern (the\n\t\t * resolved file was inside the root at some point).\n\t\t */\n\t\tif (!path_is_under(&nd->path, &nd->root))\n\t\t\treturn -EXDEV;\n\t}\n\n\tif (likely(!(nd->flags & LOOKUP_JUMPED)))\n\t\treturn 0;\n\n\tif (likely(!(dentry->d_flags & DCACHE_OP_WEAK_REVALIDATE)))\n\t\treturn 0;\n\n\tstatus = dentry->d_op->d_weak_revalidate(dentry, nd->flags);\n\tif (status > 0)\n\t\treturn 0;\n\n\tif (!status)\n\t\tstatus = -ESTALE;\n\n\treturn status;\n}\n\nstatic int set_root(struct nameidata *nd)\n{\n\tstruct fs_struct *fs = current->fs;\n\n\t/*\n\t * Jumping to the real root in a scoped-lookup is a BUG in namei, but we\n\t * still have to ensure it doesn't happen because it will cause a breakout\n\t * from the dirfd.\n\t */\n\tif (WARN_ON(nd->flags & LOOKUP_IS_SCOPED))\n\t\treturn -ENOTRECOVERABLE;\n\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tunsigned seq;\n\n\t\tdo {\n\t\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t\tnd->root = fs->root;\n\t\t\tnd->root_seq = __read_seqcount_begin(&nd->root.dentry->d_seq);\n\t\t} while (read_seqcount_retry(&fs->seq, seq));\n\t} else {\n\t\tget_fs_root(fs, &nd->root);\n\t\tnd->flags |= LOOKUP_ROOT_GRABBED;\n\t}\n\treturn 0;\n}\n\nstatic int nd_jump_root(struct nameidata *nd)\n{\n\tif (unlikely(nd->flags & LOOKUP_BENEATH))\n\t\treturn -EXDEV;\n\tif (unlikely(nd->flags & LOOKUP_NO_XDEV)) {\n\t\t/* Absolute path arguments to path_init() are allowed. */\n\t\tif (nd->path.mnt != NULL && nd->path.mnt != nd->root.mnt)\n\t\t\treturn -EXDEV;\n\t}\n\tif (!nd->root.mnt) {\n\t\tint error = set_root(nd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tstruct dentry *d;\n\t\tnd->path = nd->root;\n\t\td = nd->path.dentry;\n\t\tnd->inode = d->d_inode;\n\t\tnd->seq = nd->root_seq;\n\t\tif (unlikely(read_seqcount_retry(&d->d_seq, nd->seq)))\n\t\t\treturn -ECHILD;\n\t} else {\n\t\tpath_put(&nd->path);\n\t\tnd->path = nd->root;\n\t\tpath_get(&nd->path);\n\t\tnd->inode = nd->path.dentry->d_inode;\n\t}\n\tnd->flags |= LOOKUP_JUMPED;\n\treturn 0;\n}\n\n/*\n * Helper to directly jump to a known parsed path from ->get_link,\n * caller must have taken a reference to path beforehand.\n */\nint nd_jump_link(struct path *path)\n{\n\tint error = -ELOOP;\n\tstruct nameidata *nd = current->nameidata;\n\n\tif (unlikely(nd->flags & LOOKUP_NO_MAGICLINKS))\n\t\tgoto err;\n\n\terror = -EXDEV;\n\tif (unlikely(nd->flags & LOOKUP_NO_XDEV)) {\n\t\tif (nd->path.mnt != path->mnt)\n\t\t\tgoto err;\n\t}\n\t/* Not currently safe for scoped-lookups. */\n\tif (unlikely(nd->flags & LOOKUP_IS_SCOPED))\n\t\tgoto err;\n\n\tpath_put(&nd->path);\n\tnd->path = *path;\n\tnd->inode = nd->path.dentry->d_inode;\n\tnd->flags |= LOOKUP_JUMPED;\n\treturn 0;\n\nerr:\n\tpath_put(path);\n\treturn error;\n}\n\nstatic inline void put_link(struct nameidata *nd)\n{\n\tstruct saved *last = nd->stack + --nd->depth;\n\tdo_delayed_call(&last->done);\n\tif (!(nd->flags & LOOKUP_RCU))\n\t\tpath_put(&last->link);\n}\n\nint sysctl_protected_symlinks __read_mostly = 0;\nint sysctl_protected_hardlinks __read_mostly = 0;\nint sysctl_protected_fifos __read_mostly;\nint sysctl_protected_regular __read_mostly;\n\n/**\n * may_follow_link - Check symlink following for unsafe situations\n * @nd: nameidata pathwalk data\n *\n * In the case of the sysctl_protected_symlinks sysctl being enabled,\n * CAP_DAC_OVERRIDE needs to be specifically ignored if the symlink is\n * in a sticky world-writable directory. This is to protect privileged\n * processes from failing races against path names that may change out\n * from under them by way of other users creating malicious symlinks.\n * It will permit symlinks to be followed only when outside a sticky\n * world-writable directory, or when the uid of the symlink and follower\n * match, or when the directory owner matches the symlink's owner.\n *\n * Returns 0 if following the symlink is allowed, -ve on error.\n */\nstatic inline int may_follow_link(struct nameidata *nd, const struct inode *inode)\n{\n\tif (!sysctl_protected_symlinks)\n\t\treturn 0;\n\n\t/* Allowed if owner and follower match. */\n\tif (uid_eq(current_cred()->fsuid, inode->i_uid))\n\t\treturn 0;\n\n\t/* Allowed if parent directory not sticky and world-writable. */\n\tif ((nd->dir_mode & (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH))\n\t\treturn 0;\n\n\t/* Allowed if parent directory and link owner match. */\n\tif (uid_valid(nd->dir_uid) && uid_eq(nd->dir_uid, inode->i_uid))\n\t\treturn 0;\n\n\tif (nd->flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\taudit_inode(nd->name, nd->stack[0].link.dentry, 0);\n\taudit_log_path_denied(AUDIT_ANOM_LINK, \"follow_link\");\n\treturn -EACCES;\n}\n\n/**\n * safe_hardlink_source - Check for safe hardlink conditions\n * @inode: the source inode to hardlink from\n *\n * Return false if at least one of the following conditions:\n *    - inode is not a regular file\n *    - inode is setuid\n *    - inode is setgid and group-exec\n *    - access failure for read and write\n *\n * Otherwise returns true.\n */\nstatic bool safe_hardlink_source(struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\n\t/* Special files should not get pinned to the filesystem. */\n\tif (!S_ISREG(mode))\n\t\treturn false;\n\n\t/* Setuid files should not get pinned to the filesystem. */\n\tif (mode & S_ISUID)\n\t\treturn false;\n\n\t/* Executable setgid files should not get pinned to the filesystem. */\n\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))\n\t\treturn false;\n\n\t/* Hardlinking to unreadable or unwritable sources is dangerous. */\n\tif (inode_permission(inode, MAY_READ | MAY_WRITE))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * may_linkat - Check permissions for creating a hardlink\n * @link: the source to hardlink from\n *\n * Block hardlink when all of:\n *  - sysctl_protected_hardlinks enabled\n *  - fsuid does not match inode\n *  - hardlink source is unsafe (see safe_hardlink_source() above)\n *  - not CAP_FOWNER in a namespace with the inode owner uid mapped\n *\n * Returns 0 if successful, -ve on error.\n */\nint may_linkat(struct path *link)\n{\n\tstruct inode *inode = link->dentry->d_inode;\n\n\t/* Inode writeback is not safe when the uid or gid are invalid. */\n\tif (!uid_valid(inode->i_uid) || !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\tif (!sysctl_protected_hardlinks)\n\t\treturn 0;\n\n\t/* Source inode owner (or CAP_FOWNER) can hardlink all they like,\n\t * otherwise, it must be a safe source.\n\t */\n\tif (safe_hardlink_source(inode) || inode_owner_or_capable(inode))\n\t\treturn 0;\n\n\taudit_log_path_denied(AUDIT_ANOM_LINK, \"linkat\");\n\treturn -EPERM;\n}\n\n/**\n * may_create_in_sticky - Check whether an O_CREAT open in a sticky directory\n *\t\t\t  should be allowed, or not, on files that already\n *\t\t\t  exist.\n * @dir_mode: mode bits of directory\n * @dir_uid: owner of directory\n * @inode: the inode of the file to open\n *\n * Block an O_CREAT open of a FIFO (or a regular file) when:\n *   - sysctl_protected_fifos (or sysctl_protected_regular) is enabled\n *   - the file already exists\n *   - we are in a sticky directory\n *   - we don't own the file\n *   - the owner of the directory doesn't own the file\n *   - the directory is world writable\n * If the sysctl_protected_fifos (or sysctl_protected_regular) is set to 2\n * the directory doesn't have to be world writable: being group writable will\n * be enough.\n *\n * Returns 0 if the open is allowed, -ve on error.\n */\nstatic int may_create_in_sticky(umode_t dir_mode, kuid_t dir_uid,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\n\tif (likely(dir_mode & 0002) ||\n\t    (dir_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}\n\n/*\n * follow_up - Find the mountpoint of path's vfsmount\n *\n * Given a path, find the mountpoint of its source file system.\n * Replace @path with the path of the mountpoint in the parent mount.\n * Up is towards /.\n *\n * Return 1 if we went up a level and 0 if we were already at the\n * root.\n */\nint follow_up(struct path *path)\n{\n\tstruct mount *mnt = real_mount(path->mnt);\n\tstruct mount *parent;\n\tstruct dentry *mountpoint;\n\n\tread_seqlock_excl(&mount_lock);\n\tparent = mnt->mnt_parent;\n\tif (parent == mnt) {\n\t\tread_sequnlock_excl(&mount_lock);\n\t\treturn 0;\n\t}\n\tmntget(&parent->mnt);\n\tmountpoint = dget(mnt->mnt_mountpoint);\n\tread_sequnlock_excl(&mount_lock);\n\tdput(path->dentry);\n\tpath->dentry = mountpoint;\n\tmntput(path->mnt);\n\tpath->mnt = &parent->mnt;\n\treturn 1;\n}\nEXPORT_SYMBOL(follow_up);\n\nstatic bool choose_mountpoint_rcu(struct mount *m, const struct path *root,\n\t\t\t\t  struct path *path, unsigned *seqp)\n{\n\twhile (mnt_has_parent(m)) {\n\t\tstruct dentry *mountpoint = m->mnt_mountpoint;\n\n\t\tm = m->mnt_parent;\n\t\tif (unlikely(root->dentry == mountpoint &&\n\t\t\t     root->mnt == &m->mnt))\n\t\t\tbreak;\n\t\tif (mountpoint != m->mnt.mnt_root) {\n\t\t\tpath->mnt = &m->mnt;\n\t\t\tpath->dentry = mountpoint;\n\t\t\t*seqp = read_seqcount_begin(&mountpoint->d_seq);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool choose_mountpoint(struct mount *m, const struct path *root,\n\t\t\t      struct path *path)\n{\n\tbool found;\n\n\trcu_read_lock();\n\twhile (1) {\n\t\tunsigned seq, mseq = read_seqbegin(&mount_lock);\n\n\t\tfound = choose_mountpoint_rcu(m, root, path, &seq);\n\t\tif (unlikely(!found)) {\n\t\t\tif (!read_seqretry(&mount_lock, mseq))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (likely(__legitimize_path(path, seq, mseq)))\n\t\t\t\tbreak;\n\t\t\trcu_read_unlock();\n\t\t\tpath_put(path);\n\t\t\trcu_read_lock();\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn found;\n}\n\n/*\n * Perform an automount\n * - return -EISDIR to tell follow_managed() to stop and return the path we\n *   were called with.\n */\nstatic int follow_automount(struct path *path, int *count, unsigned lookup_flags)\n{\n\tstruct dentry *dentry = path->dentry;\n\n\t/* We don't want to mount if someone's just doing a stat -\n\t * unless they're stat'ing a directory and appended a '/' to\n\t * the name.\n\t *\n\t * We do, however, want to mount if someone wants to open or\n\t * create a file of any type under the mountpoint, wants to\n\t * traverse through the mountpoint or wants to open the\n\t * mounted directory.  Also, autofs may mark negative dentries\n\t * as being automount points.  These will need the attentions\n\t * of the daemon to instantiate them before they can be used.\n\t */\n\tif (!(lookup_flags & (LOOKUP_PARENT | LOOKUP_DIRECTORY |\n\t\t\t   LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_AUTOMOUNT)) &&\n\t    dentry->d_inode)\n\t\treturn -EISDIR;\n\n\tif (count && (*count)++ >= MAXSYMLINKS)\n\t\treturn -ELOOP;\n\n\treturn finish_automount(dentry->d_op->d_automount(path), path);\n}\n\n/*\n * mount traversal - out-of-line part.  One note on ->d_flags accesses -\n * dentries are pinned but not locked here, so negative dentry can go\n * positive right under us.  Use of smp_load_acquire() provides a barrier\n * sufficient for ->d_inode and ->d_flags consistency.\n */\nstatic int __traverse_mounts(struct path *path, unsigned flags, bool *jumped,\n\t\t\t     int *count, unsigned lookup_flags)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tbool need_mntput = false;\n\tint ret = 0;\n\n\twhile (flags & DCACHE_MANAGED_DENTRY) {\n\t\t/* Allow the filesystem to manage the transit without i_mutex\n\t\t * being held. */\n\t\tif (flags & DCACHE_MANAGE_TRANSIT) {\n\t\t\tret = path->dentry->d_op->d_manage(path, false);\n\t\t\tflags = smp_load_acquire(&path->dentry->d_flags);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (flags & DCACHE_MOUNTED) {\t// something's mounted on it..\n\t\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\t\tif (mounted) {\t\t// ... in our namespace\n\t\t\t\tdput(path->dentry);\n\t\t\t\tif (need_mntput)\n\t\t\t\t\tmntput(path->mnt);\n\t\t\t\tpath->mnt = mounted;\n\t\t\t\tpath->dentry = dget(mounted->mnt_root);\n\t\t\t\t// here we know it's positive\n\t\t\t\tflags = path->dentry->d_flags;\n\t\t\t\tneed_mntput = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!(flags & DCACHE_NEED_AUTOMOUNT))\n\t\t\tbreak;\n\n\t\t// uncovered automount point\n\t\tret = follow_automount(path, count, lookup_flags);\n\t\tflags = smp_load_acquire(&path->dentry->d_flags);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (ret == -EISDIR)\n\t\tret = 0;\n\t// possible if you race with several mount --move\n\tif (need_mntput && path->mnt == mnt)\n\t\tmntput(path->mnt);\n\tif (!ret && unlikely(d_flags_negative(flags)))\n\t\tret = -ENOENT;\n\t*jumped = need_mntput;\n\treturn ret;\n}\n\nstatic inline int traverse_mounts(struct path *path, bool *jumped,\n\t\t\t\t  int *count, unsigned lookup_flags)\n{\n\tunsigned flags = smp_load_acquire(&path->dentry->d_flags);\n\n\t/* fastpath */\n\tif (likely(!(flags & DCACHE_MANAGED_DENTRY))) {\n\t\t*jumped = false;\n\t\tif (unlikely(d_flags_negative(flags)))\n\t\t\treturn -ENOENT;\n\t\treturn 0;\n\t}\n\treturn __traverse_mounts(path, flags, jumped, count, lookup_flags);\n}\n\nint follow_down_one(struct path *path)\n{\n\tstruct vfsmount *mounted;\n\n\tmounted = lookup_mnt(path);\n\tif (mounted) {\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(follow_down_one);\n\n/*\n * Follow down to the covering mount currently visible to userspace.  At each\n * point, the filesystem owning that dentry may be queried as to whether the\n * caller is permitted to proceed or not.\n */\nint follow_down(struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tbool jumped;\n\tint ret = traverse_mounts(path, &jumped, NULL, 0);\n\n\tif (path->mnt != mnt)\n\t\tmntput(mnt);\n\treturn ret;\n}\nEXPORT_SYMBOL(follow_down);\n\n/*\n * Try to skip to top of mountpoint pile in rcuwalk mode.  Fail if\n * we meet a managed dentry that would need blocking.\n */\nstatic bool __follow_mount_rcu(struct nameidata *nd, struct path *path,\n\t\t\t       struct inode **inode, unsigned *seqp)\n{\n\tstruct dentry *dentry = path->dentry;\n\tunsigned int flags = dentry->d_flags;\n\n\tif (likely(!(flags & DCACHE_MANAGED_DENTRY)))\n\t\treturn true;\n\n\tif (unlikely(nd->flags & LOOKUP_NO_XDEV))\n\t\treturn false;\n\n\tfor (;;) {\n\t\t/*\n\t\t * Don't forget we might have a non-mountpoint managed dentry\n\t\t * that wants to block transit.\n\t\t */\n\t\tif (unlikely(flags & DCACHE_MANAGE_TRANSIT)) {\n\t\t\tint res = dentry->d_op->d_manage(path, true);\n\t\t\tif (res)\n\t\t\t\treturn res == -EISDIR;\n\t\t\tflags = dentry->d_flags;\n\t\t}\n\n\t\tif (flags & DCACHE_MOUNTED) {\n\t\t\tstruct mount *mounted = __lookup_mnt(path->mnt, dentry);\n\t\t\tif (mounted) {\n\t\t\t\tpath->mnt = &mounted->mnt;\n\t\t\t\tdentry = path->dentry = mounted->mnt.mnt_root;\n\t\t\t\tnd->flags |= LOOKUP_JUMPED;\n\t\t\t\t*seqp = read_seqcount_begin(&dentry->d_seq);\n\t\t\t\t*inode = dentry->d_inode;\n\t\t\t\t/*\n\t\t\t\t * We don't need to re-check ->d_seq after this\n\t\t\t\t * ->d_inode read - there will be an RCU delay\n\t\t\t\t * between mount hash removal and ->mnt_root\n\t\t\t\t * becoming unpinned.\n\t\t\t\t */\n\t\t\t\tflags = dentry->d_flags;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (read_seqretry(&mount_lock, nd->m_seq))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn !(flags & DCACHE_NEED_AUTOMOUNT);\n\t}\n}\n\nstatic inline int handle_mounts(struct nameidata *nd, struct dentry *dentry,\n\t\t\t  struct path *path, struct inode **inode,\n\t\t\t  unsigned int *seqp)\n{\n\tbool jumped;\n\tint ret;\n\n\tpath->mnt = nd->path.mnt;\n\tpath->dentry = dentry;\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tunsigned int seq = *seqp;\n\t\tif (unlikely(!*inode))\n\t\t\treturn -ENOENT;\n\t\tif (likely(__follow_mount_rcu(nd, path, inode, seqp)))\n\t\t\treturn 0;\n\t\tif (unlazy_child(nd, dentry, seq))\n\t\t\treturn -ECHILD;\n\t\t// *path might've been clobbered by __follow_mount_rcu()\n\t\tpath->mnt = nd->path.mnt;\n\t\tpath->dentry = dentry;\n\t}\n\tret = traverse_mounts(path, &jumped, &nd->total_link_count, nd->flags);\n\tif (jumped) {\n\t\tif (unlikely(nd->flags & LOOKUP_NO_XDEV))\n\t\t\tret = -EXDEV;\n\t\telse\n\t\t\tnd->flags |= LOOKUP_JUMPED;\n\t}\n\tif (unlikely(ret)) {\n\t\tdput(path->dentry);\n\t\tif (path->mnt != nd->path.mnt)\n\t\t\tmntput(path->mnt);\n\t} else {\n\t\t*inode = d_backing_inode(path->dentry);\n\t\t*seqp = 0; /* out of RCU mode, so the value doesn't matter */\n\t}\n\treturn ret;\n}\n\n/*\n * This looks up the name in dcache and possibly revalidates the found dentry.\n * NULL is returned if the dentry does not exist in the cache.\n */\nstatic struct dentry *lookup_dcache(const struct qstr *name,\n\t\t\t\t    struct dentry *dir,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct dentry *dentry = d_lookup(dir, name);\n\tif (dentry) {\n\t\tint error = d_revalidate(dentry, flags);\n\t\tif (unlikely(error <= 0)) {\n\t\t\tif (!error)\n\t\t\t\td_invalidate(dentry);\n\t\t\tdput(dentry);\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\t}\n\treturn dentry;\n}\n\n/*\n * Parent directory has inode locked exclusive.  This is one\n * and only case when ->lookup() gets called on non in-lookup\n * dentries - as the matter of fact, this only gets called\n * when directory is guaranteed to have no in-lookup children\n * at all.\n */\nstatic struct dentry *__lookup_hash(const struct qstr *name,\n\t\tstruct dentry *base, unsigned int flags)\n{\n\tstruct dentry *dentry = lookup_dcache(name, base, flags);\n\tstruct dentry *old;\n\tstruct inode *dir = base->d_inode;\n\n\tif (dentry)\n\t\treturn dentry;\n\n\t/* Don't create child dentry for a dead directory. */\n\tif (unlikely(IS_DEADDIR(dir)))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdentry = d_alloc(base, name);\n\tif (unlikely(!dentry))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\told = dir->i_op->lookup(dir, dentry, flags);\n\tif (unlikely(old)) {\n\t\tdput(dentry);\n\t\tdentry = old;\n\t}\n\treturn dentry;\n}\n\nstatic struct dentry *lookup_fast(struct nameidata *nd,\n\t\t\t\t  struct inode **inode,\n\t\t\t          unsigned *seqp)\n{\n\tstruct dentry *dentry, *parent = nd->path.dentry;\n\tint status = 1;\n\n\t/*\n\t * Rename seqlock is not required here because in the off chance\n\t * of a false negative due to a concurrent rename, the caller is\n\t * going to fall back to non-racy lookup.\n\t */\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tunsigned seq;\n\t\tdentry = __d_lookup_rcu(parent, &nd->last, &seq);\n\t\tif (unlikely(!dentry)) {\n\t\t\tif (unlazy_walk(nd))\n\t\t\t\treturn ERR_PTR(-ECHILD);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t * This sequence count validates that the inode matches\n\t\t * the dentry name information from lookup.\n\t\t */\n\t\t*inode = d_backing_inode(dentry);\n\t\tif (unlikely(read_seqcount_retry(&dentry->d_seq, seq)))\n\t\t\treturn ERR_PTR(-ECHILD);\n\n\t\t/*\n\t\t * This sequence count validates that the parent had no\n\t\t * changes while we did the lookup of the dentry above.\n\t\t *\n\t\t * The memory barrier in read_seqcount_begin of child is\n\t\t *  enough, we can use __read_seqcount_retry here.\n\t\t */\n\t\tif (unlikely(__read_seqcount_retry(&parent->d_seq, nd->seq)))\n\t\t\treturn ERR_PTR(-ECHILD);\n\n\t\t*seqp = seq;\n\t\tstatus = d_revalidate(dentry, nd->flags);\n\t\tif (likely(status > 0))\n\t\t\treturn dentry;\n\t\tif (unlazy_child(nd, dentry, seq))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\tif (unlikely(status == -ECHILD))\n\t\t\t/* we'd been told to redo it in non-rcu mode */\n\t\t\tstatus = d_revalidate(dentry, nd->flags);\n\t} else {\n\t\tdentry = __d_lookup(parent, &nd->last);\n\t\tif (unlikely(!dentry))\n\t\t\treturn NULL;\n\t\tstatus = d_revalidate(dentry, nd->flags);\n\t}\n\tif (unlikely(status <= 0)) {\n\t\tif (!status)\n\t\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t\treturn ERR_PTR(status);\n\t}\n\treturn dentry;\n}\n\n/* Fast lookup failed, do it the slow way */\nstatic struct dentry *__lookup_slow(const struct qstr *name,\n\t\t\t\t    struct dentry *dir,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct dentry *dentry, *old;\n\tstruct inode *inode = dir->d_inode;\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\n\t/* Don't go there if it's already dead */\n\tif (unlikely(IS_DEADDIR(inode)))\n\t\treturn ERR_PTR(-ENOENT);\nagain:\n\tdentry = d_alloc_parallel(dir, name, &wq);\n\tif (IS_ERR(dentry))\n\t\treturn dentry;\n\tif (unlikely(!d_in_lookup(dentry))) {\n\t\tint error = d_revalidate(dentry, flags);\n\t\tif (unlikely(error <= 0)) {\n\t\t\tif (!error) {\n\t\t\t\td_invalidate(dentry);\n\t\t\t\tdput(dentry);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tdput(dentry);\n\t\t\tdentry = ERR_PTR(error);\n\t\t}\n\t} else {\n\t\told = inode->i_op->lookup(inode, dentry, flags);\n\t\td_lookup_done(dentry);\n\t\tif (unlikely(old)) {\n\t\t\tdput(dentry);\n\t\t\tdentry = old;\n\t\t}\n\t}\n\treturn dentry;\n}\n\nstatic struct dentry *lookup_slow(const struct qstr *name,\n\t\t\t\t  struct dentry *dir,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct inode *inode = dir->d_inode;\n\tstruct dentry *res;\n\tinode_lock_shared(inode);\n\tres = __lookup_slow(name, dir, flags);\n\tinode_unlock_shared(inode);\n\treturn res;\n}\n\nstatic inline int may_lookup(struct nameidata *nd)\n{\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tint err = inode_permission(nd->inode, MAY_EXEC|MAY_NOT_BLOCK);\n\t\tif (err != -ECHILD)\n\t\t\treturn err;\n\t\tif (unlazy_walk(nd))\n\t\t\treturn -ECHILD;\n\t}\n\treturn inode_permission(nd->inode, MAY_EXEC);\n}\n\nstatic int reserve_stack(struct nameidata *nd, struct path *link, unsigned seq)\n{\n\tif (unlikely(nd->total_link_count++ >= MAXSYMLINKS))\n\t\treturn -ELOOP;\n\n\tif (likely(nd->depth != EMBEDDED_LEVELS))\n\t\treturn 0;\n\tif (likely(nd->stack != nd->internal))\n\t\treturn 0;\n\tif (likely(nd_alloc_stack(nd)))\n\t\treturn 0;\n\n\tif (nd->flags & LOOKUP_RCU) {\n\t\t// we need to grab link before we do unlazy.  And we can't skip\n\t\t// unlazy even if we fail to grab the link - cleanup needs it\n\t\tbool grabbed_link = legitimize_path(nd, link, seq);\n\n\t\tif (unlazy_walk(nd) != 0 || !grabbed_link)\n\t\t\treturn -ECHILD;\n\n\t\tif (nd_alloc_stack(nd))\n\t\t\treturn 0;\n\t}\n\treturn -ENOMEM;\n}\n\nenum {WALK_TRAILING = 1, WALK_MORE = 2, WALK_NOFOLLOW = 4};\n\nstatic const char *pick_link(struct nameidata *nd, struct path *link,\n\t\t     struct inode *inode, unsigned seq, int flags)\n{\n\tstruct saved *last;\n\tconst char *res;\n\tint error = reserve_stack(nd, link, seq);\n\n\tif (unlikely(error)) {\n\t\tif (!(nd->flags & LOOKUP_RCU))\n\t\t\tpath_put(link);\n\t\treturn ERR_PTR(error);\n\t}\n\tlast = nd->stack + nd->depth++;\n\tlast->link = *link;\n\tclear_delayed_call(&last->done);\n\tlast->seq = seq;\n\n\tif (flags & WALK_TRAILING) {\n\t\terror = may_follow_link(nd, inode);\n\t\tif (unlikely(error))\n\t\t\treturn ERR_PTR(error);\n\t}\n\n\tif (unlikely(nd->flags & LOOKUP_NO_SYMLINKS) ||\n\t\t\tunlikely(link->mnt->mnt_flags & MNT_NOSYMFOLLOW))\n\t\treturn ERR_PTR(-ELOOP);\n\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\ttouch_atime(&last->link);\n\t\tcond_resched();\n\t} else if (atime_needs_update(&last->link, inode)) {\n\t\tif (unlikely(unlazy_walk(nd)))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\ttouch_atime(&last->link);\n\t}\n\n\terror = security_inode_follow_link(link->dentry, inode,\n\t\t\t\t\t   nd->flags & LOOKUP_RCU);\n\tif (unlikely(error))\n\t\treturn ERR_PTR(error);\n\n\tres = READ_ONCE(inode->i_link);\n\tif (!res) {\n\t\tconst char * (*get)(struct dentry *, struct inode *,\n\t\t\t\tstruct delayed_call *);\n\t\tget = inode->i_op->get_link;\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\tres = get(NULL, inode, &last->done);\n\t\t\tif (res == ERR_PTR(-ECHILD)) {\n\t\t\t\tif (unlikely(unlazy_walk(nd)))\n\t\t\t\t\treturn ERR_PTR(-ECHILD);\n\t\t\t\tres = get(link->dentry, inode, &last->done);\n\t\t\t}\n\t\t} else {\n\t\t\tres = get(link->dentry, inode, &last->done);\n\t\t}\n\t\tif (!res)\n\t\t\tgoto all_done;\n\t\tif (IS_ERR(res))\n\t\t\treturn res;\n\t}\n\tif (*res == '/') {\n\t\terror = nd_jump_root(nd);\n\t\tif (unlikely(error))\n\t\t\treturn ERR_PTR(error);\n\t\twhile (unlikely(*++res == '/'))\n\t\t\t;\n\t}\n\tif (*res)\n\t\treturn res;\nall_done: // pure jump\n\tput_link(nd);\n\treturn NULL;\n}\n\n/*\n * Do we need to follow links? We _really_ want to be able\n * to do this check without having to look at inode->i_op,\n * so we keep a cache of \"no, this doesn't need follow_link\"\n * for the common case.\n */\nstatic const char *step_into(struct nameidata *nd, int flags,\n\t\t     struct dentry *dentry, struct inode *inode, unsigned seq)\n{\n\tstruct path path;\n\tint err = handle_mounts(nd, dentry, &path, &inode, &seq);\n\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\tif (likely(!d_is_symlink(path.dentry)) ||\n\t   ((flags & WALK_TRAILING) && !(nd->flags & LOOKUP_FOLLOW)) ||\n\t   (flags & WALK_NOFOLLOW)) {\n\t\t/* not a symlink or should not follow */\n\t\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\t\tdput(nd->path.dentry);\n\t\t\tif (nd->path.mnt != path.mnt)\n\t\t\t\tmntput(nd->path.mnt);\n\t\t}\n\t\tnd->path = path;\n\t\tnd->inode = inode;\n\t\tnd->seq = seq;\n\t\treturn NULL;\n\t}\n\tif (nd->flags & LOOKUP_RCU) {\n\t\t/* make sure that d_is_symlink above matches inode */\n\t\tif (read_seqcount_retry(&path.dentry->d_seq, seq))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t} else {\n\t\tif (path.mnt == nd->path.mnt)\n\t\t\tmntget(path.mnt);\n\t}\n\treturn pick_link(nd, &path, inode, seq, flags);\n}\n\nstatic struct dentry *follow_dotdot_rcu(struct nameidata *nd,\n\t\t\t\t\tstruct inode **inodep,\n\t\t\t\t\tunsigned *seqp)\n{\n\tstruct dentry *parent, *old;\n\n\tif (path_equal(&nd->path, &nd->root))\n\t\tgoto in_root;\n\tif (unlikely(nd->path.dentry == nd->path.mnt->mnt_root)) {\n\t\tstruct path path;\n\t\tunsigned seq;\n\t\tif (!choose_mountpoint_rcu(real_mount(nd->path.mnt),\n\t\t\t\t\t   &nd->root, &path, &seq))\n\t\t\tgoto in_root;\n\t\tif (unlikely(nd->flags & LOOKUP_NO_XDEV))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\tnd->path = path;\n\t\tnd->inode = path.dentry->d_inode;\n\t\tnd->seq = seq;\n\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\t/* we know that mountpoint was pinned */\n\t}\n\told = nd->path.dentry;\n\tparent = old->d_parent;\n\t*inodep = parent->d_inode;\n\t*seqp = read_seqcount_begin(&parent->d_seq);\n\tif (unlikely(read_seqcount_retry(&old->d_seq, nd->seq)))\n\t\treturn ERR_PTR(-ECHILD);\n\tif (unlikely(!path_connected(nd->path.mnt, parent)))\n\t\treturn ERR_PTR(-ECHILD);\n\treturn parent;\nin_root:\n\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\treturn ERR_PTR(-ECHILD);\n\tif (unlikely(nd->flags & LOOKUP_BENEATH))\n\t\treturn ERR_PTR(-ECHILD);\n\treturn NULL;\n}\n\nstatic struct dentry *follow_dotdot(struct nameidata *nd,\n\t\t\t\t struct inode **inodep,\n\t\t\t\t unsigned *seqp)\n{\n\tstruct dentry *parent;\n\n\tif (path_equal(&nd->path, &nd->root))\n\t\tgoto in_root;\n\tif (unlikely(nd->path.dentry == nd->path.mnt->mnt_root)) {\n\t\tstruct path path;\n\n\t\tif (!choose_mountpoint(real_mount(nd->path.mnt),\n\t\t\t\t       &nd->root, &path))\n\t\t\tgoto in_root;\n\t\tpath_put(&nd->path);\n\t\tnd->path = path;\n\t\tnd->inode = path.dentry->d_inode;\n\t\tif (unlikely(nd->flags & LOOKUP_NO_XDEV))\n\t\t\treturn ERR_PTR(-EXDEV);\n\t}\n\t/* rare case of legitimate dget_parent()... */\n\tparent = dget_parent(nd->path.dentry);\n\tif (unlikely(!path_connected(nd->path.mnt, parent))) {\n\t\tdput(parent);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\t*seqp = 0;\n\t*inodep = parent->d_inode;\n\treturn parent;\n\nin_root:\n\tif (unlikely(nd->flags & LOOKUP_BENEATH))\n\t\treturn ERR_PTR(-EXDEV);\n\tdget(nd->path.dentry);\n\treturn NULL;\n}\n\nstatic const char *handle_dots(struct nameidata *nd, int type)\n{\n\tif (type == LAST_DOTDOT) {\n\t\tconst char *error = NULL;\n\t\tstruct dentry *parent;\n\t\tstruct inode *inode;\n\t\tunsigned seq;\n\n\t\tif (!nd->root.mnt) {\n\t\t\terror = ERR_PTR(set_root(nd));\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif (nd->flags & LOOKUP_RCU)\n\t\t\tparent = follow_dotdot_rcu(nd, &inode, &seq);\n\t\telse\n\t\t\tparent = follow_dotdot(nd, &inode, &seq);\n\t\tif (IS_ERR(parent))\n\t\t\treturn ERR_CAST(parent);\n\t\tif (unlikely(!parent))\n\t\t\terror = step_into(nd, WALK_NOFOLLOW,\n\t\t\t\t\t nd->path.dentry, nd->inode, nd->seq);\n\t\telse\n\t\t\terror = step_into(nd, WALK_NOFOLLOW,\n\t\t\t\t\t parent, inode, seq);\n\t\tif (unlikely(error))\n\t\t\treturn error;\n\n\t\tif (unlikely(nd->flags & LOOKUP_IS_SCOPED)) {\n\t\t\t/*\n\t\t\t * If there was a racing rename or mount along our\n\t\t\t * path, then we can't be sure that \"..\" hasn't jumped\n\t\t\t * above nd->root (and so userspace should retry or use\n\t\t\t * some fallback).\n\t\t\t */\n\t\t\tsmp_rmb();\n\t\t\tif (unlikely(__read_seqcount_retry(&mount_lock.seqcount, nd->m_seq)))\n\t\t\t\treturn ERR_PTR(-EAGAIN);\n\t\t\tif (unlikely(__read_seqcount_retry(&rename_lock.seqcount, nd->r_seq)))\n\t\t\t\treturn ERR_PTR(-EAGAIN);\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic const char *walk_component(struct nameidata *nd, int flags)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned seq;\n\t/*\n\t * \".\" and \"..\" are special - \"..\" especially so because it has\n\t * to be able to know about the current root directory and\n\t * parent relationships.\n\t */\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\tif (!(flags & WALK_MORE) && nd->depth)\n\t\t\tput_link(nd);\n\t\treturn handle_dots(nd, nd->last_type);\n\t}\n\tdentry = lookup_fast(nd, &inode, &seq);\n\tif (IS_ERR(dentry))\n\t\treturn ERR_CAST(dentry);\n\tif (unlikely(!dentry)) {\n\t\tdentry = lookup_slow(&nd->last, nd->path.dentry, nd->flags);\n\t\tif (IS_ERR(dentry))\n\t\t\treturn ERR_CAST(dentry);\n\t}\n\tif (!(flags & WALK_MORE) && nd->depth)\n\t\tput_link(nd);\n\treturn step_into(nd, flags, dentry, inode, seq);\n}\n\n/*\n * We can do the critical dentry name comparison and hashing\n * operations one word at a time, but we are limited to:\n *\n * - Architectures with fast unaligned word accesses. We could\n *   do a \"get_unaligned()\" if this helps and is sufficiently\n *   fast.\n *\n * - non-CONFIG_DEBUG_PAGEALLOC configurations (so that we\n *   do not trap on the (extremely unlikely) case of a page\n *   crossing operation.\n *\n * - Furthermore, we need an efficient 64-bit compile for the\n *   64-bit case in order to generate the \"number of bytes in\n *   the final mask\". Again, that could be replaced with a\n *   efficient population count instruction or similar.\n */\n#ifdef CONFIG_DCACHE_WORD_ACCESS\n\n#include <asm/word-at-a-time.h>\n\n#ifdef HASH_MIX\n\n/* Architecture provides HASH_MIX and fold_hash() in <asm/hash.h> */\n\n#elif defined(CONFIG_64BIT)\n/*\n * Register pressure in the mixing function is an issue, particularly\n * on 32-bit x86, but almost any function requires one state value and\n * one temporary.  Instead, use a function designed for two state values\n * and no temporaries.\n *\n * This function cannot create a collision in only two iterations, so\n * we have two iterations to achieve avalanche.  In those two iterations,\n * we have six layers of mixing, which is enough to spread one bit's\n * influence out to 2^6 = 64 state bits.\n *\n * Rotate constants are scored by considering either 64 one-bit input\n * deltas or 64*63/2 = 2016 two-bit input deltas, and finding the\n * probability of that delta causing a change to each of the 128 output\n * bits, using a sample of random initial states.\n *\n * The Shannon entropy of the computed probabilities is then summed\n * to produce a score.  Ideally, any input change has a 50% chance of\n * toggling any given output bit.\n *\n * Mixing scores (in bits) for (12,45):\n * Input delta: 1-bit      2-bit\n * 1 round:     713.3    42542.6\n * 2 rounds:   2753.7   140389.8\n * 3 rounds:   5954.1   233458.2\n * 4 rounds:   7862.6   256672.2\n * Perfect:    8192     258048\n *            (64*128) (64*63/2 * 128)\n */\n#define HASH_MIX(x, y, a)\t\\\n\t(\tx ^= (a),\t\\\n\ty ^= x,\tx = rol64(x,12),\\\n\tx += y,\ty = rol64(y,45),\\\n\ty *= 9\t\t\t)\n\n/*\n * Fold two longs into one 32-bit hash value.  This must be fast, but\n * latency isn't quite as critical, as there is a fair bit of additional\n * work done before the hash value is used.\n */\nstatic inline unsigned int fold_hash(unsigned long x, unsigned long y)\n{\n\ty ^= x * GOLDEN_RATIO_64;\n\ty *= GOLDEN_RATIO_64;\n\treturn y >> 32;\n}\n\n#else\t/* 32-bit case */\n\n/*\n * Mixing scores (in bits) for (7,20):\n * Input delta: 1-bit      2-bit\n * 1 round:     330.3     9201.6\n * 2 rounds:   1246.4    25475.4\n * 3 rounds:   1907.1    31295.1\n * 4 rounds:   2042.3    31718.6\n * Perfect:    2048      31744\n *            (32*64)   (32*31/2 * 64)\n */\n#define HASH_MIX(x, y, a)\t\\\n\t(\tx ^= (a),\t\\\n\ty ^= x,\tx = rol32(x, 7),\\\n\tx += y,\ty = rol32(y,20),\\\n\ty *= 9\t\t\t)\n\nstatic inline unsigned int fold_hash(unsigned long x, unsigned long y)\n{\n\t/* Use arch-optimized multiply if one exists */\n\treturn __hash_32(y ^ __hash_32(x));\n}\n\n#endif\n\n/*\n * Return the hash of a string of known length.  This is carfully\n * designed to match hash_name(), which is the more critical function.\n * In particular, we must end by hashing a final word containing 0..7\n * payload bytes, to match the way that hash_name() iterates until it\n * finds the delimiter after the name.\n */\nunsigned int full_name_hash(const void *salt, const char *name, unsigned int len)\n{\n\tunsigned long a, x = 0, y = (unsigned long)salt;\n\n\tfor (;;) {\n\t\tif (!len)\n\t\t\tgoto done;\n\t\ta = load_unaligned_zeropad(name);\n\t\tif (len < sizeof(unsigned long))\n\t\t\tbreak;\n\t\tHASH_MIX(x, y, a);\n\t\tname += sizeof(unsigned long);\n\t\tlen -= sizeof(unsigned long);\n\t}\n\tx ^= a & bytemask_from_count(len);\ndone:\n\treturn fold_hash(x, y);\n}\nEXPORT_SYMBOL(full_name_hash);\n\n/* Return the \"hash_len\" (hash and length) of a null-terminated string */\nu64 hashlen_string(const void *salt, const char *name)\n{\n\tunsigned long a = 0, x = 0, y = (unsigned long)salt;\n\tunsigned long adata, mask, len;\n\tconst struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;\n\n\tlen = 0;\n\tgoto inside;\n\n\tdo {\n\t\tHASH_MIX(x, y, a);\n\t\tlen += sizeof(unsigned long);\ninside:\n\t\ta = load_unaligned_zeropad(name+len);\n\t} while (!has_zero(a, &adata, &constants));\n\n\tadata = prep_zero_mask(a, adata, &constants);\n\tmask = create_zero_mask(adata);\n\tx ^= a & zero_bytemask(mask);\n\n\treturn hashlen_create(fold_hash(x, y), len + find_zero(mask));\n}\nEXPORT_SYMBOL(hashlen_string);\n\n/*\n * Calculate the length and hash of the path component, and\n * return the \"hash_len\" as the result.\n */\nstatic inline u64 hash_name(const void *salt, const char *name)\n{\n\tunsigned long a = 0, b, x = 0, y = (unsigned long)salt;\n\tunsigned long adata, bdata, mask, len;\n\tconst struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;\n\n\tlen = 0;\n\tgoto inside;\n\n\tdo {\n\t\tHASH_MIX(x, y, a);\n\t\tlen += sizeof(unsigned long);\ninside:\n\t\ta = load_unaligned_zeropad(name+len);\n\t\tb = a ^ REPEAT_BYTE('/');\n\t} while (!(has_zero(a, &adata, &constants) | has_zero(b, &bdata, &constants)));\n\n\tadata = prep_zero_mask(a, adata, &constants);\n\tbdata = prep_zero_mask(b, bdata, &constants);\n\tmask = create_zero_mask(adata | bdata);\n\tx ^= a & zero_bytemask(mask);\n\n\treturn hashlen_create(fold_hash(x, y), len + find_zero(mask));\n}\n\n#else\t/* !CONFIG_DCACHE_WORD_ACCESS: Slow, byte-at-a-time version */\n\n/* Return the hash of a string of known length */\nunsigned int full_name_hash(const void *salt, const char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash(salt);\n\twhile (len--)\n\t\thash = partial_name_hash((unsigned char)*name++, hash);\n\treturn end_name_hash(hash);\n}\nEXPORT_SYMBOL(full_name_hash);\n\n/* Return the \"hash_len\" (hash and length) of a null-terminated string */\nu64 hashlen_string(const void *salt, const char *name)\n{\n\tunsigned long hash = init_name_hash(salt);\n\tunsigned long len = 0, c;\n\n\tc = (unsigned char)*name;\n\twhile (c) {\n\t\tlen++;\n\t\thash = partial_name_hash(c, hash);\n\t\tc = (unsigned char)name[len];\n\t}\n\treturn hashlen_create(end_name_hash(hash), len);\n}\nEXPORT_SYMBOL(hashlen_string);\n\n/*\n * We know there's a real path component here of at least\n * one character.\n */\nstatic inline u64 hash_name(const void *salt, const char *name)\n{\n\tunsigned long hash = init_name_hash(salt);\n\tunsigned long len = 0, c;\n\n\tc = (unsigned char)*name;\n\tdo {\n\t\tlen++;\n\t\thash = partial_name_hash(c, hash);\n\t\tc = (unsigned char)name[len];\n\t} while (c && c != '/');\n\treturn hashlen_create(end_name_hash(hash), len);\n}\n\n#endif\n\n/*\n * Name resolution.\n * This is the basic name resolution function, turning a pathname into\n * the final dentry. We expect 'base' to be positive and a directory.\n *\n * Returns 0 and nd will have valid dentry and mnt on success.\n * Returns error and drops reference to input namei data on failure.\n */\nstatic int link_path_walk(const char *name, struct nameidata *nd)\n{\n\tint depth = 0; // depth <= nd->depth\n\tint err;\n\n\tnd->last_type = LAST_ROOT;\n\tnd->flags |= LOOKUP_PARENT;\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\twhile (*name=='/')\n\t\tname++;\n\tif (!*name)\n\t\treturn 0;\n\n\t/* At this point we know we have a real path component. */\n\tfor(;;) {\n\t\tconst char *link;\n\t\tu64 hash_len;\n\t\tint type;\n\n\t\terr = may_lookup(nd);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\thash_len = hash_name(nd->path.dentry, name);\n\n\t\ttype = LAST_NORM;\n\t\tif (name[0] == '.') switch (hashlen_len(hash_len)) {\n\t\t\tcase 2:\n\t\t\t\tif (name[1] == '.') {\n\t\t\t\t\ttype = LAST_DOTDOT;\n\t\t\t\t\tnd->flags |= LOOKUP_JUMPED;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ttype = LAST_DOT;\n\t\t}\n\t\tif (likely(type == LAST_NORM)) {\n\t\t\tstruct dentry *parent = nd->path.dentry;\n\t\t\tnd->flags &= ~LOOKUP_JUMPED;\n\t\t\tif (unlikely(parent->d_flags & DCACHE_OP_HASH)) {\n\t\t\t\tstruct qstr this = { { .hash_len = hash_len }, .name = name };\n\t\t\t\terr = parent->d_op->d_hash(parent, &this);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t\thash_len = this.hash_len;\n\t\t\t\tname = this.name;\n\t\t\t}\n\t\t}\n\n\t\tnd->last.hash_len = hash_len;\n\t\tnd->last.name = name;\n\t\tnd->last_type = type;\n\n\t\tname += hashlen_len(hash_len);\n\t\tif (!*name)\n\t\t\tgoto OK;\n\t\t/*\n\t\t * If it wasn't NUL, we know it was '/'. Skip that\n\t\t * slash, and continue until no more slashes.\n\t\t */\n\t\tdo {\n\t\t\tname++;\n\t\t} while (unlikely(*name == '/'));\n\t\tif (unlikely(!*name)) {\nOK:\n\t\t\t/* pathname or trailing symlink, done */\n\t\t\tif (!depth) {\n\t\t\t\tnd->dir_uid = nd->inode->i_uid;\n\t\t\t\tnd->dir_mode = nd->inode->i_mode;\n\t\t\t\tnd->flags &= ~LOOKUP_PARENT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/* last component of nested symlink */\n\t\t\tname = nd->stack[--depth].name;\n\t\t\tlink = walk_component(nd, 0);\n\t\t} else {\n\t\t\t/* not the last component */\n\t\t\tlink = walk_component(nd, WALK_MORE);\n\t\t}\n\t\tif (unlikely(link)) {\n\t\t\tif (IS_ERR(link))\n\t\t\t\treturn PTR_ERR(link);\n\t\t\t/* a symlink to follow */\n\t\t\tnd->stack[depth++].name = name;\n\t\t\tname = link;\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(!d_can_lookup(nd->path.dentry))) {\n\t\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\t\tif (unlazy_walk(nd))\n\t\t\t\t\treturn -ECHILD;\n\t\t\t}\n\t\t\treturn -ENOTDIR;\n\t\t}\n\t}\n}\n\n/* must be paired with terminate_walk() */\nstatic const char *path_init(struct nameidata *nd, unsigned flags)\n{\n\tint error;\n\tconst char *s = nd->name->name;\n\n\tif (!*s)\n\t\tflags &= ~LOOKUP_RCU;\n\tif (flags & LOOKUP_RCU)\n\t\trcu_read_lock();\n\n\tnd->flags = flags | LOOKUP_JUMPED;\n\tnd->depth = 0;\n\n\tnd->m_seq = __read_seqcount_begin(&mount_lock.seqcount);\n\tnd->r_seq = __read_seqcount_begin(&rename_lock.seqcount);\n\tsmp_rmb();\n\n\tif (flags & LOOKUP_ROOT) {\n\t\tstruct dentry *root = nd->root.dentry;\n\t\tstruct inode *inode = root->d_inode;\n\t\tif (*s && unlikely(!d_can_lookup(root)))\n\t\t\treturn ERR_PTR(-ENOTDIR);\n\t\tnd->path = nd->root;\n\t\tnd->inode = inode;\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t\tnd->root_seq = nd->seq;\n\t\t} else {\n\t\t\tpath_get(&nd->path);\n\t\t}\n\t\treturn s;\n\t}\n\n\tnd->root.mnt = NULL;\n\tnd->path.mnt = NULL;\n\tnd->path.dentry = NULL;\n\n\t/* Absolute pathname -- fetch the root (LOOKUP_IN_ROOT uses nd->dfd). */\n\tif (*s == '/' && !(flags & LOOKUP_IN_ROOT)) {\n\t\terror = nd_jump_root(nd);\n\t\tif (unlikely(error))\n\t\t\treturn ERR_PTR(error);\n\t\treturn s;\n\t}\n\n\t/* Relative pathname -- get the starting-point it is relative to. */\n\tif (nd->dfd == AT_FDCWD) {\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tstruct fs_struct *fs = current->fs;\n\t\t\tunsigned seq;\n\n\t\t\tdo {\n\t\t\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t\t\tnd->path = fs->pwd;\n\t\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t\t\tnd->seq = __read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t\t} while (read_seqcount_retry(&fs->seq, seq));\n\t\t} else {\n\t\t\tget_fs_pwd(current->fs, &nd->path);\n\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t}\n\t} else {\n\t\t/* Caller must check execute permissions on the starting path component */\n\t\tstruct fd f = fdget_raw(nd->dfd);\n\t\tstruct dentry *dentry;\n\n\t\tif (!f.file)\n\t\t\treturn ERR_PTR(-EBADF);\n\n\t\tdentry = f.file->f_path.dentry;\n\n\t\tif (*s && unlikely(!d_can_lookup(dentry))) {\n\t\t\tfdput(f);\n\t\t\treturn ERR_PTR(-ENOTDIR);\n\t\t}\n\n\t\tnd->path = f.file->f_path;\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t\t} else {\n\t\t\tpath_get(&nd->path);\n\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t}\n\t\tfdput(f);\n\t}\n\n\t/* For scoped-lookups we need to set the root to the dirfd as well. */\n\tif (flags & LOOKUP_IS_SCOPED) {\n\t\tnd->root = nd->path;\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tnd->root_seq = nd->seq;\n\t\t} else {\n\t\t\tpath_get(&nd->root);\n\t\t\tnd->flags |= LOOKUP_ROOT_GRABBED;\n\t\t}\n\t}\n\treturn s;\n}\n\nstatic inline const char *lookup_last(struct nameidata *nd)\n{\n\tif (nd->last_type == LAST_NORM && nd->last.name[nd->last.len])\n\t\tnd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\n\n\treturn walk_component(nd, WALK_TRAILING);\n}\n\nstatic int handle_lookup_down(struct nameidata *nd)\n{\n\tif (!(nd->flags & LOOKUP_RCU))\n\t\tdget(nd->path.dentry);\n\treturn PTR_ERR(step_into(nd, WALK_NOFOLLOW,\n\t\t\tnd->path.dentry, nd->inode, nd->seq));\n}\n\n/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */\nstatic int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)\n{\n\tconst char *s = path_init(nd, flags);\n\tint err;\n\n\tif (unlikely(flags & LOOKUP_DOWN) && !IS_ERR(s)) {\n\t\terr = handle_lookup_down(nd);\n\t\tif (unlikely(err < 0))\n\t\t\ts = ERR_PTR(err);\n\t}\n\n\twhile (!(err = link_path_walk(s, nd)) &&\n\t       (s = lookup_last(nd)) != NULL)\n\t\t;\n\tif (!err)\n\t\terr = complete_walk(nd);\n\n\tif (!err && nd->flags & LOOKUP_DIRECTORY)\n\t\tif (!d_can_lookup(nd->path.dentry))\n\t\t\terr = -ENOTDIR;\n\tif (!err && unlikely(nd->flags & LOOKUP_MOUNTPOINT)) {\n\t\terr = handle_lookup_down(nd);\n\t\tnd->flags &= ~LOOKUP_JUMPED; // no d_weak_revalidate(), please...\n\t}\n\tif (!err) {\n\t\t*path = nd->path;\n\t\tnd->path.mnt = NULL;\n\t\tnd->path.dentry = NULL;\n\t}\n\tterminate_walk(nd);\n\treturn err;\n}\n\nint filename_lookup(int dfd, struct filename *name, unsigned flags,\n\t\t    struct path *path, struct path *root)\n{\n\tint retval;\n\tstruct nameidata nd;\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\tif (unlikely(root)) {\n\t\tnd.root = *root;\n\t\tflags |= LOOKUP_ROOT;\n\t}\n\tset_nameidata(&nd, dfd, name);\n\tretval = path_lookupat(&nd, flags | LOOKUP_RCU, path);\n\tif (unlikely(retval == -ECHILD))\n\t\tretval = path_lookupat(&nd, flags, path);\n\tif (unlikely(retval == -ESTALE))\n\t\tretval = path_lookupat(&nd, flags | LOOKUP_REVAL, path);\n\n\tif (likely(!retval))\n\t\taudit_inode(name, path->dentry,\n\t\t\t    flags & LOOKUP_MOUNTPOINT ? AUDIT_INODE_NOEVAL : 0);\n\trestore_nameidata();\n\tputname(name);\n\treturn retval;\n}\n\n/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */\nstatic int path_parentat(struct nameidata *nd, unsigned flags,\n\t\t\t\tstruct path *parent)\n{\n\tconst char *s = path_init(nd, flags);\n\tint err = link_path_walk(s, nd);\n\tif (!err)\n\t\terr = complete_walk(nd);\n\tif (!err) {\n\t\t*parent = nd->path;\n\t\tnd->path.mnt = NULL;\n\t\tnd->path.dentry = NULL;\n\t}\n\tterminate_walk(nd);\n\treturn err;\n}\n\nstatic struct filename *filename_parentat(int dfd, struct filename *name,\n\t\t\t\tunsigned int flags, struct path *parent,\n\t\t\t\tstruct qstr *last, int *type)\n{\n\tint retval;\n\tstruct nameidata nd;\n\n\tif (IS_ERR(name))\n\t\treturn name;\n\tset_nameidata(&nd, dfd, name);\n\tretval = path_parentat(&nd, flags | LOOKUP_RCU, parent);\n\tif (unlikely(retval == -ECHILD))\n\t\tretval = path_parentat(&nd, flags, parent);\n\tif (unlikely(retval == -ESTALE))\n\t\tretval = path_parentat(&nd, flags | LOOKUP_REVAL, parent);\n\tif (likely(!retval)) {\n\t\t*last = nd.last;\n\t\t*type = nd.last_type;\n\t\taudit_inode(name, parent->dentry, AUDIT_INODE_PARENT);\n\t} else {\n\t\tputname(name);\n\t\tname = ERR_PTR(retval);\n\t}\n\trestore_nameidata();\n\treturn name;\n}\n\n/* does lookup, returns the object with parent locked */\nstruct dentry *kern_path_locked(const char *name, struct path *path)\n{\n\tstruct filename *filename;\n\tstruct dentry *d;\n\tstruct qstr last;\n\tint type;\n\n\tfilename = filename_parentat(AT_FDCWD, getname_kernel(name), 0, path,\n\t\t\t\t    &last, &type);\n\tif (IS_ERR(filename))\n\t\treturn ERR_CAST(filename);\n\tif (unlikely(type != LAST_NORM)) {\n\t\tpath_put(path);\n\t\tputname(filename);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tinode_lock_nested(path->dentry->d_inode, I_MUTEX_PARENT);\n\td = __lookup_hash(&last, path->dentry, 0);\n\tif (IS_ERR(d)) {\n\t\tinode_unlock(path->dentry->d_inode);\n\t\tpath_put(path);\n\t}\n\tputname(filename);\n\treturn d;\n}\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\treturn filename_lookup(AT_FDCWD, getname_kernel(name),\n\t\t\t       flags, path, NULL);\n}\nEXPORT_SYMBOL(kern_path);\n\n/**\n * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair\n * @dentry:  pointer to dentry of the base directory\n * @mnt: pointer to vfs mount of the base directory\n * @name: pointer to file name\n * @flags: lookup flags\n * @path: pointer to struct path to fill\n */\nint vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt,\n\t\t    const char *name, unsigned int flags,\n\t\t    struct path *path)\n{\n\tstruct path root = {.mnt = mnt, .dentry = dentry};\n\t/* the first argument of filename_lookup() is ignored with root */\n\treturn filename_lookup(AT_FDCWD, getname_kernel(name),\n\t\t\t       flags , path, &root);\n}\nEXPORT_SYMBOL(vfs_path_lookup);\n\nstatic int lookup_one_len_common(const char *name, struct dentry *base,\n\t\t\t\t int len, struct qstr *this)\n{\n\tthis->name = name;\n\tthis->len = len;\n\tthis->hash = full_name_hash(base, name, len);\n\tif (!len)\n\t\treturn -EACCES;\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn -EACCES;\n\t}\n\n\twhile (len--) {\n\t\tunsigned int c = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn -EACCES;\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, this);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn inode_permission(base->d_inode, MAY_EXEC);\n}\n\n/**\n * try_lookup_one_len - filesystem helper to lookup single pathname component\n * @name:\tpathname component to lookup\n * @base:\tbase directory to lookup from\n * @len:\tmaximum length @len should be interpreted to\n *\n * Look up a dentry by name in the dcache, returning NULL if it does not\n * currently exist.  The function does not try to create a dentry.\n *\n * Note that this routine is purely a helper for filesystem usage and should\n * not be called by generic code.\n *\n * The caller must hold base->i_mutex.\n */\nstruct dentry *try_lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(base->d_inode));\n\n\terr = lookup_one_len_common(name, base, len, &this);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn lookup_dcache(&this, base, 0);\n}\nEXPORT_SYMBOL(try_lookup_one_len);\n\n/**\n * lookup_one_len - filesystem helper to lookup single pathname component\n * @name:\tpathname component to lookup\n * @base:\tbase directory to lookup from\n * @len:\tmaximum length @len should be interpreted to\n *\n * Note that this routine is purely a helper for filesystem usage and should\n * not be called by generic code.\n *\n * The caller must hold base->i_mutex.\n */\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct dentry *dentry;\n\tstruct qstr this;\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(base->d_inode));\n\n\terr = lookup_one_len_common(name, base, len, &this);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tdentry = lookup_dcache(&this, base, 0);\n\treturn dentry ? dentry : __lookup_slow(&this, base, 0);\n}\nEXPORT_SYMBOL(lookup_one_len);\n\n/**\n * lookup_one_len_unlocked - filesystem helper to lookup single pathname component\n * @name:\tpathname component to lookup\n * @base:\tbase directory to lookup from\n * @len:\tmaximum length @len should be interpreted to\n *\n * Note that this routine is purely a helper for filesystem usage and should\n * not be called by generic code.\n *\n * Unlike lookup_one_len, it should be called without the parent\n * i_mutex held, and will take the i_mutex itself if necessary.\n */\nstruct dentry *lookup_one_len_unlocked(const char *name,\n\t\t\t\t       struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tint err;\n\tstruct dentry *ret;\n\n\terr = lookup_one_len_common(name, base, len, &this);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tret = lookup_dcache(&this, base, 0);\n\tif (!ret)\n\t\tret = lookup_slow(&this, base, 0);\n\treturn ret;\n}\nEXPORT_SYMBOL(lookup_one_len_unlocked);\n\n/*\n * Like lookup_one_len_unlocked(), except that it yields ERR_PTR(-ENOENT)\n * on negatives.  Returns known positive or ERR_PTR(); that's what\n * most of the users want.  Note that pinned negative with unlocked parent\n * _can_ become positive at any time, so callers of lookup_one_len_unlocked()\n * need to be very careful; pinned positives have ->d_inode stable, so\n * this one avoids such problems.\n */\nstruct dentry *lookup_positive_unlocked(const char *name,\n\t\t\t\t       struct dentry *base, int len)\n{\n\tstruct dentry *ret = lookup_one_len_unlocked(name, base, len);\n\tif (!IS_ERR(ret) && d_flags_negative(smp_load_acquire(&ret->d_flags))) {\n\t\tdput(ret);\n\t\tret = ERR_PTR(-ENOENT);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(lookup_positive_unlocked);\n\n#ifdef CONFIG_UNIX98_PTYS\nint path_pts(struct path *path)\n{\n\t/* Find something mounted on \"pts\" in the same directory as\n\t * the input path.\n\t */\n\tstruct dentry *parent = dget_parent(path->dentry);\n\tstruct dentry *child;\n\tstruct qstr this = QSTR_INIT(\"pts\", 3);\n\n\tif (unlikely(!path_connected(path->mnt, parent))) {\n\t\tdput(parent);\n\t\treturn -ENOENT;\n\t}\n\tdput(path->dentry);\n\tpath->dentry = parent;\n\tchild = d_hash_and_lookup(parent, &this);\n\tif (!child)\n\t\treturn -ENOENT;\n\n\tpath->dentry = child;\n\tdput(parent);\n\tfollow_down(path);\n\treturn 0;\n}\n#endif\n\nint user_path_at_empty(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path, int *empty)\n{\n\treturn filename_lookup(dfd, getname_flags(name, flags, empty),\n\t\t\t       flags, path, NULL);\n}\nEXPORT_SYMBOL(user_path_at_empty);\n\nint __check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !capable_wrt_inode_uidgid(inode, CAP_FOWNER);\n}\nEXPORT_SYMBOL(__check_sticky);\n\n/*\n *\tCheck whether we can remove a link victim from directory dir, check\n *  whether the type of victim is right.\n *  1. We can't do it if dir is read-only (done in permission())\n *  2. We should have write and exec permissions on dir\n *  3. We can't remove anything from append-only dir\n *  4. We can't do anything with immutable dir (done in permission())\n *  5. If the sticky bit on dir is set we should either\n *\ta. be owner of dir, or\n *\tb. be owner of victim, or\n *\tc. have CAP_FOWNER capability\n *  6. If the victim is append-only or immutable we can't do antyhing with\n *     links pointing to it.\n *  7. If the victim has an unknown uid or gid we can't change the inode.\n *  8. If we were asked to remove a directory and victim isn't one - ENOTDIR.\n *  9. If we were asked to remove a non-directory and victim isn't one - EISDIR.\n * 10. We can't remove a root or mountpoint.\n * 11. We don't allow removal of NFS sillyrenamed files; it's handled by\n *     nfs_async_unlink().\n */\nstatic int may_delete(struct inode *dir, struct dentry *victim, bool isdir)\n{\n\tstruct inode *inode = d_backing_inode(victim);\n\tint error;\n\n\tif (d_is_negative(victim))\n\t\treturn -ENOENT;\n\tBUG_ON(!inode);\n\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\n\t/* Inode writeback is not safe when the uid or gid are invalid. */\n\tif (!uid_valid(inode->i_uid) || !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\taudit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);\n\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\n\tif (check_sticky(dir, inode) || IS_APPEND(inode) ||\n\t    IS_IMMUTABLE(inode) || IS_SWAPFILE(inode) || HAS_UNMAPPED_ID(inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!d_is_dir(victim))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (d_is_dir(victim))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\n/*\tCheck whether we can create an object with dentry child in directory\n *  dir.\n *  1. We can't do it if child already exists (open has special treatment for\n *     this case, but since we are inlined it's OK)\n *  2. We can't do it if dir is read-only (done in permission())\n *  3. We can't do it if the fs can't represent the fsuid or fsgid.\n *  4. We should have write and exec permissions on dir\n *  5. We can't do it if dir is immutable (done in permission())\n */\nstatic inline int may_create(struct inode *dir, struct dentry *child)\n{\n\tstruct user_namespace *s_user_ns;\n\taudit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE);\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\ts_user_ns = dir->i_sb->s_user_ns;\n\tif (!kuid_has_mapping(s_user_ns, current_fsuid()) ||\n\t    !kgid_has_mapping(s_user_ns, current_fsgid()))\n\t\treturn -EOVERFLOW;\n\treturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\n}\n\n/*\n * p1 and p2 should be directories on the same fs.\n */\nstruct dentry *lock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tif (p1 == p2) {\n\t\tinode_lock_nested(p1->d_inode, I_MUTEX_PARENT);\n\t\treturn NULL;\n\t}\n\n\tmutex_lock(&p1->d_sb->s_vfs_rename_mutex);\n\n\tp = d_ancestor(p2, p1);\n\tif (p) {\n\t\tinode_lock_nested(p2->d_inode, I_MUTEX_PARENT);\n\t\tinode_lock_nested(p1->d_inode, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tp = d_ancestor(p1, p2);\n\tif (p) {\n\t\tinode_lock_nested(p1->d_inode, I_MUTEX_PARENT);\n\t\tinode_lock_nested(p2->d_inode, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tinode_lock_nested(p1->d_inode, I_MUTEX_PARENT);\n\tinode_lock_nested(p2->d_inode, I_MUTEX_PARENT2);\n\treturn NULL;\n}\nEXPORT_SYMBOL(lock_rename);\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tinode_unlock(p1->d_inode);\n\tif (p1 != p2) {\n\t\tinode_unlock(p2->d_inode);\n\t\tmutex_unlock(&p1->d_sb->s_vfs_rename_mutex);\n\t}\n}\nEXPORT_SYMBOL(unlock_rename);\n\nint vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool want_excl)\n{\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->create)\n\t\treturn -EACCES;\t/* shouldn't it be ENOSYS? */\n\tmode &= S_IALLUGO;\n\tmode |= S_IFREG;\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\terror = dir->i_op->create(dir, dentry, mode, want_excl);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_create);\n\nint vfs_mkobj(struct dentry *dentry, umode_t mode,\n\t\tint (*f)(struct dentry *, umode_t, void *),\n\t\tvoid *arg)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tint error = may_create(dir, dentry);\n\tif (error)\n\t\treturn error;\n\n\tmode &= S_IALLUGO;\n\tmode |= S_IFREG;\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\terror = f(dentry, mode, arg);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_mkobj);\n\nbool may_open_dev(const struct path *path)\n{\n\treturn !(path->mnt->mnt_flags & MNT_NODEV) &&\n\t\t!(path->mnt->mnt_sb->s_iflags & SB_I_NODEV);\n}\n\nstatic int may_open(const struct path *path, int acc_mode, int flag)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\treturn -ELOOP;\n\tcase S_IFDIR:\n\t\tif (acc_mode & MAY_WRITE)\n\t\t\treturn -EISDIR;\n\t\tif (acc_mode & MAY_EXEC)\n\t\t\treturn -EACCES;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tif (!may_open_dev(path))\n\t\t\treturn -EACCES;\n\t\tfallthrough;\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tif (acc_mode & MAY_EXEC)\n\t\t\treturn -EACCES;\n\t\tflag &= ~O_TRUNC;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tif ((acc_mode & MAY_EXEC) && path_noexec(path))\n\t\t\treturn -EACCES;\n\t\tbreak;\n\t}\n\n\terror = inode_permission(inode, MAY_OPEN | acc_mode);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * An append-only file must be opened in append mode for writing.\n\t */\n\tif (IS_APPEND(inode)) {\n\t\tif  ((flag & O_ACCMODE) != O_RDONLY && !(flag & O_APPEND))\n\t\t\treturn -EPERM;\n\t\tif (flag & O_TRUNC)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* O_NOATIME can only be set by the owner or superuser */\n\tif (flag & O_NOATIME && !inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic int handle_truncate(struct file *filp)\n{\n\tconst struct path *path = &filp->f_path;\n\tstruct inode *inode = path->dentry->d_inode;\n\tint error = get_write_access(inode);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Refuse to truncate files with mandatory locks held on them.\n\t */\n\terror = locks_verify_locked(filp);\n\tif (!error)\n\t\terror = security_path_truncate(path);\n\tif (!error) {\n\t\terror = do_truncate(path->dentry, 0,\n\t\t\t\t    ATTR_MTIME|ATTR_CTIME|ATTR_OPEN,\n\t\t\t\t    filp);\n\t}\n\tput_write_access(inode);\n\treturn error;\n}\n\nstatic inline int open_to_namei_flags(int flag)\n{\n\tif ((flag & O_ACCMODE) == 3)\n\t\tflag--;\n\treturn flag;\n}\n\nstatic int may_o_create(const struct path *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct user_namespace *s_user_ns;\n\tint error = security_path_mknod(dir, dentry, mode, 0);\n\tif (error)\n\t\treturn error;\n\n\ts_user_ns = dir->dentry->d_sb->s_user_ns;\n\tif (!kuid_has_mapping(s_user_ns, current_fsuid()) ||\n\t    !kgid_has_mapping(s_user_ns, current_fsgid()))\n\t\treturn -EOVERFLOW;\n\n\terror = inode_permission(dir->dentry->d_inode, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\n\treturn security_inode_create(dir->dentry->d_inode, dentry, mode);\n}\n\n/*\n * Attempt to atomically look up, create and open a file from a negative\n * dentry.\n *\n * Returns 0 if successful.  The file will have been created and attached to\n * @file by the filesystem calling finish_open().\n *\n * If the file was looked up only or didn't need creating, FMODE_OPENED won't\n * be set.  The caller will need to perform the open themselves.  @path will\n * have been updated to point to the new dentry.  This may be negative.\n *\n * Returns an error code otherwise.\n */\nstatic struct dentry *atomic_open(struct nameidata *nd, struct dentry *dentry,\n\t\t\t\t  struct file *file,\n\t\t\t\t  int open_flag, umode_t mode)\n{\n\tstruct dentry *const DENTRY_NOT_SET = (void *) -1UL;\n\tstruct inode *dir =  nd->path.dentry->d_inode;\n\tint error;\n\n\tif (nd->flags & LOOKUP_DIRECTORY)\n\t\topen_flag |= O_DIRECTORY;\n\n\tfile->f_path.dentry = DENTRY_NOT_SET;\n\tfile->f_path.mnt = nd->path.mnt;\n\terror = dir->i_op->atomic_open(dir, dentry, file,\n\t\t\t\t       open_to_namei_flags(open_flag), mode);\n\td_lookup_done(dentry);\n\tif (!error) {\n\t\tif (file->f_mode & FMODE_OPENED) {\n\t\t\tif (unlikely(dentry != file->f_path.dentry)) {\n\t\t\t\tdput(dentry);\n\t\t\t\tdentry = dget(file->f_path.dentry);\n\t\t\t}\n\t\t} else if (WARN_ON(file->f_path.dentry == DENTRY_NOT_SET)) {\n\t\t\terror = -EIO;\n\t\t} else {\n\t\t\tif (file->f_path.dentry) {\n\t\t\t\tdput(dentry);\n\t\t\t\tdentry = file->f_path.dentry;\n\t\t\t}\n\t\t\tif (unlikely(d_is_negative(dentry)))\n\t\t\t\terror = -ENOENT;\n\t\t}\n\t}\n\tif (error) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(error);\n\t}\n\treturn dentry;\n}\n\n/*\n * Look up and maybe create and open the last component.\n *\n * Must be called with parent locked (exclusive in O_CREAT case).\n *\n * Returns 0 on success, that is, if\n *  the file was successfully atomically created (if necessary) and opened, or\n *  the file was not completely opened at this time, though lookups and\n *  creations were performed.\n * These case are distinguished by presence of FMODE_OPENED on file->f_mode.\n * In the latter case dentry returned in @path might be negative if O_CREAT\n * hadn't been specified.\n *\n * An error code is returned on failure.\n */\nstatic struct dentry *lookup_open(struct nameidata *nd, struct file *file,\n\t\t\t\t  const struct open_flags *op,\n\t\t\t\t  bool got_write)\n{\n\tstruct dentry *dir = nd->path.dentry;\n\tstruct inode *dir_inode = dir->d_inode;\n\tint open_flag = op->open_flag;\n\tstruct dentry *dentry;\n\tint error, create_error = 0;\n\tumode_t mode = op->mode;\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\n\tif (unlikely(IS_DEADDIR(dir_inode)))\n\t\treturn ERR_PTR(-ENOENT);\n\n\tfile->f_mode &= ~FMODE_CREATED;\n\tdentry = d_lookup(dir, &nd->last);\n\tfor (;;) {\n\t\tif (!dentry) {\n\t\t\tdentry = d_alloc_parallel(dir, &nd->last, &wq);\n\t\t\tif (IS_ERR(dentry))\n\t\t\t\treturn dentry;\n\t\t}\n\t\tif (d_in_lookup(dentry))\n\t\t\tbreak;\n\n\t\terror = d_revalidate(dentry, nd->flags);\n\t\tif (likely(error > 0))\n\t\t\tbreak;\n\t\tif (error)\n\t\t\tgoto out_dput;\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t\tdentry = NULL;\n\t}\n\tif (dentry->d_inode) {\n\t\t/* Cached positive dentry: will open in f_op->open */\n\t\treturn dentry;\n\t}\n\n\t/*\n\t * Checking write permission is tricky, bacuse we don't know if we are\n\t * going to actually need it: O_CREAT opens should work as long as the\n\t * file exists.  But checking existence breaks atomicity.  The trick is\n\t * to check access and if not granted clear O_CREAT from the flags.\n\t *\n\t * Another problem is returing the \"right\" error value (e.g. for an\n\t * O_EXCL open we want to return EEXIST not EROFS).\n\t */\n\tif (unlikely(!got_write))\n\t\topen_flag &= ~O_TRUNC;\n\tif (open_flag & O_CREAT) {\n\t\tif (open_flag & O_EXCL)\n\t\t\topen_flag &= ~O_TRUNC;\n\t\tif (!IS_POSIXACL(dir->d_inode))\n\t\t\tmode &= ~current_umask();\n\t\tif (likely(got_write))\n\t\t\tcreate_error = may_o_create(&nd->path, dentry, mode);\n\t\telse\n\t\t\tcreate_error = -EROFS;\n\t}\n\tif (create_error)\n\t\topen_flag &= ~O_CREAT;\n\tif (dir_inode->i_op->atomic_open) {\n\t\tdentry = atomic_open(nd, dentry, file, open_flag, mode);\n\t\tif (unlikely(create_error) && dentry == ERR_PTR(-ENOENT))\n\t\t\tdentry = ERR_PTR(create_error);\n\t\treturn dentry;\n\t}\n\n\tif (d_in_lookup(dentry)) {\n\t\tstruct dentry *res = dir_inode->i_op->lookup(dir_inode, dentry,\n\t\t\t\t\t\t\t     nd->flags);\n\t\td_lookup_done(dentry);\n\t\tif (unlikely(res)) {\n\t\t\tif (IS_ERR(res)) {\n\t\t\t\terror = PTR_ERR(res);\n\t\t\t\tgoto out_dput;\n\t\t\t}\n\t\t\tdput(dentry);\n\t\t\tdentry = res;\n\t\t}\n\t}\n\n\t/* Negative dentry, just create the file */\n\tif (!dentry->d_inode && (open_flag & O_CREAT)) {\n\t\tfile->f_mode |= FMODE_CREATED;\n\t\taudit_inode_child(dir_inode, dentry, AUDIT_TYPE_CHILD_CREATE);\n\t\tif (!dir_inode->i_op->create) {\n\t\t\terror = -EACCES;\n\t\t\tgoto out_dput;\n\t\t}\n\t\terror = dir_inode->i_op->create(dir_inode, dentry, mode,\n\t\t\t\t\t\topen_flag & O_EXCL);\n\t\tif (error)\n\t\t\tgoto out_dput;\n\t}\n\tif (unlikely(create_error) && !dentry->d_inode) {\n\t\terror = create_error;\n\t\tgoto out_dput;\n\t}\n\treturn dentry;\n\nout_dput:\n\tdput(dentry);\n\treturn ERR_PTR(error);\n}\n\nstatic const char *open_last_lookups(struct nameidata *nd,\n\t\t   struct file *file, const struct open_flags *op)\n{\n\tstruct dentry *dir = nd->path.dentry;\n\tint open_flag = op->open_flag;\n\tbool got_write = false;\n\tunsigned seq;\n\tstruct inode *inode;\n\tstruct dentry *dentry;\n\tconst char *res;\n\tint error;\n\n\tnd->flags |= op->intent;\n\n\tif (nd->last_type != LAST_NORM) {\n\t\tif (nd->depth)\n\t\t\tput_link(nd);\n\t\treturn handle_dots(nd, nd->last_type);\n\t}\n\n\tif (!(open_flag & O_CREAT)) {\n\t\tif (nd->last.name[nd->last.len])\n\t\t\tnd->flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\n\t\t/* we _can_ be in RCU mode here */\n\t\tdentry = lookup_fast(nd, &inode, &seq);\n\t\tif (IS_ERR(dentry))\n\t\t\treturn ERR_CAST(dentry);\n\t\tif (likely(dentry))\n\t\t\tgoto finish_lookup;\n\n\t\tBUG_ON(nd->flags & LOOKUP_RCU);\n\t} else {\n\t\t/* create side of things */\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\terror = unlazy_walk(nd);\n\t\t\tif (unlikely(error))\n\t\t\t\treturn ERR_PTR(error);\n\t\t}\n\t\taudit_inode(nd->name, dir, AUDIT_INODE_PARENT);\n\t\t/* trailing slashes? */\n\t\tif (unlikely(nd->last.name[nd->last.len]))\n\t\t\treturn ERR_PTR(-EISDIR);\n\t}\n\n\tif (open_flag & (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) {\n\t\terror = mnt_want_write(nd->path.mnt);\n\t\tif (!error)\n\t\t\tgot_write = true;\n\t\t/*\n\t\t * do _not_ fail yet - we might not need that or fail with\n\t\t * a different error; let lookup_open() decide; we'll be\n\t\t * dropping this one anyway.\n\t\t */\n\t}\n\tif (open_flag & O_CREAT)\n\t\tinode_lock(dir->d_inode);\n\telse\n\t\tinode_lock_shared(dir->d_inode);\n\tdentry = lookup_open(nd, file, op, got_write);\n\tif (!IS_ERR(dentry) && (file->f_mode & FMODE_CREATED))\n\t\tfsnotify_create(dir->d_inode, dentry);\n\tif (open_flag & O_CREAT)\n\t\tinode_unlock(dir->d_inode);\n\telse\n\t\tinode_unlock_shared(dir->d_inode);\n\n\tif (got_write)\n\t\tmnt_drop_write(nd->path.mnt);\n\n\tif (IS_ERR(dentry))\n\t\treturn ERR_CAST(dentry);\n\n\tif (file->f_mode & (FMODE_OPENED | FMODE_CREATED)) {\n\t\tdput(nd->path.dentry);\n\t\tnd->path.dentry = dentry;\n\t\treturn NULL;\n\t}\n\nfinish_lookup:\n\tif (nd->depth)\n\t\tput_link(nd);\n\tres = step_into(nd, WALK_TRAILING, dentry, inode, seq);\n\tif (unlikely(res))\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\treturn res;\n}\n\n/*\n * Handle the last step of open()\n */\nstatic int do_open(struct nameidata *nd,\n\t\t   struct file *file, const struct open_flags *op)\n{\n\tint open_flag = op->open_flag;\n\tbool do_truncate;\n\tint acc_mode;\n\tint error;\n\n\tif (!(file->f_mode & (FMODE_OPENED | FMODE_CREATED))) {\n\t\terror = complete_walk(nd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (!(file->f_mode & FMODE_CREATED))\n\t\taudit_inode(nd->name, nd->path.dentry, 0);\n\tif (open_flag & O_CREAT) {\n\t\tif ((open_flag & O_EXCL) && !(file->f_mode & FMODE_CREATED))\n\t\t\treturn -EEXIST;\n\t\tif (d_is_dir(nd->path.dentry))\n\t\t\treturn -EISDIR;\n\t\terror = may_create_in_sticky(nd->dir_mode, nd->dir_uid,\n\t\t\t\t\t     d_backing_inode(nd->path.dentry));\n\t\tif (unlikely(error))\n\t\t\treturn error;\n\t}\n\tif ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))\n\t\treturn -ENOTDIR;\n\n\tdo_truncate = false;\n\tacc_mode = op->acc_mode;\n\tif (file->f_mode & FMODE_CREATED) {\n\t\t/* Don't check for write permission, don't truncate */\n\t\topen_flag &= ~O_TRUNC;\n\t\tacc_mode = 0;\n\t} else if (d_is_reg(nd->path.dentry) && open_flag & O_TRUNC) {\n\t\terror = mnt_want_write(nd->path.mnt);\n\t\tif (error)\n\t\t\treturn error;\n\t\tdo_truncate = true;\n\t}\n\terror = may_open(&nd->path, acc_mode, open_flag);\n\tif (!error && !(file->f_mode & FMODE_OPENED))\n\t\terror = vfs_open(&nd->path, file);\n\tif (!error)\n\t\terror = ima_file_check(file, op->acc_mode);\n\tif (!error && do_truncate)\n\t\terror = handle_truncate(file);\n\tif (unlikely(error > 0)) {\n\t\tWARN_ON(1);\n\t\terror = -EINVAL;\n\t}\n\tif (do_truncate)\n\t\tmnt_drop_write(nd->path.mnt);\n\treturn error;\n}\n\nstruct dentry *vfs_tmpfile(struct dentry *dentry, umode_t mode, int open_flag)\n{\n\tstruct dentry *child = NULL;\n\tstruct inode *dir = dentry->d_inode;\n\tstruct inode *inode;\n\tint error;\n\n\t/* we want directory to be writable */\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\tgoto out_err;\n\terror = -EOPNOTSUPP;\n\tif (!dir->i_op->tmpfile)\n\t\tgoto out_err;\n\terror = -ENOMEM;\n\tchild = d_alloc(dentry, &slash_name);\n\tif (unlikely(!child))\n\t\tgoto out_err;\n\terror = dir->i_op->tmpfile(dir, child, mode);\n\tif (error)\n\t\tgoto out_err;\n\terror = -ENOENT;\n\tinode = child->d_inode;\n\tif (unlikely(!inode))\n\t\tgoto out_err;\n\tif (!(open_flag & O_EXCL)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state |= I_LINKABLE;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tima_post_create_tmpfile(inode);\n\treturn child;\n\nout_err:\n\tdput(child);\n\treturn ERR_PTR(error);\n}\nEXPORT_SYMBOL(vfs_tmpfile);\n\nstatic int do_tmpfile(struct nameidata *nd, unsigned flags,\n\t\tconst struct open_flags *op,\n\t\tstruct file *file)\n{\n\tstruct dentry *child;\n\tstruct path path;\n\tint error = path_lookupat(nd, flags | LOOKUP_DIRECTORY, &path);\n\tif (unlikely(error))\n\t\treturn error;\n\terror = mnt_want_write(path.mnt);\n\tif (unlikely(error))\n\t\tgoto out;\n\tchild = vfs_tmpfile(path.dentry, op->mode, op->open_flag);\n\terror = PTR_ERR(child);\n\tif (IS_ERR(child))\n\t\tgoto out2;\n\tdput(path.dentry);\n\tpath.dentry = child;\n\taudit_inode(nd->name, child, 0);\n\t/* Don't check for other permissions, the inode was just created */\n\terror = may_open(&path, 0, op->open_flag);\n\tif (error)\n\t\tgoto out2;\n\tfile->f_path.mnt = path.mnt;\n\terror = finish_open(file, child, NULL);\nout2:\n\tmnt_drop_write(path.mnt);\nout:\n\tpath_put(&path);\n\treturn error;\n}\n\nstatic int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)\n{\n\tstruct path path;\n\tint error = path_lookupat(nd, flags, &path);\n\tif (!error) {\n\t\taudit_inode(nd->name, path.dentry, 0);\n\t\terror = vfs_open(&path, file);\n\t\tpath_put(&path);\n\t}\n\treturn error;\n}\n\nstatic struct file *path_openat(struct nameidata *nd,\n\t\t\tconst struct open_flags *op, unsigned flags)\n{\n\tstruct file *file;\n\tint error;\n\n\tfile = alloc_empty_file(op->open_flag, current_cred());\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tif (unlikely(file->f_flags & __O_TMPFILE)) {\n\t\terror = do_tmpfile(nd, flags, op, file);\n\t} else if (unlikely(file->f_flags & O_PATH)) {\n\t\terror = do_o_path(nd, flags, file);\n\t} else {\n\t\tconst char *s = path_init(nd, flags);\n\t\twhile (!(error = link_path_walk(s, nd)) &&\n\t\t       (s = open_last_lookups(nd, file, op)) != NULL)\n\t\t\t;\n\t\tif (!error)\n\t\t\terror = do_open(nd, file, op);\n\t\tterminate_walk(nd);\n\t}\n\tif (likely(!error)) {\n\t\tif (likely(file->f_mode & FMODE_OPENED))\n\t\t\treturn file;\n\t\tWARN_ON(1);\n\t\terror = -EINVAL;\n\t}\n\tfput(file);\n\tif (error == -EOPENSTALE) {\n\t\tif (flags & LOOKUP_RCU)\n\t\t\terror = -ECHILD;\n\t\telse\n\t\t\terror = -ESTALE;\n\t}\n\treturn ERR_PTR(error);\n}\n\nstruct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tset_nameidata(&nd, dfd, pathname);\n\tfilp = path_openat(&nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(&nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(&nd, op, flags | LOOKUP_REVAL);\n\trestore_nameidata();\n\treturn filp;\n}\n\nstruct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\tconst char *name, const struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tstruct file *file;\n\tstruct filename *filename;\n\tint flags = op->lookup_flags | LOOKUP_ROOT;\n\n\tnd.root.mnt = mnt;\n\tnd.root.dentry = dentry;\n\n\tif (d_is_symlink(dentry) && op->intent & LOOKUP_OPEN)\n\t\treturn ERR_PTR(-ELOOP);\n\n\tfilename = getname_kernel(name);\n\tif (IS_ERR(filename))\n\t\treturn ERR_CAST(filename);\n\n\tset_nameidata(&nd, -1, filename);\n\tfile = path_openat(&nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(file == ERR_PTR(-ECHILD)))\n\t\tfile = path_openat(&nd, op, flags);\n\tif (unlikely(file == ERR_PTR(-ESTALE)))\n\t\tfile = path_openat(&nd, op, flags | LOOKUP_REVAL);\n\trestore_nameidata();\n\tputname(filename);\n\treturn file;\n}\n\nstatic struct dentry *filename_create(int dfd, struct filename *name,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\tstruct dentry *dentry = ERR_PTR(-EEXIST);\n\tstruct qstr last;\n\tint type;\n\tint err2;\n\tint error;\n\tbool is_dir = (lookup_flags & LOOKUP_DIRECTORY);\n\n\t/*\n\t * Note that only LOOKUP_REVAL and LOOKUP_DIRECTORY matter here. Any\n\t * other flags passed in are ignored!\n\t */\n\tlookup_flags &= LOOKUP_REVAL;\n\n\tname = filename_parentat(dfd, name, lookup_flags, path, &last, &type);\n\tif (IS_ERR(name))\n\t\treturn ERR_CAST(name);\n\n\t/*\n\t * Yucky last component or no last component at all?\n\t * (foo/., foo/.., /////)\n\t */\n\tif (unlikely(type != LAST_NORM))\n\t\tgoto out;\n\n\t/* don't fail immediately if it's r/o, at least try to report other errors */\n\terr2 = mnt_want_write(path->mnt);\n\t/*\n\t * Do the final lookup.\n\t */\n\tlookup_flags |= LOOKUP_CREATE | LOOKUP_EXCL;\n\tinode_lock_nested(path->dentry->d_inode, I_MUTEX_PARENT);\n\tdentry = __lookup_hash(&last, path->dentry, lookup_flags);\n\tif (IS_ERR(dentry))\n\t\tgoto unlock;\n\n\terror = -EEXIST;\n\tif (d_is_positive(dentry))\n\t\tgoto fail;\n\n\t/*\n\t * Special case - lookup gave negative, but... we had foo/bar/\n\t * From the vfs_mknod() POV we just have a negative dentry -\n\t * all is fine. Let's be bastards - you had / on the end, you've\n\t * been asking for (non-existent) directory. -ENOENT for you.\n\t */\n\tif (unlikely(!is_dir && last.name[last.len])) {\n\t\terror = -ENOENT;\n\t\tgoto fail;\n\t}\n\tif (unlikely(err2)) {\n\t\terror = err2;\n\t\tgoto fail;\n\t}\n\tputname(name);\n\treturn dentry;\nfail:\n\tdput(dentry);\n\tdentry = ERR_PTR(error);\nunlock:\n\tinode_unlock(path->dentry->d_inode);\n\tif (!err2)\n\t\tmnt_drop_write(path->mnt);\nout:\n\tpath_put(path);\n\tputname(name);\n\treturn dentry;\n}\n\nstruct dentry *kern_path_create(int dfd, const char *pathname,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\treturn filename_create(dfd, getname_kernel(pathname),\n\t\t\t\tpath, lookup_flags);\n}\nEXPORT_SYMBOL(kern_path_create);\n\nvoid done_path_create(struct path *path, struct dentry *dentry)\n{\n\tdput(dentry);\n\tinode_unlock(path->dentry->d_inode);\n\tmnt_drop_write(path->mnt);\n\tpath_put(path);\n}\nEXPORT_SYMBOL(done_path_create);\n\ninline struct dentry *user_path_create(int dfd, const char __user *pathname,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\treturn filename_create(dfd, getname(pathname), path, lookup_flags);\n}\nEXPORT_SYMBOL(user_path_create);\n\nint vfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\tbool is_whiteout = S_ISCHR(mode) && dev == WHITEOUT_DEV;\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif ((S_ISCHR(mode) || S_ISBLK(mode)) && !is_whiteout &&\n\t    !capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\terror = devcgroup_inode_mknod(mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_mknod(dir, dentry, mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->mknod(dir, dentry, mode, dev);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_mknod);\n\nstatic int may_mknod(umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\tcase 0: /* zero mode translates to S_IFREG */\n\t\treturn 0;\n\tcase S_IFDIR:\n\t\treturn -EPERM;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic long do_mknodat(int dfd, const char __user *filename, umode_t mode,\n\t\tunsigned int dev)\n{\n\tstruct dentry *dentry;\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = 0;\n\n\terror = may_mknod(mode);\n\tif (error)\n\t\treturn error;\nretry:\n\tdentry = user_path_create(dfd, filename, &path, lookup_flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!IS_POSIXACL(path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = security_path_mknod(&path, dentry, mode, dev);\n\tif (error)\n\t\tgoto out;\n\tswitch (mode & S_IFMT) {\n\t\tcase 0: case S_IFREG:\n\t\t\terror = vfs_create(path.dentry->d_inode,dentry,mode,true);\n\t\t\tif (!error)\n\t\t\t\tima_post_path_mknod(dentry);\n\t\t\tbreak;\n\t\tcase S_IFCHR: case S_IFBLK:\n\t\t\terror = vfs_mknod(path.dentry->d_inode,dentry,mode,\n\t\t\t\t\tnew_decode_dev(dev));\n\t\t\tbreak;\n\t\tcase S_IFIFO: case S_IFSOCK:\n\t\t\terror = vfs_mknod(path.dentry->d_inode,dentry,mode,0);\n\t\t\tbreak;\n\t}\nout:\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode,\n\t\tunsigned int, dev)\n{\n\treturn do_mknodat(dfd, filename, mode, dev);\n}\n\nSYSCALL_DEFINE3(mknod, const char __user *, filename, umode_t, mode, unsigned, dev)\n{\n\treturn do_mknodat(AT_FDCWD, filename, mode, dev);\n}\n\nint vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error = may_create(dir, dentry);\n\tunsigned max_links = dir->i_sb->s_max_links;\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tif (max_links && dir->i_nlink >= max_links)\n\t\treturn -EMLINK;\n\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_mkdir);\n\nstatic long do_mkdirat(int dfd, const char __user *pathname, umode_t mode)\n{\n\tstruct dentry *dentry;\n\tstruct path path;\n\tint error;\n\tunsigned int lookup_flags = LOOKUP_DIRECTORY;\n\nretry:\n\tdentry = user_path_create(dfd, pathname, &path, lookup_flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (!IS_POSIXACL(path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = security_path_mkdir(&path, dentry, mode);\n\tif (!error)\n\t\terror = vfs_mkdir(path.dentry->d_inode, dentry, mode);\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}\n\nSYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode)\n{\n\treturn do_mkdirat(dfd, pathname, mode);\n}\n\nSYSCALL_DEFINE2(mkdir, const char __user *, pathname, umode_t, mode)\n{\n\treturn do_mkdirat(AT_FDCWD, pathname, mode);\n}\n\nint vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tinode_lock(dentry->d_inode);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(dentry))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tdetach_mounts(dentry);\n\tfsnotify_rmdir(dir, dentry);\n\nout:\n\tinode_unlock(dentry->d_inode);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_rmdir);\n\nlong do_rmdir(int dfd, struct filename *name)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct path path;\n\tstruct qstr last;\n\tint type;\n\tunsigned int lookup_flags = 0;\nretry:\n\tname = filename_parentat(dfd, name, lookup_flags,\n\t\t\t\t&path, &last, &type);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\tswitch (type) {\n\tcase LAST_DOTDOT:\n\t\terror = -ENOTEMPTY;\n\t\tgoto exit1;\n\tcase LAST_DOT:\n\t\terror = -EINVAL;\n\t\tgoto exit1;\n\tcase LAST_ROOT:\n\t\terror = -EBUSY;\n\t\tgoto exit1;\n\t}\n\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto exit1;\n\n\tinode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);\n\tdentry = __lookup_hash(&last, path.dentry, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto exit2;\n\tif (!dentry->d_inode) {\n\t\terror = -ENOENT;\n\t\tgoto exit3;\n\t}\n\terror = security_path_rmdir(&path, dentry);\n\tif (error)\n\t\tgoto exit3;\n\terror = vfs_rmdir(path.dentry->d_inode, dentry);\nexit3:\n\tdput(dentry);\nexit2:\n\tinode_unlock(path.dentry->d_inode);\n\tmnt_drop_write(path.mnt);\nexit1:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\tputname(name);\n\treturn error;\n}\n\nSYSCALL_DEFINE1(rmdir, const char __user *, pathname)\n{\n\treturn do_rmdir(AT_FDCWD, getname(pathname));\n}\n\n/**\n * vfs_unlink - unlink a filesystem object\n * @dir:\tparent directory\n * @dentry:\tvictim\n * @delegated_inode: returns victim inode, if the inode is delegated.\n *\n * The caller must hold dir->i_mutex.\n *\n * If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and\n * return a reference to the inode in delegated_inode.  The caller\n * should then break the delegation on that inode and retry.  Because\n * breaking a delegation may take a long time, the caller should drop\n * dir->i_mutex before doing so.\n *\n * Alternatively, a caller may pass NULL for delegated_inode.  This may\n * be appropriate for callers that expect the underlying filesystem not\n * to be NFS exported.\n */\nint vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)\n{\n\tstruct inode *target = dentry->d_inode;\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tinode_lock(target);\n\tif (is_local_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = try_break_deleg(target, delegated_inode);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error) {\n\t\t\t\tdont_mount(dentry);\n\t\t\t\tdetach_mounts(dentry);\n\t\t\t\tfsnotify_unlink(dir, dentry);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tinode_unlock(target);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(target);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_unlink);\n\n/*\n * Make sure that the actual truncation of the file will occur outside its\n * directory's i_mutex.  Truncate can take a long time if there is a lot of\n * writeout happening, and we don't want to prevent access to the directory\n * while waiting on the I/O.\n */\nlong do_unlinkat(int dfd, struct filename *name)\n{\n\tint error;\n\tstruct dentry *dentry;\n\tstruct path path;\n\tstruct qstr last;\n\tint type;\n\tstruct inode *inode = NULL;\n\tstruct inode *delegated_inode = NULL;\n\tunsigned int lookup_flags = 0;\nretry:\n\tname = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\terror = -EISDIR;\n\tif (type != LAST_NORM)\n\t\tgoto exit1;\n\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto exit1;\nretry_deleg:\n\tinode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);\n\tdentry = __lookup_hash(&last, path.dentry, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (!IS_ERR(dentry)) {\n\t\t/* Why not before? Because we want correct error value */\n\t\tif (last.name[last.len])\n\t\t\tgoto slashes;\n\t\tinode = dentry->d_inode;\n\t\tif (d_is_negative(dentry))\n\t\t\tgoto slashes;\n\t\tihold(inode);\n\t\terror = security_path_unlink(&path, dentry);\n\t\tif (error)\n\t\t\tgoto exit2;\n\t\terror = vfs_unlink(path.dentry->d_inode, dentry, &delegated_inode);\nexit2:\n\t\tdput(dentry);\n\t}\n\tinode_unlock(path.dentry->d_inode);\n\tif (inode)\n\t\tiput(inode);\t/* truncate the inode here */\n\tinode = NULL;\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(path.mnt);\nexit1:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tinode = NULL;\n\t\tgoto retry;\n\t}\n\tputname(name);\n\treturn error;\n\nslashes:\n\tif (d_is_negative(dentry))\n\t\terror = -ENOENT;\n\telse if (d_is_dir(dentry))\n\t\terror = -EISDIR;\n\telse\n\t\terror = -ENOTDIR;\n\tgoto exit2;\n}\n\nSYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)\n{\n\tif ((flag & ~AT_REMOVEDIR) != 0)\n\t\treturn -EINVAL;\n\n\tif (flag & AT_REMOVEDIR)\n\t\treturn do_rmdir(dfd, getname(pathname));\n\treturn do_unlinkat(dfd, getname(pathname));\n}\n\nSYSCALL_DEFINE1(unlink, const char __user *, pathname)\n{\n\treturn do_unlinkat(AT_FDCWD, getname(pathname));\n}\n\nint vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->symlink)\n\t\treturn -EPERM;\n\n\terror = security_inode_symlink(dir, dentry, oldname);\n\tif (error)\n\t\treturn error;\n\n\terror = dir->i_op->symlink(dir, dentry, oldname);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_symlink);\n\nstatic long do_symlinkat(const char __user *oldname, int newdfd,\n\t\t  const char __user *newname)\n{\n\tint error;\n\tstruct filename *from;\n\tstruct dentry *dentry;\n\tstruct path path;\n\tunsigned int lookup_flags = 0;\n\n\tfrom = getname(oldname);\n\tif (IS_ERR(from))\n\t\treturn PTR_ERR(from);\nretry:\n\tdentry = user_path_create(newdfd, newname, &path, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_putname;\n\n\terror = security_path_symlink(&path, dentry, from->name);\n\tif (!error)\n\t\terror = vfs_symlink(path.dentry->d_inode, dentry, from->name);\n\tdone_path_create(&path, dentry);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout_putname:\n\tputname(from);\n\treturn error;\n}\n\nSYSCALL_DEFINE3(symlinkat, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname)\n{\n\treturn do_symlinkat(oldname, newdfd, newname);\n}\n\nSYSCALL_DEFINE2(symlink, const char __user *, oldname, const char __user *, newname)\n{\n\treturn do_symlinkat(oldname, AT_FDCWD, newname);\n}\n\n/**\n * vfs_link - create a new link\n * @old_dentry:\tobject to be linked\n * @dir:\tnew parent\n * @new_dentry:\twhere to create the new link\n * @delegated_inode: returns inode needing a delegation break\n *\n * The caller must hold dir->i_mutex\n *\n * If vfs_link discovers a delegation on the to-be-linked file in need\n * of breaking, it will return -EWOULDBLOCK and return a reference to the\n * inode in delegated_inode.  The caller should then break the delegation\n * and retry.  Because breaking a delegation may take a long time, the\n * caller should drop the i_mutex before doing so.\n *\n * Alternatively, a caller may pass NULL for delegated_inode.  This may\n * be appropriate for callers that expect the underlying filesystem not\n * to be NFS exported.\n */\nint vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tunsigned max_links = dir->i_sb->s_max_links;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\terror = may_create(dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (dir->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t/*\n\t * A link to an append-only or immutable file cannot be created.\n\t */\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\t/*\n\t * Updating the link count will likely cause i_uid and i_gid to\n\t * be writen back improperly if their true value is unknown to\n\t * the vfs.\n\t */\n\tif (HAS_UNMAPPED_ID(inode))\n\t\treturn -EPERM;\n\tif (!dir->i_op->link)\n\t\treturn -EPERM;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\terror = security_inode_link(old_dentry, dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tinode_lock(inode);\n\t/* Make sure we don't allow creating hardlink to an unlinked file */\n\tif (inode->i_nlink == 0 && !(inode->i_state & I_LINKABLE))\n\t\terror =  -ENOENT;\n\telse if (max_links && inode->i_nlink >= max_links)\n\t\terror = -EMLINK;\n\telse {\n\t\terror = try_break_deleg(inode, delegated_inode);\n\t\tif (!error)\n\t\t\terror = dir->i_op->link(old_dentry, dir, new_dentry);\n\t}\n\n\tif (!error && (inode->i_state & I_LINKABLE)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state &= ~I_LINKABLE;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tinode_unlock(inode);\n\tif (!error)\n\t\tfsnotify_link(dir, inode, new_dentry);\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_link);\n\n/*\n * Hardlinks are often used in delicate situations.  We avoid\n * security-related surprises by not following symlinks on the\n * newname.  --KAB\n *\n * We don't follow them on the oldname either to be compatible\n * with linux 2.0, and to avoid hard-linking to directories\n * and other special files.  --ADM\n */\nstatic int do_linkat(int olddfd, const char __user *oldname, int newdfd,\n\t      const char __user *newname, int flags)\n{\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tstruct inode *delegated_inode = NULL;\n\tint how = 0;\n\tint error;\n\n\tif ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn -EINVAL;\n\t/*\n\t * To use null names we require CAP_DAC_READ_SEARCH\n\t * This ensures that not everyone will be able to create\n\t * handlink using the passed filedescriptor.\n\t */\n\tif (flags & AT_EMPTY_PATH) {\n\t\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\t\treturn -ENOENT;\n\t\thow = LOOKUP_EMPTY;\n\t}\n\n\tif (flags & AT_SYMLINK_FOLLOW)\n\t\thow |= LOOKUP_FOLLOW;\nretry:\n\terror = user_path_at(olddfd, oldname, how, &old_path);\n\tif (error)\n\t\treturn error;\n\n\tnew_dentry = user_path_create(newdfd, newname, &new_path,\n\t\t\t\t\t(how & LOOKUP_REVAL));\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto out;\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt)\n\t\tgoto out_dput;\n\terror = may_linkat(&old_path);\n\tif (unlikely(error))\n\t\tgoto out_dput;\n\terror = security_path_link(old_path.dentry, &new_path, new_dentry);\n\tif (error)\n\t\tgoto out_dput;\n\terror = vfs_link(old_path.dentry, new_path.dentry->d_inode, new_dentry, &delegated_inode);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error) {\n\t\t\tpath_put(&old_path);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (retry_estale(error, how)) {\n\t\tpath_put(&old_path);\n\t\thow |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\tpath_put(&old_path);\n\n\treturn error;\n}\n\nSYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname, int, flags)\n{\n\treturn do_linkat(olddfd, oldname, newdfd, newname, flags);\n}\n\nSYSCALL_DEFINE2(link, const char __user *, oldname, const char __user *, newname)\n{\n\treturn do_linkat(AT_FDCWD, oldname, AT_FDCWD, newname, 0);\n}\n\n/**\n * vfs_rename - rename a filesystem object\n * @old_dir:\tparent of source\n * @old_dentry:\tsource\n * @new_dir:\tparent of destination\n * @new_dentry:\tdestination\n * @delegated_inode: returns an inode needing a delegation break\n * @flags:\trename flags\n *\n * The caller must hold multiple mutexes--see lock_rename()).\n *\n * If vfs_rename discovers a delegation in need of breaking at either\n * the source or destination, it will return -EWOULDBLOCK and return a\n * reference to the inode in delegated_inode.  The caller should then\n * break the delegation and retry.  Because breaking a delegation may\n * take a long time, the caller should drop all locks before doing\n * so.\n *\n * Alternatively, a caller may pass NULL for delegated_inode.  This may\n * be appropriate for callers that expect the underlying filesystem not\n * to be NFS exported.\n *\n * The worst of all namespace operations - renaming directory. \"Perverted\"\n * doesn't even start to describe it. Somebody in UCB had a heck of a trip...\n * Problems:\n *\n *\ta) we can get into loop creation.\n *\tb) race potential - two innocent renames can create a loop together.\n *\t   That's where 4.4 screws up. Current fix: serialization on\n *\t   sb->s_vfs_rename_mutex. We might be more accurate, but that's another\n *\t   story.\n *\tc) we have to lock _four_ objects - parents and victim (if it exists),\n *\t   and source (if it is not a directory).\n *\t   And that - after we got ->i_mutex on parents (until then we don't know\n *\t   whether the target exists).  Solution: try to be smart with locking\n *\t   order for inodes.  We rely on the fact that tree topology may change\n *\t   only under ->s_vfs_rename_mutex _and_ that parent of the object we\n *\t   move will be locked.  Thus we can rank directories by the tree\n *\t   (ancestors first) and rank all non-directories after them.\n *\t   That works since everybody except rename does \"lock parent, lookup,\n *\t   lock child\" and rename is under ->s_vfs_rename_mutex.\n *\t   HOWEVER, it relies on the assumption that any object with ->lookup()\n *\t   has no more than 1 dentry.  If \"hybrid\" objects will ever appear,\n *\t   we'd better make sure that there's no link(2) for them.\n *\td) conversion from fhandle to dentry may come in the wrong moment - when\n *\t   we are removing the target. Solution: we will have to grab ->i_mutex\n *\t   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on\n *\t   ->i_mutex on parents, which works but leads to some truly excessive\n *\t   locking].\n */\nint vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\tstruct name_snapshot old_name;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename)\n\t\treturn -EPERM;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\ttake_dentry_name_snapshot(&old_name, old_dentry);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tinode_lock(target);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t       new_dir, new_dentry, flags);\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir) {\n\t\t\tshrink_dcache_parent(new_dentry);\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\t}\n\t\tdont_mount(new_dentry);\n\t\tdetach_mounts(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tinode_unlock(target);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, &old_name.name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, &old_dentry->d_name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\trelease_dentry_name_snapshot(&old_name);\n\n\treturn error;\n}\nEXPORT_SYMBOL(vfs_rename);\n\nint do_renameat2(int olddfd, struct filename *oldname, int newdfd,\n\t\t struct filename *newname, unsigned int flags)\n{\n\tstruct dentry *old_dentry, *new_dentry;\n\tstruct dentry *trap;\n\tstruct path old_path, new_path;\n\tstruct qstr old_last, new_last;\n\tint old_type, new_type;\n\tstruct inode *delegated_inode = NULL;\n\tstruct filename *from;\n\tstruct filename *to;\n\tunsigned int lookup_flags = 0, target_flags = LOOKUP_RENAME_TARGET;\n\tbool should_retry = false;\n\tint error = -EINVAL;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\tgoto put_both;\n\n\tif ((flags & (RENAME_NOREPLACE | RENAME_WHITEOUT)) &&\n\t    (flags & RENAME_EXCHANGE))\n\t\tgoto put_both;\n\n\tif (flags & RENAME_EXCHANGE)\n\t\ttarget_flags = 0;\n\nretry:\n\tfrom = filename_parentat(olddfd, oldname, lookup_flags, &old_path,\n\t\t\t\t\t&old_last, &old_type);\n\tif (IS_ERR(from)) {\n\t\terror = PTR_ERR(from);\n\t\tgoto put_new;\n\t}\n\n\tto = filename_parentat(newdfd, newname, lookup_flags, &new_path,\n\t\t\t\t&new_last, &new_type);\n\tif (IS_ERR(to)) {\n\t\terror = PTR_ERR(to);\n\t\tgoto exit1;\n\t}\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt)\n\t\tgoto exit2;\n\n\terror = -EBUSY;\n\tif (old_type != LAST_NORM)\n\t\tgoto exit2;\n\n\tif (flags & RENAME_NOREPLACE)\n\t\terror = -EEXIST;\n\tif (new_type != LAST_NORM)\n\t\tgoto exit2;\n\n\terror = mnt_want_write(old_path.mnt);\n\tif (error)\n\t\tgoto exit2;\n\nretry_deleg:\n\ttrap = lock_rename(new_path.dentry, old_path.dentry);\n\n\told_dentry = __lookup_hash(&old_last, old_path.dentry, lookup_flags);\n\terror = PTR_ERR(old_dentry);\n\tif (IS_ERR(old_dentry))\n\t\tgoto exit3;\n\t/* source must exist */\n\terror = -ENOENT;\n\tif (d_is_negative(old_dentry))\n\t\tgoto exit4;\n\tnew_dentry = __lookup_hash(&new_last, new_path.dentry, lookup_flags | target_flags);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto exit4;\n\terror = -EEXIST;\n\tif ((flags & RENAME_NOREPLACE) && d_is_positive(new_dentry))\n\t\tgoto exit5;\n\tif (flags & RENAME_EXCHANGE) {\n\t\terror = -ENOENT;\n\t\tif (d_is_negative(new_dentry))\n\t\t\tgoto exit5;\n\n\t\tif (!d_is_dir(new_dentry)) {\n\t\t\terror = -ENOTDIR;\n\t\t\tif (new_last.name[new_last.len])\n\t\t\t\tgoto exit5;\n\t\t}\n\t}\n\t/* unless the source is a directory trailing slashes give -ENOTDIR */\n\tif (!d_is_dir(old_dentry)) {\n\t\terror = -ENOTDIR;\n\t\tif (old_last.name[old_last.len])\n\t\t\tgoto exit5;\n\t\tif (!(flags & RENAME_EXCHANGE) && new_last.name[new_last.len])\n\t\t\tgoto exit5;\n\t}\n\t/* source should not be ancestor of target */\n\terror = -EINVAL;\n\tif (old_dentry == trap)\n\t\tgoto exit5;\n\t/* target should not be an ancestor of source */\n\tif (!(flags & RENAME_EXCHANGE))\n\t\terror = -ENOTEMPTY;\n\tif (new_dentry == trap)\n\t\tgoto exit5;\n\n\terror = security_path_rename(&old_path, old_dentry,\n\t\t\t\t     &new_path, new_dentry, flags);\n\tif (error)\n\t\tgoto exit5;\n\terror = vfs_rename(old_path.dentry->d_inode, old_dentry,\n\t\t\t   new_path.dentry->d_inode, new_dentry,\n\t\t\t   &delegated_inode, flags);\nexit5:\n\tdput(new_dentry);\nexit4:\n\tdput(old_dentry);\nexit3:\n\tunlock_rename(new_path.dentry, old_path.dentry);\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(old_path.mnt);\nexit2:\n\tif (retry_estale(error, lookup_flags))\n\t\tshould_retry = true;\n\tpath_put(&new_path);\n\tputname(to);\nexit1:\n\tpath_put(&old_path);\n\tputname(from);\n\tif (should_retry) {\n\t\tshould_retry = false;\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\nput_both:\n\tif (!IS_ERR(oldname))\n\t\tputname(oldname);\nput_new:\n\tif (!IS_ERR(newname))\n\t\tputname(newname);\n\treturn error;\n}\n\nSYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname, unsigned int, flags)\n{\n\treturn do_renameat2(olddfd, getname(oldname), newdfd, getname(newname),\n\t\t\t\tflags);\n}\n\nSYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname)\n{\n\treturn do_renameat2(olddfd, getname(oldname), newdfd, getname(newname),\n\t\t\t\t0);\n}\n\nSYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)\n{\n\treturn do_renameat2(AT_FDCWD, getname(oldname), AT_FDCWD,\n\t\t\t\tgetname(newname), 0);\n}\n\nint readlink_copy(char __user *buffer, int buflen, const char *link)\n{\n\tint len = PTR_ERR(link);\n\tif (IS_ERR(link))\n\t\tgoto out;\n\n\tlen = strlen(link);\n\tif (len > (unsigned) buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, link, len))\n\t\tlen = -EFAULT;\nout:\n\treturn len;\n}\n\n/**\n * vfs_readlink - copy symlink body into userspace buffer\n * @dentry: dentry on which to get symbolic link\n * @buffer: user memory pointer\n * @buflen: size of buffer\n *\n * Does not touch atime.  That's up to the caller if necessary\n *\n * Does not call security hook.\n */\nint vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tDEFINE_DELAYED_CALL(done);\n\tconst char *link;\n\tint res;\n\n\tif (unlikely(!(inode->i_opflags & IOP_DEFAULT_READLINK))) {\n\t\tif (unlikely(inode->i_op->readlink))\n\t\t\treturn inode->i_op->readlink(dentry, buffer, buflen);\n\n\t\tif (!d_is_symlink(dentry))\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_opflags |= IOP_DEFAULT_READLINK;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\n\tlink = READ_ONCE(inode->i_link);\n\tif (!link) {\n\t\tlink = inode->i_op->get_link(dentry, inode, &done);\n\t\tif (IS_ERR(link))\n\t\t\treturn PTR_ERR(link);\n\t}\n\tres = readlink_copy(buffer, buflen, link);\n\tdo_delayed_call(&done);\n\treturn res;\n}\nEXPORT_SYMBOL(vfs_readlink);\n\n/**\n * vfs_get_link - get symlink body\n * @dentry: dentry on which to get symbolic link\n * @done: caller needs to free returned data with this\n *\n * Calls security hook and i_op->get_link() on the supplied inode.\n *\n * It does not touch atime.  That's up to the caller if necessary.\n *\n * Does not work on \"special\" symlinks like /proc/$$/fd/N\n */\nconst char *vfs_get_link(struct dentry *dentry, struct delayed_call *done)\n{\n\tconst char *res = ERR_PTR(-EINVAL);\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (d_is_symlink(dentry)) {\n\t\tres = ERR_PTR(security_inode_readlink(dentry));\n\t\tif (!res)\n\t\t\tres = inode->i_op->get_link(dentry, inode, done);\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL(vfs_get_link);\n\n/* get the link contents into pagecache */\nconst char *page_get_link(struct dentry *dentry, struct inode *inode,\n\t\t\t  struct delayed_call *callback)\n{\n\tchar *kaddr;\n\tstruct page *page;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\tif (!dentry) {\n\t\tpage = find_get_page(mapping, 0);\n\t\tif (!page)\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\tif (!PageUptodate(page)) {\n\t\t\tput_page(page);\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\t}\n\t} else {\n\t\tpage = read_mapping_page(mapping, 0, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn (char*)page;\n\t}\n\tset_delayed_call(callback, page_put_link, page);\n\tBUG_ON(mapping_gfp_mask(mapping) & __GFP_HIGHMEM);\n\tkaddr = page_address(page);\n\tnd_terminate_link(kaddr, inode->i_size, PAGE_SIZE - 1);\n\treturn kaddr;\n}\n\nEXPORT_SYMBOL(page_get_link);\n\nvoid page_put_link(void *arg)\n{\n\tput_page(arg);\n}\nEXPORT_SYMBOL(page_put_link);\n\nint page_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tDEFINE_DELAYED_CALL(done);\n\tint res = readlink_copy(buffer, buflen,\n\t\t\t\tpage_get_link(dentry, d_inode(dentry),\n\t\t\t\t\t      &done));\n\tdo_delayed_call(&done);\n\treturn res;\n}\nEXPORT_SYMBOL(page_readlink);\n\n/*\n * The nofs argument instructs pagecache_write_begin to pass AOP_FLAG_NOFS\n */\nint __page_symlink(struct inode *inode, const char *symname, int len, int nofs)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\tunsigned int flags = 0;\n\tif (nofs)\n\t\tflags |= AOP_FLAG_NOFS;\n\nretry:\n\terr = pagecache_write_begin(NULL, mapping, 0, len-1,\n\t\t\t\tflags, &page, &fsdata);\n\tif (err)\n\t\tgoto fail;\n\n\tmemcpy(page_address(page), symname, len-1);\n\n\terr = pagecache_write_end(NULL, mapping, 0, len-1, len-1,\n\t\t\t\t\t\t\tpage, fsdata);\n\tif (err < 0)\n\t\tgoto fail;\n\tif (err < len-1)\n\t\tgoto retry;\n\n\tmark_inode_dirty(inode);\n\treturn 0;\nfail:\n\treturn err;\n}\nEXPORT_SYMBOL(__page_symlink);\n\nint page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!mapping_gfp_constraint(inode->i_mapping, __GFP_FS));\n}\nEXPORT_SYMBOL(page_symlink);\n\nconst struct inode_operations page_symlink_inode_operations = {\n\t.get_link\t= page_get_link,\n};\nEXPORT_SYMBOL(page_symlink_inode_operations);\n"}, "1": {"id": 1, "path": "/src/include/linux/syscalls.h", "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * syscalls.h - Linux syscall interfaces (non-arch-specific)\n *\n * Copyright (c) 2004 Randy Dunlap\n * Copyright (c) 2004 Open Source Development Labs\n */\n\n#ifndef _LINUX_SYSCALLS_H\n#define _LINUX_SYSCALLS_H\n\nstruct __aio_sigset;\nstruct epoll_event;\nstruct iattr;\nstruct inode;\nstruct iocb;\nstruct io_event;\nstruct iovec;\nstruct __kernel_old_itimerval;\nstruct kexec_segment;\nstruct linux_dirent;\nstruct linux_dirent64;\nstruct list_head;\nstruct mmap_arg_struct;\nstruct msgbuf;\nstruct user_msghdr;\nstruct mmsghdr;\nstruct msqid_ds;\nstruct new_utsname;\nstruct nfsctl_arg;\nstruct __old_kernel_stat;\nstruct oldold_utsname;\nstruct old_utsname;\nstruct pollfd;\nstruct rlimit;\nstruct rlimit64;\nstruct rusage;\nstruct sched_param;\nstruct sched_attr;\nstruct sel_arg_struct;\nstruct semaphore;\nstruct sembuf;\nstruct shmid_ds;\nstruct sockaddr;\nstruct stat;\nstruct stat64;\nstruct statfs;\nstruct statfs64;\nstruct statx;\nstruct sysinfo;\nstruct timespec;\nstruct __kernel_old_timeval;\nstruct __kernel_timex;\nstruct timezone;\nstruct tms;\nstruct utimbuf;\nstruct mq_attr;\nstruct compat_stat;\nstruct old_timeval32;\nstruct robust_list_head;\nstruct getcpu_cache;\nstruct old_linux_dirent;\nstruct perf_event_attr;\nstruct file_handle;\nstruct sigaltstack;\nstruct rseq;\nunion bpf_attr;\nstruct io_uring_params;\nstruct clone_args;\nstruct open_how;\n\n#include <linux/types.h>\n#include <linux/aio_abi.h>\n#include <linux/capability.h>\n#include <linux/signal.h>\n#include <linux/list.h>\n#include <linux/bug.h>\n#include <linux/sem.h>\n#include <asm/siginfo.h>\n#include <linux/unistd.h>\n#include <linux/quota.h>\n#include <linux/key.h>\n#include <linux/personality.h>\n#include <trace/syscall.h>\n\n#ifdef CONFIG_ARCH_HAS_SYSCALL_WRAPPER\n/*\n * It may be useful for an architecture to override the definitions of the\n * SYSCALL_DEFINE0() and __SYSCALL_DEFINEx() macros, in particular to use a\n * different calling convention for syscalls. To allow for that, the prototypes\n * for the sys_*() functions below will *not* be included if\n * CONFIG_ARCH_HAS_SYSCALL_WRAPPER is enabled.\n */\n#include <asm/syscall_wrapper.h>\n#endif /* CONFIG_ARCH_HAS_SYSCALL_WRAPPER */\n\n/*\n * __MAP - apply a macro to syscall arguments\n * __MAP(n, m, t1, a1, t2, a2, ..., tn, an) will expand to\n *    m(t1, a1), m(t2, a2), ..., m(tn, an)\n * The first argument must be equal to the amount of type/name\n * pairs given.  Note that this list of pairs (i.e. the arguments\n * of __MAP starting at the third one) is in the same format as\n * for SYSCALL_DEFINE<n>/COMPAT_SYSCALL_DEFINE<n>\n */\n#define __MAP0(m,...)\n#define __MAP1(m,t,a,...) m(t,a)\n#define __MAP2(m,t,a,...) m(t,a), __MAP1(m,__VA_ARGS__)\n#define __MAP3(m,t,a,...) m(t,a), __MAP2(m,__VA_ARGS__)\n#define __MAP4(m,t,a,...) m(t,a), __MAP3(m,__VA_ARGS__)\n#define __MAP5(m,t,a,...) m(t,a), __MAP4(m,__VA_ARGS__)\n#define __MAP6(m,t,a,...) m(t,a), __MAP5(m,__VA_ARGS__)\n#define __MAP(n,...) __MAP##n(__VA_ARGS__)\n\n#define __SC_DECL(t, a)\tt a\n#define __TYPE_AS(t, v)\t__same_type((__force t)0, v)\n#define __TYPE_IS_L(t)\t(__TYPE_AS(t, 0L))\n#define __TYPE_IS_UL(t)\t(__TYPE_AS(t, 0UL))\n#define __TYPE_IS_LL(t) (__TYPE_AS(t, 0LL) || __TYPE_AS(t, 0ULL))\n#define __SC_LONG(t, a) __typeof(__builtin_choose_expr(__TYPE_IS_LL(t), 0LL, 0L)) a\n#define __SC_CAST(t, a)\t(__force t) a\n#define __SC_ARGS(t, a)\ta\n#define __SC_TEST(t, a) (void)BUILD_BUG_ON_ZERO(!__TYPE_IS_LL(t) && sizeof(t) > sizeof(long))\n\n#ifdef CONFIG_FTRACE_SYSCALLS\n#define __SC_STR_ADECL(t, a)\t#a\n#define __SC_STR_TDECL(t, a)\t#t\n\nextern struct trace_event_class event_class_syscall_enter;\nextern struct trace_event_class event_class_syscall_exit;\nextern struct trace_event_functions enter_syscall_print_funcs;\nextern struct trace_event_functions exit_syscall_print_funcs;\n\n#define SYSCALL_TRACE_ENTER_EVENT(sname)\t\t\t\t\\\n\tstatic struct syscall_metadata __syscall_meta_##sname;\t\t\\\n\tstatic struct trace_event_call __used\t\t\t\t\\\n\t  event_enter_##sname = {\t\t\t\t\t\\\n\t\t.class\t\t\t= &event_class_syscall_enter,\t\\\n\t\t{\t\t\t\t\t\t\t\\\n\t\t\t.name                   = \"sys_enter\"#sname,\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.event.funcs            = &enter_syscall_print_funcs,\t\\\n\t\t.data\t\t\t= (void *)&__syscall_meta_##sname,\\\n\t\t.flags                  = TRACE_EVENT_FL_CAP_ANY,\t\\\n\t};\t\t\t\t\t\t\t\t\\\n\tstatic struct trace_event_call __used\t\t\t\t\\\n\t  __section(\"_ftrace_events\")\t\t\t\t\t\\\n\t *__event_enter_##sname = &event_enter_##sname;\n\n#define SYSCALL_TRACE_EXIT_EVENT(sname)\t\t\t\t\t\\\n\tstatic struct syscall_metadata __syscall_meta_##sname;\t\t\\\n\tstatic struct trace_event_call __used\t\t\t\t\\\n\t  event_exit_##sname = {\t\t\t\t\t\\\n\t\t.class\t\t\t= &event_class_syscall_exit,\t\\\n\t\t{\t\t\t\t\t\t\t\\\n\t\t\t.name                   = \"sys_exit\"#sname,\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.event.funcs\t\t= &exit_syscall_print_funcs,\t\\\n\t\t.data\t\t\t= (void *)&__syscall_meta_##sname,\\\n\t\t.flags                  = TRACE_EVENT_FL_CAP_ANY,\t\\\n\t};\t\t\t\t\t\t\t\t\\\n\tstatic struct trace_event_call __used\t\t\t\t\\\n\t  __section(\"_ftrace_events\")\t\t\t\t\t\\\n\t*__event_exit_##sname = &event_exit_##sname;\n\n#define SYSCALL_METADATA(sname, nb, ...)\t\t\t\\\n\tstatic const char *types_##sname[] = {\t\t\t\\\n\t\t__MAP(nb,__SC_STR_TDECL,__VA_ARGS__)\t\t\\\n\t};\t\t\t\t\t\t\t\\\n\tstatic const char *args_##sname[] = {\t\t\t\\\n\t\t__MAP(nb,__SC_STR_ADECL,__VA_ARGS__)\t\t\\\n\t};\t\t\t\t\t\t\t\\\n\tSYSCALL_TRACE_ENTER_EVENT(sname);\t\t\t\\\n\tSYSCALL_TRACE_EXIT_EVENT(sname);\t\t\t\\\n\tstatic struct syscall_metadata __used\t\t\t\\\n\t  __syscall_meta_##sname = {\t\t\t\t\\\n\t\t.name \t\t= \"sys\"#sname,\t\t\t\\\n\t\t.syscall_nr\t= -1,\t/* Filled in at boot */\t\\\n\t\t.nb_args \t= nb,\t\t\t\t\\\n\t\t.types\t\t= nb ? types_##sname : NULL,\t\\\n\t\t.args\t\t= nb ? args_##sname : NULL,\t\\\n\t\t.enter_event\t= &event_enter_##sname,\t\t\\\n\t\t.exit_event\t= &event_exit_##sname,\t\t\\\n\t\t.enter_fields\t= LIST_HEAD_INIT(__syscall_meta_##sname.enter_fields), \\\n\t};\t\t\t\t\t\t\t\\\n\tstatic struct syscall_metadata __used\t\t\t\\\n\t  __section(\"__syscalls_metadata\")\t\t\t\\\n\t *__p_syscall_meta_##sname = &__syscall_meta_##sname;\n\nstatic inline int is_syscall_trace_event(struct trace_event_call *tp_event)\n{\n\treturn tp_event->class == &event_class_syscall_enter ||\n\t       tp_event->class == &event_class_syscall_exit;\n}\n\n#else\n#define SYSCALL_METADATA(sname, nb, ...)\n\nstatic inline int is_syscall_trace_event(struct trace_event_call *tp_event)\n{\n\treturn 0;\n}\n#endif\n\n#ifndef SYSCALL_DEFINE0\n#define SYSCALL_DEFINE0(sname)\t\t\t\t\t\\\n\tSYSCALL_METADATA(_##sname, 0);\t\t\t\t\\\n\tasmlinkage long sys_##sname(void);\t\t\t\\\n\tALLOW_ERROR_INJECTION(sys_##sname, ERRNO);\t\t\\\n\tasmlinkage long sys_##sname(void)\n#endif /* SYSCALL_DEFINE0 */\n\n#define SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)\n#define SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)\n#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)\n#define SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)\n#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)\n#define SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)\n\n#define SYSCALL_DEFINE_MAXARGS\t6\n\n#define SYSCALL_DEFINEx(x, sname, ...)\t\t\t\t\\\n\tSYSCALL_METADATA(sname, x, __VA_ARGS__)\t\t\t\\\n\t__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)\n\n#define __PROTECT(...) asmlinkage_protect(__VA_ARGS__)\n\n/*\n * The asmlinkage stub is aliased to a function named __se_sys_*() which\n * sign-extends 32-bit ints to longs whenever needed. The actual work is\n * done within __do_sys_*().\n */\n#ifndef __SYSCALL_DEFINEx\n#define __SYSCALL_DEFINEx(x, name, ...)\t\t\t\t\t\\\n\t__diag_push();\t\t\t\t\t\t\t\\\n\t__diag_ignore(GCC, 8, \"-Wattribute-alias\",\t\t\t\\\n\t\t      \"Type aliasing is used to sanitize syscall arguments\");\\\n\tasmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))\t\\\n\t\t__attribute__((alias(__stringify(__se_sys##name))));\t\\\n\tALLOW_ERROR_INJECTION(sys##name, ERRNO);\t\t\t\\\n\tstatic inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\\\n\tasmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));\t\\\n\tasmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tlong ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\\\n\t\t__MAP(x,__SC_TEST,__VA_ARGS__);\t\t\t\t\\\n\t\t__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t__diag_pop();\t\t\t\t\t\t\t\\\n\tstatic inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))\n#endif /* __SYSCALL_DEFINEx */\n\n/*\n * Called before coming back to user-mode. Returning to user-mode with an\n * address limit different than USER_DS can allow to overwrite kernel memory.\n */\nstatic inline void addr_limit_user_check(void)\n{\n#ifdef TIF_FSCHECK\n\tif (!test_thread_flag(TIF_FSCHECK))\n\t\treturn;\n#endif\n\n\tif (CHECK_DATA_CORRUPTION(uaccess_kernel(),\n\t\t\t\t  \"Invalid address limit on user-mode return\"))\n\t\tforce_sig(SIGKILL);\n\n#ifdef TIF_FSCHECK\n\tclear_thread_flag(TIF_FSCHECK);\n#endif\n}\n\n/*\n * These syscall function prototypes are kept in the same order as\n * include/uapi/asm-generic/unistd.h. Architecture specific entries go below,\n * followed by deprecated or obsolete system calls.\n *\n * Please note that these prototypes here are only provided for information\n * purposes, for static analysis, and for linking from the syscall table.\n * These functions should not be called elsewhere from kernel code.\n *\n * As the syscall calling convention may be different from the default\n * for architectures overriding the syscall calling convention, do not\n * include the prototypes if CONFIG_ARCH_HAS_SYSCALL_WRAPPER is enabled.\n */\n#ifndef CONFIG_ARCH_HAS_SYSCALL_WRAPPER\nasmlinkage long sys_io_setup(unsigned nr_reqs, aio_context_t __user *ctx);\nasmlinkage long sys_io_destroy(aio_context_t ctx);\nasmlinkage long sys_io_submit(aio_context_t, long,\n\t\t\tstruct iocb __user * __user *);\nasmlinkage long sys_io_cancel(aio_context_t ctx_id, struct iocb __user *iocb,\n\t\t\t      struct io_event __user *result);\nasmlinkage long sys_io_getevents(aio_context_t ctx_id,\n\t\t\t\tlong min_nr,\n\t\t\t\tlong nr,\n\t\t\t\tstruct io_event __user *events,\n\t\t\t\tstruct __kernel_timespec __user *timeout);\nasmlinkage long sys_io_getevents_time32(__u32 ctx_id,\n\t\t\t\t__s32 min_nr,\n\t\t\t\t__s32 nr,\n\t\t\t\tstruct io_event __user *events,\n\t\t\t\tstruct old_timespec32 __user *timeout);\nasmlinkage long sys_io_pgetevents(aio_context_t ctx_id,\n\t\t\t\tlong min_nr,\n\t\t\t\tlong nr,\n\t\t\t\tstruct io_event __user *events,\n\t\t\t\tstruct __kernel_timespec __user *timeout,\n\t\t\t\tconst struct __aio_sigset *sig);\nasmlinkage long sys_io_pgetevents_time32(aio_context_t ctx_id,\n\t\t\t\tlong min_nr,\n\t\t\t\tlong nr,\n\t\t\t\tstruct io_event __user *events,\n\t\t\t\tstruct old_timespec32 __user *timeout,\n\t\t\t\tconst struct __aio_sigset *sig);\nasmlinkage long sys_io_uring_setup(u32 entries,\n\t\t\t\tstruct io_uring_params __user *p);\nasmlinkage long sys_io_uring_enter(unsigned int fd, u32 to_submit,\n\t\t\t\tu32 min_complete, u32 flags,\n\t\t\t\tconst void __user *argp, size_t argsz);\nasmlinkage long sys_io_uring_register(unsigned int fd, unsigned int op,\n\t\t\t\tvoid __user *arg, unsigned int nr_args);\n\n/* fs/xattr.c */\nasmlinkage long sys_setxattr(const char __user *path, const char __user *name,\n\t\t\t     const void __user *value, size_t size, int flags);\nasmlinkage long sys_lsetxattr(const char __user *path, const char __user *name,\n\t\t\t      const void __user *value, size_t size, int flags);\nasmlinkage long sys_fsetxattr(int fd, const char __user *name,\n\t\t\t      const void __user *value, size_t size, int flags);\nasmlinkage long sys_getxattr(const char __user *path, const char __user *name,\n\t\t\t     void __user *value, size_t size);\nasmlinkage long sys_lgetxattr(const char __user *path, const char __user *name,\n\t\t\t      void __user *value, size_t size);\nasmlinkage long sys_fgetxattr(int fd, const char __user *name,\n\t\t\t      void __user *value, size_t size);\nasmlinkage long sys_listxattr(const char __user *path, char __user *list,\n\t\t\t      size_t size);\nasmlinkage long sys_llistxattr(const char __user *path, char __user *list,\n\t\t\t       size_t size);\nasmlinkage long sys_flistxattr(int fd, char __user *list, size_t size);\nasmlinkage long sys_removexattr(const char __user *path,\n\t\t\t\tconst char __user *name);\nasmlinkage long sys_lremovexattr(const char __user *path,\n\t\t\t\t const char __user *name);\nasmlinkage long sys_fremovexattr(int fd, const char __user *name);\n\n/* fs/dcache.c */\nasmlinkage long sys_getcwd(char __user *buf, unsigned long size);\n\n/* fs/cookies.c */\nasmlinkage long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);\n\n/* fs/eventfd.c */\nasmlinkage long sys_eventfd2(unsigned int count, int flags);\n\n/* fs/eventpoll.c */\nasmlinkage long sys_epoll_create1(int flags);\nasmlinkage long sys_epoll_ctl(int epfd, int op, int fd,\n\t\t\t\tstruct epoll_event __user *event);\nasmlinkage long sys_epoll_pwait(int epfd, struct epoll_event __user *events,\n\t\t\t\tint maxevents, int timeout,\n\t\t\t\tconst sigset_t __user *sigmask,\n\t\t\t\tsize_t sigsetsize);\n\n/* fs/fcntl.c */\nasmlinkage long sys_dup(unsigned int fildes);\nasmlinkage long sys_dup3(unsigned int oldfd, unsigned int newfd, int flags);\nasmlinkage long sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg);\n#if BITS_PER_LONG == 32\nasmlinkage long sys_fcntl64(unsigned int fd,\n\t\t\t\tunsigned int cmd, unsigned long arg);\n#endif\n\n/* fs/inotify_user.c */\nasmlinkage long sys_inotify_init1(int flags);\nasmlinkage long sys_inotify_add_watch(int fd, const char __user *path,\n\t\t\t\t\tu32 mask);\nasmlinkage long sys_inotify_rm_watch(int fd, __s32 wd);\n\n/* fs/ioctl.c */\nasmlinkage long sys_ioctl(unsigned int fd, unsigned int cmd,\n\t\t\t\tunsigned long arg);\n\n/* fs/ioprio.c */\nasmlinkage long sys_ioprio_set(int which, int who, int ioprio);\nasmlinkage long sys_ioprio_get(int which, int who);\n\n/* fs/locks.c */\nasmlinkage long sys_flock(unsigned int fd, unsigned int cmd);\n\n/* fs/namei.c */\nasmlinkage long sys_mknodat(int dfd, const char __user * filename, umode_t mode,\n\t\t\t    unsigned dev);\nasmlinkage long sys_mkdirat(int dfd, const char __user * pathname, umode_t mode);\nasmlinkage long sys_unlinkat(int dfd, const char __user * pathname, int flag);\nasmlinkage long sys_symlinkat(const char __user * oldname,\n\t\t\t      int newdfd, const char __user * newname);\nasmlinkage long sys_linkat(int olddfd, const char __user *oldname,\n\t\t\t   int newdfd, const char __user *newname, int flags);\nasmlinkage long sys_renameat(int olddfd, const char __user * oldname,\n\t\t\t     int newdfd, const char __user * newname);\n\n/* fs/namespace.c */\nasmlinkage long sys_umount(char __user *name, int flags);\nasmlinkage long sys_mount(char __user *dev_name, char __user *dir_name,\n\t\t\t\tchar __user *type, unsigned long flags,\n\t\t\t\tvoid __user *data);\nasmlinkage long sys_pivot_root(const char __user *new_root,\n\t\t\t\tconst char __user *put_old);\n\n/* fs/nfsctl.c */\n\n/* fs/open.c */\nasmlinkage long sys_statfs(const char __user * path,\n\t\t\t\tstruct statfs __user *buf);\nasmlinkage long sys_statfs64(const char __user *path, size_t sz,\n\t\t\t\tstruct statfs64 __user *buf);\nasmlinkage long sys_fstatfs(unsigned int fd, struct statfs __user *buf);\nasmlinkage long sys_fstatfs64(unsigned int fd, size_t sz,\n\t\t\t\tstruct statfs64 __user *buf);\nasmlinkage long sys_truncate(const char __user *path, long length);\nasmlinkage long sys_ftruncate(unsigned int fd, unsigned long length);\n#if BITS_PER_LONG == 32\nasmlinkage long sys_truncate64(const char __user *path, loff_t length);\nasmlinkage long sys_ftruncate64(unsigned int fd, loff_t length);\n#endif\nasmlinkage long sys_fallocate(int fd, int mode, loff_t offset, loff_t len);\nasmlinkage long sys_faccessat(int dfd, const char __user *filename, int mode);\nasmlinkage long sys_faccessat2(int dfd, const char __user *filename, int mode,\n\t\t\t       int flags);\nasmlinkage long sys_chdir(const char __user *filename);\nasmlinkage long sys_fchdir(unsigned int fd);\nasmlinkage long sys_chroot(const char __user *filename);\nasmlinkage long sys_fchmod(unsigned int fd, umode_t mode);\nasmlinkage long sys_fchmodat(int dfd, const char __user * filename,\n\t\t\t     umode_t mode);\nasmlinkage long sys_fchownat(int dfd, const char __user *filename, uid_t user,\n\t\t\t     gid_t group, int flag);\nasmlinkage long sys_fchown(unsigned int fd, uid_t user, gid_t group);\nasmlinkage long sys_openat(int dfd, const char __user *filename, int flags,\n\t\t\t   umode_t mode);\nasmlinkage long sys_openat2(int dfd, const char __user *filename,\n\t\t\t    struct open_how *how, size_t size);\nasmlinkage long sys_close(unsigned int fd);\nasmlinkage long sys_close_range(unsigned int fd, unsigned int max_fd,\n\t\t\t\tunsigned int flags);\nasmlinkage long sys_vhangup(void);\n\n/* fs/pipe.c */\nasmlinkage long sys_pipe2(int __user *fildes, int flags);\n\n/* fs/quota.c */\nasmlinkage long sys_quotactl(unsigned int cmd, const char __user *special,\n\t\t\t\tqid_t id, void __user *addr);\n\n/* fs/readdir.c */\nasmlinkage long sys_getdents64(unsigned int fd,\n\t\t\t\tstruct linux_dirent64 __user *dirent,\n\t\t\t\tunsigned int count);\n\n/* fs/read_write.c */\nasmlinkage long sys_llseek(unsigned int fd, unsigned long offset_high,\n\t\t\tunsigned long offset_low, loff_t __user *result,\n\t\t\tunsigned int whence);\nasmlinkage long sys_lseek(unsigned int fd, off_t offset,\n\t\t\t  unsigned int whence);\nasmlinkage long sys_read(unsigned int fd, char __user *buf, size_t count);\nasmlinkage long sys_write(unsigned int fd, const char __user *buf,\n\t\t\t  size_t count);\nasmlinkage long sys_readv(unsigned long fd,\n\t\t\t  const struct iovec __user *vec,\n\t\t\t  unsigned long vlen);\nasmlinkage long sys_writev(unsigned long fd,\n\t\t\t   const struct iovec __user *vec,\n\t\t\t   unsigned long vlen);\nasmlinkage long sys_pread64(unsigned int fd, char __user *buf,\n\t\t\t    size_t count, loff_t pos);\nasmlinkage long sys_pwrite64(unsigned int fd, const char __user *buf,\n\t\t\t     size_t count, loff_t pos);\nasmlinkage long sys_preadv(unsigned long fd, const struct iovec __user *vec,\n\t\t\t   unsigned long vlen, unsigned long pos_l, unsigned long pos_h);\nasmlinkage long sys_pwritev(unsigned long fd, const struct iovec __user *vec,\n\t\t\t    unsigned long vlen, unsigned long pos_l, unsigned long pos_h);\n\n/* fs/sendfile.c */\nasmlinkage long sys_sendfile64(int out_fd, int in_fd,\n\t\t\t       loff_t __user *offset, size_t count);\n\n/* fs/select.c */\nasmlinkage long sys_pselect6(int, fd_set __user *, fd_set __user *,\n\t\t\t     fd_set __user *, struct __kernel_timespec __user *,\n\t\t\t     void __user *);\nasmlinkage long sys_pselect6_time32(int, fd_set __user *, fd_set __user *,\n\t\t\t     fd_set __user *, struct old_timespec32 __user *,\n\t\t\t     void __user *);\nasmlinkage long sys_ppoll(struct pollfd __user *, unsigned int,\n\t\t\t  struct __kernel_timespec __user *, const sigset_t __user *,\n\t\t\t  size_t);\nasmlinkage long sys_ppoll_time32(struct pollfd __user *, unsigned int,\n\t\t\t  struct old_timespec32 __user *, const sigset_t __user *,\n\t\t\t  size_t);\n\n/* fs/signalfd.c */\nasmlinkage long sys_signalfd4(int ufd, sigset_t __user *user_mask, size_t sizemask, int flags);\n\n/* fs/splice.c */\nasmlinkage long sys_vmsplice(int fd, const struct iovec __user *iov,\n\t\t\t     unsigned long nr_segs, unsigned int flags);\nasmlinkage long sys_splice(int fd_in, loff_t __user *off_in,\n\t\t\t   int fd_out, loff_t __user *off_out,\n\t\t\t   size_t len, unsigned int flags);\nasmlinkage long sys_tee(int fdin, int fdout, size_t len, unsigned int flags);\n\n/* fs/stat.c */\nasmlinkage long sys_readlinkat(int dfd, const char __user *path, char __user *buf,\n\t\t\t       int bufsiz);\nasmlinkage long sys_newfstatat(int dfd, const char __user *filename,\n\t\t\t       struct stat __user *statbuf, int flag);\nasmlinkage long sys_newfstat(unsigned int fd, struct stat __user *statbuf);\n#if defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64)\nasmlinkage long sys_fstat64(unsigned long fd, struct stat64 __user *statbuf);\nasmlinkage long sys_fstatat64(int dfd, const char __user *filename,\n\t\t\t       struct stat64 __user *statbuf, int flag);\n#endif\n\n/* fs/sync.c */\nasmlinkage long sys_sync(void);\nasmlinkage long sys_fsync(unsigned int fd);\nasmlinkage long sys_fdatasync(unsigned int fd);\nasmlinkage long sys_sync_file_range2(int fd, unsigned int flags,\n\t\t\t\t     loff_t offset, loff_t nbytes);\nasmlinkage long sys_sync_file_range(int fd, loff_t offset, loff_t nbytes,\n\t\t\t\t\tunsigned int flags);\n\n/* fs/timerfd.c */\nasmlinkage long sys_timerfd_create(int clockid, int flags);\nasmlinkage long sys_timerfd_settime(int ufd, int flags,\n\t\t\t\t    const struct __kernel_itimerspec __user *utmr,\n\t\t\t\t    struct __kernel_itimerspec __user *otmr);\nasmlinkage long sys_timerfd_gettime(int ufd, struct __kernel_itimerspec __user *otmr);\nasmlinkage long sys_timerfd_gettime32(int ufd,\n\t\t\t\t   struct old_itimerspec32 __user *otmr);\nasmlinkage long sys_timerfd_settime32(int ufd, int flags,\n\t\t\t\t   const struct old_itimerspec32 __user *utmr,\n\t\t\t\t   struct old_itimerspec32 __user *otmr);\n\n/* fs/utimes.c */\nasmlinkage long sys_utimensat(int dfd, const char __user *filename,\n\t\t\t\tstruct __kernel_timespec __user *utimes,\n\t\t\t\tint flags);\nasmlinkage long sys_utimensat_time32(unsigned int dfd,\n\t\t\t\tconst char __user *filename,\n\t\t\t\tstruct old_timespec32 __user *t, int flags);\n\n/* kernel/acct.c */\nasmlinkage long sys_acct(const char __user *name);\n\n/* kernel/capability.c */\nasmlinkage long sys_capget(cap_user_header_t header,\n\t\t\t\tcap_user_data_t dataptr);\nasmlinkage long sys_capset(cap_user_header_t header,\n\t\t\t\tconst cap_user_data_t data);\n\n/* kernel/exec_domain.c */\nasmlinkage long sys_personality(unsigned int personality);\n\n/* kernel/exit.c */\nasmlinkage long sys_exit(int error_code);\nasmlinkage long sys_exit_group(int error_code);\nasmlinkage long sys_waitid(int which, pid_t pid,\n\t\t\t   struct siginfo __user *infop,\n\t\t\t   int options, struct rusage __user *ru);\n\n/* kernel/fork.c */\nasmlinkage long sys_set_tid_address(int __user *tidptr);\nasmlinkage long sys_unshare(unsigned long unshare_flags);\n\n/* kernel/futex.c */\nasmlinkage long sys_futex(u32 __user *uaddr, int op, u32 val,\n\t\t\tstruct __kernel_timespec __user *utime, u32 __user *uaddr2,\n\t\t\tu32 val3);\nasmlinkage long sys_futex_time32(u32 __user *uaddr, int op, u32 val,\n\t\t\tstruct old_timespec32 __user *utime, u32 __user *uaddr2,\n\t\t\tu32 val3);\nasmlinkage long sys_get_robust_list(int pid,\n\t\t\t\t    struct robust_list_head __user * __user *head_ptr,\n\t\t\t\t    size_t __user *len_ptr);\nasmlinkage long sys_set_robust_list(struct robust_list_head __user *head,\n\t\t\t\t    size_t len);\n\n/* kernel/hrtimer.c */\nasmlinkage long sys_nanosleep(struct __kernel_timespec __user *rqtp,\n\t\t\t      struct __kernel_timespec __user *rmtp);\nasmlinkage long sys_nanosleep_time32(struct old_timespec32 __user *rqtp,\n\t\t\t\t     struct old_timespec32 __user *rmtp);\n\n/* kernel/itimer.c */\nasmlinkage long sys_getitimer(int which, struct __kernel_old_itimerval __user *value);\nasmlinkage long sys_setitimer(int which,\n\t\t\t\tstruct __kernel_old_itimerval __user *value,\n\t\t\t\tstruct __kernel_old_itimerval __user *ovalue);\n\n/* kernel/kexec.c */\nasmlinkage long sys_kexec_load(unsigned long entry, unsigned long nr_segments,\n\t\t\t\tstruct kexec_segment __user *segments,\n\t\t\t\tunsigned long flags);\n\n/* kernel/module.c */\nasmlinkage long sys_init_module(void __user *umod, unsigned long len,\n\t\t\t\tconst char __user *uargs);\nasmlinkage long sys_delete_module(const char __user *name_user,\n\t\t\t\tunsigned int flags);\n\n/* kernel/posix-timers.c */\nasmlinkage long sys_timer_create(clockid_t which_clock,\n\t\t\t\t struct sigevent __user *timer_event_spec,\n\t\t\t\t timer_t __user * created_timer_id);\nasmlinkage long sys_timer_gettime(timer_t timer_id,\n\t\t\t\tstruct __kernel_itimerspec __user *setting);\nasmlinkage long sys_timer_getoverrun(timer_t timer_id);\nasmlinkage long sys_timer_settime(timer_t timer_id, int flags,\n\t\t\t\tconst struct __kernel_itimerspec __user *new_setting,\n\t\t\t\tstruct __kernel_itimerspec __user *old_setting);\nasmlinkage long sys_timer_delete(timer_t timer_id);\nasmlinkage long sys_clock_settime(clockid_t which_clock,\n\t\t\t\tconst struct __kernel_timespec __user *tp);\nasmlinkage long sys_clock_gettime(clockid_t which_clock,\n\t\t\t\tstruct __kernel_timespec __user *tp);\nasmlinkage long sys_clock_getres(clockid_t which_clock,\n\t\t\t\tstruct __kernel_timespec __user *tp);\nasmlinkage long sys_clock_nanosleep(clockid_t which_clock, int flags,\n\t\t\t\tconst struct __kernel_timespec __user *rqtp,\n\t\t\t\tstruct __kernel_timespec __user *rmtp);\nasmlinkage long sys_timer_gettime32(timer_t timer_id,\n\t\t\t\t struct old_itimerspec32 __user *setting);\nasmlinkage long sys_timer_settime32(timer_t timer_id, int flags,\n\t\t\t\t\t struct old_itimerspec32 __user *new,\n\t\t\t\t\t struct old_itimerspec32 __user *old);\nasmlinkage long sys_clock_settime32(clockid_t which_clock,\n\t\t\t\tstruct old_timespec32 __user *tp);\nasmlinkage long sys_clock_gettime32(clockid_t which_clock,\n\t\t\t\tstruct old_timespec32 __user *tp);\nasmlinkage long sys_clock_getres_time32(clockid_t which_clock,\n\t\t\t\tstruct old_timespec32 __user *tp);\nasmlinkage long sys_clock_nanosleep_time32(clockid_t which_clock, int flags,\n\t\t\t\tstruct old_timespec32 __user *rqtp,\n\t\t\t\tstruct old_timespec32 __user *rmtp);\n\n/* kernel/printk.c */\nasmlinkage long sys_syslog(int type, char __user *buf, int len);\n\n/* kernel/ptrace.c */\nasmlinkage long sys_ptrace(long request, long pid, unsigned long addr,\n\t\t\t   unsigned long data);\n/* kernel/sched/core.c */\n\nasmlinkage long sys_sched_setparam(pid_t pid,\n\t\t\t\t\tstruct sched_param __user *param);\nasmlinkage long sys_sched_setscheduler(pid_t pid, int policy,\n\t\t\t\t\tstruct sched_param __user *param);\nasmlinkage long sys_sched_getscheduler(pid_t pid);\nasmlinkage long sys_sched_getparam(pid_t pid,\n\t\t\t\t\tstruct sched_param __user *param);\nasmlinkage long sys_sched_setaffinity(pid_t pid, unsigned int len,\n\t\t\t\t\tunsigned long __user *user_mask_ptr);\nasmlinkage long sys_sched_getaffinity(pid_t pid, unsigned int len,\n\t\t\t\t\tunsigned long __user *user_mask_ptr);\nasmlinkage long sys_sched_yield(void);\nasmlinkage long sys_sched_get_priority_max(int policy);\nasmlinkage long sys_sched_get_priority_min(int policy);\nasmlinkage long sys_sched_rr_get_interval(pid_t pid,\n\t\t\t\tstruct __kernel_timespec __user *interval);\nasmlinkage long sys_sched_rr_get_interval_time32(pid_t pid,\n\t\t\t\t\t\t struct old_timespec32 __user *interval);\n\n/* kernel/signal.c */\nasmlinkage long sys_restart_syscall(void);\nasmlinkage long sys_kill(pid_t pid, int sig);\nasmlinkage long sys_tkill(pid_t pid, int sig);\nasmlinkage long sys_tgkill(pid_t tgid, pid_t pid, int sig);\nasmlinkage long sys_sigaltstack(const struct sigaltstack __user *uss,\n\t\t\t\tstruct sigaltstack __user *uoss);\nasmlinkage long sys_rt_sigsuspend(sigset_t __user *unewset, size_t sigsetsize);\n#ifndef CONFIG_ODD_RT_SIGACTION\nasmlinkage long sys_rt_sigaction(int,\n\t\t\t\t const struct sigaction __user *,\n\t\t\t\t struct sigaction __user *,\n\t\t\t\t size_t);\n#endif\nasmlinkage long sys_rt_sigprocmask(int how, sigset_t __user *set,\n\t\t\t\tsigset_t __user *oset, size_t sigsetsize);\nasmlinkage long sys_rt_sigpending(sigset_t __user *set, size_t sigsetsize);\nasmlinkage long sys_rt_sigtimedwait(const sigset_t __user *uthese,\n\t\t\t\tsiginfo_t __user *uinfo,\n\t\t\t\tconst struct __kernel_timespec __user *uts,\n\t\t\t\tsize_t sigsetsize);\nasmlinkage long sys_rt_sigtimedwait_time32(const sigset_t __user *uthese,\n\t\t\t\tsiginfo_t __user *uinfo,\n\t\t\t\tconst struct old_timespec32 __user *uts,\n\t\t\t\tsize_t sigsetsize);\nasmlinkage long sys_rt_sigqueueinfo(pid_t pid, int sig, siginfo_t __user *uinfo);\n\n/* kernel/sys.c */\nasmlinkage long sys_setpriority(int which, int who, int niceval);\nasmlinkage long sys_getpriority(int which, int who);\nasmlinkage long sys_reboot(int magic1, int magic2, unsigned int cmd,\n\t\t\t\tvoid __user *arg);\nasmlinkage long sys_setregid(gid_t rgid, gid_t egid);\nasmlinkage long sys_setgid(gid_t gid);\nasmlinkage long sys_setreuid(uid_t ruid, uid_t euid);\nasmlinkage long sys_setuid(uid_t uid);\nasmlinkage long sys_setresuid(uid_t ruid, uid_t euid, uid_t suid);\nasmlinkage long sys_getresuid(uid_t __user *ruid, uid_t __user *euid, uid_t __user *suid);\nasmlinkage long sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid);\nasmlinkage long sys_getresgid(gid_t __user *rgid, gid_t __user *egid, gid_t __user *sgid);\nasmlinkage long sys_setfsuid(uid_t uid);\nasmlinkage long sys_setfsgid(gid_t gid);\nasmlinkage long sys_times(struct tms __user *tbuf);\nasmlinkage long sys_setpgid(pid_t pid, pid_t pgid);\nasmlinkage long sys_getpgid(pid_t pid);\nasmlinkage long sys_getsid(pid_t pid);\nasmlinkage long sys_setsid(void);\nasmlinkage long sys_getgroups(int gidsetsize, gid_t __user *grouplist);\nasmlinkage long sys_setgroups(int gidsetsize, gid_t __user *grouplist);\nasmlinkage long sys_newuname(struct new_utsname __user *name);\nasmlinkage long sys_sethostname(char __user *name, int len);\nasmlinkage long sys_setdomainname(char __user *name, int len);\nasmlinkage long sys_getrlimit(unsigned int resource,\n\t\t\t\tstruct rlimit __user *rlim);\nasmlinkage long sys_setrlimit(unsigned int resource,\n\t\t\t\tstruct rlimit __user *rlim);\nasmlinkage long sys_getrusage(int who, struct rusage __user *ru);\nasmlinkage long sys_umask(int mask);\nasmlinkage long sys_prctl(int option, unsigned long arg2, unsigned long arg3,\n\t\t\tunsigned long arg4, unsigned long arg5);\nasmlinkage long sys_getcpu(unsigned __user *cpu, unsigned __user *node, struct getcpu_cache __user *cache);\n\n/* kernel/time.c */\nasmlinkage long sys_gettimeofday(struct __kernel_old_timeval __user *tv,\n\t\t\t\tstruct timezone __user *tz);\nasmlinkage long sys_settimeofday(struct __kernel_old_timeval __user *tv,\n\t\t\t\tstruct timezone __user *tz);\nasmlinkage long sys_adjtimex(struct __kernel_timex __user *txc_p);\nasmlinkage long sys_adjtimex_time32(struct old_timex32 __user *txc_p);\n\n/* kernel/timer.c */\nasmlinkage long sys_getpid(void);\nasmlinkage long sys_getppid(void);\nasmlinkage long sys_getuid(void);\nasmlinkage long sys_geteuid(void);\nasmlinkage long sys_getgid(void);\nasmlinkage long sys_getegid(void);\nasmlinkage long sys_gettid(void);\nasmlinkage long sys_sysinfo(struct sysinfo __user *info);\n\n/* ipc/mqueue.c */\nasmlinkage long sys_mq_open(const char __user *name, int oflag, umode_t mode, struct mq_attr __user *attr);\nasmlinkage long sys_mq_unlink(const char __user *name);\nasmlinkage long sys_mq_timedsend(mqd_t mqdes, const char __user *msg_ptr, size_t msg_len, unsigned int msg_prio, const struct __kernel_timespec __user *abs_timeout);\nasmlinkage long sys_mq_timedreceive(mqd_t mqdes, char __user *msg_ptr, size_t msg_len, unsigned int __user *msg_prio, const struct __kernel_timespec __user *abs_timeout);\nasmlinkage long sys_mq_notify(mqd_t mqdes, const struct sigevent __user *notification);\nasmlinkage long sys_mq_getsetattr(mqd_t mqdes, const struct mq_attr __user *mqstat, struct mq_attr __user *omqstat);\nasmlinkage long sys_mq_timedreceive_time32(mqd_t mqdes,\n\t\t\tchar __user *u_msg_ptr,\n\t\t\tunsigned int msg_len, unsigned int __user *u_msg_prio,\n\t\t\tconst struct old_timespec32 __user *u_abs_timeout);\nasmlinkage long sys_mq_timedsend_time32(mqd_t mqdes,\n\t\t\tconst char __user *u_msg_ptr,\n\t\t\tunsigned int msg_len, unsigned int msg_prio,\n\t\t\tconst struct old_timespec32 __user *u_abs_timeout);\n\n/* ipc/msg.c */\nasmlinkage long sys_msgget(key_t key, int msgflg);\nasmlinkage long sys_old_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);\nasmlinkage long sys_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);\nasmlinkage long sys_msgrcv(int msqid, struct msgbuf __user *msgp,\n\t\t\t\tsize_t msgsz, long msgtyp, int msgflg);\nasmlinkage long sys_msgsnd(int msqid, struct msgbuf __user *msgp,\n\t\t\t\tsize_t msgsz, int msgflg);\n\n/* ipc/sem.c */\nasmlinkage long sys_semget(key_t key, int nsems, int semflg);\nasmlinkage long sys_semctl(int semid, int semnum, int cmd, unsigned long arg);\nasmlinkage long sys_old_semctl(int semid, int semnum, int cmd, unsigned long arg);\nasmlinkage long sys_semtimedop(int semid, struct sembuf __user *sops,\n\t\t\t\tunsigned nsops,\n\t\t\t\tconst struct __kernel_timespec __user *timeout);\nasmlinkage long sys_semtimedop_time32(int semid, struct sembuf __user *sops,\n\t\t\t\tunsigned nsops,\n\t\t\t\tconst struct old_timespec32 __user *timeout);\nasmlinkage long sys_semop(int semid, struct sembuf __user *sops,\n\t\t\t\tunsigned nsops);\n\n/* ipc/shm.c */\nasmlinkage long sys_shmget(key_t key, size_t size, int flag);\nasmlinkage long sys_old_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);\nasmlinkage long sys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);\nasmlinkage long sys_shmat(int shmid, char __user *shmaddr, int shmflg);\nasmlinkage long sys_shmdt(char __user *shmaddr);\n\n/* net/socket.c */\nasmlinkage long sys_socket(int, int, int);\nasmlinkage long sys_socketpair(int, int, int, int __user *);\nasmlinkage long sys_bind(int, struct sockaddr __user *, int);\nasmlinkage long sys_listen(int, int);\nasmlinkage long sys_accept(int, struct sockaddr __user *, int __user *);\nasmlinkage long sys_connect(int, struct sockaddr __user *, int);\nasmlinkage long sys_getsockname(int, struct sockaddr __user *, int __user *);\nasmlinkage long sys_getpeername(int, struct sockaddr __user *, int __user *);\nasmlinkage long sys_sendto(int, void __user *, size_t, unsigned,\n\t\t\t\tstruct sockaddr __user *, int);\nasmlinkage long sys_recvfrom(int, void __user *, size_t, unsigned,\n\t\t\t\tstruct sockaddr __user *, int __user *);\nasmlinkage long sys_setsockopt(int fd, int level, int optname,\n\t\t\t\tchar __user *optval, int optlen);\nasmlinkage long sys_getsockopt(int fd, int level, int optname,\n\t\t\t\tchar __user *optval, int __user *optlen);\nasmlinkage long sys_shutdown(int, int);\nasmlinkage long sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\nasmlinkage long sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned flags);\n\n/* mm/filemap.c */\nasmlinkage long sys_readahead(int fd, loff_t offset, size_t count);\n\n/* mm/nommu.c, also with MMU */\nasmlinkage long sys_brk(unsigned long brk);\nasmlinkage long sys_munmap(unsigned long addr, size_t len);\nasmlinkage long sys_mremap(unsigned long addr,\n\t\t\t   unsigned long old_len, unsigned long new_len,\n\t\t\t   unsigned long flags, unsigned long new_addr);\n\n/* security/keys/keyctl.c */\nasmlinkage long sys_add_key(const char __user *_type,\n\t\t\t    const char __user *_description,\n\t\t\t    const void __user *_payload,\n\t\t\t    size_t plen,\n\t\t\t    key_serial_t destringid);\nasmlinkage long sys_request_key(const char __user *_type,\n\t\t\t\tconst char __user *_description,\n\t\t\t\tconst char __user *_callout_info,\n\t\t\t\tkey_serial_t destringid);\nasmlinkage long sys_keyctl(int cmd, unsigned long arg2, unsigned long arg3,\n\t\t\t   unsigned long arg4, unsigned long arg5);\n\n/* arch/example/kernel/sys_example.c */\n#ifdef CONFIG_CLONE_BACKWARDS\nasmlinkage long sys_clone(unsigned long, unsigned long, int __user *, unsigned long,\n\t       int __user *);\n#else\n#ifdef CONFIG_CLONE_BACKWARDS3\nasmlinkage long sys_clone(unsigned long, unsigned long, int, int __user *,\n\t\t\t  int __user *, unsigned long);\n#else\nasmlinkage long sys_clone(unsigned long, unsigned long, int __user *,\n\t       int __user *, unsigned long);\n#endif\n#endif\n\nasmlinkage long sys_clone3(struct clone_args __user *uargs, size_t size);\n\nasmlinkage long sys_execve(const char __user *filename,\n\t\tconst char __user *const __user *argv,\n\t\tconst char __user *const __user *envp);\n\n/* mm/fadvise.c */\nasmlinkage long sys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice);\n\n/* mm/, CONFIG_MMU only */\nasmlinkage long sys_swapon(const char __user *specialfile, int swap_flags);\nasmlinkage long sys_swapoff(const char __user *specialfile);\nasmlinkage long sys_mprotect(unsigned long start, size_t len,\n\t\t\t\tunsigned long prot);\nasmlinkage long sys_msync(unsigned long start, size_t len, int flags);\nasmlinkage long sys_mlock(unsigned long start, size_t len);\nasmlinkage long sys_munlock(unsigned long start, size_t len);\nasmlinkage long sys_mlockall(int flags);\nasmlinkage long sys_munlockall(void);\nasmlinkage long sys_mincore(unsigned long start, size_t len,\n\t\t\t\tunsigned char __user * vec);\nasmlinkage long sys_madvise(unsigned long start, size_t len, int behavior);\nasmlinkage long sys_process_madvise(int pidfd, const struct iovec __user *vec,\n\t\t\tsize_t vlen, int behavior, unsigned int flags);\nasmlinkage long sys_remap_file_pages(unsigned long start, unsigned long size,\n\t\t\tunsigned long prot, unsigned long pgoff,\n\t\t\tunsigned long flags);\nasmlinkage long sys_mbind(unsigned long start, unsigned long len,\n\t\t\t\tunsigned long mode,\n\t\t\t\tconst unsigned long __user *nmask,\n\t\t\t\tunsigned long maxnode,\n\t\t\t\tunsigned flags);\nasmlinkage long sys_get_mempolicy(int __user *policy,\n\t\t\t\tunsigned long __user *nmask,\n\t\t\t\tunsigned long maxnode,\n\t\t\t\tunsigned long addr, unsigned long flags);\nasmlinkage long sys_set_mempolicy(int mode, const unsigned long __user *nmask,\n\t\t\t\tunsigned long maxnode);\nasmlinkage long sys_migrate_pages(pid_t pid, unsigned long maxnode,\n\t\t\t\tconst unsigned long __user *from,\n\t\t\t\tconst unsigned long __user *to);\nasmlinkage long sys_move_pages(pid_t pid, unsigned long nr_pages,\n\t\t\t\tconst void __user * __user *pages,\n\t\t\t\tconst int __user *nodes,\n\t\t\t\tint __user *status,\n\t\t\t\tint flags);\n\nasmlinkage long sys_rt_tgsigqueueinfo(pid_t tgid, pid_t  pid, int sig,\n\t\tsiginfo_t __user *uinfo);\nasmlinkage long sys_perf_event_open(\n\t\tstruct perf_event_attr __user *attr_uptr,\n\t\tpid_t pid, int cpu, int group_fd, unsigned long flags);\nasmlinkage long sys_accept4(int, struct sockaddr __user *, int __user *, int);\nasmlinkage long sys_recvmmsg(int fd, struct mmsghdr __user *msg,\n\t\t\t     unsigned int vlen, unsigned flags,\n\t\t\t     struct __kernel_timespec __user *timeout);\nasmlinkage long sys_recvmmsg_time32(int fd, struct mmsghdr __user *msg,\n\t\t\t     unsigned int vlen, unsigned flags,\n\t\t\t     struct old_timespec32 __user *timeout);\n\nasmlinkage long sys_wait4(pid_t pid, int __user *stat_addr,\n\t\t\t\tint options, struct rusage __user *ru);\nasmlinkage long sys_prlimit64(pid_t pid, unsigned int resource,\n\t\t\t\tconst struct rlimit64 __user *new_rlim,\n\t\t\t\tstruct rlimit64 __user *old_rlim);\nasmlinkage long sys_fanotify_init(unsigned int flags, unsigned int event_f_flags);\nasmlinkage long sys_fanotify_mark(int fanotify_fd, unsigned int flags,\n\t\t\t\t  u64 mask, int fd,\n\t\t\t\t  const char  __user *pathname);\nasmlinkage long sys_name_to_handle_at(int dfd, const char __user *name,\n\t\t\t\t      struct file_handle __user *handle,\n\t\t\t\t      int __user *mnt_id, int flag);\nasmlinkage long sys_open_by_handle_at(int mountdirfd,\n\t\t\t\t      struct file_handle __user *handle,\n\t\t\t\t      int flags);\nasmlinkage long sys_clock_adjtime(clockid_t which_clock,\n\t\t\t\tstruct __kernel_timex __user *tx);\nasmlinkage long sys_clock_adjtime32(clockid_t which_clock,\n\t\t\t\tstruct old_timex32 __user *tx);\nasmlinkage long sys_syncfs(int fd);\nasmlinkage long sys_setns(int fd, int nstype);\nasmlinkage long sys_pidfd_open(pid_t pid, unsigned int flags);\nasmlinkage long sys_sendmmsg(int fd, struct mmsghdr __user *msg,\n\t\t\t     unsigned int vlen, unsigned flags);\nasmlinkage long sys_process_vm_readv(pid_t pid,\n\t\t\t\t     const struct iovec __user *lvec,\n\t\t\t\t     unsigned long liovcnt,\n\t\t\t\t     const struct iovec __user *rvec,\n\t\t\t\t     unsigned long riovcnt,\n\t\t\t\t     unsigned long flags);\nasmlinkage long sys_process_vm_writev(pid_t pid,\n\t\t\t\t      const struct iovec __user *lvec,\n\t\t\t\t      unsigned long liovcnt,\n\t\t\t\t      const struct iovec __user *rvec,\n\t\t\t\t      unsigned long riovcnt,\n\t\t\t\t      unsigned long flags);\nasmlinkage long sys_kcmp(pid_t pid1, pid_t pid2, int type,\n\t\t\t unsigned long idx1, unsigned long idx2);\nasmlinkage long sys_finit_module(int fd, const char __user *uargs, int flags);\nasmlinkage long sys_sched_setattr(pid_t pid,\n\t\t\t\t\tstruct sched_attr __user *attr,\n\t\t\t\t\tunsigned int flags);\nasmlinkage long sys_sched_getattr(pid_t pid,\n\t\t\t\t\tstruct sched_attr __user *attr,\n\t\t\t\t\tunsigned int size,\n\t\t\t\t\tunsigned int flags);\nasmlinkage long sys_renameat2(int olddfd, const char __user *oldname,\n\t\t\t      int newdfd, const char __user *newname,\n\t\t\t      unsigned int flags);\nasmlinkage long sys_seccomp(unsigned int op, unsigned int flags,\n\t\t\t    void __user *uargs);\nasmlinkage long sys_getrandom(char __user *buf, size_t count,\n\t\t\t      unsigned int flags);\nasmlinkage long sys_memfd_create(const char __user *uname_ptr, unsigned int flags);\nasmlinkage long sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);\nasmlinkage long sys_execveat(int dfd, const char __user *filename,\n\t\t\tconst char __user *const __user *argv,\n\t\t\tconst char __user *const __user *envp, int flags);\nasmlinkage long sys_userfaultfd(int flags);\nasmlinkage long sys_membarrier(int cmd, unsigned int flags, int cpu_id);\nasmlinkage long sys_mlock2(unsigned long start, size_t len, int flags);\nasmlinkage long sys_copy_file_range(int fd_in, loff_t __user *off_in,\n\t\t\t\t    int fd_out, loff_t __user *off_out,\n\t\t\t\t    size_t len, unsigned int flags);\nasmlinkage long sys_preadv2(unsigned long fd, const struct iovec __user *vec,\n\t\t\t    unsigned long vlen, unsigned long pos_l, unsigned long pos_h,\n\t\t\t    rwf_t flags);\nasmlinkage long sys_pwritev2(unsigned long fd, const struct iovec __user *vec,\n\t\t\t    unsigned long vlen, unsigned long pos_l, unsigned long pos_h,\n\t\t\t    rwf_t flags);\nasmlinkage long sys_pkey_mprotect(unsigned long start, size_t len,\n\t\t\t\t  unsigned long prot, int pkey);\nasmlinkage long sys_pkey_alloc(unsigned long flags, unsigned long init_val);\nasmlinkage long sys_pkey_free(int pkey);\nasmlinkage long sys_statx(int dfd, const char __user *path, unsigned flags,\n\t\t\t  unsigned mask, struct statx __user *buffer);\nasmlinkage long sys_rseq(struct rseq __user *rseq, uint32_t rseq_len,\n\t\t\t int flags, uint32_t sig);\nasmlinkage long sys_open_tree(int dfd, const char __user *path, unsigned flags);\nasmlinkage long sys_move_mount(int from_dfd, const char __user *from_path,\n\t\t\t       int to_dfd, const char __user *to_path,\n\t\t\t       unsigned int ms_flags);\nasmlinkage long sys_fsopen(const char __user *fs_name, unsigned int flags);\nasmlinkage long sys_fsconfig(int fs_fd, unsigned int cmd, const char __user *key,\n\t\t\t     const void __user *value, int aux);\nasmlinkage long sys_fsmount(int fs_fd, unsigned int flags, unsigned int ms_flags);\nasmlinkage long sys_fspick(int dfd, const char __user *path, unsigned int flags);\nasmlinkage long sys_pidfd_send_signal(int pidfd, int sig,\n\t\t\t\t       siginfo_t __user *info,\n\t\t\t\t       unsigned int flags);\nasmlinkage long sys_pidfd_getfd(int pidfd, int fd, unsigned int flags);\nasmlinkage long sys_watch_mount(int dfd, const char __user *path,\n\t\t\t\tunsigned int at_flags, int watch_fd, int watch_id);\n\n/*\n * Architecture-specific system calls\n */\n\n/* arch/x86/kernel/ioport.c */\nasmlinkage long sys_ioperm(unsigned long from, unsigned long num, int on);\n\n/* pciconfig: alpha, arm, arm64, ia64, sparc */\nasmlinkage long sys_pciconfig_read(unsigned long bus, unsigned long dfn,\n\t\t\t\tunsigned long off, unsigned long len,\n\t\t\t\tvoid __user *buf);\nasmlinkage long sys_pciconfig_write(unsigned long bus, unsigned long dfn,\n\t\t\t\tunsigned long off, unsigned long len,\n\t\t\t\tvoid __user *buf);\nasmlinkage long sys_pciconfig_iobase(long which, unsigned long bus, unsigned long devfn);\n\n/* powerpc */\nasmlinkage long sys_spu_run(int fd, __u32 __user *unpc,\n\t\t\t\t __u32 __user *ustatus);\nasmlinkage long sys_spu_create(const char __user *name,\n\t\tunsigned int flags, umode_t mode, int fd);\n\n\n/*\n * Deprecated system calls which are still defined in\n * include/uapi/asm-generic/unistd.h and wanted by >= 1 arch\n */\n\n/* __ARCH_WANT_SYSCALL_NO_AT */\nasmlinkage long sys_open(const char __user *filename,\n\t\t\t\tint flags, umode_t mode);\nasmlinkage long sys_link(const char __user *oldname,\n\t\t\t\tconst char __user *newname);\nasmlinkage long sys_unlink(const char __user *pathname);\nasmlinkage long sys_mknod(const char __user *filename, umode_t mode,\n\t\t\t\tunsigned dev);\nasmlinkage long sys_chmod(const char __user *filename, umode_t mode);\nasmlinkage long sys_chown(const char __user *filename,\n\t\t\t\tuid_t user, gid_t group);\nasmlinkage long sys_mkdir(const char __user *pathname, umode_t mode);\nasmlinkage long sys_rmdir(const char __user *pathname);\nasmlinkage long sys_lchown(const char __user *filename,\n\t\t\t\tuid_t user, gid_t group);\nasmlinkage long sys_access(const char __user *filename, int mode);\nasmlinkage long sys_rename(const char __user *oldname,\n\t\t\t\tconst char __user *newname);\nasmlinkage long sys_symlink(const char __user *old, const char __user *new);\n#if defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64)\nasmlinkage long sys_stat64(const char __user *filename,\n\t\t\t\tstruct stat64 __user *statbuf);\nasmlinkage long sys_lstat64(const char __user *filename,\n\t\t\t\tstruct stat64 __user *statbuf);\n#endif\n\n/* __ARCH_WANT_SYSCALL_NO_FLAGS */\nasmlinkage long sys_pipe(int __user *fildes);\nasmlinkage long sys_dup2(unsigned int oldfd, unsigned int newfd);\nasmlinkage long sys_epoll_create(int size);\nasmlinkage long sys_inotify_init(void);\nasmlinkage long sys_eventfd(unsigned int count);\nasmlinkage long sys_signalfd(int ufd, sigset_t __user *user_mask, size_t sizemask);\n\n/* __ARCH_WANT_SYSCALL_OFF_T */\nasmlinkage long sys_sendfile(int out_fd, int in_fd,\n\t\t\t     off_t __user *offset, size_t count);\nasmlinkage long sys_newstat(const char __user *filename,\n\t\t\t\tstruct stat __user *statbuf);\nasmlinkage long sys_newlstat(const char __user *filename,\n\t\t\t\tstruct stat __user *statbuf);\nasmlinkage long sys_fadvise64(int fd, loff_t offset, size_t len, int advice);\n\n/* __ARCH_WANT_SYSCALL_DEPRECATED */\nasmlinkage long sys_alarm(unsigned int seconds);\nasmlinkage long sys_getpgrp(void);\nasmlinkage long sys_pause(void);\nasmlinkage long sys_time(__kernel_old_time_t __user *tloc);\nasmlinkage long sys_time32(old_time32_t __user *tloc);\n#ifdef __ARCH_WANT_SYS_UTIME\nasmlinkage long sys_utime(char __user *filename,\n\t\t\t\tstruct utimbuf __user *times);\nasmlinkage long sys_utimes(char __user *filename,\n\t\t\t\tstruct __kernel_old_timeval __user *utimes);\nasmlinkage long sys_futimesat(int dfd, const char __user *filename,\n\t\t\t      struct __kernel_old_timeval __user *utimes);\n#endif\nasmlinkage long sys_futimesat_time32(unsigned int dfd,\n\t\t\t\t     const char __user *filename,\n\t\t\t\t     struct old_timeval32 __user *t);\nasmlinkage long sys_utime32(const char __user *filename,\n\t\t\t\t struct old_utimbuf32 __user *t);\nasmlinkage long sys_utimes_time32(const char __user *filename,\n\t\t\t\t  struct old_timeval32 __user *t);\nasmlinkage long sys_creat(const char __user *pathname, umode_t mode);\nasmlinkage long sys_getdents(unsigned int fd,\n\t\t\t\tstruct linux_dirent __user *dirent,\n\t\t\t\tunsigned int count);\nasmlinkage long sys_select(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t\tfd_set __user *exp, struct __kernel_old_timeval __user *tvp);\nasmlinkage long sys_poll(struct pollfd __user *ufds, unsigned int nfds,\n\t\t\t\tint timeout);\nasmlinkage long sys_epoll_wait(int epfd, struct epoll_event __user *events,\n\t\t\t\tint maxevents, int timeout);\nasmlinkage long sys_ustat(unsigned dev, struct ustat __user *ubuf);\nasmlinkage long sys_vfork(void);\nasmlinkage long sys_recv(int, void __user *, size_t, unsigned);\nasmlinkage long sys_send(int, void __user *, size_t, unsigned);\nasmlinkage long sys_bdflush(int func, long data);\nasmlinkage long sys_oldumount(char __user *name);\nasmlinkage long sys_uselib(const char __user *library);\nasmlinkage long sys_sysfs(int option,\n\t\t\t\tunsigned long arg1, unsigned long arg2);\nasmlinkage long sys_fork(void);\n\n/* obsolete: kernel/time/time.c */\nasmlinkage long sys_stime(__kernel_old_time_t __user *tptr);\nasmlinkage long sys_stime32(old_time32_t __user *tptr);\n\n/* obsolete: kernel/signal.c */\nasmlinkage long sys_sigpending(old_sigset_t __user *uset);\nasmlinkage long sys_sigprocmask(int how, old_sigset_t __user *set,\n\t\t\t\told_sigset_t __user *oset);\n#ifdef CONFIG_OLD_SIGSUSPEND\nasmlinkage long sys_sigsuspend(old_sigset_t mask);\n#endif\n\n#ifdef CONFIG_OLD_SIGSUSPEND3\nasmlinkage long sys_sigsuspend(int unused1, int unused2, old_sigset_t mask);\n#endif\n\n#ifdef CONFIG_OLD_SIGACTION\nasmlinkage long sys_sigaction(int, const struct old_sigaction __user *,\n\t\t\t\tstruct old_sigaction __user *);\n#endif\nasmlinkage long sys_sgetmask(void);\nasmlinkage long sys_ssetmask(int newmask);\nasmlinkage long sys_signal(int sig, __sighandler_t handler);\n\n/* obsolete: kernel/sched/core.c */\nasmlinkage long sys_nice(int increment);\n\n/* obsolete: kernel/kexec_file.c */\nasmlinkage long sys_kexec_file_load(int kernel_fd, int initrd_fd,\n\t\t\t\t    unsigned long cmdline_len,\n\t\t\t\t    const char __user *cmdline_ptr,\n\t\t\t\t    unsigned long flags);\n\n/* obsolete: kernel/exit.c */\nasmlinkage long sys_waitpid(pid_t pid, int __user *stat_addr, int options);\n\n/* obsolete: kernel/uid16.c */\n#ifdef CONFIG_HAVE_UID16\nasmlinkage long sys_chown16(const char __user *filename,\n\t\t\t\told_uid_t user, old_gid_t group);\nasmlinkage long sys_lchown16(const char __user *filename,\n\t\t\t\told_uid_t user, old_gid_t group);\nasmlinkage long sys_fchown16(unsigned int fd, old_uid_t user, old_gid_t group);\nasmlinkage long sys_setregid16(old_gid_t rgid, old_gid_t egid);\nasmlinkage long sys_setgid16(old_gid_t gid);\nasmlinkage long sys_setreuid16(old_uid_t ruid, old_uid_t euid);\nasmlinkage long sys_setuid16(old_uid_t uid);\nasmlinkage long sys_setresuid16(old_uid_t ruid, old_uid_t euid, old_uid_t suid);\nasmlinkage long sys_getresuid16(old_uid_t __user *ruid,\n\t\t\t\told_uid_t __user *euid, old_uid_t __user *suid);\nasmlinkage long sys_setresgid16(old_gid_t rgid, old_gid_t egid, old_gid_t sgid);\nasmlinkage long sys_getresgid16(old_gid_t __user *rgid,\n\t\t\t\told_gid_t __user *egid, old_gid_t __user *sgid);\nasmlinkage long sys_setfsuid16(old_uid_t uid);\nasmlinkage long sys_setfsgid16(old_gid_t gid);\nasmlinkage long sys_getgroups16(int gidsetsize, old_gid_t __user *grouplist);\nasmlinkage long sys_setgroups16(int gidsetsize, old_gid_t __user *grouplist);\nasmlinkage long sys_getuid16(void);\nasmlinkage long sys_geteuid16(void);\nasmlinkage long sys_getgid16(void);\nasmlinkage long sys_getegid16(void);\n#endif\n\n/* obsolete: net/socket.c */\nasmlinkage long sys_socketcall(int call, unsigned long __user *args);\n\n/* obsolete: fs/stat.c */\nasmlinkage long sys_stat(const char __user *filename,\n\t\t\tstruct __old_kernel_stat __user *statbuf);\nasmlinkage long sys_lstat(const char __user *filename,\n\t\t\tstruct __old_kernel_stat __user *statbuf);\nasmlinkage long sys_fstat(unsigned int fd,\n\t\t\tstruct __old_kernel_stat __user *statbuf);\nasmlinkage long sys_readlink(const char __user *path,\n\t\t\t\tchar __user *buf, int bufsiz);\n\n/* obsolete: fs/select.c */\nasmlinkage long sys_old_select(struct sel_arg_struct __user *arg);\n\n/* obsolete: fs/readdir.c */\nasmlinkage long sys_old_readdir(unsigned int, struct old_linux_dirent __user *, unsigned int);\n\n/* obsolete: kernel/sys.c */\nasmlinkage long sys_gethostname(char __user *name, int len);\nasmlinkage long sys_uname(struct old_utsname __user *);\nasmlinkage long sys_olduname(struct oldold_utsname __user *);\n#ifdef __ARCH_WANT_SYS_OLD_GETRLIMIT\nasmlinkage long sys_old_getrlimit(unsigned int resource, struct rlimit __user *rlim);\n#endif\n\n/* obsolete: ipc */\nasmlinkage long sys_ipc(unsigned int call, int first, unsigned long second,\n\t\tunsigned long third, void __user *ptr, long fifth);\n\n/* obsolete: mm/ */\nasmlinkage long sys_mmap_pgoff(unsigned long addr, unsigned long len,\n\t\t\tunsigned long prot, unsigned long flags,\n\t\t\tunsigned long fd, unsigned long pgoff);\nasmlinkage long sys_old_mmap(struct mmap_arg_struct __user *arg);\n\n\n/*\n * Not a real system call, but a placeholder for syscalls which are\n * not implemented -- see kernel/sys_ni.c\n */\nasmlinkage long sys_ni_syscall(void);\n\n#endif /* CONFIG_ARCH_HAS_SYSCALL_WRAPPER */\n\n\n/*\n * Kernel code should not call syscalls (i.e., sys_xyzyyz()) directly.\n * Instead, use one of the functions which work equivalently, such as\n * the ksys_xyzyyz() functions prototyped below.\n */\nssize_t ksys_write(unsigned int fd, const char __user *buf, size_t count);\nint ksys_fchown(unsigned int fd, uid_t user, gid_t group);\nssize_t ksys_read(unsigned int fd, char __user *buf, size_t count);\nvoid ksys_sync(void);\nint ksys_unshare(unsigned long unshare_flags);\nint ksys_setsid(void);\nint ksys_sync_file_range(int fd, loff_t offset, loff_t nbytes,\n\t\t\t unsigned int flags);\nssize_t ksys_pread64(unsigned int fd, char __user *buf, size_t count,\n\t\t     loff_t pos);\nssize_t ksys_pwrite64(unsigned int fd, const char __user *buf,\n\t\t      size_t count, loff_t pos);\nint ksys_fallocate(int fd, int mode, loff_t offset, loff_t len);\n#ifdef CONFIG_ADVISE_SYSCALLS\nint ksys_fadvise64_64(int fd, loff_t offset, loff_t len, int advice);\n#else\nstatic inline int ksys_fadvise64_64(int fd, loff_t offset, loff_t len,\n\t\t\t\t    int advice)\n{\n\treturn -EINVAL;\n}\n#endif\nunsigned long ksys_mmap_pgoff(unsigned long addr, unsigned long len,\n\t\t\t      unsigned long prot, unsigned long flags,\n\t\t\t      unsigned long fd, unsigned long pgoff);\nssize_t ksys_readahead(int fd, loff_t offset, size_t count);\nint ksys_ipc(unsigned int call, int first, unsigned long second,\n\tunsigned long third, void __user * ptr, long fifth);\nint compat_ksys_ipc(u32 call, int first, int second,\n\tu32 third, u32 ptr, u32 fifth);\n\n/*\n * The following kernel syscall equivalents are just wrappers to fs-internal\n * functions. Therefore, provide stubs to be inlined at the callsites.\n */\nextern int do_fchownat(int dfd, const char __user *filename, uid_t user,\n\t\t       gid_t group, int flag);\n\nstatic inline long ksys_chown(const char __user *filename, uid_t user,\n\t\t\t      gid_t group)\n{\n\treturn do_fchownat(AT_FDCWD, filename, user, group, 0);\n}\n\nstatic inline long ksys_lchown(const char __user *filename, uid_t user,\n\t\t\t       gid_t group)\n{\n\treturn do_fchownat(AT_FDCWD, filename, user, group,\n\t\t\t     AT_SYMLINK_NOFOLLOW);\n}\n\nextern long do_sys_ftruncate(unsigned int fd, loff_t length, int small);\n\nstatic inline long ksys_ftruncate(unsigned int fd, loff_t length)\n{\n\treturn do_sys_ftruncate(fd, length, 1);\n}\n\nextern int __close_fd(struct files_struct *files, unsigned int fd);\n\n/*\n * In contrast to sys_close(), this stub does not check whether the syscall\n * should or should not be restarted, but returns the raw error codes from\n * __close_fd().\n */\nstatic inline int ksys_close(unsigned int fd)\n{\n\treturn __close_fd(current->files, fd);\n}\n\nextern long do_sys_truncate(const char __user *pathname, loff_t length);\n\nstatic inline long ksys_truncate(const char __user *pathname, loff_t length)\n{\n\treturn do_sys_truncate(pathname, length);\n}\n\nstatic inline unsigned int ksys_personality(unsigned int personality)\n{\n\tunsigned int old = current->personality;\n\n\tif (personality != 0xffffffff)\n\t\tset_personality(personality);\n\n\treturn old;\n}\n\n/* for __ARCH_WANT_SYS_IPC */\nlong ksys_semtimedop(int semid, struct sembuf __user *tsops,\n\t\t     unsigned int nsops,\n\t\t     const struct __kernel_timespec __user *timeout);\nlong ksys_semget(key_t key, int nsems, int semflg);\nlong ksys_old_semctl(int semid, int semnum, int cmd, unsigned long arg);\nlong ksys_msgget(key_t key, int msgflg);\nlong ksys_old_msgctl(int msqid, int cmd, struct msqid_ds __user *buf);\nlong ksys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz,\n\t\t long msgtyp, int msgflg);\nlong ksys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz,\n\t\t int msgflg);\nlong ksys_shmget(key_t key, size_t size, int shmflg);\nlong ksys_shmdt(char __user *shmaddr);\nlong ksys_old_shmctl(int shmid, int cmd, struct shmid_ds __user *buf);\nlong compat_ksys_semtimedop(int semid, struct sembuf __user *tsems,\n\t\t\t    unsigned int nsops,\n\t\t\t    const struct old_timespec32 __user *timeout);\n\nint __sys_getsockopt(int fd, int level, int optname, char __user *optval,\n\t\tint __user *optlen);\nint __sys_setsockopt(int fd, int level, int optname, char __user *optval,\n\t\tint optlen);\n#endif\n"}, "2": {"id": 2, "path": "/src/arch/x86/include/asm/syscall_wrapper.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * syscall_wrapper.h - x86 specific wrappers to syscall definitions\n */\n\n#ifndef _ASM_X86_SYSCALL_WRAPPER_H\n#define _ASM_X86_SYSCALL_WRAPPER_H\n\nstruct pt_regs;\n\nextern long __x64_sys_ni_syscall(const struct pt_regs *regs);\nextern long __ia32_sys_ni_syscall(const struct pt_regs *regs);\n\n/*\n * Instead of the generic __SYSCALL_DEFINEx() definition, the x86 version takes\n * struct pt_regs *regs as the only argument of the syscall stub(s) named as:\n * __x64_sys_*()         - 64-bit native syscall\n * __ia32_sys_*()        - 32-bit native syscall or common compat syscall\n * __ia32_compat_sys_*() - 32-bit compat syscall\n * __x32_compat_sys_*()  - 64-bit X32 compat syscall\n *\n * The registers are decoded according to the ABI:\n * 64-bit: RDI, RSI, RDX, R10, R8, R9\n * 32-bit: EBX, ECX, EDX, ESI, EDI, EBP\n *\n * The stub then passes the decoded arguments to the __se_sys_*() wrapper to\n * perform sign-extension (omitted for zero-argument syscalls).  Finally the\n * arguments are passed to the __do_sys_*() function which is the actual\n * syscall.  These wrappers are marked as inline so the compiler can optimize\n * the functions where appropriate.\n *\n * Example assembly (slightly re-ordered for better readability):\n *\n * <__x64_sys_recv>:\t\t<-- syscall with 4 parameters\n *\tcallq\t<__fentry__>\n *\n *\tmov\t0x70(%rdi),%rdi\t<-- decode regs->di\n *\tmov\t0x68(%rdi),%rsi\t<-- decode regs->si\n *\tmov\t0x60(%rdi),%rdx\t<-- decode regs->dx\n *\tmov\t0x38(%rdi),%rcx\t<-- decode regs->r10\n *\n *\txor\t%r9d,%r9d\t<-- clear %r9\n *\txor\t%r8d,%r8d\t<-- clear %r8\n *\n *\tcallq\t__sys_recvfrom\t<-- do the actual work in __sys_recvfrom()\n *\t\t\t\t    which takes 6 arguments\n *\n *\tcltq\t\t\t<-- extend return value to 64-bit\n *\tretq\t\t\t<-- return\n *\n * This approach avoids leaking random user-provided register content down\n * the call chain.\n */\n\n/* Mapping of registers to parameters for syscalls on x86-64 and x32 */\n#define SC_X86_64_REGS_TO_ARGS(x, ...)\t\t\t\t\t\\\n\t__MAP(x,__SC_ARGS\t\t\t\t\t\t\\\n\t\t,,regs->di,,regs->si,,regs->dx\t\t\t\t\\\n\t\t,,regs->r10,,regs->r8,,regs->r9)\t\t\t\\\n\n/* Mapping of registers to parameters for syscalls on i386 */\n#define SC_IA32_REGS_TO_ARGS(x, ...)\t\t\t\t\t\\\n\t__MAP(x,__SC_ARGS\t\t\t\t\t\t\\\n\t      ,,(unsigned int)regs->bx,,(unsigned int)regs->cx\t\t\\\n\t      ,,(unsigned int)regs->dx,,(unsigned int)regs->si\t\t\\\n\t      ,,(unsigned int)regs->di,,(unsigned int)regs->bp)\n\n#define __SYS_STUB0(abi, name)\t\t\t\t\t\t\\\n\tlong __##abi##_##name(const struct pt_regs *regs);\t\t\\\n\tALLOW_ERROR_INJECTION(__##abi##_##name, ERRNO);\t\t\t\\\n\tlong __##abi##_##name(const struct pt_regs *regs)\t\t\\\n\t\t__alias(\"__do_\" #name);\n\n#define __SYS_STUBx(abi, name, ...)\t\t\t\t\t\\\n\tlong __##abi##_##name(const struct pt_regs *regs);\t\t\\\n\tALLOW_ERROR_INJECTION(__##abi##_##name, ERRNO);\t\t\t\\\n\tlong __##abi##_##name(const struct pt_regs *regs)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn __se_##name(__VA_ARGS__);\t\t\t\\\n\t}\n\n#define __COND_SYSCALL(abi, name)\t\t\t\t\t\\\n\t__weak long __##abi##_##name(const struct pt_regs *__unused)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn sys_ni_syscall();\t\t\t\t\\\n\t}\n\n#define __SYS_NI(abi, name)\t\t\t\t\t\t\\\n\tSYSCALL_ALIAS(__##abi##_##name, sys_ni_posix_timers);\n\n#ifdef CONFIG_X86_64\n#define __X64_SYS_STUB0(name)\t\t\t\t\t\t\\\n\t__SYS_STUB0(x64, sys_##name)\n\n#define __X64_SYS_STUBx(x, name, ...)\t\t\t\t\t\\\n\t__SYS_STUBx(x64, sys##name,\t\t\t\t\t\\\n\t\t    SC_X86_64_REGS_TO_ARGS(x, __VA_ARGS__))\n\n#define __X64_COND_SYSCALL(name)\t\t\t\t\t\\\n\t__COND_SYSCALL(x64, sys_##name)\n\n#define __X64_SYS_NI(name)\t\t\t\t\t\t\\\n\t__SYS_NI(x64, sys_##name)\n#else /* CONFIG_X86_64 */\n#define __X64_SYS_STUB0(name)\n#define __X64_SYS_STUBx(x, name, ...)\n#define __X64_COND_SYSCALL(name)\n#define __X64_SYS_NI(name)\n#endif /* CONFIG_X86_64 */\n\n#if defined(CONFIG_X86_32) || defined(CONFIG_IA32_EMULATION)\n#define __IA32_SYS_STUB0(name)\t\t\t\t\t\t\\\n\t__SYS_STUB0(ia32, sys_##name)\n\n#define __IA32_SYS_STUBx(x, name, ...)\t\t\t\t\t\\\n\t__SYS_STUBx(ia32, sys##name,\t\t\t\t\t\\\n\t\t    SC_IA32_REGS_TO_ARGS(x, __VA_ARGS__))\n\n#define __IA32_COND_SYSCALL(name)\t\t\t\t\t\\\n\t__COND_SYSCALL(ia32, sys_##name)\n\n#define __IA32_SYS_NI(name)\t\t\t\t\t\t\\\n\t__SYS_NI(ia32, sys_##name)\n#else /* CONFIG_X86_32 || CONFIG_IA32_EMULATION */\n#define __IA32_SYS_STUB0(name)\n#define __IA32_SYS_STUBx(x, name, ...)\n#define __IA32_COND_SYSCALL(name)\n#define __IA32_SYS_NI(name)\n#endif /* CONFIG_X86_32 || CONFIG_IA32_EMULATION */\n\n#ifdef CONFIG_IA32_EMULATION\n/*\n * For IA32 emulation, we need to handle \"compat\" syscalls *and* create\n * additional wrappers (aptly named __ia32_sys_xyzzy) which decode the\n * ia32 regs in the proper order for shared or \"common\" syscalls. As some\n * syscalls may not be implemented, we need to expand COND_SYSCALL in\n * kernel/sys_ni.c and SYS_NI in kernel/time/posix-stubs.c to cover this\n * case as well.\n */\n#define __IA32_COMPAT_SYS_STUB0(name)\t\t\t\t\t\\\n\t__SYS_STUB0(ia32, compat_sys_##name)\n\n#define __IA32_COMPAT_SYS_STUBx(x, name, ...)\t\t\t\t\\\n\t__SYS_STUBx(ia32, compat_sys##name,\t\t\t\t\\\n\t\t    SC_IA32_REGS_TO_ARGS(x, __VA_ARGS__))\n\n#define __IA32_COMPAT_COND_SYSCALL(name)\t\t\t\t\\\n\t__COND_SYSCALL(ia32, compat_sys_##name)\n\n#define __IA32_COMPAT_SYS_NI(name)\t\t\t\t\t\\\n\t__SYS_NI(ia32, compat_sys_##name)\n\n#else /* CONFIG_IA32_EMULATION */\n#define __IA32_COMPAT_SYS_STUB0(name)\n#define __IA32_COMPAT_SYS_STUBx(x, name, ...)\n#define __IA32_COMPAT_COND_SYSCALL(name)\n#define __IA32_COMPAT_SYS_NI(name)\n#endif /* CONFIG_IA32_EMULATION */\n\n\n#ifdef CONFIG_X86_X32\n/*\n * For the x32 ABI, we need to create a stub for compat_sys_*() which is aware\n * of the x86-64-style parameter ordering of x32 syscalls. The syscalls common\n * with x86_64 obviously do not need such care.\n */\n#define __X32_COMPAT_SYS_STUB0(name)\t\t\t\t\t\\\n\t__SYS_STUB0(x32, compat_sys_##name)\n\n#define __X32_COMPAT_SYS_STUBx(x, name, ...)\t\t\t\t\\\n\t__SYS_STUBx(x32, compat_sys##name,\t\t\t\t\\\n\t\t    SC_X86_64_REGS_TO_ARGS(x, __VA_ARGS__))\n\n#define __X32_COMPAT_COND_SYSCALL(name)\t\t\t\t\t\\\n\t__COND_SYSCALL(x32, compat_sys_##name)\n\n#define __X32_COMPAT_SYS_NI(name)\t\t\t\t\t\\\n\t__SYS_NI(x32, compat_sys_##name)\n#else /* CONFIG_X86_X32 */\n#define __X32_COMPAT_SYS_STUB0(name)\n#define __X32_COMPAT_SYS_STUBx(x, name, ...)\n#define __X32_COMPAT_COND_SYSCALL(name)\n#define __X32_COMPAT_SYS_NI(name)\n#endif /* CONFIG_X86_X32 */\n\n\n#ifdef CONFIG_COMPAT\n/*\n * Compat means IA32_EMULATION and/or X86_X32. As they use a different\n * mapping of registers to parameters, we need to generate stubs for each\n * of them.\n */\n#define COMPAT_SYSCALL_DEFINE0(name)\t\t\t\t\t\\\n\tstatic long\t\t\t\t\t\t\t\\\n\t__do_compat_sys_##name(const struct pt_regs *__unused);\t\t\\\n\t__IA32_COMPAT_SYS_STUB0(name)\t\t\t\t\t\\\n\t__X32_COMPAT_SYS_STUB0(name)\t\t\t\t\t\\\n\tstatic long\t\t\t\t\t\t\t\\\n\t__do_compat_sys_##name(const struct pt_regs *__unused)\n\n#define COMPAT_SYSCALL_DEFINEx(x, name, ...)\t\t\t\t\t\\\n\tstatic long __se_compat_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));\t\\\n\tstatic inline long __do_compat_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\\\n\t__IA32_COMPAT_SYS_STUBx(x, name, __VA_ARGS__)\t\t\t\t\\\n\t__X32_COMPAT_SYS_STUBx(x, name, __VA_ARGS__)\t\t\t\t\\\n\tstatic long __se_compat_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))\t\\\n\t{\t\t\t\t\t\t\t\t\t\\\n\t\treturn __do_compat_sys##name(__MAP(x,__SC_DELOUSE,__VA_ARGS__));\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\tstatic inline long __do_compat_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))\n\n/*\n * As some compat syscalls may not be implemented, we need to expand\n * COND_SYSCALL_COMPAT in kernel/sys_ni.c and COMPAT_SYS_NI in\n * kernel/time/posix-stubs.c to cover this case as well.\n */\n#define COND_SYSCALL_COMPAT(name) \t\t\t\t\t\\\n\t__IA32_COMPAT_COND_SYSCALL(name)\t\t\t\t\\\n\t__X32_COMPAT_COND_SYSCALL(name)\n\n#define COMPAT_SYS_NI(name)\t\t\t\t\t\t\\\n\t__IA32_COMPAT_SYS_NI(name)\t\t\t\t\t\\\n\t__X32_COMPAT_SYS_NI(name)\n\n#endif /* CONFIG_COMPAT */\n\n#define __SYSCALL_DEFINEx(x, name, ...)\t\t\t\t\t\\\n\tstatic long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));\t\\\n\tstatic inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\\\n\t__X64_SYS_STUBx(x, name, __VA_ARGS__)\t\t\t\t\\\n\t__IA32_SYS_STUBx(x, name, __VA_ARGS__)\t\t\t\t\\\n\tstatic long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tlong ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\\\n\t\t__MAP(x,__SC_TEST,__VA_ARGS__);\t\t\t\t\\\n\t\t__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tstatic inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))\n\n/*\n * As the generic SYSCALL_DEFINE0() macro does not decode any parameters for\n * obvious reasons, and passing struct pt_regs *regs to it in %rdi does not\n * hurt, we only need to re-define it here to keep the naming congruent to\n * SYSCALL_DEFINEx() -- which is essential for the COND_SYSCALL() and SYS_NI()\n * macros to work correctly.\n */\n#define SYSCALL_DEFINE0(sname)\t\t\t\t\t\t\\\n\tSYSCALL_METADATA(_##sname, 0);\t\t\t\t\t\\\n\tstatic long __do_sys_##sname(const struct pt_regs *__unused);\t\\\n\t__X64_SYS_STUB0(sname)\t\t\t\t\t\t\\\n\t__IA32_SYS_STUB0(sname)\t\t\t\t\t\t\\\n\tstatic long __do_sys_##sname(const struct pt_regs *__unused)\n\n#define COND_SYSCALL(name)\t\t\t\t\t\t\\\n\t__X64_COND_SYSCALL(name)\t\t\t\t\t\\\n\t__IA32_COND_SYSCALL(name)\n\n#define SYS_NI(name)\t\t\t\t\t\t\t\\\n\t__X64_SYS_NI(name)\t\t\t\t\t\t\\\n\t__IA32_SYS_NI(name)\n\n\n/*\n * For VSYSCALLS, we need to declare these three syscalls with the new\n * pt_regs-based calling convention for in-kernel use.\n */\nlong __x64_sys_getcpu(const struct pt_regs *regs);\nlong __x64_sys_gettimeofday(const struct pt_regs *regs);\nlong __x64_sys_time(const struct pt_regs *regs);\n\n#endif /* _ASM_X86_SYSCALL_WRAPPER_H */\n"}, "3": {"id": 3, "path": "/src/include/linux/compiler.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_H\n#define __LINUX_COMPILER_H\n\n#include <linux/compiler_types.h>\n\n#ifndef __ASSEMBLY__\n\n#ifdef __KERNEL__\n\n/*\n * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code\n * to disable branch tracing on a per file basis.\n */\n#if defined(CONFIG_TRACE_BRANCH_PROFILING) \\\n    && !defined(DISABLE_BRANCH_PROFILING) && !defined(__CHECKER__)\nvoid ftrace_likely_update(struct ftrace_likely_data *f, int val,\n\t\t\t  int expect, int is_constant);\n\n#define likely_notrace(x)\t__builtin_expect(!!(x), 1)\n#define unlikely_notrace(x)\t__builtin_expect(!!(x), 0)\n\n#define __branch_check__(x, expect, is_constant) ({\t\t\t\\\n\t\t\tlong ______r;\t\t\t\t\t\\\n\t\t\tstatic struct ftrace_likely_data\t\t\\\n\t\t\t\t__aligned(4)\t\t\t\t\\\n\t\t\t\t__section(\"_ftrace_annotated_branch\")\t\\\n\t\t\t\t______f = {\t\t\t\t\\\n\t\t\t\t.data.func = __func__,\t\t\t\\\n\t\t\t\t.data.file = __FILE__,\t\t\t\\\n\t\t\t\t.data.line = __LINE__,\t\t\t\\\n\t\t\t};\t\t\t\t\t\t\\\n\t\t\t______r = __builtin_expect(!!(x), expect);\t\\\n\t\t\tftrace_likely_update(&______f, ______r,\t\t\\\n\t\t\t\t\t     expect, is_constant);\t\\\n\t\t\t______r;\t\t\t\t\t\\\n\t\t})\n\n/*\n * Using __builtin_constant_p(x) to ignore cases where the return\n * value is always the same.  This idea is taken from a similar patch\n * written by Daniel Walker.\n */\n# ifndef likely\n#  define likely(x)\t(__branch_check__(x, 1, __builtin_constant_p(x)))\n# endif\n# ifndef unlikely\n#  define unlikely(x)\t(__branch_check__(x, 0, __builtin_constant_p(x)))\n# endif\n\n#ifdef CONFIG_PROFILE_ALL_BRANCHES\n/*\n * \"Define 'is'\", Bill Clinton\n * \"Define 'if'\", Steven Rostedt\n */\n#define if(cond, ...) if ( __trace_if_var( !!(cond , ## __VA_ARGS__) ) )\n\n#define __trace_if_var(cond) (__builtin_constant_p(cond) ? (cond) : __trace_if_value(cond))\n\n#define __trace_if_value(cond) ({\t\t\t\\\n\tstatic struct ftrace_branch_data\t\t\\\n\t\t__aligned(4)\t\t\t\t\\\n\t\t__section(\"_ftrace_branch\")\t\t\\\n\t\t__if_trace = {\t\t\t\t\\\n\t\t\t.func = __func__,\t\t\\\n\t\t\t.file = __FILE__,\t\t\\\n\t\t\t.line = __LINE__,\t\t\\\n\t\t};\t\t\t\t\t\\\n\t(cond) ?\t\t\t\t\t\\\n\t\t(__if_trace.miss_hit[1]++,1) :\t\t\\\n\t\t(__if_trace.miss_hit[0]++,0);\t\t\\\n})\n\n#endif /* CONFIG_PROFILE_ALL_BRANCHES */\n\n#else\n# define likely(x)\t__builtin_expect(!!(x), 1)\n# define unlikely(x)\t__builtin_expect(!!(x), 0)\n#endif\n\n/* Optimization barrier */\n#ifndef barrier\n/* The \"volatile\" is due to gcc bugs */\n# define barrier() __asm__ __volatile__(\"\": : :\"memory\")\n#endif\n\n#ifndef barrier_data\n/*\n * This version is i.e. to prevent dead stores elimination on @ptr\n * where gcc and llvm may behave differently when otherwise using\n * normal barrier(): while gcc behavior gets along with a normal\n * barrier(), llvm needs an explicit input variable to be assumed\n * clobbered. The issue is as follows: while the inline asm might\n * access any memory it wants, the compiler could have fit all of\n * @ptr into memory registers instead, and since @ptr never escaped\n * from that, it proved that the inline asm wasn't touching any of\n * it. This version works well with both compilers, i.e. we're telling\n * the compiler that the inline asm absolutely may see the contents\n * of @ptr. See also: https://llvm.org/bugs/show_bug.cgi?id=15495\n */\n# define barrier_data(ptr) __asm__ __volatile__(\"\": :\"r\"(ptr) :\"memory\")\n#endif\n\n/* workaround for GCC PR82365 if needed */\n#ifndef barrier_before_unreachable\n# define barrier_before_unreachable() do { } while (0)\n#endif\n\n/* Unreachable code */\n#ifdef CONFIG_STACK_VALIDATION\n/*\n * These macros help objtool understand GCC code flow for unreachable code.\n * The __COUNTER__ based labels are a hack to make each instance of the macros\n * unique, to convince GCC not to merge duplicate inline asm statements.\n */\n#define annotate_reachable() ({\t\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.reachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define annotate_unreachable() ({\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.unreachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define ASM_UNREACHABLE\t\t\t\t\t\t\t\\\n\t\"999:\\n\\t\"\t\t\t\t\t\t\t\\\n\t\".pushsection .discard.unreachable\\n\\t\"\t\t\t\t\\\n\t\".long 999b - .\\n\\t\"\t\t\t\t\t\t\\\n\t\".popsection\\n\\t\"\n\n/* Annotate a C jump table to allow objtool to follow the code flow */\n#define __annotate_jump_table __section(\".rodata..c_jump_table\")\n\n#else\n#define annotate_reachable()\n#define annotate_unreachable()\n#define __annotate_jump_table\n#endif\n\n#ifndef ASM_UNREACHABLE\n# define ASM_UNREACHABLE\n#endif\n#ifndef unreachable\n# define unreachable() do {\t\t\\\n\tannotate_unreachable();\t\t\\\n\t__builtin_unreachable();\t\\\n} while (0)\n#endif\n\n/*\n * KENTRY - kernel entry point\n * This can be used to annotate symbols (functions or data) that are used\n * without their linker symbol being referenced explicitly. For example,\n * interrupt vector handlers, or functions in the kernel image that are found\n * programatically.\n *\n * Not required for symbols exported with EXPORT_SYMBOL, or initcalls. Those\n * are handled in their own way (with KEEP() in linker scripts).\n *\n * KENTRY can be avoided if the symbols in question are marked as KEEP() in the\n * linker script. For example an architecture could KEEP() its entire\n * boot/exception vector code rather than annotate each function and data.\n */\n#ifndef KENTRY\n# define KENTRY(sym)\t\t\t\t\t\t\\\n\textern typeof(sym) sym;\t\t\t\t\t\\\n\tstatic const unsigned long __kentry_##sym\t\t\\\n\t__used\t\t\t\t\t\t\t\\\n\t__attribute__((__section__(\"___kentry+\" #sym)))\t\t\\\n\t= (unsigned long)&sym;\n#endif\n\n#ifndef RELOC_HIDE\n# define RELOC_HIDE(ptr, off)\t\t\t\t\t\\\n  ({ unsigned long __ptr;\t\t\t\t\t\\\n     __ptr = (unsigned long) (ptr);\t\t\t\t\\\n    (typeof(ptr)) (__ptr + (off)); })\n#endif\n\n#ifndef OPTIMIZER_HIDE_VAR\n/* Make the optimizer believe the variable can be manipulated arbitrarily. */\n#define OPTIMIZER_HIDE_VAR(var)\t\t\t\t\t\t\\\n\t__asm__ (\"\" : \"=r\" (var) : \"0\" (var))\n#endif\n\n/* Not-quite-unique ID. */\n#ifndef __UNIQUE_ID\n# define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)\n#endif\n\n/**\n * data_race - mark an expression as containing intentional data races\n *\n * This data_race() macro is useful for situations in which data races\n * should be forgiven.  One example is diagnostic code that accesses\n * shared variables but is not a part of the core synchronization design.\n *\n * This macro *does not* affect normal code generation, but is a hint\n * to tooling that data races here are to be ignored.\n */\n#define data_race(expr)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__unqual_scalar_typeof(({ expr; })) __v = ({\t\t\t\\\n\t\t__kcsan_disable_current();\t\t\t\t\\\n\t\texpr;\t\t\t\t\t\t\t\\\n\t});\t\t\t\t\t\t\t\t\\\n\t__kcsan_enable_current();\t\t\t\t\t\\\n\t__v;\t\t\t\t\t\t\t\t\\\n})\n\n#endif /* __KERNEL__ */\n\n/*\n * Force the compiler to emit 'sym' as a symbol, so that we can reference\n * it from inline assembler. Necessary in case 'sym' could be inlined\n * otherwise, or eliminated entirely due to lack of references that are\n * visible to the compiler.\n */\n#define __ADDRESSABLE(sym) \\\n\tstatic void * __section(\".discard.addressable\") __used \\\n\t\t__UNIQUE_ID(__PASTE(__addressable_,sym)) = (void *)&sym;\n\n/**\n * offset_to_ptr - convert a relative memory offset to an absolute pointer\n * @off:\tthe address of the 32-bit offset value\n */\nstatic inline void *offset_to_ptr(const int *off)\n{\n\treturn (void *)((unsigned long)off + *off);\n}\n\n#endif /* __ASSEMBLY__ */\n\n/* &a[0] degrades to a pointer: a different type from an array */\n#define __must_be_array(a)\tBUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))\n\n/*\n * This is needed in functions which generate the stack canary, see\n * arch/x86/kernel/smpboot.c::start_secondary() for an example.\n */\n#define prevent_tail_call_optimization()\tmb()\n\n#include <asm/rwonce.h>\n\n#endif /* __LINUX_COMPILER_H */\n"}, "4": {"id": 4, "path": "/src/include/linux/err.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_ERR_H\n#define _LINUX_ERR_H\n\n#include <linux/compiler.h>\n#include <linux/types.h>\n\n#include <asm/errno.h>\n\n/*\n * Kernel pointers have redundant information, so we can use a\n * scheme where we can return either an error code or a normal\n * pointer with the same return value.\n *\n * This should be a per-architecture thing, to allow different\n * error and pointer decisions.\n */\n#define MAX_ERRNO\t4095\n\n#ifndef __ASSEMBLY__\n\n#define IS_ERR_VALUE(x) unlikely((unsigned long)(void *)(x) >= (unsigned long)-MAX_ERRNO)\n\nstatic inline void * __must_check ERR_PTR(long error)\n{\n\treturn (void *) error;\n}\n\nstatic inline long __must_check PTR_ERR(__force const void *ptr)\n{\n\treturn (long) ptr;\n}\n\nstatic inline bool __must_check IS_ERR(__force const void *ptr)\n{\n\treturn IS_ERR_VALUE((unsigned long)ptr);\n}\n\nstatic inline bool __must_check IS_ERR_OR_NULL(__force const void *ptr)\n{\n\treturn unlikely(!ptr) || IS_ERR_VALUE((unsigned long)ptr);\n}\n\n/**\n * ERR_CAST - Explicitly cast an error-valued pointer to another pointer type\n * @ptr: The pointer to cast.\n *\n * Explicitly cast an error-valued pointer to another pointer type in such a\n * way as to make it clear that's what's going on.\n */\nstatic inline void * __must_check ERR_CAST(__force const void *ptr)\n{\n\t/* cast away the const */\n\treturn (void *) ptr;\n}\n\nstatic inline int __must_check PTR_ERR_OR_ZERO(__force const void *ptr)\n{\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\telse\n\t\treturn 0;\n}\n\n#endif\n\n#endif /* _LINUX_ERR_H */\n"}, "5": {"id": 5, "path": "/src/include/linux/cred.h", "content": "/* SPDX-License-Identifier: GPL-2.0-or-later */\n/* Credentials management - see Documentation/security/credentials.rst\n *\n * Copyright (C) 2008 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n */\n\n#ifndef _LINUX_CRED_H\n#define _LINUX_CRED_H\n\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/key.h>\n#include <linux/atomic.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/sched/user.h>\n\nstruct cred;\nstruct inode;\n\n/*\n * COW Supplementary groups list\n */\nstruct group_info {\n\tatomic_t\tusage;\n\tint\t\tngroups;\n\tkgid_t\t\tgid[0];\n} __randomize_layout;\n\n/**\n * get_group_info - Get a reference to a group info structure\n * @group_info: The group info to reference\n *\n * This gets a reference to a set of supplementary groups.\n *\n * If the caller is accessing a task's credentials, they must hold the RCU read\n * lock when reading.\n */\nstatic inline struct group_info *get_group_info(struct group_info *gi)\n{\n\tatomic_inc(&gi->usage);\n\treturn gi;\n}\n\n/**\n * put_group_info - Release a reference to a group info structure\n * @group_info: The group info to release\n */\n#define put_group_info(group_info)\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (atomic_dec_and_test(&(group_info)->usage))\t\\\n\t\tgroups_free(group_info);\t\t\\\n} while (0)\n\nextern struct group_info init_groups;\n#ifdef CONFIG_MULTIUSER\nextern struct group_info *groups_alloc(int);\nextern void groups_free(struct group_info *);\n\nextern int in_group_p(kgid_t);\nextern int in_egroup_p(kgid_t);\nextern int groups_search(const struct group_info *, kgid_t);\n\nextern int set_current_groups(struct group_info *);\nextern void set_groups(struct cred *, struct group_info *);\nextern bool may_setgroups(void);\nextern void groups_sort(struct group_info *);\n#else\nstatic inline void groups_free(struct group_info *group_info)\n{\n}\n\nstatic inline int in_group_p(kgid_t grp)\n{\n        return 1;\n}\nstatic inline int in_egroup_p(kgid_t grp)\n{\n        return 1;\n}\nstatic inline int groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\treturn 1;\n}\n#endif\n\n/*\n * The security context of a task\n *\n * The parts of the context break down into two categories:\n *\n *  (1) The objective context of a task.  These parts are used when some other\n *\ttask is attempting to affect this one.\n *\n *  (2) The subjective context.  These details are used when the task is acting\n *\tupon another object, be that a file, a task, a key or whatever.\n *\n * Note that some members of this structure belong to both categories - the\n * LSM security pointer for instance.\n *\n * A task has two security pointers.  task->real_cred points to the objective\n * context that defines that task's actual details.  The objective part of this\n * context is used whenever that task is acted upon.\n *\n * task->cred points to the subjective context that defines the details of how\n * that task is going to act upon another object.  This may be overridden\n * temporarily to point to another security context, but normally points to the\n * same context as task->real_cred.\n */\nstruct cred {\n\tatomic_t\tusage;\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tatomic_t\tsubscribers;\t/* number of processes subscribed */\n\tvoid\t\t*put_addr;\n\tunsigned\tmagic;\n#define CRED_MAGIC\t0x43736564\n#define CRED_MAGIC_DEAD\t0x44656144\n#endif\n\tkuid_t\t\tuid;\t\t/* real UID of the task */\n\tkgid_t\t\tgid;\t\t/* real GID of the task */\n\tkuid_t\t\tsuid;\t\t/* saved UID of the task */\n\tkgid_t\t\tsgid;\t\t/* saved GID of the task */\n\tkuid_t\t\teuid;\t\t/* effective UID of the task */\n\tkgid_t\t\tegid;\t\t/* effective GID of the task */\n\tkuid_t\t\tfsuid;\t\t/* UID for VFS ops */\n\tkgid_t\t\tfsgid;\t\t/* GID for VFS ops */\n\tunsigned\tsecurebits;\t/* SUID-less security management */\n\tkernel_cap_t\tcap_inheritable; /* caps our children can inherit */\n\tkernel_cap_t\tcap_permitted;\t/* caps we're permitted */\n\tkernel_cap_t\tcap_effective;\t/* caps we can actually use */\n\tkernel_cap_t\tcap_bset;\t/* capability bounding set */\n\tkernel_cap_t\tcap_ambient;\t/* Ambient capability set */\n#ifdef CONFIG_KEYS\n\tunsigned char\tjit_keyring;\t/* default keyring to attach requested\n\t\t\t\t\t * keys to */\n\tstruct key\t*session_keyring; /* keyring inherited over fork */\n\tstruct key\t*process_keyring; /* keyring private to this process */\n\tstruct key\t*thread_keyring; /* keyring private to this thread */\n\tstruct key\t*request_key_auth; /* assumed request_key authority */\n#endif\n#ifdef CONFIG_SECURITY\n\tvoid\t\t*security;\t/* subjective LSM security */\n#endif\n\tstruct user_struct *user;\t/* real user ID subscription */\n\tstruct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */\n\tstruct group_info *group_info;\t/* supplementary groups for euid/fsgid */\n\t/* RCU deletion */\n\tunion {\n\t\tint non_rcu;\t\t\t/* Can we skip RCU deletion? */\n\t\tstruct rcu_head\trcu;\t\t/* RCU deletion hook */\n\t};\n} __randomize_layout;\n\nextern void __put_cred(struct cred *);\nextern void exit_creds(struct task_struct *);\nextern int copy_creds(struct task_struct *, unsigned long);\nextern const struct cred *get_task_cred(struct task_struct *);\nextern struct cred *cred_alloc_blank(void);\nextern struct cred *prepare_creds(void);\nextern struct cred *prepare_exec_creds(void);\nextern int commit_creds(struct cred *);\nextern void abort_creds(struct cred *);\nextern const struct cred *override_creds(const struct cred *);\nextern void revert_creds(const struct cred *);\nextern struct cred *prepare_kernel_cred(struct task_struct *);\nextern int change_create_files_as(struct cred *, struct inode *);\nextern int set_security_override(struct cred *, u32);\nextern int set_security_override_from_ctx(struct cred *, const char *);\nextern int set_create_files_as(struct cred *, struct inode *);\nextern int cred_fscmp(const struct cred *, const struct cred *);\nextern void __init cred_init(void);\n\n/*\n * check for validity of credentials\n */\n#ifdef CONFIG_DEBUG_CREDENTIALS\nextern void __invalid_creds(const struct cred *, const char *, unsigned);\nextern void __validate_process_creds(struct task_struct *,\n\t\t\t\t     const char *, unsigned);\n\nextern bool creds_are_invalid(const struct cred *cred);\n\nstatic inline void __validate_creds(const struct cred *cred,\n\t\t\t\t    const char *file, unsigned line)\n{\n\tif (unlikely(creds_are_invalid(cred)))\n\t\t__invalid_creds(cred, file, line);\n}\n\n#define validate_creds(cred)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\t__validate_creds((cred), __FILE__, __LINE__);\t\\\n} while(0)\n\n#define validate_process_creds()\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\t__validate_process_creds(current, __FILE__, __LINE__);\t\\\n} while(0)\n\nextern void validate_creds_for_do_exit(struct task_struct *);\n#else\nstatic inline void validate_creds(const struct cred *cred)\n{\n}\nstatic inline void validate_creds_for_do_exit(struct task_struct *tsk)\n{\n}\nstatic inline void validate_process_creds(void)\n{\n}\n#endif\n\nstatic inline bool cap_ambient_invariant_ok(const struct cred *cred)\n{\n\treturn cap_issubset(cred->cap_ambient,\n\t\t\t    cap_intersect(cred->cap_permitted,\n\t\t\t\t\t  cred->cap_inheritable));\n}\n\n/**\n * get_new_cred - Get a reference on a new set of credentials\n * @cred: The new credentials to reference\n *\n * Get a reference on the specified set of new credentials.  The caller must\n * release the reference.\n */\nstatic inline struct cred *get_new_cred(struct cred *cred)\n{\n\tatomic_inc(&cred->usage);\n\treturn cred;\n}\n\n/**\n * get_cred - Get a reference on a set of credentials\n * @cred: The credentials to reference\n *\n * Get a reference on the specified set of credentials.  The caller must\n * release the reference.  If %NULL is passed, it is returned with no action.\n *\n * This is used to deal with a committed set of credentials.  Although the\n * pointer is const, this will temporarily discard the const and increment the\n * usage count.  The purpose of this is to attempt to catch at compile time the\n * accidental alteration of a set of credentials that should be considered\n * immutable.\n */\nstatic inline const struct cred *get_cred(const struct cred *cred)\n{\n\tstruct cred *nonconst_cred = (struct cred *) cred;\n\tif (!cred)\n\t\treturn cred;\n\tvalidate_creds(cred);\n\tnonconst_cred->non_rcu = 0;\n\treturn get_new_cred(nonconst_cred);\n}\n\nstatic inline const struct cred *get_cred_rcu(const struct cred *cred)\n{\n\tstruct cred *nonconst_cred = (struct cred *) cred;\n\tif (!cred)\n\t\treturn NULL;\n\tif (!atomic_inc_not_zero(&nonconst_cred->usage))\n\t\treturn NULL;\n\tvalidate_creds(cred);\n\tnonconst_cred->non_rcu = 0;\n\treturn cred;\n}\n\n/**\n * put_cred - Release a reference to a set of credentials\n * @cred: The credentials to release\n *\n * Release a reference to a set of credentials, deleting them when the last ref\n * is released.  If %NULL is passed, nothing is done.\n *\n * This takes a const pointer to a set of credentials because the credentials\n * on task_struct are attached by const pointers to prevent accidental\n * alteration of otherwise immutable credential sets.\n */\nstatic inline void put_cred(const struct cred *_cred)\n{\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tif (cred) {\n\t\tvalidate_creds(cred);\n\t\tif (atomic_dec_and_test(&(cred)->usage))\n\t\t\t__put_cred(cred);\n\t}\n}\n\n/**\n * current_cred - Access the current task's subjective credentials\n *\n * Access the subjective credentials of the current task.  RCU-safe,\n * since nobody else can modify it.\n */\n#define current_cred() \\\n\trcu_dereference_protected(current->cred, 1)\n\n/**\n * current_real_cred - Access the current task's objective credentials\n *\n * Access the objective credentials of the current task.  RCU-safe,\n * since nobody else can modify it.\n */\n#define current_real_cred() \\\n\trcu_dereference_protected(current->real_cred, 1)\n\n/**\n * __task_cred - Access a task's objective credentials\n * @task: The task to query\n *\n * Access the objective credentials of a task.  The caller must hold the RCU\n * readlock.\n *\n * The result of this function should not be passed directly to get_cred();\n * rather get_task_cred() should be used instead.\n */\n#define __task_cred(task)\t\\\n\trcu_dereference((task)->real_cred)\n\n/**\n * get_current_cred - Get the current task's subjective credentials\n *\n * Get the subjective credentials of the current task, pinning them so that\n * they can't go away.  Accessing the current task's credentials directly is\n * not permitted.\n */\n#define get_current_cred()\t\t\t\t\\\n\t(get_cred(current_cred()))\n\n/**\n * get_current_user - Get the current task's user_struct\n *\n * Get the user record of the current task, pinning it so that it can't go\n * away.\n */\n#define get_current_user()\t\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tstruct user_struct *__u;\t\t\t\\\n\tconst struct cred *__cred;\t\t\t\\\n\t__cred = current_cred();\t\t\t\\\n\t__u = get_uid(__cred->user);\t\t\t\\\n\t__u;\t\t\t\t\t\t\\\n})\n\n/**\n * get_current_groups - Get the current task's supplementary group list\n *\n * Get the supplementary group list of the current task, pinning it so that it\n * can't go away.\n */\n#define get_current_groups()\t\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tstruct group_info *__groups;\t\t\t\\\n\tconst struct cred *__cred;\t\t\t\\\n\t__cred = current_cred();\t\t\t\\\n\t__groups = get_group_info(__cred->group_info);\t\\\n\t__groups;\t\t\t\t\t\\\n})\n\n#define task_cred_xxx(task, xxx)\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\t__typeof__(((struct cred *)NULL)->xxx) ___val;\t\\\n\trcu_read_lock();\t\t\t\t\\\n\t___val = __task_cred((task))->xxx;\t\t\\\n\trcu_read_unlock();\t\t\t\t\\\n\t___val;\t\t\t\t\t\t\\\n})\n\n#define task_uid(task)\t\t(task_cred_xxx((task), uid))\n#define task_euid(task)\t\t(task_cred_xxx((task), euid))\n\n#define current_cred_xxx(xxx)\t\t\t\\\n({\t\t\t\t\t\t\\\n\tcurrent_cred()->xxx;\t\t\t\\\n})\n\n#define current_uid()\t\t(current_cred_xxx(uid))\n#define current_gid()\t\t(current_cred_xxx(gid))\n#define current_euid()\t\t(current_cred_xxx(euid))\n#define current_egid()\t\t(current_cred_xxx(egid))\n#define current_suid()\t\t(current_cred_xxx(suid))\n#define current_sgid()\t\t(current_cred_xxx(sgid))\n#define current_fsuid() \t(current_cred_xxx(fsuid))\n#define current_fsgid() \t(current_cred_xxx(fsgid))\n#define current_cap()\t\t(current_cred_xxx(cap_effective))\n#define current_user()\t\t(current_cred_xxx(user))\n\nextern struct user_namespace init_user_ns;\n#ifdef CONFIG_USER_NS\n#define current_user_ns()\t(current_cred_xxx(user_ns))\n#else\nstatic inline struct user_namespace *current_user_ns(void)\n{\n\treturn &init_user_ns;\n}\n#endif\n\n\n#define current_uid_gid(_uid, _gid)\t\t\\\ndo {\t\t\t\t\t\t\\\n\tconst struct cred *__cred;\t\t\\\n\t__cred = current_cred();\t\t\\\n\t*(_uid) = __cred->uid;\t\t\t\\\n\t*(_gid) = __cred->gid;\t\t\t\\\n} while(0)\n\n#define current_euid_egid(_euid, _egid)\t\t\\\ndo {\t\t\t\t\t\t\\\n\tconst struct cred *__cred;\t\t\\\n\t__cred = current_cred();\t\t\\\n\t*(_euid) = __cred->euid;\t\t\\\n\t*(_egid) = __cred->egid;\t\t\\\n} while(0)\n\n#define current_fsuid_fsgid(_fsuid, _fsgid)\t\\\ndo {\t\t\t\t\t\t\\\n\tconst struct cred *__cred;\t\t\\\n\t__cred = current_cred();\t\t\\\n\t*(_fsuid) = __cred->fsuid;\t\t\\\n\t*(_fsgid) = __cred->fsgid;\t\t\\\n} while(0)\n\n#endif /* _LINUX_CRED_H */\n"}, "6": {"id": 6, "path": "/src/include/linux/rcupdate.h", "content": "/* SPDX-License-Identifier: GPL-2.0+ */\n/*\n * Read-Copy Update mechanism for mutual exclusion\n *\n * Copyright IBM Corporation, 2001\n *\n * Author: Dipankar Sarma <dipankar@in.ibm.com>\n *\n * Based on the original work by Paul McKenney <paulmck@vnet.ibm.com>\n * and inputs from Rusty Russell, Andrea Arcangeli and Andi Kleen.\n * Papers:\n * http://www.rdrop.com/users/paulmck/paper/rclockpdcsproof.pdf\n * http://lse.sourceforge.net/locking/rclock_OLS.2001.05.01c.sc.pdf (OLS2001)\n *\n * For detailed explanation of Read-Copy Update mechanism see -\n *\t\thttp://lse.sourceforge.net/locking/rcupdate.html\n *\n */\n\n#ifndef __LINUX_RCUPDATE_H\n#define __LINUX_RCUPDATE_H\n\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/irqflags.h>\n#include <linux/preempt.h>\n#include <linux/bottom_half.h>\n#include <linux/lockdep.h>\n#include <asm/processor.h>\n#include <linux/cpumask.h>\n\n#define ULONG_CMP_GE(a, b)\t(ULONG_MAX / 2 >= (a) - (b))\n#define ULONG_CMP_LT(a, b)\t(ULONG_MAX / 2 < (a) - (b))\n#define ulong2long(a)\t\t(*(long *)(&(a)))\n\n/* Exported common interfaces */\nvoid call_rcu(struct rcu_head *head, rcu_callback_t func);\nvoid rcu_barrier_tasks(void);\nvoid rcu_barrier_tasks_rude(void);\nvoid synchronize_rcu(void);\n\n#ifdef CONFIG_PREEMPT_RCU\n\nvoid __rcu_read_lock(void);\nvoid __rcu_read_unlock(void);\n\n/*\n * Defined as a macro as it is a very low level header included from\n * areas that don't even know about current.  This gives the rcu_read_lock()\n * nesting depth, but makes sense only if CONFIG_PREEMPT_RCU -- in other\n * types of kernel builds, the rcu_read_lock() nesting depth is unknowable.\n */\n#define rcu_preempt_depth() (current->rcu_read_lock_nesting)\n\n#else /* #ifdef CONFIG_PREEMPT_RCU */\n\n#ifdef CONFIG_TINY_RCU\n#define rcu_read_unlock_strict() do { } while (0)\n#else\nvoid rcu_read_unlock_strict(void);\n#endif\n\nstatic inline void __rcu_read_lock(void)\n{\n\tpreempt_disable();\n}\n\nstatic inline void __rcu_read_unlock(void)\n{\n\tpreempt_enable();\n\trcu_read_unlock_strict();\n}\n\nstatic inline int rcu_preempt_depth(void)\n{\n\treturn 0;\n}\n\n#endif /* #else #ifdef CONFIG_PREEMPT_RCU */\n\n/* Internal to kernel */\nvoid rcu_init(void);\nextern int rcu_scheduler_active __read_mostly;\nvoid rcu_sched_clock_irq(int user);\nvoid rcu_report_dead(unsigned int cpu);\nvoid rcutree_migrate_callbacks(int cpu);\n\n#ifdef CONFIG_RCU_STALL_COMMON\nvoid rcu_sysrq_start(void);\nvoid rcu_sysrq_end(void);\n#else /* #ifdef CONFIG_RCU_STALL_COMMON */\nstatic inline void rcu_sysrq_start(void) { }\nstatic inline void rcu_sysrq_end(void) { }\n#endif /* #else #ifdef CONFIG_RCU_STALL_COMMON */\n\n#ifdef CONFIG_NO_HZ_FULL\nvoid rcu_user_enter(void);\nvoid rcu_user_exit(void);\n#else\nstatic inline void rcu_user_enter(void) { }\nstatic inline void rcu_user_exit(void) { }\n#endif /* CONFIG_NO_HZ_FULL */\n\n#ifdef CONFIG_RCU_NOCB_CPU\nvoid rcu_init_nohz(void);\n#else /* #ifdef CONFIG_RCU_NOCB_CPU */\nstatic inline void rcu_init_nohz(void) { }\n#endif /* #else #ifdef CONFIG_RCU_NOCB_CPU */\n\n/**\n * RCU_NONIDLE - Indicate idle-loop code that needs RCU readers\n * @a: Code that RCU needs to pay attention to.\n *\n * RCU read-side critical sections are forbidden in the inner idle loop,\n * that is, between the rcu_idle_enter() and the rcu_idle_exit() -- RCU\n * will happily ignore any such read-side critical sections.  However,\n * things like powertop need tracepoints in the inner idle loop.\n *\n * This macro provides the way out:  RCU_NONIDLE(do_something_with_RCU())\n * will tell RCU that it needs to pay attention, invoke its argument\n * (in this example, calling the do_something_with_RCU() function),\n * and then tell RCU to go back to ignoring this CPU.  It is permissible\n * to nest RCU_NONIDLE() wrappers, but not indefinitely (but the limit is\n * on the order of a million or so, even on 32-bit systems).  It is\n * not legal to block within RCU_NONIDLE(), nor is it permissible to\n * transfer control either into or out of RCU_NONIDLE()'s statement.\n */\n#define RCU_NONIDLE(a) \\\n\tdo { \\\n\t\trcu_irq_enter_irqson(); \\\n\t\tdo { a; } while (0); \\\n\t\trcu_irq_exit_irqson(); \\\n\t} while (0)\n\n/*\n * Note a quasi-voluntary context switch for RCU-tasks's benefit.\n * This is a macro rather than an inline function to avoid #include hell.\n */\n#ifdef CONFIG_TASKS_RCU_GENERIC\n\n# ifdef CONFIG_TASKS_RCU\n# define rcu_tasks_classic_qs(t, preempt)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!(preempt) && READ_ONCE((t)->rcu_tasks_holdout))\t\\\n\t\t\tWRITE_ONCE((t)->rcu_tasks_holdout, false);\t\\\n\t} while (0)\nvoid call_rcu_tasks(struct rcu_head *head, rcu_callback_t func);\nvoid synchronize_rcu_tasks(void);\n# else\n# define rcu_tasks_classic_qs(t, preempt) do { } while (0)\n# define call_rcu_tasks call_rcu\n# define synchronize_rcu_tasks synchronize_rcu\n# endif\n\n# ifdef CONFIG_TASKS_RCU_TRACE\n# define rcu_tasks_trace_qs(t)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!likely(READ_ONCE((t)->trc_reader_checked)) &&\t\\\n\t\t    !unlikely(READ_ONCE((t)->trc_reader_nesting))) {\t\\\n\t\t\tsmp_store_release(&(t)->trc_reader_checked, true); \\\n\t\t\tsmp_mb(); /* Readers partitioned by store. */\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n# else\n# define rcu_tasks_trace_qs(t) do { } while (0)\n# endif\n\n#define rcu_tasks_qs(t, preempt)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\trcu_tasks_classic_qs((t), (preempt));\t\t\t\t\\\n\trcu_tasks_trace_qs((t));\t\t\t\t\t\\\n} while (0)\n\n# ifdef CONFIG_TASKS_RUDE_RCU\nvoid call_rcu_tasks_rude(struct rcu_head *head, rcu_callback_t func);\nvoid synchronize_rcu_tasks_rude(void);\n# endif\n\n#define rcu_note_voluntary_context_switch(t) rcu_tasks_qs(t, false)\nvoid exit_tasks_rcu_start(void);\nvoid exit_tasks_rcu_finish(void);\n#else /* #ifdef CONFIG_TASKS_RCU_GENERIC */\n#define rcu_tasks_qs(t, preempt) do { } while (0)\n#define rcu_note_voluntary_context_switch(t) do { } while (0)\n#define call_rcu_tasks call_rcu\n#define synchronize_rcu_tasks synchronize_rcu\nstatic inline void exit_tasks_rcu_start(void) { }\nstatic inline void exit_tasks_rcu_finish(void) { }\n#endif /* #else #ifdef CONFIG_TASKS_RCU_GENERIC */\n\n/**\n * cond_resched_tasks_rcu_qs - Report potential quiescent states to RCU\n *\n * This macro resembles cond_resched(), except that it is defined to\n * report potential quiescent states to RCU-tasks even if the cond_resched()\n * machinery were to be shut off, as some advocate for PREEMPTION kernels.\n */\n#define cond_resched_tasks_rcu_qs() \\\ndo { \\\n\trcu_tasks_qs(current, false); \\\n\tcond_resched(); \\\n} while (0)\n\n/*\n * Infrastructure to implement the synchronize_() primitives in\n * TREE_RCU and rcu_barrier_() primitives in TINY_RCU.\n */\n\n#if defined(CONFIG_TREE_RCU)\n#include <linux/rcutree.h>\n#elif defined(CONFIG_TINY_RCU)\n#include <linux/rcutiny.h>\n#else\n#error \"Unknown RCU implementation specified to kernel configuration\"\n#endif\n\n/*\n * The init_rcu_head_on_stack() and destroy_rcu_head_on_stack() calls\n * are needed for dynamic initialization and destruction of rcu_head\n * on the stack, and init_rcu_head()/destroy_rcu_head() are needed for\n * dynamic initialization and destruction of statically allocated rcu_head\n * structures.  However, rcu_head structures allocated dynamically in the\n * heap don't need any initialization.\n */\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\nvoid init_rcu_head(struct rcu_head *head);\nvoid destroy_rcu_head(struct rcu_head *head);\nvoid init_rcu_head_on_stack(struct rcu_head *head);\nvoid destroy_rcu_head_on_stack(struct rcu_head *head);\n#else /* !CONFIG_DEBUG_OBJECTS_RCU_HEAD */\nstatic inline void init_rcu_head(struct rcu_head *head) { }\nstatic inline void destroy_rcu_head(struct rcu_head *head) { }\nstatic inline void init_rcu_head_on_stack(struct rcu_head *head) { }\nstatic inline void destroy_rcu_head_on_stack(struct rcu_head *head) { }\n#endif\t/* #else !CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n\n#if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU)\nbool rcu_lockdep_current_cpu_online(void);\n#else /* #if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU) */\nstatic inline bool rcu_lockdep_current_cpu_online(void) { return true; }\n#endif /* #else #if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU) */\n\nextern struct lockdep_map rcu_lock_map;\nextern struct lockdep_map rcu_bh_lock_map;\nextern struct lockdep_map rcu_sched_lock_map;\nextern struct lockdep_map rcu_callback_map;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\nstatic inline void rcu_lock_acquire(struct lockdep_map *map)\n{\n\tlock_acquire(map, 0, 0, 2, 0, NULL, _THIS_IP_);\n}\n\nstatic inline void rcu_lock_release(struct lockdep_map *map)\n{\n\tlock_release(map, _THIS_IP_);\n}\n\nint debug_lockdep_rcu_enabled(void);\nint rcu_read_lock_held(void);\nint rcu_read_lock_bh_held(void);\nint rcu_read_lock_sched_held(void);\nint rcu_read_lock_any_held(void);\n\n#else /* #ifdef CONFIG_DEBUG_LOCK_ALLOC */\n\n# define rcu_lock_acquire(a)\t\tdo { } while (0)\n# define rcu_lock_release(a)\t\tdo { } while (0)\n\nstatic inline int rcu_read_lock_held(void)\n{\n\treturn 1;\n}\n\nstatic inline int rcu_read_lock_bh_held(void)\n{\n\treturn 1;\n}\n\nstatic inline int rcu_read_lock_sched_held(void)\n{\n\treturn !preemptible();\n}\n\nstatic inline int rcu_read_lock_any_held(void)\n{\n\treturn !preemptible();\n}\n\n#endif /* #else #ifdef CONFIG_DEBUG_LOCK_ALLOC */\n\n#ifdef CONFIG_PROVE_RCU\n\n/**\n * RCU_LOCKDEP_WARN - emit lockdep splat if specified condition is met\n * @c: condition to check\n * @s: informative message\n */\n#define RCU_LOCKDEP_WARN(c, s)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstatic bool __section(\".data.unlikely\") __warned;\t\\\n\t\tif (debug_lockdep_rcu_enabled() && !__warned && (c)) {\t\\\n\t\t\t__warned = true;\t\t\t\t\\\n\t\t\tlockdep_rcu_suspicious(__FILE__, __LINE__, s);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#if defined(CONFIG_PROVE_RCU) && !defined(CONFIG_PREEMPT_RCU)\nstatic inline void rcu_preempt_sleep_check(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_lock_map),\n\t\t\t \"Illegal context switch in RCU read-side critical section\");\n}\n#else /* #ifdef CONFIG_PROVE_RCU */\nstatic inline void rcu_preempt_sleep_check(void) { }\n#endif /* #else #ifdef CONFIG_PROVE_RCU */\n\n#define rcu_sleep_check()\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\trcu_preempt_sleep_check();\t\t\t\t\\\n\t\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map),\t\\\n\t\t\t\t \"Illegal context switch in RCU-bh read-side critical section\"); \\\n\t\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_sched_lock_map),\t\\\n\t\t\t\t \"Illegal context switch in RCU-sched read-side critical section\"); \\\n\t} while (0)\n\n#else /* #ifdef CONFIG_PROVE_RCU */\n\n#define RCU_LOCKDEP_WARN(c, s) do { } while (0 && (c))\n#define rcu_sleep_check() do { } while (0)\n\n#endif /* #else #ifdef CONFIG_PROVE_RCU */\n\n/*\n * Helper functions for rcu_dereference_check(), rcu_dereference_protected()\n * and rcu_assign_pointer().  Some of these could be folded into their\n * callers, but they are left separate in order to ease introduction of\n * multiple pointers markings to match different RCU implementations\n * (e.g., __srcu), should this make sense in the future.\n */\n\n#ifdef __CHECKER__\n#define rcu_check_sparse(p, space) \\\n\t((void)(((typeof(*p) space *)p) == p))\n#else /* #ifdef __CHECKER__ */\n#define rcu_check_sparse(p, space)\n#endif /* #else #ifdef __CHECKER__ */\n\n#define __rcu_access_pointer(p, space) \\\n({ \\\n\ttypeof(*p) *_________p1 = (typeof(*p) *__force)READ_ONCE(p); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(_________p1)); \\\n})\n#define __rcu_dereference_check(p, c, space) \\\n({ \\\n\t/* Dependency order vs. p above. */ \\\n\ttypeof(*p) *________p1 = (typeof(*p) *__force)READ_ONCE(p); \\\n\tRCU_LOCKDEP_WARN(!(c), \"suspicious rcu_dereference_check() usage\"); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(________p1)); \\\n})\n#define __rcu_dereference_protected(p, c, space) \\\n({ \\\n\tRCU_LOCKDEP_WARN(!(c), \"suspicious rcu_dereference_protected() usage\"); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(p)); \\\n})\n#define rcu_dereference_raw(p) \\\n({ \\\n\t/* Dependency order vs. p above. */ \\\n\ttypeof(p) ________p1 = READ_ONCE(p); \\\n\t((typeof(*p) __force __kernel *)(________p1)); \\\n})\n\n/**\n * RCU_INITIALIZER() - statically initialize an RCU-protected global variable\n * @v: The value to statically initialize with.\n */\n#define RCU_INITIALIZER(v) (typeof(*(v)) __force __rcu *)(v)\n\n/**\n * rcu_assign_pointer() - assign to RCU-protected pointer\n * @p: pointer to assign to\n * @v: value to assign (publish)\n *\n * Assigns the specified value to the specified RCU-protected\n * pointer, ensuring that any concurrent RCU readers will see\n * any prior initialization.\n *\n * Inserts memory barriers on architectures that require them\n * (which is most of them), and also prevents the compiler from\n * reordering the code that initializes the structure after the pointer\n * assignment.  More importantly, this call documents which pointers\n * will be dereferenced by RCU read-side code.\n *\n * In some special cases, you may use RCU_INIT_POINTER() instead\n * of rcu_assign_pointer().  RCU_INIT_POINTER() is a bit faster due\n * to the fact that it does not constrain either the CPU or the compiler.\n * That said, using RCU_INIT_POINTER() when you should have used\n * rcu_assign_pointer() is a very bad thing that results in\n * impossible-to-diagnose memory corruption.  So please be careful.\n * See the RCU_INIT_POINTER() comment header for details.\n *\n * Note that rcu_assign_pointer() evaluates each of its arguments only\n * once, appearances notwithstanding.  One of the \"extra\" evaluations\n * is in typeof() and the other visible only to sparse (__CHECKER__),\n * neither of which actually execute the argument.  As with most cpp\n * macros, this execute-arguments-only-once property is important, so\n * please be careful when making changes to rcu_assign_pointer() and the\n * other macros that it invokes.\n */\n#define rcu_assign_pointer(p, v)\t\t\t\t\t      \\\ndo {\t\t\t\t\t\t\t\t\t      \\\n\tuintptr_t _r_a_p__v = (uintptr_t)(v);\t\t\t\t      \\\n\trcu_check_sparse(p, __rcu);\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (__builtin_constant_p(v) && (_r_a_p__v) == (uintptr_t)NULL)\t      \\\n\t\tWRITE_ONCE((p), (typeof(p))(_r_a_p__v));\t\t      \\\n\telse\t\t\t\t\t\t\t\t      \\\n\t\tsmp_store_release(&p, RCU_INITIALIZER((typeof(p))_r_a_p__v)); \\\n} while (0)\n\n/**\n * rcu_replace_pointer() - replace an RCU pointer, returning its old value\n * @rcu_ptr: RCU pointer, whose old value is returned\n * @ptr: regular pointer\n * @c: the lockdep conditions under which the dereference will take place\n *\n * Perform a replacement, where @rcu_ptr is an RCU-annotated\n * pointer and @c is the lockdep argument that is passed to the\n * rcu_dereference_protected() call used to read that pointer.  The old\n * value of @rcu_ptr is returned, and @rcu_ptr is set to @ptr.\n */\n#define rcu_replace_pointer(rcu_ptr, ptr, c)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(ptr) __tmp = rcu_dereference_protected((rcu_ptr), (c));\t\\\n\trcu_assign_pointer((rcu_ptr), (ptr));\t\t\t\t\\\n\t__tmp;\t\t\t\t\t\t\t\t\\\n})\n\n/**\n * rcu_access_pointer() - fetch RCU pointer with no dereferencing\n * @p: The pointer to read\n *\n * Return the value of the specified RCU-protected pointer, but omit the\n * lockdep checks for being in an RCU read-side critical section.  This is\n * useful when the value of this pointer is accessed, but the pointer is\n * not dereferenced, for example, when testing an RCU-protected pointer\n * against NULL.  Although rcu_access_pointer() may also be used in cases\n * where update-side locks prevent the value of the pointer from changing,\n * you should instead use rcu_dereference_protected() for this use case.\n *\n * It is also permissible to use rcu_access_pointer() when read-side\n * access to the pointer was removed at least one grace period ago, as\n * is the case in the context of the RCU callback that is freeing up\n * the data, or after a synchronize_rcu() returns.  This can be useful\n * when tearing down multi-linked structures after a grace period\n * has elapsed.\n */\n#define rcu_access_pointer(p) __rcu_access_pointer((p), __rcu)\n\n/**\n * rcu_dereference_check() - rcu_dereference with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * Do an rcu_dereference(), but check that the conditions under which the\n * dereference will take place are correct.  Typically the conditions\n * indicate the various locking conditions that should be held at that\n * point.  The check should return true if the conditions are satisfied.\n * An implicit check for being in an RCU read-side critical section\n * (rcu_read_lock()) is included.\n *\n * For example:\n *\n *\tbar = rcu_dereference_check(foo->bar, lockdep_is_held(&foo->lock));\n *\n * could be used to indicate to lockdep that foo->bar may only be dereferenced\n * if either rcu_read_lock() is held, or that the lock required to replace\n * the bar struct at foo->bar is held.\n *\n * Note that the list of conditions may also include indications of when a lock\n * need not be held, for example during initialisation or destruction of the\n * target struct:\n *\n *\tbar = rcu_dereference_check(foo->bar, lockdep_is_held(&foo->lock) ||\n *\t\t\t\t\t      atomic_read(&foo->usage) == 0);\n *\n * Inserts memory barriers on architectures that require them\n * (currently only the Alpha), prevents the compiler from refetching\n * (and from merging fetches), and, more importantly, documents exactly\n * which pointers are protected by RCU and checks that the pointer is\n * annotated as __rcu.\n */\n#define rcu_dereference_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_held(), __rcu)\n\n/**\n * rcu_dereference_bh_check() - rcu_dereference_bh with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * This is the RCU-bh counterpart to rcu_dereference_check().\n */\n#define rcu_dereference_bh_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_bh_held(), __rcu)\n\n/**\n * rcu_dereference_sched_check() - rcu_dereference_sched with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * This is the RCU-sched counterpart to rcu_dereference_check().\n */\n#define rcu_dereference_sched_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_sched_held(), \\\n\t\t\t\t__rcu)\n\n/*\n * The tracing infrastructure traces RCU (we want that), but unfortunately\n * some of the RCU checks causes tracing to lock up the system.\n *\n * The no-tracing version of rcu_dereference_raw() must not call\n * rcu_read_lock_held().\n */\n#define rcu_dereference_raw_check(p) __rcu_dereference_check((p), 1, __rcu)\n\n/**\n * rcu_dereference_protected() - fetch RCU pointer when updates prevented\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * Return the value of the specified RCU-protected pointer, but omit\n * the READ_ONCE().  This is useful in cases where update-side locks\n * prevent the value of the pointer from changing.  Please note that this\n * primitive does *not* prevent the compiler from repeating this reference\n * or combining it with other references, so it should not be used without\n * protection of appropriate locks.\n *\n * This function is only for update-side use.  Using this function\n * when protected only by rcu_read_lock() will result in infrequent\n * but very ugly failures.\n */\n#define rcu_dereference_protected(p, c) \\\n\t__rcu_dereference_protected((p), (c), __rcu)\n\n\n/**\n * rcu_dereference() - fetch RCU-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * This is a simple wrapper around rcu_dereference_check().\n */\n#define rcu_dereference(p) rcu_dereference_check(p, 0)\n\n/**\n * rcu_dereference_bh() - fetch an RCU-bh-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * Makes rcu_dereference_check() do the dirty work.\n */\n#define rcu_dereference_bh(p) rcu_dereference_bh_check(p, 0)\n\n/**\n * rcu_dereference_sched() - fetch RCU-sched-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * Makes rcu_dereference_check() do the dirty work.\n */\n#define rcu_dereference_sched(p) rcu_dereference_sched_check(p, 0)\n\n/**\n * rcu_pointer_handoff() - Hand off a pointer from RCU to other mechanism\n * @p: The pointer to hand off\n *\n * This is simply an identity function, but it documents where a pointer\n * is handed off from RCU to some other synchronization mechanism, for\n * example, reference counting or locking.  In C11, it would map to\n * kill_dependency().  It could be used as follows::\n *\n *\trcu_read_lock();\n *\tp = rcu_dereference(gp);\n *\tlong_lived = is_long_lived(p);\n *\tif (long_lived) {\n *\t\tif (!atomic_inc_not_zero(p->refcnt))\n *\t\t\tlong_lived = false;\n *\t\telse\n *\t\t\tp = rcu_pointer_handoff(p);\n *\t}\n *\trcu_read_unlock();\n */\n#define rcu_pointer_handoff(p) (p)\n\n/**\n * rcu_read_lock() - mark the beginning of an RCU read-side critical section\n *\n * When synchronize_rcu() is invoked on one CPU while other CPUs\n * are within RCU read-side critical sections, then the\n * synchronize_rcu() is guaranteed to block until after all the other\n * CPUs exit their critical sections.  Similarly, if call_rcu() is invoked\n * on one CPU while other CPUs are within RCU read-side critical\n * sections, invocation of the corresponding RCU callback is deferred\n * until after the all the other CPUs exit their critical sections.\n *\n * Note, however, that RCU callbacks are permitted to run concurrently\n * with new RCU read-side critical sections.  One way that this can happen\n * is via the following sequence of events: (1) CPU 0 enters an RCU\n * read-side critical section, (2) CPU 1 invokes call_rcu() to register\n * an RCU callback, (3) CPU 0 exits the RCU read-side critical section,\n * (4) CPU 2 enters a RCU read-side critical section, (5) the RCU\n * callback is invoked.  This is legal, because the RCU read-side critical\n * section that was running concurrently with the call_rcu() (and which\n * therefore might be referencing something that the corresponding RCU\n * callback would free up) has completed before the corresponding\n * RCU callback is invoked.\n *\n * RCU read-side critical sections may be nested.  Any deferred actions\n * will be deferred until the outermost RCU read-side critical section\n * completes.\n *\n * You can avoid reading and understanding the next paragraph by\n * following this rule: don't put anything in an rcu_read_lock() RCU\n * read-side critical section that would block in a !PREEMPTION kernel.\n * But if you want the full story, read on!\n *\n * In non-preemptible RCU implementations (pure TREE_RCU and TINY_RCU),\n * it is illegal to block while in an RCU read-side critical section.\n * In preemptible RCU implementations (PREEMPT_RCU) in CONFIG_PREEMPTION\n * kernel builds, RCU read-side critical sections may be preempted,\n * but explicit blocking is illegal.  Finally, in preemptible RCU\n * implementations in real-time (with -rt patchset) kernel builds, RCU\n * read-side critical sections may be preempted and they may also block, but\n * only when acquiring spinlocks that are subject to priority inheritance.\n */\nstatic __always_inline void rcu_read_lock(void)\n{\n\t__rcu_read_lock();\n\t__acquire(RCU);\n\trcu_lock_acquire(&rcu_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock() used illegally while idle\");\n}\n\n/*\n * So where is rcu_write_lock()?  It does not exist, as there is no\n * way for writers to lock out RCU readers.  This is a feature, not\n * a bug -- this property is what provides RCU's performance benefits.\n * Of course, writers must coordinate with each other.  The normal\n * spinlock primitives work well for this, but any other technique may be\n * used as well.  RCU does not care how the writers keep out of each\n * others' way, as long as they do so.\n */\n\n/**\n * rcu_read_unlock() - marks the end of an RCU read-side critical section.\n *\n * In most situations, rcu_read_unlock() is immune from deadlock.\n * However, in kernels built with CONFIG_RCU_BOOST, rcu_read_unlock()\n * is responsible for deboosting, which it does via rt_mutex_unlock().\n * Unfortunately, this function acquires the scheduler's runqueue and\n * priority-inheritance spinlocks.  This means that deadlock could result\n * if the caller of rcu_read_unlock() already holds one of these locks or\n * any lock that is ever acquired while holding them.\n *\n * That said, RCU readers are never priority boosted unless they were\n * preempted.  Therefore, one way to avoid deadlock is to make sure\n * that preemption never happens within any RCU read-side critical\n * section whose outermost rcu_read_unlock() is called with one of\n * rt_mutex_unlock()'s locks held.  Such preemption can be avoided in\n * a number of ways, for example, by invoking preempt_disable() before\n * critical section's outermost rcu_read_lock().\n *\n * Given that the set of locks acquired by rt_mutex_unlock() might change\n * at any time, a somewhat more future-proofed approach is to make sure\n * that that preemption never happens within any RCU read-side critical\n * section whose outermost rcu_read_unlock() is called with irqs disabled.\n * This approach relies on the fact that rt_mutex_unlock() currently only\n * acquires irq-disabled locks.\n *\n * The second of these two approaches is best in most situations,\n * however, the first approach can also be useful, at least to those\n * developers willing to keep abreast of the set of locks acquired by\n * rt_mutex_unlock().\n *\n * See rcu_read_lock() for more information.\n */\nstatic inline void rcu_read_unlock(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock() used illegally while idle\");\n\t__release(RCU);\n\t__rcu_read_unlock();\n\trcu_lock_release(&rcu_lock_map); /* Keep acq info for rls diags. */\n}\n\n/**\n * rcu_read_lock_bh() - mark the beginning of an RCU-bh critical section\n *\n * This is equivalent of rcu_read_lock(), but also disables softirqs.\n * Note that anything else that disables softirqs can also serve as\n * an RCU read-side critical section.\n *\n * Note that rcu_read_lock_bh() and the matching rcu_read_unlock_bh()\n * must occur in the same context, for example, it is illegal to invoke\n * rcu_read_unlock_bh() from one task if the matching rcu_read_lock_bh()\n * was invoked from some other task.\n */\nstatic inline void rcu_read_lock_bh(void)\n{\n\tlocal_bh_disable();\n\t__acquire(RCU_BH);\n\trcu_lock_acquire(&rcu_bh_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock_bh() used illegally while idle\");\n}\n\n/**\n * rcu_read_unlock_bh() - marks the end of a softirq-only RCU critical section\n *\n * See rcu_read_lock_bh() for more information.\n */\nstatic inline void rcu_read_unlock_bh(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock_bh() used illegally while idle\");\n\trcu_lock_release(&rcu_bh_lock_map);\n\t__release(RCU_BH);\n\tlocal_bh_enable();\n}\n\n/**\n * rcu_read_lock_sched() - mark the beginning of a RCU-sched critical section\n *\n * This is equivalent of rcu_read_lock(), but disables preemption.\n * Read-side critical sections can also be introduced by anything else\n * that disables preemption, including local_irq_disable() and friends.\n *\n * Note that rcu_read_lock_sched() and the matching rcu_read_unlock_sched()\n * must occur in the same context, for example, it is illegal to invoke\n * rcu_read_unlock_sched() from process context if the matching\n * rcu_read_lock_sched() was invoked from an NMI handler.\n */\nstatic inline void rcu_read_lock_sched(void)\n{\n\tpreempt_disable();\n\t__acquire(RCU_SCHED);\n\trcu_lock_acquire(&rcu_sched_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock_sched() used illegally while idle\");\n}\n\n/* Used by lockdep and tracing: cannot be traced, cannot call lockdep. */\nstatic inline notrace void rcu_read_lock_sched_notrace(void)\n{\n\tpreempt_disable_notrace();\n\t__acquire(RCU_SCHED);\n}\n\n/**\n * rcu_read_unlock_sched() - marks the end of a RCU-classic critical section\n *\n * See rcu_read_lock_sched() for more information.\n */\nstatic inline void rcu_read_unlock_sched(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock_sched() used illegally while idle\");\n\trcu_lock_release(&rcu_sched_lock_map);\n\t__release(RCU_SCHED);\n\tpreempt_enable();\n}\n\n/* Used by lockdep and tracing: cannot be traced, cannot call lockdep. */\nstatic inline notrace void rcu_read_unlock_sched_notrace(void)\n{\n\t__release(RCU_SCHED);\n\tpreempt_enable_notrace();\n}\n\n/**\n * RCU_INIT_POINTER() - initialize an RCU protected pointer\n * @p: The pointer to be initialized.\n * @v: The value to initialized the pointer to.\n *\n * Initialize an RCU-protected pointer in special cases where readers\n * do not need ordering constraints on the CPU or the compiler.  These\n * special cases are:\n *\n * 1.\tThis use of RCU_INIT_POINTER() is NULLing out the pointer *or*\n * 2.\tThe caller has taken whatever steps are required to prevent\n *\tRCU readers from concurrently accessing this pointer *or*\n * 3.\tThe referenced data structure has already been exposed to\n *\treaders either at compile time or via rcu_assign_pointer() *and*\n *\n *\ta.\tYou have not made *any* reader-visible changes to\n *\t\tthis structure since then *or*\n *\tb.\tIt is OK for readers accessing this structure from its\n *\t\tnew location to see the old state of the structure.  (For\n *\t\texample, the changes were to statistical counters or to\n *\t\tother state where exact synchronization is not required.)\n *\n * Failure to follow these rules governing use of RCU_INIT_POINTER() will\n * result in impossible-to-diagnose memory corruption.  As in the structures\n * will look OK in crash dumps, but any concurrent RCU readers might\n * see pre-initialized values of the referenced data structure.  So\n * please be very careful how you use RCU_INIT_POINTER()!!!\n *\n * If you are creating an RCU-protected linked structure that is accessed\n * by a single external-to-structure RCU-protected pointer, then you may\n * use RCU_INIT_POINTER() to initialize the internal RCU-protected\n * pointers, but you must use rcu_assign_pointer() to initialize the\n * external-to-structure pointer *after* you have completely initialized\n * the reader-accessible portions of the linked structure.\n *\n * Note that unlike rcu_assign_pointer(), RCU_INIT_POINTER() provides no\n * ordering guarantees for either the CPU or the compiler.\n */\n#define RCU_INIT_POINTER(p, v) \\\n\tdo { \\\n\t\trcu_check_sparse(p, __rcu); \\\n\t\tWRITE_ONCE(p, RCU_INITIALIZER(v)); \\\n\t} while (0)\n\n/**\n * RCU_POINTER_INITIALIZER() - statically initialize an RCU protected pointer\n * @p: The pointer to be initialized.\n * @v: The value to initialized the pointer to.\n *\n * GCC-style initialization for an RCU-protected pointer in a structure field.\n */\n#define RCU_POINTER_INITIALIZER(p, v) \\\n\t\t.p = RCU_INITIALIZER(v)\n\n/*\n * Does the specified offset indicate that the corresponding rcu_head\n * structure can be handled by kvfree_rcu()?\n */\n#define __is_kvfree_rcu_offset(offset) ((offset) < 4096)\n\n/*\n * Helper macro for kfree_rcu() to prevent argument-expansion eyestrain.\n */\n#define __kvfree_rcu(head, offset) \\\n\tdo { \\\n\t\tBUILD_BUG_ON(!__is_kvfree_rcu_offset(offset)); \\\n\t\tkvfree_call_rcu(head, (rcu_callback_t)(unsigned long)(offset)); \\\n\t} while (0)\n\n/**\n * kfree_rcu() - kfree an object after a grace period.\n * @ptr:\tpointer to kfree\n * @rhf:\tthe name of the struct rcu_head within the type of @ptr.\n *\n * Many rcu callbacks functions just call kfree() on the base structure.\n * These functions are trivial, but their size adds up, and furthermore\n * when they are used in a kernel module, that module must invoke the\n * high-latency rcu_barrier() function at module-unload time.\n *\n * The kfree_rcu() function handles this issue.  Rather than encoding a\n * function address in the embedded rcu_head structure, kfree_rcu() instead\n * encodes the offset of the rcu_head structure within the base structure.\n * Because the functions are not allowed in the low-order 4096 bytes of\n * kernel virtual memory, offsets up to 4095 bytes can be accommodated.\n * If the offset is larger than 4095 bytes, a compile-time error will\n * be generated in __kvfree_rcu(). If this error is triggered, you can\n * either fall back to use of call_rcu() or rearrange the structure to\n * position the rcu_head structure into the first 4096 bytes.\n *\n * Note that the allowable offset might decrease in the future, for example,\n * to allow something like kmem_cache_free_rcu().\n *\n * The BUILD_BUG_ON check must not involve any function calls, hence the\n * checks are done in macros here.\n */\n#define kfree_rcu(ptr, rhf)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\ttypeof (ptr) ___p = (ptr);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (___p)\t\t\t\t\t\t\t\\\n\t\t__kvfree_rcu(&((___p)->rhf), offsetof(typeof(*(ptr)), rhf)); \\\n} while (0)\n\n/**\n * kvfree_rcu() - kvfree an object after a grace period.\n *\n * This macro consists of one or two arguments and it is\n * based on whether an object is head-less or not. If it\n * has a head then a semantic stays the same as it used\n * to be before:\n *\n *     kvfree_rcu(ptr, rhf);\n *\n * where @ptr is a pointer to kvfree(), @rhf is the name\n * of the rcu_head structure within the type of @ptr.\n *\n * When it comes to head-less variant, only one argument\n * is passed and that is just a pointer which has to be\n * freed after a grace period. Therefore the semantic is\n *\n *     kvfree_rcu(ptr);\n *\n * where @ptr is a pointer to kvfree().\n *\n * Please note, head-less way of freeing is permitted to\n * use from a context that has to follow might_sleep()\n * annotation. Otherwise, please switch and embed the\n * rcu_head structure within the type of @ptr.\n */\n#define kvfree_rcu(...) KVFREE_GET_MACRO(__VA_ARGS__,\t\t\\\n\tkvfree_rcu_arg_2, kvfree_rcu_arg_1)(__VA_ARGS__)\n\n#define KVFREE_GET_MACRO(_1, _2, NAME, ...) NAME\n#define kvfree_rcu_arg_2(ptr, rhf) kfree_rcu(ptr, rhf)\n#define kvfree_rcu_arg_1(ptr)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\ttypeof(ptr) ___p = (ptr);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (___p)\t\t\t\t\t\t\\\n\t\tkvfree_call_rcu(NULL, (rcu_callback_t) (___p));\t\\\n} while (0)\n\n/*\n * Place this after a lock-acquisition primitive to guarantee that\n * an UNLOCK+LOCK pair acts as a full barrier.  This guarantee applies\n * if the UNLOCK and LOCK are executed by the same CPU or if the\n * UNLOCK and LOCK operate on the same lock variable.\n */\n#ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE\n#define smp_mb__after_unlock_lock()\tsmp_mb()  /* Full ordering for lock. */\n#else /* #ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE */\n#define smp_mb__after_unlock_lock()\tdo { } while (0)\n#endif /* #else #ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE */\n\n\n/* Has the specified rcu_head structure been handed to call_rcu()? */\n\n/**\n * rcu_head_init - Initialize rcu_head for rcu_head_after_call_rcu()\n * @rhp: The rcu_head structure to initialize.\n *\n * If you intend to invoke rcu_head_after_call_rcu() to test whether a\n * given rcu_head structure has already been passed to call_rcu(), then\n * you must also invoke this rcu_head_init() function on it just after\n * allocating that structure.  Calls to this function must not race with\n * calls to call_rcu(), rcu_head_after_call_rcu(), or callback invocation.\n */\nstatic inline void rcu_head_init(struct rcu_head *rhp)\n{\n\trhp->func = (rcu_callback_t)~0L;\n}\n\n/**\n * rcu_head_after_call_rcu() - Has this rcu_head been passed to call_rcu()?\n * @rhp: The rcu_head structure to test.\n * @f: The function passed to call_rcu() along with @rhp.\n *\n * Returns @true if the @rhp has been passed to call_rcu() with @func,\n * and @false otherwise.  Emits a warning in any other case, including\n * the case where @rhp has already been invoked after a grace period.\n * Calls to this function must not race with callback invocation.  One way\n * to avoid such races is to enclose the call to rcu_head_after_call_rcu()\n * in an RCU read-side critical section that includes a read-side fetch\n * of the pointer to the structure containing @rhp.\n */\nstatic inline bool\nrcu_head_after_call_rcu(struct rcu_head *rhp, rcu_callback_t f)\n{\n\trcu_callback_t func = READ_ONCE(rhp->func);\n\n\tif (func == f)\n\t\treturn true;\n\tWARN_ON_ONCE(func != (rcu_callback_t)~0L);\n\treturn false;\n}\n\n/* kernel/ksysfs.c definitions */\nextern int rcu_expedited;\nextern int rcu_normal;\n\n#endif /* __LINUX_RCUPDATE_H */\n"}}, "reports": [{"events": [{"location": {"col": 1, "file": 0, "line": 4169}, "message": "Calling '__se_sys_link'"}, {"location": {"col": 36, "file": 1, "line": 214}, "message": "expanded from macro 'SYSCALL_DEFINE2'"}, {"location": {"col": 2, "file": 1, "line": 224}, "message": "expanded from macro 'SYSCALL_DEFINEx'"}, {"location": {"col": 2, "file": 2, "line": 231}, "message": "expanded from macro '__SYSCALL_DEFINEx'"}, {"location": {"col": 2, "file": 2, "line": 116}, "message": "expanded from macro '__IA32_SYS_STUBx'"}, {"location": {"col": 10, "file": 2, "line": 79}, "message": "expanded from macro '__SYS_STUBx'"}, {"location": {"col": 2, "file": 0, "line": 496}, "message": "1st function call argument is an uninitialized value"}], "macros": [], "notes": [], "path": "/src/fs/namei.c", "reportHash": "0b18b753abdf48ac712e259e5aa0a542", "checkerName": "clang-analyzer-core.CallAndMessage", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 3, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 2431}, "message": "'type' declared without an initial value"}, {"location": {"col": 13, "file": 0, "line": 2433}, "message": "Calling 'filename_parentat'"}, {"location": {"col": 2, "file": 0, "line": 2405}, "message": "Taking false branch"}, {"location": {"col": 15, "file": 0, "line": 2409}, "message": "Assuming the condition is false"}, {"location": {"col": 42, "file": 3, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 2409}, "message": "Taking false branch"}, {"location": {"col": 15, "file": 0, "line": 2411}, "message": "Assuming the condition is false"}, {"location": {"col": 42, "file": 3, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 2411}, "message": "Taking false branch"}, {"location": {"col": 14, "file": 0, "line": 2413}, "message": "'retval' is not equal to 0"}, {"location": {"col": 40, "file": 3, "line": 77}, "message": "expanded from macro 'likely'"}, {"location": {"col": 2, "file": 0, "line": 2413}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 2422}, "message": "Returning without writing to '*type'"}, {"location": {"col": 13, "file": 0, "line": 2433}, "message": "Returning from 'filename_parentat'"}, {"location": {"col": 6, "file": 0, "line": 2435}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 4, "line": 36}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 4, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 3, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 4, "line": 36}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 2435}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 2, "file": 0, "line": 2435}, "message": "Taking false branch"}, {"location": {"col": 20, "file": 0, "line": 2437}, "message": "The left operand of '!=' is a garbage value"}, {"location": {"col": 42, "file": 3, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 20, "file": 0, "line": 2437}, "message": "The left operand of '!=' is a garbage value"}], "macros": [], "notes": [], "path": "/src/fs/namei.c", "reportHash": "d6b23debc0c505e5ff6ae0ea2c5bae03", "checkerName": "clang-analyzer-core.UndefinedBinaryOperatorResult", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 0, "line": 3396}, "message": "Calling 'path_openat'"}, {"location": {"col": 41, "file": 0, "line": 3355}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 5, "line": 298}, "message": "expanded from macro 'current_cred'"}, {"location": {"col": 2, "file": 6, "line": 548}, "message": "expanded from macro 'rcu_dereference_protected'"}, {"location": {"col": 2, "file": 6, "line": 367}, "message": "expanded from macro '__rcu_dereference_protected'"}, {"location": {"col": 48, "file": 6, "line": 331}, "message": "expanded from macro 'RCU_LOCKDEP_WARN'"}, {"location": {"col": 41, "file": 0, "line": 3355}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 5, "line": 298}, "message": "expanded from macro 'current_cred'"}, {"location": {"col": 2, "file": 6, "line": 548}, "message": "expanded from macro 'rcu_dereference_protected'"}, {"location": {"col": 2, "file": 6, "line": 367}, "message": "expanded from macro '__rcu_dereference_protected'"}, {"location": {"col": 32, "file": 6, "line": 331}, "message": "expanded from macro 'RCU_LOCKDEP_WARN'"}, {"location": {"col": 2, "file": 0, "line": 3356}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3359}, "message": "Assuming the condition is true"}, {"location": {"col": 40, "file": 3, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 3359}, "message": "Taking false branch"}, {"location": {"col": 13, "file": 0, "line": 3361}, "message": "Assuming the condition is true"}, {"location": {"col": 40, "file": 3, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 9, "file": 0, "line": 3361}, "message": "Taking false branch"}, {"location": {"col": 12, "file": 0, "line": 3365}, "message": "Assuming 'error' is 0"}, {"location": {"col": 10, "file": 0, "line": 3365}, "message": "Left side of '&&' is true"}, {"location": {"col": 15, "file": 0, "line": 3366}, "message": "Calling 'open_last_lookups'"}, {"location": {"col": 2, "file": 0, "line": 3127}, "message": "'inode' declared without an initial value"}, {"location": {"col": 6, "file": 0, "line": 3134}, "message": "Assuming field 'last_type' is equal to LAST_NORM"}, {"location": {"col": 2, "file": 0, "line": 3134}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3140}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 0, "line": 3140}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 3141}, "message": "Assuming the condition is true"}, {"location": {"col": 3, "file": 0, "line": 3141}, "message": "Taking true branch"}, {"location": {"col": 12, "file": 0, "line": 3144}, "message": "Calling 'lookup_fast'"}, {"location": {"col": 6, "file": 0, "line": 1465}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1465}, "message": "Taking false branch"}, {"location": {"col": 16, "file": 0, "line": 1503}, "message": "Assuming 'dentry' is non-null"}, {"location": {"col": 42, "file": 3, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 3, "file": 0, "line": 1503}, "message": "Taking false branch"}, {"location": {"col": 15, "file": 0, "line": 1507}, "message": "Assuming 'status' is > 0"}, {"location": {"col": 42, "file": 3, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 1507}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1513}, "message": "Returning without writing to '*inode'"}, {"location": {"col": 12, "file": 0, "line": 3144}, "message": "Returning from 'lookup_fast'"}, {"location": {"col": 7, "file": 0, "line": 3145}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 4, "line": 36}, "message": "Assuming the condition is false"}, {"location": {"col": 34, "file": 4, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 3, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 4, "line": 36}, "message": "Returning zero, which participates in a condition later"}, {"location": {"col": 7, "file": 0, "line": 3145}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 3, "file": 0, "line": 3145}, "message": "Taking false branch"}, {"location": {"col": 14, "file": 0, "line": 3147}, "message": "'dentry' is non-null"}, {"location": {"col": 40, "file": 3, "line": 77}, "message": "expanded from macro 'likely'"}, {"location": {"col": 3, "file": 0, "line": 3147}, "message": "Taking true branch"}, {"location": {"col": 4, "file": 0, "line": 3148}, "message": "Control jumps to line 3199"}, {"location": {"col": 6, "file": 0, "line": 3199}, "message": "Assuming field 'depth' is 0"}, {"location": {"col": 2, "file": 0, "line": 3199}, "message": "Taking false branch"}, {"location": {"col": 8, "file": 0, "line": 3201}, "message": "4th function call argument is an uninitialized value"}, {"location": {"col": 8, "file": 0, "line": 3201}, "message": "4th function call argument is an uninitialized value"}], "macros": [], "notes": [], "path": "/src/fs/namei.c", "reportHash": "be33947e9b32cd44ef4fe2d574ba836c", "checkerName": "clang-analyzer-core.CallAndMessage", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 0, "line": 4169}, "message": "Calling '__se_sys_link'"}, {"location": {"col": 36, "file": 1, "line": 214}, "message": "expanded from macro 'SYSCALL_DEFINE2'"}, {"location": {"col": 2, "file": 1, "line": 224}, "message": "expanded from macro 'SYSCALL_DEFINEx'"}, {"location": {"col": 2, "file": 2, "line": 231}, "message": "expanded from macro '__SYSCALL_DEFINEx'"}, {"location": {"col": 2, "file": 2, "line": 116}, "message": "expanded from macro '__IA32_SYS_STUBx'"}, {"location": {"col": 10, "file": 2, "line": 79}, "message": "expanded from macro '__SYS_STUBx'"}, {"location": {"col": 20, "file": 0, "line": 3458}, "message": "The left operand of '!=' is a garbage value"}], "macros": [], "notes": [], "path": "/src/fs/namei.c", "reportHash": "dc380fe6b3787e5da3df6d8a361f6aab", "checkerName": "clang-analyzer-core.UndefinedBinaryOperatorResult", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 0, "line": 3941}, "message": "Calling '__se_sys_unlink'"}, {"location": {"col": 36, "file": 1, "line": 213}, "message": "expanded from macro 'SYSCALL_DEFINE1'"}, {"location": {"col": 2, "file": 1, "line": 224}, "message": "expanded from macro 'SYSCALL_DEFINEx'"}, {"location": {"col": 2, "file": 2, "line": 231}, "message": "expanded from macro '__SYSCALL_DEFINEx'"}, {"location": {"col": 2, "file": 2, "line": 116}, "message": "expanded from macro '__IA32_SYS_STUBx'"}, {"location": {"col": 10, "file": 2, "line": 79}, "message": "expanded from macro '__SYS_STUBx'"}, {"location": {"col": 11, "file": 0, "line": 3876}, "message": "The left operand of '!=' is a garbage value"}], "macros": [], "notes": [], "path": "/src/fs/namei.c", "reportHash": "d6369a1252114a9234ec245b5c8a24fe", "checkerName": "clang-analyzer-core.UndefinedBinaryOperatorResult", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 0, "line": 4169}, "message": "Calling '__se_sys_link'"}, {"location": {"col": 36, "file": 1, "line": 214}, "message": "expanded from macro 'SYSCALL_DEFINE2'"}, {"location": {"col": 2, "file": 1, "line": 224}, "message": "expanded from macro 'SYSCALL_DEFINEx'"}, {"location": {"col": 2, "file": 2, "line": 231}, "message": "expanded from macro '__SYSCALL_DEFINEx'"}, {"location": {"col": 2, "file": 2, "line": 116}, "message": "expanded from macro '__IA32_SYS_STUBx'"}, {"location": {"col": 10, "file": 2, "line": 79}, "message": "expanded from macro '__SYS_STUBx'"}, {"location": {"col": 19, "file": 0, "line": 4134}, "message": "The left operand of '!=' is a garbage value"}], "macros": [], "notes": [], "path": "/src/fs/namei.c", "reportHash": "cd8442033b42f2cf87fd61772eb62cdd", "checkerName": "clang-analyzer-core.UndefinedBinaryOperatorResult", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 0, "line": 4509}, "message": "Calling '__se_sys_rename'"}, {"location": {"col": 36, "file": 1, "line": 214}, "message": "expanded from macro 'SYSCALL_DEFINE2'"}, {"location": {"col": 2, "file": 1, "line": 224}, "message": "expanded from macro 'SYSCALL_DEFINEx'"}, {"location": {"col": 2, "file": 2, "line": 231}, "message": "expanded from macro '__SYSCALL_DEFINEx'"}, {"location": {"col": 2, "file": 2, "line": 116}, "message": "expanded from macro '__IA32_SYS_STUBx'"}, {"location": {"col": 10, "file": 2, "line": 79}, "message": "expanded from macro '__SYS_STUBx'"}, {"location": {"col": 19, "file": 0, "line": 4390}, "message": "The left operand of '!=' is a garbage value"}], "macros": [], "notes": [], "path": "/src/fs/namei.c", "reportHash": "cd8442033b42f2cf87fd61772eb62cdd", "checkerName": "clang-analyzer-core.UndefinedBinaryOperatorResult", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
