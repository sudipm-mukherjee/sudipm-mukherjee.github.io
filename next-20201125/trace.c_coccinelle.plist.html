<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/kernel/trace/trace.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n * ring buffer based function tracer\n *\n * Copyright (C) 2007-2012 Steven Rostedt <srostedt@redhat.com>\n * Copyright (C) 2008 Ingo Molnar <mingo@redhat.com>\n *\n * Originally taken from the RT patch by:\n *    Arnaldo Carvalho de Melo <acme@redhat.com>\n *\n * Based on code from the latency_tracer, that is:\n *  Copyright (C) 2004-2006 Ingo Molnar\n *  Copyright (C) 2004 Nadia Yvette Chambers\n */\n#include <linux/ring_buffer.h>\n#include <generated/utsrelease.h>\n#include <linux/stacktrace.h>\n#include <linux/writeback.h>\n#include <linux/kallsyms.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/notifier.h>\n#include <linux/irqflags.h>\n#include <linux/debugfs.h>\n#include <linux/tracefs.h>\n#include <linux/pagemap.h>\n#include <linux/hardirq.h>\n#include <linux/linkage.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/percpu.h>\n#include <linux/splice.h>\n#include <linux/kdebug.h>\n#include <linux/string.h>\n#include <linux/mount.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/nmi.h>\n#include <linux/fs.h>\n#include <linux/trace.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/rt.h>\n#include <linux/fsnotify.h>\n#include <linux/irq_work.h>\n#include <linux/workqueue.h>\n\n#include \"trace.h\"\n#include \"trace_output.h\"\n\n/*\n * On boot up, the ring buffer is set to the minimum size, so that\n * we do not waste memory on systems that are not using tracing.\n */\nbool ring_buffer_expanded;\n\n/*\n * We need to change this state when a selftest is running.\n * A selftest will lurk into the ring-buffer to count the\n * entries inserted during the selftest although some concurrent\n * insertions into the ring-buffer such as trace_printk could occurred\n * at the same time, giving false positive or negative results.\n */\nstatic bool __read_mostly tracing_selftest_running;\n\n/*\n * If a tracer is running, we do not want to run SELFTEST.\n */\nbool __read_mostly tracing_selftest_disabled;\n\n/* Pipe tracepoints to printk */\nstruct trace_iterator *tracepoint_print_iter;\nint tracepoint_printk;\nstatic DEFINE_STATIC_KEY_FALSE(tracepoint_printk_key);\n\n/* For tracers that don't implement custom flags */\nstatic struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};\n\nstatic int\ndummy_set_flag(struct trace_array *tr, u32 old_flags, u32 bit, int set)\n{\n\treturn 0;\n}\n\n/*\n * To prevent the comm cache from being overwritten when no\n * tracing is active, only save the comm when a trace event\n * occurred.\n */\nstatic DEFINE_PER_CPU(bool, trace_taskinfo_save);\n\n/*\n * Kill all tracing for good (never come back).\n * It is initialized to 1 but will turn to zero if the initialization\n * of the tracer is successful. But that is the only place that sets\n * this back to zero.\n */\nstatic int tracing_disabled = 1;\n\ncpumask_var_t __read_mostly\ttracing_buffer_mask;\n\n/*\n * ftrace_dump_on_oops - variable to dump ftrace buffer on oops\n *\n * If there is an oops (or kernel panic) and the ftrace_dump_on_oops\n * is set, then ftrace_dump is called. This will output the contents\n * of the ftrace buffers to the console.  This is very useful for\n * capturing traces that lead to crashes and outputing it to a\n * serial console.\n *\n * It is default off, but you can enable it with either specifying\n * \"ftrace_dump_on_oops\" in the kernel command line, or setting\n * /proc/sys/kernel/ftrace_dump_on_oops\n * Set 1 if you want to dump buffers of all CPUs\n * Set 2 if you want to dump the buffer of the CPU that triggered oops\n */\n\nenum ftrace_dump_mode ftrace_dump_on_oops;\n\n/* When set, tracing will stop when a WARN*() is hit */\nint __disable_trace_on_warning;\n\n#ifdef CONFIG_TRACE_EVAL_MAP_FILE\n/* Map of enums to their values, for \"eval_map\" file */\nstruct trace_eval_map_head {\n\tstruct module\t\t\t*mod;\n\tunsigned long\t\t\tlength;\n};\n\nunion trace_eval_map_item;\n\nstruct trace_eval_map_tail {\n\t/*\n\t * \"end\" is first and points to NULL as it must be different\n\t * than \"mod\" or \"eval_string\"\n\t */\n\tunion trace_eval_map_item\t*next;\n\tconst char\t\t\t*end;\t/* points to NULL */\n};\n\nstatic DEFINE_MUTEX(trace_eval_mutex);\n\n/*\n * The trace_eval_maps are saved in an array with two extra elements,\n * one at the beginning, and one at the end. The beginning item contains\n * the count of the saved maps (head.length), and the module they\n * belong to if not built in (head.mod). The ending item contains a\n * pointer to the next array of saved eval_map items.\n */\nunion trace_eval_map_item {\n\tstruct trace_eval_map\t\tmap;\n\tstruct trace_eval_map_head\thead;\n\tstruct trace_eval_map_tail\ttail;\n};\n\nstatic union trace_eval_map_item *trace_eval_maps;\n#endif /* CONFIG_TRACE_EVAL_MAP_FILE */\n\nint tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic void ftrace_trace_userstack(struct trace_buffer *buffer,\n\t\t\t\t   unsigned long flags, int pc);\n\n#define MAX_TRACER_SIZE\t\t100\nstatic char bootup_tracer_buf[MAX_TRACER_SIZE] __initdata;\nstatic char *default_bootup_tracer;\n\nstatic bool allocate_snapshot;\n\nstatic int __init set_cmdline_ftrace(char *str)\n{\n\tstrlcpy(bootup_tracer_buf, str, MAX_TRACER_SIZE);\n\tdefault_bootup_tracer = bootup_tracer_buf;\n\t/* We are using ftrace early, expand it */\n\tring_buffer_expanded = true;\n\treturn 1;\n}\n__setup(\"ftrace=\", set_cmdline_ftrace);\n\nstatic int __init set_ftrace_dump_on_oops(char *str)\n{\n\tif (*str++ != '=' || !*str) {\n\t\tftrace_dump_on_oops = DUMP_ALL;\n\t\treturn 1;\n\t}\n\n\tif (!strcmp(\"orig_cpu\", str)) {\n\t\tftrace_dump_on_oops = DUMP_ORIG;\n                return 1;\n        }\n\n        return 0;\n}\n__setup(\"ftrace_dump_on_oops\", set_ftrace_dump_on_oops);\n\nstatic int __init stop_trace_on_warning(char *str)\n{\n\tif ((strcmp(str, \"=0\") != 0 && strcmp(str, \"=off\") != 0))\n\t\t__disable_trace_on_warning = 1;\n\treturn 1;\n}\n__setup(\"traceoff_on_warning\", stop_trace_on_warning);\n\nstatic int __init boot_alloc_snapshot(char *str)\n{\n\tallocate_snapshot = true;\n\t/* We also need the main ring buffer expanded */\n\tring_buffer_expanded = true;\n\treturn 1;\n}\n__setup(\"alloc_snapshot\", boot_alloc_snapshot);\n\n\nstatic char trace_boot_options_buf[MAX_TRACER_SIZE] __initdata;\n\nstatic int __init set_trace_boot_options(char *str)\n{\n\tstrlcpy(trace_boot_options_buf, str, MAX_TRACER_SIZE);\n\treturn 0;\n}\n__setup(\"trace_options=\", set_trace_boot_options);\n\nstatic char trace_boot_clock_buf[MAX_TRACER_SIZE] __initdata;\nstatic char *trace_boot_clock __initdata;\n\nstatic int __init set_trace_boot_clock(char *str)\n{\n\tstrlcpy(trace_boot_clock_buf, str, MAX_TRACER_SIZE);\n\ttrace_boot_clock = trace_boot_clock_buf;\n\treturn 0;\n}\n__setup(\"trace_clock=\", set_trace_boot_clock);\n\nstatic int __init set_tracepoint_printk(char *str)\n{\n\tif ((strcmp(str, \"=0\") != 0 && strcmp(str, \"=off\") != 0))\n\t\ttracepoint_printk = 1;\n\treturn 1;\n}\n__setup(\"tp_printk\", set_tracepoint_printk);\n\nunsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}\n\nstatic void\ntrace_process_export(struct trace_export *export,\n\t       struct ring_buffer_event *event, int flag)\n{\n\tstruct trace_entry *entry;\n\tunsigned int size = 0;\n\n\tif (export->flags & flag) {\n\t\tentry = ring_buffer_event_data(event);\n\t\tsize = ring_buffer_event_length(event);\n\t\texport->write(export, entry, size);\n\t}\n}\n\nstatic DEFINE_MUTEX(ftrace_export_lock);\n\nstatic struct trace_export __rcu *ftrace_exports_list __read_mostly;\n\nstatic DEFINE_STATIC_KEY_FALSE(trace_function_exports_enabled);\nstatic DEFINE_STATIC_KEY_FALSE(trace_event_exports_enabled);\nstatic DEFINE_STATIC_KEY_FALSE(trace_marker_exports_enabled);\n\nstatic inline void ftrace_exports_enable(struct trace_export *export)\n{\n\tif (export->flags & TRACE_EXPORT_FUNCTION)\n\t\tstatic_branch_inc(&trace_function_exports_enabled);\n\n\tif (export->flags & TRACE_EXPORT_EVENT)\n\t\tstatic_branch_inc(&trace_event_exports_enabled);\n\n\tif (export->flags & TRACE_EXPORT_MARKER)\n\t\tstatic_branch_inc(&trace_marker_exports_enabled);\n}\n\nstatic inline void ftrace_exports_disable(struct trace_export *export)\n{\n\tif (export->flags & TRACE_EXPORT_FUNCTION)\n\t\tstatic_branch_dec(&trace_function_exports_enabled);\n\n\tif (export->flags & TRACE_EXPORT_EVENT)\n\t\tstatic_branch_dec(&trace_event_exports_enabled);\n\n\tif (export->flags & TRACE_EXPORT_MARKER)\n\t\tstatic_branch_dec(&trace_marker_exports_enabled);\n}\n\nstatic void ftrace_exports(struct ring_buffer_event *event, int flag)\n{\n\tstruct trace_export *export;\n\n\tpreempt_disable_notrace();\n\n\texport = rcu_dereference_raw_check(ftrace_exports_list);\n\twhile (export) {\n\t\ttrace_process_export(export, event, flag);\n\t\texport = rcu_dereference_raw_check(export->next);\n\t}\n\n\tpreempt_enable_notrace();\n}\n\nstatic inline void\nadd_trace_export(struct trace_export **list, struct trace_export *export)\n{\n\trcu_assign_pointer(export->next, *list);\n\t/*\n\t * We are entering export into the list but another\n\t * CPU might be walking that list. We need to make sure\n\t * the export->next pointer is valid before another CPU sees\n\t * the export pointer included into the list.\n\t */\n\trcu_assign_pointer(*list, export);\n}\n\nstatic inline int\nrm_trace_export(struct trace_export **list, struct trace_export *export)\n{\n\tstruct trace_export **p;\n\n\tfor (p = list; *p != NULL; p = &(*p)->next)\n\t\tif (*p == export)\n\t\t\tbreak;\n\n\tif (*p != export)\n\t\treturn -1;\n\n\trcu_assign_pointer(*p, (*p)->next);\n\n\treturn 0;\n}\n\nstatic inline void\nadd_ftrace_export(struct trace_export **list, struct trace_export *export)\n{\n\tftrace_exports_enable(export);\n\n\tadd_trace_export(list, export);\n}\n\nstatic inline int\nrm_ftrace_export(struct trace_export **list, struct trace_export *export)\n{\n\tint ret;\n\n\tret = rm_trace_export(list, export);\n\tftrace_exports_disable(export);\n\n\treturn ret;\n}\n\nint register_ftrace_export(struct trace_export *export)\n{\n\tif (WARN_ON_ONCE(!export->write))\n\t\treturn -1;\n\n\tmutex_lock(&ftrace_export_lock);\n\n\tadd_ftrace_export(&ftrace_exports_list, export);\n\n\tmutex_unlock(&ftrace_export_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(register_ftrace_export);\n\nint unregister_ftrace_export(struct trace_export *export)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_export_lock);\n\n\tret = rm_ftrace_export(&ftrace_exports_list, export);\n\n\tmutex_unlock(&ftrace_export_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(unregister_ftrace_export);\n\n/* trace_flags holds trace_options default values */\n#define TRACE_DEFAULT_FLAGS\t\t\t\t\t\t\\\n\t(FUNCTION_DEFAULT_FLAGS |\t\t\t\t\t\\\n\t TRACE_ITER_PRINT_PARENT | TRACE_ITER_PRINTK |\t\t\t\\\n\t TRACE_ITER_ANNOTATE | TRACE_ITER_CONTEXT_INFO |\t\t\\\n\t TRACE_ITER_RECORD_CMD | TRACE_ITER_OVERWRITE |\t\t\t\\\n\t TRACE_ITER_IRQ_INFO | TRACE_ITER_MARKERS)\n\n/* trace_options that are only supported by global_trace */\n#define TOP_LEVEL_TRACE_FLAGS (TRACE_ITER_PRINTK |\t\t\t\\\n\t       TRACE_ITER_PRINTK_MSGONLY | TRACE_ITER_RECORD_CMD)\n\n/* trace_flags that are default zero for instances */\n#define ZEROED_TRACE_FLAGS \\\n\t(TRACE_ITER_EVENT_FORK | TRACE_ITER_FUNC_FORK)\n\n/*\n * The global_trace is the descriptor that holds the top-level tracing\n * buffers for the live tracing.\n */\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nLIST_HEAD(ftrace_trace_arrays);\n\nint trace_array_get(struct trace_array *this_tr)\n{\n\tstruct trace_array *tr;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr == this_tr) {\n\t\t\ttr->ref++;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\nstatic void __trace_array_put(struct trace_array *this_tr)\n{\n\tWARN_ON(!this_tr->ref);\n\tthis_tr->ref--;\n}\n\n/**\n * trace_array_put - Decrement the reference counter for this trace array.\n *\n * NOTE: Use this when we no longer need the trace array returned by\n * trace_array_get_by_name(). This ensures the trace array can be later\n * destroyed.\n *\n */\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tif (!this_tr)\n\t\treturn;\n\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}\nEXPORT_SYMBOL_GPL(trace_array_put);\n\nint tracing_check_open_get_tr(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (tr && trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct trace_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nvoid trace_free_pid_list(struct trace_pid_list *pid_list)\n{\n\tvfree(pid_list->pids);\n\tkfree(pid_list);\n}\n\n/**\n * trace_find_filtered_pid - check if a pid exists in a filtered_pid list\n * @filtered_pids: The list of pids to check\n * @search_pid: The PID to find in @filtered_pids\n *\n * Returns true if @search_pid is fonud in @filtered_pids, and false otherwis.\n */\nbool\ntrace_find_filtered_pid(struct trace_pid_list *filtered_pids, pid_t search_pid)\n{\n\t/*\n\t * If pid_max changed after filtered_pids was created, we\n\t * by default ignore all pids greater than the previous pid_max.\n\t */\n\tif (search_pid >= filtered_pids->pid_max)\n\t\treturn false;\n\n\treturn test_bit(search_pid, filtered_pids->pids);\n}\n\n/**\n * trace_ignore_this_task - should a task be ignored for tracing\n * @filtered_pids: The list of pids to check\n * @task: The task that should be ignored if not filtered\n *\n * Checks if @task should be traced or not from @filtered_pids.\n * Returns true if @task should *NOT* be traced.\n * Returns false if @task should be traced.\n */\nbool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids,\n\t\t       struct trace_pid_list *filtered_no_pids,\n\t\t       struct task_struct *task)\n{\n\t/*\n\t * If filterd_no_pids is not empty, and the task's pid is listed\n\t * in filtered_no_pids, then return true.\n\t * Otherwise, if filtered_pids is empty, that means we can\n\t * trace all tasks. If it has content, then only trace pids\n\t * within filtered_pids.\n\t */\n\n\treturn (filtered_pids &&\n\t\t!trace_find_filtered_pid(filtered_pids, task->pid)) ||\n\t\t(filtered_no_pids &&\n\t\t trace_find_filtered_pid(filtered_no_pids, task->pid));\n}\n\n/**\n * trace_filter_add_remove_task - Add or remove a task from a pid_list\n * @pid_list: The list to modify\n * @self: The current task for fork or NULL for exit\n * @task: The task to add or remove\n *\n * If adding a task, if @self is defined, the task is only added if @self\n * is also included in @pid_list. This happens on fork and tasks should\n * only be added when the parent is listed. If @self is NULL, then the\n * @task pid will be removed from the list, which would happen on exit\n * of a task.\n */\nvoid trace_filter_add_remove_task(struct trace_pid_list *pid_list,\n\t\t\t\t  struct task_struct *self,\n\t\t\t\t  struct task_struct *task)\n{\n\tif (!pid_list)\n\t\treturn;\n\n\t/* For forks, we only add if the forking task is listed */\n\tif (self) {\n\t\tif (!trace_find_filtered_pid(pid_list, self->pid))\n\t\t\treturn;\n\t}\n\n\t/* Sorry, but we don't support pid_max changing after setting */\n\tif (task->pid >= pid_list->pid_max)\n\t\treturn;\n\n\t/* \"self\" is set for forks, and NULL for exits */\n\tif (self)\n\t\tset_bit(task->pid, pid_list->pids);\n\telse\n\t\tclear_bit(task->pid, pid_list->pids);\n}\n\n/**\n * trace_pid_next - Used for seq_file to get to the next pid of a pid_list\n * @pid_list: The pid list to show\n * @v: The last pid that was shown (+1 the actual pid to let zero be displayed)\n * @pos: The position of the file\n *\n * This is used by the seq_file \"next\" operation to iterate the pids\n * listed in a trace_pid_list structure.\n *\n * Returns the pid+1 as we want to display pid of zero, but NULL would\n * stop the iteration.\n */\nvoid *trace_pid_next(struct trace_pid_list *pid_list, void *v, loff_t *pos)\n{\n\tunsigned long pid = (unsigned long)v;\n\n\t(*pos)++;\n\n\t/* pid already is +1 of the actual prevous bit */\n\tpid = find_next_bit(pid_list->pids, pid_list->pid_max, pid);\n\n\t/* Return pid + 1 to allow zero to be represented */\n\tif (pid < pid_list->pid_max)\n\t\treturn (void *)(pid + 1);\n\n\treturn NULL;\n}\n\n/**\n * trace_pid_start - Used for seq_file to start reading pid lists\n * @pid_list: The pid list to show\n * @pos: The position of the file\n *\n * This is used by seq_file \"start\" operation to start the iteration\n * of listing pids.\n *\n * Returns the pid+1 as we want to display pid of zero, but NULL would\n * stop the iteration.\n */\nvoid *trace_pid_start(struct trace_pid_list *pid_list, loff_t *pos)\n{\n\tunsigned long pid;\n\tloff_t l = 0;\n\n\tpid = find_first_bit(pid_list->pids, pid_list->pid_max);\n\tif (pid >= pid_list->pid_max)\n\t\treturn NULL;\n\n\t/* Return pid + 1 so that zero can be the exit value */\n\tfor (pid++; pid && l < *pos;\n\t     pid = (unsigned long)trace_pid_next(pid_list, (void *)pid, &l))\n\t\t;\n\treturn (void *)pid;\n}\n\n/**\n * trace_pid_show - show the current pid in seq_file processing\n * @m: The seq_file structure to write into\n * @v: A void pointer of the pid (+1) value to display\n *\n * Can be directly used by seq_file operations to display the current\n * pid value.\n */\nint trace_pid_show(struct seq_file *m, void *v)\n{\n\tunsigned long pid = (unsigned long)v - 1;\n\n\tseq_printf(m, \"%lu\\n\", pid);\n\treturn 0;\n}\n\n/* 128 should be much more than enough */\n#define PID_BUF_SIZE\t\t127\n\nint trace_pid_write(struct trace_pid_list *filtered_pids,\n\t\t    struct trace_pid_list **new_pid_list,\n\t\t    const char __user *ubuf, size_t cnt)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_parser parser;\n\tunsigned long val;\n\tint nr_pids = 0;\n\tssize_t read = 0;\n\tssize_t ret = 0;\n\tloff_t pos;\n\tpid_t pid;\n\n\tif (trace_parser_get_init(&parser, PID_BUF_SIZE + 1))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Always recreate a new array. The write is an all or nothing\n\t * operation. Always create a new array when adding new pids by\n\t * the user. If the operation fails, then the current list is\n\t * not modified.\n\t */\n\tpid_list = kmalloc(sizeof(*pid_list), GFP_KERNEL);\n\tif (!pid_list) {\n\t\ttrace_parser_put(&parser);\n\t\treturn -ENOMEM;\n\t}\n\n\tpid_list->pid_max = READ_ONCE(pid_max);\n\n\t/* Only truncating will shrink pid_max */\n\tif (filtered_pids && filtered_pids->pid_max > pid_list->pid_max)\n\t\tpid_list->pid_max = filtered_pids->pid_max;\n\n\tpid_list->pids = vzalloc((pid_list->pid_max + 7) >> 3);\n\tif (!pid_list->pids) {\n\t\ttrace_parser_put(&parser);\n\t\tkfree(pid_list);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (filtered_pids) {\n\t\t/* copy the current bits to the new max */\n\t\tfor_each_set_bit(pid, filtered_pids->pids,\n\t\t\t\t filtered_pids->pid_max) {\n\t\t\tset_bit(pid, pid_list->pids);\n\t\t\tnr_pids++;\n\t\t}\n\t}\n\n\twhile (cnt > 0) {\n\n\t\tpos = 0;\n\n\t\tret = trace_get_user(&parser, ubuf, cnt, &pos);\n\t\tif (ret < 0 || !trace_parser_loaded(&parser))\n\t\t\tbreak;\n\n\t\tread += ret;\n\t\tubuf += ret;\n\t\tcnt -= ret;\n\n\t\tret = -EINVAL;\n\t\tif (kstrtoul(parser.buffer, 0, &val))\n\t\t\tbreak;\n\t\tif (val >= pid_list->pid_max)\n\t\t\tbreak;\n\n\t\tpid = (pid_t)val;\n\n\t\tset_bit(pid, pid_list->pids);\n\t\tnr_pids++;\n\n\t\ttrace_parser_clear(&parser);\n\t\tret = 0;\n\t}\n\ttrace_parser_put(&parser);\n\n\tif (ret < 0) {\n\t\ttrace_free_pid_list(pid_list);\n\t\treturn ret;\n\t}\n\n\tif (!nr_pids) {\n\t\t/* Cleared the list of pids */\n\t\ttrace_free_pid_list(pid_list);\n\t\tread = ret;\n\t\tpid_list = NULL;\n\t}\n\n\t*new_pid_list = pid_list;\n\n\treturn read;\n}\n\nstatic u64 buffer_ftrace_now(struct array_buffer *buf, int cpu)\n{\n\tu64 ts;\n\n\t/* Early boot up does not have a buffer yet */\n\tif (!buf->buffer)\n\t\treturn trace_clock_local();\n\n\tts = ring_buffer_time_stamp(buf->buffer, cpu);\n\tring_buffer_normalize_time_stamp(buf->buffer, cpu, &ts);\n\n\treturn ts;\n}\n\nu64 ftrace_now(int cpu)\n{\n\treturn buffer_ftrace_now(&global_trace.array_buffer, cpu);\n}\n\n/**\n * tracing_is_enabled - Show if global_trace has been disabled\n *\n * Shows if the global trace has been enabled or not. It uses the\n * mirror flag \"buffer_disabled\" to be used in fast paths such as for\n * the irqsoff tracer. But it may be inaccurate due to races. If you\n * need to know the accurate state, use tracing_is_on() which is a little\n * slower, but accurate.\n */\nint tracing_is_enabled(void)\n{\n\t/*\n\t * For quick access (irqsoff uses this in fast path), just\n\t * return the mirror variable of the state of the ring buffer.\n\t * It's a little racy, but we don't really care.\n\t */\n\tsmp_rmb();\n\treturn !global_trace.buffer_disabled;\n}\n\n/*\n * trace_buf_size is the size in bytes that is allocated\n * for a buffer. Note, the number of bytes is always rounded\n * to page size.\n *\n * This number is purposely set to a low number of 16384.\n * If the dump on oops happens, it will be much appreciated\n * to not have to wait for all that output. Anyway this can be\n * boot time and run time configurable.\n */\n#define TRACE_BUF_SIZE_DEFAULT\t1441792UL /* 16384 * 88 (sizeof(entry)) */\n\nstatic unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;\n\n/* trace_types holds a link list of available tracers. */\nstatic struct tracer\t\t*trace_types __read_mostly;\n\n/*\n * trace_types_lock is used to protect the trace_types list.\n */\nDEFINE_MUTEX(trace_types_lock);\n\n/*\n * serialize the access of the ring buffer\n *\n * ring buffer serializes readers, but it is low level protection.\n * The validity of the events (which returns by ring_buffer_peek() ..etc)\n * are not protected by ring buffer.\n *\n * The content of events may become garbage if we allow other process consumes\n * these events concurrently:\n *   A) the page of the consumed events may become a normal page\n *      (not reader page) in ring buffer, and this page will be rewrited\n *      by events producer.\n *   B) The page of the consumed events may become a page for splice_read,\n *      and this page will be returned to system.\n *\n * These primitives allow multi process access to different cpu ring buffer\n * concurrently.\n *\n * These primitives don't distinguish read-only and read-consume access.\n * Multi read-only access are also serialized.\n */\n\n#ifdef CONFIG_SMP\nstatic DECLARE_RWSEM(all_cpu_access_lock);\nstatic DEFINE_PER_CPU(struct mutex, cpu_access_lock);\n\nstatic inline void trace_access_lock(int cpu)\n{\n\tif (cpu == RING_BUFFER_ALL_CPUS) {\n\t\t/* gain it for accessing the whole ring buffer. */\n\t\tdown_write(&all_cpu_access_lock);\n\t} else {\n\t\t/* gain it for accessing a cpu ring buffer. */\n\n\t\t/* Firstly block other trace_access_lock(RING_BUFFER_ALL_CPUS). */\n\t\tdown_read(&all_cpu_access_lock);\n\n\t\t/* Secondly block other access to this @cpu ring buffer. */\n\t\tmutex_lock(&per_cpu(cpu_access_lock, cpu));\n\t}\n}\n\nstatic inline void trace_access_unlock(int cpu)\n{\n\tif (cpu == RING_BUFFER_ALL_CPUS) {\n\t\tup_write(&all_cpu_access_lock);\n\t} else {\n\t\tmutex_unlock(&per_cpu(cpu_access_lock, cpu));\n\t\tup_read(&all_cpu_access_lock);\n\t}\n}\n\nstatic inline void trace_access_lock_init(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tmutex_init(&per_cpu(cpu_access_lock, cpu));\n}\n\n#else\n\nstatic DEFINE_MUTEX(access_lock);\n\nstatic inline void trace_access_lock(int cpu)\n{\n\t(void)cpu;\n\tmutex_lock(&access_lock);\n}\n\nstatic inline void trace_access_unlock(int cpu)\n{\n\t(void)cpu;\n\tmutex_unlock(&access_lock);\n}\n\nstatic inline void trace_access_lock_init(void)\n{\n}\n\n#endif\n\n#ifdef CONFIG_STACKTRACE\nstatic void __ftrace_trace_stack(struct trace_buffer *buffer,\n\t\t\t\t unsigned long flags,\n\t\t\t\t int skip, int pc, struct pt_regs *regs);\nstatic inline void ftrace_trace_stack(struct trace_array *tr,\n\t\t\t\t      struct trace_buffer *buffer,\n\t\t\t\t      unsigned long flags,\n\t\t\t\t      int skip, int pc, struct pt_regs *regs);\n\n#else\nstatic inline void __ftrace_trace_stack(struct trace_buffer *buffer,\n\t\t\t\t\tunsigned long flags,\n\t\t\t\t\tint skip, int pc, struct pt_regs *regs)\n{\n}\nstatic inline void ftrace_trace_stack(struct trace_array *tr,\n\t\t\t\t      struct trace_buffer *buffer,\n\t\t\t\t      unsigned long flags,\n\t\t\t\t      int skip, int pc, struct pt_regs *regs)\n{\n}\n\n#endif\n\nstatic __always_inline void\ntrace_event_setup(struct ring_buffer_event *event,\n\t\t  int type, unsigned long flags, int pc)\n{\n\tstruct trace_entry *ent = ring_buffer_event_data(event);\n\n\ttracing_generic_entry_update(ent, type, flags, pc);\n}\n\nstatic __always_inline struct ring_buffer_event *\n__trace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\tstruct ring_buffer_event *event;\n\n\tevent = ring_buffer_lock_reserve(buffer, len);\n\tif (event != NULL)\n\t\ttrace_event_setup(event, type, flags, pc);\n\n\treturn event;\n}\n\nvoid tracer_tracing_on(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\tring_buffer_record_on(tr->array_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 0;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}\n\n/**\n * tracing_on - enable tracing buffers\n *\n * This function enables tracing buffers that may have been\n * disabled with tracing_off.\n */\nvoid tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}\nEXPORT_SYMBOL_GPL(tracing_on);\n\n\nstatic __always_inline void\n__buffer_unlock_commit(struct trace_buffer *buffer, struct ring_buffer_event *event)\n{\n\t__this_cpu_write(trace_taskinfo_save, true);\n\n\t/* If this is the temp buffer, we need to commit fully */\n\tif (this_cpu_read(trace_buffered_event) == event) {\n\t\t/* Length is in event->array[0] */\n\t\tring_buffer_write(buffer, event->array[0], &event->array[1]);\n\t\t/* Release the temp buffer */\n\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t} else\n\t\tring_buffer_unlock_commit(buffer, event);\n}\n\n/**\n * __trace_puts - write a constant string into the trace buffer.\n * @ip:\t   The address of the caller\n * @str:   The constant string to write\n * @size:  The size of the string.\n */\nint __trace_puts(unsigned long ip, const char *str, int size)\n{\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer;\n\tstruct print_entry *entry;\n\tunsigned long irq_flags;\n\tint alloc;\n\tint pc;\n\n\tif (!(global_trace.trace_flags & TRACE_ITER_PRINTK))\n\t\treturn 0;\n\n\tpc = preempt_count();\n\n\tif (unlikely(tracing_selftest_running || tracing_disabled))\n\t\treturn 0;\n\n\talloc = sizeof(*entry) + size + 2; /* possible \\n added */\n\n\tlocal_save_flags(irq_flags);\n\tbuffer = global_trace.array_buffer.buffer;\n\tring_buffer_nest_start(buffer);\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_PRINT, alloc, \n\t\t\t\t\t    irq_flags, pc);\n\tif (!event) {\n\t\tsize = 0;\n\t\tgoto out;\n\t}\n\n\tentry = ring_buffer_event_data(event);\n\tentry->ip = ip;\n\n\tmemcpy(&entry->buf, str, size);\n\n\t/* Add a newline if necessary */\n\tif (entry->buf[size - 1] != '\\n') {\n\t\tentry->buf[size] = '\\n';\n\t\tentry->buf[size + 1] = '\\0';\n\t} else\n\t\tentry->buf[size] = '\\0';\n\n\t__buffer_unlock_commit(buffer, event);\n\tftrace_trace_stack(&global_trace, buffer, irq_flags, 4, pc, NULL);\n out:\n\tring_buffer_nest_end(buffer);\n\treturn size;\n}\nEXPORT_SYMBOL_GPL(__trace_puts);\n\n/**\n * __trace_bputs - write the pointer to a constant string into trace buffer\n * @ip:\t   The address of the caller\n * @str:   The constant string to write to the buffer to\n */\nint __trace_bputs(unsigned long ip, const char *str)\n{\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer;\n\tstruct bputs_entry *entry;\n\tunsigned long irq_flags;\n\tint size = sizeof(struct bputs_entry);\n\tint ret = 0;\n\tint pc;\n\n\tif (!(global_trace.trace_flags & TRACE_ITER_PRINTK))\n\t\treturn 0;\n\n\tpc = preempt_count();\n\n\tif (unlikely(tracing_selftest_running || tracing_disabled))\n\t\treturn 0;\n\n\tlocal_save_flags(irq_flags);\n\tbuffer = global_trace.array_buffer.buffer;\n\n\tring_buffer_nest_start(buffer);\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_BPUTS, size,\n\t\t\t\t\t    irq_flags, pc);\n\tif (!event)\n\t\tgoto out;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->ip\t\t\t= ip;\n\tentry->str\t\t\t= str;\n\n\t__buffer_unlock_commit(buffer, event);\n\tftrace_trace_stack(&global_trace, buffer, irq_flags, 4, pc, NULL);\n\n\tret = 1;\n out:\n\tring_buffer_nest_end(buffer);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__trace_bputs);\n\n#ifdef CONFIG_TRACER_SNAPSHOT\nstatic void tracing_snapshot_instance_cond(struct trace_array *tr,\n\t\t\t\t\t   void *cond_data)\n{\n\tstruct tracer *tracer = tr->current_trace;\n\tunsigned long flags;\n\n\tif (in_nmi()) {\n\t\tinternal_trace_puts(\"*** SNAPSHOT CALLED FROM NMI CONTEXT ***\\n\");\n\t\tinternal_trace_puts(\"*** snapshot is being ignored        ***\\n\");\n\t\treturn;\n\t}\n\n\tif (!tr->allocated_snapshot) {\n\t\tinternal_trace_puts(\"*** SNAPSHOT NOT ALLOCATED ***\\n\");\n\t\tinternal_trace_puts(\"*** stopping trace here!   ***\\n\");\n\t\ttracing_off();\n\t\treturn;\n\t}\n\n\t/* Note, snapshot can not be used when the tracer uses it */\n\tif (tracer->use_max_tr) {\n\t\tinternal_trace_puts(\"*** LATENCY TRACER ACTIVE ***\\n\");\n\t\tinternal_trace_puts(\"*** Can not use snapshot (sorry) ***\\n\");\n\t\treturn;\n\t}\n\n\tlocal_irq_save(flags);\n\tupdate_max_tr(tr, current, smp_processor_id(), cond_data);\n\tlocal_irq_restore(flags);\n}\n\nvoid tracing_snapshot_instance(struct trace_array *tr)\n{\n\ttracing_snapshot_instance_cond(tr, NULL);\n}\n\n/**\n * tracing_snapshot - take a snapshot of the current buffer.\n *\n * This causes a swap between the snapshot buffer and the current live\n * tracing buffer. You can use this to take snapshots of the live\n * trace when some condition is triggered, but continue to trace.\n *\n * Note, make sure to allocate the snapshot with either\n * a tracing_snapshot_alloc(), or by doing it manually\n * with: echo 1 > /sys/kernel/debug/tracing/snapshot\n *\n * If the snapshot buffer is not allocated, it will stop tracing.\n * Basically making a permanent snapshot.\n */\nvoid tracing_snapshot(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\ttracing_snapshot_instance(tr);\n}\nEXPORT_SYMBOL_GPL(tracing_snapshot);\n\n/**\n * tracing_snapshot_cond - conditionally take a snapshot of the current buffer.\n * @tr:\t\tThe tracing instance to snapshot\n * @cond_data:\tThe data to be tested conditionally, and possibly saved\n *\n * This is the same as tracing_snapshot() except that the snapshot is\n * conditional - the snapshot will only happen if the\n * cond_snapshot.update() implementation receiving the cond_data\n * returns true, which means that the trace array's cond_snapshot\n * update() operation used the cond_data to determine whether the\n * snapshot should be taken, and if it was, presumably saved it along\n * with the snapshot.\n */\nvoid tracing_snapshot_cond(struct trace_array *tr, void *cond_data)\n{\n\ttracing_snapshot_instance_cond(tr, cond_data);\n}\nEXPORT_SYMBOL_GPL(tracing_snapshot_cond);\n\n/**\n * tracing_snapshot_cond_data - get the user data associated with a snapshot\n * @tr:\t\tThe tracing instance\n *\n * When the user enables a conditional snapshot using\n * tracing_snapshot_cond_enable(), the user-defined cond_data is saved\n * with the snapshot.  This accessor is used to retrieve it.\n *\n * Should not be called from cond_snapshot.update(), since it takes\n * the tr->max_lock lock, which the code calling\n * cond_snapshot.update() has already done.\n *\n * Returns the cond_data associated with the trace array's snapshot.\n */\nvoid *tracing_cond_snapshot_data(struct trace_array *tr)\n{\n\tvoid *cond_data = NULL;\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tif (tr->cond_snapshot)\n\t\tcond_data = tr->cond_snapshot->cond_data;\n\n\tarch_spin_unlock(&tr->max_lock);\n\n\treturn cond_data;\n}\nEXPORT_SYMBOL_GPL(tracing_cond_snapshot_data);\n\nstatic int resize_buffer_duplicate_size(struct array_buffer *trace_buf,\n\t\t\t\t\tstruct array_buffer *size_buf, int cpu_id);\nstatic void set_buffer_entries(struct array_buffer *buf, unsigned long val);\n\nint tracing_alloc_snapshot_instance(struct trace_array *tr)\n{\n\tint ret;\n\n\tif (!tr->allocated_snapshot) {\n\n\t\t/* allocate spare buffer */\n\t\tret = resize_buffer_duplicate_size(&tr->max_buffer,\n\t\t\t\t   &tr->array_buffer, RING_BUFFER_ALL_CPUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttr->allocated_snapshot = true;\n\t}\n\n\treturn 0;\n}\n\nstatic void free_snapshot(struct trace_array *tr)\n{\n\t/*\n\t * We don't free the ring buffer. instead, resize it because\n\t * The max_tr ring buffer has some state (e.g. ring->clock) and\n\t * we want preserve it.\n\t */\n\tring_buffer_resize(tr->max_buffer.buffer, 1, RING_BUFFER_ALL_CPUS);\n\tset_buffer_entries(&tr->max_buffer, 1);\n\ttracing_reset_online_cpus(&tr->max_buffer);\n\ttr->allocated_snapshot = false;\n}\n\n/**\n * tracing_alloc_snapshot - allocate snapshot buffer.\n *\n * This only allocates the snapshot buffer if it isn't already\n * allocated - it doesn't also take a snapshot.\n *\n * This is meant to be used in cases where the snapshot buffer needs\n * to be set up for events that can't sleep but need to be able to\n * trigger a snapshot.\n */\nint tracing_alloc_snapshot(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\tint ret;\n\n\tret = tracing_alloc_snapshot_instance(tr);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tracing_alloc_snapshot);\n\n/**\n * tracing_snapshot_alloc - allocate and take a snapshot of the current buffer.\n *\n * This is similar to tracing_snapshot(), but it will allocate the\n * snapshot buffer if it isn't already allocated. Use this only\n * where it is safe to sleep, as the allocation may sleep.\n *\n * This causes a swap between the snapshot buffer and the current live\n * tracing buffer. You can use this to take snapshots of the live\n * trace when some condition is triggered, but continue to trace.\n */\nvoid tracing_snapshot_alloc(void)\n{\n\tint ret;\n\n\tret = tracing_alloc_snapshot();\n\tif (ret < 0)\n\t\treturn;\n\n\ttracing_snapshot();\n}\nEXPORT_SYMBOL_GPL(tracing_snapshot_alloc);\n\n/**\n * tracing_snapshot_cond_enable - enable conditional snapshot for an instance\n * @tr:\t\tThe tracing instance\n * @cond_data:\tUser data to associate with the snapshot\n * @update:\tImplementation of the cond_snapshot update function\n *\n * Check whether the conditional snapshot for the given instance has\n * already been enabled, or if the current tracer is already using a\n * snapshot; if so, return -EBUSY, else create a cond_snapshot and\n * save the cond_data and update function inside.\n *\n * Returns 0 if successful, error otherwise.\n */\nint tracing_snapshot_cond_enable(struct trace_array *tr, void *cond_data,\n\t\t\t\t cond_update_fn_t update)\n{\n\tstruct cond_snapshot *cond_snapshot;\n\tint ret = 0;\n\n\tcond_snapshot = kzalloc(sizeof(*cond_snapshot), GFP_KERNEL);\n\tif (!cond_snapshot)\n\t\treturn -ENOMEM;\n\n\tcond_snapshot->cond_data = cond_data;\n\tcond_snapshot->update = update;\n\n\tmutex_lock(&trace_types_lock);\n\n\tret = tracing_alloc_snapshot_instance(tr);\n\tif (ret)\n\t\tgoto fail_unlock;\n\n\tif (tr->current_trace->use_max_tr) {\n\t\tret = -EBUSY;\n\t\tgoto fail_unlock;\n\t}\n\n\t/*\n\t * The cond_snapshot can only change to NULL without the\n\t * trace_types_lock. We don't care if we race with it going\n\t * to NULL, but we want to make sure that it's not set to\n\t * something other than NULL when we get here, which we can\n\t * do safely with only holding the trace_types_lock and not\n\t * having to take the max_lock.\n\t */\n\tif (tr->cond_snapshot) {\n\t\tret = -EBUSY;\n\t\tgoto fail_unlock;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\ttr->cond_snapshot = cond_snapshot;\n\tarch_spin_unlock(&tr->max_lock);\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n\n fail_unlock:\n\tmutex_unlock(&trace_types_lock);\n\tkfree(cond_snapshot);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tracing_snapshot_cond_enable);\n\n/**\n * tracing_snapshot_cond_disable - disable conditional snapshot for an instance\n * @tr:\t\tThe tracing instance\n *\n * Check whether the conditional snapshot for the given instance is\n * enabled; if so, free the cond_snapshot associated with it,\n * otherwise return -EINVAL.\n *\n * Returns 0 if successful, error otherwise.\n */\nint tracing_snapshot_cond_disable(struct trace_array *tr)\n{\n\tint ret = 0;\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tif (!tr->cond_snapshot)\n\t\tret = -EINVAL;\n\telse {\n\t\tkfree(tr->cond_snapshot);\n\t\ttr->cond_snapshot = NULL;\n\t}\n\n\tarch_spin_unlock(&tr->max_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tracing_snapshot_cond_disable);\n#else\nvoid tracing_snapshot(void)\n{\n\tWARN_ONCE(1, \"Snapshot feature not enabled, but internal snapshot used\");\n}\nEXPORT_SYMBOL_GPL(tracing_snapshot);\nvoid tracing_snapshot_cond(struct trace_array *tr, void *cond_data)\n{\n\tWARN_ONCE(1, \"Snapshot feature not enabled, but internal conditional snapshot used\");\n}\nEXPORT_SYMBOL_GPL(tracing_snapshot_cond);\nint tracing_alloc_snapshot(void)\n{\n\tWARN_ONCE(1, \"Snapshot feature not enabled, but snapshot allocation used\");\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(tracing_alloc_snapshot);\nvoid tracing_snapshot_alloc(void)\n{\n\t/* Give warning */\n\ttracing_snapshot();\n}\nEXPORT_SYMBOL_GPL(tracing_snapshot_alloc);\nvoid *tracing_cond_snapshot_data(struct trace_array *tr)\n{\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(tracing_cond_snapshot_data);\nint tracing_snapshot_cond_enable(struct trace_array *tr, void *cond_data, cond_update_fn_t update)\n{\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(tracing_snapshot_cond_enable);\nint tracing_snapshot_cond_disable(struct trace_array *tr)\n{\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(tracing_snapshot_cond_disable);\n#endif /* CONFIG_TRACER_SNAPSHOT */\n\nvoid tracer_tracing_off(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\tring_buffer_record_off(tr->array_buffer.buffer);\n\t/*\n\t * This flag is looked at when buffers haven't been allocated\n\t * yet, or by some tracers (like irqsoff), that just want to\n\t * know if the ring buffer has been disabled, but it can handle\n\t * races of where it gets disabled but we still do a record.\n\t * As the check is in the fast path of the tracers, it is more\n\t * important to be fast than accurate.\n\t */\n\ttr->buffer_disabled = 1;\n\t/* Make the flag seen by readers */\n\tsmp_wmb();\n}\n\n/**\n * tracing_off - turn off tracing buffers\n *\n * This function stops the tracing buffers from recording data.\n * It does not disable any overhead the tracers themselves may\n * be causing. This function simply causes all recording to\n * the ring buffers to fail.\n */\nvoid tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}\nEXPORT_SYMBOL_GPL(tracing_off);\n\nvoid disable_trace_on_warning(void)\n{\n\tif (__disable_trace_on_warning) {\n\t\ttrace_array_printk_buf(global_trace.array_buffer.buffer, _THIS_IP_,\n\t\t\t\"Disabling tracing due to warning\\n\");\n\t\ttracing_off();\n\t}\n}\n\n/**\n * tracer_tracing_is_on - show real state of ring buffer enabled\n * @tr : the trace array to know if ring buffer is enabled\n *\n * Shows real state of the ring buffer if it is enabled or not.\n */\nbool tracer_tracing_is_on(struct trace_array *tr)\n{\n\tif (tr->array_buffer.buffer)\n\t\treturn ring_buffer_record_is_on(tr->array_buffer.buffer);\n\treturn !tr->buffer_disabled;\n}\n\n/**\n * tracing_is_on - show state of ring buffers enabled\n */\nint tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}\nEXPORT_SYMBOL_GPL(tracing_is_on);\n\nstatic int __init set_buf_size(char *str)\n{\n\tunsigned long buf_size;\n\n\tif (!str)\n\t\treturn 0;\n\tbuf_size = memparse(str, &str);\n\t/* nr_entries can not be zero */\n\tif (buf_size == 0)\n\t\treturn 0;\n\ttrace_buf_size = buf_size;\n\treturn 1;\n}\n__setup(\"trace_buf_size=\", set_buf_size);\n\nstatic int __init set_tracing_thresh(char *str)\n{\n\tunsigned long threshold;\n\tint ret;\n\n\tif (!str)\n\t\treturn 0;\n\tret = kstrtoul(str, 0, &threshold);\n\tif (ret < 0)\n\t\treturn 0;\n\ttracing_thresh = threshold * 1000;\n\treturn 1;\n}\n__setup(\"tracing_thresh=\", set_tracing_thresh);\n\nunsigned long nsecs_to_usecs(unsigned long nsecs)\n{\n\treturn nsecs / 1000;\n}\n\n/*\n * TRACE_FLAGS is defined as a tuple matching bit masks with strings.\n * It uses C(a, b) where 'a' is the eval (enum) name and 'b' is the string that\n * matches it. By defining \"C(a, b) b\", TRACE_FLAGS becomes a list\n * of strings in the order that the evals (enum) were defined.\n */\n#undef C\n#define C(a, b) b\n\n/* These must match the bit postions in trace_iterator_flags */\nstatic const char *trace_options[] = {\n\tTRACE_FLAGS\n\tNULL\n};\n\nstatic struct {\n\tu64 (*func)(void);\n\tconst char *name;\n\tint in_ns;\t\t/* is this clock in nanoseconds? */\n} trace_clocks[] = {\n\t{ trace_clock_local,\t\t\"local\",\t1 },\n\t{ trace_clock_global,\t\t\"global\",\t1 },\n\t{ trace_clock_counter,\t\t\"counter\",\t0 },\n\t{ trace_clock_jiffies,\t\t\"uptime\",\t0 },\n\t{ trace_clock,\t\t\t\"perf\",\t\t1 },\n\t{ ktime_get_mono_fast_ns,\t\"mono\",\t\t1 },\n\t{ ktime_get_raw_fast_ns,\t\"mono_raw\",\t1 },\n\t{ ktime_get_boot_fast_ns,\t\"boot\",\t\t1 },\n\tARCH_TRACE_CLOCKS\n};\n\nbool trace_clock_in_ns(struct trace_array *tr)\n{\n\tif (trace_clocks[tr->clock_id].in_ns)\n\t\treturn true;\n\n\treturn false;\n}\n\n/*\n * trace_parser_get_init - gets the buffer for trace parser\n */\nint trace_parser_get_init(struct trace_parser *parser, int size)\n{\n\tmemset(parser, 0, sizeof(*parser));\n\n\tparser->buffer = kmalloc(size, GFP_KERNEL);\n\tif (!parser->buffer)\n\t\treturn 1;\n\n\tparser->size = size;\n\treturn 0;\n}\n\n/*\n * trace_parser_put - frees the buffer for trace parser\n */\nvoid trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}\n\n/*\n * trace_get_user - reads the user input string separated by  space\n * (matched by isspace(ch))\n *\n * For each string found the 'struct trace_parser' is updated,\n * and the function returns.\n *\n * Returns number of bytes read.\n *\n * See kernel/trace/trace.h for 'struct trace_parser' details.\n */\nint trace_get_user(struct trace_parser *parser, const char __user *ubuf,\n\tsize_t cnt, loff_t *ppos)\n{\n\tchar ch;\n\tsize_t read = 0;\n\tssize_t ret;\n\n\tif (!*ppos)\n\t\ttrace_parser_clear(parser);\n\n\tret = get_user(ch, ubuf++);\n\tif (ret)\n\t\tgoto out;\n\n\tread++;\n\tcnt--;\n\n\t/*\n\t * The parser is not finished with the last write,\n\t * continue reading the user input without skipping spaces.\n\t */\n\tif (!parser->cont) {\n\t\t/* skip white space */\n\t\twhile (cnt && isspace(ch)) {\n\t\t\tret = get_user(ch, ubuf++);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tread++;\n\t\t\tcnt--;\n\t\t}\n\n\t\tparser->idx = 0;\n\n\t\t/* only spaces were written */\n\t\tif (isspace(ch) || !ch) {\n\t\t\t*ppos += read;\n\t\t\tret = read;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* read the non-space input */\n\twhile (cnt && !isspace(ch) && ch) {\n\t\tif (parser->idx < parser->size - 1)\n\t\t\tparser->buffer[parser->idx++] = ch;\n\t\telse {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_user(ch, ubuf++);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tread++;\n\t\tcnt--;\n\t}\n\n\t/* We either got finished input or we have to wait for another call. */\n\tif (isspace(ch) || !ch) {\n\t\tparser->buffer[parser->idx] = 0;\n\t\tparser->cont = false;\n\t} else if (parser->idx < parser->size - 1) {\n\t\tparser->cont = true;\n\t\tparser->buffer[parser->idx++] = ch;\n\t\t/* Make sure the parsed string always terminates with '\\0'. */\n\t\tparser->buffer[parser->idx] = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ppos += read;\n\tret = read;\n\nout:\n\treturn ret;\n}\n\n/* TODO add a seq_buf_to_buffer() */\nstatic ssize_t trace_seq_to_buffer(struct trace_seq *s, void *buf, size_t cnt)\n{\n\tint len;\n\n\tif (trace_seq_used(s) <= s->seq.readpos)\n\t\treturn -EBUSY;\n\n\tlen = trace_seq_used(s) - s->seq.readpos;\n\tif (cnt > len)\n\t\tcnt = len;\n\tmemcpy(buf, s->buffer + s->seq.readpos, cnt);\n\n\ts->seq.readpos += cnt;\n\treturn cnt;\n}\n\nunsigned long __read_mostly\ttracing_thresh;\nstatic const struct file_operations tracing_max_lat_fops;\n\n#if (defined(CONFIG_TRACER_MAX_TRACE) || defined(CONFIG_HWLAT_TRACER)) && \\\n\tdefined(CONFIG_FSNOTIFY)\n\nstatic struct workqueue_struct *fsnotify_wq;\n\nstatic void latency_fsnotify_workfn(struct work_struct *work)\n{\n\tstruct trace_array *tr = container_of(work, struct trace_array,\n\t\t\t\t\t      fsnotify_work);\n\tfsnotify_inode(tr->d_max_latency->d_inode, FS_MODIFY);\n}\n\nstatic void latency_fsnotify_workfn_irq(struct irq_work *iwork)\n{\n\tstruct trace_array *tr = container_of(iwork, struct trace_array,\n\t\t\t\t\t      fsnotify_irqwork);\n\tqueue_work(fsnotify_wq, &tr->fsnotify_work);\n}\n\nstatic void trace_create_maxlat_file(struct trace_array *tr,\n\t\t\t\t     struct dentry *d_tracer)\n{\n\tINIT_WORK(&tr->fsnotify_work, latency_fsnotify_workfn);\n\tinit_irq_work(&tr->fsnotify_irqwork, latency_fsnotify_workfn_irq);\n\ttr->d_max_latency = trace_create_file(\"tracing_max_latency\", 0644,\n\t\t\t\t\t      d_tracer, &tr->max_latency,\n\t\t\t\t\t      &tracing_max_lat_fops);\n}\n\n__init static int latency_fsnotify_init(void)\n{\n\tfsnotify_wq = alloc_workqueue(\"tr_max_lat_wq\",\n\t\t\t\t      WQ_UNBOUND | WQ_HIGHPRI, 0);\n\tif (!fsnotify_wq) {\n\t\tpr_err(\"Unable to allocate tr_max_lat_wq\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nlate_initcall_sync(latency_fsnotify_init);\n\nvoid latency_fsnotify(struct trace_array *tr)\n{\n\tif (!fsnotify_wq)\n\t\treturn;\n\t/*\n\t * We cannot call queue_work(&tr->fsnotify_work) from here because it's\n\t * possible that we are called from __schedule() or do_idle(), which\n\t * could cause a deadlock.\n\t */\n\tirq_work_queue(&tr->fsnotify_irqwork);\n}\n\n/*\n * (defined(CONFIG_TRACER_MAX_TRACE) || defined(CONFIG_HWLAT_TRACER)) && \\\n *  defined(CONFIG_FSNOTIFY)\n */\n#else\n\n#define trace_create_maxlat_file(tr, d_tracer)\t\t\t\t\\\n\ttrace_create_file(\"tracing_max_latency\", 0644, d_tracer,\t\\\n\t\t\t  &tr->max_latency, &tracing_max_lat_fops)\n\n#endif\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n/*\n * Copy the new maximum trace into the separate maximum-trace\n * structure. (this way the maximum trace is permanently saved,\n * for later retrieval via /sys/kernel/tracing/tracing_max_latency)\n */\nstatic void\n__update_max_tr(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tstruct array_buffer *trace_buf = &tr->array_buffer;\n\tstruct array_buffer *max_buf = &tr->max_buffer;\n\tstruct trace_array_cpu *data = per_cpu_ptr(trace_buf->data, cpu);\n\tstruct trace_array_cpu *max_data = per_cpu_ptr(max_buf->data, cpu);\n\n\tmax_buf->cpu = cpu;\n\tmax_buf->time_start = data->preempt_timestamp;\n\n\tmax_data->saved_latency = tr->max_latency;\n\tmax_data->critical_start = data->critical_start;\n\tmax_data->critical_end = data->critical_end;\n\n\tstrncpy(max_data->comm, tsk->comm, TASK_COMM_LEN);\n\tmax_data->pid = tsk->pid;\n\t/*\n\t * If tsk == current, then use current_uid(), as that does not use\n\t * RCU. The irq tracer can be called out of RCU scope.\n\t */\n\tif (tsk == current)\n\t\tmax_data->uid = current_uid();\n\telse\n\t\tmax_data->uid = task_uid(tsk);\n\n\tmax_data->nice = tsk->static_prio - 20 - MAX_RT_PRIO;\n\tmax_data->policy = tsk->policy;\n\tmax_data->rt_priority = tsk->rt_priority;\n\n\t/* record this tasks comm */\n\ttracing_record_cmdline(tsk);\n\tlatency_fsnotify(tr);\n}\n\n/**\n * update_max_tr - snapshot all trace buffers from global_trace to max_tr\n * @tr: tracer\n * @tsk: the task with the latency\n * @cpu: The cpu that initiated the trace.\n * @cond_data: User data associated with a conditional snapshot\n *\n * Flip the buffers between the @tr and the max_tr and record information\n * about which task was the cause of this latency.\n */\nvoid\nupdate_max_tr(struct trace_array *tr, struct task_struct *tsk, int cpu,\n\t      void *cond_data)\n{\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\t/* Inherit the recordable setting from array_buffer */\n\tif (ring_buffer_record_is_set_on(tr->array_buffer.buffer))\n\t\tring_buffer_record_on(tr->max_buffer.buffer);\n\telse\n\t\tring_buffer_record_off(tr->max_buffer.buffer);\n\n#ifdef CONFIG_TRACER_SNAPSHOT\n\tif (tr->cond_snapshot && !tr->cond_snapshot->update(tr, cond_data))\n\t\tgoto out_unlock;\n#endif\n\tswap(tr->array_buffer.buffer, tr->max_buffer.buffer);\n\n\t__update_max_tr(tr, tsk, cpu);\n\n out_unlock:\n\tarch_spin_unlock(&tr->max_lock);\n}\n\n/**\n * update_max_tr_single - only copy one trace over, and reset the rest\n * @tr: tracer\n * @tsk: task with the latency\n * @cpu: the cpu of the buffer to copy.\n *\n * Flip the trace of a single CPU buffer between the @tr and the max_tr.\n */\nvoid\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->array_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}\n#endif /* CONFIG_TRACER_MAX_TRACE */\n\nstatic int wait_on_pipe(struct trace_iterator *iter, int full)\n{\n\t/* Iterators are static, they should be filled or empty */\n\tif (trace_buffer_iter(iter, iter->cpu_file))\n\t\treturn 0;\n\n\treturn ring_buffer_wait(iter->array_buffer->buffer, iter->cpu_file,\n\t\t\t\tfull);\n}\n\n#ifdef CONFIG_FTRACE_STARTUP_TEST\nstatic bool selftests_can_run;\n\nstruct trace_selftests {\n\tstruct list_head\t\tlist;\n\tstruct tracer\t\t\t*type;\n};\n\nstatic LIST_HEAD(postponed_selftests);\n\nstatic int save_selftest(struct tracer *type)\n{\n\tstruct trace_selftests *selftest;\n\n\tselftest = kmalloc(sizeof(*selftest), GFP_KERNEL);\n\tif (!selftest)\n\t\treturn -ENOMEM;\n\n\tselftest->type = type;\n\tlist_add(&selftest->list, &postponed_selftests);\n\treturn 0;\n}\n\nstatic int run_tracer_selftest(struct tracer *type)\n{\n\tstruct trace_array *tr = &global_trace;\n\tstruct tracer *saved_tracer = tr->current_trace;\n\tint ret;\n\n\tif (!type->selftest || tracing_selftest_disabled)\n\t\treturn 0;\n\n\t/*\n\t * If a tracer registers early in boot up (before scheduling is\n\t * initialized and such), then do not run its selftests yet.\n\t * Instead, run it a little later in the boot process.\n\t */\n\tif (!selftests_can_run)\n\t\treturn save_selftest(type);\n\n\t/*\n\t * Run a selftest on this tracer.\n\t * Here we reset the trace buffer, and set the current\n\t * tracer to be this tracer. The tracer can then run some\n\t * internal tracing to verify that everything is in order.\n\t * If we fail, we do not register this tracer.\n\t */\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\n\ttr->current_trace = type;\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (type->use_max_tr) {\n\t\t/* If we expanded the buffers, make sure the max is expanded too */\n\t\tif (ring_buffer_expanded)\n\t\t\tring_buffer_resize(tr->max_buffer.buffer, trace_buf_size,\n\t\t\t\t\t   RING_BUFFER_ALL_CPUS);\n\t\ttr->allocated_snapshot = true;\n\t}\n#endif\n\n\t/* the test is responsible for initializing and enabling */\n\tpr_info(\"Testing tracer %s: \", type->name);\n\tret = type->selftest(type, tr);\n\t/* the test is responsible for resetting too */\n\ttr->current_trace = saved_tracer;\n\tif (ret) {\n\t\tprintk(KERN_CONT \"FAILED!\\n\");\n\t\t/* Add the warning after printing 'FAILED' */\n\t\tWARN_ON(1);\n\t\treturn -1;\n\t}\n\t/* Only reset on passing, to avoid touching corrupted buffers */\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (type->use_max_tr) {\n\t\ttr->allocated_snapshot = false;\n\n\t\t/* Shrink the max buffer again */\n\t\tif (ring_buffer_expanded)\n\t\t\tring_buffer_resize(tr->max_buffer.buffer, 1,\n\t\t\t\t\t   RING_BUFFER_ALL_CPUS);\n\t}\n#endif\n\n\tprintk(KERN_CONT \"PASSED\\n\");\n\treturn 0;\n}\n\nstatic __init int init_trace_selftests(void)\n{\n\tstruct trace_selftests *p, *n;\n\tstruct tracer *t, **last;\n\tint ret;\n\n\tselftests_can_run = true;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (list_empty(&postponed_selftests))\n\t\tgoto out;\n\n\tpr_info(\"Running postponed tracer tests:\\n\");\n\n\ttracing_selftest_running = true;\n\tlist_for_each_entry_safe(p, n, &postponed_selftests, list) {\n\t\t/* This loop can take minutes when sanitizers are enabled, so\n\t\t * lets make sure we allow RCU processing.\n\t\t */\n\t\tcond_resched();\n\t\tret = run_tracer_selftest(p->type);\n\t\t/* If the test fails, then warn and remove from available_tracers */\n\t\tif (ret < 0) {\n\t\t\tWARN(1, \"tracer: %s failed selftest, disabling\\n\",\n\t\t\t     p->type->name);\n\t\t\tlast = &trace_types;\n\t\t\tfor (t = trace_types; t; t = t->next) {\n\t\t\t\tif (t == p->type) {\n\t\t\t\t\t*last = t->next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlast = &t->next;\n\t\t\t}\n\t\t}\n\t\tlist_del(&p->list);\n\t\tkfree(p);\n\t}\n\ttracing_selftest_running = false;\n\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n}\ncore_initcall(init_trace_selftests);\n#else\nstatic inline int run_tracer_selftest(struct tracer *type)\n{\n\treturn 0;\n}\n#endif /* CONFIG_FTRACE_STARTUP_TEST */\n\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nstatic void __init apply_trace_boot_options(void);\n\n/**\n * register_tracer - register a tracer with the ftrace system.\n * @type: the plugin for the tracer\n *\n * Register a new plugin tracer.\n */\nint __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Can not register tracer %s due to lockdown\\n\",\n\t\t\t   type->name);\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\ttracing_selftest_disabled = true;\n#ifdef CONFIG_FTRACE_STARTUP_TEST\n\tprintk(KERN_INFO \"Disabling FTRACE selftests due to running tracer '%s'\\n\",\n\t       type->name);\n#endif\n\n out_unlock:\n\treturn ret;\n}\n\nstatic void tracing_reset_cpu(struct array_buffer *buf, int cpu)\n{\n\tstruct trace_buffer *buffer = buf->buffer;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_rcu();\n\tring_buffer_reset_cpu(buffer, cpu);\n\n\tring_buffer_record_enable(buffer);\n}\n\nvoid tracing_reset_online_cpus(struct array_buffer *buf)\n{\n\tstruct trace_buffer *buffer = buf->buffer;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_rcu();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tring_buffer_reset_online_cpus(buffer);\n\n\tring_buffer_record_enable(buffer);\n}\n\n/* Must have trace_types_lock held */\nvoid tracing_reset_all_online_cpus(void)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->clear_trace)\n\t\t\tcontinue;\n\t\ttr->clear_trace = false;\n\t\ttracing_reset_online_cpus(&tr->array_buffer);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\ttracing_reset_online_cpus(&tr->max_buffer);\n#endif\n\t}\n}\n\nstatic int *tgid_map;\n\n#define SAVED_CMDLINES_DEFAULT 128\n#define NO_CMDLINE_MAP UINT_MAX\nstatic arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;\nstruct saved_cmdlines_buffer {\n\tunsigned map_pid_to_cmdline[PID_MAX_DEFAULT+1];\n\tunsigned *map_cmdline_to_pid;\n\tunsigned cmdline_num;\n\tint cmdline_idx;\n\tchar *saved_cmdlines;\n};\nstatic struct saved_cmdlines_buffer *savedcmd;\n\n/* temporary disable recording */\nstatic atomic_t trace_record_taskinfo_disabled __read_mostly;\n\nstatic inline char *get_saved_cmdlines(int idx)\n{\n\treturn &savedcmd->saved_cmdlines[idx * TASK_COMM_LEN];\n}\n\nstatic inline void set_cmdline(int idx, const char *cmdline)\n{\n\tstrncpy(get_saved_cmdlines(idx), cmdline, TASK_COMM_LEN);\n}\n\nstatic int allocate_cmdlines_buffer(unsigned int val,\n\t\t\t\t    struct saved_cmdlines_buffer *s)\n{\n\ts->map_cmdline_to_pid = kmalloc_array(val,\n\t\t\t\t\t      sizeof(*s->map_cmdline_to_pid),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!s->map_cmdline_to_pid)\n\t\treturn -ENOMEM;\n\n\ts->saved_cmdlines = kmalloc_array(TASK_COMM_LEN, val, GFP_KERNEL);\n\tif (!s->saved_cmdlines) {\n\t\tkfree(s->map_cmdline_to_pid);\n\t\treturn -ENOMEM;\n\t}\n\n\ts->cmdline_idx = 0;\n\ts->cmdline_num = val;\n\tmemset(&s->map_pid_to_cmdline, NO_CMDLINE_MAP,\n\t       sizeof(s->map_pid_to_cmdline));\n\tmemset(s->map_cmdline_to_pid, NO_CMDLINE_MAP,\n\t       val * sizeof(*s->map_cmdline_to_pid));\n\n\treturn 0;\n}\n\nstatic int trace_create_savedcmd(void)\n{\n\tint ret;\n\n\tsavedcmd = kmalloc(sizeof(*savedcmd), GFP_KERNEL);\n\tif (!savedcmd)\n\t\treturn -ENOMEM;\n\n\tret = allocate_cmdlines_buffer(SAVED_CMDLINES_DEFAULT, savedcmd);\n\tif (ret < 0) {\n\t\tkfree(savedcmd);\n\t\tsavedcmd = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nint is_tracing_stopped(void)\n{\n\treturn global_trace.stop_count;\n}\n\n/**\n * tracing_start - quick start of the tracer\n *\n * If tracing is enabled but was stopped by tracing_stop,\n * this will start the tracer back up.\n */\nvoid tracing_start(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}\n\nstatic void tracing_start_tr(struct trace_array *tr)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\t/* If global, we need to also start the max tracer */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL)\n\t\treturn tracing_start();\n\n\traw_spin_lock_irqsave(&tr->start_lock, flags);\n\n\tif (--tr->stop_count) {\n\t\tif (tr->stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\ttr->stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tbuffer = tr->array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n out:\n\traw_spin_unlock_irqrestore(&tr->start_lock, flags);\n}\n\n/**\n * tracing_stop - quick stop of the tracer\n *\n * Light weight way to stop tracing. Use in conjunction with\n * tracing_start.\n */\nvoid tracing_stop(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}\n\nstatic void tracing_stop_tr(struct trace_array *tr)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\t/* If global, we need to also stop the max tracer */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL)\n\t\treturn tracing_stop();\n\n\traw_spin_lock_irqsave(&tr->start_lock, flags);\n\tif (tr->stop_count++)\n\t\tgoto out;\n\n\tbuffer = tr->array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n out:\n\traw_spin_unlock_irqrestore(&tr->start_lock, flags);\n}\n\nstatic int trace_save_cmdline(struct task_struct *tsk)\n{\n\tunsigned pid, idx;\n\n\t/* treat recording of idle task as a success */\n\tif (!tsk->pid)\n\t\treturn 1;\n\n\tif (unlikely(tsk->pid > PID_MAX_DEFAULT))\n\t\treturn 0;\n\n\t/*\n\t * It's not the end of the world if we don't get\n\t * the lock, but we also don't want to spin\n\t * nor do we want to disable interrupts,\n\t * so if we miss here, then better luck next time.\n\t */\n\tif (!arch_spin_trylock(&trace_cmdline_lock))\n\t\treturn 0;\n\n\tidx = savedcmd->map_pid_to_cmdline[tsk->pid];\n\tif (idx == NO_CMDLINE_MAP) {\n\t\tidx = (savedcmd->cmdline_idx + 1) % savedcmd->cmdline_num;\n\n\t\t/*\n\t\t * Check whether the cmdline buffer at idx has a pid\n\t\t * mapped. We are going to overwrite that entry so we\n\t\t * need to clear the map_pid_to_cmdline. Otherwise we\n\t\t * would read the new comm for the old pid.\n\t\t */\n\t\tpid = savedcmd->map_cmdline_to_pid[idx];\n\t\tif (pid != NO_CMDLINE_MAP)\n\t\t\tsavedcmd->map_pid_to_cmdline[pid] = NO_CMDLINE_MAP;\n\n\t\tsavedcmd->map_cmdline_to_pid[idx] = tsk->pid;\n\t\tsavedcmd->map_pid_to_cmdline[tsk->pid] = idx;\n\n\t\tsavedcmd->cmdline_idx = idx;\n\t}\n\n\tset_cmdline(idx, tsk->comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\n\treturn 1;\n}\n\nstatic void __trace_find_cmdline(int pid, char comm[])\n{\n\tunsigned map;\n\n\tif (!pid) {\n\t\tstrcpy(comm, \"<idle>\");\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(pid < 0)) {\n\t\tstrcpy(comm, \"<XXX>\");\n\t\treturn;\n\t}\n\n\tif (pid > PID_MAX_DEFAULT) {\n\t\tstrcpy(comm, \"<...>\");\n\t\treturn;\n\t}\n\n\tmap = savedcmd->map_pid_to_cmdline[pid];\n\tif (map != NO_CMDLINE_MAP)\n\t\tstrlcpy(comm, get_saved_cmdlines(map), TASK_COMM_LEN);\n\telse\n\t\tstrcpy(comm, \"<...>\");\n}\n\nvoid trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}\n\nint trace_find_tgid(int pid)\n{\n\tif (unlikely(!tgid_map || !pid || pid > PID_MAX_DEFAULT))\n\t\treturn 0;\n\n\treturn tgid_map[pid];\n}\n\nstatic int trace_save_tgid(struct task_struct *tsk)\n{\n\t/* treat recording of idle task as a success */\n\tif (!tsk->pid)\n\t\treturn 1;\n\n\tif (unlikely(!tgid_map || tsk->pid > PID_MAX_DEFAULT))\n\t\treturn 0;\n\n\ttgid_map[tsk->pid] = tsk->tgid;\n\treturn 1;\n}\n\nstatic bool tracing_record_taskinfo_skip(int flags)\n{\n\tif (unlikely(!(flags & (TRACE_RECORD_CMDLINE | TRACE_RECORD_TGID))))\n\t\treturn true;\n\tif (atomic_read(&trace_record_taskinfo_disabled) || !tracing_is_on())\n\t\treturn true;\n\tif (!__this_cpu_read(trace_taskinfo_save))\n\t\treturn true;\n\treturn false;\n}\n\n/**\n * tracing_record_taskinfo - record the task info of a task\n *\n * @task:  task to record\n * @flags: TRACE_RECORD_CMDLINE for recording comm\n *         TRACE_RECORD_TGID for recording tgid\n */\nvoid tracing_record_taskinfo(struct task_struct *task, int flags)\n{\n\tbool done;\n\n\tif (tracing_record_taskinfo_skip(flags))\n\t\treturn;\n\n\t/*\n\t * Record as much task information as possible. If some fail, continue\n\t * to try to record the others.\n\t */\n\tdone = !(flags & TRACE_RECORD_CMDLINE) || trace_save_cmdline(task);\n\tdone &= !(flags & TRACE_RECORD_TGID) || trace_save_tgid(task);\n\n\t/* If recording any information failed, retry again soon. */\n\tif (!done)\n\t\treturn;\n\n\t__this_cpu_write(trace_taskinfo_save, false);\n}\n\n/**\n * tracing_record_taskinfo_sched_switch - record task info for sched_switch\n *\n * @prev: previous task during sched_switch\n * @next: next task during sched_switch\n * @flags: TRACE_RECORD_CMDLINE for recording comm\n *         TRACE_RECORD_TGID for recording tgid\n */\nvoid tracing_record_taskinfo_sched_switch(struct task_struct *prev,\n\t\t\t\t\t  struct task_struct *next, int flags)\n{\n\tbool done;\n\n\tif (tracing_record_taskinfo_skip(flags))\n\t\treturn;\n\n\t/*\n\t * Record as much task information as possible. If some fail, continue\n\t * to try to record the others.\n\t */\n\tdone  = !(flags & TRACE_RECORD_CMDLINE) || trace_save_cmdline(prev);\n\tdone &= !(flags & TRACE_RECORD_CMDLINE) || trace_save_cmdline(next);\n\tdone &= !(flags & TRACE_RECORD_TGID) || trace_save_tgid(prev);\n\tdone &= !(flags & TRACE_RECORD_TGID) || trace_save_tgid(next);\n\n\t/* If recording any information failed, retry again soon. */\n\tif (!done)\n\t\treturn;\n\n\t__this_cpu_write(trace_taskinfo_save, false);\n}\n\n/* Helpers to record a specific task information */\nvoid tracing_record_cmdline(struct task_struct *task)\n{\n\ttracing_record_taskinfo(task, TRACE_RECORD_CMDLINE);\n}\n\nvoid tracing_record_tgid(struct task_struct *task)\n{\n\ttracing_record_taskinfo(task, TRACE_RECORD_TGID);\n}\n\n/*\n * Several functions return TRACE_TYPE_PARTIAL_LINE if the trace_seq\n * overflowed, and TRACE_TYPE_HANDLED otherwise. This helper function\n * simplifies those functions and keeps them in sync.\n */\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}\nEXPORT_SYMBOL_GPL(trace_handle_return);\n\nvoid\ntracing_generic_entry_update(struct trace_entry *entry, unsigned short type,\n\t\t\t     unsigned long flags, int pc)\n{\n\tstruct task_struct *tsk = current;\n\n\tentry->preempt_count\t\t= pc & 0xff;\n\tentry->pid\t\t\t= (tsk) ? tsk->pid : 0;\n\tentry->type\t\t\t= type;\n\tentry->flags =\n#ifdef CONFIG_TRACE_IRQFLAGS_SUPPORT\n\t\t(irqs_disabled_flags(flags) ? TRACE_FLAG_IRQS_OFF : 0) |\n#else\n\t\tTRACE_FLAG_IRQS_NOSUPPORT |\n#endif\n\t\t((pc & NMI_MASK    ) ? TRACE_FLAG_NMI     : 0) |\n\t\t((pc & HARDIRQ_MASK) ? TRACE_FLAG_HARDIRQ : 0) |\n\t\t((pc & SOFTIRQ_OFFSET) ? TRACE_FLAG_SOFTIRQ : 0) |\n\t\t(tif_need_resched() ? TRACE_FLAG_NEED_RESCHED : 0) |\n\t\t(test_preempt_need_resched() ? TRACE_FLAG_PREEMPT_RESCHED : 0);\n}\nEXPORT_SYMBOL_GPL(tracing_generic_entry_update);\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct trace_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}\n\nDEFINE_PER_CPU(struct ring_buffer_event *, trace_buffered_event);\nDEFINE_PER_CPU(int, trace_buffered_event_cnt);\nstatic int trace_buffered_event_ref;\n\n/**\n * trace_buffered_event_enable - enable buffering events\n *\n * When events are being filtered, it is quicker to use a temporary\n * buffer to write the event data into if there's a likely chance\n * that it will not be committed. The discard of the ring buffer\n * is not as fast as committing, and is much slower than copying\n * a commit.\n *\n * When an event is to be filtered, allocate per cpu buffers to\n * write the event data into, and if the event is filtered and discarded\n * it is simply dropped, otherwise, the entire data is to be committed\n * in one shot.\n */\nvoid trace_buffered_event_enable(void)\n{\n\tstruct ring_buffer_event *event;\n\tstruct page *page;\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (trace_buffered_event_ref++)\n\t\treturn;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tpage = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\tGFP_KERNEL | __GFP_NORETRY, 0);\n\t\tif (!page)\n\t\t\tgoto failed;\n\n\t\tevent = page_address(page);\n\t\tmemset(event, 0, sizeof(*event));\n\n\t\tper_cpu(trace_buffered_event, cpu) = event;\n\n\t\tpreempt_disable();\n\t\tif (cpu == smp_processor_id() &&\n\t\t    __this_cpu_read(trace_buffered_event) !=\n\t\t    per_cpu(trace_buffered_event, cpu))\n\t\t\tWARN_ON_ONCE(1);\n\t\tpreempt_enable();\n\t}\n\n\treturn;\n failed:\n\ttrace_buffered_event_disable();\n}\n\nstatic void enable_trace_buffered_event(void *data)\n{\n\t/* Probably not needed, but do it anyway */\n\tsmp_rmb();\n\tthis_cpu_dec(trace_buffered_event_cnt);\n}\n\nstatic void disable_trace_buffered_event(void *data)\n{\n\tthis_cpu_inc(trace_buffered_event_cnt);\n}\n\n/**\n * trace_buffered_event_disable - disable buffering events\n *\n * When a filter is removed, it is faster to not use the buffered\n * events, and to commit directly into the ring buffer. Free up\n * the temp buffers when there are no more users. This requires\n * special synchronization with current events.\n */\nvoid trace_buffered_event_disable(void)\n{\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (WARN_ON_ONCE(!trace_buffered_event_ref))\n\t\treturn;\n\n\tif (--trace_buffered_event_ref)\n\t\treturn;\n\n\tpreempt_disable();\n\t/* For each CPU, set the buffer as used. */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       disable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n\n\t/* Wait for all current users to finish */\n\tsynchronize_rcu();\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tfree_page((unsigned long)per_cpu(trace_buffered_event, cpu));\n\t\tper_cpu(trace_buffered_event, cpu) = NULL;\n\t}\n\t/*\n\t * Make sure trace_buffered_event is NULL before clearing\n\t * trace_buffered_event_cnt.\n\t */\n\tsmp_wmb();\n\n\tpreempt_disable();\n\t/* Do the work on each cpu */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       enable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n}\n\nstatic struct trace_buffer *temp_buffer;\n\nstruct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct trace_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\tstruct ring_buffer_event *entry;\n\tint val;\n\n\t*current_rb = trace_file->tr->array_buffer.buffer;\n\n\tif (!ring_buffer_time_stamp_abs(*current_rb) && (trace_file->flags &\n\t     (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED)) &&\n\t    (entry = this_cpu_read(trace_buffered_event))) {\n\t\t/* Try to use the per cpu buffer first */\n\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\t\tif (val == 1) {\n\t\t\ttrace_event_setup(entry, type, flags, pc);\n\t\t\tentry->array[0] = len;\n\t\t\treturn entry;\n\t\t}\n\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t    type, len, flags, pc);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the trigger to use. It's recursive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t\t    type, len, flags, pc);\n\t}\n\treturn entry;\n}\nEXPORT_SYMBOL_GPL(trace_event_buffer_lock_reserve);\n\nstatic DEFINE_SPINLOCK(tracepoint_iter_lock);\nstatic DEFINE_MUTEX(tracepoint_printk_mutex);\n\nstatic void output_printk(struct trace_event_buffer *fbuffer)\n{\n\tstruct trace_event_call *event_call;\n\tstruct trace_event_file *file;\n\tstruct trace_event *event;\n\tunsigned long flags;\n\tstruct trace_iterator *iter = tracepoint_print_iter;\n\n\t/* We should never get here if iter is NULL */\n\tif (WARN_ON_ONCE(!iter))\n\t\treturn;\n\n\tevent_call = fbuffer->trace_file->event_call;\n\tif (!event_call || !event_call->event.funcs ||\n\t    !event_call->event.funcs->trace)\n\t\treturn;\n\n\tfile = fbuffer->trace_file;\n\tif (test_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags) ||\n\t    (unlikely(file->flags & EVENT_FILE_FL_FILTERED) &&\n\t     !filter_match_preds(file->filter, fbuffer->entry)))\n\t\treturn;\n\n\tevent = &fbuffer->trace_file->event_call->event;\n\n\tspin_lock_irqsave(&tracepoint_iter_lock, flags);\n\ttrace_seq_init(&iter->seq);\n\titer->ent = fbuffer->entry;\n\tevent_call->event.funcs->trace(iter, 0, event);\n\ttrace_seq_putc(&iter->seq, 0);\n\tprintk(\"%s\", iter->seq.buffer);\n\n\tspin_unlock_irqrestore(&tracepoint_iter_lock, flags);\n}\n\nint tracepoint_printk_sysctl(struct ctl_table *table, int write,\n\t\t\t     void *buffer, size_t *lenp,\n\t\t\t     loff_t *ppos)\n{\n\tint save_tracepoint_printk;\n\tint ret;\n\n\tmutex_lock(&tracepoint_printk_mutex);\n\tsave_tracepoint_printk = tracepoint_printk;\n\n\tret = proc_dointvec(table, write, buffer, lenp, ppos);\n\n\t/*\n\t * This will force exiting early, as tracepoint_printk\n\t * is always zero when tracepoint_printk_iter is not allocated\n\t */\n\tif (!tracepoint_print_iter)\n\t\ttracepoint_printk = 0;\n\n\tif (save_tracepoint_printk == tracepoint_printk)\n\t\tgoto out;\n\n\tif (tracepoint_printk)\n\t\tstatic_key_enable(&tracepoint_printk_key.key);\n\telse\n\t\tstatic_key_disable(&tracepoint_printk_key.key);\n\n out:\n\tmutex_unlock(&tracepoint_printk_mutex);\n\n\treturn ret;\n}\n\nvoid trace_event_buffer_commit(struct trace_event_buffer *fbuffer)\n{\n\tif (static_key_false(&tracepoint_printk_key.key))\n\t\toutput_printk(fbuffer);\n\n\tif (static_branch_unlikely(&trace_event_exports_enabled))\n\t\tftrace_exports(fbuffer->event, TRACE_EXPORT_EVENT);\n\tevent_trigger_unlock_commit_regs(fbuffer->trace_file, fbuffer->buffer,\n\t\t\t\t    fbuffer->event, fbuffer->entry,\n\t\t\t\t    fbuffer->flags, fbuffer->pc, fbuffer->regs);\n}\nEXPORT_SYMBOL_GPL(trace_event_buffer_commit);\n\n/*\n * Skip 3:\n *\n *   trace_buffer_unlock_commit_regs()\n *   trace_event_buffer_commit()\n *   trace_event_raw_event_xxx()\n */\n# define STACK_SKIP 3\n\nvoid trace_buffer_unlock_commit_regs(struct trace_array *tr,\n\t\t\t\t     struct trace_buffer *buffer,\n\t\t\t\t     struct ring_buffer_event *event,\n\t\t\t\t     unsigned long flags, int pc,\n\t\t\t\t     struct pt_regs *regs)\n{\n\t__buffer_unlock_commit(buffer, event);\n\n\t/*\n\t * If regs is not set, then skip the necessary functions.\n\t * Note, we can still get here via blktrace, wakeup tracer\n\t * and mmiotrace, but that's ok if they lose a function or\n\t * two. They are not that meaningful.\n\t */\n\tftrace_trace_stack(tr, buffer, flags, regs ? 0 : STACK_SKIP, pc, regs);\n\tftrace_trace_userstack(buffer, flags, pc);\n}\n\n/*\n * Similar to trace_buffer_unlock_commit_regs() but do not dump stack.\n */\nvoid\ntrace_buffer_unlock_commit_nostack(struct trace_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}\n\nvoid\ntrace_function(struct trace_array *tr,\n\t       unsigned long ip, unsigned long parent_ip, unsigned long flags,\n\t       int pc)\n{\n\tstruct trace_event_call *call = &event_function;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct ftrace_entry *entry;\n\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_FN, sizeof(*entry),\n\t\t\t\t\t    flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ip\t\t\t= ip;\n\tentry->parent_ip\t\t= parent_ip;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event)) {\n\t\tif (static_branch_unlikely(&trace_function_exports_enabled))\n\t\t\tftrace_exports(event, TRACE_EXPORT_FUNCTION);\n\t\t__buffer_unlock_commit(buffer, event);\n\t}\n}\n\n#ifdef CONFIG_STACKTRACE\n\n/* Allow 4 levels of nesting: normal, softirq, irq, NMI */\n#define FTRACE_KSTACK_NESTING\t4\n\n#define FTRACE_KSTACK_ENTRIES\t(PAGE_SIZE / FTRACE_KSTACK_NESTING)\n\nstruct ftrace_stack {\n\tunsigned long\t\tcalls[FTRACE_KSTACK_ENTRIES];\n};\n\n\nstruct ftrace_stacks {\n\tstruct ftrace_stack\tstacks[FTRACE_KSTACK_NESTING];\n};\n\nstatic DEFINE_PER_CPU(struct ftrace_stacks, ftrace_stacks);\nstatic DEFINE_PER_CPU(int, ftrace_stack_reserve);\n\nstatic void __ftrace_trace_stack(struct trace_buffer *buffer,\n\t\t\t\t unsigned long flags,\n\t\t\t\t int skip, int pc, struct pt_regs *regs)\n{\n\tstruct trace_event_call *call = &event_kernel_stack;\n\tstruct ring_buffer_event *event;\n\tunsigned int size, nr_entries;\n\tstruct ftrace_stack *fstack;\n\tstruct stack_entry *entry;\n\tint stackidx;\n\n\t/*\n\t * Add one, for this function and the call to save_stack_trace()\n\t * If regs is set, then these functions will not be in the way.\n\t */\n#ifndef CONFIG_UNWINDER_ORC\n\tif (!regs)\n\t\tskip++;\n#endif\n\n\tpreempt_disable_notrace();\n\n\tstackidx = __this_cpu_inc_return(ftrace_stack_reserve) - 1;\n\n\t/* This should never happen. If it does, yell once and skip */\n\tif (WARN_ON_ONCE(stackidx >= FTRACE_KSTACK_NESTING))\n\t\tgoto out;\n\n\t/*\n\t * The above __this_cpu_inc_return() is 'atomic' cpu local. An\n\t * interrupt will either see the value pre increment or post\n\t * increment. If the interrupt happens pre increment it will have\n\t * restored the counter when it returns.  We just need a barrier to\n\t * keep gcc from moving things around.\n\t */\n\tbarrier();\n\n\tfstack = this_cpu_ptr(ftrace_stacks.stacks) + stackidx;\n\tsize = ARRAY_SIZE(fstack->calls);\n\n\tif (regs) {\n\t\tnr_entries = stack_trace_save_regs(regs, fstack->calls,\n\t\t\t\t\t\t   size, skip);\n\t} else {\n\t\tnr_entries = stack_trace_save(fstack->calls, size, skip);\n\t}\n\n\tsize = nr_entries * sizeof(unsigned long);\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_STACK,\n\t\t\t\t\t    sizeof(*entry) + size, flags, pc);\n\tif (!event)\n\t\tgoto out;\n\tentry = ring_buffer_event_data(event);\n\n\tmemcpy(&entry->caller, fstack->calls, size);\n\tentry->size = nr_entries;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\t__buffer_unlock_commit(buffer, event);\n\n out:\n\t/* Again, don't let gcc optimize things here */\n\tbarrier();\n\t__this_cpu_dec(ftrace_stack_reserve);\n\tpreempt_enable_notrace();\n\n}\n\nstatic inline void ftrace_trace_stack(struct trace_array *tr,\n\t\t\t\t      struct trace_buffer *buffer,\n\t\t\t\t      unsigned long flags,\n\t\t\t\t      int skip, int pc, struct pt_regs *regs)\n{\n\tif (!(tr->trace_flags & TRACE_ITER_STACKTRACE))\n\t\treturn;\n\n\t__ftrace_trace_stack(buffer, flags, skip, pc, regs);\n}\n\nvoid __trace_stack(struct trace_array *tr, unsigned long flags, int skip,\n\t\t   int pc)\n{\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\n\tif (rcu_is_watching()) {\n\t\t__ftrace_trace_stack(buffer, flags, skip, pc, NULL);\n\t\treturn;\n\t}\n\n\t/*\n\t * When an NMI triggers, RCU is enabled via rcu_nmi_enter(),\n\t * but if the above rcu_is_watching() failed, then the NMI\n\t * triggered someplace critical, and rcu_irq_enter() should\n\t * not be called from NMI.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\trcu_irq_enter_irqson();\n\t__ftrace_trace_stack(buffer, flags, skip, pc, NULL);\n\trcu_irq_exit_irqson();\n}\n\n/**\n * trace_dump_stack - record a stack back trace in the trace buffer\n * @skip: Number of functions to skip (helper handlers)\n */\nvoid trace_dump_stack(int skip)\n{\n\tunsigned long flags;\n\n\tif (tracing_disabled || tracing_selftest_running)\n\t\treturn;\n\n\tlocal_save_flags(flags);\n\n#ifndef CONFIG_UNWINDER_ORC\n\t/* Skip 1 to skip this function. */\n\tskip++;\n#endif\n\t__ftrace_trace_stack(global_trace.array_buffer.buffer,\n\t\t\t     flags, skip, preempt_count(), NULL);\n}\nEXPORT_SYMBOL_GPL(trace_dump_stack);\n\n#ifdef CONFIG_USER_STACKTRACE_SUPPORT\nstatic DEFINE_PER_CPU(int, user_stack_count);\n\nstatic void\nftrace_trace_userstack(struct trace_buffer *buffer, unsigned long flags, int pc)\n{\n\tstruct trace_event_call *call = &event_user_stack;\n\tstruct ring_buffer_event *event;\n\tstruct userstack_entry *entry;\n\n\tif (!(global_trace.trace_flags & TRACE_ITER_USERSTACKTRACE))\n\t\treturn;\n\n\t/*\n\t * NMIs can not handle page faults, even with fix ups.\n\t * The save user stack can (and often does) fault.\n\t */\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\t/*\n\t * prevent recursion, since the user stack tracing may\n\t * trigger other kernel events.\n\t */\n\tpreempt_disable();\n\tif (__this_cpu_read(user_stack_count))\n\t\tgoto out;\n\n\t__this_cpu_inc(user_stack_count);\n\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_USER_STACK,\n\t\t\t\t\t    sizeof(*entry), flags, pc);\n\tif (!event)\n\t\tgoto out_drop_count;\n\tentry\t= ring_buffer_event_data(event);\n\n\tentry->tgid\t\t= current->tgid;\n\tmemset(&entry->caller, 0, sizeof(entry->caller));\n\n\tstack_trace_save_user(entry->caller, FTRACE_STACK_ENTRIES);\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\t__buffer_unlock_commit(buffer, event);\n\n out_drop_count:\n\t__this_cpu_dec(user_stack_count);\n out:\n\tpreempt_enable();\n}\n#else /* CONFIG_USER_STACKTRACE_SUPPORT */\nstatic void ftrace_trace_userstack(struct trace_buffer *buffer,\n\t\t\t\t   unsigned long flags, int pc)\n{\n}\n#endif /* !CONFIG_USER_STACKTRACE_SUPPORT */\n\n#endif /* CONFIG_STACKTRACE */\n\n/* created for use with alloc_percpu */\nstruct trace_buffer_struct {\n\tint nesting;\n\tchar buffer[4][TRACE_BUF_SIZE];\n};\n\nstatic struct trace_buffer_struct *trace_percpu_buffer;\n\n/*\n * This allows for lockless recording.  If we're nested too deeply, then\n * this returns NULL.\n */\nstatic char *get_trace_buf(void)\n{\n\tstruct trace_buffer_struct *buffer = this_cpu_ptr(trace_percpu_buffer);\n\n\tif (!buffer || buffer->nesting >= 4)\n\t\treturn NULL;\n\n\tbuffer->nesting++;\n\n\t/* Interrupts must see nesting incremented before we use the buffer */\n\tbarrier();\n\treturn &buffer->buffer[buffer->nesting - 1][0];\n}\n\nstatic void put_trace_buf(void)\n{\n\t/* Don't let the decrement of nesting leak before this */\n\tbarrier();\n\tthis_cpu_dec(trace_percpu_buffer->nesting);\n}\n\nstatic int alloc_percpu_trace_buffer(void)\n{\n\tstruct trace_buffer_struct *buffers;\n\n\tif (trace_percpu_buffer)\n\t\treturn 0;\n\n\tbuffers = alloc_percpu(struct trace_buffer_struct);\n\tif (MEM_FAIL(!buffers, \"Could not allocate percpu trace_printk buffer\"))\n\t\treturn -ENOMEM;\n\n\ttrace_percpu_buffer = buffers;\n\treturn 0;\n}\n\nstatic int buffers_allocated;\n\nvoid trace_printk_init_buffers(void)\n{\n\tif (buffers_allocated)\n\t\treturn;\n\n\tif (alloc_percpu_trace_buffer())\n\t\treturn;\n\n\t/* trace_printk() is for debug use only. Don't use it in production. */\n\n\tpr_warn(\"\\n\");\n\tpr_warn(\"**********************************************************\\n\");\n\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** trace_printk() being used. Allocating extra memory.  **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** This means that this is a DEBUG kernel and it is     **\\n\");\n\tpr_warn(\"** unsafe for production use.                           **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** If you see this message and you are not debugging    **\\n\");\n\tpr_warn(\"** the kernel, report this immediately to your vendor!  **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\tpr_warn(\"**********************************************************\\n\");\n\n\t/* Expand the buffers to set size */\n\ttracing_update_buffers();\n\n\tbuffers_allocated = 1;\n\n\t/*\n\t * trace_printk_init_buffers() can be called by modules.\n\t * If that happens, then we need to start cmdline recording\n\t * directly here. If the global_trace.buffer is already\n\t * allocated here, then this was called by module code.\n\t */\n\tif (global_trace.array_buffer.buffer)\n\t\ttracing_start_cmdline_record();\n}\nEXPORT_SYMBOL_GPL(trace_printk_init_buffers);\n\nvoid trace_printk_start_comm(void)\n{\n\t/* Start tracing comms if trace printk is set */\n\tif (!buffers_allocated)\n\t\treturn;\n\ttracing_start_cmdline_record();\n}\n\nstatic void trace_printk_start_stop_comm(int enabled)\n{\n\tif (!buffers_allocated)\n\t\treturn;\n\n\tif (enabled)\n\t\ttracing_start_cmdline_record();\n\telse\n\t\ttracing_stop_cmdline_record();\n}\n\n/**\n * trace_vbprintk - write binary msg to tracing buffer\n * @ip:    The address of the caller\n * @fmt:   The string format to write to the buffer\n * @args:  Arguments for @fmt\n */\nint trace_vbprintk(unsigned long ip, const char *fmt, va_list args)\n{\n\tstruct trace_event_call *call = &event_bprint;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer;\n\tstruct trace_array *tr = &global_trace;\n\tstruct bprint_entry *entry;\n\tunsigned long flags;\n\tchar *tbuffer;\n\tint len = 0, size, pc;\n\n\tif (unlikely(tracing_selftest_running || tracing_disabled))\n\t\treturn 0;\n\n\t/* Don't pollute graph traces with trace_vprintk internals */\n\tpause_graph_tracing();\n\n\tpc = preempt_count();\n\tpreempt_disable_notrace();\n\n\ttbuffer = get_trace_buf();\n\tif (!tbuffer) {\n\t\tlen = 0;\n\t\tgoto out_nobuffer;\n\t}\n\n\tlen = vbin_printf((u32 *)tbuffer, TRACE_BUF_SIZE/sizeof(int), fmt, args);\n\n\tif (len > TRACE_BUF_SIZE/sizeof(int) || len < 0)\n\t\tgoto out_put;\n\n\tlocal_save_flags(flags);\n\tsize = sizeof(*entry) + sizeof(u32) * len;\n\tbuffer = tr->array_buffer.buffer;\n\tring_buffer_nest_start(buffer);\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_BPRINT, size,\n\t\t\t\t\t    flags, pc);\n\tif (!event)\n\t\tgoto out;\n\tentry = ring_buffer_event_data(event);\n\tentry->ip\t\t\t= ip;\n\tentry->fmt\t\t\t= fmt;\n\n\tmemcpy(entry->buf, tbuffer, sizeof(u32) * len);\n\tif (!call_filter_check_discard(call, entry, buffer, event)) {\n\t\t__buffer_unlock_commit(buffer, event);\n\t\tftrace_trace_stack(tr, buffer, flags, 6, pc, NULL);\n\t}\n\nout:\n\tring_buffer_nest_end(buffer);\nout_put:\n\tput_trace_buf();\n\nout_nobuffer:\n\tpreempt_enable_notrace();\n\tunpause_graph_tracing();\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(trace_vbprintk);\n\n__printf(3, 0)\nstatic int\n__trace_array_vprintk(struct trace_buffer *buffer,\n\t\t      unsigned long ip, const char *fmt, va_list args)\n{\n\tstruct trace_event_call *call = &event_print;\n\tstruct ring_buffer_event *event;\n\tint len = 0, size, pc;\n\tstruct print_entry *entry;\n\tunsigned long flags;\n\tchar *tbuffer;\n\n\tif (tracing_disabled || tracing_selftest_running)\n\t\treturn 0;\n\n\t/* Don't pollute graph traces with trace_vprintk internals */\n\tpause_graph_tracing();\n\n\tpc = preempt_count();\n\tpreempt_disable_notrace();\n\n\n\ttbuffer = get_trace_buf();\n\tif (!tbuffer) {\n\t\tlen = 0;\n\t\tgoto out_nobuffer;\n\t}\n\n\tlen = vscnprintf(tbuffer, TRACE_BUF_SIZE, fmt, args);\n\n\tlocal_save_flags(flags);\n\tsize = sizeof(*entry) + len + 1;\n\tring_buffer_nest_start(buffer);\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_PRINT, size,\n\t\t\t\t\t    flags, pc);\n\tif (!event)\n\t\tgoto out;\n\tentry = ring_buffer_event_data(event);\n\tentry->ip = ip;\n\n\tmemcpy(&entry->buf, tbuffer, len + 1);\n\tif (!call_filter_check_discard(call, entry, buffer, event)) {\n\t\t__buffer_unlock_commit(buffer, event);\n\t\tftrace_trace_stack(&global_trace, buffer, flags, 6, pc, NULL);\n\t}\n\nout:\n\tring_buffer_nest_end(buffer);\n\tput_trace_buf();\n\nout_nobuffer:\n\tpreempt_enable_notrace();\n\tunpause_graph_tracing();\n\n\treturn len;\n}\n\n__printf(3, 0)\nint trace_array_vprintk(struct trace_array *tr,\n\t\t\tunsigned long ip, const char *fmt, va_list args)\n{\n\treturn __trace_array_vprintk(tr->array_buffer.buffer, ip, fmt, args);\n}\n\n/**\n * trace_array_printk - Print a message to a specific instance\n * @tr: The instance trace_array descriptor\n * @ip: The instruction pointer that this is called from.\n * @fmt: The format to print (printf format)\n *\n * If a subsystem sets up its own instance, they have the right to\n * printk strings into their tracing instance buffer using this\n * function. Note, this function will not write into the top level\n * buffer (use trace_printk() for that), as writing into the top level\n * buffer should only have events that can be individually disabled.\n * trace_printk() is only used for debugging a kernel, and should not\n * be ever encorporated in normal use.\n *\n * trace_array_printk() can be used, as it will not add noise to the\n * top level tracing buffer.\n *\n * Note, trace_array_init_printk() must be called on @tr before this\n * can be used.\n */\n__printf(3, 0)\nint trace_array_printk(struct trace_array *tr,\n\t\t       unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\t/* This is only allowed for created instances */\n\tif (tr == &global_trace)\n\t\treturn 0;\n\n\tif (!(tr->trace_flags & TRACE_ITER_PRINTK))\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_array_vprintk(tr, ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(trace_array_printk);\n\n/**\n * trace_array_init_printk - Initialize buffers for trace_array_printk()\n * @tr: The trace array to initialize the buffers for\n *\n * As trace_array_printk() only writes into instances, they are OK to\n * have in the kernel (unlike trace_printk()). This needs to be called\n * before trace_array_printk() can be used on a trace_array.\n */\nint trace_array_init_printk(struct trace_array *tr)\n{\n\tif (!tr)\n\t\treturn -ENOENT;\n\n\t/* This is only allowed for created instances */\n\tif (tr == &global_trace)\n\t\treturn -EINVAL;\n\n\treturn alloc_percpu_trace_buffer();\n}\nEXPORT_SYMBOL_GPL(trace_array_init_printk);\n\n__printf(3, 4)\nint trace_array_printk_buf(struct trace_buffer *buffer,\n\t\t\t   unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!(global_trace.trace_flags & TRACE_ITER_PRINTK))\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = __trace_array_vprintk(buffer, ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n\n__printf(2, 0)\nint trace_vprintk(unsigned long ip, const char *fmt, va_list args)\n{\n\treturn trace_array_vprintk(&global_trace, ip, fmt, args);\n}\nEXPORT_SYMBOL_GPL(trace_vprintk);\n\nstatic void trace_iterator_increment(struct trace_iterator *iter)\n{\n\tstruct ring_buffer_iter *buf_iter = trace_buffer_iter(iter, iter->cpu);\n\n\titer->idx++;\n\tif (buf_iter)\n\t\tring_buffer_iter_advance(buf_iter);\n}\n\nstatic struct trace_entry *\npeek_next_entry(struct trace_iterator *iter, int cpu, u64 *ts,\n\t\tunsigned long *lost_events)\n{\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer_iter *buf_iter = trace_buffer_iter(iter, cpu);\n\n\tif (buf_iter) {\n\t\tevent = ring_buffer_iter_peek(buf_iter, ts);\n\t\tif (lost_events)\n\t\t\t*lost_events = ring_buffer_iter_dropped(buf_iter) ?\n\t\t\t\t(unsigned long)-1 : 0;\n\t} else {\n\t\tevent = ring_buffer_peek(iter->array_buffer->buffer, cpu, ts,\n\t\t\t\t\t lost_events);\n\t}\n\n\tif (event) {\n\t\titer->ent_size = ring_buffer_event_length(event);\n\t\treturn ring_buffer_event_data(event);\n\t}\n\titer->ent_size = 0;\n\treturn NULL;\n}\n\nstatic struct trace_entry *\n__find_next_entry(struct trace_iterator *iter, int *ent_cpu,\n\t\t  unsigned long *missing_events, u64 *ent_ts)\n{\n\tstruct trace_buffer *buffer = iter->array_buffer->buffer;\n\tstruct trace_entry *ent, *next = NULL;\n\tunsigned long lost_events = 0, next_lost = 0;\n\tint cpu_file = iter->cpu_file;\n\tu64 next_ts = 0, ts;\n\tint next_cpu = -1;\n\tint next_size = 0;\n\tint cpu;\n\n\t/*\n\t * If we are in a per_cpu trace file, don't bother by iterating over\n\t * all cpu and peek directly.\n\t */\n\tif (cpu_file > RING_BUFFER_ALL_CPUS) {\n\t\tif (ring_buffer_empty_cpu(buffer, cpu_file))\n\t\t\treturn NULL;\n\t\tent = peek_next_entry(iter, cpu_file, ent_ts, missing_events);\n\t\tif (ent_cpu)\n\t\t\t*ent_cpu = cpu_file;\n\n\t\treturn ent;\n\t}\n\n\tfor_each_tracing_cpu(cpu) {\n\n\t\tif (ring_buffer_empty_cpu(buffer, cpu))\n\t\t\tcontinue;\n\n\t\tent = peek_next_entry(iter, cpu, &ts, &lost_events);\n\n\t\t/*\n\t\t * Pick the entry with the smallest timestamp:\n\t\t */\n\t\tif (ent && (!next || ts < next_ts)) {\n\t\t\tnext = ent;\n\t\t\tnext_cpu = cpu;\n\t\t\tnext_ts = ts;\n\t\t\tnext_lost = lost_events;\n\t\t\tnext_size = iter->ent_size;\n\t\t}\n\t}\n\n\titer->ent_size = next_size;\n\n\tif (ent_cpu)\n\t\t*ent_cpu = next_cpu;\n\n\tif (ent_ts)\n\t\t*ent_ts = next_ts;\n\n\tif (missing_events)\n\t\t*missing_events = next_lost;\n\n\treturn next;\n}\n\n#define STATIC_TEMP_BUF_SIZE\t128\nstatic char static_temp_buf[STATIC_TEMP_BUF_SIZE];\n\n/* Find the next real entry, without updating the iterator itself */\nstruct trace_entry *trace_find_next_entry(struct trace_iterator *iter,\n\t\t\t\t\t  int *ent_cpu, u64 *ent_ts)\n{\n\t/* __find_next_entry will reset ent_size */\n\tint ent_size = iter->ent_size;\n\tstruct trace_entry *entry;\n\n\t/*\n\t * If called from ftrace_dump(), then the iter->temp buffer\n\t * will be the static_temp_buf and not created from kmalloc.\n\t * If the entry size is greater than the buffer, we can\n\t * not save it. Just return NULL in that case. This is only\n\t * used to add markers when two consecutive events' time\n\t * stamps have a large delta. See trace_print_lat_context()\n\t */\n\tif (iter->temp == static_temp_buf &&\n\t    STATIC_TEMP_BUF_SIZE < ent_size)\n\t\treturn NULL;\n\n\t/*\n\t * The __find_next_entry() may call peek_next_entry(), which may\n\t * call ring_buffer_peek() that may make the contents of iter->ent\n\t * undefined. Need to copy iter->ent now.\n\t */\n\tif (iter->ent && iter->ent != iter->temp) {\n\t\tif ((!iter->temp || iter->temp_size < iter->ent_size) &&\n\t\t    !WARN_ON_ONCE(iter->temp == static_temp_buf)) {\n\t\t\tvoid *temp;\n\t\t\ttemp = kmalloc(iter->ent_size, GFP_KERNEL);\n\t\t\tif (!temp)\n\t\t\t\treturn NULL;\n\t\t\tkfree(iter->temp);\n\t\t\titer->temp = temp;\n\t\t\titer->temp_size = iter->ent_size;\n\t\t}\n\t\tmemcpy(iter->temp, iter->ent, iter->ent_size);\n\t\titer->ent = iter->temp;\n\t}\n\tentry = __find_next_entry(iter, ent_cpu, NULL, ent_ts);\n\t/* Put back the original ent_size */\n\titer->ent_size = ent_size;\n\n\treturn entry;\n}\n\n/* Find the next real entry, and increment the iterator to the next entry */\nvoid *trace_find_next_entry_inc(struct trace_iterator *iter)\n{\n\titer->ent = __find_next_entry(iter, &iter->cpu,\n\t\t\t\t      &iter->lost_events, &iter->ts);\n\n\tif (iter->ent)\n\t\ttrace_iterator_increment(iter);\n\n\treturn iter->ent ? iter : NULL;\n}\n\nstatic void trace_consume(struct trace_iterator *iter)\n{\n\tring_buffer_consume(iter->array_buffer->buffer, iter->cpu, &iter->ts,\n\t\t\t    &iter->lost_events);\n}\n\nstatic void *s_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_iterator *iter = m->private;\n\tint i = (int)*pos;\n\tvoid *ent;\n\n\tWARN_ON_ONCE(iter->leftover);\n\n\t(*pos)++;\n\n\t/* can't go backwards */\n\tif (iter->idx > i)\n\t\treturn NULL;\n\n\tif (iter->idx < 0)\n\t\tent = trace_find_next_entry_inc(iter);\n\telse\n\t\tent = iter;\n\n\twhile (ent && iter->idx < i)\n\t\tent = trace_find_next_entry_inc(iter);\n\n\titer->pos = *pos;\n\n\treturn ent;\n}\n\nvoid tracing_iter_reset(struct trace_iterator *iter, int cpu)\n{\n\tstruct ring_buffer_iter *buf_iter;\n\tunsigned long entries = 0;\n\tu64 ts;\n\n\tper_cpu_ptr(iter->array_buffer->data, cpu)->skipped_entries = 0;\n\n\tbuf_iter = trace_buffer_iter(iter, cpu);\n\tif (!buf_iter)\n\t\treturn;\n\n\tring_buffer_iter_reset(buf_iter);\n\n\t/*\n\t * We could have the case with the max latency tracers\n\t * that a reset never took place on a cpu. This is evident\n\t * by the timestamp being before the start of the buffer.\n\t */\n\twhile (ring_buffer_iter_peek(buf_iter, &ts)) {\n\t\tif (ts >= iter->array_buffer->time_start)\n\t\t\tbreak;\n\t\tentries++;\n\t\tring_buffer_iter_advance(buf_iter);\n\t}\n\n\tper_cpu_ptr(iter->array_buffer->data, cpu)->skipped_entries = entries;\n}\n\n/*\n * The current tracer is copied to avoid a global locking\n * all around.\n */\nstatic void *s_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu_file = iter->cpu_file;\n\tvoid *p = NULL;\n\tloff_t l = 0;\n\tint cpu;\n\n\t/*\n\t * copy the tracer to avoid using a global lock all around.\n\t * iter->trace is a copy of current_trace, the pointer to the\n\t * name may be used instead of a strcmp(), as iter->trace->name\n\t * will point to the same string as current_trace->name.\n\t */\n\tmutex_lock(&trace_types_lock);\n\tif (unlikely(tr->current_trace && iter->trace->name != tr->current_trace->name))\n\t\t*iter->trace = *tr->current_trace;\n\tmutex_unlock(&trace_types_lock);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (iter->snapshot && iter->trace->use_max_tr)\n\t\treturn ERR_PTR(-EBUSY);\n#endif\n\n\tif (!iter->snapshot)\n\t\tatomic_inc(&trace_record_taskinfo_disabled);\n\n\tif (*pos != iter->pos) {\n\t\titer->ent = NULL;\n\t\titer->cpu = 0;\n\t\titer->idx = -1;\n\n\t\tif (cpu_file == RING_BUFFER_ALL_CPUS) {\n\t\t\tfor_each_tracing_cpu(cpu)\n\t\t\t\ttracing_iter_reset(iter, cpu);\n\t\t} else\n\t\t\ttracing_iter_reset(iter, cpu_file);\n\n\t\titer->leftover = 0;\n\t\tfor (p = iter; p && l < *pos; p = s_next(m, p, &l))\n\t\t\t;\n\n\t} else {\n\t\t/*\n\t\t * If we overflowed the seq_file before, then we want\n\t\t * to just reuse the trace_seq buffer again.\n\t\t */\n\t\tif (iter->leftover)\n\t\t\tp = iter;\n\t\telse {\n\t\t\tl = *pos - 1;\n\t\t\tp = s_next(m, p, &l);\n\t\t}\n\t}\n\n\ttrace_event_read_lock();\n\ttrace_access_lock(cpu_file);\n\treturn p;\n}\n\nstatic void s_stop(struct seq_file *m, void *p)\n{\n\tstruct trace_iterator *iter = m->private;\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (iter->snapshot && iter->trace->use_max_tr)\n\t\treturn;\n#endif\n\n\tif (!iter->snapshot)\n\t\tatomic_dec(&trace_record_taskinfo_disabled);\n\n\ttrace_access_unlock(iter->cpu_file);\n\ttrace_event_read_unlock();\n}\n\nstatic void\nget_total_entries_cpu(struct array_buffer *buf, unsigned long *total,\n\t\t      unsigned long *entries, int cpu)\n{\n\tunsigned long count;\n\n\tcount = ring_buffer_entries_cpu(buf->buffer, cpu);\n\t/*\n\t * If this buffer has skipped entries, then we hold all\n\t * entries for the trace and we need to ignore the\n\t * ones before the time stamp.\n\t */\n\tif (per_cpu_ptr(buf->data, cpu)->skipped_entries) {\n\t\tcount -= per_cpu_ptr(buf->data, cpu)->skipped_entries;\n\t\t/* total is the same as the entries */\n\t\t*total = count;\n\t} else\n\t\t*total = count +\n\t\t\tring_buffer_overrun_cpu(buf->buffer, cpu);\n\t*entries = count;\n}\n\nstatic void\nget_total_entries(struct array_buffer *buf,\n\t\t  unsigned long *total, unsigned long *entries)\n{\n\tunsigned long t, e;\n\tint cpu;\n\n\t*total = 0;\n\t*entries = 0;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tget_total_entries_cpu(buf, &t, &e, cpu);\n\t\t*total += t;\n\t\t*entries += e;\n\t}\n}\n\nunsigned long trace_total_entries_cpu(struct trace_array *tr, int cpu)\n{\n\tunsigned long total, entries;\n\n\tif (!tr)\n\t\ttr = &global_trace;\n\n\tget_total_entries_cpu(&tr->array_buffer, &total, &entries, cpu);\n\n\treturn entries;\n}\n\nunsigned long trace_total_entries(struct trace_array *tr)\n{\n\tunsigned long total, entries;\n\n\tif (!tr)\n\t\ttr = &global_trace;\n\n\tget_total_entries(&tr->array_buffer, &total, &entries);\n\n\treturn entries;\n}\n\nstatic void print_lat_help_header(struct seq_file *m)\n{\n\tseq_puts(m, \"#                    _------=> CPU#            \\n\"\n\t\t    \"#                   / _-----=> irqs-off        \\n\"\n\t\t    \"#                  | / _----=> need-resched    \\n\"\n\t\t    \"#                  || / _---=> hardirq/softirq \\n\"\n\t\t    \"#                  ||| / _--=> preempt-depth   \\n\"\n\t\t    \"#                  |||| /     delay            \\n\"\n\t\t    \"#  cmd     pid     ||||| time  |   caller      \\n\"\n\t\t    \"#     \\\\   /        |||||  \\\\    |   /         \\n\");\n}\n\nstatic void print_event_info(struct array_buffer *buf, struct seq_file *m)\n{\n\tunsigned long total;\n\tunsigned long entries;\n\n\tget_total_entries(buf, &total, &entries);\n\tseq_printf(m, \"# entries-in-buffer/entries-written: %lu/%lu   #P:%d\\n\",\n\t\t   entries, total, num_online_cpus());\n\tseq_puts(m, \"#\\n\");\n}\n\nstatic void print_func_help_header(struct array_buffer *buf, struct seq_file *m,\n\t\t\t\t   unsigned int flags)\n{\n\tbool tgid = flags & TRACE_ITER_RECORD_TGID;\n\n\tprint_event_info(buf, m);\n\n\tseq_printf(m, \"#           TASK-PID    %s CPU#     TIMESTAMP  FUNCTION\\n\", tgid ? \"   TGID   \" : \"\");\n\tseq_printf(m, \"#              | |      %s   |         |         |\\n\",      tgid ? \"     |    \" : \"\");\n}\n\nstatic void print_func_help_header_irq(struct array_buffer *buf, struct seq_file *m,\n\t\t\t\t       unsigned int flags)\n{\n\tbool tgid = flags & TRACE_ITER_RECORD_TGID;\n\tconst char *space = \"            \";\n\tint prec = tgid ? 12 : 2;\n\n\tprint_event_info(buf, m);\n\n\tseq_printf(m, \"#                            %.*s  _-----=> irqs-off\\n\", prec, space);\n\tseq_printf(m, \"#                            %.*s / _----=> need-resched\\n\", prec, space);\n\tseq_printf(m, \"#                            %.*s| / _---=> hardirq/softirq\\n\", prec, space);\n\tseq_printf(m, \"#                            %.*s|| / _--=> preempt-depth\\n\", prec, space);\n\tseq_printf(m, \"#                            %.*s||| /     delay\\n\", prec, space);\n\tseq_printf(m, \"#           TASK-PID  %.*s CPU#  ||||   TIMESTAMP  FUNCTION\\n\", prec, \"     TGID   \");\n\tseq_printf(m, \"#              | |    %.*s   |   ||||      |         |\\n\", prec, \"       |    \");\n}\n\nvoid\nprint_trace_header(struct seq_file *m, struct trace_iterator *iter)\n{\n\tunsigned long sym_flags = (global_trace.trace_flags & TRACE_ITER_SYM_MASK);\n\tstruct array_buffer *buf = iter->array_buffer;\n\tstruct trace_array_cpu *data = per_cpu_ptr(buf->data, buf->cpu);\n\tstruct tracer *type = iter->trace;\n\tunsigned long entries;\n\tunsigned long total;\n\tconst char *name = \"preemption\";\n\n\tname = type->name;\n\n\tget_total_entries(buf, &total, &entries);\n\n\tseq_printf(m, \"# %s latency trace v1.1.5 on %s\\n\",\n\t\t   name, UTS_RELEASE);\n\tseq_puts(m, \"# -----------------------------------\"\n\t\t \"---------------------------------\\n\");\n\tseq_printf(m, \"# latency: %lu us, #%lu/%lu, CPU#%d |\"\n\t\t   \" (M:%s VP:%d, KP:%d, SP:%d HP:%d\",\n\t\t   nsecs_to_usecs(data->saved_latency),\n\t\t   entries,\n\t\t   total,\n\t\t   buf->cpu,\n#if defined(CONFIG_PREEMPT_NONE)\n\t\t   \"server\",\n#elif defined(CONFIG_PREEMPT_VOLUNTARY)\n\t\t   \"desktop\",\n#elif defined(CONFIG_PREEMPT)\n\t\t   \"preempt\",\n#elif defined(CONFIG_PREEMPT_RT)\n\t\t   \"preempt_rt\",\n#else\n\t\t   \"unknown\",\n#endif\n\t\t   /* These are reserved for later use */\n\t\t   0, 0, 0, 0);\n#ifdef CONFIG_SMP\n\tseq_printf(m, \" #P:%d)\\n\", num_online_cpus());\n#else\n\tseq_puts(m, \")\\n\");\n#endif\n\tseq_puts(m, \"#    -----------------\\n\");\n\tseq_printf(m, \"#    | task: %.16s-%d \"\n\t\t   \"(uid:%d nice:%ld policy:%ld rt_prio:%ld)\\n\",\n\t\t   data->comm, data->pid,\n\t\t   from_kuid_munged(seq_user_ns(m), data->uid), data->nice,\n\t\t   data->policy, data->rt_priority);\n\tseq_puts(m, \"#    -----------------\\n\");\n\n\tif (data->critical_start) {\n\t\tseq_puts(m, \"#  => started at: \");\n\t\tseq_print_ip_sym(&iter->seq, data->critical_start, sym_flags);\n\t\ttrace_print_seq(m, &iter->seq);\n\t\tseq_puts(m, \"\\n#  => ended at:   \");\n\t\tseq_print_ip_sym(&iter->seq, data->critical_end, sym_flags);\n\t\ttrace_print_seq(m, &iter->seq);\n\t\tseq_puts(m, \"\\n#\\n\");\n\t}\n\n\tseq_puts(m, \"#\\n\");\n}\n\nstatic void test_cpu_buff_start(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (!(tr->trace_flags & TRACE_ITER_ANNOTATE))\n\t\treturn;\n\n\tif (!(iter->iter_flags & TRACE_FILE_ANNOTATE))\n\t\treturn;\n\n\tif (cpumask_available(iter->started) &&\n\t    cpumask_test_cpu(iter->cpu, iter->started))\n\t\treturn;\n\n\tif (per_cpu_ptr(iter->array_buffer->data, iter->cpu)->skipped_entries)\n\t\treturn;\n\n\tif (cpumask_available(iter->started))\n\t\tcpumask_set_cpu(iter->cpu, iter->started);\n\n\t/* Don't print started cpu buffer for the first entry of the trace */\n\tif (iter->idx > 1)\n\t\ttrace_seq_printf(s, \"##### CPU %u buffer started ####\\n\",\n\t\t\t\titer->cpu);\n}\n\nstatic enum print_line_t print_trace_fmt(struct trace_iterator *iter)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tunsigned long sym_flags = (tr->trace_flags & TRACE_ITER_SYM_MASK);\n\tstruct trace_entry *entry;\n\tstruct trace_event *event;\n\n\tentry = iter->ent;\n\n\ttest_cpu_buff_start(iter);\n\n\tevent = ftrace_find_event(entry->type);\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\tif (iter->iter_flags & TRACE_FILE_LAT_FMT)\n\t\t\ttrace_print_lat_context(iter);\n\t\telse\n\t\t\ttrace_print_context(iter);\n\t}\n\n\tif (trace_seq_has_overflowed(s))\n\t\treturn TRACE_TYPE_PARTIAL_LINE;\n\n\tif (event)\n\t\treturn event->funcs->trace(iter, sym_flags, event);\n\n\ttrace_seq_printf(s, \"Unknown type %d\\n\", entry->type);\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t print_raw_fmt(struct trace_iterator *iter)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry;\n\tstruct trace_event *event;\n\n\tentry = iter->ent;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO)\n\t\ttrace_seq_printf(s, \"%d %d %llu \",\n\t\t\t\t entry->pid, iter->cpu, iter->ts);\n\n\tif (trace_seq_has_overflowed(s))\n\t\treturn TRACE_TYPE_PARTIAL_LINE;\n\n\tevent = ftrace_find_event(entry->type);\n\tif (event)\n\t\treturn event->funcs->raw(iter, 0, event);\n\n\ttrace_seq_printf(s, \"%d ?\\n\", entry->type);\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t print_hex_fmt(struct trace_iterator *iter)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tunsigned char newline = '\\n';\n\tstruct trace_entry *entry;\n\tstruct trace_event *event;\n\n\tentry = iter->ent;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\tSEQ_PUT_HEX_FIELD(s, entry->pid);\n\t\tSEQ_PUT_HEX_FIELD(s, iter->cpu);\n\t\tSEQ_PUT_HEX_FIELD(s, iter->ts);\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\treturn TRACE_TYPE_PARTIAL_LINE;\n\t}\n\n\tevent = ftrace_find_event(entry->type);\n\tif (event) {\n\t\tenum print_line_t ret = event->funcs->hex(iter, 0, event);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t}\n\n\tSEQ_PUT_FIELD(s, newline);\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t print_bin_fmt(struct trace_iterator *iter)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry;\n\tstruct trace_event *event;\n\n\tentry = iter->ent;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\tSEQ_PUT_FIELD(s, entry->pid);\n\t\tSEQ_PUT_FIELD(s, iter->cpu);\n\t\tSEQ_PUT_FIELD(s, iter->ts);\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\treturn TRACE_TYPE_PARTIAL_LINE;\n\t}\n\n\tevent = ftrace_find_event(entry->type);\n\treturn event ? event->funcs->binary(iter, 0, event) :\n\t\tTRACE_TYPE_HANDLED;\n}\n\nint trace_empty(struct trace_iterator *iter)\n{\n\tstruct ring_buffer_iter *buf_iter;\n\tint cpu;\n\n\t/* If we are looking at one CPU buffer, only check that one */\n\tif (iter->cpu_file != RING_BUFFER_ALL_CPUS) {\n\t\tcpu = iter->cpu_file;\n\t\tbuf_iter = trace_buffer_iter(iter, cpu);\n\t\tif (buf_iter) {\n\t\t\tif (!ring_buffer_iter_empty(buf_iter))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!ring_buffer_empty_cpu(iter->array_buffer->buffer, cpu))\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tbuf_iter = trace_buffer_iter(iter, cpu);\n\t\tif (buf_iter) {\n\t\t\tif (!ring_buffer_iter_empty(buf_iter))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!ring_buffer_empty_cpu(iter->array_buffer->buffer, cpu))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n/*  Called with trace_event_read_lock() held. */\nenum print_line_t print_trace_line(struct trace_iterator *iter)\n{\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long trace_flags = tr->trace_flags;\n\tenum print_line_t ret;\n\n\tif (iter->lost_events) {\n\t\tif (iter->lost_events == (unsigned long)-1)\n\t\t\ttrace_seq_printf(&iter->seq, \"CPU:%d [LOST EVENTS]\\n\",\n\t\t\t\t\t iter->cpu);\n\t\telse\n\t\t\ttrace_seq_printf(&iter->seq, \"CPU:%d [LOST %lu EVENTS]\\n\",\n\t\t\t\t\t iter->cpu, iter->lost_events);\n\t\tif (trace_seq_has_overflowed(&iter->seq))\n\t\t\treturn TRACE_TYPE_PARTIAL_LINE;\n\t}\n\n\tif (iter->trace && iter->trace->print_line) {\n\t\tret = iter->trace->print_line(iter);\n\t\tif (ret != TRACE_TYPE_UNHANDLED)\n\t\t\treturn ret;\n\t}\n\n\tif (iter->ent->type == TRACE_BPUTS &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK_MSGONLY)\n\t\treturn trace_print_bputs_msg_only(iter);\n\n\tif (iter->ent->type == TRACE_BPRINT &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK_MSGONLY)\n\t\treturn trace_print_bprintk_msg_only(iter);\n\n\tif (iter->ent->type == TRACE_PRINT &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK &&\n\t\t\ttrace_flags & TRACE_ITER_PRINTK_MSGONLY)\n\t\treturn trace_print_printk_msg_only(iter);\n\n\tif (trace_flags & TRACE_ITER_BIN)\n\t\treturn print_bin_fmt(iter);\n\n\tif (trace_flags & TRACE_ITER_HEX)\n\t\treturn print_hex_fmt(iter);\n\n\tif (trace_flags & TRACE_ITER_RAW)\n\t\treturn print_raw_fmt(iter);\n\n\treturn print_trace_fmt(iter);\n}\n\nvoid trace_latency_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\n\t/* print nothing if the buffers are empty */\n\tif (trace_empty(iter))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT)\n\t\tprint_trace_header(m, iter);\n\n\tif (!(tr->trace_flags & TRACE_ITER_VERBOSE))\n\t\tprint_lat_help_header(m);\n}\n\nvoid trace_default_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long trace_flags = tr->trace_flags;\n\n\tif (!(trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (iter->iter_flags & TRACE_FILE_LAT_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\t\tprint_trace_header(m, iter);\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE))\n\t\t\tprint_lat_help_header(m);\n\t} else {\n\t\tif (!(trace_flags & TRACE_ITER_VERBOSE)) {\n\t\t\tif (trace_flags & TRACE_ITER_IRQ_INFO)\n\t\t\t\tprint_func_help_header_irq(iter->array_buffer,\n\t\t\t\t\t\t\t   m, trace_flags);\n\t\t\telse\n\t\t\t\tprint_func_help_header(iter->array_buffer, m,\n\t\t\t\t\t\t       trace_flags);\n\t\t}\n\t}\n}\n\nstatic void test_ftrace_alive(struct seq_file *m)\n{\n\tif (!ftrace_is_dead())\n\t\treturn;\n\tseq_puts(m, \"# WARNING: FUNCTION TRACING IS CORRUPTED\\n\"\n\t\t    \"#          MAY BE MISSING FUNCTION EVENTS\\n\");\n}\n\n#ifdef CONFIG_TRACER_MAX_TRACE\nstatic void show_snapshot_main_help(struct seq_file *m)\n{\n\tseq_puts(m, \"# echo 0 > snapshot : Clears and frees snapshot buffer\\n\"\n\t\t    \"# echo 1 > snapshot : Allocates snapshot buffer, if not already allocated.\\n\"\n\t\t    \"#                      Takes a snapshot of the main buffer.\\n\"\n\t\t    \"# echo 2 > snapshot : Clears snapshot buffer (but does not allocate or free)\\n\"\n\t\t    \"#                      (Doesn't have to be '2' works with any number that\\n\"\n\t\t    \"#                       is not a '0' or '1')\\n\");\n}\n\nstatic void show_snapshot_percpu_help(struct seq_file *m)\n{\n\tseq_puts(m, \"# echo 0 > snapshot : Invalid for per_cpu snapshot file.\\n\");\n#ifdef CONFIG_RING_BUFFER_ALLOW_SWAP\n\tseq_puts(m, \"# echo 1 > snapshot : Allocates snapshot buffer, if not already allocated.\\n\"\n\t\t    \"#                      Takes a snapshot of the main buffer for this cpu.\\n\");\n#else\n\tseq_puts(m, \"# echo 1 > snapshot : Not supported with this kernel.\\n\"\n\t\t    \"#                     Must use main snapshot file to allocate.\\n\");\n#endif\n\tseq_puts(m, \"# echo 2 > snapshot : Clears this cpu's snapshot buffer (but does not allocate)\\n\"\n\t\t    \"#                      (Doesn't have to be '2' works with any number that\\n\"\n\t\t    \"#                       is not a '0' or '1')\\n\");\n}\n\nstatic void print_snapshot_help(struct seq_file *m, struct trace_iterator *iter)\n{\n\tif (iter->tr->allocated_snapshot)\n\t\tseq_puts(m, \"#\\n# * Snapshot is allocated *\\n#\\n\");\n\telse\n\t\tseq_puts(m, \"#\\n# * Snapshot is freed *\\n#\\n\");\n\n\tseq_puts(m, \"# Snapshot commands:\\n\");\n\tif (iter->cpu_file == RING_BUFFER_ALL_CPUS)\n\t\tshow_snapshot_main_help(m);\n\telse\n\t\tshow_snapshot_percpu_help(m);\n}\n#else\n/* Should never be called */\nstatic inline void print_snapshot_help(struct seq_file *m, struct trace_iterator *iter) { }\n#endif\n\nstatic int s_show(struct seq_file *m, void *v)\n{\n\tstruct trace_iterator *iter = v;\n\tint ret;\n\n\tif (iter->ent == NULL) {\n\t\tif (iter->tr) {\n\t\t\tseq_printf(m, \"# tracer: %s\\n\", iter->trace->name);\n\t\t\tseq_puts(m, \"#\\n\");\n\t\t\ttest_ftrace_alive(m);\n\t\t}\n\t\tif (iter->snapshot && trace_empty(iter))\n\t\t\tprint_snapshot_help(m, iter);\n\t\telse if (iter->trace && iter->trace->print_header)\n\t\t\titer->trace->print_header(m);\n\t\telse\n\t\t\ttrace_default_header(m);\n\n\t} else if (iter->leftover) {\n\t\t/*\n\t\t * If we filled the seq_file buffer earlier, we\n\t\t * want to just show it now.\n\t\t */\n\t\tret = trace_print_seq(m, &iter->seq);\n\n\t\t/* ret should this time be zero, but you never know */\n\t\titer->leftover = ret;\n\n\t} else {\n\t\tprint_trace_line(iter);\n\t\tret = trace_print_seq(m, &iter->seq);\n\t\t/*\n\t\t * If we overflow the seq_file buffer, then it will\n\t\t * ask us for this data again at start up.\n\t\t * Use that instead.\n\t\t *  ret is 0 if seq_file write succeeded.\n\t\t *        -1 otherwise.\n\t\t */\n\t\titer->leftover = ret;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Should be used after trace_array_get(), trace_types_lock\n * ensures that i_cdev was already initialized.\n */\nstatic inline int tracing_get_cpu(struct inode *inode)\n{\n\tif (inode->i_cdev) /* See trace_create_cpu_file() */\n\t\treturn (long)inode->i_cdev - 1;\n\treturn RING_BUFFER_ALL_CPUS;\n}\n\nstatic const struct seq_operations tracer_seq_ops = {\n\t.start\t\t= s_start,\n\t.next\t\t= s_next,\n\t.stop\t\t= s_stop,\n\t.show\t\t= s_show,\n};\n\nstatic struct trace_iterator *\n__tracing_open(struct inode *inode, struct file *file, bool snapshot)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct trace_iterator *iter;\n\tint cpu;\n\n\tif (tracing_disabled)\n\t\treturn ERR_PTR(-ENODEV);\n\n\titer = __seq_open_private(file, &tracer_seq_ops, sizeof(*iter));\n\tif (!iter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\titer->buffer_iter = kcalloc(nr_cpu_ids, sizeof(*iter->buffer_iter),\n\t\t\t\t    GFP_KERNEL);\n\tif (!iter->buffer_iter)\n\t\tgoto release;\n\n\t/*\n\t * trace_find_next_entry() may need to save off iter->ent.\n\t * It will place it into the iter->temp buffer. As most\n\t * events are less than 128, allocate a buffer of that size.\n\t * If one is greater, then trace_find_next_entry() will\n\t * allocate a new buffer to adjust for the bigger iter->ent.\n\t * It's not critical if it fails to get allocated here.\n\t */\n\titer->temp = kmalloc(128, GFP_KERNEL);\n\tif (iter->temp)\n\t\titer->temp_size = 128;\n\n\t/*\n\t * We make a copy of the current tracer to avoid concurrent\n\t * changes on it while we are reading.\n\t */\n\tmutex_lock(&trace_types_lock);\n\titer->trace = kzalloc(sizeof(*iter->trace), GFP_KERNEL);\n\tif (!iter->trace)\n\t\tgoto fail;\n\n\t*iter->trace = *tr->current_trace;\n\n\tif (!zalloc_cpumask_var(&iter->started, GFP_KERNEL))\n\t\tgoto fail;\n\n\titer->tr = tr;\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t/* Currently only the top directory has a snapshot */\n\tif (tr->current_trace->print_max || snapshot)\n\t\titer->array_buffer = &tr->max_buffer;\n\telse\n#endif\n\t\titer->array_buffer = &tr->array_buffer;\n\titer->snapshot = snapshot;\n\titer->pos = -1;\n\titer->cpu_file = tracing_get_cpu(inode);\n\tmutex_init(&iter->mutex);\n\n\t/* Notify the tracer early; before we stop tracing. */\n\tif (iter->trace->open)\n\t\titer->trace->open(iter);\n\n\t/* Annotate start of buffers if we had overruns */\n\tif (ring_buffer_overruns(iter->array_buffer->buffer))\n\t\titer->iter_flags |= TRACE_FILE_ANNOTATE;\n\n\t/* Output in nanoseconds only if we are using a clock in nanoseconds. */\n\tif (trace_clocks[tr->clock_id].in_ns)\n\t\titer->iter_flags |= TRACE_FILE_TIME_IN_NS;\n\n\t/*\n\t * If pause-on-trace is enabled, then stop the trace while\n\t * dumping, unless this is the \"snapshot\" file\n\t */\n\tif (!iter->snapshot && (tr->trace_flags & TRACE_ITER_PAUSE_ON_TRACE))\n\t\ttracing_stop_tr(tr);\n\n\tif (iter->cpu_file == RING_BUFFER_ALL_CPUS) {\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\titer->buffer_iter[cpu] =\n\t\t\t\tring_buffer_read_prepare(iter->array_buffer->buffer,\n\t\t\t\t\t\t\t cpu, GFP_KERNEL);\n\t\t}\n\t\tring_buffer_read_prepare_sync();\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\tring_buffer_read_start(iter->buffer_iter[cpu]);\n\t\t\ttracing_iter_reset(iter, cpu);\n\t\t}\n\t} else {\n\t\tcpu = iter->cpu_file;\n\t\titer->buffer_iter[cpu] =\n\t\t\tring_buffer_read_prepare(iter->array_buffer->buffer,\n\t\t\t\t\t\t cpu, GFP_KERNEL);\n\t\tring_buffer_read_prepare_sync();\n\t\tring_buffer_read_start(iter->buffer_iter[cpu]);\n\t\ttracing_iter_reset(iter, cpu);\n\t}\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn iter;\n\n fail:\n\tmutex_unlock(&trace_types_lock);\n\tkfree(iter->trace);\n\tkfree(iter->temp);\n\tkfree(iter->buffer_iter);\nrelease:\n\tseq_release_private(inode, file);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nint tracing_open_generic(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tret = tracing_check_open_get_tr(NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tfilp->private_data = inode->i_private;\n\treturn 0;\n}\n\nbool tracing_is_disabled(void)\n{\n\treturn (tracing_disabled) ? true: false;\n}\n\n/*\n * Open and update trace_array ref count.\n * Must have the current trace_array passed to it.\n */\nint tracing_open_generic_tr(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tfilp->private_data = inode->i_private;\n\n\treturn 0;\n}\n\nstatic int tracing_release(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct seq_file *m = file->private_data;\n\tstruct trace_iterator *iter;\n\tint cpu;\n\n\tif (!(file->f_mode & FMODE_READ)) {\n\t\ttrace_array_put(tr);\n\t\treturn 0;\n\t}\n\n\t/* Writes do not use seq_file */\n\titer = m->private;\n\tmutex_lock(&trace_types_lock);\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tif (iter->buffer_iter[cpu])\n\t\t\tring_buffer_read_finish(iter->buffer_iter[cpu]);\n\t}\n\n\tif (iter->trace && iter->trace->close)\n\t\titer->trace->close(iter);\n\n\tif (!iter->snapshot && tr->stop_count)\n\t\t/* reenable tracing if it was previously enabled */\n\t\ttracing_start_tr(tr);\n\n\t__trace_array_put(tr);\n\n\tmutex_unlock(&trace_types_lock);\n\n\tmutex_destroy(&iter->mutex);\n\tfree_cpumask_var(iter->started);\n\tkfree(iter->temp);\n\tkfree(iter->trace);\n\tkfree(iter->buffer_iter);\n\tseq_release_private(inode, file);\n\n\treturn 0;\n}\n\nstatic int tracing_release_generic_tr(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\treturn 0;\n}\n\nstatic int tracing_single_release_tr(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\n\treturn single_release(inode, file);\n}\n\nstatic int tracing_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct trace_iterator *iter;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\t/* If this file was open for write, then erase contents */\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tint cpu = tracing_get_cpu(inode);\n\t\tstruct array_buffer *trace_buf = &tr->array_buffer;\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\tif (tr->current_trace->print_max)\n\t\t\ttrace_buf = &tr->max_buffer;\n#endif\n\n\t\tif (cpu == RING_BUFFER_ALL_CPUS)\n\t\t\ttracing_reset_online_cpus(trace_buf);\n\t\telse\n\t\t\ttracing_reset_cpu(trace_buf, cpu);\n\t}\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer = __tracing_open(inode, file, false);\n\t\tif (IS_ERR(iter))\n\t\t\tret = PTR_ERR(iter);\n\t\telse if (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\t\titer->iter_flags |= TRACE_FILE_LAT_FMT;\n\t}\n\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\n\treturn ret;\n}\n\n/*\n * Some tracers are not suitable for instance buffers.\n * A tracer is always available for the global array (toplevel)\n * or if it explicitly states that it is.\n */\nstatic bool\ntrace_ok_for_array(struct tracer *t, struct trace_array *tr)\n{\n\treturn (tr->flags & TRACE_ARRAY_FL_GLOBAL) || t->allow_instances;\n}\n\n/* Find the next tracer that this trace array may use */\nstatic struct tracer *\nget_tracer_for_array(struct trace_array *tr, struct tracer *t)\n{\n\twhile (t && !trace_ok_for_array(t, tr))\n\t\tt = t->next;\n\n\treturn t;\n}\n\nstatic void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct tracer *t = v;\n\n\t(*pos)++;\n\n\tif (t)\n\t\tt = get_tracer_for_array(tr, t->next);\n\n\treturn t;\n}\n\nstatic void *t_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct tracer *t;\n\tloff_t l = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tt = get_tracer_for_array(tr, trace_types);\n\tfor (; t && l < *pos; t = t_next(m, t, &l))\n\t\t\t;\n\n\treturn t;\n}\n\nstatic void t_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&trace_types_lock);\n}\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tstruct tracer *t = v;\n\n\tif (!t)\n\t\treturn 0;\n\n\tseq_puts(m, t->name);\n\tif (t->next)\n\t\tseq_putc(m, ' ');\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}\n\nstatic const struct seq_operations show_traces_seq_ops = {\n\t.start\t\t= t_start,\n\t.next\t\t= t_next,\n\t.stop\t\t= t_stop,\n\t.show\t\t= t_show,\n};\n\nstatic int show_traces_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = seq_open(file, &show_traces_seq_ops);\n\tif (ret) {\n\t\ttrace_array_put(tr);\n\t\treturn ret;\n\t}\n\n\tm = file->private_data;\n\tm->private = tr;\n\n\treturn 0;\n}\n\nstatic int show_traces_release(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\treturn seq_release(inode, file);\n}\n\nstatic ssize_t\ntracing_write_stub(struct file *filp, const char __user *ubuf,\n\t\t   size_t count, loff_t *ppos)\n{\n\treturn count;\n}\n\nloff_t tracing_lseek(struct file *file, loff_t offset, int whence)\n{\n\tint ret;\n\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 0;\n\n\treturn ret;\n}\n\nstatic const struct file_operations tracing_fops = {\n\t.open\t\t= tracing_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= tracing_write_stub,\n\t.llseek\t\t= tracing_lseek,\n\t.release\t= tracing_release,\n};\n\nstatic const struct file_operations show_traces_fops = {\n\t.open\t\t= show_traces_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= show_traces_release,\n};\n\nstatic ssize_t\ntracing_cpumask_read(struct file *filp, char __user *ubuf,\n\t\t     size_t count, loff_t *ppos)\n{\n\tstruct trace_array *tr = file_inode(filp)->i_private;\n\tchar *mask_str;\n\tint len;\n\n\tlen = snprintf(NULL, 0, \"%*pb\\n\",\n\t\t       cpumask_pr_args(tr->tracing_cpumask)) + 1;\n\tmask_str = kmalloc(len, GFP_KERNEL);\n\tif (!mask_str)\n\t\treturn -ENOMEM;\n\n\tlen = snprintf(mask_str, len, \"%*pb\\n\",\n\t\t       cpumask_pr_args(tr->tracing_cpumask));\n\tif (len >= count) {\n\t\tcount = -EINVAL;\n\t\tgoto out_err;\n\t}\n\tcount = simple_read_from_buffer(ubuf, count, ppos, mask_str, len);\n\nout_err:\n\tkfree(mask_str);\n\n\treturn count;\n}\n\nint tracing_set_cpumask(struct trace_array *tr,\n\t\t\tcpumask_var_t tracing_cpumask_new)\n{\n\tint cpu;\n\n\tif (!tr)\n\t\treturn -EINVAL;\n\n\tlocal_irq_disable();\n\tarch_spin_lock(&tr->max_lock);\n\tfor_each_tracing_cpu(cpu) {\n\t\t/*\n\t\t * Increase/decrease the disabled counter if we are\n\t\t * about to flip a bit in the cpumask:\n\t\t */\n\t\tif (cpumask_test_cpu(cpu, tr->tracing_cpumask) &&\n\t\t\t\t!cpumask_test_cpu(cpu, tracing_cpumask_new)) {\n\t\t\tatomic_inc(&per_cpu_ptr(tr->array_buffer.data, cpu)->disabled);\n\t\t\tring_buffer_record_disable_cpu(tr->array_buffer.buffer, cpu);\n\t\t}\n\t\tif (!cpumask_test_cpu(cpu, tr->tracing_cpumask) &&\n\t\t\t\tcpumask_test_cpu(cpu, tracing_cpumask_new)) {\n\t\t\tatomic_dec(&per_cpu_ptr(tr->array_buffer.data, cpu)->disabled);\n\t\t\tring_buffer_record_enable_cpu(tr->array_buffer.buffer, cpu);\n\t\t}\n\t}\n\tarch_spin_unlock(&tr->max_lock);\n\tlocal_irq_enable();\n\n\tcpumask_copy(tr->tracing_cpumask, tracing_cpumask_new);\n\n\treturn 0;\n}\n\nstatic ssize_t\ntracing_cpumask_write(struct file *filp, const char __user *ubuf,\n\t\t      size_t count, loff_t *ppos)\n{\n\tstruct trace_array *tr = file_inode(filp)->i_private;\n\tcpumask_var_t tracing_cpumask_new;\n\tint err;\n\n\tif (!alloc_cpumask_var(&tracing_cpumask_new, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\terr = cpumask_parse_user(ubuf, count, tracing_cpumask_new);\n\tif (err)\n\t\tgoto err_free;\n\n\terr = tracing_set_cpumask(tr, tracing_cpumask_new);\n\tif (err)\n\t\tgoto err_free;\n\n\tfree_cpumask_var(tracing_cpumask_new);\n\n\treturn count;\n\nerr_free:\n\tfree_cpumask_var(tracing_cpumask_new);\n\n\treturn err;\n}\n\nstatic const struct file_operations tracing_cpumask_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.read\t\t= tracing_cpumask_read,\n\t.write\t\t= tracing_cpumask_write,\n\t.release\t= tracing_release_generic_tr,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int tracing_trace_options_show(struct seq_file *m, void *v)\n{\n\tstruct tracer_opt *trace_opts;\n\tstruct trace_array *tr = m->private;\n\tu32 tracer_flags;\n\tint i;\n\n\tmutex_lock(&trace_types_lock);\n\ttracer_flags = tr->current_trace->flags->val;\n\ttrace_opts = tr->current_trace->flags->opts;\n\n\tfor (i = 0; trace_options[i]; i++) {\n\t\tif (tr->trace_flags & (1 << i))\n\t\t\tseq_printf(m, \"%s\\n\", trace_options[i]);\n\t\telse\n\t\t\tseq_printf(m, \"no%s\\n\", trace_options[i]);\n\t}\n\n\tfor (i = 0; trace_opts[i].name; i++) {\n\t\tif (tracer_flags & trace_opts[i].bit)\n\t\t\tseq_printf(m, \"%s\\n\", trace_opts[i].name);\n\t\telse\n\t\t\tseq_printf(m, \"no%s\\n\", trace_opts[i].name);\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n}\n\nstatic int __set_tracer_option(struct trace_array *tr,\n\t\t\t       struct tracer_flags *tracer_flags,\n\t\t\t       struct tracer_opt *opts, int neg)\n{\n\tstruct tracer *trace = tracer_flags->trace;\n\tint ret;\n\n\tret = trace->set_flag(tr, tracer_flags->val, opts->bit, !neg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (neg)\n\t\ttracer_flags->val &= ~opts->bit;\n\telse\n\t\ttracer_flags->val |= opts->bit;\n\treturn 0;\n}\n\n/* Try to assign a tracer specific option */\nstatic int set_tracer_option(struct trace_array *tr, char *cmp, int neg)\n{\n\tstruct tracer *trace = tr->current_trace;\n\tstruct tracer_flags *tracer_flags = trace->flags;\n\tstruct tracer_opt *opts = NULL;\n\tint i;\n\n\tfor (i = 0; tracer_flags->opts[i].name; i++) {\n\t\topts = &tracer_flags->opts[i];\n\n\t\tif (strcmp(cmp, opts->name) == 0)\n\t\t\treturn __set_tracer_option(tr, trace->flags, opts, neg);\n\t}\n\n\treturn -EINVAL;\n}\n\n/* Some tracers require overwrite to stay enabled */\nint trace_keep_overwrite(struct tracer *tracer, u32 mask, int set)\n{\n\tif (tracer->enabled && (mask & TRACE_ITER_OVERWRITE) && !set)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint set_tracer_flag(struct trace_array *tr, unsigned int mask, int enabled)\n{\n\tif ((mask == TRACE_ITER_RECORD_TGID) ||\n\t    (mask == TRACE_ITER_RECORD_CMD))\n\t\tlockdep_assert_held(&event_mutex);\n\n\t/* do nothing if flag is already set */\n\tif (!!(tr->trace_flags & mask) == !!enabled)\n\t\treturn 0;\n\n\t/* Give the tracer a chance to approve the change */\n\tif (tr->current_trace->flag_changed)\n\t\tif (tr->current_trace->flag_changed(tr, mask, !!enabled))\n\t\t\treturn -EINVAL;\n\n\tif (enabled)\n\t\ttr->trace_flags |= mask;\n\telse\n\t\ttr->trace_flags &= ~mask;\n\n\tif (mask == TRACE_ITER_RECORD_CMD)\n\t\ttrace_event_enable_cmd_record(enabled);\n\n\tif (mask == TRACE_ITER_RECORD_TGID) {\n\t\tif (!tgid_map)\n\t\t\ttgid_map = kvcalloc(PID_MAX_DEFAULT + 1,\n\t\t\t\t\t   sizeof(*tgid_map),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!tgid_map) {\n\t\t\ttr->trace_flags &= ~TRACE_ITER_RECORD_TGID;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttrace_event_enable_tgid_record(enabled);\n\t}\n\n\tif (mask == TRACE_ITER_EVENT_FORK)\n\t\ttrace_event_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_FUNC_FORK)\n\t\tftrace_pid_follow_fork(tr, enabled);\n\n\tif (mask == TRACE_ITER_OVERWRITE) {\n\t\tring_buffer_change_overwrite(tr->array_buffer.buffer, enabled);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\tring_buffer_change_overwrite(tr->max_buffer.buffer, enabled);\n#endif\n\t}\n\n\tif (mask == TRACE_ITER_PRINTK) {\n\t\ttrace_printk_start_stop_comm(enabled);\n\t\ttrace_printk_control(enabled);\n\t}\n\n\treturn 0;\n}\n\nint trace_set_options(struct trace_array *tr, char *option)\n{\n\tchar *cmp;\n\tint neg = 0;\n\tint ret;\n\tsize_t orig_len = strlen(option);\n\tint len;\n\n\tcmp = strstrip(option);\n\n\tlen = str_has_prefix(cmp, \"no\");\n\tif (len)\n\t\tneg = 1;\n\n\tcmp += len;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tret = match_string(trace_options, -1, cmp);\n\t/* If no option could be set, test the specific tracer options */\n\tif (ret < 0)\n\t\tret = set_tracer_option(tr, cmp, neg);\n\telse\n\t\tret = set_tracer_flag(tr, 1 << ret, !neg);\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\t/*\n\t * If the first trailing whitespace is replaced with '\\0' by strstrip,\n\t * turn it back into a space.\n\t */\n\tif (orig_len > strlen(option))\n\t\toption[strlen(option)] = ' ';\n\n\treturn ret;\n}\n\nstatic void __init apply_trace_boot_options(void)\n{\n\tchar *buf = trace_boot_options_buf;\n\tchar *option;\n\n\twhile (true) {\n\t\toption = strsep(&buf, \",\");\n\n\t\tif (!option)\n\t\t\tbreak;\n\n\t\tif (*option)\n\t\t\ttrace_set_options(&global_trace, option);\n\n\t\t/* Put back the comma to allow this to be called again */\n\t\tif (buf)\n\t\t\t*(buf - 1) = ',';\n\t}\n}\n\nstatic ssize_t\ntracing_trace_options_write(struct file *filp, const char __user *ubuf,\n\t\t\tsize_t cnt, loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tchar buf[64];\n\tint ret;\n\n\tif (cnt >= sizeof(buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, ubuf, cnt))\n\t\treturn -EFAULT;\n\n\tbuf[cnt] = 0;\n\n\tret = trace_set_options(tr, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic int tracing_trace_options_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = single_open(file, tracing_trace_options_show, inode->i_private);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\n\treturn ret;\n}\n\nstatic const struct file_operations tracing_iter_fops = {\n\t.open\t\t= tracing_trace_options_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= tracing_single_release_tr,\n\t.write\t\t= tracing_trace_options_write,\n};\n\nstatic const char readme_msg[] =\n\t\"tracing mini-HOWTO:\\n\\n\"\n\t\"# echo 0 > tracing_on : quick way to disable tracing\\n\"\n\t\"# echo 1 > tracing_on : quick way to re-enable tracing\\n\\n\"\n\t\" Important files:\\n\"\n\t\"  trace\\t\\t\\t- The static contents of the buffer\\n\"\n\t\"\\t\\t\\t  To clear the buffer write into this file: echo > trace\\n\"\n\t\"  trace_pipe\\t\\t- A consuming read to see the contents of the buffer\\n\"\n\t\"  current_tracer\\t- function and latency tracers\\n\"\n\t\"  available_tracers\\t- list of configured tracers for current_tracer\\n\"\n\t\"  error_log\\t- error log for failed commands (that support it)\\n\"\n\t\"  buffer_size_kb\\t- view and modify size of per cpu buffer\\n\"\n\t\"  buffer_total_size_kb  - view total size of all cpu buffers\\n\\n\"\n\t\"  trace_clock\\t\\t-change the clock used to order events\\n\"\n\t\"       local:   Per cpu clock but may not be synced across CPUs\\n\"\n\t\"      global:   Synced across CPUs but slows tracing down.\\n\"\n\t\"     counter:   Not a clock, but just an increment\\n\"\n\t\"      uptime:   Jiffy counter from time of boot\\n\"\n\t\"        perf:   Same clock that perf events use\\n\"\n#ifdef CONFIG_X86_64\n\t\"     x86-tsc:   TSC cycle counter\\n\"\n#endif\n\t\"\\n  timestamp_mode\\t-view the mode used to timestamp events\\n\"\n\t\"       delta:   Delta difference against a buffer-wide timestamp\\n\"\n\t\"    absolute:   Absolute (standalone) timestamp\\n\"\n\t\"\\n  trace_marker\\t\\t- Writes into this file writes into the kernel buffer\\n\"\n\t\"\\n  trace_marker_raw\\t\\t- Writes into this file writes binary data into the kernel buffer\\n\"\n\t\"  tracing_cpumask\\t- Limit which CPUs to trace\\n\"\n\t\"  instances\\t\\t- Make sub-buffers with: mkdir instances/foo\\n\"\n\t\"\\t\\t\\t  Remove sub-buffer with rmdir\\n\"\n\t\"  trace_options\\t\\t- Set format or modify how tracing happens\\n\"\n\t\"\\t\\t\\t  Disable an option by prefixing 'no' to the\\n\"\n\t\"\\t\\t\\t  option name\\n\"\n\t\"  saved_cmdlines_size\\t- echo command number in here to store comm-pid list\\n\"\n#ifdef CONFIG_DYNAMIC_FTRACE\n\t\"\\n  available_filter_functions - list of functions that can be filtered on\\n\"\n\t\"  set_ftrace_filter\\t- echo function name in here to only trace these\\n\"\n\t\"\\t\\t\\t  functions\\n\"\n\t\"\\t     accepts: func_full_name or glob-matching-pattern\\n\"\n\t\"\\t     modules: Can select a group via module\\n\"\n\t\"\\t      Format: :mod:<module-name>\\n\"\n\t\"\\t     example: echo :mod:ext3 > set_ftrace_filter\\n\"\n\t\"\\t    triggers: a command to perform when function is hit\\n\"\n\t\"\\t      Format: <function>:<trigger>[:count]\\n\"\n\t\"\\t     trigger: traceon, traceoff\\n\"\n\t\"\\t\\t      enable_event:<system>:<event>\\n\"\n\t\"\\t\\t      disable_event:<system>:<event>\\n\"\n#ifdef CONFIG_STACKTRACE\n\t\"\\t\\t      stacktrace\\n\"\n#endif\n#ifdef CONFIG_TRACER_SNAPSHOT\n\t\"\\t\\t      snapshot\\n\"\n#endif\n\t\"\\t\\t      dump\\n\"\n\t\"\\t\\t      cpudump\\n\"\n\t\"\\t     example: echo do_fault:traceoff > set_ftrace_filter\\n\"\n\t\"\\t              echo do_trap:traceoff:3 > set_ftrace_filter\\n\"\n\t\"\\t     The first one will disable tracing every time do_fault is hit\\n\"\n\t\"\\t     The second will disable tracing at most 3 times when do_trap is hit\\n\"\n\t\"\\t       The first time do trap is hit and it disables tracing, the\\n\"\n\t\"\\t       counter will decrement to 2. If tracing is already disabled,\\n\"\n\t\"\\t       the counter will not decrement. It only decrements when the\\n\"\n\t\"\\t       trigger did work\\n\"\n\t\"\\t     To remove trigger without count:\\n\"\n\t\"\\t       echo '!<function>:<trigger> > set_ftrace_filter\\n\"\n\t\"\\t     To remove trigger with a count:\\n\"\n\t\"\\t       echo '!<function>:<trigger>:0 > set_ftrace_filter\\n\"\n\t\"  set_ftrace_notrace\\t- echo function name in here to never trace.\\n\"\n\t\"\\t    accepts: func_full_name, *func_end, func_begin*, *func_middle*\\n\"\n\t\"\\t    modules: Can select a group via module command :mod:\\n\"\n\t\"\\t    Does not accept triggers\\n\"\n#endif /* CONFIG_DYNAMIC_FTRACE */\n#ifdef CONFIG_FUNCTION_TRACER\n\t\"  set_ftrace_pid\\t- Write pid(s) to only function trace those pids\\n\"\n\t\"\\t\\t    (function)\\n\"\n\t\"  set_ftrace_notrace_pid\\t- Write pid(s) to not function trace those pids\\n\"\n\t\"\\t\\t    (function)\\n\"\n#endif\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\t\"  set_graph_function\\t- Trace the nested calls of a function (function_graph)\\n\"\n\t\"  set_graph_notrace\\t- Do not trace the nested calls of a function (function_graph)\\n\"\n\t\"  max_graph_depth\\t- Trace a limited depth of nested calls (0 is unlimited)\\n\"\n#endif\n#ifdef CONFIG_TRACER_SNAPSHOT\n\t\"\\n  snapshot\\t\\t- Like 'trace' but shows the content of the static\\n\"\n\t\"\\t\\t\\t  snapshot buffer. Read the contents for more\\n\"\n\t\"\\t\\t\\t  information\\n\"\n#endif\n#ifdef CONFIG_STACK_TRACER\n\t\"  stack_trace\\t\\t- Shows the max stack trace when active\\n\"\n\t\"  stack_max_size\\t- Shows current max stack size that was traced\\n\"\n\t\"\\t\\t\\t  Write into this file to reset the max size (trigger a\\n\"\n\t\"\\t\\t\\t  new trace)\\n\"\n#ifdef CONFIG_DYNAMIC_FTRACE\n\t\"  stack_trace_filter\\t- Like set_ftrace_filter but limits what stack_trace\\n\"\n\t\"\\t\\t\\t  traces\\n\"\n#endif\n#endif /* CONFIG_STACK_TRACER */\n#ifdef CONFIG_DYNAMIC_EVENTS\n\t\"  dynamic_events\\t\\t- Create/append/remove/show the generic dynamic events\\n\"\n\t\"\\t\\t\\t  Write into this file to define/undefine new trace events.\\n\"\n#endif\n#ifdef CONFIG_KPROBE_EVENTS\n\t\"  kprobe_events\\t\\t- Create/append/remove/show the kernel dynamic events\\n\"\n\t\"\\t\\t\\t  Write into this file to define/undefine new trace events.\\n\"\n#endif\n#ifdef CONFIG_UPROBE_EVENTS\n\t\"  uprobe_events\\t\\t- Create/append/remove/show the userspace dynamic events\\n\"\n\t\"\\t\\t\\t  Write into this file to define/undefine new trace events.\\n\"\n#endif\n#if defined(CONFIG_KPROBE_EVENTS) || defined(CONFIG_UPROBE_EVENTS)\n\t\"\\t  accepts: event-definitions (one definition per line)\\n\"\n\t\"\\t   Format: p[:[<group>/]<event>] <place> [<args>]\\n\"\n\t\"\\t           r[maxactive][:[<group>/]<event>] <place> [<args>]\\n\"\n#ifdef CONFIG_HIST_TRIGGERS\n\t\"\\t           s:[synthetic/]<event> <field> [<field>]\\n\"\n#endif\n\t\"\\t           -:[<group>/]<event>\\n\"\n#ifdef CONFIG_KPROBE_EVENTS\n\t\"\\t    place: [<module>:]<symbol>[+<offset>]|<memaddr>\\n\"\n  \"place (kretprobe): [<module>:]<symbol>[+<offset>]%return|<memaddr>\\n\"\n#endif\n#ifdef CONFIG_UPROBE_EVENTS\n  \"   place (uprobe): <path>:<offset>[%return][(ref_ctr_offset)]\\n\"\n#endif\n\t\"\\t     args: <name>=fetcharg[:type]\\n\"\n\t\"\\t fetcharg: %<register>, @<address>, @<symbol>[+|-<offset>],\\n\"\n#ifdef CONFIG_HAVE_FUNCTION_ARG_ACCESS_API\n\t\"\\t           $stack<index>, $stack, $retval, $comm, $arg<N>,\\n\"\n#else\n\t\"\\t           $stack<index>, $stack, $retval, $comm,\\n\"\n#endif\n\t\"\\t           +|-[u]<offset>(<fetcharg>), \\\\imm-value, \\\\\\\"imm-string\\\"\\n\"\n\t\"\\t     type: s8/16/32/64, u8/16/32/64, x8/16/32/64, string, symbol,\\n\"\n\t\"\\t           b<bit-width>@<bit-offset>/<container-size>, ustring,\\n\"\n\t\"\\t           <type>\\\\[<array-size>\\\\]\\n\"\n#ifdef CONFIG_HIST_TRIGGERS\n\t\"\\t    field: <stype> <name>;\\n\"\n\t\"\\t    stype: u8/u16/u32/u64, s8/s16/s32/s64, pid_t,\\n\"\n\t\"\\t           [unsigned] char/int/long\\n\"\n#endif\n#endif\n\t\"  events/\\t\\t- Directory containing all trace event subsystems:\\n\"\n\t\"      enable\\t\\t- Write 0/1 to enable/disable tracing of all events\\n\"\n\t\"  events/<system>/\\t- Directory containing all trace events for <system>:\\n\"\n\t\"      enable\\t\\t- Write 0/1 to enable/disable tracing of all <system>\\n\"\n\t\"\\t\\t\\t  events\\n\"\n\t\"      filter\\t\\t- If set, only events passing filter are traced\\n\"\n\t\"  events/<system>/<event>/\\t- Directory containing control files for\\n\"\n\t\"\\t\\t\\t  <event>:\\n\"\n\t\"      enable\\t\\t- Write 0/1 to enable/disable tracing of <event>\\n\"\n\t\"      filter\\t\\t- If set, only events passing filter are traced\\n\"\n\t\"      trigger\\t\\t- If set, a command to perform when event is hit\\n\"\n\t\"\\t    Format: <trigger>[:count][if <filter>]\\n\"\n\t\"\\t   trigger: traceon, traceoff\\n\"\n\t\"\\t            enable_event:<system>:<event>\\n\"\n\t\"\\t            disable_event:<system>:<event>\\n\"\n#ifdef CONFIG_HIST_TRIGGERS\n\t\"\\t            enable_hist:<system>:<event>\\n\"\n\t\"\\t            disable_hist:<system>:<event>\\n\"\n#endif\n#ifdef CONFIG_STACKTRACE\n\t\"\\t\\t    stacktrace\\n\"\n#endif\n#ifdef CONFIG_TRACER_SNAPSHOT\n\t\"\\t\\t    snapshot\\n\"\n#endif\n#ifdef CONFIG_HIST_TRIGGERS\n\t\"\\t\\t    hist (see below)\\n\"\n#endif\n\t\"\\t   example: echo traceoff > events/block/block_unplug/trigger\\n\"\n\t\"\\t            echo traceoff:3 > events/block/block_unplug/trigger\\n\"\n\t\"\\t            echo 'enable_event:kmem:kmalloc:3 if nr_rq > 1' > \\\\\\n\"\n\t\"\\t                  events/block/block_unplug/trigger\\n\"\n\t\"\\t   The first disables tracing every time block_unplug is hit.\\n\"\n\t\"\\t   The second disables tracing the first 3 times block_unplug is hit.\\n\"\n\t\"\\t   The third enables the kmalloc event the first 3 times block_unplug\\n\"\n\t\"\\t     is hit and has value of greater than 1 for the 'nr_rq' event field.\\n\"\n\t\"\\t   Like function triggers, the counter is only decremented if it\\n\"\n\t\"\\t    enabled or disabled tracing.\\n\"\n\t\"\\t   To remove a trigger without a count:\\n\"\n\t\"\\t     echo '!<trigger> > <system>/<event>/trigger\\n\"\n\t\"\\t   To remove a trigger with a count:\\n\"\n\t\"\\t     echo '!<trigger>:0 > <system>/<event>/trigger\\n\"\n\t\"\\t   Filters can be ignored when removing a trigger.\\n\"\n#ifdef CONFIG_HIST_TRIGGERS\n\t\"      hist trigger\\t- If set, event hits are aggregated into a hash table\\n\"\n\t\"\\t    Format: hist:keys=<field1[,field2,...]>\\n\"\n\t\"\\t            [:values=<field1[,field2,...]>]\\n\"\n\t\"\\t            [:sort=<field1[,field2,...]>]\\n\"\n\t\"\\t            [:size=#entries]\\n\"\n\t\"\\t            [:pause][:continue][:clear]\\n\"\n\t\"\\t            [:name=histname1]\\n\"\n\t\"\\t            [:<handler>.<action>]\\n\"\n\t\"\\t            [if <filter>]\\n\\n\"\n\t\"\\t    When a matching event is hit, an entry is added to a hash\\n\"\n\t\"\\t    table using the key(s) and value(s) named, and the value of a\\n\"\n\t\"\\t    sum called 'hitcount' is incremented.  Keys and values\\n\"\n\t\"\\t    correspond to fields in the event's format description.  Keys\\n\"\n\t\"\\t    can be any field, or the special string 'stacktrace'.\\n\"\n\t\"\\t    Compound keys consisting of up to two fields can be specified\\n\"\n\t\"\\t    by the 'keys' keyword.  Values must correspond to numeric\\n\"\n\t\"\\t    fields.  Sort keys consisting of up to two fields can be\\n\"\n\t\"\\t    specified using the 'sort' keyword.  The sort direction can\\n\"\n\t\"\\t    be modified by appending '.descending' or '.ascending' to a\\n\"\n\t\"\\t    sort field.  The 'size' parameter can be used to specify more\\n\"\n\t\"\\t    or fewer than the default 2048 entries for the hashtable size.\\n\"\n\t\"\\t    If a hist trigger is given a name using the 'name' parameter,\\n\"\n\t\"\\t    its histogram data will be shared with other triggers of the\\n\"\n\t\"\\t    same name, and trigger hits will update this common data.\\n\\n\"\n\t\"\\t    Reading the 'hist' file for the event will dump the hash\\n\"\n\t\"\\t    table in its entirety to stdout.  If there are multiple hist\\n\"\n\t\"\\t    triggers attached to an event, there will be a table for each\\n\"\n\t\"\\t    trigger in the output.  The table displayed for a named\\n\"\n\t\"\\t    trigger will be the same as any other instance having the\\n\"\n\t\"\\t    same name.  The default format used to display a given field\\n\"\n\t\"\\t    can be modified by appending any of the following modifiers\\n\"\n\t\"\\t    to the field name, as applicable:\\n\\n\"\n\t\"\\t            .hex        display a number as a hex value\\n\"\n\t\"\\t            .sym        display an address as a symbol\\n\"\n\t\"\\t            .sym-offset display an address as a symbol and offset\\n\"\n\t\"\\t            .execname   display a common_pid as a program name\\n\"\n\t\"\\t            .syscall    display a syscall id as a syscall name\\n\"\n\t\"\\t            .log2       display log2 value rather than raw number\\n\"\n\t\"\\t            .usecs      display a common_timestamp in microseconds\\n\\n\"\n\t\"\\t    The 'pause' parameter can be used to pause an existing hist\\n\"\n\t\"\\t    trigger or to start a hist trigger but not log any events\\n\"\n\t\"\\t    until told to do so.  'continue' can be used to start or\\n\"\n\t\"\\t    restart a paused hist trigger.\\n\\n\"\n\t\"\\t    The 'clear' parameter will clear the contents of a running\\n\"\n\t\"\\t    hist trigger and leave its current paused/active state\\n\"\n\t\"\\t    unchanged.\\n\\n\"\n\t\"\\t    The enable_hist and disable_hist triggers can be used to\\n\"\n\t\"\\t    have one event conditionally start and stop another event's\\n\"\n\t\"\\t    already-attached hist trigger.  The syntax is analogous to\\n\"\n\t\"\\t    the enable_event and disable_event triggers.\\n\\n\"\n\t\"\\t    Hist trigger handlers and actions are executed whenever a\\n\"\n\t\"\\t    a histogram entry is added or updated.  They take the form:\\n\\n\"\n\t\"\\t        <handler>.<action>\\n\\n\"\n\t\"\\t    The available handlers are:\\n\\n\"\n\t\"\\t        onmatch(matching.event)  - invoke on addition or update\\n\"\n\t\"\\t        onmax(var)               - invoke if var exceeds current max\\n\"\n\t\"\\t        onchange(var)            - invoke action if var changes\\n\\n\"\n\t\"\\t    The available actions are:\\n\\n\"\n\t\"\\t        trace(<synthetic_event>,param list)  - generate synthetic event\\n\"\n\t\"\\t        save(field,...)                      - save current event fields\\n\"\n#ifdef CONFIG_TRACER_SNAPSHOT\n\t\"\\t        snapshot()                           - snapshot the trace buffer\\n\\n\"\n#endif\n#ifdef CONFIG_SYNTH_EVENTS\n\t\"  events/synthetic_events\\t- Create/append/remove/show synthetic events\\n\"\n\t\"\\t  Write into this file to define/undefine new synthetic events.\\n\"\n\t\"\\t     example: echo 'myevent u64 lat; char name[]' >> synthetic_events\\n\"\n#endif\n#endif\n;\n\nstatic ssize_t\ntracing_readme_read(struct file *filp, char __user *ubuf,\n\t\t       size_t cnt, loff_t *ppos)\n{\n\treturn simple_read_from_buffer(ubuf, cnt, ppos,\n\t\t\t\t\treadme_msg, strlen(readme_msg));\n}\n\nstatic const struct file_operations tracing_readme_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_readme_read,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic void *saved_tgids_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tint *ptr = v;\n\n\tif (*pos || m->count)\n\t\tptr++;\n\n\t(*pos)++;\n\n\tfor (; ptr <= &tgid_map[PID_MAX_DEFAULT]; ptr++) {\n\t\tif (trace_find_tgid(*ptr))\n\t\t\treturn ptr;\n\t}\n\n\treturn NULL;\n}\n\nstatic void *saved_tgids_start(struct seq_file *m, loff_t *pos)\n{\n\tvoid *v;\n\tloff_t l = 0;\n\n\tif (!tgid_map)\n\t\treturn NULL;\n\n\tv = &tgid_map[0];\n\twhile (l <= *pos) {\n\t\tv = saved_tgids_next(m, v, &l);\n\t\tif (!v)\n\t\t\treturn NULL;\n\t}\n\n\treturn v;\n}\n\nstatic void saved_tgids_stop(struct seq_file *m, void *v)\n{\n}\n\nstatic int saved_tgids_show(struct seq_file *m, void *v)\n{\n\tint pid = (int *)v - tgid_map;\n\n\tseq_printf(m, \"%d %d\\n\", pid, trace_find_tgid(pid));\n\treturn 0;\n}\n\nstatic const struct seq_operations tracing_saved_tgids_seq_ops = {\n\t.start\t\t= saved_tgids_start,\n\t.stop\t\t= saved_tgids_stop,\n\t.next\t\t= saved_tgids_next,\n\t.show\t\t= saved_tgids_show,\n};\n\nstatic int tracing_saved_tgids_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tret = tracing_check_open_get_tr(NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn seq_open(filp, &tracing_saved_tgids_seq_ops);\n}\n\n\nstatic const struct file_operations tracing_saved_tgids_fops = {\n\t.open\t\t= tracing_saved_tgids_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic void *saved_cmdlines_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tunsigned int *ptr = v;\n\n\tif (*pos || m->count)\n\t\tptr++;\n\n\t(*pos)++;\n\n\tfor (; ptr < &savedcmd->map_cmdline_to_pid[savedcmd->cmdline_num];\n\t     ptr++) {\n\t\tif (*ptr == -1 || *ptr == NO_CMDLINE_MAP)\n\t\t\tcontinue;\n\n\t\treturn ptr;\n\t}\n\n\treturn NULL;\n}\n\nstatic void *saved_cmdlines_start(struct seq_file *m, loff_t *pos)\n{\n\tvoid *v;\n\tloff_t l = 0;\n\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\tv = &savedcmd->map_cmdline_to_pid[0];\n\twhile (l <= *pos) {\n\t\tv = saved_cmdlines_next(m, v, &l);\n\t\tif (!v)\n\t\t\treturn NULL;\n\t}\n\n\treturn v;\n}\n\nstatic void saved_cmdlines_stop(struct seq_file *m, void *v)\n{\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}\n\nstatic int saved_cmdlines_show(struct seq_file *m, void *v)\n{\n\tchar buf[TASK_COMM_LEN];\n\tunsigned int *pid = v;\n\n\t__trace_find_cmdline(*pid, buf);\n\tseq_printf(m, \"%d %s\\n\", *pid, buf);\n\treturn 0;\n}\n\nstatic const struct seq_operations tracing_saved_cmdlines_seq_ops = {\n\t.start\t\t= saved_cmdlines_start,\n\t.next\t\t= saved_cmdlines_next,\n\t.stop\t\t= saved_cmdlines_stop,\n\t.show\t\t= saved_cmdlines_show,\n};\n\nstatic int tracing_saved_cmdlines_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tret = tracing_check_open_get_tr(NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn seq_open(filp, &tracing_saved_cmdlines_seq_ops);\n}\n\nstatic const struct file_operations tracing_saved_cmdlines_fops = {\n\t.open\t\t= tracing_saved_cmdlines_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic ssize_t\ntracing_saved_cmdlines_size_read(struct file *filp, char __user *ubuf,\n\t\t\t\t size_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\n\tint r;\n\n\tarch_spin_lock(&trace_cmdline_lock);\n\tr = scnprintf(buf, sizeof(buf), \"%u\\n\", savedcmd->cmdline_num);\n\tarch_spin_unlock(&trace_cmdline_lock);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nstatic void free_saved_cmdlines_buffer(struct saved_cmdlines_buffer *s)\n{\n\tkfree(s->saved_cmdlines);\n\tkfree(s->map_cmdline_to_pid);\n\tkfree(s);\n}\n\nstatic int tracing_resize_saved_cmdlines(unsigned int val)\n{\n\tstruct saved_cmdlines_buffer *s, *savedcmd_temp;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tif (allocate_cmdlines_buffer(val, s) < 0) {\n\t\tkfree(s);\n\t\treturn -ENOMEM;\n\t}\n\n\tarch_spin_lock(&trace_cmdline_lock);\n\tsavedcmd_temp = savedcmd;\n\tsavedcmd = s;\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tfree_saved_cmdlines_buffer(savedcmd_temp);\n\n\treturn 0;\n}\n\nstatic ssize_t\ntracing_saved_cmdlines_size_write(struct file *filp, const char __user *ubuf,\n\t\t\t\t  size_t cnt, loff_t *ppos)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t/* must have at least 1 entry or less than PID_MAX_DEFAULT */\n\tif (!val || val > PID_MAX_DEFAULT)\n\t\treturn -EINVAL;\n\n\tret = tracing_resize_saved_cmdlines((unsigned int)val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic const struct file_operations tracing_saved_cmdlines_size_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_saved_cmdlines_size_read,\n\t.write\t\t= tracing_saved_cmdlines_size_write,\n};\n\n#ifdef CONFIG_TRACE_EVAL_MAP_FILE\nstatic union trace_eval_map_item *\nupdate_eval_map(union trace_eval_map_item *ptr)\n{\n\tif (!ptr->map.eval_string) {\n\t\tif (ptr->tail.next) {\n\t\t\tptr = ptr->tail.next;\n\t\t\t/* Set ptr to the next real item (skip head) */\n\t\t\tptr++;\n\t\t} else\n\t\t\treturn NULL;\n\t}\n\treturn ptr;\n}\n\nstatic void *eval_map_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tunion trace_eval_map_item *ptr = v;\n\n\t/*\n\t * Paranoid! If ptr points to end, we don't want to increment past it.\n\t * This really should never happen.\n\t */\n\t(*pos)++;\n\tptr = update_eval_map(ptr);\n\tif (WARN_ON_ONCE(!ptr))\n\t\treturn NULL;\n\n\tptr++;\n\tptr = update_eval_map(ptr);\n\n\treturn ptr;\n}\n\nstatic void *eval_map_start(struct seq_file *m, loff_t *pos)\n{\n\tunion trace_eval_map_item *v;\n\tloff_t l = 0;\n\n\tmutex_lock(&trace_eval_mutex);\n\n\tv = trace_eval_maps;\n\tif (v)\n\t\tv++;\n\n\twhile (v && l < *pos) {\n\t\tv = eval_map_next(m, v, &l);\n\t}\n\n\treturn v;\n}\n\nstatic void eval_map_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&trace_eval_mutex);\n}\n\nstatic int eval_map_show(struct seq_file *m, void *v)\n{\n\tunion trace_eval_map_item *ptr = v;\n\n\tseq_printf(m, \"%s %ld (%s)\\n\",\n\t\t   ptr->map.eval_string, ptr->map.eval_value,\n\t\t   ptr->map.system);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations tracing_eval_map_seq_ops = {\n\t.start\t\t= eval_map_start,\n\t.next\t\t= eval_map_next,\n\t.stop\t\t= eval_map_stop,\n\t.show\t\t= eval_map_show,\n};\n\nstatic int tracing_eval_map_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tret = tracing_check_open_get_tr(NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn seq_open(filp, &tracing_eval_map_seq_ops);\n}\n\nstatic const struct file_operations tracing_eval_map_fops = {\n\t.open\t\t= tracing_eval_map_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic inline union trace_eval_map_item *\ntrace_eval_jmp_to_tail(union trace_eval_map_item *ptr)\n{\n\t/* Return tail of array given the head */\n\treturn ptr + ptr->head.length + 1;\n}\n\nstatic void\ntrace_insert_eval_map_file(struct module *mod, struct trace_eval_map **start,\n\t\t\t   int len)\n{\n\tstruct trace_eval_map **stop;\n\tstruct trace_eval_map **map;\n\tunion trace_eval_map_item *map_array;\n\tunion trace_eval_map_item *ptr;\n\n\tstop = start + len;\n\n\t/*\n\t * The trace_eval_maps contains the map plus a head and tail item,\n\t * where the head holds the module and length of array, and the\n\t * tail holds a pointer to the next list.\n\t */\n\tmap_array = kmalloc_array(len + 2, sizeof(*map_array), GFP_KERNEL);\n\tif (!map_array) {\n\t\tpr_warn(\"Unable to allocate trace eval mapping\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&trace_eval_mutex);\n\n\tif (!trace_eval_maps)\n\t\ttrace_eval_maps = map_array;\n\telse {\n\t\tptr = trace_eval_maps;\n\t\tfor (;;) {\n\t\t\tptr = trace_eval_jmp_to_tail(ptr);\n\t\t\tif (!ptr->tail.next)\n\t\t\t\tbreak;\n\t\t\tptr = ptr->tail.next;\n\n\t\t}\n\t\tptr->tail.next = map_array;\n\t}\n\tmap_array->head.mod = mod;\n\tmap_array->head.length = len;\n\tmap_array++;\n\n\tfor (map = start; (unsigned long)map < (unsigned long)stop; map++) {\n\t\tmap_array->map = **map;\n\t\tmap_array++;\n\t}\n\tmemset(map_array, 0, sizeof(*map_array));\n\n\tmutex_unlock(&trace_eval_mutex);\n}\n\nstatic void trace_create_eval_file(struct dentry *d_tracer)\n{\n\ttrace_create_file(\"eval_map\", 0444, d_tracer,\n\t\t\t  NULL, &tracing_eval_map_fops);\n}\n\n#else /* CONFIG_TRACE_EVAL_MAP_FILE */\nstatic inline void trace_create_eval_file(struct dentry *d_tracer) { }\nstatic inline void trace_insert_eval_map_file(struct module *mod,\n\t\t\t      struct trace_eval_map **start, int len) { }\n#endif /* !CONFIG_TRACE_EVAL_MAP_FILE */\n\nstatic void trace_insert_eval_map(struct module *mod,\n\t\t\t\t  struct trace_eval_map **start, int len)\n{\n\tstruct trace_eval_map **map;\n\n\tif (len <= 0)\n\t\treturn;\n\n\tmap = start;\n\n\ttrace_event_eval_update(map, len);\n\n\ttrace_insert_eval_map_file(mod, start, len);\n}\n\nstatic ssize_t\ntracing_set_trace_read(struct file *filp, char __user *ubuf,\n\t\t       size_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tchar buf[MAX_TRACER_SIZE+2];\n\tint r;\n\n\tmutex_lock(&trace_types_lock);\n\tr = sprintf(buf, \"%s\\n\", tr->current_trace->name);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nint tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\treturn t->init(tr);\n}\n\nstatic void set_buffer_entries(struct array_buffer *buf, unsigned long val)\n{\n\tint cpu;\n\n\tfor_each_tracing_cpu(cpu)\n\t\tper_cpu_ptr(buf->data, cpu)->entries = val;\n}\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n/* resize @tr's buffer to the size of @size_tr's entries */\nstatic int resize_buffer_duplicate_size(struct array_buffer *trace_buf,\n\t\t\t\t\tstruct array_buffer *size_buf, int cpu_id)\n{\n\tint cpu, ret = 0;\n\n\tif (cpu_id == RING_BUFFER_ALL_CPUS) {\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\tret = ring_buffer_resize(trace_buf->buffer,\n\t\t\t\t per_cpu_ptr(size_buf->data, cpu)->entries, cpu);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tper_cpu_ptr(trace_buf->data, cpu)->entries =\n\t\t\t\tper_cpu_ptr(size_buf->data, cpu)->entries;\n\t\t}\n\t} else {\n\t\tret = ring_buffer_resize(trace_buf->buffer,\n\t\t\t\t per_cpu_ptr(size_buf->data, cpu_id)->entries, cpu_id);\n\t\tif (ret == 0)\n\t\t\tper_cpu_ptr(trace_buf->data, cpu_id)->entries =\n\t\t\t\tper_cpu_ptr(size_buf->data, cpu_id)->entries;\n\t}\n\n\treturn ret;\n}\n#endif /* CONFIG_TRACER_MAX_TRACE */\n\nstatic int __tracing_resize_ring_buffer(struct trace_array *tr,\n\t\t\t\t\tunsigned long size, int cpu)\n{\n\tint ret;\n\n\t/*\n\t * If kernel or user changes the size of the ring buffer\n\t * we use the size that was given, and we can forget about\n\t * expanding it later.\n\t */\n\tring_buffer_expanded = true;\n\n\t/* May be called before buffers are initialized */\n\tif (!tr->array_buffer.buffer)\n\t\treturn 0;\n\n\tret = ring_buffer_resize(tr->array_buffer.buffer, size, cpu);\n\tif (ret < 0)\n\t\treturn ret;\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (!(tr->flags & TRACE_ARRAY_FL_GLOBAL) ||\n\t    !tr->current_trace->use_max_tr)\n\t\tgoto out;\n\n\tret = ring_buffer_resize(tr->max_buffer.buffer, size, cpu);\n\tif (ret < 0) {\n\t\tint r = resize_buffer_duplicate_size(&tr->array_buffer,\n\t\t\t\t\t\t     &tr->array_buffer, cpu);\n\t\tif (r < 0) {\n\t\t\t/*\n\t\t\t * AARGH! We are left with different\n\t\t\t * size max buffer!!!!\n\t\t\t * The max buffer is our \"snapshot\" buffer.\n\t\t\t * When a tracer needs a snapshot (one of the\n\t\t\t * latency tracers), it swaps the max buffer\n\t\t\t * with the saved snap shot. We succeeded to\n\t\t\t * update the size of the main buffer, but failed to\n\t\t\t * update the size of the max buffer. But when we tried\n\t\t\t * to reset the main buffer to the original size, we\n\t\t\t * failed there too. This is very unlikely to\n\t\t\t * happen, but if it does, warn and kill all\n\t\t\t * tracing.\n\t\t\t */\n\t\t\tWARN_ON(1);\n\t\t\ttracing_disabled = 1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (cpu == RING_BUFFER_ALL_CPUS)\n\t\tset_buffer_entries(&tr->max_buffer, size);\n\telse\n\t\tper_cpu_ptr(tr->max_buffer.data, cpu)->entries = size;\n\n out:\n#endif /* CONFIG_TRACER_MAX_TRACE */\n\n\tif (cpu == RING_BUFFER_ALL_CPUS)\n\t\tset_buffer_entries(&tr->array_buffer, size);\n\telse\n\t\tper_cpu_ptr(tr->array_buffer.data, cpu)->entries = size;\n\n\treturn ret;\n}\n\nssize_t tracing_resize_ring_buffer(struct trace_array *tr,\n\t\t\t\t  unsigned long size, int cpu_id)\n{\n\tint ret = size;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (cpu_id != RING_BUFFER_ALL_CPUS) {\n\t\t/* make sure, this cpu is enabled in the mask */\n\t\tif (!cpumask_test_cpu(cpu_id, tracing_buffer_mask)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = __tracing_resize_ring_buffer(tr, size, cpu_id);\n\tif (ret < 0)\n\t\tret = -ENOMEM;\n\nout:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\n\n/**\n * tracing_update_buffers - used by tracing facility to expand ring buffers\n *\n * To save on memory when the tracing is never used on a system with it\n * configured in. The ring buffers are set to a minimum size. But once\n * a user starts to use the tracing facility, then they need to grow\n * to their default size.\n *\n * This function is to be called when a tracer is about to be used.\n */\nint tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\nstruct trace_option_dentry;\n\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\n/*\n * Used to clear out the tracer before deletion of an instance.\n * Must have trace_types_lock held.\n */\nstatic void tracing_set_nop(struct trace_array *tr)\n{\n\tif (tr->current_trace == &nop_trace)\n\t\treturn;\n\t\n\ttr->current_trace->enabled--;\n\n\tif (tr->current_trace->reset)\n\t\ttr->current_trace->reset(tr);\n\n\ttr->current_trace = &nop_trace;\n}\n\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t)\n{\n\t/* Only enable if the directory has been created already. */\n\tif (!tr->dir)\n\t\treturn;\n\n\tcreate_trace_option_files(tr, t);\n}\n\nint tracing_set_tracer(struct trace_array *tr, const char *buf)\n{\n\tstruct tracer *t;\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbool had_max_tr;\n#endif\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (!ring_buffer_expanded) {\n\t\tret = __tracing_resize_ring_buffer(tr, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(t->name, buf) == 0)\n\t\t\tbreak;\n\t}\n\tif (!t) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (t == tr->current_trace)\n\t\tgoto out;\n\n#ifdef CONFIG_TRACER_SNAPSHOT\n\tif (t->use_max_tr) {\n\t\tarch_spin_lock(&tr->max_lock);\n\t\tif (tr->cond_snapshot)\n\t\t\tret = -EBUSY;\n\t\tarch_spin_unlock(&tr->max_lock);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n#endif\n\t/* Some tracers won't work on kernel command line */\n\tif (system_state < SYSTEM_RUNNING && t->noboot) {\n\t\tpr_warn(\"Tracer '%s' is not allowed on command line, ignored\\n\",\n\t\t\tt->name);\n\t\tgoto out;\n\t}\n\n\t/* Some tracers are only allowed for the top level buffer */\n\tif (!trace_ok_for_array(t, tr)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* If trace pipe files are being read, we can't change the tracer */\n\tif (tr->trace_ref) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\ttrace_branch_disable();\n\n\ttr->current_trace->enabled--;\n\n\tif (tr->current_trace->reset)\n\t\ttr->current_trace->reset(tr);\n\n\t/* Current trace needs to be nop_trace before synchronize_rcu */\n\ttr->current_trace = &nop_trace;\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\thad_max_tr = tr->allocated_snapshot;\n\n\tif (had_max_tr && !t->use_max_tr) {\n\t\t/*\n\t\t * We need to make sure that the update_max_tr sees that\n\t\t * current_trace changed to nop_trace to keep it from\n\t\t * swapping the buffers after we resize it.\n\t\t * The update_max_tr is called from interrupts disabled\n\t\t * so a synchronized_sched() is sufficient.\n\t\t */\n\t\tsynchronize_rcu();\n\t\tfree_snapshot(tr);\n\t}\n#endif\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (t->use_max_tr && !had_max_tr) {\n\t\tret = tracing_alloc_snapshot_instance(tr);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n#endif\n\n\tif (t->init) {\n\t\tret = tracer_init(t, tr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\ttr->current_trace = t;\n\ttr->current_trace->enabled++;\n\ttrace_branch_enable(tr);\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t\ntracing_set_trace_write(struct file *filp, const char __user *ubuf,\n\t\t\tsize_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tchar buf[MAX_TRACER_SIZE+1];\n\tint i;\n\tsize_t ret;\n\tint err;\n\n\tret = cnt;\n\n\tif (cnt > MAX_TRACER_SIZE)\n\t\tcnt = MAX_TRACER_SIZE;\n\n\tif (copy_from_user(buf, ubuf, cnt))\n\t\treturn -EFAULT;\n\n\tbuf[cnt] = 0;\n\n\t/* strip ending whitespace. */\n\tfor (i = cnt - 1; i > 0 && isspace(buf[i]); i--)\n\t\tbuf[i] = 0;\n\n\terr = tracing_set_tracer(tr, buf);\n\tif (err)\n\t\treturn err;\n\n\t*ppos += ret;\n\n\treturn ret;\n}\n\nstatic ssize_t\ntracing_nsecs_read(unsigned long *ptr, char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\n\tint r;\n\n\tr = snprintf(buf, sizeof(buf), \"%ld\\n\",\n\t\t     *ptr == (unsigned long)-1 ? -1 : nsecs_to_usecs(*ptr));\n\tif (r > sizeof(buf))\n\t\tr = sizeof(buf);\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nstatic ssize_t\ntracing_nsecs_write(unsigned long *ptr, const char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t*ptr = val * 1000;\n\n\treturn cnt;\n}\n\nstatic ssize_t\ntracing_thresh_read(struct file *filp, char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\treturn tracing_nsecs_read(&tracing_thresh, ubuf, cnt, ppos);\n}\n\nstatic ssize_t\ntracing_thresh_write(struct file *filp, const char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tint ret;\n\n\tmutex_lock(&trace_types_lock);\n\tret = tracing_nsecs_write(&tracing_thresh, ubuf, cnt, ppos);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (tr->current_trace->update_thresh) {\n\t\tret = tr->current_trace->update_thresh(tr);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = cnt;\nout:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\n#if defined(CONFIG_TRACER_MAX_TRACE) || defined(CONFIG_HWLAT_TRACER)\n\nstatic ssize_t\ntracing_max_lat_read(struct file *filp, char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\treturn tracing_nsecs_read(filp->private_data, ubuf, cnt, ppos);\n}\n\nstatic ssize_t\ntracing_max_lat_write(struct file *filp, const char __user *ubuf,\n\t\t      size_t cnt, loff_t *ppos)\n{\n\treturn tracing_nsecs_write(filp->private_data, ubuf, cnt, ppos);\n}\n\n#endif\n\nstatic int tracing_open_pipe(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct trace_iterator *iter;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&trace_types_lock);\n\n\t/* create a buffer to store the information to pass to userspace */\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter) {\n\t\tret = -ENOMEM;\n\t\t__trace_array_put(tr);\n\t\tgoto out;\n\t}\n\n\ttrace_seq_init(&iter->seq);\n\titer->trace = tr->current_trace;\n\n\tif (!alloc_cpumask_var(&iter->started, GFP_KERNEL)) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t/* trace pipe does not show start of buffer */\n\tcpumask_setall(iter->started);\n\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\titer->iter_flags |= TRACE_FILE_LAT_FMT;\n\n\t/* Output in nanoseconds only if we are using a clock in nanoseconds. */\n\tif (trace_clocks[tr->clock_id].in_ns)\n\t\titer->iter_flags |= TRACE_FILE_TIME_IN_NS;\n\n\titer->tr = tr;\n\titer->array_buffer = &tr->array_buffer;\n\titer->cpu_file = tracing_get_cpu(inode);\n\tmutex_init(&iter->mutex);\n\tfilp->private_data = iter;\n\n\tif (iter->trace->pipe_open)\n\t\titer->trace->pipe_open(iter);\n\n\tnonseekable_open(inode, filp);\n\n\ttr->trace_ref++;\nout:\n\tmutex_unlock(&trace_types_lock);\n\treturn ret;\n\nfail:\n\tkfree(iter);\n\t__trace_array_put(tr);\n\tmutex_unlock(&trace_types_lock);\n\treturn ret;\n}\n\nstatic int tracing_release_pipe(struct inode *inode, struct file *file)\n{\n\tstruct trace_iterator *iter = file->private_data;\n\tstruct trace_array *tr = inode->i_private;\n\n\tmutex_lock(&trace_types_lock);\n\n\ttr->trace_ref--;\n\n\tif (iter->trace->pipe_close)\n\t\titer->trace->pipe_close(iter);\n\n\tmutex_unlock(&trace_types_lock);\n\n\tfree_cpumask_var(iter->started);\n\tmutex_destroy(&iter->mutex);\n\tkfree(iter);\n\n\ttrace_array_put(tr);\n\n\treturn 0;\n}\n\nstatic __poll_t\ntrace_poll(struct trace_iterator *iter, struct file *filp, poll_table *poll_table)\n{\n\tstruct trace_array *tr = iter->tr;\n\n\t/* Iterators are static, they should be filled or empty */\n\tif (trace_buffer_iter(iter, iter->cpu_file))\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\n\tif (tr->trace_flags & TRACE_ITER_BLOCK)\n\t\t/*\n\t\t * Always select as readable when in blocking mode\n\t\t */\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\telse\n\t\treturn ring_buffer_poll_wait(iter->array_buffer->buffer, iter->cpu_file,\n\t\t\t\t\t     filp, poll_table);\n}\n\nstatic __poll_t\ntracing_poll_pipe(struct file *filp, poll_table *poll_table)\n{\n\tstruct trace_iterator *iter = filp->private_data;\n\n\treturn trace_poll(iter, filp, poll_table);\n}\n\n/* Must be called with iter->mutex held. */\nstatic int tracing_wait_pipe(struct file *filp)\n{\n\tstruct trace_iterator *iter = filp->private_data;\n\tint ret;\n\n\twhile (trace_empty(iter)) {\n\n\t\tif ((filp->f_flags & O_NONBLOCK)) {\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\t/*\n\t\t * We block until we read something and tracing is disabled.\n\t\t * We still block if tracing is disabled, but we have never\n\t\t * read anything. This allows a user to cat this file, and\n\t\t * then enable tracing. But after we have read something,\n\t\t * we give an EOF when tracing is again disabled.\n\t\t *\n\t\t * iter->pos will be 0 if we haven't read anything.\n\t\t */\n\t\tif (!tracer_tracing_is_on(iter->tr) && iter->pos)\n\t\t\tbreak;\n\n\t\tmutex_unlock(&iter->mutex);\n\n\t\tret = wait_on_pipe(iter, 0);\n\n\t\tmutex_lock(&iter->mutex);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 1;\n}\n\n/*\n * Consumer reader.\n */\nstatic ssize_t\ntracing_read_pipe(struct file *filp, char __user *ubuf,\n\t\t  size_t cnt, loff_t *ppos)\n{\n\tstruct trace_iterator *iter = filp->private_data;\n\tssize_t sret;\n\n\t/*\n\t * Avoid more than one consumer on a single file descriptor\n\t * This is just a matter of traces coherency, the ring buffer itself\n\t * is protected.\n\t */\n\tmutex_lock(&iter->mutex);\n\n\t/* return any leftover data */\n\tsret = trace_seq_to_user(&iter->seq, ubuf, cnt);\n\tif (sret != -EBUSY)\n\t\tgoto out;\n\n\ttrace_seq_init(&iter->seq);\n\n\tif (iter->trace->read) {\n\t\tsret = iter->trace->read(iter, filp, ubuf, cnt, ppos);\n\t\tif (sret)\n\t\t\tgoto out;\n\t}\n\nwaitagain:\n\tsret = tracing_wait_pipe(filp);\n\tif (sret <= 0)\n\t\tgoto out;\n\n\t/* stop when tracing is finished */\n\tif (trace_empty(iter)) {\n\t\tsret = 0;\n\t\tgoto out;\n\t}\n\n\tif (cnt >= PAGE_SIZE)\n\t\tcnt = PAGE_SIZE - 1;\n\n\t/* reset all but tr, trace, and overruns */\n\tmemset(&iter->seq, 0,\n\t       sizeof(struct trace_iterator) -\n\t       offsetof(struct trace_iterator, seq));\n\tcpumask_clear(iter->started);\n\ttrace_seq_init(&iter->seq);\n\titer->pos = -1;\n\n\ttrace_event_read_lock();\n\ttrace_access_lock(iter->cpu_file);\n\twhile (trace_find_next_entry_inc(iter) != NULL) {\n\t\tenum print_line_t ret;\n\t\tint save_len = iter->seq.seq.len;\n\n\t\tret = print_trace_line(iter);\n\t\tif (ret == TRACE_TYPE_PARTIAL_LINE) {\n\t\t\t/* don't print partial lines */\n\t\t\titer->seq.seq.len = save_len;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret != TRACE_TYPE_NO_CONSUME)\n\t\t\ttrace_consume(iter);\n\n\t\tif (trace_seq_used(&iter->seq) >= cnt)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Setting the full flag means we reached the trace_seq buffer\n\t\t * size and we should leave by partial output condition above.\n\t\t * One of the trace_seq_* functions is not used properly.\n\t\t */\n\t\tWARN_ONCE(iter->seq.full, \"full flag set for trace type %d\",\n\t\t\t  iter->ent->type);\n\t}\n\ttrace_access_unlock(iter->cpu_file);\n\ttrace_event_read_unlock();\n\n\t/* Now copy what we have to the user */\n\tsret = trace_seq_to_user(&iter->seq, ubuf, cnt);\n\tif (iter->seq.seq.readpos >= trace_seq_used(&iter->seq))\n\t\ttrace_seq_init(&iter->seq);\n\n\t/*\n\t * If there was nothing to send to user, in spite of consuming trace\n\t * entries, go back to wait for more entries.\n\t */\n\tif (sret == -EBUSY)\n\t\tgoto waitagain;\n\nout:\n\tmutex_unlock(&iter->mutex);\n\n\treturn sret;\n}\n\nstatic void tracing_spd_release_pipe(struct splice_pipe_desc *spd,\n\t\t\t\t     unsigned int idx)\n{\n\t__free_page(spd->pages[idx]);\n}\n\nstatic size_t\ntracing_fill_pipe_page(size_t rem, struct trace_iterator *iter)\n{\n\tsize_t count;\n\tint save_len;\n\tint ret;\n\n\t/* Seq buffer is page-sized, exactly what we need. */\n\tfor (;;) {\n\t\tsave_len = iter->seq.seq.len;\n\t\tret = print_trace_line(iter);\n\n\t\tif (trace_seq_has_overflowed(&iter->seq)) {\n\t\t\titer->seq.seq.len = save_len;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * This should not be hit, because it should only\n\t\t * be set if the iter->seq overflowed. But check it\n\t\t * anyway to be safe.\n\t\t */\n\t\tif (ret == TRACE_TYPE_PARTIAL_LINE) {\n\t\t\titer->seq.seq.len = save_len;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = trace_seq_used(&iter->seq) - save_len;\n\t\tif (rem < count) {\n\t\t\trem = 0;\n\t\t\titer->seq.seq.len = save_len;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret != TRACE_TYPE_NO_CONSUME)\n\t\t\ttrace_consume(iter);\n\t\trem -= count;\n\t\tif (!trace_find_next_entry_inc(iter))\t{\n\t\t\trem = 0;\n\t\t\titer->ent = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rem;\n}\n\nstatic ssize_t tracing_splice_read_pipe(struct file *filp,\n\t\t\t\t\tloff_t *ppos,\n\t\t\t\t\tstruct pipe_inode_info *pipe,\n\t\t\t\t\tsize_t len,\n\t\t\t\t\tunsigned int flags)\n{\n\tstruct page *pages_def[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial_def[PIPE_DEF_BUFFERS];\n\tstruct trace_iterator *iter = filp->private_data;\n\tstruct splice_pipe_desc spd = {\n\t\t.pages\t\t= pages_def,\n\t\t.partial\t= partial_def,\n\t\t.nr_pages\t= 0, /* This gets updated below. */\n\t\t.nr_pages_max\t= PIPE_DEF_BUFFERS,\n\t\t.ops\t\t= &default_pipe_buf_ops,\n\t\t.spd_release\t= tracing_spd_release_pipe,\n\t};\n\tssize_t ret;\n\tsize_t rem;\n\tunsigned int i;\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&iter->mutex);\n\n\tif (iter->trace->splice_read) {\n\t\tret = iter->trace->splice_read(iter, filp,\n\t\t\t\t\t       ppos, pipe, len, flags);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\t}\n\n\tret = tracing_wait_pipe(filp);\n\tif (ret <= 0)\n\t\tgoto out_err;\n\n\tif (!iter->ent && !trace_find_next_entry_inc(iter)) {\n\t\tret = -EFAULT;\n\t\tgoto out_err;\n\t}\n\n\ttrace_event_read_lock();\n\ttrace_access_lock(iter->cpu_file);\n\n\t/* Fill as many pages as possible. */\n\tfor (i = 0, rem = len; i < spd.nr_pages_max && rem; i++) {\n\t\tspd.pages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!spd.pages[i])\n\t\t\tbreak;\n\n\t\trem = tracing_fill_pipe_page(rem, iter);\n\n\t\t/* Copy the data into the page, so we can start over. */\n\t\tret = trace_seq_to_buffer(&iter->seq,\n\t\t\t\t\t  page_address(spd.pages[i]),\n\t\t\t\t\t  trace_seq_used(&iter->seq));\n\t\tif (ret < 0) {\n\t\t\t__free_page(spd.pages[i]);\n\t\t\tbreak;\n\t\t}\n\t\tspd.partial[i].offset = 0;\n\t\tspd.partial[i].len = trace_seq_used(&iter->seq);\n\n\t\ttrace_seq_init(&iter->seq);\n\t}\n\n\ttrace_access_unlock(iter->cpu_file);\n\ttrace_event_read_unlock();\n\tmutex_unlock(&iter->mutex);\n\n\tspd.nr_pages = i;\n\n\tif (i)\n\t\tret = splice_to_pipe(pipe, &spd);\n\telse\n\t\tret = 0;\nout:\n\tsplice_shrink_spd(&spd);\n\treturn ret;\n\nout_err:\n\tmutex_unlock(&iter->mutex);\n\tgoto out;\n}\n\nstatic ssize_t\ntracing_entries_read(struct file *filp, char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct trace_array *tr = inode->i_private;\n\tint cpu = tracing_get_cpu(inode);\n\tchar buf[64];\n\tint r = 0;\n\tssize_t ret;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (cpu == RING_BUFFER_ALL_CPUS) {\n\t\tint cpu, buf_size_same;\n\t\tunsigned long size;\n\n\t\tsize = 0;\n\t\tbuf_size_same = 1;\n\t\t/* check if all cpu sizes are same */\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\t/* fill in the size from first enabled cpu */\n\t\t\tif (size == 0)\n\t\t\t\tsize = per_cpu_ptr(tr->array_buffer.data, cpu)->entries;\n\t\t\tif (size != per_cpu_ptr(tr->array_buffer.data, cpu)->entries) {\n\t\t\t\tbuf_size_same = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (buf_size_same) {\n\t\t\tif (!ring_buffer_expanded)\n\t\t\t\tr = sprintf(buf, \"%lu (expanded: %lu)\\n\",\n\t\t\t\t\t    size >> 10,\n\t\t\t\t\t    trace_buf_size >> 10);\n\t\t\telse\n\t\t\t\tr = sprintf(buf, \"%lu\\n\", size >> 10);\n\t\t} else\n\t\t\tr = sprintf(buf, \"X\\n\");\n\t} else\n\t\tr = sprintf(buf, \"%lu\\n\", per_cpu_ptr(tr->array_buffer.data, cpu)->entries >> 10);\n\n\tmutex_unlock(&trace_types_lock);\n\n\tret = simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n\treturn ret;\n}\n\nstatic ssize_t\ntracing_entries_write(struct file *filp, const char __user *ubuf,\n\t\t      size_t cnt, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct trace_array *tr = inode->i_private;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t/* must have at least 1 entry */\n\tif (!val)\n\t\treturn -EINVAL;\n\n\t/* value is in KB */\n\tval <<= 10;\n\tret = tracing_resize_ring_buffer(tr, val, tracing_get_cpu(inode));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic ssize_t\ntracing_total_entries_read(struct file *filp, char __user *ubuf,\n\t\t\t\tsize_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tchar buf[64];\n\tint r, cpu;\n\tunsigned long size = 0, expanded_size = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tfor_each_tracing_cpu(cpu) {\n\t\tsize += per_cpu_ptr(tr->array_buffer.data, cpu)->entries >> 10;\n\t\tif (!ring_buffer_expanded)\n\t\t\texpanded_size += trace_buf_size >> 10;\n\t}\n\tif (ring_buffer_expanded)\n\t\tr = sprintf(buf, \"%lu\\n\", size);\n\telse\n\t\tr = sprintf(buf, \"%lu (expanded: %lu)\\n\", size, expanded_size);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nstatic ssize_t\ntracing_free_buffer_write(struct file *filp, const char __user *ubuf,\n\t\t\t  size_t cnt, loff_t *ppos)\n{\n\t/*\n\t * There is no need to read what the user has written, this function\n\t * is just to make sure that there is no error when \"echo\" is used\n\t */\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic int\ntracing_free_buffer_release(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\t/* disable tracing ? */\n\tif (tr->trace_flags & TRACE_ITER_STOP_ON_FREE)\n\t\ttracer_tracing_off(tr);\n\t/* resize the ring buffer to 0 */\n\ttracing_resize_ring_buffer(tr, 0, RING_BUFFER_ALL_CPUS);\n\n\ttrace_array_put(tr);\n\n\treturn 0;\n}\n\nstatic ssize_t\ntracing_mark_write(struct file *filp, const char __user *ubuf,\n\t\t\t\t\tsize_t cnt, loff_t *fpos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tstruct ring_buffer_event *event;\n\tenum event_trigger_type tt = ETT_NONE;\n\tstruct trace_buffer *buffer;\n\tstruct print_entry *entry;\n\tunsigned long irq_flags;\n\tssize_t written;\n\tint size;\n\tint len;\n\n/* Used in tracing_mark_raw_write() as well */\n#define FAULTED_STR \"<faulted>\"\n#define FAULTED_SIZE (sizeof(FAULTED_STR) - 1) /* '\\0' is already accounted for */\n\n\tif (tracing_disabled)\n\t\treturn -EINVAL;\n\n\tif (!(tr->trace_flags & TRACE_ITER_MARKERS))\n\t\treturn -EINVAL;\n\n\tif (cnt > TRACE_BUF_SIZE)\n\t\tcnt = TRACE_BUF_SIZE;\n\n\tBUILD_BUG_ON(TRACE_BUF_SIZE >= PAGE_SIZE);\n\n\tlocal_save_flags(irq_flags);\n\tsize = sizeof(*entry) + cnt + 2; /* add '\\0' and possible '\\n' */\n\n\t/* If less than \"<faulted>\", then make sure we can still add that */\n\tif (cnt < FAULTED_SIZE)\n\t\tsize += FAULTED_SIZE - cnt;\n\n\tbuffer = tr->array_buffer.buffer;\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_PRINT, size,\n\t\t\t\t\t    irq_flags, preempt_count());\n\tif (unlikely(!event))\n\t\t/* Ring buffer disabled, return as if not open for write */\n\t\treturn -EBADF;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->ip = _THIS_IP_;\n\n\tlen = __copy_from_user_inatomic(&entry->buf, ubuf, cnt);\n\tif (len) {\n\t\tmemcpy(&entry->buf, FAULTED_STR, FAULTED_SIZE);\n\t\tcnt = FAULTED_SIZE;\n\t\twritten = -EFAULT;\n\t} else\n\t\twritten = cnt;\n\n\tif (tr->trace_marker_file && !list_empty(&tr->trace_marker_file->triggers)) {\n\t\t/* do not add \\n before testing triggers, but add \\0 */\n\t\tentry->buf[cnt] = '\\0';\n\t\ttt = event_triggers_call(tr->trace_marker_file, entry, event);\n\t}\n\n\tif (entry->buf[cnt - 1] != '\\n') {\n\t\tentry->buf[cnt] = '\\n';\n\t\tentry->buf[cnt + 1] = '\\0';\n\t} else\n\t\tentry->buf[cnt] = '\\0';\n\n\tif (static_branch_unlikely(&trace_marker_exports_enabled))\n\t\tftrace_exports(event, TRACE_EXPORT_MARKER);\n\t__buffer_unlock_commit(buffer, event);\n\n\tif (tt)\n\t\tevent_triggers_post_call(tr->trace_marker_file, tt);\n\n\tif (written > 0)\n\t\t*fpos += written;\n\n\treturn written;\n}\n\n/* Limit it for now to 3K (including tag) */\n#define RAW_DATA_MAX_SIZE (1024*3)\n\nstatic ssize_t\ntracing_mark_raw_write(struct file *filp, const char __user *ubuf,\n\t\t\t\t\tsize_t cnt, loff_t *fpos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tstruct ring_buffer_event *event;\n\tstruct trace_buffer *buffer;\n\tstruct raw_data_entry *entry;\n\tunsigned long irq_flags;\n\tssize_t written;\n\tint size;\n\tint len;\n\n#define FAULT_SIZE_ID (FAULTED_SIZE + sizeof(int))\n\n\tif (tracing_disabled)\n\t\treturn -EINVAL;\n\n\tif (!(tr->trace_flags & TRACE_ITER_MARKERS))\n\t\treturn -EINVAL;\n\n\t/* The marker must at least have a tag id */\n\tif (cnt < sizeof(unsigned int) || cnt > RAW_DATA_MAX_SIZE)\n\t\treturn -EINVAL;\n\n\tif (cnt > TRACE_BUF_SIZE)\n\t\tcnt = TRACE_BUF_SIZE;\n\n\tBUILD_BUG_ON(TRACE_BUF_SIZE >= PAGE_SIZE);\n\n\tlocal_save_flags(irq_flags);\n\tsize = sizeof(*entry) + cnt;\n\tif (cnt < FAULT_SIZE_ID)\n\t\tsize += FAULT_SIZE_ID - cnt;\n\n\tbuffer = tr->array_buffer.buffer;\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_RAW_DATA, size,\n\t\t\t\t\t    irq_flags, preempt_count());\n\tif (!event)\n\t\t/* Ring buffer disabled, return as if not open for write */\n\t\treturn -EBADF;\n\n\tentry = ring_buffer_event_data(event);\n\n\tlen = __copy_from_user_inatomic(&entry->id, ubuf, cnt);\n\tif (len) {\n\t\tentry->id = -1;\n\t\tmemcpy(&entry->buf, FAULTED_STR, FAULTED_SIZE);\n\t\twritten = -EFAULT;\n\t} else\n\t\twritten = cnt;\n\n\t__buffer_unlock_commit(buffer, event);\n\n\tif (written > 0)\n\t\t*fpos += written;\n\n\treturn written;\n}\n\nstatic int tracing_clock_show(struct seq_file *m, void *v)\n{\n\tstruct trace_array *tr = m->private;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(trace_clocks); i++)\n\t\tseq_printf(m,\n\t\t\t\"%s%s%s%s\", i ? \" \" : \"\",\n\t\t\ti == tr->clock_id ? \"[\" : \"\", trace_clocks[i].name,\n\t\t\ti == tr->clock_id ? \"]\" : \"\");\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}\n\nint tracing_set_clock(struct trace_array *tr, const char *clockstr)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(trace_clocks); i++) {\n\t\tif (strcmp(trace_clocks[i].name, clockstr) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(trace_clocks))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&trace_types_lock);\n\n\ttr->clock_id = i;\n\n\tring_buffer_set_clock(tr->array_buffer.buffer, trace_clocks[i].func);\n\n\t/*\n\t * New clock may not be consistent with the previous clock.\n\t * Reset the buffer so that it doesn't have incomparable timestamps.\n\t */\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (tr->max_buffer.buffer)\n\t\tring_buffer_set_clock(tr->max_buffer.buffer, trace_clocks[i].func);\n\ttracing_reset_online_cpus(&tr->max_buffer);\n#endif\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n}\n\nstatic ssize_t tracing_clock_write(struct file *filp, const char __user *ubuf,\n\t\t\t\t   size_t cnt, loff_t *fpos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tchar buf[64];\n\tconst char *clockstr;\n\tint ret;\n\n\tif (cnt >= sizeof(buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, ubuf, cnt))\n\t\treturn -EFAULT;\n\n\tbuf[cnt] = 0;\n\n\tclockstr = strstrip(buf);\n\n\tret = tracing_set_clock(tr, clockstr);\n\tif (ret)\n\t\treturn ret;\n\n\t*fpos += cnt;\n\n\treturn cnt;\n}\n\nstatic int tracing_clock_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = single_open(file, tracing_clock_show, inode->i_private);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\n\treturn ret;\n}\n\nstatic int tracing_time_stamp_mode_show(struct seq_file *m, void *v)\n{\n\tstruct trace_array *tr = m->private;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (ring_buffer_time_stamp_abs(tr->array_buffer.buffer))\n\t\tseq_puts(m, \"delta [absolute]\\n\");\n\telse\n\t\tseq_puts(m, \"[delta] absolute\\n\");\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n}\n\nstatic int tracing_time_stamp_mode_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = single_open(file, tracing_time_stamp_mode_show, inode->i_private);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\n\treturn ret;\n}\n\nint tracing_set_time_stamp_abs(struct trace_array *tr, bool abs)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (abs && tr->time_stamp_abs_ref++)\n\t\tgoto out;\n\n\tif (!abs) {\n\t\tif (WARN_ON_ONCE(!tr->time_stamp_abs_ref)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (--tr->time_stamp_abs_ref)\n\t\t\tgoto out;\n\t}\n\n\tring_buffer_set_time_stamp_abs(tr->array_buffer.buffer, abs);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (tr->max_buffer.buffer)\n\t\tring_buffer_set_time_stamp_abs(tr->max_buffer.buffer, abs);\n#endif\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\nstruct ftrace_buffer_info {\n\tstruct trace_iterator\titer;\n\tvoid\t\t\t*spare;\n\tunsigned int\t\tspare_cpu;\n\tunsigned int\t\tread;\n};\n\n#ifdef CONFIG_TRACER_SNAPSHOT\nstatic int tracing_snapshot_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct trace_iterator *iter;\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (file->f_mode & FMODE_READ) {\n\t\titer = __tracing_open(inode, file, true);\n\t\tif (IS_ERR(iter))\n\t\t\tret = PTR_ERR(iter);\n\t} else {\n\t\t/* Writes still need the seq_file to hold the private data */\n\t\tret = -ENOMEM;\n\t\tm = kzalloc(sizeof(*m), GFP_KERNEL);\n\t\tif (!m)\n\t\t\tgoto out;\n\t\titer = kzalloc(sizeof(*iter), GFP_KERNEL);\n\t\tif (!iter) {\n\t\t\tkfree(m);\n\t\t\tgoto out;\n\t\t}\n\t\tret = 0;\n\n\t\titer->tr = tr;\n\t\titer->array_buffer = &tr->max_buffer;\n\t\titer->cpu_file = tracing_get_cpu(inode);\n\t\tm->private = iter;\n\t\tfile->private_data = m;\n\t}\nout:\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\n\treturn ret;\n}\n\nstatic ssize_t\ntracing_snapshot_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t       loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long val;\n\tint ret;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (tr->current_trace->use_max_tr) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\tif (tr->cond_snapshot)\n\t\tret = -EBUSY;\n\tarch_spin_unlock(&tr->max_lock);\n\tif (ret)\n\t\tgoto out;\n\n\tswitch (val) {\n\tcase 0:\n\t\tif (iter->cpu_file != RING_BUFFER_ALL_CPUS) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (tr->allocated_snapshot)\n\t\t\tfree_snapshot(tr);\n\t\tbreak;\n\tcase 1:\n/* Only allow per-cpu swap if the ring buffer supports it */\n#ifndef CONFIG_RING_BUFFER_ALLOW_SWAP\n\t\tif (iter->cpu_file != RING_BUFFER_ALL_CPUS) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tif (tr->allocated_snapshot)\n\t\t\tret = resize_buffer_duplicate_size(&tr->max_buffer,\n\t\t\t\t\t&tr->array_buffer, iter->cpu_file);\n\t\telse\n\t\t\tret = tracing_alloc_snapshot_instance(tr);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tlocal_irq_disable();\n\t\t/* Now, we're going to swap */\n\t\tif (iter->cpu_file == RING_BUFFER_ALL_CPUS)\n\t\t\tupdate_max_tr(tr, current, smp_processor_id(), NULL);\n\t\telse\n\t\t\tupdate_max_tr_single(tr, current, iter->cpu_file);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\tdefault:\n\t\tif (tr->allocated_snapshot) {\n\t\t\tif (iter->cpu_file == RING_BUFFER_ALL_CPUS)\n\t\t\t\ttracing_reset_online_cpus(&tr->max_buffer);\n\t\t\telse\n\t\t\t\ttracing_reset_cpu(&tr->max_buffer, iter->cpu_file);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (ret >= 0) {\n\t\t*ppos += cnt;\n\t\tret = cnt;\n\t}\nout:\n\tmutex_unlock(&trace_types_lock);\n\treturn ret;\n}\n\nstatic int tracing_snapshot_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tint ret;\n\n\tret = tracing_release(inode, file);\n\n\tif (file->f_mode & FMODE_READ)\n\t\treturn ret;\n\n\t/* If write only, the seq_file is just a stub */\n\tif (m)\n\t\tkfree(m->private);\n\tkfree(m);\n\n\treturn 0;\n}\n\nstatic int tracing_buffers_open(struct inode *inode, struct file *filp);\nstatic ssize_t tracing_buffers_read(struct file *filp, char __user *ubuf,\n\t\t\t\t    size_t count, loff_t *ppos);\nstatic int tracing_buffers_release(struct inode *inode, struct file *file);\nstatic ssize_t tracing_buffers_splice_read(struct file *file, loff_t *ppos,\n\t\t   struct pipe_inode_info *pipe, size_t len, unsigned int flags);\n\nstatic int snapshot_raw_open(struct inode *inode, struct file *filp)\n{\n\tstruct ftrace_buffer_info *info;\n\tint ret;\n\n\t/* The following checks for tracefs lockdown */\n\tret = tracing_buffers_open(inode, filp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinfo = filp->private_data;\n\n\tif (info->iter.trace->use_max_tr) {\n\t\ttracing_buffers_release(inode, filp);\n\t\treturn -EBUSY;\n\t}\n\n\tinfo->iter.snapshot = true;\n\tinfo->iter.array_buffer = &info->iter.tr->max_buffer;\n\n\treturn ret;\n}\n\n#endif /* CONFIG_TRACER_SNAPSHOT */\n\n\nstatic const struct file_operations tracing_thresh_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_thresh_read,\n\t.write\t\t= tracing_thresh_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\n#if defined(CONFIG_TRACER_MAX_TRACE) || defined(CONFIG_HWLAT_TRACER)\nstatic const struct file_operations tracing_max_lat_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_max_lat_read,\n\t.write\t\t= tracing_max_lat_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif\n\nstatic const struct file_operations set_tracer_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_set_trace_read,\n\t.write\t\t= tracing_set_trace_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct file_operations tracing_pipe_fops = {\n\t.open\t\t= tracing_open_pipe,\n\t.poll\t\t= tracing_poll_pipe,\n\t.read\t\t= tracing_read_pipe,\n\t.splice_read\t= tracing_splice_read_pipe,\n\t.release\t= tracing_release_pipe,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic const struct file_operations tracing_entries_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.read\t\t= tracing_entries_read,\n\t.write\t\t= tracing_entries_write,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= tracing_release_generic_tr,\n};\n\nstatic const struct file_operations tracing_total_entries_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.read\t\t= tracing_total_entries_read,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= tracing_release_generic_tr,\n};\n\nstatic const struct file_operations tracing_free_buffer_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.write\t\t= tracing_free_buffer_write,\n\t.release\t= tracing_free_buffer_release,\n};\n\nstatic const struct file_operations tracing_mark_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.write\t\t= tracing_mark_write,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= tracing_release_generic_tr,\n};\n\nstatic const struct file_operations tracing_mark_raw_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.write\t\t= tracing_mark_raw_write,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= tracing_release_generic_tr,\n};\n\nstatic const struct file_operations trace_clock_fops = {\n\t.open\t\t= tracing_clock_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= tracing_single_release_tr,\n\t.write\t\t= tracing_clock_write,\n};\n\nstatic const struct file_operations trace_time_stamp_mode_fops = {\n\t.open\t\t= tracing_time_stamp_mode_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= tracing_single_release_tr,\n};\n\n#ifdef CONFIG_TRACER_SNAPSHOT\nstatic const struct file_operations snapshot_fops = {\n\t.open\t\t= tracing_snapshot_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= tracing_snapshot_write,\n\t.llseek\t\t= tracing_lseek,\n\t.release\t= tracing_snapshot_release,\n};\n\nstatic const struct file_operations snapshot_raw_fops = {\n\t.open\t\t= snapshot_raw_open,\n\t.read\t\t= tracing_buffers_read,\n\t.release\t= tracing_buffers_release,\n\t.splice_read\t= tracing_buffers_splice_read,\n\t.llseek\t\t= no_llseek,\n};\n\n#endif /* CONFIG_TRACER_SNAPSHOT */\n\n#define TRACING_LOG_ERRS_MAX\t8\n#define TRACING_LOG_LOC_MAX\t128\n\n#define CMD_PREFIX \"  Command: \"\n\nstruct err_info {\n\tconst char\t**errs;\t/* ptr to loc-specific array of err strings */\n\tu8\t\ttype;\t/* index into errs -> specific err string */\n\tu8\t\tpos;\t/* MAX_FILTER_STR_VAL = 256 */\n\tu64\t\tts;\n};\n\nstruct tracing_log_err {\n\tstruct list_head\tlist;\n\tstruct err_info\t\tinfo;\n\tchar\t\t\tloc[TRACING_LOG_LOC_MAX]; /* err location */\n\tchar\t\t\tcmd[MAX_FILTER_STR_VAL]; /* what caused err */\n};\n\nstatic DEFINE_MUTEX(tracing_err_log_lock);\n\nstatic struct tracing_log_err *get_tracing_log_err(struct trace_array *tr)\n{\n\tstruct tracing_log_err *err;\n\n\tif (tr->n_err_log_entries < TRACING_LOG_ERRS_MAX) {\n\t\terr = kzalloc(sizeof(*err), GFP_KERNEL);\n\t\tif (!err)\n\t\t\terr = ERR_PTR(-ENOMEM);\n\t\ttr->n_err_log_entries++;\n\n\t\treturn err;\n\t}\n\n\terr = list_first_entry(&tr->err_log, struct tracing_log_err, list);\n\tlist_del(&err->list);\n\n\treturn err;\n}\n\n/**\n * err_pos - find the position of a string within a command for error careting\n * @cmd: The tracing command that caused the error\n * @str: The string to position the caret at within @cmd\n *\n * Finds the position of the first occurence of @str within @cmd.  The\n * return value can be passed to tracing_log_err() for caret placement\n * within @cmd.\n *\n * Returns the index within @cmd of the first occurence of @str or 0\n * if @str was not found.\n */\nunsigned int err_pos(char *cmd, const char *str)\n{\n\tchar *found;\n\n\tif (WARN_ON(!strlen(cmd)))\n\t\treturn 0;\n\n\tfound = strstr(cmd, str);\n\tif (found)\n\t\treturn found - cmd;\n\n\treturn 0;\n}\n\n/**\n * tracing_log_err - write an error to the tracing error log\n * @tr: The associated trace array for the error (NULL for top level array)\n * @loc: A string describing where the error occurred\n * @cmd: The tracing command that caused the error\n * @errs: The array of loc-specific static error strings\n * @type: The index into errs[], which produces the specific static err string\n * @pos: The position the caret should be placed in the cmd\n *\n * Writes an error into tracing/error_log of the form:\n *\n * <loc>: error: <text>\n *   Command: <cmd>\n *              ^\n *\n * tracing/error_log is a small log file containing the last\n * TRACING_LOG_ERRS_MAX errors (8).  Memory for errors isn't allocated\n * unless there has been a tracing error, and the error log can be\n * cleared and have its memory freed by writing the empty string in\n * truncation mode to it i.e. echo > tracing/error_log.\n *\n * NOTE: the @errs array along with the @type param are used to\n * produce a static error string - this string is not copied and saved\n * when the error is logged - only a pointer to it is saved.  See\n * existing callers for examples of how static strings are typically\n * defined for use with tracing_log_err().\n */\nvoid tracing_log_err(struct trace_array *tr,\n\t\t     const char *loc, const char *cmd,\n\t\t     const char **errs, u8 type, u8 pos)\n{\n\tstruct tracing_log_err *err;\n\n\tif (!tr)\n\t\ttr = &global_trace;\n\n\tmutex_lock(&tracing_err_log_lock);\n\terr = get_tracing_log_err(tr);\n\tif (PTR_ERR(err) == -ENOMEM) {\n\t\tmutex_unlock(&tracing_err_log_lock);\n\t\treturn;\n\t}\n\n\tsnprintf(err->loc, TRACING_LOG_LOC_MAX, \"%s: error: \", loc);\n\tsnprintf(err->cmd, MAX_FILTER_STR_VAL,\"\\n\" CMD_PREFIX \"%s\\n\", cmd);\n\n\terr->info.errs = errs;\n\terr->info.type = type;\n\terr->info.pos = pos;\n\terr->info.ts = local_clock();\n\n\tlist_add_tail(&err->list, &tr->err_log);\n\tmutex_unlock(&tracing_err_log_lock);\n}\n\nstatic void clear_tracing_err_log(struct trace_array *tr)\n{\n\tstruct tracing_log_err *err, *next;\n\n\tmutex_lock(&tracing_err_log_lock);\n\tlist_for_each_entry_safe(err, next, &tr->err_log, list) {\n\t\tlist_del(&err->list);\n\t\tkfree(err);\n\t}\n\n\ttr->n_err_log_entries = 0;\n\tmutex_unlock(&tracing_err_log_lock);\n}\n\nstatic void *tracing_err_log_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\n\tmutex_lock(&tracing_err_log_lock);\n\n\treturn seq_list_start(&tr->err_log, *pos);\n}\n\nstatic void *tracing_err_log_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\n\treturn seq_list_next(v, &tr->err_log, pos);\n}\n\nstatic void tracing_err_log_seq_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&tracing_err_log_lock);\n}\n\nstatic void tracing_err_log_show_pos(struct seq_file *m, u8 pos)\n{\n\tu8 i;\n\n\tfor (i = 0; i < sizeof(CMD_PREFIX) - 1; i++)\n\t\tseq_putc(m, ' ');\n\tfor (i = 0; i < pos; i++)\n\t\tseq_putc(m, ' ');\n\tseq_puts(m, \"^\\n\");\n}\n\nstatic int tracing_err_log_seq_show(struct seq_file *m, void *v)\n{\n\tstruct tracing_log_err *err = v;\n\n\tif (err) {\n\t\tconst char *err_text = err->info.errs[err->info.type];\n\t\tu64 sec = err->info.ts;\n\t\tu32 nsec;\n\n\t\tnsec = do_div(sec, NSEC_PER_SEC);\n\t\tseq_printf(m, \"[%5llu.%06u] %s%s\", sec, nsec / 1000,\n\t\t\t   err->loc, err_text);\n\t\tseq_printf(m, \"%s\", err->cmd);\n\t\ttracing_err_log_show_pos(m, err->info.pos);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct seq_operations tracing_err_log_seq_ops = {\n\t.start  = tracing_err_log_seq_start,\n\t.next   = tracing_err_log_seq_next,\n\t.stop   = tracing_err_log_seq_stop,\n\t.show   = tracing_err_log_seq_show\n};\n\nstatic int tracing_err_log_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tint ret = 0;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\t/* If this file was opened for write, then erase contents */\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC))\n\t\tclear_tracing_err_log(tr);\n\n\tif (file->f_mode & FMODE_READ) {\n\t\tret = seq_open(file, &tracing_err_log_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = tr;\n\t\t} else {\n\t\t\ttrace_array_put(tr);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic ssize_t tracing_err_log_write(struct file *file,\n\t\t\t\t     const char __user *buffer,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\treturn count;\n}\n\nstatic int tracing_err_log_release(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\n\tif (file->f_mode & FMODE_READ)\n\t\tseq_release(inode, file);\n\n\treturn 0;\n}\n\nstatic const struct file_operations tracing_err_log_fops = {\n\t.open           = tracing_err_log_open,\n\t.write\t\t= tracing_err_log_write,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = tracing_err_log_release,\n};\n\nstatic int tracing_buffers_open(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct ftrace_buffer_info *info;\n\tint ret;\n\n\tret = tracing_check_open_get_tr(tr);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo = kvzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info) {\n\t\ttrace_array_put(tr);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\tinfo->iter.tr\t\t= tr;\n\tinfo->iter.cpu_file\t= tracing_get_cpu(inode);\n\tinfo->iter.trace\t= tr->current_trace;\n\tinfo->iter.array_buffer = &tr->array_buffer;\n\tinfo->spare\t\t= NULL;\n\t/* Force reading ring buffer for first read */\n\tinfo->read\t\t= (unsigned int)-1;\n\n\tfilp->private_data = info;\n\n\ttr->trace_ref++;\n\n\tmutex_unlock(&trace_types_lock);\n\n\tret = nonseekable_open(inode, filp);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\n\treturn ret;\n}\n\nstatic __poll_t\ntracing_buffers_poll(struct file *filp, poll_table *poll_table)\n{\n\tstruct ftrace_buffer_info *info = filp->private_data;\n\tstruct trace_iterator *iter = &info->iter;\n\n\treturn trace_poll(iter, filp, poll_table);\n}\n\nstatic ssize_t\ntracing_buffers_read(struct file *filp, char __user *ubuf,\n\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ftrace_buffer_info *info = filp->private_data;\n\tstruct trace_iterator *iter = &info->iter;\n\tssize_t ret = 0;\n\tssize_t size;\n\n\tif (!count)\n\t\treturn 0;\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (iter->snapshot && iter->tr->current_trace->use_max_tr)\n\t\treturn -EBUSY;\n#endif\n\n\tif (!info->spare) {\n\t\tinfo->spare = ring_buffer_alloc_read_page(iter->array_buffer->buffer,\n\t\t\t\t\t\t\t  iter->cpu_file);\n\t\tif (IS_ERR(info->spare)) {\n\t\t\tret = PTR_ERR(info->spare);\n\t\t\tinfo->spare = NULL;\n\t\t} else {\n\t\t\tinfo->spare_cpu = iter->cpu_file;\n\t\t}\n\t}\n\tif (!info->spare)\n\t\treturn ret;\n\n\t/* Do we have previous read data to read? */\n\tif (info->read < PAGE_SIZE)\n\t\tgoto read;\n\n again:\n\ttrace_access_lock(iter->cpu_file);\n\tret = ring_buffer_read_page(iter->array_buffer->buffer,\n\t\t\t\t    &info->spare,\n\t\t\t\t    count,\n\t\t\t\t    iter->cpu_file, 0);\n\ttrace_access_unlock(iter->cpu_file);\n\n\tif (ret < 0) {\n\t\tif (trace_empty(iter)) {\n\t\t\tif ((filp->f_flags & O_NONBLOCK))\n\t\t\t\treturn -EAGAIN;\n\n\t\t\tret = wait_on_pipe(iter, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tgoto again;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tinfo->read = 0;\n read:\n\tsize = PAGE_SIZE - info->read;\n\tif (size > count)\n\t\tsize = count;\n\n\tret = copy_to_user(ubuf, info->spare + info->read, size);\n\tif (ret == size)\n\t\treturn -EFAULT;\n\n\tsize -= ret;\n\n\t*ppos += size;\n\tinfo->read += size;\n\n\treturn size;\n}\n\nstatic int tracing_buffers_release(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_buffer_info *info = file->private_data;\n\tstruct trace_iterator *iter = &info->iter;\n\n\tmutex_lock(&trace_types_lock);\n\n\titer->tr->trace_ref--;\n\n\t__trace_array_put(iter->tr);\n\n\tif (info->spare)\n\t\tring_buffer_free_read_page(iter->array_buffer->buffer,\n\t\t\t\t\t   info->spare_cpu, info->spare);\n\tkvfree(info);\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n}\n\nstruct buffer_ref {\n\tstruct trace_buffer\t*buffer;\n\tvoid\t\t\t*page;\n\tint\t\t\tcpu;\n\trefcount_t\t\trefcount;\n};\n\nstatic void buffer_ref_release(struct buffer_ref *ref)\n{\n\tif (!refcount_dec_and_test(&ref->refcount))\n\t\treturn;\n\tring_buffer_free_read_page(ref->buffer, ref->cpu, ref->page);\n\tkfree(ref);\n}\n\nstatic void buffer_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t    struct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\n\tbuffer_ref_release(ref);\n\tbuf->private = 0;\n}\n\nstatic bool buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\n\tif (refcount_read(&ref->refcount) > INT_MAX/2)\n\t\treturn false;\n\n\trefcount_inc(&ref->refcount);\n\treturn true;\n}\n\n/* Pipe buffer operations for a buffer. */\nstatic const struct pipe_buf_operations buffer_pipe_buf_ops = {\n\t.release\t\t= buffer_pipe_buf_release,\n\t.get\t\t\t= buffer_pipe_buf_get,\n};\n\n/*\n * Callback from splice_to_pipe(), if we need to release some pages\n * at the end of the spd in case we error'ed out in filling the pipe.\n */\nstatic void buffer_spd_release(struct splice_pipe_desc *spd, unsigned int i)\n{\n\tstruct buffer_ref *ref =\n\t\t(struct buffer_ref *)spd->partial[i].private;\n\n\tbuffer_ref_release(ref);\n\tspd->partial[i].private = 0;\n}\n\nstatic ssize_t\ntracing_buffers_splice_read(struct file *file, loff_t *ppos,\n\t\t\t    struct pipe_inode_info *pipe, size_t len,\n\t\t\t    unsigned int flags)\n{\n\tstruct ftrace_buffer_info *info = file->private_data;\n\tstruct trace_iterator *iter = &info->iter;\n\tstruct partial_page partial_def[PIPE_DEF_BUFFERS];\n\tstruct page *pages_def[PIPE_DEF_BUFFERS];\n\tstruct splice_pipe_desc spd = {\n\t\t.pages\t\t= pages_def,\n\t\t.partial\t= partial_def,\n\t\t.nr_pages_max\t= PIPE_DEF_BUFFERS,\n\t\t.ops\t\t= &buffer_pipe_buf_ops,\n\t\t.spd_release\t= buffer_spd_release,\n\t};\n\tstruct buffer_ref *ref;\n\tint entries, i;\n\tssize_t ret = 0;\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (iter->snapshot && iter->tr->current_trace->use_max_tr)\n\t\treturn -EBUSY;\n#endif\n\n\tif (*ppos & (PAGE_SIZE - 1))\n\t\treturn -EINVAL;\n\n\tif (len & (PAGE_SIZE - 1)) {\n\t\tif (len < PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tlen &= PAGE_MASK;\n\t}\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n again:\n\ttrace_access_lock(iter->cpu_file);\n\tentries = ring_buffer_entries_cpu(iter->array_buffer->buffer, iter->cpu_file);\n\n\tfor (i = 0; i < spd.nr_pages_max && len && entries; i++, len -= PAGE_SIZE) {\n\t\tstruct page *page;\n\t\tint r;\n\n\t\tref = kzalloc(sizeof(*ref), GFP_KERNEL);\n\t\tif (!ref) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\trefcount_set(&ref->refcount, 1);\n\t\tref->buffer = iter->array_buffer->buffer;\n\t\tref->page = ring_buffer_alloc_read_page(ref->buffer, iter->cpu_file);\n\t\tif (IS_ERR(ref->page)) {\n\t\t\tret = PTR_ERR(ref->page);\n\t\t\tref->page = NULL;\n\t\t\tkfree(ref);\n\t\t\tbreak;\n\t\t}\n\t\tref->cpu = iter->cpu_file;\n\n\t\tr = ring_buffer_read_page(ref->buffer, &ref->page,\n\t\t\t\t\t  len, iter->cpu_file, 1);\n\t\tif (r < 0) {\n\t\t\tring_buffer_free_read_page(ref->buffer, ref->cpu,\n\t\t\t\t\t\t   ref->page);\n\t\t\tkfree(ref);\n\t\t\tbreak;\n\t\t}\n\n\t\tpage = virt_to_page(ref->page);\n\n\t\tspd.pages[i] = page;\n\t\tspd.partial[i].len = PAGE_SIZE;\n\t\tspd.partial[i].offset = 0;\n\t\tspd.partial[i].private = (unsigned long)ref;\n\t\tspd.nr_pages++;\n\t\t*ppos += PAGE_SIZE;\n\n\t\tentries = ring_buffer_entries_cpu(iter->array_buffer->buffer, iter->cpu_file);\n\t}\n\n\ttrace_access_unlock(iter->cpu_file);\n\tspd.nr_pages = i;\n\n\t/* did we read anything? */\n\tif (!spd.nr_pages) {\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = -EAGAIN;\n\t\tif ((file->f_flags & O_NONBLOCK) || (flags & SPLICE_F_NONBLOCK))\n\t\t\tgoto out;\n\n\t\tret = wait_on_pipe(iter, iter->tr->buffer_percent);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tgoto again;\n\t}\n\n\tret = splice_to_pipe(pipe, &spd);\nout:\n\tsplice_shrink_spd(&spd);\n\n\treturn ret;\n}\n\nstatic const struct file_operations tracing_buffers_fops = {\n\t.open\t\t= tracing_buffers_open,\n\t.read\t\t= tracing_buffers_read,\n\t.poll\t\t= tracing_buffers_poll,\n\t.release\t= tracing_buffers_release,\n\t.splice_read\t= tracing_buffers_splice_read,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic ssize_t\ntracing_stats_read(struct file *filp, char __user *ubuf,\n\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct trace_array *tr = inode->i_private;\n\tstruct array_buffer *trace_buf = &tr->array_buffer;\n\tint cpu = tracing_get_cpu(inode);\n\tstruct trace_seq *s;\n\tunsigned long cnt;\n\tunsigned long long t;\n\tunsigned long usec_rem;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ttrace_seq_init(s);\n\n\tcnt = ring_buffer_entries_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"entries: %ld\\n\", cnt);\n\n\tcnt = ring_buffer_overrun_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"overrun: %ld\\n\", cnt);\n\n\tcnt = ring_buffer_commit_overrun_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"commit overrun: %ld\\n\", cnt);\n\n\tcnt = ring_buffer_bytes_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"bytes: %ld\\n\", cnt);\n\n\tif (trace_clocks[tr->clock_id].in_ns) {\n\t\t/* local or global for trace_clock */\n\t\tt = ns2usecs(ring_buffer_oldest_event_ts(trace_buf->buffer, cpu));\n\t\tusec_rem = do_div(t, USEC_PER_SEC);\n\t\ttrace_seq_printf(s, \"oldest event ts: %5llu.%06lu\\n\",\n\t\t\t\t\t\t\t\tt, usec_rem);\n\n\t\tt = ns2usecs(ring_buffer_time_stamp(trace_buf->buffer, cpu));\n\t\tusec_rem = do_div(t, USEC_PER_SEC);\n\t\ttrace_seq_printf(s, \"now ts: %5llu.%06lu\\n\", t, usec_rem);\n\t} else {\n\t\t/* counter or tsc mode for trace_clock */\n\t\ttrace_seq_printf(s, \"oldest event ts: %llu\\n\",\n\t\t\t\tring_buffer_oldest_event_ts(trace_buf->buffer, cpu));\n\n\t\ttrace_seq_printf(s, \"now ts: %llu\\n\",\n\t\t\t\tring_buffer_time_stamp(trace_buf->buffer, cpu));\n\t}\n\n\tcnt = ring_buffer_dropped_events_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"dropped events: %ld\\n\", cnt);\n\n\tcnt = ring_buffer_read_events_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"read events: %ld\\n\", cnt);\n\n\tcount = simple_read_from_buffer(ubuf, count, ppos,\n\t\t\t\t\ts->buffer, trace_seq_used(s));\n\n\tkfree(s);\n\n\treturn count;\n}\n\nstatic const struct file_operations tracing_stats_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.read\t\t= tracing_stats_read,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= tracing_release_generic_tr,\n};\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\nstatic ssize_t\ntracing_read_dyn_info(struct file *filp, char __user *ubuf,\n\t\t  size_t cnt, loff_t *ppos)\n{\n\tssize_t ret;\n\tchar *buf;\n\tint r;\n\n\t/* 256 should be plenty to hold the amount needed */\n\tbuf = kmalloc(256, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tr = scnprintf(buf, 256, \"%ld pages:%ld groups: %ld\\n\",\n\t\t      ftrace_update_tot_cnt,\n\t\t      ftrace_number_of_pages,\n\t\t      ftrace_number_of_groups);\n\n\tret = simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic const struct file_operations tracing_dyn_info_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_read_dyn_info,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif /* CONFIG_DYNAMIC_FTRACE */\n\n#if defined(CONFIG_TRACER_SNAPSHOT) && defined(CONFIG_DYNAMIC_FTRACE)\nstatic void\nftrace_snapshot(unsigned long ip, unsigned long parent_ip,\n\t\tstruct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\tvoid *data)\n{\n\ttracing_snapshot_instance(tr);\n}\n\nstatic void\nftrace_count_snapshot(unsigned long ip, unsigned long parent_ip,\n\t\t      struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t      void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count) {\n\n\t\tif (*count <= 0)\n\t\t\treturn;\n\n\t\t(*count)--;\n\t}\n\n\ttracing_snapshot_instance(tr);\n}\n\nstatic int\nftrace_snapshot_print(struct seq_file *m, unsigned long ip,\n\t\t      struct ftrace_probe_ops *ops, void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tlong *count = NULL;\n\n\tseq_printf(m, \"%ps:\", (void *)ip);\n\n\tseq_puts(m, \"snapshot\");\n\n\tif (mapper)\n\t\tcount = (long *)ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (count)\n\t\tseq_printf(m, \":count=%ld\\n\", *count);\n\telse\n\t\tseq_puts(m, \":unlimited\\n\");\n\n\treturn 0;\n}\n\nstatic int\nftrace_snapshot_init(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t     unsigned long ip, void *init_data, void **data)\n{\n\tstruct ftrace_func_mapper *mapper = *data;\n\n\tif (!mapper) {\n\t\tmapper = allocate_ftrace_func_mapper();\n\t\tif (!mapper)\n\t\t\treturn -ENOMEM;\n\t\t*data = mapper;\n\t}\n\n\treturn ftrace_func_mapper_add_ip(mapper, ip, init_data);\n}\n\nstatic void\nftrace_snapshot_free(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t     unsigned long ip, void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\n\tif (!ip) {\n\t\tif (!mapper)\n\t\t\treturn;\n\t\tfree_ftrace_func_mapper(mapper, NULL);\n\t\treturn;\n\t}\n\n\tftrace_func_mapper_remove_ip(mapper, ip);\n}\n\nstatic struct ftrace_probe_ops snapshot_probe_ops = {\n\t.func\t\t\t= ftrace_snapshot,\n\t.print\t\t\t= ftrace_snapshot_print,\n};\n\nstatic struct ftrace_probe_ops snapshot_count_probe_ops = {\n\t.func\t\t\t= ftrace_count_snapshot,\n\t.print\t\t\t= ftrace_snapshot_print,\n\t.init\t\t\t= ftrace_snapshot_init,\n\t.free\t\t\t= ftrace_snapshot_free,\n};\n\nstatic int\nftrace_trace_snapshot_callback(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t\t       char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tops = param ? &snapshot_count_probe_ops :  &snapshot_probe_ops;\n\n\tif (glob[0] == '!')\n\t\treturn unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = tracing_alloc_snapshot_instance(tr);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = register_ftrace_function_probe(glob, tr, ops, count);\n\n out:\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic struct ftrace_func_command ftrace_snapshot_cmd = {\n\t.name\t\t\t= \"snapshot\",\n\t.func\t\t\t= ftrace_trace_snapshot_callback,\n};\n\nstatic __init int register_snapshot_cmd(void)\n{\n\treturn register_ftrace_command(&ftrace_snapshot_cmd);\n}\n#else\nstatic inline __init int register_snapshot_cmd(void) { return 0; }\n#endif /* defined(CONFIG_TRACER_SNAPSHOT) && defined(CONFIG_DYNAMIC_FTRACE) */\n\nstatic struct dentry *tracing_get_dentry(struct trace_array *tr)\n{\n\tif (WARN_ON(!tr->dir))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t/* Top directory uses NULL as the parent */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL)\n\t\treturn NULL;\n\n\t/* All sub buffers have a descriptor */\n\treturn tr->dir;\n}\n\nstatic struct dentry *tracing_dentry_percpu(struct trace_array *tr, int cpu)\n{\n\tstruct dentry *d_tracer;\n\n\tif (tr->percpu_dir)\n\t\treturn tr->percpu_dir;\n\n\td_tracer = tracing_get_dentry(tr);\n\tif (IS_ERR(d_tracer))\n\t\treturn NULL;\n\n\ttr->percpu_dir = tracefs_create_dir(\"per_cpu\", d_tracer);\n\n\tMEM_FAIL(!tr->percpu_dir,\n\t\t  \"Could not create tracefs directory 'per_cpu/%d'\\n\", cpu);\n\n\treturn tr->percpu_dir;\n}\n\nstatic struct dentry *\ntrace_create_cpu_file(const char *name, umode_t mode, struct dentry *parent,\n\t\t      void *data, long cpu, const struct file_operations *fops)\n{\n\tstruct dentry *ret = trace_create_file(name, mode, parent, data, fops);\n\n\tif (ret) /* See tracing_get_cpu() */\n\t\td_inode(ret)->i_cdev = (void *)(cpu + 1);\n\treturn ret;\n}\n\nstatic void\ntracing_init_tracefs_percpu(struct trace_array *tr, long cpu)\n{\n\tstruct dentry *d_percpu = tracing_dentry_percpu(tr, cpu);\n\tstruct dentry *d_cpu;\n\tchar cpu_dir[30]; /* 30 characters should be more than enough */\n\n\tif (!d_percpu)\n\t\treturn;\n\n\tsnprintf(cpu_dir, 30, \"cpu%ld\", cpu);\n\td_cpu = tracefs_create_dir(cpu_dir, d_percpu);\n\tif (!d_cpu) {\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", cpu_dir);\n\t\treturn;\n\t}\n\n\t/* per cpu trace_pipe */\n\ttrace_create_cpu_file(\"trace_pipe\", 0444, d_cpu,\n\t\t\t\ttr, cpu, &tracing_pipe_fops);\n\n\t/* per cpu trace */\n\ttrace_create_cpu_file(\"trace\", 0644, d_cpu,\n\t\t\t\ttr, cpu, &tracing_fops);\n\n\ttrace_create_cpu_file(\"trace_pipe_raw\", 0444, d_cpu,\n\t\t\t\ttr, cpu, &tracing_buffers_fops);\n\n\ttrace_create_cpu_file(\"stats\", 0444, d_cpu,\n\t\t\t\ttr, cpu, &tracing_stats_fops);\n\n\ttrace_create_cpu_file(\"buffer_size_kb\", 0444, d_cpu,\n\t\t\t\ttr, cpu, &tracing_entries_fops);\n\n#ifdef CONFIG_TRACER_SNAPSHOT\n\ttrace_create_cpu_file(\"snapshot\", 0644, d_cpu,\n\t\t\t\ttr, cpu, &snapshot_fops);\n\n\ttrace_create_cpu_file(\"snapshot_raw\", 0444, d_cpu,\n\t\t\t\ttr, cpu, &snapshot_raw_fops);\n#endif\n}\n\n#ifdef CONFIG_FTRACE_SELFTEST\n/* Let selftest have access to static functions in this file */\n#include \"trace_selftest.c\"\n#endif\n\nstatic ssize_t\ntrace_options_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t\tloff_t *ppos)\n{\n\tstruct trace_option_dentry *topt = filp->private_data;\n\tchar *buf;\n\n\tif (topt->flags->val & topt->opt->bit)\n\t\tbuf = \"1\\n\";\n\telse\n\t\tbuf = \"0\\n\";\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, 2);\n}\n\nstatic ssize_t\ntrace_options_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t\t loff_t *ppos)\n{\n\tstruct trace_option_dentry *topt = filp->private_data;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != 0 && val != 1)\n\t\treturn -EINVAL;\n\n\tif (!!(topt->flags->val & topt->opt->bit) != val) {\n\t\tmutex_lock(&trace_types_lock);\n\t\tret = __set_tracer_option(topt->tr, topt->flags,\n\t\t\t\t\t  topt->opt, !val);\n\t\tmutex_unlock(&trace_types_lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\n\nstatic const struct file_operations trace_options_fops = {\n\t.open = tracing_open_generic,\n\t.read = trace_options_read,\n\t.write = trace_options_write,\n\t.llseek\t= generic_file_llseek,\n};\n\n/*\n * In order to pass in both the trace_array descriptor as well as the index\n * to the flag that the trace option file represents, the trace_array\n * has a character array of trace_flags_index[], which holds the index\n * of the bit for the flag it represents. index[0] == 0, index[1] == 1, etc.\n * The address of this character array is passed to the flag option file\n * read/write callbacks.\n *\n * In order to extract both the index and the trace_array descriptor,\n * get_tr_index() uses the following algorithm.\n *\n *   idx = *ptr;\n *\n * As the pointer itself contains the address of the index (remember\n * index[1] == 1).\n *\n * Then to get the trace_array descriptor, by subtracting that index\n * from the ptr, we get to the start of the index itself.\n *\n *   ptr - idx == &index[0]\n *\n * Then a simple container_of() from that pointer gets us to the\n * trace_array descriptor.\n */\nstatic void get_tr_index(void *data, struct trace_array **ptr,\n\t\t\t unsigned int *pindex)\n{\n\t*pindex = *(unsigned char *)data;\n\n\t*ptr = container_of(data - *pindex, struct trace_array,\n\t\t\t    trace_flags_index);\n}\n\nstatic ssize_t\ntrace_options_core_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t\tloff_t *ppos)\n{\n\tvoid *tr_index = filp->private_data;\n\tstruct trace_array *tr;\n\tunsigned int index;\n\tchar *buf;\n\n\tget_tr_index(tr_index, &tr, &index);\n\n\tif (tr->trace_flags & (1 << index))\n\t\tbuf = \"1\\n\";\n\telse\n\t\tbuf = \"0\\n\";\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, 2);\n}\n\nstatic ssize_t\ntrace_options_core_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t\t loff_t *ppos)\n{\n\tvoid *tr_index = filp->private_data;\n\tstruct trace_array *tr;\n\tunsigned int index;\n\tunsigned long val;\n\tint ret;\n\n\tget_tr_index(tr_index, &tr, &index);\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != 0 && val != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tret = set_tracer_flag(tr, 1 << index, val);\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic const struct file_operations trace_options_core_fops = {\n\t.open = tracing_open_generic,\n\t.read = trace_options_core_read,\n\t.write = trace_options_core_write,\n\t.llseek = generic_file_llseek,\n};\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}\n\n\nstatic struct dentry *trace_options_init_dentry(struct trace_array *tr)\n{\n\tstruct dentry *d_tracer;\n\n\tif (tr->options)\n\t\treturn tr->options;\n\n\td_tracer = tracing_get_dentry(tr);\n\tif (IS_ERR(d_tracer))\n\t\treturn NULL;\n\n\ttr->options = tracefs_create_dir(\"options\", d_tracer);\n\tif (!tr->options) {\n\t\tpr_warn(\"Could not create tracefs directory 'options'\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn tr->options;\n}\n\nstatic void\ncreate_trace_option_file(struct trace_array *tr,\n\t\t\t struct trace_option_dentry *topt,\n\t\t\t struct tracer_flags *flags,\n\t\t\t struct tracer_opt *opt)\n{\n\tstruct dentry *t_options;\n\n\tt_options = trace_options_init_dentry(tr);\n\tif (!t_options)\n\t\treturn;\n\n\ttopt->flags = flags;\n\ttopt->opt = opt;\n\ttopt->tr = tr;\n\n\ttopt->entry = trace_create_file(opt->name, 0644, t_options, topt,\n\t\t\t\t    &trace_options_fops);\n\n}\n\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer)\n{\n\tstruct trace_option_dentry *topts;\n\tstruct trace_options *tr_topts;\n\tstruct tracer_flags *flags;\n\tstruct tracer_opt *opts;\n\tint cnt;\n\tint i;\n\n\tif (!tracer)\n\t\treturn;\n\n\tflags = tracer->flags;\n\n\tif (!flags || !flags->opts)\n\t\treturn;\n\n\t/*\n\t * If this is an instance, only create flags for tracers\n\t * the instance may have.\n\t */\n\tif (!trace_ok_for_array(tracer, tr))\n\t\treturn;\n\n\tfor (i = 0; i < tr->nr_topts; i++) {\n\t\t/* Make sure there's no duplicate flags. */\n\t\tif (WARN_ON_ONCE(tr->topts[i].tracer->flags == tracer->flags))\n\t\t\treturn;\n\t}\n\n\topts = flags->opts;\n\n\tfor (cnt = 0; opts[cnt].name; cnt++)\n\t\t;\n\n\ttopts = kcalloc(cnt + 1, sizeof(*topts), GFP_KERNEL);\n\tif (!topts)\n\t\treturn;\n\n\ttr_topts = krealloc(tr->topts, sizeof(*tr->topts) * (tr->nr_topts + 1),\n\t\t\t    GFP_KERNEL);\n\tif (!tr_topts) {\n\t\tkfree(topts);\n\t\treturn;\n\t}\n\n\ttr->topts = tr_topts;\n\ttr->topts[tr->nr_topts].tracer = tracer;\n\ttr->topts[tr->nr_topts].topts = topts;\n\ttr->nr_topts++;\n\n\tfor (cnt = 0; opts[cnt].name; cnt++) {\n\t\tcreate_trace_option_file(tr, &topts[cnt], flags,\n\t\t\t\t\t &opts[cnt]);\n\t\tMEM_FAIL(topts[cnt].entry == NULL,\n\t\t\t  \"Failed to create trace option: %s\",\n\t\t\t  opts[cnt].name);\n\t}\n}\n\nstatic struct dentry *\ncreate_trace_option_core_file(struct trace_array *tr,\n\t\t\t      const char *option, long index)\n{\n\tstruct dentry *t_options;\n\n\tt_options = trace_options_init_dentry(tr);\n\tif (!t_options)\n\t\treturn NULL;\n\n\treturn trace_create_file(option, 0644, t_options,\n\t\t\t\t (void *)&tr->trace_flags_index[index],\n\t\t\t\t &trace_options_core_fops);\n}\n\nstatic void create_trace_options_dir(struct trace_array *tr)\n{\n\tstruct dentry *t_options;\n\tbool top_level = tr == &global_trace;\n\tint i;\n\n\tt_options = trace_options_init_dentry(tr);\n\tif (!t_options)\n\t\treturn;\n\n\tfor (i = 0; trace_options[i]; i++) {\n\t\tif (top_level ||\n\t\t    !((1 << i) & TOP_LEVEL_TRACE_FLAGS))\n\t\t\tcreate_trace_option_core_file(tr, trace_options[i], i);\n\t}\n}\n\nstatic ssize_t\nrb_simple_read(struct file *filp, char __user *ubuf,\n\t       size_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tchar buf[64];\n\tint r;\n\n\tr = tracer_tracing_is_on(tr);\n\tr = sprintf(buf, \"%d\\n\", r);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nstatic ssize_t\nrb_simple_write(struct file *filp, const char __user *ubuf,\n\t\tsize_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tstruct trace_buffer *buffer = tr->array_buffer.buffer;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (buffer) {\n\t\tmutex_lock(&trace_types_lock);\n\t\tif (!!val == tracer_tracing_is_on(tr)) {\n\t\t\tval = 0; /* do nothing */\n\t\t} else if (val) {\n\t\t\ttracer_tracing_on(tr);\n\t\t\tif (tr->current_trace->start)\n\t\t\t\ttr->current_trace->start(tr);\n\t\t} else {\n\t\t\ttracer_tracing_off(tr);\n\t\t\tif (tr->current_trace->stop)\n\t\t\t\ttr->current_trace->stop(tr);\n\t\t}\n\t\tmutex_unlock(&trace_types_lock);\n\t}\n\n\t(*ppos)++;\n\n\treturn cnt;\n}\n\nstatic const struct file_operations rb_simple_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.read\t\t= rb_simple_read,\n\t.write\t\t= rb_simple_write,\n\t.release\t= tracing_release_generic_tr,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic ssize_t\nbuffer_percent_read(struct file *filp, char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tchar buf[64];\n\tint r;\n\n\tr = tr->buffer_percent;\n\tr = sprintf(buf, \"%d\\n\", r);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nstatic ssize_t\nbuffer_percent_write(struct file *filp, const char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > 100)\n\t\treturn -EINVAL;\n\n\tif (!val)\n\t\tval = 1;\n\n\ttr->buffer_percent = val;\n\n\t(*ppos)++;\n\n\treturn cnt;\n}\n\nstatic const struct file_operations buffer_percent_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.read\t\t= buffer_percent_read,\n\t.write\t\t= buffer_percent_write,\n\t.release\t= tracing_release_generic_tr,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic struct dentry *trace_instance_dir;\n\nstatic void\ninit_tracer_tracefs(struct trace_array *tr, struct dentry *d_tracer);\n\nstatic int\nallocate_trace_buffer(struct trace_array *tr, struct array_buffer *buf, int size)\n{\n\tenum ring_buffer_flags rb_flags;\n\n\trb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;\n\n\tbuf->tr = tr;\n\n\tbuf->buffer = ring_buffer_alloc(size, rb_flags);\n\tif (!buf->buffer)\n\t\treturn -ENOMEM;\n\n\tbuf->data = alloc_percpu(struct trace_array_cpu);\n\tif (!buf->data) {\n\t\tring_buffer_free(buf->buffer);\n\t\tbuf->buffer = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Allocate the first page for all buffers */\n\tset_buffer_entries(&tr->array_buffer,\n\t\t\t   ring_buffer_size(tr->array_buffer.buffer, 0));\n\n\treturn 0;\n}\n\nstatic int allocate_trace_buffers(struct trace_array *tr, int size)\n{\n\tint ret;\n\n\tret = allocate_trace_buffer(tr, &tr->array_buffer, size);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tret = allocate_trace_buffer(tr, &tr->max_buffer,\n\t\t\t\t    allocate_snapshot ? size : 1);\n\tif (MEM_FAIL(ret, \"Failed to allocate trace buffer\\n\")) {\n\t\tring_buffer_free(tr->array_buffer.buffer);\n\t\ttr->array_buffer.buffer = NULL;\n\t\tfree_percpu(tr->array_buffer.data);\n\t\ttr->array_buffer.data = NULL;\n\t\treturn -ENOMEM;\n\t}\n\ttr->allocated_snapshot = allocate_snapshot;\n\n\t/*\n\t * Only the top level trace array gets its snapshot allocated\n\t * from the kernel command line.\n\t */\n\tallocate_snapshot = false;\n#endif\n\n\treturn 0;\n}\n\nstatic void free_trace_buffer(struct array_buffer *buf)\n{\n\tif (buf->buffer) {\n\t\tring_buffer_free(buf->buffer);\n\t\tbuf->buffer = NULL;\n\t\tfree_percpu(buf->data);\n\t\tbuf->data = NULL;\n\t}\n}\n\nstatic void free_trace_buffers(struct trace_array *tr)\n{\n\tif (!tr)\n\t\treturn;\n\n\tfree_trace_buffer(&tr->array_buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tfree_trace_buffer(&tr->max_buffer);\n#endif\n}\n\nstatic void init_trace_flags_index(struct trace_array *tr)\n{\n\tint i;\n\n\t/* Used by the trace options files */\n\tfor (i = 0; i < TRACE_FLAGS_MAX_SIZE; i++)\n\t\ttr->trace_flags_index[i] = i;\n}\n\nstatic void __update_tracer_options(struct trace_array *tr)\n{\n\tstruct tracer *t;\n\n\tfor (t = trace_types; t; t = t->next)\n\t\tadd_tracer_options(tr, t);\n}\n\nstatic void update_tracer_options(struct trace_array *tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__update_tracer_options(tr);\n\tmutex_unlock(&trace_types_lock);\n}\n\n/* Must have trace_types_lock held */\nstruct trace_array *trace_array_find(const char *instance)\n{\n\tstruct trace_array *tr, *found = NULL;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr->name && strcmp(tr->name, instance) == 0) {\n\t\t\tfound = tr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstruct trace_array *trace_array_find_get(const char *instance)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&trace_types_lock);\n\ttr = trace_array_find(instance);\n\tif (tr)\n\t\ttr->ref++;\n\tmutex_unlock(&trace_types_lock);\n\n\treturn tr;\n}\n\nstatic int trace_array_create_dir(struct trace_array *tr)\n{\n\tint ret;\n\n\ttr->dir = tracefs_create_dir(tr->name, trace_instance_dir);\n\tif (!tr->dir)\n\t\treturn -EINVAL;\n\n\tret = event_trace_add_tracer(tr->dir, tr);\n\tif (ret)\n\t\ttracefs_remove(tr->dir);\n\n\tinit_tracer_tracefs(tr, tr->dir);\n\t__update_tracer_options(tr);\n\n\treturn ret;\n}\n\nstatic struct trace_array *trace_array_create(const char *name)\n{\n\tstruct trace_array *tr;\n\tint ret;\n\n\tret = -ENOMEM;\n\ttr = kzalloc(sizeof(*tr), GFP_KERNEL);\n\tif (!tr)\n\t\treturn ERR_PTR(ret);\n\n\ttr->name = kstrdup(name, GFP_KERNEL);\n\tif (!tr->name)\n\t\tgoto out_free_tr;\n\n\tif (!alloc_cpumask_var(&tr->tracing_cpumask, GFP_KERNEL))\n\t\tgoto out_free_tr;\n\n\ttr->trace_flags = global_trace.trace_flags & ~ZEROED_TRACE_FLAGS;\n\n\tcpumask_copy(tr->tracing_cpumask, cpu_all_mask);\n\n\traw_spin_lock_init(&tr->start_lock);\n\n\ttr->max_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\n\ttr->current_trace = &nop_trace;\n\n\tINIT_LIST_HEAD(&tr->systems);\n\tINIT_LIST_HEAD(&tr->events);\n\tINIT_LIST_HEAD(&tr->hist_vars);\n\tINIT_LIST_HEAD(&tr->err_log);\n\n\tif (allocate_trace_buffers(tr, trace_buf_size) < 0)\n\t\tgoto out_free_tr;\n\n\tif (ftrace_allocate_ftrace_ops(tr) < 0)\n\t\tgoto out_free_tr;\n\n\tftrace_init_trace_array(tr);\n\n\tinit_trace_flags_index(tr);\n\n\tif (trace_instance_dir) {\n\t\tret = trace_array_create_dir(tr);\n\t\tif (ret)\n\t\t\tgoto out_free_tr;\n\t} else\n\t\t__trace_early_add_events(tr);\n\n\tlist_add(&tr->list, &ftrace_trace_arrays);\n\n\ttr->ref++;\n\n\treturn tr;\n\n out_free_tr:\n\tftrace_free_ftrace_ops(tr);\n\tfree_trace_buffers(tr);\n\tfree_cpumask_var(tr->tracing_cpumask);\n\tkfree(tr->name);\n\tkfree(tr);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic int instance_mkdir(const char *name)\n{\n\tstruct trace_array *tr;\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tret = -EEXIST;\n\tif (trace_array_find(name))\n\t\tgoto out_unlock;\n\n\ttr = trace_array_create(name);\n\n\tret = PTR_ERR_OR_ZERO(tr);\n\nout_unlock:\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n}\n\n/**\n * trace_array_get_by_name - Create/Lookup a trace array, given its name.\n * @name: The name of the trace array to be looked up/created.\n *\n * Returns pointer to trace array with given name.\n * NULL, if it cannot be created.\n *\n * NOTE: This function increments the reference counter associated with the\n * trace array returned. This makes sure it cannot be freed while in use.\n * Use trace_array_put() once the trace array is no longer needed.\n * If the trace_array is to be freed, trace_array_destroy() needs to\n * be called after the trace_array_put(), or simply let user space delete\n * it from the tracefs instances directory. But until the\n * trace_array_put() is called, user space can not delete it.\n *\n */\nstruct trace_array *trace_array_get_by_name(const char *name)\n{\n\tstruct trace_array *tr;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr->name && strcmp(tr->name, name) == 0)\n\t\t\tgoto out_unlock;\n\t}\n\n\ttr = trace_array_create(name);\n\n\tif (IS_ERR(tr))\n\t\ttr = NULL;\nout_unlock:\n\tif (tr)\n\t\ttr->ref++;\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\treturn tr;\n}\nEXPORT_SYMBOL_GPL(trace_array_get_by_name);\n\nstatic int __remove_instance(struct trace_array *tr)\n{\n\tint i;\n\n\t/* Reference counter for a newly created trace array = 1. */\n\tif (tr->ref > 1 || (tr->current_trace && tr->trace_ref))\n\t\treturn -EBUSY;\n\n\tlist_del(&tr->list);\n\n\t/* Disable all the flags that were enabled coming in */\n\tfor (i = 0; i < TRACE_FLAGS_MAX_SIZE; i++) {\n\t\tif ((1 << i) & ZEROED_TRACE_FLAGS)\n\t\t\tset_tracer_flag(tr, 1 << i, 0);\n\t}\n\n\ttracing_set_nop(tr);\n\tclear_ftrace_function_probes(tr);\n\tevent_trace_del_tracer(tr);\n\tftrace_clear_pids(tr);\n\tftrace_destroy_function_files(tr);\n\ttracefs_remove(tr->dir);\n\tfree_trace_buffers(tr);\n\n\tfor (i = 0; i < tr->nr_topts; i++) {\n\t\tkfree(tr->topts[i].topts);\n\t}\n\tkfree(tr->topts);\n\n\tfree_cpumask_var(tr->tracing_cpumask);\n\tkfree(tr->name);\n\tkfree(tr);\n\n\treturn 0;\n}\n\nint trace_array_destroy(struct trace_array *this_tr)\n{\n\tstruct trace_array *tr;\n\tint ret;\n\n\tif (!this_tr)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tret = -ENODEV;\n\n\t/* Making sure trace array exists before destroying it. */\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr == this_tr) {\n\t\t\tret = __remove_instance(tr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(trace_array_destroy);\n\nstatic int instance_rmdir(const char *name)\n{\n\tstruct trace_array *tr;\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tret = -ENODEV;\n\ttr = trace_array_find(name);\n\tif (tr)\n\t\tret = __remove_instance(tr);\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}\n\nstatic __init void create_trace_instances(struct dentry *d_tracer)\n{\n\tstruct trace_array *tr;\n\n\ttrace_instance_dir = tracefs_create_instance_dir(\"instances\", d_tracer,\n\t\t\t\t\t\t\t instance_mkdir,\n\t\t\t\t\t\t\t instance_rmdir);\n\tif (MEM_FAIL(!trace_instance_dir, \"Failed to create instances directory\\n\"))\n\t\treturn;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->name)\n\t\t\tcontinue;\n\t\tif (MEM_FAIL(trace_array_create_dir(tr) < 0,\n\t\t\t     \"Failed to create instance directory\\n\"))\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n}\n\nstatic void\ninit_tracer_tracefs(struct trace_array *tr, struct dentry *d_tracer)\n{\n\tstruct trace_event_file *file;\n\tint cpu;\n\n\ttrace_create_file(\"available_tracers\", 0444, d_tracer,\n\t\t\ttr, &show_traces_fops);\n\n\ttrace_create_file(\"current_tracer\", 0644, d_tracer,\n\t\t\ttr, &set_tracer_fops);\n\n\ttrace_create_file(\"tracing_cpumask\", 0644, d_tracer,\n\t\t\t  tr, &tracing_cpumask_fops);\n\n\ttrace_create_file(\"trace_options\", 0644, d_tracer,\n\t\t\t  tr, &tracing_iter_fops);\n\n\ttrace_create_file(\"trace\", 0644, d_tracer,\n\t\t\t  tr, &tracing_fops);\n\n\ttrace_create_file(\"trace_pipe\", 0444, d_tracer,\n\t\t\t  tr, &tracing_pipe_fops);\n\n\ttrace_create_file(\"buffer_size_kb\", 0644, d_tracer,\n\t\t\t  tr, &tracing_entries_fops);\n\n\ttrace_create_file(\"buffer_total_size_kb\", 0444, d_tracer,\n\t\t\t  tr, &tracing_total_entries_fops);\n\n\ttrace_create_file(\"free_buffer\", 0200, d_tracer,\n\t\t\t  tr, &tracing_free_buffer_fops);\n\n\ttrace_create_file(\"trace_marker\", 0220, d_tracer,\n\t\t\t  tr, &tracing_mark_fops);\n\n\tfile = __find_event_file(tr, \"ftrace\", \"print\");\n\tif (file && file->dir)\n\t\ttrace_create_file(\"trigger\", 0644, file->dir, file,\n\t\t\t\t  &event_trigger_fops);\n\ttr->trace_marker_file = file;\n\n\ttrace_create_file(\"trace_marker_raw\", 0220, d_tracer,\n\t\t\t  tr, &tracing_mark_raw_fops);\n\n\ttrace_create_file(\"trace_clock\", 0644, d_tracer, tr,\n\t\t\t  &trace_clock_fops);\n\n\ttrace_create_file(\"tracing_on\", 0644, d_tracer,\n\t\t\t  tr, &rb_simple_fops);\n\n\ttrace_create_file(\"timestamp_mode\", 0444, d_tracer, tr,\n\t\t\t  &trace_time_stamp_mode_fops);\n\n\ttr->buffer_percent = 50;\n\n\ttrace_create_file(\"buffer_percent\", 0444, d_tracer,\n\t\t\ttr, &buffer_percent_fops);\n\n\tcreate_trace_options_dir(tr);\n\n#if defined(CONFIG_TRACER_MAX_TRACE) || defined(CONFIG_HWLAT_TRACER)\n\ttrace_create_maxlat_file(tr, d_tracer);\n#endif\n\n\tif (ftrace_create_function_files(tr, d_tracer))\n\t\tMEM_FAIL(1, \"Could not allocate function filter files\");\n\n#ifdef CONFIG_TRACER_SNAPSHOT\n\ttrace_create_file(\"snapshot\", 0644, d_tracer,\n\t\t\t  tr, &snapshot_fops);\n#endif\n\n\ttrace_create_file(\"error_log\", 0644, d_tracer,\n\t\t\t  tr, &tracing_err_log_fops);\n\n\tfor_each_tracing_cpu(cpu)\n\t\ttracing_init_tracefs_percpu(tr, cpu);\n\n\tftrace_init_tracefs(tr, d_tracer);\n}\n\nstatic struct vfsmount *trace_automount(struct dentry *mntpt, void *ingore)\n{\n\tstruct vfsmount *mnt;\n\tstruct file_system_type *type;\n\n\t/*\n\t * To maintain backward compatibility for tools that mount\n\t * debugfs to get to the tracing facility, tracefs is automatically\n\t * mounted to the debugfs/tracing directory.\n\t */\n\ttype = get_fs_type(\"tracefs\");\n\tif (!type)\n\t\treturn NULL;\n\tmnt = vfs_submount(mntpt, type, \"tracefs\", NULL);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn NULL;\n\tmntget(mnt);\n\n\treturn mnt;\n}\n\n/**\n * tracing_init_dentry - initialize top level trace array\n *\n * This is called when creating files or directories in the tracing\n * directory. It is called via fs_initcall() by any of the boot up code\n * and expects to return the dentry of the top level tracing directory.\n */\nint tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kerenl.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}\n\nextern struct trace_eval_map *__start_ftrace_eval_maps[];\nextern struct trace_eval_map *__stop_ftrace_eval_maps[];\n\nstatic void __init trace_eval_init(void)\n{\n\tint len;\n\n\tlen = __stop_ftrace_eval_maps - __start_ftrace_eval_maps;\n\ttrace_insert_eval_map(NULL, __start_ftrace_eval_maps, len);\n}\n\n#ifdef CONFIG_MODULES\nstatic void trace_module_add_evals(struct module *mod)\n{\n\tif (!mod->num_trace_evals)\n\t\treturn;\n\n\t/*\n\t * Modules with bad taint do not have events created, do\n\t * not bother with enums either.\n\t */\n\tif (trace_module_has_bad_taint(mod))\n\t\treturn;\n\n\ttrace_insert_eval_map(mod, mod->trace_evals, mod->num_trace_evals);\n}\n\n#ifdef CONFIG_TRACE_EVAL_MAP_FILE\nstatic void trace_module_remove_evals(struct module *mod)\n{\n\tunion trace_eval_map_item *map;\n\tunion trace_eval_map_item **last = &trace_eval_maps;\n\n\tif (!mod->num_trace_evals)\n\t\treturn;\n\n\tmutex_lock(&trace_eval_mutex);\n\n\tmap = trace_eval_maps;\n\n\twhile (map) {\n\t\tif (map->head.mod == mod)\n\t\t\tbreak;\n\t\tmap = trace_eval_jmp_to_tail(map);\n\t\tlast = &map->tail.next;\n\t\tmap = map->tail.next;\n\t}\n\tif (!map)\n\t\tgoto out;\n\n\t*last = trace_eval_jmp_to_tail(map)->tail.next;\n\tkfree(map);\n out:\n\tmutex_unlock(&trace_eval_mutex);\n}\n#else\nstatic inline void trace_module_remove_evals(struct module *mod) { }\n#endif /* CONFIG_TRACE_EVAL_MAP_FILE */\n\nstatic int trace_module_notify(struct notifier_block *self,\n\t\t\t       unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\ttrace_module_add_evals(mod);\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\ttrace_module_remove_evals(mod);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block trace_module_nb = {\n\t.notifier_call = trace_module_notify,\n\t.priority = 0,\n};\n#endif /* CONFIG_MODULES */\n\nstatic __init int tracer_init_tracefs(void)\n{\n\tint ret;\n\n\ttrace_access_lock_init();\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn 0;\n\n\tevent_trace_init();\n\n\tinit_tracer_tracefs(&global_trace, NULL);\n\tftrace_init_tracefs_toplevel(&global_trace, NULL);\n\n\ttrace_create_file(\"tracing_thresh\", 0644, NULL,\n\t\t\t&global_trace, &tracing_thresh_fops);\n\n\ttrace_create_file(\"README\", 0444, NULL,\n\t\t\tNULL, &tracing_readme_fops);\n\n\ttrace_create_file(\"saved_cmdlines\", 0444, NULL,\n\t\t\tNULL, &tracing_saved_cmdlines_fops);\n\n\ttrace_create_file(\"saved_cmdlines_size\", 0644, NULL,\n\t\t\t  NULL, &tracing_saved_cmdlines_size_fops);\n\n\ttrace_create_file(\"saved_tgids\", 0444, NULL,\n\t\t\tNULL, &tracing_saved_tgids_fops);\n\n\ttrace_eval_init();\n\n\ttrace_create_eval_file(NULL);\n\n#ifdef CONFIG_MODULES\n\tregister_module_notifier(&trace_module_nb);\n#endif\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\ttrace_create_file(\"dyn_ftrace_total_info\", 0444, NULL,\n\t\t\tNULL, &tracing_dyn_info_fops);\n#endif\n\n\tcreate_trace_instances(NULL);\n\n\tupdate_tracer_options(&global_trace);\n\n\treturn 0;\n}\n\nstatic int trace_panic_handler(struct notifier_block *this,\n\t\t\t       unsigned long event, void *unused)\n{\n\tif (ftrace_dump_on_oops)\n\t\tftrace_dump(ftrace_dump_on_oops);\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block trace_panic_notifier = {\n\t.notifier_call  = trace_panic_handler,\n\t.next           = NULL,\n\t.priority       = 150   /* priority: INT_MAX >= x >= 0 */\n};\n\nstatic int trace_die_handler(struct notifier_block *self,\n\t\t\t     unsigned long val,\n\t\t\t     void *data)\n{\n\tswitch (val) {\n\tcase DIE_OOPS:\n\t\tif (ftrace_dump_on_oops)\n\t\t\tftrace_dump(ftrace_dump_on_oops);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block trace_die_notifier = {\n\t.notifier_call = trace_die_handler,\n\t.priority = 200\n};\n\n/*\n * printk is set to max of 1024, we really don't need it that big.\n * Nothing should be printing 1000 characters anyway.\n */\n#define TRACE_MAX_PRINT\t\t1000\n\n/*\n * Define here KERN_TRACE so that we have one place to modify\n * it if we decide to change what log level the ftrace dump\n * should be at.\n */\n#define KERN_TRACE\t\tKERN_EMERG\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}\n\nvoid trace_init_global_iter(struct trace_iterator *iter)\n{\n\titer->tr = &global_trace;\n\titer->trace = iter->tr->current_trace;\n\titer->cpu_file = RING_BUFFER_ALL_CPUS;\n\titer->array_buffer = &global_trace.array_buffer;\n\n\tif (iter->trace && iter->trace->open)\n\t\titer->trace->open(iter);\n\n\t/* Annotate start of buffers if we had overruns */\n\tif (ring_buffer_overruns(iter->array_buffer->buffer))\n\t\titer->iter_flags |= TRACE_FILE_ANNOTATE;\n\n\t/* Output in nanoseconds only if we are using a clock in nanoseconds. */\n\tif (trace_clocks[iter->tr->clock_id].in_ns)\n\t\titer->iter_flags |= TRACE_FILE_TIME_IN_NS;\n}\n\nvoid ftrace_dump(enum ftrace_dump_mode oops_dump_mode)\n{\n\t/* use static because iter can be a bit big for the stack */\n\tstatic struct trace_iterator iter;\n\tstatic atomic_t dump_running;\n\tstruct trace_array *tr = &global_trace;\n\tunsigned int old_userobj;\n\tunsigned long flags;\n\tint cnt = 0, cpu;\n\n\t/* Only allow one dump user at a time. */\n\tif (atomic_inc_return(&dump_running) != 1) {\n\t\tatomic_dec(&dump_running);\n\t\treturn;\n\t}\n\n\t/*\n\t * Always turn off tracing when we dump.\n\t * We don't need to show trace output of what happens\n\t * between multiple crashes.\n\t *\n\t * If the user does a sysrq-z, then they can re-enable\n\t * tracing with echo 1 > tracing_on.\n\t */\n\ttracing_off();\n\n\tlocal_irq_save(flags);\n\tprintk_nmi_direct_enter();\n\n\t/* Simulate the iterator */\n\ttrace_init_global_iter(&iter);\n\t/* Can not use kmalloc for iter.temp */\n\titer.temp = static_temp_buf;\n\titer.temp_size = STATIC_TEMP_BUF_SIZE;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\n\told_userobj = tr->trace_flags & TRACE_ITER_SYM_USEROBJ;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tswitch (oops_dump_mode) {\n\tcase DUMP_ALL:\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t\tbreak;\n\tcase DUMP_ORIG:\n\t\titer.cpu_file = raw_smp_processor_id();\n\t\tbreak;\n\tcase DUMP_NONE:\n\t\tgoto out_enable;\n\tdefault:\n\t\tprintk(KERN_TRACE \"Bad dumping mode, switching to all CPUs dump\\n\");\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tprintk(KERN_TRACE \"Dumping ftrace buffer:\\n\");\n\n\t/* Did function tracer already get disabled? */\n\tif (ftrace_is_dead()) {\n\t\tprintk(\"# WARNING: FUNCTION TRACING IS CORRUPTED\\n\");\n\t\tprintk(\"#          MAY BE MISSING FUNCTION EVENTS\\n\");\n\t}\n\n\t/*\n\t * We need to stop all tracing on all CPUS to read\n\t * the next buffer. This is a bit expensive, but is\n\t * not done often. We fill all what we can read,\n\t * and then release the locks again.\n\t */\n\n\twhile (!trace_empty(&iter)) {\n\n\t\tif (!cnt)\n\t\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n\t\tcnt++;\n\n\t\ttrace_iterator_reset(&iter);\n\t\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\n\t\tif (trace_find_next_entry_inc(&iter) != NULL) {\n\t\t\tint ret;\n\n\t\t\tret = print_trace_line(&iter);\n\t\t\tif (ret != TRACE_TYPE_NO_CONSUME)\n\t\t\t\ttrace_consume(&iter);\n\t\t}\n\t\ttouch_nmi_watchdog();\n\n\t\ttrace_printk_seq(&iter.seq);\n\t}\n\n\tif (!cnt)\n\t\tprintk(KERN_TRACE \"   (ftrace buffer empty)\\n\");\n\telse\n\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n out_enable:\n\ttr->trace_flags |= old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\tatomic_dec(&dump_running);\n\tprintk_nmi_direct_exit();\n\tlocal_irq_restore(flags);\n}\nEXPORT_SYMBOL_GPL(ftrace_dump);\n\nint trace_run_command(const char *buf, int (*createfn)(int, char **))\n{\n\tchar **argv;\n\tint argc, ret;\n\n\targc = 0;\n\tret = 0;\n\targv = argv_split(GFP_KERNEL, buf, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argc)\n\t\tret = createfn(argc, argv);\n\n\targv_free(argv);\n\n\treturn ret;\n}\n\n#define WRITE_BUFSIZE  4096\n\nssize_t trace_parse_run_command(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\tint (*createfn)(int, char **))\n{\n\tchar *kbuf, *buf, *tmp;\n\tint ret = 0;\n\tsize_t done = 0;\n\tsize_t size;\n\n\tkbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\twhile (done < count) {\n\t\tsize = count - done;\n\n\t\tif (size >= WRITE_BUFSIZE)\n\t\t\tsize = WRITE_BUFSIZE - 1;\n\n\t\tif (copy_from_user(kbuf, buffer + done, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkbuf[size] = '\\0';\n\t\tbuf = kbuf;\n\t\tdo {\n\t\t\ttmp = strchr(buf, '\\n');\n\t\t\tif (tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tsize = tmp - buf + 1;\n\t\t\t} else {\n\t\t\t\tsize = strlen(buf);\n\t\t\t\tif (done + size < count) {\n\t\t\t\t\tif (buf != kbuf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/* This can accept WRITE_BUFSIZE - 2 ('\\n' + '\\0') */\n\t\t\t\t\tpr_warn(\"Line length is too long: Should be less than %d\\n\",\n\t\t\t\t\t\tWRITE_BUFSIZE - 2);\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone += size;\n\n\t\t\t/* Remove comments */\n\t\t\ttmp = strchr(buf, '#');\n\n\t\t\tif (tmp)\n\t\t\t\t*tmp = '\\0';\n\n\t\t\tret = trace_run_command(buf, createfn);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbuf += size;\n\n\t\t} while (done < count);\n\t}\n\tret = done;\n\nout:\n\tkfree(kbuf);\n\n\treturn ret;\n}\n\n__init static int tracer_alloc_buffers(void)\n{\n\tint ring_buf_size;\n\tint ret = -ENOMEM;\n\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * Make sure we don't accidentally add more trace options\n\t * than we have bits for.\n\t */\n\tBUILD_BUG_ON(TRACE_ITER_LAST_BIT > TRACE_FLAGS_MAX_SIZE);\n\n\tif (!alloc_cpumask_var(&tracing_buffer_mask, GFP_KERNEL))\n\t\tgoto out;\n\n\tif (!alloc_cpumask_var(&global_trace.tracing_cpumask, GFP_KERNEL))\n\t\tgoto out_free_buffer_mask;\n\n\t/* Only allocate trace_printk buffers if a trace_printk exists */\n\tif (&__stop___trace_bprintk_fmt != &__start___trace_bprintk_fmt)\n\t\t/* Must be called before global_trace.buffer is allocated */\n\t\ttrace_printk_init_buffers();\n\n\t/* To save memory, keep the ring buffer size to its minimum */\n\tif (ring_buffer_expanded)\n\t\tring_buf_size = trace_buf_size;\n\telse\n\t\tring_buf_size = 1;\n\n\tcpumask_copy(tracing_buffer_mask, cpu_possible_mask);\n\tcpumask_copy(global_trace.tracing_cpumask, cpu_all_mask);\n\n\traw_spin_lock_init(&global_trace.start_lock);\n\n\t/*\n\t * The prepare callbacks allocates some memory for the ring buffer. We\n\t * don't free the buffer if the CPU goes down. If we were to free\n\t * the buffer, then the user would lose any trace that was in the\n\t * buffer. The memory will be removed once the \"instance\" is removed.\n\t */\n\tret = cpuhp_setup_state_multi(CPUHP_TRACE_RB_PREPARE,\n\t\t\t\t      \"trace/RB:preapre\", trace_rb_cpu_prepare,\n\t\t\t\t      NULL);\n\tif (ret < 0)\n\t\tgoto out_free_cpumask;\n\t/* Used for event triggers */\n\tret = -ENOMEM;\n\ttemp_buffer = ring_buffer_alloc(PAGE_SIZE, RB_FL_OVERWRITE);\n\tif (!temp_buffer)\n\t\tgoto out_rm_hp_state;\n\n\tif (trace_create_savedcmd() < 0)\n\t\tgoto out_free_temp_buffer;\n\n\t/* TODO: make the number of buffers hot pluggable with CPUS */\n\tif (allocate_trace_buffers(&global_trace, ring_buf_size) < 0) {\n\t\tMEM_FAIL(1, \"tracer: failed to allocate ring buffer!\\n\");\n\t\tgoto out_free_savedcmd;\n\t}\n\n\tif (global_trace.buffer_disabled)\n\t\ttracing_off();\n\n\tif (trace_boot_clock) {\n\t\tret = tracing_set_clock(&global_trace, trace_boot_clock);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Trace clock %s not defined, going back to default\\n\",\n\t\t\t\ttrace_boot_clock);\n\t}\n\n\t/*\n\t * register_tracer() might reference current_trace, so it\n\t * needs to be set before we register anything. This is\n\t * just a bootstrap of current_trace anyway.\n\t */\n\tglobal_trace.current_trace = &nop_trace;\n\n\tglobal_trace.max_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\n\tftrace_init_global_array_ops(&global_trace);\n\n\tinit_trace_flags_index(&global_trace);\n\n\tregister_tracer(&nop_trace);\n\n\t/* Function tracing may start here (via kernel command line) */\n\tinit_function_trace();\n\n\t/* All seems OK, enable tracing */\n\ttracing_disabled = 0;\n\n\tatomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t       &trace_panic_notifier);\n\n\tregister_die_notifier(&trace_die_notifier);\n\n\tglobal_trace.flags = TRACE_ARRAY_FL_GLOBAL;\n\n\tINIT_LIST_HEAD(&global_trace.systems);\n\tINIT_LIST_HEAD(&global_trace.events);\n\tINIT_LIST_HEAD(&global_trace.hist_vars);\n\tINIT_LIST_HEAD(&global_trace.err_log);\n\tlist_add(&global_trace.list, &ftrace_trace_arrays);\n\n\tapply_trace_boot_options();\n\n\tregister_snapshot_cmd();\n\n\treturn 0;\n\nout_free_savedcmd:\n\tfree_saved_cmdlines_buffer(savedcmd);\nout_free_temp_buffer:\n\tring_buffer_free(temp_buffer);\nout_rm_hp_state:\n\tcpuhp_remove_multi_state(CPUHP_TRACE_RB_PREPARE);\nout_free_cpumask:\n\tfree_cpumask_var(global_trace.tracing_cpumask);\nout_free_buffer_mask:\n\tfree_cpumask_var(tracing_buffer_mask);\nout:\n\treturn ret;\n}\n\nvoid __init early_trace_init(void)\n{\n\tif (tracepoint_printk) {\n\t\ttracepoint_print_iter =\n\t\t\tkmalloc(sizeof(*tracepoint_print_iter), GFP_KERNEL);\n\t\tif (MEM_FAIL(!tracepoint_print_iter,\n\t\t\t     \"Failed to allocate trace iterator\\n\"))\n\t\t\ttracepoint_printk = 0;\n\t\telse\n\t\t\tstatic_key_enable(&tracepoint_printk_key.key);\n\t}\n\ttracer_alloc_buffers();\n}\n\nvoid __init trace_init(void)\n{\n\ttrace_event_init();\n}\n\n__init static int clear_boot_tracer(void)\n{\n\t/*\n\t * The default tracer at boot buffer is an init section.\n\t * This function is called in lateinit. If we did not\n\t * find the boot tracer, then clear it out, to prevent\n\t * later registration from accessing the buffer that is\n\t * about to be freed.\n\t */\n\tif (!default_bootup_tracer)\n\t\treturn 0;\n\n\tprintk(KERN_INFO \"ftrace bootup tracer '%s' not registered.\\n\",\n\t       default_bootup_tracer);\n\tdefault_bootup_tracer = NULL;\n\n\treturn 0;\n}\n\nfs_initcall(tracer_init_tracefs);\nlate_initcall_sync(clear_boot_tracer);\n\n#ifdef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK\n__init static int tracing_set_default_clock(void)\n{\n\t/* sched_clock_stable() is determined in late_initcall */\n\tif (!trace_boot_clock && !sched_clock_stable()) {\n\t\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\t\tpr_warn(\"Can not set tracing clock due to lockdown\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\tprintk(KERN_WARNING\n\t\t       \"Unstable clock detected, switching default tracing clock to \\\"global\\\"\\n\"\n\t\t       \"If you want to keep using the local clock, then add:\\n\"\n\t\t       \"  \\\"trace_clock=local\\\"\\n\"\n\t\t       \"on the kernel command line\\n\");\n\t\ttracing_set_clock(&global_trace, \"global\");\n\t}\n\n\treturn 0;\n}\nlate_initcall_sync(tracing_set_default_clock);\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 3, "file": 0, "line": 6241}, "message": "preceding lock on line 6260"}], "macros": [], "notes": [], "path": "/src/kernel/trace/trace.c", "reportHash": "f582ebc261a1c008f23c9f1979421d45", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 0, "line": 6263}, "message": "preceding lock on line 6260"}], "macros": [], "notes": [], "path": "/src/kernel/trace/trace.c", "reportHash": "125f21fd22108908354bcca2e0fd6d96", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
