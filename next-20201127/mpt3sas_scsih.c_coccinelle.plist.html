<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/scsi/mpt3sas/mpt3sas_scsih.c", "content": "/*\n * Scsi Host Layer for MPT (Message Passing Technology) based controllers\n *\n * This code is based on drivers/scsi/mpt3sas/mpt3sas_scsih.c\n * Copyright (C) 2012-2014  LSI Corporation\n * Copyright (C) 2013-2014 Avago Technologies\n *  (mailto: MPT-FusionLinux.pdl@avagotech.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * NO WARRANTY\n * THE PROGRAM IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT\n * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,\n * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is\n * solely responsible for determining the appropriateness of using and\n * distributing the Program and assumes all risks associated with its\n * exercise of rights under this Agreement, including but not limited to\n * the risks and costs of program errors, damage to or loss of data,\n * programs or equipment, and unavailability or interruption of operations.\n\n * DISCLAIMER OF LIABILITY\n * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED\n * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES\n\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/blkdev.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/aer.h>\n#include <linux/raid_class.h>\n#include <asm/unaligned.h>\n\n#include \"mpt3sas_base.h\"\n\n#define RAID_CHANNEL 1\n\n#define PCIE_CHANNEL 2\n\n/* forward proto's */\nstatic void _scsih_expander_node_remove(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_node *sas_expander);\nstatic void _firmware_event_work(struct work_struct *work);\n\nstatic void _scsih_remove_device(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_device *sas_device);\nstatic int _scsih_add_device(struct MPT3SAS_ADAPTER *ioc, u16 handle,\n\tu8 retry_count, u8 is_pd);\nstatic int _scsih_pcie_add_device(struct MPT3SAS_ADAPTER *ioc, u16 handle);\nstatic void _scsih_pcie_device_remove_from_sml(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _pcie_device *pcie_device);\nstatic void\n_scsih_pcie_check_device(struct MPT3SAS_ADAPTER *ioc, u16 handle);\nstatic u8 _scsih_check_for_pending_tm(struct MPT3SAS_ADAPTER *ioc, u16 smid);\n\n/* global parameters */\nLIST_HEAD(mpt3sas_ioc_list);\n/* global ioc lock for list operations */\nDEFINE_SPINLOCK(gioc_lock);\n\nMODULE_AUTHOR(MPT3SAS_AUTHOR);\nMODULE_DESCRIPTION(MPT3SAS_DESCRIPTION);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(MPT3SAS_DRIVER_VERSION);\nMODULE_ALIAS(\"mpt2sas\");\n\n/* local parameters */\nstatic u8 scsi_io_cb_idx = -1;\nstatic u8 tm_cb_idx = -1;\nstatic u8 ctl_cb_idx = -1;\nstatic u8 base_cb_idx = -1;\nstatic u8 port_enable_cb_idx = -1;\nstatic u8 transport_cb_idx = -1;\nstatic u8 scsih_cb_idx = -1;\nstatic u8 config_cb_idx = -1;\nstatic int mpt2_ids;\nstatic int mpt3_ids;\n\nstatic u8 tm_tr_cb_idx = -1 ;\nstatic u8 tm_tr_volume_cb_idx = -1 ;\nstatic u8 tm_sas_control_cb_idx = -1;\n\n/* command line options */\nstatic u32 logging_level;\nMODULE_PARM_DESC(logging_level,\n\t\" bits for enabling additional logging info (default=0)\");\n\n\nstatic ushort max_sectors = 0xFFFF;\nmodule_param(max_sectors, ushort, 0444);\nMODULE_PARM_DESC(max_sectors, \"max sectors, range 64 to 32767  default=32767\");\n\n\nstatic int missing_delay[2] = {-1, -1};\nmodule_param_array(missing_delay, int, NULL, 0444);\nMODULE_PARM_DESC(missing_delay, \" device missing delay , io missing delay\");\n\n/* scsi-mid layer global parmeter is max_report_luns, which is 511 */\n#define MPT3SAS_MAX_LUN (16895)\nstatic u64 max_lun = MPT3SAS_MAX_LUN;\nmodule_param(max_lun, ullong, 0444);\nMODULE_PARM_DESC(max_lun, \" max lun, default=16895 \");\n\nstatic ushort hbas_to_enumerate;\nmodule_param(hbas_to_enumerate, ushort, 0444);\nMODULE_PARM_DESC(hbas_to_enumerate,\n\t\t\" 0 - enumerates both SAS 2.0 & SAS 3.0 generation HBAs\\n \\\n\t\t  1 - enumerates only SAS 2.0 generation HBAs\\n \\\n\t\t  2 - enumerates only SAS 3.0 generation HBAs (default=0)\");\n\n/* diag_buffer_enable is bitwise\n * bit 0 set = TRACE\n * bit 1 set = SNAPSHOT\n * bit 2 set = EXTENDED\n *\n * Either bit can be set, or both\n */\nstatic int diag_buffer_enable = -1;\nmodule_param(diag_buffer_enable, int, 0444);\nMODULE_PARM_DESC(diag_buffer_enable,\n\t\" post diag buffers (TRACE=1/SNAPSHOT=2/EXTENDED=4/default=0)\");\nstatic int disable_discovery = -1;\nmodule_param(disable_discovery, int, 0444);\nMODULE_PARM_DESC(disable_discovery, \" disable discovery \");\n\n\n/* permit overriding the host protection capabilities mask (EEDP/T10 PI) */\nstatic int prot_mask = -1;\nmodule_param(prot_mask, int, 0444);\nMODULE_PARM_DESC(prot_mask, \" host protection capabilities mask, def=7 \");\n\nstatic bool enable_sdev_max_qd;\nmodule_param(enable_sdev_max_qd, bool, 0444);\nMODULE_PARM_DESC(enable_sdev_max_qd,\n\t\"Enable sdev max qd as can_queue, def=disabled(0)\");\n\nstatic int multipath_on_hba = -1;\nmodule_param(multipath_on_hba, int, 0);\nMODULE_PARM_DESC(multipath_on_hba,\n\t\"Multipath support to add same target device\\n\\t\\t\"\n\t\"as many times as it is visible to HBA from various paths\\n\\t\\t\"\n\t\"(by default:\\n\\t\\t\"\n\t\"\\t SAS 2.0 & SAS 3.0 HBA - This will be disabled,\\n\\t\\t\"\n\t\"\\t SAS 3.5 HBA - This will be enabled)\");\n\n/* raid transport support */\nstatic struct raid_template *mpt3sas_raid_template;\nstatic struct raid_template *mpt2sas_raid_template;\n\n\n/**\n * struct sense_info - common structure for obtaining sense keys\n * @skey: sense key\n * @asc: additional sense code\n * @ascq: additional sense code qualifier\n */\nstruct sense_info {\n\tu8 skey;\n\tu8 asc;\n\tu8 ascq;\n};\n\n#define MPT3SAS_PROCESS_TRIGGER_DIAG (0xFFFB)\n#define MPT3SAS_TURN_ON_PFA_LED (0xFFFC)\n#define MPT3SAS_PORT_ENABLE_COMPLETE (0xFFFD)\n#define MPT3SAS_ABRT_TASK_SET (0xFFFE)\n#define MPT3SAS_REMOVE_UNRESPONDING_DEVICES (0xFFFF)\n/**\n * struct fw_event_work - firmware event struct\n * @list: link list framework\n * @work: work object (ioc->fault_reset_work_q)\n * @ioc: per adapter object\n * @device_handle: device handle\n * @VF_ID: virtual function id\n * @VP_ID: virtual port id\n * @ignore: flag meaning this event has been marked to ignore\n * @event: firmware event MPI2_EVENT_XXX defined in mpi2_ioc.h\n * @refcount: kref for this event\n * @event_data: reply event data payload follows\n *\n * This object stored on ioc->fw_event_list.\n */\nstruct fw_event_work {\n\tstruct list_head\tlist;\n\tstruct work_struct\twork;\n\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tu16\t\t\tdevice_handle;\n\tu8\t\t\tVF_ID;\n\tu8\t\t\tVP_ID;\n\tu8\t\t\tignore;\n\tu16\t\t\tevent;\n\tstruct kref\t\trefcount;\n\tchar\t\t\tevent_data[] __aligned(4);\n};\n\nstatic void fw_event_work_free(struct kref *r)\n{\n\tkfree(container_of(r, struct fw_event_work, refcount));\n}\n\nstatic void fw_event_work_get(struct fw_event_work *fw_work)\n{\n\tkref_get(&fw_work->refcount);\n}\n\nstatic void fw_event_work_put(struct fw_event_work *fw_work)\n{\n\tkref_put(&fw_work->refcount, fw_event_work_free);\n}\n\nstatic struct fw_event_work *alloc_fw_event_work(int len)\n{\n\tstruct fw_event_work *fw_event;\n\n\tfw_event = kzalloc(sizeof(*fw_event) + len, GFP_ATOMIC);\n\tif (!fw_event)\n\t\treturn NULL;\n\n\tkref_init(&fw_event->refcount);\n\treturn fw_event;\n}\n\n/**\n * struct _scsi_io_transfer - scsi io transfer\n * @handle: sas device handle (assigned by firmware)\n * @is_raid: flag set for hidden raid components\n * @dir: DMA_TO_DEVICE, DMA_FROM_DEVICE,\n * @data_length: data transfer length\n * @data_dma: dma pointer to data\n * @sense: sense data\n * @lun: lun number\n * @cdb_length: cdb length\n * @cdb: cdb contents\n * @timeout: timeout for this command\n * @VF_ID: virtual function id\n * @VP_ID: virtual port id\n * @valid_reply: flag set for reply message\n * @sense_length: sense length\n * @ioc_status: ioc status\n * @scsi_state: scsi state\n * @scsi_status: scsi staus\n * @log_info: log information\n * @transfer_length: data length transfer when there is a reply message\n *\n * Used for sending internal scsi commands to devices within this module.\n * Refer to _scsi_send_scsi_io().\n */\nstruct _scsi_io_transfer {\n\tu16\thandle;\n\tu8\tis_raid;\n\tenum dma_data_direction dir;\n\tu32\tdata_length;\n\tdma_addr_t data_dma;\n\tu8\tsense[SCSI_SENSE_BUFFERSIZE];\n\tu32\tlun;\n\tu8\tcdb_length;\n\tu8\tcdb[32];\n\tu8\ttimeout;\n\tu8\tVF_ID;\n\tu8\tVP_ID;\n\tu8\tvalid_reply;\n  /* the following bits are only valid when 'valid_reply = 1' */\n\tu32\tsense_length;\n\tu16\tioc_status;\n\tu8\tscsi_state;\n\tu8\tscsi_status;\n\tu32\tlog_info;\n\tu32\ttransfer_length;\n};\n\n/**\n * _scsih_set_debug_level - global setting of ioc->logging_level.\n * @val: ?\n * @kp: ?\n *\n * Note: The logging levels are defined in mpt3sas_debug.h.\n */\nstatic int\n_scsih_set_debug_level(const char *val, const struct kernel_param *kp)\n{\n\tint ret = param_set_int(val, kp);\n\tstruct MPT3SAS_ADAPTER *ioc;\n\n\tif (ret)\n\t\treturn ret;\n\n\tpr_info(\"setting logging_level(0x%08x)\\n\", logging_level);\n\tspin_lock(&gioc_lock);\n\tlist_for_each_entry(ioc, &mpt3sas_ioc_list, list)\n\t\tioc->logging_level = logging_level;\n\tspin_unlock(&gioc_lock);\n\treturn 0;\n}\nmodule_param_call(logging_level, _scsih_set_debug_level, param_get_int,\n\t&logging_level, 0644);\n\n/**\n * _scsih_srch_boot_sas_address - search based on sas_address\n * @sas_address: sas address\n * @boot_device: boot device object from bios page 2\n *\n * Return: 1 when there's a match, 0 means no match.\n */\nstatic inline int\n_scsih_srch_boot_sas_address(u64 sas_address,\n\tMpi2BootDeviceSasWwid_t *boot_device)\n{\n\treturn (sas_address == le64_to_cpu(boot_device->SASAddress)) ?  1 : 0;\n}\n\n/**\n * _scsih_srch_boot_device_name - search based on device name\n * @device_name: device name specified in INDENTIFY fram\n * @boot_device: boot device object from bios page 2\n *\n * Return: 1 when there's a match, 0 means no match.\n */\nstatic inline int\n_scsih_srch_boot_device_name(u64 device_name,\n\tMpi2BootDeviceDeviceName_t *boot_device)\n{\n\treturn (device_name == le64_to_cpu(boot_device->DeviceName)) ? 1 : 0;\n}\n\n/**\n * _scsih_srch_boot_encl_slot - search based on enclosure_logical_id/slot\n * @enclosure_logical_id: enclosure logical id\n * @slot_number: slot number\n * @boot_device: boot device object from bios page 2\n *\n * Return: 1 when there's a match, 0 means no match.\n */\nstatic inline int\n_scsih_srch_boot_encl_slot(u64 enclosure_logical_id, u16 slot_number,\n\tMpi2BootDeviceEnclosureSlot_t *boot_device)\n{\n\treturn (enclosure_logical_id == le64_to_cpu(boot_device->\n\t    EnclosureLogicalID) && slot_number == le16_to_cpu(boot_device->\n\t    SlotNumber)) ? 1 : 0;\n}\n\n/**\n * mpt3sas_get_port_by_id - get hba port entry corresponding to provided\n *\t\t\t  port number from port list\n * @ioc: per adapter object\n * @port_id: port number\n * @bypass_dirty_port_flag: when set look the matching hba port entry even\n *\t\t\tif hba port entry is marked as dirty.\n *\n * Search for hba port entry corresponding to provided port number,\n * if available return port object otherwise return NULL.\n */\nstruct hba_port *\nmpt3sas_get_port_by_id(struct MPT3SAS_ADAPTER *ioc,\n\tu8 port_id, u8 bypass_dirty_port_flag)\n{\n\tstruct hba_port *port, *port_next;\n\n\t/*\n\t * When multipath_on_hba is disabled then\n\t * search the hba_port entry using default\n\t * port id i.e. 255\n\t */\n\tif (!ioc->multipath_on_hba)\n\t\tport_id = MULTIPATH_DISABLED_PORT_ID;\n\n\tlist_for_each_entry_safe(port, port_next,\n\t    &ioc->port_table_list, list) {\n\t\tif (port->port_id != port_id)\n\t\t\tcontinue;\n\t\tif (bypass_dirty_port_flag)\n\t\t\treturn port;\n\t\tif (port->flags & HBA_PORT_FLAG_DIRTY_PORT)\n\t\t\tcontinue;\n\t\treturn port;\n\t}\n\n\t/*\n\t * Allocate hba_port object for default port id (i.e. 255)\n\t * when multipath_on_hba is disabled for the HBA.\n\t * And add this object to port_table_list.\n\t */\n\tif (!ioc->multipath_on_hba) {\n\t\tport = kzalloc(sizeof(struct hba_port), GFP_KERNEL);\n\t\tif (!port)\n\t\t\treturn NULL;\n\n\t\tport->port_id = port_id;\n\t\tioc_info(ioc,\n\t\t   \"hba_port entry: %p, port: %d is added to hba_port list\\n\",\n\t\t   port, port->port_id);\n\t\tlist_add_tail(&port->list,\n\t\t    &ioc->port_table_list);\n\t\treturn port;\n\t}\n\treturn NULL;\n}\n\n/**\n * mpt3sas_get_vphy_by_phy - get virtual_phy object corresponding to phy number\n * @ioc: per adapter object\n * @port: hba_port object\n * @phy: phy number\n *\n * Return virtual_phy object corresponding to phy number.\n */\nstruct virtual_phy *\nmpt3sas_get_vphy_by_phy(struct MPT3SAS_ADAPTER *ioc,\n\tstruct hba_port *port, u32 phy)\n{\n\tstruct virtual_phy *vphy, *vphy_next;\n\n\tif (!port->vphys_mask)\n\t\treturn NULL;\n\n\tlist_for_each_entry_safe(vphy, vphy_next, &port->vphys_list, list) {\n\t\tif (vphy->phy_mask & (1 << phy))\n\t\t\treturn vphy;\n\t}\n\treturn NULL;\n}\n\n/**\n * _scsih_is_boot_device - search for matching boot device.\n * @sas_address: sas address\n * @device_name: device name specified in INDENTIFY fram\n * @enclosure_logical_id: enclosure logical id\n * @slot: slot number\n * @form: specifies boot device form\n * @boot_device: boot device object from bios page 2\n *\n * Return: 1 when there's a match, 0 means no match.\n */\nstatic int\n_scsih_is_boot_device(u64 sas_address, u64 device_name,\n\tu64 enclosure_logical_id, u16 slot, u8 form,\n\tMpi2BiosPage2BootDevice_t *boot_device)\n{\n\tint rc = 0;\n\n\tswitch (form) {\n\tcase MPI2_BIOSPAGE2_FORM_SAS_WWID:\n\t\tif (!sas_address)\n\t\t\tbreak;\n\t\trc = _scsih_srch_boot_sas_address(\n\t\t    sas_address, &boot_device->SasWwid);\n\t\tbreak;\n\tcase MPI2_BIOSPAGE2_FORM_ENCLOSURE_SLOT:\n\t\tif (!enclosure_logical_id)\n\t\t\tbreak;\n\t\trc = _scsih_srch_boot_encl_slot(\n\t\t    enclosure_logical_id,\n\t\t    slot, &boot_device->EnclosureSlot);\n\t\tbreak;\n\tcase MPI2_BIOSPAGE2_FORM_DEVICE_NAME:\n\t\tif (!device_name)\n\t\t\tbreak;\n\t\trc = _scsih_srch_boot_device_name(\n\t\t    device_name, &boot_device->DeviceName);\n\t\tbreak;\n\tcase MPI2_BIOSPAGE2_FORM_NO_DEVICE_SPECIFIED:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n/**\n * _scsih_get_sas_address - set the sas_address for given device handle\n * @ioc: ?\n * @handle: device handle\n * @sas_address: sas address\n *\n * Return: 0 success, non-zero when failure\n */\nstatic int\n_scsih_get_sas_address(struct MPT3SAS_ADAPTER *ioc, u16 handle,\n\tu64 *sas_address)\n{\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu32 ioc_status;\n\n\t*sas_address = 0;\n\n\tif ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\n\t    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -ENXIO;\n\t}\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status == MPI2_IOCSTATUS_SUCCESS) {\n\t\t/* For HBA, vSES doesn't return HBA SAS address. Instead return\n\t\t * vSES's sas address.\n\t\t */\n\t\tif ((handle <= ioc->sas_hba.num_phys) &&\n\t\t   (!(le32_to_cpu(sas_device_pg0.DeviceInfo) &\n\t\t   MPI2_SAS_DEVICE_INFO_SEP)))\n\t\t\t*sas_address = ioc->sas_hba.sas_address;\n\t\telse\n\t\t\t*sas_address = le64_to_cpu(sas_device_pg0.SASAddress);\n\t\treturn 0;\n\t}\n\n\t/* we hit this because the given parent handle doesn't exist */\n\tif (ioc_status == MPI2_IOCSTATUS_CONFIG_INVALID_PAGE)\n\t\treturn -ENXIO;\n\n\t/* else error case */\n\tioc_err(ioc, \"handle(0x%04x), ioc_status(0x%04x), failure at %s:%d/%s()!\\n\",\n\t\thandle, ioc_status, __FILE__, __LINE__, __func__);\n\treturn -EIO;\n}\n\n/**\n * _scsih_determine_boot_device - determine boot device.\n * @ioc: per adapter object\n * @device: sas_device or pcie_device object\n * @channel: SAS or PCIe channel\n *\n * Determines whether this device should be first reported device to\n * to scsi-ml or sas transport, this purpose is for persistent boot device.\n * There are primary, alternate, and current entries in bios page 2. The order\n * priority is primary, alternate, then current.  This routine saves\n * the corresponding device object.\n * The saved data to be used later in _scsih_probe_boot_devices().\n */\nstatic void\n_scsih_determine_boot_device(struct MPT3SAS_ADAPTER *ioc, void *device,\n\tu32 channel)\n{\n\tstruct _sas_device *sas_device;\n\tstruct _pcie_device *pcie_device;\n\tstruct _raid_device *raid_device;\n\tu64 sas_address;\n\tu64 device_name;\n\tu64 enclosure_logical_id;\n\tu16 slot;\n\n\t /* only process this function when driver loads */\n\tif (!ioc->is_driver_loading)\n\t\treturn;\n\n\t /* no Bios, return immediately */\n\tif (!ioc->bios_pg3.BiosVersion)\n\t\treturn;\n\n\tif (channel == RAID_CHANNEL) {\n\t\traid_device = device;\n\t\tsas_address = raid_device->wwid;\n\t\tdevice_name = 0;\n\t\tenclosure_logical_id = 0;\n\t\tslot = 0;\n\t} else if (channel == PCIE_CHANNEL) {\n\t\tpcie_device = device;\n\t\tsas_address = pcie_device->wwid;\n\t\tdevice_name = 0;\n\t\tenclosure_logical_id = 0;\n\t\tslot = 0;\n\t} else {\n\t\tsas_device = device;\n\t\tsas_address = sas_device->sas_address;\n\t\tdevice_name = sas_device->device_name;\n\t\tenclosure_logical_id = sas_device->enclosure_logical_id;\n\t\tslot = sas_device->slot;\n\t}\n\n\tif (!ioc->req_boot_device.device) {\n\t\tif (_scsih_is_boot_device(sas_address, device_name,\n\t\t    enclosure_logical_id, slot,\n\t\t    (ioc->bios_pg2.ReqBootDeviceForm &\n\t\t    MPI2_BIOSPAGE2_FORM_MASK),\n\t\t    &ioc->bios_pg2.RequestedBootDevice)) {\n\t\t\tdinitprintk(ioc,\n\t\t\t\t    ioc_info(ioc, \"%s: req_boot_device(0x%016llx)\\n\",\n\t\t\t\t\t     __func__, (u64)sas_address));\n\t\t\tioc->req_boot_device.device = device;\n\t\t\tioc->req_boot_device.channel = channel;\n\t\t}\n\t}\n\n\tif (!ioc->req_alt_boot_device.device) {\n\t\tif (_scsih_is_boot_device(sas_address, device_name,\n\t\t    enclosure_logical_id, slot,\n\t\t    (ioc->bios_pg2.ReqAltBootDeviceForm &\n\t\t    MPI2_BIOSPAGE2_FORM_MASK),\n\t\t    &ioc->bios_pg2.RequestedAltBootDevice)) {\n\t\t\tdinitprintk(ioc,\n\t\t\t\t    ioc_info(ioc, \"%s: req_alt_boot_device(0x%016llx)\\n\",\n\t\t\t\t\t     __func__, (u64)sas_address));\n\t\t\tioc->req_alt_boot_device.device = device;\n\t\t\tioc->req_alt_boot_device.channel = channel;\n\t\t}\n\t}\n\n\tif (!ioc->current_boot_device.device) {\n\t\tif (_scsih_is_boot_device(sas_address, device_name,\n\t\t    enclosure_logical_id, slot,\n\t\t    (ioc->bios_pg2.CurrentBootDeviceForm &\n\t\t    MPI2_BIOSPAGE2_FORM_MASK),\n\t\t    &ioc->bios_pg2.CurrentBootDevice)) {\n\t\t\tdinitprintk(ioc,\n\t\t\t\t    ioc_info(ioc, \"%s: current_boot_device(0x%016llx)\\n\",\n\t\t\t\t\t     __func__, (u64)sas_address));\n\t\t\tioc->current_boot_device.device = device;\n\t\t\tioc->current_boot_device.channel = channel;\n\t\t}\n\t}\n}\n\nstatic struct _sas_device *\n__mpt3sas_get_sdev_from_target(struct MPT3SAS_ADAPTER *ioc,\n\t\tstruct MPT3SAS_TARGET *tgt_priv)\n{\n\tstruct _sas_device *ret;\n\n\tassert_spin_locked(&ioc->sas_device_lock);\n\n\tret = tgt_priv->sas_dev;\n\tif (ret)\n\t\tsas_device_get(ret);\n\n\treturn ret;\n}\n\nstatic struct _sas_device *\nmpt3sas_get_sdev_from_target(struct MPT3SAS_ADAPTER *ioc,\n\t\tstruct MPT3SAS_TARGET *tgt_priv)\n{\n\tstruct _sas_device *ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tret = __mpt3sas_get_sdev_from_target(ioc, tgt_priv);\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\treturn ret;\n}\n\nstatic struct _pcie_device *\n__mpt3sas_get_pdev_from_target(struct MPT3SAS_ADAPTER *ioc,\n\tstruct MPT3SAS_TARGET *tgt_priv)\n{\n\tstruct _pcie_device *ret;\n\n\tassert_spin_locked(&ioc->pcie_device_lock);\n\n\tret = tgt_priv->pcie_dev;\n\tif (ret)\n\t\tpcie_device_get(ret);\n\n\treturn ret;\n}\n\n/**\n * mpt3sas_get_pdev_from_target - pcie device search\n * @ioc: per adapter object\n * @tgt_priv: starget private object\n *\n * Context: This function will acquire ioc->pcie_device_lock and will release\n * before returning the pcie_device object.\n *\n * This searches for pcie_device from target, then return pcie_device object.\n */\nstatic struct _pcie_device *\nmpt3sas_get_pdev_from_target(struct MPT3SAS_ADAPTER *ioc,\n\tstruct MPT3SAS_TARGET *tgt_priv)\n{\n\tstruct _pcie_device *ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tret = __mpt3sas_get_pdev_from_target(ioc, tgt_priv);\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\treturn ret;\n}\n\n\n/**\n * __mpt3sas_get_sdev_by_rphy - sas device search\n * @ioc: per adapter object\n * @rphy: sas_rphy pointer\n *\n * Context: This function will acquire ioc->sas_device_lock and will release\n * before returning the sas_device object.\n *\n * This searches for sas_device from rphy object\n * then return sas_device object.\n */\nstruct _sas_device *\n__mpt3sas_get_sdev_by_rphy(struct MPT3SAS_ADAPTER *ioc,\n\tstruct sas_rphy *rphy)\n{\n\tstruct _sas_device *sas_device;\n\n\tassert_spin_locked(&ioc->sas_device_lock);\n\n\tlist_for_each_entry(sas_device, &ioc->sas_device_list, list) {\n\t\tif (sas_device->rphy != rphy)\n\t\t\tcontinue;\n\t\tsas_device_get(sas_device);\n\t\treturn sas_device;\n\t}\n\n\tsas_device = NULL;\n\tlist_for_each_entry(sas_device, &ioc->sas_device_init_list, list) {\n\t\tif (sas_device->rphy != rphy)\n\t\t\tcontinue;\n\t\tsas_device_get(sas_device);\n\t\treturn sas_device;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * mpt3sas_get_sdev_by_addr - get _sas_device object corresponding to provided\n *\t\t\t\tsas address from sas_device_list list\n * @ioc: per adapter object\n * @port: port number\n *\n * Search for _sas_device object corresponding to provided sas address,\n * if available return _sas_device object address otherwise return NULL.\n */\nstruct _sas_device *\n__mpt3sas_get_sdev_by_addr(struct MPT3SAS_ADAPTER *ioc,\n\tu64 sas_address, struct hba_port *port)\n{\n\tstruct _sas_device *sas_device;\n\n\tif (!port)\n\t\treturn NULL;\n\n\tassert_spin_locked(&ioc->sas_device_lock);\n\n\tlist_for_each_entry(sas_device, &ioc->sas_device_list, list) {\n\t\tif (sas_device->sas_address != sas_address)\n\t\t\tcontinue;\n\t\tif (sas_device->port != port)\n\t\t\tcontinue;\n\t\tsas_device_get(sas_device);\n\t\treturn sas_device;\n\t}\n\n\tlist_for_each_entry(sas_device, &ioc->sas_device_init_list, list) {\n\t\tif (sas_device->sas_address != sas_address)\n\t\t\tcontinue;\n\t\tif (sas_device->port != port)\n\t\t\tcontinue;\n\t\tsas_device_get(sas_device);\n\t\treturn sas_device;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * mpt3sas_get_sdev_by_addr - sas device search\n * @ioc: per adapter object\n * @sas_address: sas address\n * @port: hba port entry\n * Context: Calling function should acquire ioc->sas_device_lock\n *\n * This searches for sas_device based on sas_address & port number,\n * then return sas_device object.\n */\nstruct _sas_device *\nmpt3sas_get_sdev_by_addr(struct MPT3SAS_ADAPTER *ioc,\n\tu64 sas_address, struct hba_port *port)\n{\n\tstruct _sas_device *sas_device;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_addr(ioc,\n\t    sas_address, port);\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\treturn sas_device;\n}\n\nstatic struct _sas_device *\n__mpt3sas_get_sdev_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _sas_device *sas_device;\n\n\tassert_spin_locked(&ioc->sas_device_lock);\n\n\tlist_for_each_entry(sas_device, &ioc->sas_device_list, list)\n\t\tif (sas_device->handle == handle)\n\t\t\tgoto found_device;\n\n\tlist_for_each_entry(sas_device, &ioc->sas_device_init_list, list)\n\t\tif (sas_device->handle == handle)\n\t\t\tgoto found_device;\n\n\treturn NULL;\n\nfound_device:\n\tsas_device_get(sas_device);\n\treturn sas_device;\n}\n\n/**\n * mpt3sas_get_sdev_by_handle - sas device search\n * @ioc: per adapter object\n * @handle: sas device handle (assigned by firmware)\n * Context: Calling function should acquire ioc->sas_device_lock\n *\n * This searches for sas_device based on sas_address, then return sas_device\n * object.\n */\nstruct _sas_device *\nmpt3sas_get_sdev_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _sas_device *sas_device;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_handle(ioc, handle);\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\treturn sas_device;\n}\n\n/**\n * _scsih_display_enclosure_chassis_info - display device location info\n * @ioc: per adapter object\n * @sas_device: per sas device object\n * @sdev: scsi device struct\n * @starget: scsi target struct\n */\nstatic void\n_scsih_display_enclosure_chassis_info(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_device *sas_device, struct scsi_device *sdev,\n\tstruct scsi_target *starget)\n{\n\tif (sdev) {\n\t\tif (sas_device->enclosure_handle != 0)\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"enclosure logical id (0x%016llx), slot(%d) \\n\",\n\t\t\t    (unsigned long long)\n\t\t\t    sas_device->enclosure_logical_id,\n\t\t\t    sas_device->slot);\n\t\tif (sas_device->connector_name[0] != '\\0')\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t    sas_device->enclosure_level,\n\t\t\t    sas_device->connector_name);\n\t\tif (sas_device->is_chassis_slot_valid)\n\t\t\tsdev_printk(KERN_INFO, sdev, \"chassis slot(0x%04x)\\n\",\n\t\t\t    sas_device->chassis_slot);\n\t} else if (starget) {\n\t\tif (sas_device->enclosure_handle != 0)\n\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t    \"enclosure logical id(0x%016llx), slot(%d) \\n\",\n\t\t\t    (unsigned long long)\n\t\t\t    sas_device->enclosure_logical_id,\n\t\t\t    sas_device->slot);\n\t\tif (sas_device->connector_name[0] != '\\0')\n\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t    \"enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t    sas_device->enclosure_level,\n\t\t\t    sas_device->connector_name);\n\t\tif (sas_device->is_chassis_slot_valid)\n\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t    \"chassis slot(0x%04x)\\n\",\n\t\t\t    sas_device->chassis_slot);\n\t} else {\n\t\tif (sas_device->enclosure_handle != 0)\n\t\t\tioc_info(ioc, \"enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t (u64)sas_device->enclosure_logical_id,\n\t\t\t\t sas_device->slot);\n\t\tif (sas_device->connector_name[0] != '\\0')\n\t\t\tioc_info(ioc, \"enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t\t sas_device->enclosure_level,\n\t\t\t\t sas_device->connector_name);\n\t\tif (sas_device->is_chassis_slot_valid)\n\t\t\tioc_info(ioc, \"chassis slot(0x%04x)\\n\",\n\t\t\t\t sas_device->chassis_slot);\n\t}\n}\n\n/**\n * _scsih_sas_device_remove - remove sas_device from list.\n * @ioc: per adapter object\n * @sas_device: the sas_device object\n * Context: This function will acquire ioc->sas_device_lock.\n *\n * If sas_device is on the list, remove it and decrement its reference count.\n */\nstatic void\n_scsih_sas_device_remove(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_device *sas_device)\n{\n\tunsigned long flags;\n\n\tif (!sas_device)\n\t\treturn;\n\tioc_info(ioc, \"removing handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t sas_device->handle, (u64)sas_device->sas_address);\n\n\t_scsih_display_enclosure_chassis_info(ioc, sas_device, NULL, NULL);\n\n\t/*\n\t * The lock serializes access to the list, but we still need to verify\n\t * that nobody removed the entry while we were waiting on the lock.\n\t */\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tif (!list_empty(&sas_device->list)) {\n\t\tlist_del_init(&sas_device->list);\n\t\tsas_device_put(sas_device);\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n}\n\n/**\n * _scsih_device_remove_by_handle - removing device object by handle\n * @ioc: per adapter object\n * @handle: device handle\n */\nstatic void\n_scsih_device_remove_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _sas_device *sas_device;\n\tunsigned long flags;\n\n\tif (ioc->shost_recovery)\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_handle(ioc, handle);\n\tif (sas_device) {\n\t\tlist_del_init(&sas_device->list);\n\t\tsas_device_put(sas_device);\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\tif (sas_device) {\n\t\t_scsih_remove_device(ioc, sas_device);\n\t\tsas_device_put(sas_device);\n\t}\n}\n\n/**\n * mpt3sas_device_remove_by_sas_address - removing device object by\n *\t\t\t\t\tsas address & port number\n * @ioc: per adapter object\n * @sas_address: device sas_address\n * @port: hba port entry\n *\n * Return nothing.\n */\nvoid\nmpt3sas_device_remove_by_sas_address(struct MPT3SAS_ADAPTER *ioc,\n\tu64 sas_address, struct hba_port *port)\n{\n\tstruct _sas_device *sas_device;\n\tunsigned long flags;\n\n\tif (ioc->shost_recovery)\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_addr(ioc, sas_address, port);\n\tif (sas_device) {\n\t\tlist_del_init(&sas_device->list);\n\t\tsas_device_put(sas_device);\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\tif (sas_device) {\n\t\t_scsih_remove_device(ioc, sas_device);\n\t\tsas_device_put(sas_device);\n\t}\n}\n\n/**\n * _scsih_sas_device_add - insert sas_device to the list.\n * @ioc: per adapter object\n * @sas_device: the sas_device object\n * Context: This function will acquire ioc->sas_device_lock.\n *\n * Adding new object to the ioc->sas_device_list.\n */\nstatic void\n_scsih_sas_device_add(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_device *sas_device)\n{\n\tunsigned long flags;\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t    __func__, sas_device->handle,\n\t\t\t    (u64)sas_device->sas_address));\n\n\tdewtprintk(ioc, _scsih_display_enclosure_chassis_info(ioc, sas_device,\n\t    NULL, NULL));\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device_get(sas_device);\n\tlist_add_tail(&sas_device->list, &ioc->sas_device_list);\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\tif (ioc->hide_drives) {\n\t\tclear_bit(sas_device->handle, ioc->pend_os_device_add);\n\t\treturn;\n\t}\n\n\tif (!mpt3sas_transport_port_add(ioc, sas_device->handle,\n\t     sas_device->sas_address_parent, sas_device->port)) {\n\t\t_scsih_sas_device_remove(ioc, sas_device);\n\t} else if (!sas_device->starget) {\n\t\t/*\n\t\t * When asyn scanning is enabled, its not possible to remove\n\t\t * devices while scanning is turned on due to an oops in\n\t\t * scsi_sysfs_add_sdev()->add_device()->sysfs_addrm_start()\n\t\t */\n\t\tif (!ioc->is_driver_loading) {\n\t\t\tmpt3sas_transport_port_remove(ioc,\n\t\t\t    sas_device->sas_address,\n\t\t\t    sas_device->sas_address_parent,\n\t\t\t    sas_device->port);\n\t\t\t_scsih_sas_device_remove(ioc, sas_device);\n\t\t}\n\t} else\n\t\tclear_bit(sas_device->handle, ioc->pend_os_device_add);\n}\n\n/**\n * _scsih_sas_device_init_add - insert sas_device to the list.\n * @ioc: per adapter object\n * @sas_device: the sas_device object\n * Context: This function will acquire ioc->sas_device_lock.\n *\n * Adding new object at driver load time to the ioc->sas_device_init_list.\n */\nstatic void\n_scsih_sas_device_init_add(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_device *sas_device)\n{\n\tunsigned long flags;\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t    __func__, sas_device->handle,\n\t\t\t    (u64)sas_device->sas_address));\n\n\tdewtprintk(ioc, _scsih_display_enclosure_chassis_info(ioc, sas_device,\n\t    NULL, NULL));\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device_get(sas_device);\n\tlist_add_tail(&sas_device->list, &ioc->sas_device_init_list);\n\t_scsih_determine_boot_device(ioc, sas_device, 0);\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n}\n\n\nstatic struct _pcie_device *\n__mpt3sas_get_pdev_by_wwid(struct MPT3SAS_ADAPTER *ioc, u64 wwid)\n{\n\tstruct _pcie_device *pcie_device;\n\n\tassert_spin_locked(&ioc->pcie_device_lock);\n\n\tlist_for_each_entry(pcie_device, &ioc->pcie_device_list, list)\n\t\tif (pcie_device->wwid == wwid)\n\t\t\tgoto found_device;\n\n\tlist_for_each_entry(pcie_device, &ioc->pcie_device_init_list, list)\n\t\tif (pcie_device->wwid == wwid)\n\t\t\tgoto found_device;\n\n\treturn NULL;\n\nfound_device:\n\tpcie_device_get(pcie_device);\n\treturn pcie_device;\n}\n\n\n/**\n * mpt3sas_get_pdev_by_wwid - pcie device search\n * @ioc: per adapter object\n * @wwid: wwid\n *\n * Context: This function will acquire ioc->pcie_device_lock and will release\n * before returning the pcie_device object.\n *\n * This searches for pcie_device based on wwid, then return pcie_device object.\n */\nstatic struct _pcie_device *\nmpt3sas_get_pdev_by_wwid(struct MPT3SAS_ADAPTER *ioc, u64 wwid)\n{\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tpcie_device = __mpt3sas_get_pdev_by_wwid(ioc, wwid);\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\treturn pcie_device;\n}\n\n\nstatic struct _pcie_device *\n__mpt3sas_get_pdev_by_idchannel(struct MPT3SAS_ADAPTER *ioc, int id,\n\tint channel)\n{\n\tstruct _pcie_device *pcie_device;\n\n\tassert_spin_locked(&ioc->pcie_device_lock);\n\n\tlist_for_each_entry(pcie_device, &ioc->pcie_device_list, list)\n\t\tif (pcie_device->id == id && pcie_device->channel == channel)\n\t\t\tgoto found_device;\n\n\tlist_for_each_entry(pcie_device, &ioc->pcie_device_init_list, list)\n\t\tif (pcie_device->id == id && pcie_device->channel == channel)\n\t\t\tgoto found_device;\n\n\treturn NULL;\n\nfound_device:\n\tpcie_device_get(pcie_device);\n\treturn pcie_device;\n}\n\nstatic struct _pcie_device *\n__mpt3sas_get_pdev_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _pcie_device *pcie_device;\n\n\tassert_spin_locked(&ioc->pcie_device_lock);\n\n\tlist_for_each_entry(pcie_device, &ioc->pcie_device_list, list)\n\t\tif (pcie_device->handle == handle)\n\t\t\tgoto found_device;\n\n\tlist_for_each_entry(pcie_device, &ioc->pcie_device_init_list, list)\n\t\tif (pcie_device->handle == handle)\n\t\t\tgoto found_device;\n\n\treturn NULL;\n\nfound_device:\n\tpcie_device_get(pcie_device);\n\treturn pcie_device;\n}\n\n\n/**\n * mpt3sas_get_pdev_by_handle - pcie device search\n * @ioc: per adapter object\n * @handle: Firmware device handle\n *\n * Context: This function will acquire ioc->pcie_device_lock and will release\n * before returning the pcie_device object.\n *\n * This searches for pcie_device based on handle, then return pcie_device\n * object.\n */\nstruct _pcie_device *\nmpt3sas_get_pdev_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tpcie_device = __mpt3sas_get_pdev_by_handle(ioc, handle);\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\treturn pcie_device;\n}\n\n/**\n * _scsih_set_nvme_max_shutdown_latency - Update max_shutdown_latency.\n * @ioc: per adapter object\n * Context: This function will acquire ioc->pcie_device_lock\n *\n * Update ioc->max_shutdown_latency to that NVMe drives RTD3 Entry Latency\n * which has reported maximum among all available NVMe drives.\n * Minimum max_shutdown_latency will be six seconds.\n */\nstatic void\n_scsih_set_nvme_max_shutdown_latency(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\tu16 shutdown_latency = IO_UNIT_CONTROL_SHUTDOWN_TIMEOUT;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tlist_for_each_entry(pcie_device, &ioc->pcie_device_list, list) {\n\t\tif (pcie_device->shutdown_latency) {\n\t\t\tif (shutdown_latency < pcie_device->shutdown_latency)\n\t\t\t\tshutdown_latency =\n\t\t\t\t\tpcie_device->shutdown_latency;\n\t\t}\n\t}\n\tioc->max_shutdown_latency = shutdown_latency;\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n}\n\n/**\n * _scsih_pcie_device_remove - remove pcie_device from list.\n * @ioc: per adapter object\n * @pcie_device: the pcie_device object\n * Context: This function will acquire ioc->pcie_device_lock.\n *\n * If pcie_device is on the list, remove it and decrement its reference count.\n */\nstatic void\n_scsih_pcie_device_remove(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _pcie_device *pcie_device)\n{\n\tunsigned long flags;\n\tint was_on_pcie_device_list = 0;\n\tu8 update_latency = 0;\n\n\tif (!pcie_device)\n\t\treturn;\n\tioc_info(ioc, \"removing handle(0x%04x), wwid(0x%016llx)\\n\",\n\t\t pcie_device->handle, (u64)pcie_device->wwid);\n\tif (pcie_device->enclosure_handle != 0)\n\t\tioc_info(ioc, \"removing enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t (u64)pcie_device->enclosure_logical_id,\n\t\t\t pcie_device->slot);\n\tif (pcie_device->connector_name[0] != '\\0')\n\t\tioc_info(ioc, \"removing enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t pcie_device->enclosure_level,\n\t\t\t pcie_device->connector_name);\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tif (!list_empty(&pcie_device->list)) {\n\t\tlist_del_init(&pcie_device->list);\n\t\twas_on_pcie_device_list = 1;\n\t}\n\tif (pcie_device->shutdown_latency == ioc->max_shutdown_latency)\n\t\tupdate_latency = 1;\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\tif (was_on_pcie_device_list) {\n\t\tkfree(pcie_device->serial_number);\n\t\tpcie_device_put(pcie_device);\n\t}\n\n\t/*\n\t * This device's RTD3 Entry Latency matches IOC's\n\t * max_shutdown_latency. Recalculate IOC's max_shutdown_latency\n\t * from the available drives as current drive is getting removed.\n\t */\n\tif (update_latency)\n\t\t_scsih_set_nvme_max_shutdown_latency(ioc);\n}\n\n\n/**\n * _scsih_pcie_device_remove_by_handle - removing pcie device object by handle\n * @ioc: per adapter object\n * @handle: device handle\n */\nstatic void\n_scsih_pcie_device_remove_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\tint was_on_pcie_device_list = 0;\n\tu8 update_latency = 0;\n\n\tif (ioc->shost_recovery)\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tpcie_device = __mpt3sas_get_pdev_by_handle(ioc, handle);\n\tif (pcie_device) {\n\t\tif (!list_empty(&pcie_device->list)) {\n\t\t\tlist_del_init(&pcie_device->list);\n\t\t\twas_on_pcie_device_list = 1;\n\t\t\tpcie_device_put(pcie_device);\n\t\t}\n\t\tif (pcie_device->shutdown_latency == ioc->max_shutdown_latency)\n\t\t\tupdate_latency = 1;\n\t}\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\tif (was_on_pcie_device_list) {\n\t\t_scsih_pcie_device_remove_from_sml(ioc, pcie_device);\n\t\tpcie_device_put(pcie_device);\n\t}\n\n\t/*\n\t * This device's RTD3 Entry Latency matches IOC's\n\t * max_shutdown_latency. Recalculate IOC's max_shutdown_latency\n\t * from the available drives as current drive is getting removed.\n\t */\n\tif (update_latency)\n\t\t_scsih_set_nvme_max_shutdown_latency(ioc);\n}\n\n/**\n * _scsih_pcie_device_add - add pcie_device object\n * @ioc: per adapter object\n * @pcie_device: pcie_device object\n *\n * This is added to the pcie_device_list link list.\n */\nstatic void\n_scsih_pcie_device_add(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _pcie_device *pcie_device)\n{\n\tunsigned long flags;\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: handle (0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t    __func__,\n\t\t\t    pcie_device->handle, (u64)pcie_device->wwid));\n\tif (pcie_device->enclosure_handle != 0)\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: enclosure logical id(0x%016llx), slot( %d)\\n\",\n\t\t\t\t    __func__,\n\t\t\t\t    (u64)pcie_device->enclosure_logical_id,\n\t\t\t\t    pcie_device->slot));\n\tif (pcie_device->connector_name[0] != '\\0')\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t\t    __func__, pcie_device->enclosure_level,\n\t\t\t\t    pcie_device->connector_name));\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tpcie_device_get(pcie_device);\n\tlist_add_tail(&pcie_device->list, &ioc->pcie_device_list);\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\tif (pcie_device->access_status ==\n\t    MPI26_PCIEDEV0_ASTATUS_DEVICE_BLOCKED) {\n\t\tclear_bit(pcie_device->handle, ioc->pend_os_device_add);\n\t\treturn;\n\t}\n\tif (scsi_add_device(ioc->shost, PCIE_CHANNEL, pcie_device->id, 0)) {\n\t\t_scsih_pcie_device_remove(ioc, pcie_device);\n\t} else if (!pcie_device->starget) {\n\t\tif (!ioc->is_driver_loading) {\n/*TODO-- Need to find out whether this condition will occur or not*/\n\t\t\tclear_bit(pcie_device->handle, ioc->pend_os_device_add);\n\t\t}\n\t} else\n\t\tclear_bit(pcie_device->handle, ioc->pend_os_device_add);\n}\n\n/*\n * _scsih_pcie_device_init_add - insert pcie_device to the init list.\n * @ioc: per adapter object\n * @pcie_device: the pcie_device object\n * Context: This function will acquire ioc->pcie_device_lock.\n *\n * Adding new object at driver load time to the ioc->pcie_device_init_list.\n */\nstatic void\n_scsih_pcie_device_init_add(struct MPT3SAS_ADAPTER *ioc,\n\t\t\t\tstruct _pcie_device *pcie_device)\n{\n\tunsigned long flags;\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: handle (0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t    __func__,\n\t\t\t    pcie_device->handle, (u64)pcie_device->wwid));\n\tif (pcie_device->enclosure_handle != 0)\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: enclosure logical id(0x%016llx), slot( %d)\\n\",\n\t\t\t\t    __func__,\n\t\t\t\t    (u64)pcie_device->enclosure_logical_id,\n\t\t\t\t    pcie_device->slot));\n\tif (pcie_device->connector_name[0] != '\\0')\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t\t    __func__, pcie_device->enclosure_level,\n\t\t\t\t    pcie_device->connector_name));\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tpcie_device_get(pcie_device);\n\tlist_add_tail(&pcie_device->list, &ioc->pcie_device_init_list);\n\tif (pcie_device->access_status !=\n\t    MPI26_PCIEDEV0_ASTATUS_DEVICE_BLOCKED)\n\t\t_scsih_determine_boot_device(ioc, pcie_device, PCIE_CHANNEL);\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n}\n/**\n * _scsih_raid_device_find_by_id - raid device search\n * @ioc: per adapter object\n * @id: sas device target id\n * @channel: sas device channel\n * Context: Calling function should acquire ioc->raid_device_lock\n *\n * This searches for raid_device based on target id, then return raid_device\n * object.\n */\nstatic struct _raid_device *\n_scsih_raid_device_find_by_id(struct MPT3SAS_ADAPTER *ioc, int id, int channel)\n{\n\tstruct _raid_device *raid_device, *r;\n\n\tr = NULL;\n\tlist_for_each_entry(raid_device, &ioc->raid_device_list, list) {\n\t\tif (raid_device->id == id && raid_device->channel == channel) {\n\t\t\tr = raid_device;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n out:\n\treturn r;\n}\n\n/**\n * mpt3sas_raid_device_find_by_handle - raid device search\n * @ioc: per adapter object\n * @handle: sas device handle (assigned by firmware)\n * Context: Calling function should acquire ioc->raid_device_lock\n *\n * This searches for raid_device based on handle, then return raid_device\n * object.\n */\nstruct _raid_device *\nmpt3sas_raid_device_find_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _raid_device *raid_device, *r;\n\n\tr = NULL;\n\tlist_for_each_entry(raid_device, &ioc->raid_device_list, list) {\n\t\tif (raid_device->handle != handle)\n\t\t\tcontinue;\n\t\tr = raid_device;\n\t\tgoto out;\n\t}\n\n out:\n\treturn r;\n}\n\n/**\n * _scsih_raid_device_find_by_wwid - raid device search\n * @ioc: per adapter object\n * @wwid: ?\n * Context: Calling function should acquire ioc->raid_device_lock\n *\n * This searches for raid_device based on wwid, then return raid_device\n * object.\n */\nstatic struct _raid_device *\n_scsih_raid_device_find_by_wwid(struct MPT3SAS_ADAPTER *ioc, u64 wwid)\n{\n\tstruct _raid_device *raid_device, *r;\n\n\tr = NULL;\n\tlist_for_each_entry(raid_device, &ioc->raid_device_list, list) {\n\t\tif (raid_device->wwid != wwid)\n\t\t\tcontinue;\n\t\tr = raid_device;\n\t\tgoto out;\n\t}\n\n out:\n\treturn r;\n}\n\n/**\n * _scsih_raid_device_add - add raid_device object\n * @ioc: per adapter object\n * @raid_device: raid_device object\n *\n * This is added to the raid_device_list link list.\n */\nstatic void\n_scsih_raid_device_add(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _raid_device *raid_device)\n{\n\tunsigned long flags;\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: handle(0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t    __func__,\n\t\t\t    raid_device->handle, (u64)raid_device->wwid));\n\n\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\tlist_add_tail(&raid_device->list, &ioc->raid_device_list);\n\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n}\n\n/**\n * _scsih_raid_device_remove - delete raid_device object\n * @ioc: per adapter object\n * @raid_device: raid_device object\n *\n */\nstatic void\n_scsih_raid_device_remove(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _raid_device *raid_device)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\tlist_del(&raid_device->list);\n\tkfree(raid_device);\n\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n}\n\n/**\n * mpt3sas_scsih_expander_find_by_handle - expander device search\n * @ioc: per adapter object\n * @handle: expander handle (assigned by firmware)\n * Context: Calling function should acquire ioc->sas_device_lock\n *\n * This searches for expander device based on handle, then returns the\n * sas_node object.\n */\nstruct _sas_node *\nmpt3sas_scsih_expander_find_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _sas_node *sas_expander, *r;\n\n\tr = NULL;\n\tlist_for_each_entry(sas_expander, &ioc->sas_expander_list, list) {\n\t\tif (sas_expander->handle != handle)\n\t\t\tcontinue;\n\t\tr = sas_expander;\n\t\tgoto out;\n\t}\n out:\n\treturn r;\n}\n\n/**\n * mpt3sas_scsih_enclosure_find_by_handle - exclosure device search\n * @ioc: per adapter object\n * @handle: enclosure handle (assigned by firmware)\n * Context: Calling function should acquire ioc->sas_device_lock\n *\n * This searches for enclosure device based on handle, then returns the\n * enclosure object.\n */\nstatic struct _enclosure_node *\nmpt3sas_scsih_enclosure_find_by_handle(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _enclosure_node *enclosure_dev, *r;\n\n\tr = NULL;\n\tlist_for_each_entry(enclosure_dev, &ioc->enclosure_list, list) {\n\t\tif (le16_to_cpu(enclosure_dev->pg0.EnclosureHandle) != handle)\n\t\t\tcontinue;\n\t\tr = enclosure_dev;\n\t\tgoto out;\n\t}\nout:\n\treturn r;\n}\n/**\n * mpt3sas_scsih_expander_find_by_sas_address - expander device search\n * @ioc: per adapter object\n * @sas_address: sas address\n * @port: hba port entry\n * Context: Calling function should acquire ioc->sas_node_lock.\n *\n * This searches for expander device based on sas_address & port number,\n * then returns the sas_node object.\n */\nstruct _sas_node *\nmpt3sas_scsih_expander_find_by_sas_address(struct MPT3SAS_ADAPTER *ioc,\n\tu64 sas_address, struct hba_port *port)\n{\n\tstruct _sas_node *sas_expander, *r = NULL;\n\n\tif (!port)\n\t\treturn r;\n\n\tlist_for_each_entry(sas_expander, &ioc->sas_expander_list, list) {\n\t\tif (sas_expander->sas_address != sas_address)\n\t\t\tcontinue;\n\t\tif (sas_expander->port != port)\n\t\t\tcontinue;\n\t\tr = sas_expander;\n\t\tgoto out;\n\t}\n out:\n\treturn r;\n}\n\n/**\n * _scsih_expander_node_add - insert expander device to the list.\n * @ioc: per adapter object\n * @sas_expander: the sas_device object\n * Context: This function will acquire ioc->sas_node_lock.\n *\n * Adding new object to the ioc->sas_expander_list.\n */\nstatic void\n_scsih_expander_node_add(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_node *sas_expander)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tlist_add_tail(&sas_expander->list, &ioc->sas_expander_list);\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n}\n\n/**\n * _scsih_is_end_device - determines if device is an end device\n * @device_info: bitfield providing information about the device.\n * Context: none\n *\n * Return: 1 if end device.\n */\nstatic int\n_scsih_is_end_device(u32 device_info)\n{\n\tif (device_info & MPI2_SAS_DEVICE_INFO_END_DEVICE &&\n\t\t((device_info & MPI2_SAS_DEVICE_INFO_SSP_TARGET) |\n\t\t(device_info & MPI2_SAS_DEVICE_INFO_STP_TARGET) |\n\t\t(device_info & MPI2_SAS_DEVICE_INFO_SATA_DEVICE)))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n/**\n * _scsih_is_nvme_pciescsi_device - determines if\n *\t\t\tdevice is an pcie nvme/scsi device\n * @device_info: bitfield providing information about the device.\n * Context: none\n *\n * Returns 1 if device is pcie device type nvme/scsi.\n */\nstatic int\n_scsih_is_nvme_pciescsi_device(u32 device_info)\n{\n\tif (((device_info & MPI26_PCIE_DEVINFO_MASK_DEVICE_TYPE)\n\t    == MPI26_PCIE_DEVINFO_NVME) ||\n\t    ((device_info & MPI26_PCIE_DEVINFO_MASK_DEVICE_TYPE)\n\t    == MPI26_PCIE_DEVINFO_SCSI))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n/**\n * _scsih_scsi_lookup_find_by_target - search for matching channel:id\n * @ioc: per adapter object\n * @id: target id\n * @channel: channel\n * Context: This function will acquire ioc->scsi_lookup_lock.\n *\n * This will search for a matching channel:id in the scsi_lookup array,\n * returning 1 if found.\n */\nstatic u8\n_scsih_scsi_lookup_find_by_target(struct MPT3SAS_ADAPTER *ioc, int id,\n\tint channel)\n{\n\tint smid;\n\tstruct scsi_cmnd *scmd;\n\n\tfor (smid = 1;\n\t     smid <= ioc->shost->can_queue; smid++) {\n\t\tscmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);\n\t\tif (!scmd)\n\t\t\tcontinue;\n\t\tif (scmd->device->id == id &&\n\t\t    scmd->device->channel == channel)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/**\n * _scsih_scsi_lookup_find_by_lun - search for matching channel:id:lun\n * @ioc: per adapter object\n * @id: target id\n * @lun: lun number\n * @channel: channel\n * Context: This function will acquire ioc->scsi_lookup_lock.\n *\n * This will search for a matching channel:id:lun in the scsi_lookup array,\n * returning 1 if found.\n */\nstatic u8\n_scsih_scsi_lookup_find_by_lun(struct MPT3SAS_ADAPTER *ioc, int id,\n\tunsigned int lun, int channel)\n{\n\tint smid;\n\tstruct scsi_cmnd *scmd;\n\n\tfor (smid = 1; smid <= ioc->shost->can_queue; smid++) {\n\n\t\tscmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);\n\t\tif (!scmd)\n\t\t\tcontinue;\n\t\tif (scmd->device->id == id &&\n\t\t    scmd->device->channel == channel &&\n\t\t    scmd->device->lun == lun)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/**\n * mpt3sas_scsih_scsi_lookup_get - returns scmd entry\n * @ioc: per adapter object\n * @smid: system request message index\n *\n * Return: the smid stored scmd pointer.\n * Then will dereference the stored scmd pointer.\n */\nstruct scsi_cmnd *\nmpt3sas_scsih_scsi_lookup_get(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tstruct scsi_cmnd *scmd = NULL;\n\tstruct scsiio_tracker *st;\n\tMpi25SCSIIORequest_t *mpi_request;\n\n\tif (smid > 0  &&\n\t    smid <= ioc->scsiio_depth - INTERNAL_SCSIIO_CMDS_COUNT) {\n\t\tu32 unique_tag = smid - 1;\n\n\t\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\n\t\t/*\n\t\t * If SCSI IO request is outstanding at driver level then\n\t\t * DevHandle filed must be non-zero. If DevHandle is zero\n\t\t * then it means that this smid is free at driver level,\n\t\t * so return NULL.\n\t\t */\n\t\tif (!mpi_request->DevHandle)\n\t\t\treturn scmd;\n\n\t\tscmd = scsi_host_find_tag(ioc->shost, unique_tag);\n\t\tif (scmd) {\n\t\t\tst = scsi_cmd_priv(scmd);\n\t\t\tif (st->cb_idx == 0xFF || st->smid == 0)\n\t\t\t\tscmd = NULL;\n\t\t}\n\t}\n\treturn scmd;\n}\n\n/**\n * scsih_change_queue_depth - setting device queue depth\n * @sdev: scsi device struct\n * @qdepth: requested queue depth\n *\n * Return: queue depth.\n */\nstatic int\nscsih_change_queue_depth(struct scsi_device *sdev, int qdepth)\n{\n\tstruct Scsi_Host *shost = sdev->host;\n\tint max_depth;\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct _sas_device *sas_device;\n\tunsigned long flags;\n\n\tmax_depth = shost->can_queue;\n\n\t/*\n\t * limit max device queue for SATA to 32 if enable_sdev_max_qd\n\t * is disabled.\n\t */\n\tif (ioc->enable_sdev_max_qd)\n\t\tgoto not_sata;\n\n\tsas_device_priv_data = sdev->hostdata;\n\tif (!sas_device_priv_data)\n\t\tgoto not_sata;\n\tsas_target_priv_data = sas_device_priv_data->sas_target;\n\tif (!sas_target_priv_data)\n\t\tgoto not_sata;\n\tif ((sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME))\n\t\tgoto not_sata;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_from_target(ioc, sas_target_priv_data);\n\tif (sas_device) {\n\t\tif (sas_device->device_info & MPI2_SAS_DEVICE_INFO_SATA_DEVICE)\n\t\t\tmax_depth = MPT3SAS_SATA_QUEUE_DEPTH;\n\n\t\tsas_device_put(sas_device);\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n not_sata:\n\n\tif (!sdev->tagged_supported)\n\t\tmax_depth = 1;\n\tif (qdepth > max_depth)\n\t\tqdepth = max_depth;\n\tscsi_change_queue_depth(sdev, qdepth);\n\tsdev_printk(KERN_INFO, sdev,\n\t    \"qdepth(%d), tagged(%d), scsi_level(%d), cmd_que(%d)\\n\",\n\t    sdev->queue_depth, sdev->tagged_supported,\n\t    sdev->scsi_level, ((sdev->inquiry[7] & 2) >> 1));\n\treturn sdev->queue_depth;\n}\n\n/**\n * mpt3sas_scsih_change_queue_depth - setting device queue depth\n * @sdev: scsi device struct\n * @qdepth: requested queue depth\n *\n * Returns nothing.\n */\nvoid\nmpt3sas_scsih_change_queue_depth(struct scsi_device *sdev, int qdepth)\n{\n\tstruct Scsi_Host *shost = sdev->host;\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\tif (ioc->enable_sdev_max_qd)\n\t\tqdepth = shost->can_queue;\n\n\tscsih_change_queue_depth(sdev, qdepth);\n}\n\n/**\n * scsih_target_alloc - target add routine\n * @starget: scsi target struct\n *\n * Return: 0 if ok. Any other return is assumed to be an error and\n * the device is ignored.\n */\nstatic int\nscsih_target_alloc(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct _sas_device *sas_device;\n\tstruct _raid_device *raid_device;\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\tstruct sas_rphy *rphy;\n\n\tsas_target_priv_data = kzalloc(sizeof(*sas_target_priv_data),\n\t\t\t\t       GFP_KERNEL);\n\tif (!sas_target_priv_data)\n\t\treturn -ENOMEM;\n\n\tstarget->hostdata = sas_target_priv_data;\n\tsas_target_priv_data->starget = starget;\n\tsas_target_priv_data->handle = MPT3SAS_INVALID_DEVICE_HANDLE;\n\n\t/* RAID volumes */\n\tif (starget->channel == RAID_CHANNEL) {\n\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\traid_device = _scsih_raid_device_find_by_id(ioc, starget->id,\n\t\t    starget->channel);\n\t\tif (raid_device) {\n\t\t\tsas_target_priv_data->handle = raid_device->handle;\n\t\t\tsas_target_priv_data->sas_address = raid_device->wwid;\n\t\t\tsas_target_priv_data->flags |= MPT_TARGET_FLAGS_VOLUME;\n\t\t\tif (ioc->is_warpdrive)\n\t\t\t\tsas_target_priv_data->raid_device = raid_device;\n\t\t\traid_device->starget = starget;\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t\treturn 0;\n\t}\n\n\t/* PCIe devices */\n\tif (starget->channel == PCIE_CHANNEL) {\n\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\tpcie_device = __mpt3sas_get_pdev_by_idchannel(ioc, starget->id,\n\t\t\tstarget->channel);\n\t\tif (pcie_device) {\n\t\t\tsas_target_priv_data->handle = pcie_device->handle;\n\t\t\tsas_target_priv_data->sas_address = pcie_device->wwid;\n\t\t\tsas_target_priv_data->port = NULL;\n\t\t\tsas_target_priv_data->pcie_dev = pcie_device;\n\t\t\tpcie_device->starget = starget;\n\t\t\tpcie_device->id = starget->id;\n\t\t\tpcie_device->channel = starget->channel;\n\t\t\tsas_target_priv_data->flags |=\n\t\t\t\tMPT_TARGET_FLAGS_PCIE_DEVICE;\n\t\t\tif (pcie_device->fast_path)\n\t\t\t\tsas_target_priv_data->flags |=\n\t\t\t\t\tMPT_TARGET_FASTPATH_IO;\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\treturn 0;\n\t}\n\n\t/* sas/sata devices */\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\trphy = dev_to_rphy(starget->dev.parent);\n\tsas_device = __mpt3sas_get_sdev_by_rphy(ioc, rphy);\n\n\tif (sas_device) {\n\t\tsas_target_priv_data->handle = sas_device->handle;\n\t\tsas_target_priv_data->sas_address = sas_device->sas_address;\n\t\tsas_target_priv_data->port = sas_device->port;\n\t\tsas_target_priv_data->sas_dev = sas_device;\n\t\tsas_device->starget = starget;\n\t\tsas_device->id = starget->id;\n\t\tsas_device->channel = starget->channel;\n\t\tif (test_bit(sas_device->handle, ioc->pd_handles))\n\t\t\tsas_target_priv_data->flags |=\n\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT;\n\t\tif (sas_device->fast_path)\n\t\t\tsas_target_priv_data->flags |=\n\t\t\t\t\tMPT_TARGET_FASTPATH_IO;\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\treturn 0;\n}\n\n/**\n * scsih_target_destroy - target destroy routine\n * @starget: scsi target struct\n */\nstatic void\nscsih_target_destroy(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct _sas_device *sas_device;\n\tstruct _raid_device *raid_device;\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\n\tsas_target_priv_data = starget->hostdata;\n\tif (!sas_target_priv_data)\n\t\treturn;\n\n\tif (starget->channel == RAID_CHANNEL) {\n\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\traid_device = _scsih_raid_device_find_by_id(ioc, starget->id,\n\t\t    starget->channel);\n\t\tif (raid_device) {\n\t\t\traid_device->starget = NULL;\n\t\t\traid_device->sdev = NULL;\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t\tgoto out;\n\t}\n\n\tif (starget->channel == PCIE_CHANNEL) {\n\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\tpcie_device = __mpt3sas_get_pdev_from_target(ioc,\n\t\t\t\t\t\t\tsas_target_priv_data);\n\t\tif (pcie_device && (pcie_device->starget == starget) &&\n\t\t\t(pcie_device->id == starget->id) &&\n\t\t\t(pcie_device->channel == starget->channel))\n\t\t\tpcie_device->starget = NULL;\n\n\t\tif (pcie_device) {\n\t\t\t/*\n\t\t\t * Corresponding get() is in _scsih_target_alloc()\n\t\t\t */\n\t\t\tsas_target_priv_data->pcie_dev = NULL;\n\t\t\tpcie_device_put(pcie_device);\n\t\t\tpcie_device_put(pcie_device);\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_from_target(ioc, sas_target_priv_data);\n\tif (sas_device && (sas_device->starget == starget) &&\n\t    (sas_device->id == starget->id) &&\n\t    (sas_device->channel == starget->channel))\n\t\tsas_device->starget = NULL;\n\n\tif (sas_device) {\n\t\t/*\n\t\t * Corresponding get() is in _scsih_target_alloc()\n\t\t */\n\t\tsas_target_priv_data->sas_dev = NULL;\n\t\tsas_device_put(sas_device);\n\n\t\tsas_device_put(sas_device);\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n out:\n\tkfree(sas_target_priv_data);\n\tstarget->hostdata = NULL;\n}\n\n/**\n * scsih_slave_alloc - device add routine\n * @sdev: scsi device struct\n *\n * Return: 0 if ok. Any other return is assumed to be an error and\n * the device is ignored.\n */\nstatic int\nscsih_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsi_target *starget;\n\tstruct _raid_device *raid_device;\n\tstruct _sas_device *sas_device;\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\n\tsas_device_priv_data = kzalloc(sizeof(*sas_device_priv_data),\n\t\t\t\t       GFP_KERNEL);\n\tif (!sas_device_priv_data)\n\t\treturn -ENOMEM;\n\n\tsas_device_priv_data->lun = sdev->lun;\n\tsas_device_priv_data->flags = MPT_DEVICE_FLAGS_INIT;\n\n\tstarget = scsi_target(sdev);\n\tsas_target_priv_data = starget->hostdata;\n\tsas_target_priv_data->num_luns++;\n\tsas_device_priv_data->sas_target = sas_target_priv_data;\n\tsdev->hostdata = sas_device_priv_data;\n\tif ((sas_target_priv_data->flags & MPT_TARGET_FLAGS_RAID_COMPONENT))\n\t\tsdev->no_uld_attach = 1;\n\n\tshost = dev_to_shost(&starget->dev);\n\tioc = shost_priv(shost);\n\tif (starget->channel == RAID_CHANNEL) {\n\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\traid_device = _scsih_raid_device_find_by_id(ioc,\n\t\t    starget->id, starget->channel);\n\t\tif (raid_device)\n\t\t\traid_device->sdev = sdev; /* raid is single lun */\n\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t}\n\tif (starget->channel == PCIE_CHANNEL) {\n\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\tpcie_device = __mpt3sas_get_pdev_by_wwid(ioc,\n\t\t\t\tsas_target_priv_data->sas_address);\n\t\tif (pcie_device && (pcie_device->starget == NULL)) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"%s : pcie_device->starget set to starget @ %d\\n\",\n\t\t\t    __func__, __LINE__);\n\t\t\tpcie_device->starget = starget;\n\t\t}\n\n\t\tif (pcie_device)\n\t\t\tpcie_device_put(pcie_device);\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\t} else  if (!(sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME)) {\n\t\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\t\tsas_device = __mpt3sas_get_sdev_by_addr(ioc,\n\t\t    sas_target_priv_data->sas_address,\n\t\t    sas_target_priv_data->port);\n\t\tif (sas_device && (sas_device->starget == NULL)) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\"%s : sas_device->starget set to starget @ %d\\n\",\n\t\t\t     __func__, __LINE__);\n\t\t\tsas_device->starget = starget;\n\t\t}\n\n\t\tif (sas_device)\n\t\t\tsas_device_put(sas_device);\n\n\t\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\t}\n\n\treturn 0;\n}\n\n/**\n * scsih_slave_destroy - device destroy routine\n * @sdev: scsi device struct\n */\nstatic void\nscsih_slave_destroy(struct scsi_device *sdev)\n{\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct scsi_target *starget;\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tstruct _sas_device *sas_device;\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\n\tif (!sdev->hostdata)\n\t\treturn;\n\n\tstarget = scsi_target(sdev);\n\tsas_target_priv_data = starget->hostdata;\n\tsas_target_priv_data->num_luns--;\n\n\tshost = dev_to_shost(&starget->dev);\n\tioc = shost_priv(shost);\n\n\tif (sas_target_priv_data->flags & MPT_TARGET_FLAGS_PCIE_DEVICE) {\n\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\tpcie_device = __mpt3sas_get_pdev_from_target(ioc,\n\t\t\t\tsas_target_priv_data);\n\t\tif (pcie_device && !sas_target_priv_data->num_luns)\n\t\t\tpcie_device->starget = NULL;\n\n\t\tif (pcie_device)\n\t\t\tpcie_device_put(pcie_device);\n\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\t} else if (!(sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME)) {\n\t\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\t\tsas_device = __mpt3sas_get_sdev_from_target(ioc,\n\t\t\t\tsas_target_priv_data);\n\t\tif (sas_device && !sas_target_priv_data->num_luns)\n\t\t\tsas_device->starget = NULL;\n\n\t\tif (sas_device)\n\t\t\tsas_device_put(sas_device);\n\t\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\t}\n\n\tkfree(sdev->hostdata);\n\tsdev->hostdata = NULL;\n}\n\n/**\n * _scsih_display_sata_capabilities - sata capabilities\n * @ioc: per adapter object\n * @handle: device handle\n * @sdev: scsi device struct\n */\nstatic void\n_scsih_display_sata_capabilities(struct MPT3SAS_ADAPTER *ioc,\n\tu16 handle, struct scsi_device *sdev)\n{\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tu32 ioc_status;\n\tu16 flags;\n\tu32 device_info;\n\n\tif ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\n\t    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tflags = le16_to_cpu(sas_device_pg0.Flags);\n\tdevice_info = le32_to_cpu(sas_device_pg0.DeviceInfo);\n\n\tsdev_printk(KERN_INFO, sdev,\n\t    \"atapi(%s), ncq(%s), asyn_notify(%s), smart(%s), fua(%s), \"\n\t    \"sw_preserve(%s)\\n\",\n\t    (device_info & MPI2_SAS_DEVICE_INFO_ATAPI_DEVICE) ? \"y\" : \"n\",\n\t    (flags & MPI2_SAS_DEVICE0_FLAGS_SATA_NCQ_SUPPORTED) ? \"y\" : \"n\",\n\t    (flags & MPI2_SAS_DEVICE0_FLAGS_SATA_ASYNCHRONOUS_NOTIFY) ? \"y\" :\n\t    \"n\",\n\t    (flags & MPI2_SAS_DEVICE0_FLAGS_SATA_SMART_SUPPORTED) ? \"y\" : \"n\",\n\t    (flags & MPI2_SAS_DEVICE0_FLAGS_SATA_FUA_SUPPORTED) ? \"y\" : \"n\",\n\t    (flags & MPI2_SAS_DEVICE0_FLAGS_SATA_SW_PRESERVE) ? \"y\" : \"n\");\n}\n\n/*\n * raid transport support -\n * Enabled for SLES11 and newer, in older kernels the driver will panic when\n * unloading the driver followed by a load - I believe that the subroutine\n * raid_class_release() is not cleaning up properly.\n */\n\n/**\n * scsih_is_raid - return boolean indicating device is raid volume\n * @dev: the device struct object\n */\nstatic int\nscsih_is_raid(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(sdev->host);\n\n\tif (ioc->is_warpdrive)\n\t\treturn 0;\n\treturn (sdev->channel == RAID_CHANNEL) ? 1 : 0;\n}\n\nstatic int\nscsih_is_nvme(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\n\treturn (sdev->channel == PCIE_CHANNEL) ? 1 : 0;\n}\n\n/**\n * scsih_get_resync - get raid volume resync percent complete\n * @dev: the device struct object\n */\nstatic void\nscsih_get_resync(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(sdev->host);\n\tstatic struct _raid_device *raid_device;\n\tunsigned long flags;\n\tMpi2RaidVolPage0_t vol_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu32 volume_status_flags;\n\tu8 percent_complete;\n\tu16 handle;\n\n\tpercent_complete = 0;\n\thandle = 0;\n\tif (ioc->is_warpdrive)\n\t\tgoto out;\n\n\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\traid_device = _scsih_raid_device_find_by_id(ioc, sdev->id,\n\t    sdev->channel);\n\tif (raid_device) {\n\t\thandle = raid_device->handle;\n\t\tpercent_complete = raid_device->percent_complete;\n\t}\n\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\n\tif (!handle)\n\t\tgoto out;\n\n\tif (mpt3sas_config_get_raid_volume_pg0(ioc, &mpi_reply, &vol_pg0,\n\t     MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, handle,\n\t     sizeof(Mpi2RaidVolPage0_t))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tpercent_complete = 0;\n\t\tgoto out;\n\t}\n\n\tvolume_status_flags = le32_to_cpu(vol_pg0.VolumeStatusFlags);\n\tif (!(volume_status_flags &\n\t    MPI2_RAIDVOL0_STATUS_FLAG_RESYNC_IN_PROGRESS))\n\t\tpercent_complete = 0;\n\n out:\n\n\tswitch (ioc->hba_mpi_version_belonged) {\n\tcase MPI2_VERSION:\n\t\traid_set_resync(mpt2sas_raid_template, dev, percent_complete);\n\t\tbreak;\n\tcase MPI25_VERSION:\n\tcase MPI26_VERSION:\n\t\traid_set_resync(mpt3sas_raid_template, dev, percent_complete);\n\t\tbreak;\n\t}\n}\n\n/**\n * scsih_get_state - get raid volume level\n * @dev: the device struct object\n */\nstatic void\nscsih_get_state(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(sdev->host);\n\tstatic struct _raid_device *raid_device;\n\tunsigned long flags;\n\tMpi2RaidVolPage0_t vol_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu32 volstate;\n\tenum raid_state state = RAID_STATE_UNKNOWN;\n\tu16 handle = 0;\n\n\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\traid_device = _scsih_raid_device_find_by_id(ioc, sdev->id,\n\t    sdev->channel);\n\tif (raid_device)\n\t\thandle = raid_device->handle;\n\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\n\tif (!raid_device)\n\t\tgoto out;\n\n\tif (mpt3sas_config_get_raid_volume_pg0(ioc, &mpi_reply, &vol_pg0,\n\t     MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, handle,\n\t     sizeof(Mpi2RaidVolPage0_t))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\n\tvolstate = le32_to_cpu(vol_pg0.VolumeStatusFlags);\n\tif (volstate & MPI2_RAIDVOL0_STATUS_FLAG_RESYNC_IN_PROGRESS) {\n\t\tstate = RAID_STATE_RESYNCING;\n\t\tgoto out;\n\t}\n\n\tswitch (vol_pg0.VolumeState) {\n\tcase MPI2_RAID_VOL_STATE_OPTIMAL:\n\tcase MPI2_RAID_VOL_STATE_ONLINE:\n\t\tstate = RAID_STATE_ACTIVE;\n\t\tbreak;\n\tcase  MPI2_RAID_VOL_STATE_DEGRADED:\n\t\tstate = RAID_STATE_DEGRADED;\n\t\tbreak;\n\tcase MPI2_RAID_VOL_STATE_FAILED:\n\tcase MPI2_RAID_VOL_STATE_MISSING:\n\t\tstate = RAID_STATE_OFFLINE;\n\t\tbreak;\n\t}\n out:\n\tswitch (ioc->hba_mpi_version_belonged) {\n\tcase MPI2_VERSION:\n\t\traid_set_state(mpt2sas_raid_template, dev, state);\n\t\tbreak;\n\tcase MPI25_VERSION:\n\tcase MPI26_VERSION:\n\t\traid_set_state(mpt3sas_raid_template, dev, state);\n\t\tbreak;\n\t}\n}\n\n/**\n * _scsih_set_level - set raid level\n * @ioc: ?\n * @sdev: scsi device struct\n * @volume_type: volume type\n */\nstatic void\n_scsih_set_level(struct MPT3SAS_ADAPTER *ioc,\n\tstruct scsi_device *sdev, u8 volume_type)\n{\n\tenum raid_level level = RAID_LEVEL_UNKNOWN;\n\n\tswitch (volume_type) {\n\tcase MPI2_RAID_VOL_TYPE_RAID0:\n\t\tlevel = RAID_LEVEL_0;\n\t\tbreak;\n\tcase MPI2_RAID_VOL_TYPE_RAID10:\n\t\tlevel = RAID_LEVEL_10;\n\t\tbreak;\n\tcase MPI2_RAID_VOL_TYPE_RAID1E:\n\t\tlevel = RAID_LEVEL_1E;\n\t\tbreak;\n\tcase MPI2_RAID_VOL_TYPE_RAID1:\n\t\tlevel = RAID_LEVEL_1;\n\t\tbreak;\n\t}\n\n\tswitch (ioc->hba_mpi_version_belonged) {\n\tcase MPI2_VERSION:\n\t\traid_set_level(mpt2sas_raid_template,\n\t\t\t&sdev->sdev_gendev, level);\n\t\tbreak;\n\tcase MPI25_VERSION:\n\tcase MPI26_VERSION:\n\t\traid_set_level(mpt3sas_raid_template,\n\t\t\t&sdev->sdev_gendev, level);\n\t\tbreak;\n\t}\n}\n\n\n/**\n * _scsih_get_volume_capabilities - volume capabilities\n * @ioc: per adapter object\n * @raid_device: the raid_device object\n *\n * Return: 0 for success, else 1\n */\nstatic int\n_scsih_get_volume_capabilities(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _raid_device *raid_device)\n{\n\tMpi2RaidVolPage0_t *vol_pg0;\n\tMpi2RaidPhysDiskPage0_t pd_pg0;\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 sz;\n\tu8 num_pds;\n\n\tif ((mpt3sas_config_get_number_pds(ioc, raid_device->handle,\n\t    &num_pds)) || !num_pds) {\n\t\tdfailprintk(ioc,\n\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\treturn 1;\n\t}\n\n\traid_device->num_pds = num_pds;\n\tsz = offsetof(Mpi2RaidVolPage0_t, PhysDisk) + (num_pds *\n\t    sizeof(Mpi2RaidVol0PhysDisk_t));\n\tvol_pg0 = kzalloc(sz, GFP_KERNEL);\n\tif (!vol_pg0) {\n\t\tdfailprintk(ioc,\n\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\treturn 1;\n\t}\n\n\tif ((mpt3sas_config_get_raid_volume_pg0(ioc, &mpi_reply, vol_pg0,\n\t     MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, raid_device->handle, sz))) {\n\t\tdfailprintk(ioc,\n\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\tkfree(vol_pg0);\n\t\treturn 1;\n\t}\n\n\traid_device->volume_type = vol_pg0->VolumeType;\n\n\t/* figure out what the underlying devices are by\n\t * obtaining the device_info bits for the 1st device\n\t */\n\tif (!(mpt3sas_config_get_phys_disk_pg0(ioc, &mpi_reply,\n\t    &pd_pg0, MPI2_PHYSDISK_PGAD_FORM_PHYSDISKNUM,\n\t    vol_pg0->PhysDisk[0].PhysDiskNum))) {\n\t\tif (!(mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply,\n\t\t    &sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_HANDLE,\n\t\t    le16_to_cpu(pd_pg0.DevHandle)))) {\n\t\t\traid_device->device_info =\n\t\t\t    le32_to_cpu(sas_device_pg0.DeviceInfo);\n\t\t}\n\t}\n\n\tkfree(vol_pg0);\n\treturn 0;\n}\n\n/**\n * _scsih_enable_tlr - setting TLR flags\n * @ioc: per adapter object\n * @sdev: scsi device struct\n *\n * Enabling Transaction Layer Retries for tape devices when\n * vpd page 0x90 is present\n *\n */\nstatic void\n_scsih_enable_tlr(struct MPT3SAS_ADAPTER *ioc, struct scsi_device *sdev)\n{\n\n\t/* only for TAPE */\n\tif (sdev->type != TYPE_TAPE)\n\t\treturn;\n\n\tif (!(ioc->facts.IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_TLR))\n\t\treturn;\n\n\tsas_enable_tlr(sdev);\n\tsdev_printk(KERN_INFO, sdev, \"TLR %s\\n\",\n\t    sas_is_tlr_enabled(sdev) ? \"Enabled\" : \"Disabled\");\n\treturn;\n\n}\n\n/**\n * scsih_slave_configure - device configure routine.\n * @sdev: scsi device struct\n *\n * Return: 0 if ok. Any other return is assumed to be an error and\n * the device is ignored.\n */\nstatic int\nscsih_slave_configure(struct scsi_device *sdev)\n{\n\tstruct Scsi_Host *shost = sdev->host;\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct _sas_device *sas_device;\n\tstruct _pcie_device *pcie_device;\n\tstruct _raid_device *raid_device;\n\tunsigned long flags;\n\tint qdepth;\n\tu8 ssp_target = 0;\n\tchar *ds = \"\";\n\tchar *r_level = \"\";\n\tu16 handle, volume_handle = 0;\n\tu64 volume_wwid = 0;\n\n\tqdepth = 1;\n\tsas_device_priv_data = sdev->hostdata;\n\tsas_device_priv_data->configured_lun = 1;\n\tsas_device_priv_data->flags &= ~MPT_DEVICE_FLAGS_INIT;\n\tsas_target_priv_data = sas_device_priv_data->sas_target;\n\thandle = sas_target_priv_data->handle;\n\n\t/* raid volume handling */\n\tif (sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME) {\n\n\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\traid_device = mpt3sas_raid_device_find_by_handle(ioc, handle);\n\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t\tif (!raid_device) {\n\t\t\tdfailprintk(ioc,\n\t\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (_scsih_get_volume_capabilities(ioc, raid_device)) {\n\t\t\tdfailprintk(ioc,\n\t\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\t\treturn 1;\n\t\t}\n\n\t\t/*\n\t\t * WARPDRIVE: Initialize the required data for Direct IO\n\t\t */\n\t\tmpt3sas_init_warpdrive_properties(ioc, raid_device);\n\n\t\t/* RAID Queue Depth Support\n\t\t * IS volume = underlying qdepth of drive type, either\n\t\t *    MPT3SAS_SAS_QUEUE_DEPTH or MPT3SAS_SATA_QUEUE_DEPTH\n\t\t * IM/IME/R10 = 128 (MPT3SAS_RAID_QUEUE_DEPTH)\n\t\t */\n\t\tif (raid_device->device_info &\n\t\t    MPI2_SAS_DEVICE_INFO_SSP_TARGET) {\n\t\t\tqdepth = MPT3SAS_SAS_QUEUE_DEPTH;\n\t\t\tds = \"SSP\";\n\t\t} else {\n\t\t\tqdepth = MPT3SAS_SATA_QUEUE_DEPTH;\n\t\t\tif (raid_device->device_info &\n\t\t\t    MPI2_SAS_DEVICE_INFO_SATA_DEVICE)\n\t\t\t\tds = \"SATA\";\n\t\t\telse\n\t\t\t\tds = \"STP\";\n\t\t}\n\n\t\tswitch (raid_device->volume_type) {\n\t\tcase MPI2_RAID_VOL_TYPE_RAID0:\n\t\t\tr_level = \"RAID0\";\n\t\t\tbreak;\n\t\tcase MPI2_RAID_VOL_TYPE_RAID1E:\n\t\t\tqdepth = MPT3SAS_RAID_QUEUE_DEPTH;\n\t\t\tif (ioc->manu_pg10.OEMIdentifier &&\n\t\t\t    (le32_to_cpu(ioc->manu_pg10.GenericFlags0) &\n\t\t\t    MFG10_GF0_R10_DISPLAY) &&\n\t\t\t    !(raid_device->num_pds % 2))\n\t\t\t\tr_level = \"RAID10\";\n\t\t\telse\n\t\t\t\tr_level = \"RAID1E\";\n\t\t\tbreak;\n\t\tcase MPI2_RAID_VOL_TYPE_RAID1:\n\t\t\tqdepth = MPT3SAS_RAID_QUEUE_DEPTH;\n\t\t\tr_level = \"RAID1\";\n\t\t\tbreak;\n\t\tcase MPI2_RAID_VOL_TYPE_RAID10:\n\t\t\tqdepth = MPT3SAS_RAID_QUEUE_DEPTH;\n\t\t\tr_level = \"RAID10\";\n\t\t\tbreak;\n\t\tcase MPI2_RAID_VOL_TYPE_UNKNOWN:\n\t\tdefault:\n\t\t\tqdepth = MPT3SAS_RAID_QUEUE_DEPTH;\n\t\t\tr_level = \"RAIDX\";\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ioc->hide_ir_msg)\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t   \"%s: handle(0x%04x), wwid(0x%016llx),\"\n\t\t\t    \" pd_count(%d), type(%s)\\n\",\n\t\t\t    r_level, raid_device->handle,\n\t\t\t    (unsigned long long)raid_device->wwid,\n\t\t\t    raid_device->num_pds, ds);\n\n\t\tif (shost->max_sectors > MPT3SAS_RAID_MAX_SECTORS) {\n\t\t\tblk_queue_max_hw_sectors(sdev->request_queue,\n\t\t\t\t\t\tMPT3SAS_RAID_MAX_SECTORS);\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t\t\"Set queue's max_sector to: %u\\n\",\n\t\t\t\t\t\tMPT3SAS_RAID_MAX_SECTORS);\n\t\t}\n\n\t\tmpt3sas_scsih_change_queue_depth(sdev, qdepth);\n\n\t\t/* raid transport support */\n\t\tif (!ioc->is_warpdrive)\n\t\t\t_scsih_set_level(ioc, sdev, raid_device->volume_type);\n\t\treturn 0;\n\t}\n\n\t/* non-raid handling */\n\tif (sas_target_priv_data->flags & MPT_TARGET_FLAGS_RAID_COMPONENT) {\n\t\tif (mpt3sas_config_get_volume_handle(ioc, handle,\n\t\t    &volume_handle)) {\n\t\t\tdfailprintk(ioc,\n\t\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\t\treturn 1;\n\t\t}\n\t\tif (volume_handle && mpt3sas_config_get_volume_wwid(ioc,\n\t\t    volume_handle, &volume_wwid)) {\n\t\t\tdfailprintk(ioc,\n\t\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* PCIe handling */\n\tif (sas_target_priv_data->flags & MPT_TARGET_FLAGS_PCIE_DEVICE) {\n\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\tpcie_device = __mpt3sas_get_pdev_by_wwid(ioc,\n\t\t\t\tsas_device_priv_data->sas_target->sas_address);\n\t\tif (!pcie_device) {\n\t\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\t\tdfailprintk(ioc,\n\t\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\t\treturn 1;\n\t\t}\n\n\t\tqdepth = MPT3SAS_NVME_QUEUE_DEPTH;\n\t\tds = \"NVMe\";\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\"%s: handle(0x%04x), wwid(0x%016llx), port(%d)\\n\",\n\t\t\tds, handle, (unsigned long long)pcie_device->wwid,\n\t\t\tpcie_device->port_num);\n\t\tif (pcie_device->enclosure_handle != 0)\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\"%s: enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\tds,\n\t\t\t(unsigned long long)pcie_device->enclosure_logical_id,\n\t\t\tpcie_device->slot);\n\t\tif (pcie_device->connector_name[0] != '\\0')\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t\"%s: enclosure level(0x%04x),\"\n\t\t\t\t\"connector name( %s)\\n\", ds,\n\t\t\t\tpcie_device->enclosure_level,\n\t\t\t\tpcie_device->connector_name);\n\n\t\tif (pcie_device->nvme_mdts)\n\t\t\tblk_queue_max_hw_sectors(sdev->request_queue,\n\t\t\t\t\tpcie_device->nvme_mdts/512);\n\n\t\tpcie_device_put(pcie_device);\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\tmpt3sas_scsih_change_queue_depth(sdev, qdepth);\n\t\t/* Enable QUEUE_FLAG_NOMERGES flag, so that IOs won't be\n\t\t ** merged and can eliminate holes created during merging\n\t\t ** operation.\n\t\t **/\n\t\tblk_queue_flag_set(QUEUE_FLAG_NOMERGES,\n\t\t\t\tsdev->request_queue);\n\t\tblk_queue_virt_boundary(sdev->request_queue,\n\t\t\t\tioc->page_size - 1);\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_addr(ioc,\n\t   sas_device_priv_data->sas_target->sas_address,\n\t   sas_device_priv_data->sas_target->port);\n\tif (!sas_device) {\n\t\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\t\tdfailprintk(ioc,\n\t\t\t    ioc_warn(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t     __FILE__, __LINE__, __func__));\n\t\treturn 1;\n\t}\n\n\tsas_device->volume_handle = volume_handle;\n\tsas_device->volume_wwid = volume_wwid;\n\tif (sas_device->device_info & MPI2_SAS_DEVICE_INFO_SSP_TARGET) {\n\t\tqdepth = MPT3SAS_SAS_QUEUE_DEPTH;\n\t\tssp_target = 1;\n\t\tif (sas_device->device_info &\n\t\t\t\tMPI2_SAS_DEVICE_INFO_SEP) {\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\"set ignore_delay_remove for handle(0x%04x)\\n\",\n\t\t\tsas_device_priv_data->sas_target->handle);\n\t\t\tsas_device_priv_data->ignore_delay_remove = 1;\n\t\t\tds = \"SES\";\n\t\t} else\n\t\t\tds = \"SSP\";\n\t} else {\n\t\tqdepth = MPT3SAS_SATA_QUEUE_DEPTH;\n\t\tif (sas_device->device_info & MPI2_SAS_DEVICE_INFO_STP_TARGET)\n\t\t\tds = \"STP\";\n\t\telse if (sas_device->device_info &\n\t\t    MPI2_SAS_DEVICE_INFO_SATA_DEVICE)\n\t\t\tds = \"SATA\";\n\t}\n\n\tsdev_printk(KERN_INFO, sdev, \"%s: handle(0x%04x), \" \\\n\t    \"sas_addr(0x%016llx), phy(%d), device_name(0x%016llx)\\n\",\n\t    ds, handle, (unsigned long long)sas_device->sas_address,\n\t    sas_device->phy, (unsigned long long)sas_device->device_name);\n\n\t_scsih_display_enclosure_chassis_info(NULL, sas_device, sdev, NULL);\n\n\tsas_device_put(sas_device);\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\tif (!ssp_target)\n\t\t_scsih_display_sata_capabilities(ioc, handle, sdev);\n\n\n\tmpt3sas_scsih_change_queue_depth(sdev, qdepth);\n\n\tif (ssp_target) {\n\t\tsas_read_port_mode_page(sdev);\n\t\t_scsih_enable_tlr(ioc, sdev);\n\t}\n\n\treturn 0;\n}\n\n/**\n * scsih_bios_param - fetch head, sector, cylinder info for a disk\n * @sdev: scsi device struct\n * @bdev: pointer to block device context\n * @capacity: device size (in 512 byte sectors)\n * @params: three element array to place output:\n *              params[0] number of heads (max 255)\n *              params[1] number of sectors (max 63)\n *              params[2] number of cylinders\n */\nstatic int\nscsih_bios_param(struct scsi_device *sdev, struct block_device *bdev,\n\tsector_t capacity, int params[])\n{\n\tint\t\theads;\n\tint\t\tsectors;\n\tsector_t\tcylinders;\n\tulong\t\tdummy;\n\n\theads = 64;\n\tsectors = 32;\n\n\tdummy = heads * sectors;\n\tcylinders = capacity;\n\tsector_div(cylinders, dummy);\n\n\t/*\n\t * Handle extended translation size for logical drives\n\t * > 1Gb\n\t */\n\tif ((ulong)capacity >= 0x200000) {\n\t\theads = 255;\n\t\tsectors = 63;\n\t\tdummy = heads * sectors;\n\t\tcylinders = capacity;\n\t\tsector_div(cylinders, dummy);\n\t}\n\n\t/* return result */\n\tparams[0] = heads;\n\tparams[1] = sectors;\n\tparams[2] = cylinders;\n\n\treturn 0;\n}\n\n/**\n * _scsih_response_code - translation of device response code\n * @ioc: per adapter object\n * @response_code: response code returned by the device\n */\nstatic void\n_scsih_response_code(struct MPT3SAS_ADAPTER *ioc, u8 response_code)\n{\n\tchar *desc;\n\n\tswitch (response_code) {\n\tcase MPI2_SCSITASKMGMT_RSP_TM_COMPLETE:\n\t\tdesc = \"task management request completed\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_INVALID_FRAME:\n\t\tdesc = \"invalid frame\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_TM_NOT_SUPPORTED:\n\t\tdesc = \"task management request not supported\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_TM_FAILED:\n\t\tdesc = \"task management request failed\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_TM_SUCCEEDED:\n\t\tdesc = \"task management request succeeded\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_TM_INVALID_LUN:\n\t\tdesc = \"invalid lun\";\n\t\tbreak;\n\tcase 0xA:\n\t\tdesc = \"overlapped tag attempted\";\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC:\n\t\tdesc = \"task queued, however not sent to target\";\n\t\tbreak;\n\tdefault:\n\t\tdesc = \"unknown\";\n\t\tbreak;\n\t}\n\tioc_warn(ioc, \"response_code(0x%01x): %s\\n\", response_code, desc);\n}\n\n/**\n * _scsih_tm_done - tm completion routine\n * @ioc: per adapter object\n * @smid: system request message index\n * @msix_index: MSIX table index supplied by the OS\n * @reply: reply message frame(lower 32bit addr)\n * Context: none.\n *\n * The callback handler when using scsih_issue_tm.\n *\n * Return: 1 meaning mf should be freed from _base_interrupt\n *         0 means the mf is freed from this function.\n */\nstatic u8\n_scsih_tm_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)\n{\n\tMPI2DefaultReply_t *mpi_reply;\n\n\tif (ioc->tm_cmds.status == MPT3_CMD_NOT_USED)\n\t\treturn 1;\n\tif (ioc->tm_cmds.smid != smid)\n\t\treturn 1;\n\tioc->tm_cmds.status |= MPT3_CMD_COMPLETE;\n\tmpi_reply =  mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\tif (mpi_reply) {\n\t\tmemcpy(ioc->tm_cmds.reply, mpi_reply, mpi_reply->MsgLength*4);\n\t\tioc->tm_cmds.status |= MPT3_CMD_REPLY_VALID;\n\t}\n\tioc->tm_cmds.status &= ~MPT3_CMD_PENDING;\n\tcomplete(&ioc->tm_cmds.done);\n\treturn 1;\n}\n\n/**\n * mpt3sas_scsih_set_tm_flag - set per target tm_busy\n * @ioc: per adapter object\n * @handle: device handle\n *\n * During taskmangement request, we need to freeze the device queue.\n */\nvoid\nmpt3sas_scsih_set_tm_flag(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsi_device *sdev;\n\tu8 skip = 0;\n\n\tshost_for_each_device(sdev, ioc->shost) {\n\t\tif (skip)\n\t\t\tcontinue;\n\t\tsas_device_priv_data = sdev->hostdata;\n\t\tif (!sas_device_priv_data)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->sas_target->handle == handle) {\n\t\t\tsas_device_priv_data->sas_target->tm_busy = 1;\n\t\t\tskip = 1;\n\t\t\tioc->ignore_loginfos = 1;\n\t\t}\n\t}\n}\n\n/**\n * mpt3sas_scsih_clear_tm_flag - clear per target tm_busy\n * @ioc: per adapter object\n * @handle: device handle\n *\n * During taskmangement request, we need to freeze the device queue.\n */\nvoid\nmpt3sas_scsih_clear_tm_flag(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsi_device *sdev;\n\tu8 skip = 0;\n\n\tshost_for_each_device(sdev, ioc->shost) {\n\t\tif (skip)\n\t\t\tcontinue;\n\t\tsas_device_priv_data = sdev->hostdata;\n\t\tif (!sas_device_priv_data)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->sas_target->handle == handle) {\n\t\t\tsas_device_priv_data->sas_target->tm_busy = 0;\n\t\t\tskip = 1;\n\t\t\tioc->ignore_loginfos = 0;\n\t\t}\n\t}\n}\n\n/**\n * scsih_tm_cmd_map_status - map the target reset & LUN reset TM status\n * @ioc: per adapter object\n * @channel: the channel assigned by the OS\n * @id: the id assigned by the OS\n * @lun: lun number\n * @type: MPI2_SCSITASKMGMT_TASKTYPE__XXX (defined in mpi2_init.h)\n * @smid_task: smid assigned to the task\n *\n * Look whether TM has aborted the timed out SCSI command, if\n * TM has aborted the IO then return SUCCESS else return FAILED.\n */\nstatic int\nscsih_tm_cmd_map_status(struct MPT3SAS_ADAPTER *ioc, uint channel,\n\tuint id, uint lun, u8 type, u16 smid_task)\n{\n\n\tif (smid_task <= ioc->shost->can_queue) {\n\t\tswitch (type) {\n\t\tcase MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET:\n\t\t\tif (!(_scsih_scsi_lookup_find_by_target(ioc,\n\t\t\t    id, channel)))\n\t\t\t\treturn SUCCESS;\n\t\t\tbreak;\n\t\tcase MPI2_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET:\n\t\tcase MPI2_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET:\n\t\t\tif (!(_scsih_scsi_lookup_find_by_lun(ioc, id,\n\t\t\t    lun, channel)))\n\t\t\t\treturn SUCCESS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn SUCCESS;\n\t\t}\n\t} else if (smid_task == ioc->scsih_cmds.smid) {\n\t\tif ((ioc->scsih_cmds.status & MPT3_CMD_COMPLETE) ||\n\t\t    (ioc->scsih_cmds.status & MPT3_CMD_NOT_USED))\n\t\t\treturn SUCCESS;\n\t} else if (smid_task == ioc->ctl_cmds.smid) {\n\t\tif ((ioc->ctl_cmds.status & MPT3_CMD_COMPLETE) ||\n\t\t    (ioc->ctl_cmds.status & MPT3_CMD_NOT_USED))\n\t\t\treturn SUCCESS;\n\t}\n\n\treturn FAILED;\n}\n\n/**\n * scsih_tm_post_processing - post processing of target & LUN reset\n * @ioc: per adapter object\n * @handle: device handle\n * @channel: the channel assigned by the OS\n * @id: the id assigned by the OS\n * @lun: lun number\n * @type: MPI2_SCSITASKMGMT_TASKTYPE__XXX (defined in mpi2_init.h)\n * @smid_task: smid assigned to the task\n *\n * Post processing of target & LUN reset. Due to interrupt latency\n * issue it possible that interrupt for aborted IO might not be\n * received yet. So before returning failure status, poll the\n * reply descriptor pools for the reply of timed out SCSI command.\n * Return FAILED status if reply for timed out is not received\n * otherwise return SUCCESS.\n */\nstatic int\nscsih_tm_post_processing(struct MPT3SAS_ADAPTER *ioc, u16 handle,\n\tuint channel, uint id, uint lun, u8 type, u16 smid_task)\n{\n\tint rc;\n\n\trc = scsih_tm_cmd_map_status(ioc, channel, id, lun, type, smid_task);\n\tif (rc == SUCCESS)\n\t\treturn rc;\n\n\tioc_info(ioc,\n\t    \"Poll ReplyDescriptor queues for completion of\"\n\t    \" smid(%d), task_type(0x%02x), handle(0x%04x)\\n\",\n\t    smid_task, type, handle);\n\n\t/*\n\t * Due to interrupt latency issues, driver may receive interrupt for\n\t * TM first and then for aborted SCSI IO command. So, poll all the\n\t * ReplyDescriptor pools before returning the FAILED status to SML.\n\t */\n\tmpt3sas_base_mask_interrupts(ioc);\n\tmpt3sas_base_sync_reply_irqs(ioc, 1);\n\tmpt3sas_base_unmask_interrupts(ioc);\n\n\treturn scsih_tm_cmd_map_status(ioc, channel, id, lun, type, smid_task);\n}\n\n/**\n * mpt3sas_scsih_issue_tm - main routine for sending tm requests\n * @ioc: per adapter struct\n * @handle: device handle\n * @channel: the channel assigned by the OS\n * @id: the id assigned by the OS\n * @lun: lun number\n * @type: MPI2_SCSITASKMGMT_TASKTYPE__XXX (defined in mpi2_init.h)\n * @smid_task: smid assigned to the task\n * @msix_task: MSIX table index supplied by the OS\n * @timeout: timeout in seconds\n * @tr_method: Target Reset Method\n * Context: user\n *\n * A generic API for sending task management requests to firmware.\n *\n * The callback index is set inside `ioc->tm_cb_idx`.\n * The caller is responsible to check for outstanding commands.\n *\n * Return: SUCCESS or FAILED.\n */\nint\nmpt3sas_scsih_issue_tm(struct MPT3SAS_ADAPTER *ioc, u16 handle, uint channel,\n\tuint id, u64 lun, u8 type, u16 smid_task, u16 msix_task,\n\tu8 timeout, u8 tr_method)\n{\n\tMpi2SCSITaskManagementRequest_t *mpi_request;\n\tMpi2SCSITaskManagementReply_t *mpi_reply;\n\tMpi25SCSIIORequest_t *request;\n\tu16 smid = 0;\n\tu32 ioc_state;\n\tint rc;\n\tu8 issue_reset = 0;\n\n\tlockdep_assert_held(&ioc->tm_cmds.mutex);\n\n\tif (ioc->tm_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_info(ioc, \"%s: tm_cmd busy!!!\\n\", __func__);\n\t\treturn FAILED;\n\t}\n\n\tif (ioc->shost_recovery || ioc->remove_host ||\n\t    ioc->pci_error_recovery) {\n\t\tioc_info(ioc, \"%s: host reset in progress!\\n\", __func__);\n\t\treturn FAILED;\n\t}\n\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 0);\n\tif (ioc_state & MPI2_DOORBELL_USED) {\n\t\tdhsprintk(ioc, ioc_info(ioc, \"unexpected doorbell active!\\n\"));\n\t\trc = mpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\t\treturn (!rc) ? SUCCESS : FAILED;\n\t}\n\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {\n\t\tmpt3sas_print_fault_code(ioc, ioc_state &\n\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\trc = mpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\t\treturn (!rc) ? SUCCESS : FAILED;\n\t} else if ((ioc_state & MPI2_IOC_STATE_MASK) ==\n\t    MPI2_IOC_STATE_COREDUMP) {\n\t\tmpt3sas_print_coredump_info(ioc, ioc_state &\n\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\trc = mpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\t\treturn (!rc) ? SUCCESS : FAILED;\n\t}\n\n\tsmid = mpt3sas_base_get_smid_hpr(ioc, ioc->tm_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\treturn FAILED;\n\t}\n\n\tdtmprintk(ioc,\n\t\t  ioc_info(ioc, \"sending tm: handle(0x%04x), task_type(0x%02x), smid(%d), timeout(%d), tr_method(0x%x)\\n\",\n\t\t\t   handle, type, smid_task, timeout, tr_method));\n\tioc->tm_cmds.status = MPT3_CMD_PENDING;\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->tm_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi2SCSITaskManagementRequest_t));\n\tmemset(ioc->tm_cmds.reply, 0, sizeof(Mpi2SCSITaskManagementReply_t));\n\tmpi_request->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;\n\tmpi_request->DevHandle = cpu_to_le16(handle);\n\tmpi_request->TaskType = type;\n\tif (type == MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK ||\n\t    type == MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK)\n\t\tmpi_request->MsgFlags = tr_method;\n\tmpi_request->TaskMID = cpu_to_le16(smid_task);\n\tint_to_scsilun(lun, (struct scsi_lun *)mpi_request->LUN);\n\tmpt3sas_scsih_set_tm_flag(ioc, handle);\n\tinit_completion(&ioc->tm_cmds.done);\n\tioc->put_smid_hi_priority(ioc, smid, msix_task);\n\twait_for_completion_timeout(&ioc->tm_cmds.done, timeout*HZ);\n\tif (!(ioc->tm_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tmpt3sas_check_cmd_timeout(ioc,\n\t\t    ioc->tm_cmds.status, mpi_request,\n\t\t    sizeof(Mpi2SCSITaskManagementRequest_t)/4, issue_reset);\n\t\tif (issue_reset) {\n\t\t\trc = mpt3sas_base_hard_reset_handler(ioc,\n\t\t\t\t\tFORCE_BIG_HAMMER);\n\t\t\trc = (!rc) ? SUCCESS : FAILED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* sync IRQs in case those were busy during flush. */\n\tmpt3sas_base_sync_reply_irqs(ioc, 0);\n\n\tif (ioc->tm_cmds.status & MPT3_CMD_REPLY_VALID) {\n\t\tmpt3sas_trigger_master(ioc, MASTER_TRIGGER_TASK_MANAGMENT);\n\t\tmpi_reply = ioc->tm_cmds.reply;\n\t\tdtmprintk(ioc,\n\t\t\t  ioc_info(ioc, \"complete tm: ioc_status(0x%04x), loginfo(0x%08x), term_count(0x%08x)\\n\",\n\t\t\t\t   le16_to_cpu(mpi_reply->IOCStatus),\n\t\t\t\t   le32_to_cpu(mpi_reply->IOCLogInfo),\n\t\t\t\t   le32_to_cpu(mpi_reply->TerminationCount)));\n\t\tif (ioc->logging_level & MPT_DEBUG_TM) {\n\t\t\t_scsih_response_code(ioc, mpi_reply->ResponseCode);\n\t\t\tif (mpi_reply->IOCStatus)\n\t\t\t\t_debug_dump_mf(mpi_request,\n\t\t\t\t    sizeof(Mpi2SCSITaskManagementRequest_t)/4);\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK:\n\t\trc = SUCCESS;\n\t\t/*\n\t\t * If DevHandle filed in smid_task's entry of request pool\n\t\t * doesn't match with device handle on which this task abort\n\t\t * TM is received then it means that TM has successfully\n\t\t * aborted the timed out command. Since smid_task's entry in\n\t\t * request pool will be memset to zero once the timed out\n\t\t * command is returned to the SML. If the command is not\n\t\t * aborted then smid_task\u2019s entry won\u2019t be cleared and it\n\t\t * will have same DevHandle value on which this task abort TM\n\t\t * is received and driver will return the TM status as FAILED.\n\t\t */\n\t\trequest = mpt3sas_base_get_msg_frame(ioc, smid_task);\n\t\tif (le16_to_cpu(request->DevHandle) != handle)\n\t\t\tbreak;\n\n\t\tioc_info(ioc, \"Task abort tm failed: handle(0x%04x),\"\n\t\t    \"timeout(%d) tr_method(0x%x) smid(%d) msix_index(%d)\\n\",\n\t\t    handle, timeout, tr_method, smid_task, msix_task);\n\t\trc = FAILED;\n\t\tbreak;\n\n\tcase MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET:\n\tcase MPI2_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET:\n\tcase MPI2_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET:\n\t\trc = scsih_tm_post_processing(ioc, handle, channel, id, lun,\n\t\t    type, smid_task);\n\t\tbreak;\n\tcase MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK:\n\t\trc = SUCCESS;\n\t\tbreak;\n\tdefault:\n\t\trc = FAILED;\n\t\tbreak;\n\t}\n\nout:\n\tmpt3sas_scsih_clear_tm_flag(ioc, handle);\n\tioc->tm_cmds.status = MPT3_CMD_NOT_USED;\n\treturn rc;\n}\n\nint mpt3sas_scsih_issue_locked_tm(struct MPT3SAS_ADAPTER *ioc, u16 handle,\n\t\tuint channel, uint id, u64 lun, u8 type, u16 smid_task,\n\t\tu16 msix_task, u8 timeout, u8 tr_method)\n{\n\tint ret;\n\n\tmutex_lock(&ioc->tm_cmds.mutex);\n\tret = mpt3sas_scsih_issue_tm(ioc, handle, channel, id, lun, type,\n\t\t\tsmid_task, msix_task, timeout, tr_method);\n\tmutex_unlock(&ioc->tm_cmds.mutex);\n\n\treturn ret;\n}\n\n/**\n * _scsih_tm_display_info - displays info about the device\n * @ioc: per adapter struct\n * @scmd: pointer to scsi command object\n *\n * Called by task management callback handlers.\n */\nstatic void\n_scsih_tm_display_info(struct MPT3SAS_ADAPTER *ioc, struct scsi_cmnd *scmd)\n{\n\tstruct scsi_target *starget = scmd->device->sdev_target;\n\tstruct MPT3SAS_TARGET *priv_target = starget->hostdata;\n\tstruct _sas_device *sas_device = NULL;\n\tstruct _pcie_device *pcie_device = NULL;\n\tunsigned long flags;\n\tchar *device_str = NULL;\n\n\tif (!priv_target)\n\t\treturn;\n\tif (ioc->hide_ir_msg)\n\t\tdevice_str = \"WarpDrive\";\n\telse\n\t\tdevice_str = \"volume\";\n\n\tscsi_print_command(scmd);\n\tif (priv_target->flags & MPT_TARGET_FLAGS_VOLUME) {\n\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\"%s handle(0x%04x), %s wwid(0x%016llx)\\n\",\n\t\t\tdevice_str, priv_target->handle,\n\t\t    device_str, (unsigned long long)priv_target->sas_address);\n\n\t} else if (priv_target->flags & MPT_TARGET_FLAGS_PCIE_DEVICE) {\n\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\tpcie_device = __mpt3sas_get_pdev_from_target(ioc, priv_target);\n\t\tif (pcie_device) {\n\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\t\"handle(0x%04x), wwid(0x%016llx), port(%d)\\n\",\n\t\t\t\tpcie_device->handle,\n\t\t\t\t(unsigned long long)pcie_device->wwid,\n\t\t\t\tpcie_device->port_num);\n\t\t\tif (pcie_device->enclosure_handle != 0)\n\t\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\t\t\"enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t\t(unsigned long long)\n\t\t\t\t\tpcie_device->enclosure_logical_id,\n\t\t\t\t\tpcie_device->slot);\n\t\t\tif (pcie_device->connector_name[0] != '\\0')\n\t\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\t\t\"enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t\t\tpcie_device->enclosure_level,\n\t\t\t\t\tpcie_device->connector_name);\n\t\t\tpcie_device_put(pcie_device);\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\t} else {\n\t\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\t\tsas_device = __mpt3sas_get_sdev_from_target(ioc, priv_target);\n\t\tif (sas_device) {\n\t\t\tif (priv_target->flags &\n\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT) {\n\t\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\t    \"volume handle(0x%04x), \"\n\t\t\t\t    \"volume wwid(0x%016llx)\\n\",\n\t\t\t\t    sas_device->volume_handle,\n\t\t\t\t   (unsigned long long)sas_device->volume_wwid);\n\t\t\t}\n\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t    \"handle(0x%04x), sas_address(0x%016llx), phy(%d)\\n\",\n\t\t\t    sas_device->handle,\n\t\t\t    (unsigned long long)sas_device->sas_address,\n\t\t\t    sas_device->phy);\n\n\t\t\t_scsih_display_enclosure_chassis_info(NULL, sas_device,\n\t\t\t    NULL, starget);\n\n\t\t\tsas_device_put(sas_device);\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\t}\n}\n\n/**\n * scsih_abort - eh threads main abort routine\n * @scmd: pointer to scsi command object\n *\n * Return: SUCCESS if command aborted else FAILED\n */\nstatic int\nscsih_abort(struct scsi_cmnd *scmd)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(scmd->device->host);\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsiio_tracker *st = scsi_cmd_priv(scmd);\n\tu16 handle;\n\tint r;\n\n\tu8 timeout = 30;\n\tstruct _pcie_device *pcie_device = NULL;\n\tsdev_printk(KERN_INFO, scmd->device, \"attempting task abort!\"\n\t    \"scmd(0x%p), outstanding for %u ms & timeout %u ms\\n\",\n\t    scmd, jiffies_to_msecs(jiffies - scmd->jiffies_at_alloc),\n\t    (scmd->request->timeout / HZ) * 1000);\n\t_scsih_tm_display_info(ioc, scmd);\n\n\tsas_device_priv_data = scmd->device->hostdata;\n\tif (!sas_device_priv_data || !sas_device_priv_data->sas_target ||\n\t    ioc->remove_host) {\n\t\tsdev_printk(KERN_INFO, scmd->device,\n\t\t    \"device been deleted! scmd(0x%p)\\n\", scmd);\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscmd->scsi_done(scmd);\n\t\tr = SUCCESS;\n\t\tgoto out;\n\t}\n\n\t/* check for completed command */\n\tif (st == NULL || st->cb_idx == 0xFF) {\n\t\tsdev_printk(KERN_INFO, scmd->device, \"No reference found at \"\n\t\t    \"driver, assuming scmd(0x%p) might have completed\\n\", scmd);\n\t\tscmd->result = DID_RESET << 16;\n\t\tr = SUCCESS;\n\t\tgoto out;\n\t}\n\n\t/* for hidden raid components and volumes this is not supported */\n\tif (sas_device_priv_data->sas_target->flags &\n\t    MPT_TARGET_FLAGS_RAID_COMPONENT ||\n\t    sas_device_priv_data->sas_target->flags & MPT_TARGET_FLAGS_VOLUME) {\n\t\tscmd->result = DID_RESET << 16;\n\t\tr = FAILED;\n\t\tgoto out;\n\t}\n\n\tmpt3sas_halt_firmware(ioc);\n\n\thandle = sas_device_priv_data->sas_target->handle;\n\tpcie_device = mpt3sas_get_pdev_by_handle(ioc, handle);\n\tif (pcie_device && (!ioc->tm_custom_handling) &&\n\t    (!(mpt3sas_scsih_is_pcie_scsi_device(pcie_device->device_info))))\n\t\ttimeout = ioc->nvme_abort_timeout;\n\tr = mpt3sas_scsih_issue_locked_tm(ioc, handle, scmd->device->channel,\n\t\tscmd->device->id, scmd->device->lun,\n\t\tMPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK,\n\t\tst->smid, st->msix_io, timeout, 0);\n\t/* Command must be cleared after abort */\n\tif (r == SUCCESS && st->cb_idx != 0xFF)\n\t\tr = FAILED;\n out:\n\tsdev_printk(KERN_INFO, scmd->device, \"task abort: %s scmd(0x%p)\\n\",\n\t    ((r == SUCCESS) ? \"SUCCESS\" : \"FAILED\"), scmd);\n\tif (pcie_device)\n\t\tpcie_device_put(pcie_device);\n\treturn r;\n}\n\n/**\n * scsih_dev_reset - eh threads main device reset routine\n * @scmd: pointer to scsi command object\n *\n * Return: SUCCESS if command aborted else FAILED\n */\nstatic int\nscsih_dev_reset(struct scsi_cmnd *scmd)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(scmd->device->host);\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct _sas_device *sas_device = NULL;\n\tstruct _pcie_device *pcie_device = NULL;\n\tu16\thandle;\n\tu8\ttr_method = 0;\n\tu8\ttr_timeout = 30;\n\tint r;\n\n\tstruct scsi_target *starget = scmd->device->sdev_target;\n\tstruct MPT3SAS_TARGET *target_priv_data = starget->hostdata;\n\n\tsdev_printk(KERN_INFO, scmd->device,\n\t    \"attempting device reset! scmd(0x%p)\\n\", scmd);\n\t_scsih_tm_display_info(ioc, scmd);\n\n\tsas_device_priv_data = scmd->device->hostdata;\n\tif (!sas_device_priv_data || !sas_device_priv_data->sas_target ||\n\t    ioc->remove_host) {\n\t\tsdev_printk(KERN_INFO, scmd->device,\n\t\t    \"device been deleted! scmd(0x%p)\\n\", scmd);\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscmd->scsi_done(scmd);\n\t\tr = SUCCESS;\n\t\tgoto out;\n\t}\n\n\t/* for hidden raid components obtain the volume_handle */\n\thandle = 0;\n\tif (sas_device_priv_data->sas_target->flags &\n\t    MPT_TARGET_FLAGS_RAID_COMPONENT) {\n\t\tsas_device = mpt3sas_get_sdev_from_target(ioc,\n\t\t\t\ttarget_priv_data);\n\t\tif (sas_device)\n\t\t\thandle = sas_device->volume_handle;\n\t} else\n\t\thandle = sas_device_priv_data->sas_target->handle;\n\n\tif (!handle) {\n\t\tscmd->result = DID_RESET << 16;\n\t\tr = FAILED;\n\t\tgoto out;\n\t}\n\n\tpcie_device = mpt3sas_get_pdev_by_handle(ioc, handle);\n\n\tif (pcie_device && (!ioc->tm_custom_handling) &&\n\t    (!(mpt3sas_scsih_is_pcie_scsi_device(pcie_device->device_info)))) {\n\t\ttr_timeout = pcie_device->reset_timeout;\n\t\ttr_method = MPI26_SCSITASKMGMT_MSGFLAGS_PROTOCOL_LVL_RST_PCIE;\n\t} else\n\t\ttr_method = MPI2_SCSITASKMGMT_MSGFLAGS_LINK_RESET;\n\n\tr = mpt3sas_scsih_issue_locked_tm(ioc, handle, scmd->device->channel,\n\t\tscmd->device->id, scmd->device->lun,\n\t\tMPI2_SCSITASKMGMT_TASKTYPE_LOGICAL_UNIT_RESET, 0, 0,\n\t\ttr_timeout, tr_method);\n\t/* Check for busy commands after reset */\n\tif (r == SUCCESS && atomic_read(&scmd->device->device_busy))\n\t\tr = FAILED;\n out:\n\tsdev_printk(KERN_INFO, scmd->device, \"device reset: %s scmd(0x%p)\\n\",\n\t    ((r == SUCCESS) ? \"SUCCESS\" : \"FAILED\"), scmd);\n\n\tif (sas_device)\n\t\tsas_device_put(sas_device);\n\tif (pcie_device)\n\t\tpcie_device_put(pcie_device);\n\n\treturn r;\n}\n\n/**\n * scsih_target_reset - eh threads main target reset routine\n * @scmd: pointer to scsi command object\n *\n * Return: SUCCESS if command aborted else FAILED\n */\nstatic int\nscsih_target_reset(struct scsi_cmnd *scmd)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(scmd->device->host);\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct _sas_device *sas_device = NULL;\n\tstruct _pcie_device *pcie_device = NULL;\n\tu16\thandle;\n\tu8\ttr_method = 0;\n\tu8\ttr_timeout = 30;\n\tint r;\n\tstruct scsi_target *starget = scmd->device->sdev_target;\n\tstruct MPT3SAS_TARGET *target_priv_data = starget->hostdata;\n\n\tstarget_printk(KERN_INFO, starget,\n\t    \"attempting target reset! scmd(0x%p)\\n\", scmd);\n\t_scsih_tm_display_info(ioc, scmd);\n\n\tsas_device_priv_data = scmd->device->hostdata;\n\tif (!sas_device_priv_data || !sas_device_priv_data->sas_target ||\n\t    ioc->remove_host) {\n\t\tstarget_printk(KERN_INFO, starget,\n\t\t    \"target been deleted! scmd(0x%p)\\n\", scmd);\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscmd->scsi_done(scmd);\n\t\tr = SUCCESS;\n\t\tgoto out;\n\t}\n\n\t/* for hidden raid components obtain the volume_handle */\n\thandle = 0;\n\tif (sas_device_priv_data->sas_target->flags &\n\t    MPT_TARGET_FLAGS_RAID_COMPONENT) {\n\t\tsas_device = mpt3sas_get_sdev_from_target(ioc,\n\t\t\t\ttarget_priv_data);\n\t\tif (sas_device)\n\t\t\thandle = sas_device->volume_handle;\n\t} else\n\t\thandle = sas_device_priv_data->sas_target->handle;\n\n\tif (!handle) {\n\t\tscmd->result = DID_RESET << 16;\n\t\tr = FAILED;\n\t\tgoto out;\n\t}\n\n\tpcie_device = mpt3sas_get_pdev_by_handle(ioc, handle);\n\n\tif (pcie_device && (!ioc->tm_custom_handling) &&\n\t    (!(mpt3sas_scsih_is_pcie_scsi_device(pcie_device->device_info)))) {\n\t\ttr_timeout = pcie_device->reset_timeout;\n\t\ttr_method = MPI26_SCSITASKMGMT_MSGFLAGS_PROTOCOL_LVL_RST_PCIE;\n\t} else\n\t\ttr_method = MPI2_SCSITASKMGMT_MSGFLAGS_LINK_RESET;\n\tr = mpt3sas_scsih_issue_locked_tm(ioc, handle, scmd->device->channel,\n\t\tscmd->device->id, 0,\n\t\tMPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET, 0, 0,\n\t    tr_timeout, tr_method);\n\t/* Check for busy commands after reset */\n\tif (r == SUCCESS && atomic_read(&starget->target_busy))\n\t\tr = FAILED;\n out:\n\tstarget_printk(KERN_INFO, starget, \"target reset: %s scmd(0x%p)\\n\",\n\t    ((r == SUCCESS) ? \"SUCCESS\" : \"FAILED\"), scmd);\n\n\tif (sas_device)\n\t\tsas_device_put(sas_device);\n\tif (pcie_device)\n\t\tpcie_device_put(pcie_device);\n\treturn r;\n}\n\n\n/**\n * scsih_host_reset - eh threads main host reset routine\n * @scmd: pointer to scsi command object\n *\n * Return: SUCCESS if command aborted else FAILED\n */\nstatic int\nscsih_host_reset(struct scsi_cmnd *scmd)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(scmd->device->host);\n\tint r, retval;\n\n\tioc_info(ioc, \"attempting host reset! scmd(0x%p)\\n\", scmd);\n\tscsi_print_command(scmd);\n\n\tif (ioc->is_driver_loading || ioc->remove_host) {\n\t\tioc_info(ioc, \"Blocking the host reset\\n\");\n\t\tr = FAILED;\n\t\tgoto out;\n\t}\n\n\tretval = mpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\tr = (retval < 0) ? FAILED : SUCCESS;\nout:\n\tioc_info(ioc, \"host reset: %s scmd(0x%p)\\n\",\n\t\t r == SUCCESS ? \"SUCCESS\" : \"FAILED\", scmd);\n\n\treturn r;\n}\n\n/**\n * _scsih_fw_event_add - insert and queue up fw_event\n * @ioc: per adapter object\n * @fw_event: object describing the event\n * Context: This function will acquire ioc->fw_event_lock.\n *\n * This adds the firmware event object into link list, then queues it up to\n * be processed from user context.\n */\nstatic void\n_scsih_fw_event_add(struct MPT3SAS_ADAPTER *ioc, struct fw_event_work *fw_event)\n{\n\tunsigned long flags;\n\n\tif (ioc->firmware_event_thread == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\tfw_event_work_get(fw_event);\n\tINIT_LIST_HEAD(&fw_event->list);\n\tlist_add_tail(&fw_event->list, &ioc->fw_event_list);\n\tINIT_WORK(&fw_event->work, _firmware_event_work);\n\tfw_event_work_get(fw_event);\n\tqueue_work(ioc->firmware_event_thread, &fw_event->work);\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n}\n\n/**\n * _scsih_fw_event_del_from_list - delete fw_event from the list\n * @ioc: per adapter object\n * @fw_event: object describing the event\n * Context: This function will acquire ioc->fw_event_lock.\n *\n * If the fw_event is on the fw_event_list, remove it and do a put.\n */\nstatic void\n_scsih_fw_event_del_from_list(struct MPT3SAS_ADAPTER *ioc, struct fw_event_work\n\t*fw_event)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\tif (!list_empty(&fw_event->list)) {\n\t\tlist_del_init(&fw_event->list);\n\t\tfw_event_work_put(fw_event);\n\t}\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n}\n\n\n /**\n * mpt3sas_send_trigger_data_event - send event for processing trigger data\n * @ioc: per adapter object\n * @event_data: trigger event data\n */\nvoid\nmpt3sas_send_trigger_data_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct SL_WH_TRIGGERS_EVENT_DATA_T *event_data)\n{\n\tstruct fw_event_work *fw_event;\n\tu16 sz;\n\n\tif (ioc->is_driver_loading)\n\t\treturn;\n\tsz = sizeof(*event_data);\n\tfw_event = alloc_fw_event_work(sz);\n\tif (!fw_event)\n\t\treturn;\n\tfw_event->event = MPT3SAS_PROCESS_TRIGGER_DIAG;\n\tfw_event->ioc = ioc;\n\tmemcpy(fw_event->event_data, event_data, sizeof(*event_data));\n\t_scsih_fw_event_add(ioc, fw_event);\n\tfw_event_work_put(fw_event);\n}\n\n/**\n * _scsih_error_recovery_delete_devices - remove devices not responding\n * @ioc: per adapter object\n */\nstatic void\n_scsih_error_recovery_delete_devices(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct fw_event_work *fw_event;\n\n\tif (ioc->is_driver_loading)\n\t\treturn;\n\tfw_event = alloc_fw_event_work(0);\n\tif (!fw_event)\n\t\treturn;\n\tfw_event->event = MPT3SAS_REMOVE_UNRESPONDING_DEVICES;\n\tfw_event->ioc = ioc;\n\t_scsih_fw_event_add(ioc, fw_event);\n\tfw_event_work_put(fw_event);\n}\n\n/**\n * mpt3sas_port_enable_complete - port enable completed (fake event)\n * @ioc: per adapter object\n */\nvoid\nmpt3sas_port_enable_complete(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct fw_event_work *fw_event;\n\n\tfw_event = alloc_fw_event_work(0);\n\tif (!fw_event)\n\t\treturn;\n\tfw_event->event = MPT3SAS_PORT_ENABLE_COMPLETE;\n\tfw_event->ioc = ioc;\n\t_scsih_fw_event_add(ioc, fw_event);\n\tfw_event_work_put(fw_event);\n}\n\nstatic struct fw_event_work *dequeue_next_fw_event(struct MPT3SAS_ADAPTER *ioc)\n{\n\tunsigned long flags;\n\tstruct fw_event_work *fw_event = NULL;\n\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\tif (!list_empty(&ioc->fw_event_list)) {\n\t\tfw_event = list_first_entry(&ioc->fw_event_list,\n\t\t\t\tstruct fw_event_work, list);\n\t\tlist_del_init(&fw_event->list);\n\t}\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n\n\treturn fw_event;\n}\n\n/**\n * _scsih_fw_event_cleanup_queue - cleanup event queue\n * @ioc: per adapter object\n *\n * Walk the firmware event queue, either killing timers, or waiting\n * for outstanding events to complete\n */\nstatic void\n_scsih_fw_event_cleanup_queue(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct fw_event_work *fw_event;\n\n\tif ((list_empty(&ioc->fw_event_list) && !ioc->current_event) ||\n\t     !ioc->firmware_event_thread || in_interrupt())\n\t\treturn;\n\n\tioc->fw_events_cleanup = 1;\n\twhile ((fw_event = dequeue_next_fw_event(ioc)) ||\n\t     (fw_event = ioc->current_event)) {\n\t\t/*\n\t\t * Wait on the fw_event to complete. If this returns 1, then\n\t\t * the event was never executed, and we need a put for the\n\t\t * reference the work had on the fw_event.\n\t\t *\n\t\t * If it did execute, we wait for it to finish, and the put will\n\t\t * happen from _firmware_event_work()\n\t\t */\n\t\tif (cancel_work_sync(&fw_event->work))\n\t\t\tfw_event_work_put(fw_event);\n\n\t\tfw_event_work_put(fw_event);\n\t}\n\tioc->fw_events_cleanup = 0;\n}\n\n/**\n * _scsih_internal_device_block - block the sdev device\n * @sdev: per device object\n * @sas_device_priv_data : per device driver private data\n *\n * make sure device is blocked without error, if not\n * print an error\n */\nstatic void\n_scsih_internal_device_block(struct scsi_device *sdev,\n\t\t\tstruct MPT3SAS_DEVICE *sas_device_priv_data)\n{\n\tint r = 0;\n\n\tsdev_printk(KERN_INFO, sdev, \"device_block, handle(0x%04x)\\n\",\n\t    sas_device_priv_data->sas_target->handle);\n\tsas_device_priv_data->block = 1;\n\n\tr = scsi_internal_device_block_nowait(sdev);\n\tif (r == -EINVAL)\n\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t    \"device_block failed with return(%d) for handle(0x%04x)\\n\",\n\t\t    r, sas_device_priv_data->sas_target->handle);\n}\n\n/**\n * _scsih_internal_device_unblock - unblock the sdev device\n * @sdev: per device object\n * @sas_device_priv_data : per device driver private data\n * make sure device is unblocked without error, if not retry\n * by blocking and then unblocking\n */\n\nstatic void\n_scsih_internal_device_unblock(struct scsi_device *sdev,\n\t\t\tstruct MPT3SAS_DEVICE *sas_device_priv_data)\n{\n\tint r = 0;\n\n\tsdev_printk(KERN_WARNING, sdev, \"device_unblock and setting to running, \"\n\t    \"handle(0x%04x)\\n\", sas_device_priv_data->sas_target->handle);\n\tsas_device_priv_data->block = 0;\n\tr = scsi_internal_device_unblock_nowait(sdev, SDEV_RUNNING);\n\tif (r == -EINVAL) {\n\t\t/* The device has been set to SDEV_RUNNING by SD layer during\n\t\t * device addition but the request queue is still stopped by\n\t\t * our earlier block call. We need to perform a block again\n\t\t * to get the device to SDEV_BLOCK and then to SDEV_RUNNING */\n\n\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t    \"device_unblock failed with return(%d) for handle(0x%04x) \"\n\t\t    \"performing a block followed by an unblock\\n\",\n\t\t    r, sas_device_priv_data->sas_target->handle);\n\t\tsas_device_priv_data->block = 1;\n\t\tr = scsi_internal_device_block_nowait(sdev);\n\t\tif (r)\n\t\t\tsdev_printk(KERN_WARNING, sdev, \"retried device_block \"\n\t\t\t    \"failed with return(%d) for handle(0x%04x)\\n\",\n\t\t\t    r, sas_device_priv_data->sas_target->handle);\n\n\t\tsas_device_priv_data->block = 0;\n\t\tr = scsi_internal_device_unblock_nowait(sdev, SDEV_RUNNING);\n\t\tif (r)\n\t\t\tsdev_printk(KERN_WARNING, sdev, \"retried device_unblock\"\n\t\t\t    \" failed with return(%d) for handle(0x%04x)\\n\",\n\t\t\t    r, sas_device_priv_data->sas_target->handle);\n\t}\n}\n\n/**\n * _scsih_ublock_io_all_device - unblock every device\n * @ioc: per adapter object\n *\n * change the device state from block to running\n */\nstatic void\n_scsih_ublock_io_all_device(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsi_device *sdev;\n\n\tshost_for_each_device(sdev, ioc->shost) {\n\t\tsas_device_priv_data = sdev->hostdata;\n\t\tif (!sas_device_priv_data)\n\t\t\tcontinue;\n\t\tif (!sas_device_priv_data->block)\n\t\t\tcontinue;\n\n\t\tdewtprintk(ioc, sdev_printk(KERN_INFO, sdev,\n\t\t\t\"device_running, handle(0x%04x)\\n\",\n\t\t    sas_device_priv_data->sas_target->handle));\n\t\t_scsih_internal_device_unblock(sdev, sas_device_priv_data);\n\t}\n}\n\n\n/**\n * _scsih_ublock_io_device - prepare device to be deleted\n * @ioc: per adapter object\n * @sas_address: sas address\n * @port: hba port entry\n *\n * unblock then put device in offline state\n */\nstatic void\n_scsih_ublock_io_device(struct MPT3SAS_ADAPTER *ioc,\n\tu64 sas_address, struct hba_port *port)\n{\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsi_device *sdev;\n\n\tshost_for_each_device(sdev, ioc->shost) {\n\t\tsas_device_priv_data = sdev->hostdata;\n\t\tif (!sas_device_priv_data)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->sas_target->sas_address\n\t\t    != sas_address)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->sas_target->port != port)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->block)\n\t\t\t_scsih_internal_device_unblock(sdev,\n\t\t\t\tsas_device_priv_data);\n\t}\n}\n\n/**\n * _scsih_block_io_all_device - set the device state to SDEV_BLOCK\n * @ioc: per adapter object\n *\n * During device pull we need to appropriately set the sdev state.\n */\nstatic void\n_scsih_block_io_all_device(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsi_device *sdev;\n\n\tshost_for_each_device(sdev, ioc->shost) {\n\t\tsas_device_priv_data = sdev->hostdata;\n\t\tif (!sas_device_priv_data)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->block)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->ignore_delay_remove) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\"%s skip device_block for SES handle(0x%04x)\\n\",\n\t\t\t__func__, sas_device_priv_data->sas_target->handle);\n\t\t\tcontinue;\n\t\t}\n\t\t_scsih_internal_device_block(sdev, sas_device_priv_data);\n\t}\n}\n\n/**\n * _scsih_block_io_device - set the device state to SDEV_BLOCK\n * @ioc: per adapter object\n * @handle: device handle\n *\n * During device pull we need to appropriately set the sdev state.\n */\nstatic void\n_scsih_block_io_device(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsi_device *sdev;\n\tstruct _sas_device *sas_device;\n\n\tsas_device = mpt3sas_get_sdev_by_handle(ioc, handle);\n\n\tshost_for_each_device(sdev, ioc->shost) {\n\t\tsas_device_priv_data = sdev->hostdata;\n\t\tif (!sas_device_priv_data)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->sas_target->handle != handle)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->block)\n\t\t\tcontinue;\n\t\tif (sas_device && sas_device->pend_sas_rphy_add)\n\t\t\tcontinue;\n\t\tif (sas_device_priv_data->ignore_delay_remove) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\"%s skip device_block for SES handle(0x%04x)\\n\",\n\t\t\t__func__, sas_device_priv_data->sas_target->handle);\n\t\t\tcontinue;\n\t\t}\n\t\t_scsih_internal_device_block(sdev, sas_device_priv_data);\n\t}\n\n\tif (sas_device)\n\t\tsas_device_put(sas_device);\n}\n\n/**\n * _scsih_block_io_to_children_attached_to_ex\n * @ioc: per adapter object\n * @sas_expander: the sas_device object\n *\n * This routine set sdev state to SDEV_BLOCK for all devices\n * attached to this expander. This function called when expander is\n * pulled.\n */\nstatic void\n_scsih_block_io_to_children_attached_to_ex(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_node *sas_expander)\n{\n\tstruct _sas_port *mpt3sas_port;\n\tstruct _sas_device *sas_device;\n\tstruct _sas_node *expander_sibling;\n\tunsigned long flags;\n\n\tif (!sas_expander)\n\t\treturn;\n\n\tlist_for_each_entry(mpt3sas_port,\n\t   &sas_expander->sas_port_list, port_list) {\n\t\tif (mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_END_DEVICE) {\n\t\t\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\t\t\tsas_device = __mpt3sas_get_sdev_by_addr(ioc,\n\t\t\t    mpt3sas_port->remote_identify.sas_address,\n\t\t\t    mpt3sas_port->hba_port);\n\t\t\tif (sas_device) {\n\t\t\t\tset_bit(sas_device->handle,\n\t\t\t\t\t\tioc->blocking_handles);\n\t\t\t\tsas_device_put(sas_device);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\t\t}\n\t}\n\n\tlist_for_each_entry(mpt3sas_port,\n\t   &sas_expander->sas_port_list, port_list) {\n\n\t\tif (mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\texpander_sibling =\n\t\t\t    mpt3sas_scsih_expander_find_by_sas_address(\n\t\t\t    ioc, mpt3sas_port->remote_identify.sas_address,\n\t\t\t    mpt3sas_port->hba_port);\n\t\t\t_scsih_block_io_to_children_attached_to_ex(ioc,\n\t\t\t    expander_sibling);\n\t\t}\n\t}\n}\n\n/**\n * _scsih_block_io_to_children_attached_directly\n * @ioc: per adapter object\n * @event_data: topology change event data\n *\n * This routine set sdev state to SDEV_BLOCK for all devices\n * direct attached during device pull.\n */\nstatic void\n_scsih_block_io_to_children_attached_directly(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataSasTopologyChangeList_t *event_data)\n{\n\tint i;\n\tu16 handle;\n\tu16 reason_code;\n\n\tfor (i = 0; i < event_data->NumEntries; i++) {\n\t\thandle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\treason_code = event_data->PHY[i].PhyStatus &\n\t\t    MPI2_EVENT_SAS_TOPO_RC_MASK;\n\t\tif (reason_code == MPI2_EVENT_SAS_TOPO_RC_DELAY_NOT_RESPONDING)\n\t\t\t_scsih_block_io_device(ioc, handle);\n\t}\n}\n\n/**\n * _scsih_block_io_to_pcie_children_attached_directly\n * @ioc: per adapter object\n * @event_data: topology change event data\n *\n * This routine set sdev state to SDEV_BLOCK for all devices\n * direct attached during device pull/reconnect.\n */\nstatic void\n_scsih_block_io_to_pcie_children_attached_directly(struct MPT3SAS_ADAPTER *ioc,\n\t\tMpi26EventDataPCIeTopologyChangeList_t *event_data)\n{\n\tint i;\n\tu16 handle;\n\tu16 reason_code;\n\n\tfor (i = 0; i < event_data->NumEntries; i++) {\n\t\thandle =\n\t\t\tle16_to_cpu(event_data->PortEntry[i].AttachedDevHandle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\treason_code = event_data->PortEntry[i].PortStatus;\n\t\tif (reason_code ==\n\t\t\t\tMPI26_EVENT_PCIE_TOPO_PS_DELAY_NOT_RESPONDING)\n\t\t\t_scsih_block_io_device(ioc, handle);\n\t}\n}\n/**\n * _scsih_tm_tr_send - send task management request\n * @ioc: per adapter object\n * @handle: device handle\n * Context: interrupt time.\n *\n * This code is to initiate the device removal handshake protocol\n * with controller firmware.  This function will issue target reset\n * using high priority request queue.  It will send a sas iounit\n * control request (MPI2_SAS_OP_REMOVE_DEVICE) from this completion.\n *\n * This is designed to send muliple task management request at the same\n * time to the fifo. If the fifo is full, we will append the request,\n * and process it in a future completion.\n */\nstatic void\n_scsih_tm_tr_send(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tMpi2SCSITaskManagementRequest_t *mpi_request;\n\tu16 smid;\n\tstruct _sas_device *sas_device = NULL;\n\tstruct _pcie_device *pcie_device = NULL;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data = NULL;\n\tu64 sas_address = 0;\n\tunsigned long flags;\n\tstruct _tr_list *delayed_tr;\n\tu32 ioc_state;\n\tu8 tr_method = 0;\n\tstruct hba_port *port = NULL;\n\n\tif (ioc->pci_error_recovery) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host in pci error recovery: handle(0x%04x)\\n\",\n\t\t\t\t    __func__, handle));\n\t\treturn;\n\t}\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 1);\n\tif (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host is not operational: handle(0x%04x)\\n\",\n\t\t\t\t    __func__, handle));\n\t\treturn;\n\t}\n\n\t/* if PD, then return */\n\tif (test_bit(handle, ioc->pd_handles))\n\t\treturn;\n\n\tclear_bit(handle, ioc->pend_os_device_add);\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_handle(ioc, handle);\n\tif (sas_device && sas_device->starget &&\n\t    sas_device->starget->hostdata) {\n\t\tsas_target_priv_data = sas_device->starget->hostdata;\n\t\tsas_target_priv_data->deleted = 1;\n\t\tsas_address = sas_device->sas_address;\n\t\tport = sas_device->port;\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\tif (!sas_device) {\n\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\tpcie_device = __mpt3sas_get_pdev_by_handle(ioc, handle);\n\t\tif (pcie_device && pcie_device->starget &&\n\t\t\tpcie_device->starget->hostdata) {\n\t\t\tsas_target_priv_data = pcie_device->starget->hostdata;\n\t\t\tsas_target_priv_data->deleted = 1;\n\t\t\tsas_address = pcie_device->wwid;\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\tif (pcie_device && (!ioc->tm_custom_handling) &&\n\t\t    (!(mpt3sas_scsih_is_pcie_scsi_device(\n\t\t    pcie_device->device_info))))\n\t\t\ttr_method =\n\t\t\t    MPI26_SCSITASKMGMT_MSGFLAGS_PROTOCOL_LVL_RST_PCIE;\n\t\telse\n\t\t\ttr_method = MPI2_SCSITASKMGMT_MSGFLAGS_LINK_RESET;\n\t}\n\tif (sas_target_priv_data) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"setting delete flag: handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t\t    handle, (u64)sas_address));\n\t\tif (sas_device) {\n\t\t\tif (sas_device->enclosure_handle != 0)\n\t\t\t\tdewtprintk(ioc,\n\t\t\t\t\t   ioc_info(ioc, \"setting delete flag:enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t\t\t    (u64)sas_device->enclosure_logical_id,\n\t\t\t\t\t\t    sas_device->slot));\n\t\t\tif (sas_device->connector_name[0] != '\\0')\n\t\t\t\tdewtprintk(ioc,\n\t\t\t\t\t   ioc_info(ioc, \"setting delete flag: enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t\t\t\t    sas_device->enclosure_level,\n\t\t\t\t\t\t    sas_device->connector_name));\n\t\t} else if (pcie_device) {\n\t\t\tif (pcie_device->enclosure_handle != 0)\n\t\t\t\tdewtprintk(ioc,\n\t\t\t\t\t   ioc_info(ioc, \"setting delete flag: logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t\t\t    (u64)pcie_device->enclosure_logical_id,\n\t\t\t\t\t\t    pcie_device->slot));\n\t\t\tif (pcie_device->connector_name[0] != '\\0')\n\t\t\t\tdewtprintk(ioc,\n\t\t\t\t\t   ioc_info(ioc, \"setting delete flag:, enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t\t\t\t    pcie_device->enclosure_level,\n\t\t\t\t\t\t    pcie_device->connector_name));\n\t\t}\n\t\t_scsih_ublock_io_device(ioc, sas_address, port);\n\t\tsas_target_priv_data->handle = MPT3SAS_INVALID_DEVICE_HANDLE;\n\t}\n\n\tsmid = mpt3sas_base_get_smid_hpr(ioc, ioc->tm_tr_cb_idx);\n\tif (!smid) {\n\t\tdelayed_tr = kzalloc(sizeof(*delayed_tr), GFP_ATOMIC);\n\t\tif (!delayed_tr)\n\t\t\tgoto out;\n\t\tINIT_LIST_HEAD(&delayed_tr->list);\n\t\tdelayed_tr->handle = handle;\n\t\tlist_add_tail(&delayed_tr->list, &ioc->delayed_tr_list);\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"DELAYED:tr:handle(0x%04x), (open)\\n\",\n\t\t\t\t    handle));\n\t\tgoto out;\n\t}\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"tr_send:handle(0x%04x), (open), smid(%d), cb(%d)\\n\",\n\t\t\t    handle, smid, ioc->tm_tr_cb_idx));\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tmemset(mpi_request, 0, sizeof(Mpi2SCSITaskManagementRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;\n\tmpi_request->DevHandle = cpu_to_le16(handle);\n\tmpi_request->TaskType = MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET;\n\tmpi_request->MsgFlags = tr_method;\n\tset_bit(handle, ioc->device_remove_in_progress);\n\tioc->put_smid_hi_priority(ioc, smid, 0);\n\tmpt3sas_trigger_master(ioc, MASTER_TRIGGER_DEVICE_REMOVAL);\n\nout:\n\tif (sas_device)\n\t\tsas_device_put(sas_device);\n\tif (pcie_device)\n\t\tpcie_device_put(pcie_device);\n}\n\n/**\n * _scsih_tm_tr_complete -\n * @ioc: per adapter object\n * @smid: system request message index\n * @msix_index: MSIX table index supplied by the OS\n * @reply: reply message frame(lower 32bit addr)\n * Context: interrupt time.\n *\n * This is the target reset completion routine.\n * This code is part of the code to initiate the device removal\n * handshake protocol with controller firmware.\n * It will send a sas iounit control request (MPI2_SAS_OP_REMOVE_DEVICE)\n *\n * Return: 1 meaning mf should be freed from _base_interrupt\n *         0 means the mf is freed from this function.\n */\nstatic u8\n_scsih_tm_tr_complete(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,\n\tu32 reply)\n{\n\tu16 handle;\n\tMpi2SCSITaskManagementRequest_t *mpi_request_tm;\n\tMpi2SCSITaskManagementReply_t *mpi_reply =\n\t    mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\tMpi2SasIoUnitControlRequest_t *mpi_request;\n\tu16 smid_sas_ctrl;\n\tu32 ioc_state;\n\tstruct _sc_list *delayed_sc;\n\n\tif (ioc->pci_error_recovery) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host in pci error recovery\\n\",\n\t\t\t\t    __func__));\n\t\treturn 1;\n\t}\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 1);\n\tif (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host is not operational\\n\",\n\t\t\t\t    __func__));\n\t\treturn 1;\n\t}\n\tif (unlikely(!mpi_reply)) {\n\t\tioc_err(ioc, \"mpi_reply not valid at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn 1;\n\t}\n\tmpi_request_tm = mpt3sas_base_get_msg_frame(ioc, smid);\n\thandle = le16_to_cpu(mpi_request_tm->DevHandle);\n\tif (handle != le16_to_cpu(mpi_reply->DevHandle)) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_err(ioc, \"spurious interrupt: handle(0x%04x:0x%04x), smid(%d)!!!\\n\",\n\t\t\t\t   handle,\n\t\t\t\t   le16_to_cpu(mpi_reply->DevHandle), smid));\n\t\treturn 0;\n\t}\n\n\tmpt3sas_trigger_master(ioc, MASTER_TRIGGER_TASK_MANAGMENT);\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"tr_complete:handle(0x%04x), (open) smid(%d), ioc_status(0x%04x), loginfo(0x%08x), completed(%d)\\n\",\n\t\t\t    handle, smid, le16_to_cpu(mpi_reply->IOCStatus),\n\t\t\t    le32_to_cpu(mpi_reply->IOCLogInfo),\n\t\t\t    le32_to_cpu(mpi_reply->TerminationCount)));\n\n\tsmid_sas_ctrl = mpt3sas_base_get_smid(ioc, ioc->tm_sas_control_cb_idx);\n\tif (!smid_sas_ctrl) {\n\t\tdelayed_sc = kzalloc(sizeof(*delayed_sc), GFP_ATOMIC);\n\t\tif (!delayed_sc)\n\t\t\treturn _scsih_check_for_pending_tm(ioc, smid);\n\t\tINIT_LIST_HEAD(&delayed_sc->list);\n\t\tdelayed_sc->handle = le16_to_cpu(mpi_request_tm->DevHandle);\n\t\tlist_add_tail(&delayed_sc->list, &ioc->delayed_sc_list);\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"DELAYED:sc:handle(0x%04x), (open)\\n\",\n\t\t\t\t    handle));\n\t\treturn _scsih_check_for_pending_tm(ioc, smid);\n\t}\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"sc_send:handle(0x%04x), (open), smid(%d), cb(%d)\\n\",\n\t\t\t    handle, smid_sas_ctrl, ioc->tm_sas_control_cb_idx));\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid_sas_ctrl);\n\tmemset(mpi_request, 0, sizeof(Mpi2SasIoUnitControlRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_SAS_IO_UNIT_CONTROL;\n\tmpi_request->Operation = MPI2_SAS_OP_REMOVE_DEVICE;\n\tmpi_request->DevHandle = mpi_request_tm->DevHandle;\n\tioc->put_smid_default(ioc, smid_sas_ctrl);\n\n\treturn _scsih_check_for_pending_tm(ioc, smid);\n}\n\n/** _scsih_allow_scmd_to_device - check whether scmd needs to\n *\t\t\t\t issue to IOC or not.\n * @ioc: per adapter object\n * @scmd: pointer to scsi command object\n *\n * Returns true if scmd can be issued to IOC otherwise returns false.\n */\ninline bool _scsih_allow_scmd_to_device(struct MPT3SAS_ADAPTER *ioc,\n\tstruct scsi_cmnd *scmd)\n{\n\n\tif (ioc->pci_error_recovery)\n\t\treturn false;\n\n\tif (ioc->hba_mpi_version_belonged == MPI2_VERSION) {\n\t\tif (ioc->remove_host)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\tif (ioc->remove_host) {\n\n\t\tswitch (scmd->cmnd[0]) {\n\t\tcase SYNCHRONIZE_CACHE:\n\t\tcase START_STOP:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * _scsih_sas_control_complete - completion routine\n * @ioc: per adapter object\n * @smid: system request message index\n * @msix_index: MSIX table index supplied by the OS\n * @reply: reply message frame(lower 32bit addr)\n * Context: interrupt time.\n *\n * This is the sas iounit control completion routine.\n * This code is part of the code to initiate the device removal\n * handshake protocol with controller firmware.\n *\n * Return: 1 meaning mf should be freed from _base_interrupt\n *         0 means the mf is freed from this function.\n */\nstatic u8\n_scsih_sas_control_complete(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\tu8 msix_index, u32 reply)\n{\n\tMpi2SasIoUnitControlReply_t *mpi_reply =\n\t    mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\n\tif (likely(mpi_reply)) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"sc_complete:handle(0x%04x), (open) smid(%d), ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t    le16_to_cpu(mpi_reply->DevHandle), smid,\n\t\t\t\t    le16_to_cpu(mpi_reply->IOCStatus),\n\t\t\t\t    le32_to_cpu(mpi_reply->IOCLogInfo)));\n\t\tif (le16_to_cpu(mpi_reply->IOCStatus) ==\n\t\t     MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tclear_bit(le16_to_cpu(mpi_reply->DevHandle),\n\t\t\t    ioc->device_remove_in_progress);\n\t\t}\n\t} else {\n\t\tioc_err(ioc, \"mpi_reply not valid at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t}\n\treturn mpt3sas_check_for_pending_internal_cmds(ioc, smid);\n}\n\n/**\n * _scsih_tm_tr_volume_send - send target reset request for volumes\n * @ioc: per adapter object\n * @handle: device handle\n * Context: interrupt time.\n *\n * This is designed to send muliple task management request at the same\n * time to the fifo. If the fifo is full, we will append the request,\n * and process it in a future completion.\n */\nstatic void\n_scsih_tm_tr_volume_send(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tMpi2SCSITaskManagementRequest_t *mpi_request;\n\tu16 smid;\n\tstruct _tr_list *delayed_tr;\n\n\tif (ioc->pci_error_recovery) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host reset in progress!\\n\",\n\t\t\t\t    __func__));\n\t\treturn;\n\t}\n\n\tsmid = mpt3sas_base_get_smid_hpr(ioc, ioc->tm_tr_volume_cb_idx);\n\tif (!smid) {\n\t\tdelayed_tr = kzalloc(sizeof(*delayed_tr), GFP_ATOMIC);\n\t\tif (!delayed_tr)\n\t\t\treturn;\n\t\tINIT_LIST_HEAD(&delayed_tr->list);\n\t\tdelayed_tr->handle = handle;\n\t\tlist_add_tail(&delayed_tr->list, &ioc->delayed_tr_volume_list);\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"DELAYED:tr:handle(0x%04x), (open)\\n\",\n\t\t\t\t    handle));\n\t\treturn;\n\t}\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"tr_send:handle(0x%04x), (open), smid(%d), cb(%d)\\n\",\n\t\t\t    handle, smid, ioc->tm_tr_volume_cb_idx));\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tmemset(mpi_request, 0, sizeof(Mpi2SCSITaskManagementRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;\n\tmpi_request->DevHandle = cpu_to_le16(handle);\n\tmpi_request->TaskType = MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET;\n\tioc->put_smid_hi_priority(ioc, smid, 0);\n}\n\n/**\n * _scsih_tm_volume_tr_complete - target reset completion\n * @ioc: per adapter object\n * @smid: system request message index\n * @msix_index: MSIX table index supplied by the OS\n * @reply: reply message frame(lower 32bit addr)\n * Context: interrupt time.\n *\n * Return: 1 meaning mf should be freed from _base_interrupt\n *         0 means the mf is freed from this function.\n */\nstatic u8\n_scsih_tm_volume_tr_complete(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\tu8 msix_index, u32 reply)\n{\n\tu16 handle;\n\tMpi2SCSITaskManagementRequest_t *mpi_request_tm;\n\tMpi2SCSITaskManagementReply_t *mpi_reply =\n\t    mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\n\tif (ioc->shost_recovery || ioc->pci_error_recovery) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host reset in progress!\\n\",\n\t\t\t\t    __func__));\n\t\treturn 1;\n\t}\n\tif (unlikely(!mpi_reply)) {\n\t\tioc_err(ioc, \"mpi_reply not valid at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn 1;\n\t}\n\n\tmpi_request_tm = mpt3sas_base_get_msg_frame(ioc, smid);\n\thandle = le16_to_cpu(mpi_request_tm->DevHandle);\n\tif (handle != le16_to_cpu(mpi_reply->DevHandle)) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_err(ioc, \"spurious interrupt: handle(0x%04x:0x%04x), smid(%d)!!!\\n\",\n\t\t\t\t   handle, le16_to_cpu(mpi_reply->DevHandle),\n\t\t\t\t   smid));\n\t\treturn 0;\n\t}\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"tr_complete:handle(0x%04x), (open) smid(%d), ioc_status(0x%04x), loginfo(0x%08x), completed(%d)\\n\",\n\t\t\t    handle, smid, le16_to_cpu(mpi_reply->IOCStatus),\n\t\t\t    le32_to_cpu(mpi_reply->IOCLogInfo),\n\t\t\t    le32_to_cpu(mpi_reply->TerminationCount)));\n\n\treturn _scsih_check_for_pending_tm(ioc, smid);\n}\n\n/**\n * _scsih_issue_delayed_event_ack - issue delayed Event ACK messages\n * @ioc: per adapter object\n * @smid: system request message index\n * @event: Event ID\n * @event_context: used to track events uniquely\n *\n * Context - processed in interrupt context.\n */\nstatic void\n_scsih_issue_delayed_event_ack(struct MPT3SAS_ADAPTER *ioc, u16 smid, U16 event,\n\t\t\t\tU32 event_context)\n{\n\tMpi2EventAckRequest_t *ack_request;\n\tint i = smid - ioc->internal_smid;\n\tunsigned long flags;\n\n\t/* Without releasing the smid just update the\n\t * call back index and reuse the same smid for\n\t * processing this delayed request\n\t */\n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\tioc->internal_lookup[i].cb_idx = ioc->base_cb_idx;\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"EVENT ACK: event(0x%04x), smid(%d), cb(%d)\\n\",\n\t\t\t    le16_to_cpu(event), smid, ioc->base_cb_idx));\n\tack_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tmemset(ack_request, 0, sizeof(Mpi2EventAckRequest_t));\n\tack_request->Function = MPI2_FUNCTION_EVENT_ACK;\n\tack_request->Event = event;\n\tack_request->EventContext = event_context;\n\tack_request->VF_ID = 0;  /* TODO */\n\tack_request->VP_ID = 0;\n\tioc->put_smid_default(ioc, smid);\n}\n\n/**\n * _scsih_issue_delayed_sas_io_unit_ctrl - issue delayed\n *\t\t\t\tsas_io_unit_ctrl messages\n * @ioc: per adapter object\n * @smid: system request message index\n * @handle: device handle\n *\n * Context - processed in interrupt context.\n */\nstatic void\n_scsih_issue_delayed_sas_io_unit_ctrl(struct MPT3SAS_ADAPTER *ioc,\n\t\t\t\t\tu16 smid, u16 handle)\n{\n\tMpi2SasIoUnitControlRequest_t *mpi_request;\n\tu32 ioc_state;\n\tint i = smid - ioc->internal_smid;\n\tunsigned long flags;\n\n\tif (ioc->remove_host) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host has been removed\\n\",\n\t\t\t\t    __func__));\n\t\treturn;\n\t} else if (ioc->pci_error_recovery) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host in pci error recovery\\n\",\n\t\t\t\t    __func__));\n\t\treturn;\n\t}\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 1);\n\tif (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: host is not operational\\n\",\n\t\t\t\t    __func__));\n\t\treturn;\n\t}\n\n\t/* Without releasing the smid just update the\n\t * call back index and reuse the same smid for\n\t * processing this delayed request\n\t */\n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\tioc->internal_lookup[i].cb_idx = ioc->tm_sas_control_cb_idx;\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"sc_send:handle(0x%04x), (open), smid(%d), cb(%d)\\n\",\n\t\t\t    handle, smid, ioc->tm_sas_control_cb_idx));\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tmemset(mpi_request, 0, sizeof(Mpi2SasIoUnitControlRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_SAS_IO_UNIT_CONTROL;\n\tmpi_request->Operation = MPI2_SAS_OP_REMOVE_DEVICE;\n\tmpi_request->DevHandle = cpu_to_le16(handle);\n\tioc->put_smid_default(ioc, smid);\n}\n\n/**\n * _scsih_check_for_pending_internal_cmds - check for pending internal messages\n * @ioc: per adapter object\n * @smid: system request message index\n *\n * Context: Executed in interrupt context\n *\n * This will check delayed internal messages list, and process the\n * next request.\n *\n * Return: 1 meaning mf should be freed from _base_interrupt\n *         0 means the mf is freed from this function.\n */\nu8\nmpt3sas_check_for_pending_internal_cmds(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tstruct _sc_list *delayed_sc;\n\tstruct _event_ack_list *delayed_event_ack;\n\n\tif (!list_empty(&ioc->delayed_event_ack_list)) {\n\t\tdelayed_event_ack = list_entry(ioc->delayed_event_ack_list.next,\n\t\t\t\t\t\tstruct _event_ack_list, list);\n\t\t_scsih_issue_delayed_event_ack(ioc, smid,\n\t\t  delayed_event_ack->Event, delayed_event_ack->EventContext);\n\t\tlist_del(&delayed_event_ack->list);\n\t\tkfree(delayed_event_ack);\n\t\treturn 0;\n\t}\n\n\tif (!list_empty(&ioc->delayed_sc_list)) {\n\t\tdelayed_sc = list_entry(ioc->delayed_sc_list.next,\n\t\t\t\t\t\tstruct _sc_list, list);\n\t\t_scsih_issue_delayed_sas_io_unit_ctrl(ioc, smid,\n\t\t\t\t\t\t delayed_sc->handle);\n\t\tlist_del(&delayed_sc->list);\n\t\tkfree(delayed_sc);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/**\n * _scsih_check_for_pending_tm - check for pending task management\n * @ioc: per adapter object\n * @smid: system request message index\n *\n * This will check delayed target reset list, and feed the\n * next reqeust.\n *\n * Return: 1 meaning mf should be freed from _base_interrupt\n *         0 means the mf is freed from this function.\n */\nstatic u8\n_scsih_check_for_pending_tm(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tstruct _tr_list *delayed_tr;\n\n\tif (!list_empty(&ioc->delayed_tr_volume_list)) {\n\t\tdelayed_tr = list_entry(ioc->delayed_tr_volume_list.next,\n\t\t    struct _tr_list, list);\n\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t_scsih_tm_tr_volume_send(ioc, delayed_tr->handle);\n\t\tlist_del(&delayed_tr->list);\n\t\tkfree(delayed_tr);\n\t\treturn 0;\n\t}\n\n\tif (!list_empty(&ioc->delayed_tr_list)) {\n\t\tdelayed_tr = list_entry(ioc->delayed_tr_list.next,\n\t\t    struct _tr_list, list);\n\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t_scsih_tm_tr_send(ioc, delayed_tr->handle);\n\t\tlist_del(&delayed_tr->list);\n\t\tkfree(delayed_tr);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/**\n * _scsih_check_topo_delete_events - sanity check on topo events\n * @ioc: per adapter object\n * @event_data: the event data payload\n *\n * This routine added to better handle cable breaker.\n *\n * This handles the case where driver receives multiple expander\n * add and delete events in a single shot.  When there is a delete event\n * the routine will void any pending add events waiting in the event queue.\n */\nstatic void\n_scsih_check_topo_delete_events(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataSasTopologyChangeList_t *event_data)\n{\n\tstruct fw_event_work *fw_event;\n\tMpi2EventDataSasTopologyChangeList_t *local_event_data;\n\tu16 expander_handle;\n\tstruct _sas_node *sas_expander;\n\tunsigned long flags;\n\tint i, reason_code;\n\tu16 handle;\n\n\tfor (i = 0 ; i < event_data->NumEntries; i++) {\n\t\thandle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\treason_code = event_data->PHY[i].PhyStatus &\n\t\t    MPI2_EVENT_SAS_TOPO_RC_MASK;\n\t\tif (reason_code == MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING)\n\t\t\t_scsih_tm_tr_send(ioc, handle);\n\t}\n\n\texpander_handle = le16_to_cpu(event_data->ExpanderDevHandle);\n\tif (expander_handle < ioc->sas_hba.num_phys) {\n\t\t_scsih_block_io_to_children_attached_directly(ioc, event_data);\n\t\treturn;\n\t}\n\tif (event_data->ExpStatus ==\n\t    MPI2_EVENT_SAS_TOPO_ES_DELAY_NOT_RESPONDING) {\n\t\t/* put expander attached devices into blocking state */\n\t\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\t\tsas_expander = mpt3sas_scsih_expander_find_by_handle(ioc,\n\t\t    expander_handle);\n\t\t_scsih_block_io_to_children_attached_to_ex(ioc, sas_expander);\n\t\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\t\tdo {\n\t\t\thandle = find_first_bit(ioc->blocking_handles,\n\t\t\t    ioc->facts.MaxDevHandle);\n\t\t\tif (handle < ioc->facts.MaxDevHandle)\n\t\t\t\t_scsih_block_io_device(ioc, handle);\n\t\t} while (test_and_clear_bit(handle, ioc->blocking_handles));\n\t} else if (event_data->ExpStatus == MPI2_EVENT_SAS_TOPO_ES_RESPONDING)\n\t\t_scsih_block_io_to_children_attached_directly(ioc, event_data);\n\n\tif (event_data->ExpStatus != MPI2_EVENT_SAS_TOPO_ES_NOT_RESPONDING)\n\t\treturn;\n\n\t/* mark ignore flag for pending events */\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\tlist_for_each_entry(fw_event, &ioc->fw_event_list, list) {\n\t\tif (fw_event->event != MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST ||\n\t\t    fw_event->ignore)\n\t\t\tcontinue;\n\t\tlocal_event_data = (Mpi2EventDataSasTopologyChangeList_t *)\n\t\t\t\t   fw_event->event_data;\n\t\tif (local_event_data->ExpStatus ==\n\t\t    MPI2_EVENT_SAS_TOPO_ES_ADDED ||\n\t\t    local_event_data->ExpStatus ==\n\t\t    MPI2_EVENT_SAS_TOPO_ES_RESPONDING) {\n\t\t\tif (le16_to_cpu(local_event_data->ExpanderDevHandle) ==\n\t\t\t    expander_handle) {\n\t\t\t\tdewtprintk(ioc,\n\t\t\t\t\t   ioc_info(ioc, \"setting ignoring flag\\n\"));\n\t\t\t\tfw_event->ignore = 1;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n}\n\n/**\n * _scsih_check_pcie_topo_remove_events - sanity check on topo\n * events\n * @ioc: per adapter object\n * @event_data: the event data payload\n *\n * This handles the case where driver receives multiple switch\n * or device add and delete events in a single shot.  When there\n * is a delete event the routine will void any pending add\n * events waiting in the event queue.\n */\nstatic void\n_scsih_check_pcie_topo_remove_events(struct MPT3SAS_ADAPTER *ioc,\n\tMpi26EventDataPCIeTopologyChangeList_t *event_data)\n{\n\tstruct fw_event_work *fw_event;\n\tMpi26EventDataPCIeTopologyChangeList_t *local_event_data;\n\tunsigned long flags;\n\tint i, reason_code;\n\tu16 handle, switch_handle;\n\n\tfor (i = 0; i < event_data->NumEntries; i++) {\n\t\thandle =\n\t\t\tle16_to_cpu(event_data->PortEntry[i].AttachedDevHandle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\treason_code = event_data->PortEntry[i].PortStatus;\n\t\tif (reason_code == MPI26_EVENT_PCIE_TOPO_PS_NOT_RESPONDING)\n\t\t\t_scsih_tm_tr_send(ioc, handle);\n\t}\n\n\tswitch_handle = le16_to_cpu(event_data->SwitchDevHandle);\n\tif (!switch_handle) {\n\t\t_scsih_block_io_to_pcie_children_attached_directly(\n\t\t\t\t\t\t\tioc, event_data);\n\t\treturn;\n\t}\n    /* TODO We are not supporting cascaded PCIe Switch removal yet*/\n\tif ((event_data->SwitchStatus\n\t\t== MPI26_EVENT_PCIE_TOPO_SS_DELAY_NOT_RESPONDING) ||\n\t\t(event_data->SwitchStatus ==\n\t\t\t\t\tMPI26_EVENT_PCIE_TOPO_SS_RESPONDING))\n\t\t_scsih_block_io_to_pcie_children_attached_directly(\n\t\t\t\t\t\t\tioc, event_data);\n\n\tif (event_data->SwitchStatus != MPI2_EVENT_SAS_TOPO_ES_NOT_RESPONDING)\n\t\treturn;\n\n\t/* mark ignore flag for pending events */\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\tlist_for_each_entry(fw_event, &ioc->fw_event_list, list) {\n\t\tif (fw_event->event != MPI2_EVENT_PCIE_TOPOLOGY_CHANGE_LIST ||\n\t\t\tfw_event->ignore)\n\t\t\tcontinue;\n\t\tlocal_event_data =\n\t\t\t(Mpi26EventDataPCIeTopologyChangeList_t *)\n\t\t\tfw_event->event_data;\n\t\tif (local_event_data->SwitchStatus ==\n\t\t    MPI2_EVENT_SAS_TOPO_ES_ADDED ||\n\t\t    local_event_data->SwitchStatus ==\n\t\t    MPI2_EVENT_SAS_TOPO_ES_RESPONDING) {\n\t\t\tif (le16_to_cpu(local_event_data->SwitchDevHandle) ==\n\t\t\t\tswitch_handle) {\n\t\t\t\tdewtprintk(ioc,\n\t\t\t\t\t   ioc_info(ioc, \"setting ignoring flag for switch event\\n\"));\n\t\t\t\tfw_event->ignore = 1;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n}\n\n/**\n * _scsih_set_volume_delete_flag - setting volume delete flag\n * @ioc: per adapter object\n * @handle: device handle\n *\n * This returns nothing.\n */\nstatic void\n_scsih_set_volume_delete_flag(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _raid_device *raid_device;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\traid_device = mpt3sas_raid_device_find_by_handle(ioc, handle);\n\tif (raid_device && raid_device->starget &&\n\t    raid_device->starget->hostdata) {\n\t\tsas_target_priv_data =\n\t\t    raid_device->starget->hostdata;\n\t\tsas_target_priv_data->deleted = 1;\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"setting delete flag: handle(0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t\t    handle, (u64)raid_device->wwid));\n\t}\n\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n}\n\n/**\n * _scsih_set_volume_handle_for_tr - set handle for target reset to volume\n * @handle: input handle\n * @a: handle for volume a\n * @b: handle for volume b\n *\n * IR firmware only supports two raid volumes.  The purpose of this\n * routine is to set the volume handle in either a or b. When the given\n * input handle is non-zero, or when a and b have not been set before.\n */\nstatic void\n_scsih_set_volume_handle_for_tr(u16 handle, u16 *a, u16 *b)\n{\n\tif (!handle || handle == *a || handle == *b)\n\t\treturn;\n\tif (!*a)\n\t\t*a = handle;\n\telse if (!*b)\n\t\t*b = handle;\n}\n\n/**\n * _scsih_check_ir_config_unhide_events - check for UNHIDE events\n * @ioc: per adapter object\n * @event_data: the event data payload\n * Context: interrupt time.\n *\n * This routine will send target reset to volume, followed by target\n * resets to the PDs. This is called when a PD has been removed, or\n * volume has been deleted or removed. When the target reset is sent\n * to volume, the PD target resets need to be queued to start upon\n * completion of the volume target reset.\n */\nstatic void\n_scsih_check_ir_config_unhide_events(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataIrConfigChangeList_t *event_data)\n{\n\tMpi2EventIrConfigElement_t *element;\n\tint i;\n\tu16 handle, volume_handle, a, b;\n\tstruct _tr_list *delayed_tr;\n\n\ta = 0;\n\tb = 0;\n\n\tif (ioc->is_warpdrive)\n\t\treturn;\n\n\t/* Volume Resets for Deleted or Removed */\n\telement = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];\n\tfor (i = 0; i < event_data->NumElements; i++, element++) {\n\t\tif (le32_to_cpu(event_data->Flags) &\n\t\t    MPI2_EVENT_IR_CHANGE_FLAGS_FOREIGN_CONFIG)\n\t\t\tcontinue;\n\t\tif (element->ReasonCode ==\n\t\t    MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED ||\n\t\t    element->ReasonCode ==\n\t\t    MPI2_EVENT_IR_CHANGE_RC_REMOVED) {\n\t\t\tvolume_handle = le16_to_cpu(element->VolDevHandle);\n\t\t\t_scsih_set_volume_delete_flag(ioc, volume_handle);\n\t\t\t_scsih_set_volume_handle_for_tr(volume_handle, &a, &b);\n\t\t}\n\t}\n\n\t/* Volume Resets for UNHIDE events */\n\telement = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];\n\tfor (i = 0; i < event_data->NumElements; i++, element++) {\n\t\tif (le32_to_cpu(event_data->Flags) &\n\t\t    MPI2_EVENT_IR_CHANGE_FLAGS_FOREIGN_CONFIG)\n\t\t\tcontinue;\n\t\tif (element->ReasonCode == MPI2_EVENT_IR_CHANGE_RC_UNHIDE) {\n\t\t\tvolume_handle = le16_to_cpu(element->VolDevHandle);\n\t\t\t_scsih_set_volume_handle_for_tr(volume_handle, &a, &b);\n\t\t}\n\t}\n\n\tif (a)\n\t\t_scsih_tm_tr_volume_send(ioc, a);\n\tif (b)\n\t\t_scsih_tm_tr_volume_send(ioc, b);\n\n\t/* PD target resets */\n\telement = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];\n\tfor (i = 0; i < event_data->NumElements; i++, element++) {\n\t\tif (element->ReasonCode != MPI2_EVENT_IR_CHANGE_RC_UNHIDE)\n\t\t\tcontinue;\n\t\thandle = le16_to_cpu(element->PhysDiskDevHandle);\n\t\tvolume_handle = le16_to_cpu(element->VolDevHandle);\n\t\tclear_bit(handle, ioc->pd_handles);\n\t\tif (!volume_handle)\n\t\t\t_scsih_tm_tr_send(ioc, handle);\n\t\telse if (volume_handle == a || volume_handle == b) {\n\t\t\tdelayed_tr = kzalloc(sizeof(*delayed_tr), GFP_ATOMIC);\n\t\t\tBUG_ON(!delayed_tr);\n\t\t\tINIT_LIST_HEAD(&delayed_tr->list);\n\t\t\tdelayed_tr->handle = handle;\n\t\t\tlist_add_tail(&delayed_tr->list, &ioc->delayed_tr_list);\n\t\t\tdewtprintk(ioc,\n\t\t\t\t   ioc_info(ioc, \"DELAYED:tr:handle(0x%04x), (open)\\n\",\n\t\t\t\t\t    handle));\n\t\t} else\n\t\t\t_scsih_tm_tr_send(ioc, handle);\n\t}\n}\n\n\n/**\n * _scsih_check_volume_delete_events - set delete flag for volumes\n * @ioc: per adapter object\n * @event_data: the event data payload\n * Context: interrupt time.\n *\n * This will handle the case when the cable connected to entire volume is\n * pulled. We will take care of setting the deleted flag so normal IO will\n * not be sent.\n */\nstatic void\n_scsih_check_volume_delete_events(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataIrVolume_t *event_data)\n{\n\tu32 state;\n\n\tif (event_data->ReasonCode != MPI2_EVENT_IR_VOLUME_RC_STATE_CHANGED)\n\t\treturn;\n\tstate = le32_to_cpu(event_data->NewValue);\n\tif (state == MPI2_RAID_VOL_STATE_MISSING || state ==\n\t    MPI2_RAID_VOL_STATE_FAILED)\n\t\t_scsih_set_volume_delete_flag(ioc,\n\t\t    le16_to_cpu(event_data->VolDevHandle));\n}\n\n/**\n * _scsih_temp_threshold_events - display temperature threshold exceeded events\n * @ioc: per adapter object\n * @event_data: the temp threshold event data\n * Context: interrupt time.\n */\nstatic void\n_scsih_temp_threshold_events(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataTemperature_t *event_data)\n{\n\tu32 doorbell;\n\tif (ioc->temp_sensors_count >= event_data->SensorNum) {\n\t\tioc_err(ioc, \"Temperature Threshold flags %s%s%s%s exceeded for Sensor: %d !!!\\n\",\n\t\t\tle16_to_cpu(event_data->Status) & 0x1 ? \"0 \" : \" \",\n\t\t\tle16_to_cpu(event_data->Status) & 0x2 ? \"1 \" : \" \",\n\t\t\tle16_to_cpu(event_data->Status) & 0x4 ? \"2 \" : \" \",\n\t\t\tle16_to_cpu(event_data->Status) & 0x8 ? \"3 \" : \" \",\n\t\t\tevent_data->SensorNum);\n\t\tioc_err(ioc, \"Current Temp In Celsius: %d\\n\",\n\t\t\tevent_data->CurrentTemperature);\n\t\tif (ioc->hba_mpi_version_belonged != MPI2_VERSION) {\n\t\t\tdoorbell = mpt3sas_base_get_iocstate(ioc, 0);\n\t\t\tif ((doorbell & MPI2_IOC_STATE_MASK) ==\n\t\t\t    MPI2_IOC_STATE_FAULT) {\n\t\t\t\tmpt3sas_print_fault_code(ioc,\n\t\t\t\t    doorbell & MPI2_DOORBELL_DATA_MASK);\n\t\t\t} else if ((doorbell & MPI2_IOC_STATE_MASK) ==\n\t\t\t    MPI2_IOC_STATE_COREDUMP) {\n\t\t\t\tmpt3sas_print_coredump_info(ioc,\n\t\t\t\t    doorbell & MPI2_DOORBELL_DATA_MASK);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int _scsih_set_satl_pending(struct scsi_cmnd *scmd, bool pending)\n{\n\tstruct MPT3SAS_DEVICE *priv = scmd->device->hostdata;\n\n\tif (scmd->cmnd[0] != ATA_12 && scmd->cmnd[0] != ATA_16)\n\t\treturn 0;\n\n\tif (pending)\n\t\treturn test_and_set_bit(0, &priv->ata_command_pending);\n\n\tclear_bit(0, &priv->ata_command_pending);\n\treturn 0;\n}\n\n/**\n * _scsih_flush_running_cmds - completing outstanding commands.\n * @ioc: per adapter object\n *\n * The flushing out of all pending scmd commands following host reset,\n * where all IO is dropped to the floor.\n */\nstatic void\n_scsih_flush_running_cmds(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct scsi_cmnd *scmd;\n\tstruct scsiio_tracker *st;\n\tu16 smid;\n\tint count = 0;\n\n\tfor (smid = 1; smid <= ioc->scsiio_depth; smid++) {\n\t\tscmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);\n\t\tif (!scmd)\n\t\t\tcontinue;\n\t\tcount++;\n\t\t_scsih_set_satl_pending(scmd, false);\n\t\tst = scsi_cmd_priv(scmd);\n\t\tmpt3sas_base_clear_st(ioc, st);\n\t\tscsi_dma_unmap(scmd);\n\t\tif (ioc->pci_error_recovery || ioc->remove_host)\n\t\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\telse\n\t\t\tscmd->result = DID_RESET << 16;\n\t\tscmd->scsi_done(scmd);\n\t}\n\tdtmprintk(ioc, ioc_info(ioc, \"completing %d cmds\\n\", count));\n}\n\n/**\n * _scsih_setup_eedp - setup MPI request for EEDP transfer\n * @ioc: per adapter object\n * @scmd: pointer to scsi command object\n * @mpi_request: pointer to the SCSI_IO request message frame\n *\n * Supporting protection 1 and 3.\n */\nstatic void\n_scsih_setup_eedp(struct MPT3SAS_ADAPTER *ioc, struct scsi_cmnd *scmd,\n\tMpi25SCSIIORequest_t *mpi_request)\n{\n\tu16 eedp_flags;\n\tunsigned char prot_op = scsi_get_prot_op(scmd);\n\tunsigned char prot_type = scsi_get_prot_type(scmd);\n\tMpi25SCSIIORequest_t *mpi_request_3v =\n\t   (Mpi25SCSIIORequest_t *)mpi_request;\n\n\tif (prot_type == SCSI_PROT_DIF_TYPE0 || prot_op == SCSI_PROT_NORMAL)\n\t\treturn;\n\n\tif (prot_op ==  SCSI_PROT_READ_STRIP)\n\t\teedp_flags = MPI2_SCSIIO_EEDPFLAGS_CHECK_REMOVE_OP;\n\telse if (prot_op ==  SCSI_PROT_WRITE_INSERT)\n\t\teedp_flags = MPI2_SCSIIO_EEDPFLAGS_INSERT_OP;\n\telse\n\t\treturn;\n\n\tswitch (prot_type) {\n\tcase SCSI_PROT_DIF_TYPE1:\n\tcase SCSI_PROT_DIF_TYPE2:\n\n\t\t/*\n\t\t* enable ref/guard checking\n\t\t* auto increment ref tag\n\t\t*/\n\t\teedp_flags |= MPI2_SCSIIO_EEDPFLAGS_INC_PRI_REFTAG |\n\t\t    MPI2_SCSIIO_EEDPFLAGS_CHECK_REFTAG |\n\t\t    MPI2_SCSIIO_EEDPFLAGS_CHECK_GUARD;\n\t\tmpi_request->CDB.EEDP32.PrimaryReferenceTag =\n\t\t    cpu_to_be32(t10_pi_ref_tag(scmd->request));\n\t\tbreak;\n\n\tcase SCSI_PROT_DIF_TYPE3:\n\n\t\t/*\n\t\t* enable guard checking\n\t\t*/\n\t\teedp_flags |= MPI2_SCSIIO_EEDPFLAGS_CHECK_GUARD;\n\n\t\tbreak;\n\t}\n\n\tmpi_request_3v->EEDPBlockSize =\n\t    cpu_to_le16(scmd->device->sector_size);\n\n\tif (ioc->is_gen35_ioc)\n\t\teedp_flags |= MPI25_SCSIIO_EEDPFLAGS_APPTAG_DISABLE_MODE;\n\tmpi_request->EEDPFlags = cpu_to_le16(eedp_flags);\n}\n\n/**\n * _scsih_eedp_error_handling - return sense code for EEDP errors\n * @scmd: pointer to scsi command object\n * @ioc_status: ioc status\n */\nstatic void\n_scsih_eedp_error_handling(struct scsi_cmnd *scmd, u16 ioc_status)\n{\n\tu8 ascq;\n\n\tswitch (ioc_status) {\n\tcase MPI2_IOCSTATUS_EEDP_GUARD_ERROR:\n\t\tascq = 0x01;\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_EEDP_APP_TAG_ERROR:\n\t\tascq = 0x02;\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_EEDP_REF_TAG_ERROR:\n\t\tascq = 0x03;\n\t\tbreak;\n\tdefault:\n\t\tascq = 0x00;\n\t\tbreak;\n\t}\n\tscsi_build_sense_buffer(0, scmd->sense_buffer, ILLEGAL_REQUEST, 0x10,\n\t    ascq);\n\tscmd->result = DRIVER_SENSE << 24 | (DID_ABORT << 16) |\n\t    SAM_STAT_CHECK_CONDITION;\n}\n\n/**\n * scsih_qcmd - main scsi request entry point\n * @shost: SCSI host pointer\n * @scmd: pointer to scsi command object\n *\n * The callback index is set inside `ioc->scsi_io_cb_idx`.\n *\n * Return: 0 on success.  If there's a failure, return either:\n * SCSI_MLQUEUE_DEVICE_BUSY if the device queue is full, or\n * SCSI_MLQUEUE_HOST_BUSY if the entire host queue is full\n */\nstatic int\nscsih_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *scmd)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct _raid_device *raid_device;\n\tstruct request *rq = scmd->request;\n\tint class;\n\tMpi25SCSIIORequest_t *mpi_request;\n\tstruct _pcie_device *pcie_device = NULL;\n\tu32 mpi_control;\n\tu16 smid;\n\tu16 handle;\n\n\tif (ioc->logging_level & MPT_DEBUG_SCSI)\n\t\tscsi_print_command(scmd);\n\n\tsas_device_priv_data = scmd->device->hostdata;\n\tif (!sas_device_priv_data || !sas_device_priv_data->sas_target) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscmd->scsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tif (!(_scsih_allow_scmd_to_device(ioc, scmd))) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscmd->scsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tsas_target_priv_data = sas_device_priv_data->sas_target;\n\n\t/* invalid device handle */\n\thandle = sas_target_priv_data->handle;\n\tif (handle == MPT3SAS_INVALID_DEVICE_HANDLE) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscmd->scsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\n\tif (ioc->shost_recovery || ioc->ioc_link_reset_in_progress) {\n\t\t/* host recovery or link resets sent via IOCTLs */\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t} else if (sas_target_priv_data->deleted) {\n\t\t/* device has been deleted */\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscmd->scsi_done(scmd);\n\t\treturn 0;\n\t} else if (sas_target_priv_data->tm_busy ||\n\t\t   sas_device_priv_data->block) {\n\t\t/* device busy with task management */\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t}\n\n\t/*\n\t * Bug work around for firmware SATL handling.  The loop\n\t * is based on atomic operations and ensures consistency\n\t * since we're lockless at this point\n\t */\n\tdo {\n\t\tif (test_bit(0, &sas_device_priv_data->ata_command_pending))\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t} while (_scsih_set_satl_pending(scmd, true));\n\n\tif (scmd->sc_data_direction == DMA_FROM_DEVICE)\n\t\tmpi_control = MPI2_SCSIIO_CONTROL_READ;\n\telse if (scmd->sc_data_direction == DMA_TO_DEVICE)\n\t\tmpi_control = MPI2_SCSIIO_CONTROL_WRITE;\n\telse\n\t\tmpi_control = MPI2_SCSIIO_CONTROL_NODATATRANSFER;\n\n\t/* set tags */\n\tmpi_control |= MPI2_SCSIIO_CONTROL_SIMPLEQ;\n\t/* NCQ Prio supported, make sure control indicated high priority */\n\tif (sas_device_priv_data->ncq_prio_enable) {\n\t\tclass = IOPRIO_PRIO_CLASS(req_get_ioprio(rq));\n\t\tif (class == IOPRIO_CLASS_RT)\n\t\t\tmpi_control |= 1 << MPI2_SCSIIO_CONTROL_CMDPRI_SHIFT;\n\t}\n\t/* Make sure Device is not raid volume.\n\t * We do not expose raid functionality to upper layer for warpdrive.\n\t */\n\tif (((!ioc->is_warpdrive && !scsih_is_raid(&scmd->device->sdev_gendev))\n\t\t&& !scsih_is_nvme(&scmd->device->sdev_gendev))\n\t\t&& sas_is_tlr_enabled(scmd->device) && scmd->cmd_len != 32)\n\t\tmpi_control |= MPI2_SCSIIO_CONTROL_TLR_ON;\n\n\tsmid = mpt3sas_base_get_smid_scsiio(ioc, ioc->scsi_io_cb_idx, scmd);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\t_scsih_set_satl_pending(scmd, false);\n\t\tgoto out;\n\t}\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tmemset(mpi_request, 0, ioc->request_sz);\n\t_scsih_setup_eedp(ioc, scmd, mpi_request);\n\n\tif (scmd->cmd_len == 32)\n\t\tmpi_control |= 4 << MPI2_SCSIIO_CONTROL_ADDCDBLEN_SHIFT;\n\tmpi_request->Function = MPI2_FUNCTION_SCSI_IO_REQUEST;\n\tif (sas_device_priv_data->sas_target->flags &\n\t    MPT_TARGET_FLAGS_RAID_COMPONENT)\n\t\tmpi_request->Function = MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH;\n\telse\n\t\tmpi_request->Function = MPI2_FUNCTION_SCSI_IO_REQUEST;\n\tmpi_request->DevHandle = cpu_to_le16(handle);\n\tmpi_request->DataLength = cpu_to_le32(scsi_bufflen(scmd));\n\tmpi_request->Control = cpu_to_le32(mpi_control);\n\tmpi_request->IoFlags = cpu_to_le16(scmd->cmd_len);\n\tmpi_request->MsgFlags = MPI2_SCSIIO_MSGFLAGS_SYSTEM_SENSE_ADDR;\n\tmpi_request->SenseBufferLength = SCSI_SENSE_BUFFERSIZE;\n\tmpi_request->SenseBufferLowAddress =\n\t    mpt3sas_base_get_sense_buffer_dma(ioc, smid);\n\tmpi_request->SGLOffset0 = offsetof(Mpi25SCSIIORequest_t, SGL) / 4;\n\tint_to_scsilun(sas_device_priv_data->lun, (struct scsi_lun *)\n\t    mpi_request->LUN);\n\tmemcpy(mpi_request->CDB.CDB32, scmd->cmnd, scmd->cmd_len);\n\n\tif (mpi_request->DataLength) {\n\t\tpcie_device = sas_target_priv_data->pcie_dev;\n\t\tif (ioc->build_sg_scmd(ioc, scmd, smid, pcie_device)) {\n\t\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t\t_scsih_set_satl_pending(scmd, false);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tioc->build_zero_len_sge(ioc, &mpi_request->SGL);\n\n\traid_device = sas_target_priv_data->raid_device;\n\tif (raid_device && raid_device->direct_io_enabled)\n\t\tmpt3sas_setup_direct_io(ioc, scmd,\n\t\t\traid_device, mpi_request);\n\n\tif (likely(mpi_request->Function == MPI2_FUNCTION_SCSI_IO_REQUEST)) {\n\t\tif (sas_target_priv_data->flags & MPT_TARGET_FASTPATH_IO) {\n\t\t\tmpi_request->IoFlags = cpu_to_le16(scmd->cmd_len |\n\t\t\t    MPI25_SCSIIO_IOFLAGS_FAST_PATH);\n\t\t\tioc->put_smid_fast_path(ioc, smid, handle);\n\t\t} else\n\t\t\tioc->put_smid_scsi_io(ioc, smid,\n\t\t\t    le16_to_cpu(mpi_request->DevHandle));\n\t} else\n\t\tioc->put_smid_default(ioc, smid);\n\treturn 0;\n\n out:\n\treturn SCSI_MLQUEUE_HOST_BUSY;\n}\n\n/**\n * _scsih_normalize_sense - normalize descriptor and fixed format sense data\n * @sense_buffer: sense data returned by target\n * @data: normalized skey/asc/ascq\n */\nstatic void\n_scsih_normalize_sense(char *sense_buffer, struct sense_info *data)\n{\n\tif ((sense_buffer[0] & 0x7F) >= 0x72) {\n\t\t/* descriptor format */\n\t\tdata->skey = sense_buffer[1] & 0x0F;\n\t\tdata->asc = sense_buffer[2];\n\t\tdata->ascq = sense_buffer[3];\n\t} else {\n\t\t/* fixed format */\n\t\tdata->skey = sense_buffer[2] & 0x0F;\n\t\tdata->asc = sense_buffer[12];\n\t\tdata->ascq = sense_buffer[13];\n\t}\n}\n\n/**\n * _scsih_scsi_ioc_info - translated non-succesfull SCSI_IO request\n * @ioc: per adapter object\n * @scmd: pointer to scsi command object\n * @mpi_reply: reply mf payload returned from firmware\n * @smid: ?\n *\n * scsi_status - SCSI Status code returned from target device\n * scsi_state - state info associated with SCSI_IO determined by ioc\n * ioc_status - ioc supplied status info\n */\nstatic void\n_scsih_scsi_ioc_info(struct MPT3SAS_ADAPTER *ioc, struct scsi_cmnd *scmd,\n\tMpi2SCSIIOReply_t *mpi_reply, u16 smid)\n{\n\tu32 response_info;\n\tu8 *response_bytes;\n\tu16 ioc_status = le16_to_cpu(mpi_reply->IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tu8 scsi_state = mpi_reply->SCSIState;\n\tu8 scsi_status = mpi_reply->SCSIStatus;\n\tchar *desc_ioc_state = NULL;\n\tchar *desc_scsi_status = NULL;\n\tchar *desc_scsi_state = ioc->tmp_string;\n\tu32 log_info = le32_to_cpu(mpi_reply->IOCLogInfo);\n\tstruct _sas_device *sas_device = NULL;\n\tstruct _pcie_device *pcie_device = NULL;\n\tstruct scsi_target *starget = scmd->device->sdev_target;\n\tstruct MPT3SAS_TARGET *priv_target = starget->hostdata;\n\tchar *device_str = NULL;\n\n\tif (!priv_target)\n\t\treturn;\n\tif (ioc->hide_ir_msg)\n\t\tdevice_str = \"WarpDrive\";\n\telse\n\t\tdevice_str = \"volume\";\n\n\tif (log_info == 0x31170000)\n\t\treturn;\n\n\tswitch (ioc_status) {\n\tcase MPI2_IOCSTATUS_SUCCESS:\n\t\tdesc_ioc_state = \"success\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INVALID_FUNCTION:\n\t\tdesc_ioc_state = \"invalid function\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_RECOVERED_ERROR:\n\t\tdesc_ioc_state = \"scsi recovered error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_INVALID_DEVHANDLE:\n\t\tdesc_ioc_state = \"scsi invalid dev handle\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_DEVICE_NOT_THERE:\n\t\tdesc_ioc_state = \"scsi device not there\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_DATA_OVERRUN:\n\t\tdesc_ioc_state = \"scsi data overrun\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_DATA_UNDERRUN:\n\t\tdesc_ioc_state = \"scsi data underrun\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_IO_DATA_ERROR:\n\t\tdesc_ioc_state = \"scsi io data error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_PROTOCOL_ERROR:\n\t\tdesc_ioc_state = \"scsi protocol error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_TASK_TERMINATED:\n\t\tdesc_ioc_state = \"scsi task terminated\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:\n\t\tdesc_ioc_state = \"scsi residual mismatch\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_TASK_MGMT_FAILED:\n\t\tdesc_ioc_state = \"scsi task mgmt failed\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_IOC_TERMINATED:\n\t\tdesc_ioc_state = \"scsi ioc terminated\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_EXT_TERMINATED:\n\t\tdesc_ioc_state = \"scsi ext terminated\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_EEDP_GUARD_ERROR:\n\t\tdesc_ioc_state = \"eedp guard error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_EEDP_REF_TAG_ERROR:\n\t\tdesc_ioc_state = \"eedp ref tag error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_EEDP_APP_TAG_ERROR:\n\t\tdesc_ioc_state = \"eedp app tag error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INSUFFICIENT_POWER:\n\t\tdesc_ioc_state = \"insufficient power\";\n\t\tbreak;\n\tdefault:\n\t\tdesc_ioc_state = \"unknown\";\n\t\tbreak;\n\t}\n\n\tswitch (scsi_status) {\n\tcase MPI2_SCSI_STATUS_GOOD:\n\t\tdesc_scsi_status = \"good\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_CHECK_CONDITION:\n\t\tdesc_scsi_status = \"check condition\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_CONDITION_MET:\n\t\tdesc_scsi_status = \"condition met\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_BUSY:\n\t\tdesc_scsi_status = \"busy\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_INTERMEDIATE:\n\t\tdesc_scsi_status = \"intermediate\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_INTERMEDIATE_CONDMET:\n\t\tdesc_scsi_status = \"intermediate condmet\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_RESERVATION_CONFLICT:\n\t\tdesc_scsi_status = \"reservation conflict\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_COMMAND_TERMINATED:\n\t\tdesc_scsi_status = \"command terminated\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_TASK_SET_FULL:\n\t\tdesc_scsi_status = \"task set full\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_ACA_ACTIVE:\n\t\tdesc_scsi_status = \"aca active\";\n\t\tbreak;\n\tcase MPI2_SCSI_STATUS_TASK_ABORTED:\n\t\tdesc_scsi_status = \"task aborted\";\n\t\tbreak;\n\tdefault:\n\t\tdesc_scsi_status = \"unknown\";\n\t\tbreak;\n\t}\n\n\tdesc_scsi_state[0] = '\\0';\n\tif (!scsi_state)\n\t\tdesc_scsi_state = \" \";\n\tif (scsi_state & MPI2_SCSI_STATE_RESPONSE_INFO_VALID)\n\t\tstrcat(desc_scsi_state, \"response info \");\n\tif (scsi_state & MPI2_SCSI_STATE_TERMINATED)\n\t\tstrcat(desc_scsi_state, \"state terminated \");\n\tif (scsi_state & MPI2_SCSI_STATE_NO_SCSI_STATUS)\n\t\tstrcat(desc_scsi_state, \"no status \");\n\tif (scsi_state & MPI2_SCSI_STATE_AUTOSENSE_FAILED)\n\t\tstrcat(desc_scsi_state, \"autosense failed \");\n\tif (scsi_state & MPI2_SCSI_STATE_AUTOSENSE_VALID)\n\t\tstrcat(desc_scsi_state, \"autosense valid \");\n\n\tscsi_print_command(scmd);\n\n\tif (priv_target->flags & MPT_TARGET_FLAGS_VOLUME) {\n\t\tioc_warn(ioc, \"\\t%s wwid(0x%016llx)\\n\",\n\t\t\t device_str, (u64)priv_target->sas_address);\n\t} else if (priv_target->flags & MPT_TARGET_FLAGS_PCIE_DEVICE) {\n\t\tpcie_device = mpt3sas_get_pdev_from_target(ioc, priv_target);\n\t\tif (pcie_device) {\n\t\t\tioc_info(ioc, \"\\twwid(0x%016llx), port(%d)\\n\",\n\t\t\t\t (u64)pcie_device->wwid, pcie_device->port_num);\n\t\t\tif (pcie_device->enclosure_handle != 0)\n\t\t\t\tioc_info(ioc, \"\\tenclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t\t (u64)pcie_device->enclosure_logical_id,\n\t\t\t\t\t pcie_device->slot);\n\t\t\tif (pcie_device->connector_name[0])\n\t\t\t\tioc_info(ioc, \"\\tenclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t\t\t pcie_device->enclosure_level,\n\t\t\t\t\t pcie_device->connector_name);\n\t\t\tpcie_device_put(pcie_device);\n\t\t}\n\t} else {\n\t\tsas_device = mpt3sas_get_sdev_from_target(ioc, priv_target);\n\t\tif (sas_device) {\n\t\t\tioc_warn(ioc, \"\\tsas_address(0x%016llx), phy(%d)\\n\",\n\t\t\t\t (u64)sas_device->sas_address, sas_device->phy);\n\n\t\t\t_scsih_display_enclosure_chassis_info(ioc, sas_device,\n\t\t\t    NULL, NULL);\n\n\t\t\tsas_device_put(sas_device);\n\t\t}\n\t}\n\n\tioc_warn(ioc, \"\\thandle(0x%04x), ioc_status(%s)(0x%04x), smid(%d)\\n\",\n\t\t le16_to_cpu(mpi_reply->DevHandle),\n\t\t desc_ioc_state, ioc_status, smid);\n\tioc_warn(ioc, \"\\trequest_len(%d), underflow(%d), resid(%d)\\n\",\n\t\t scsi_bufflen(scmd), scmd->underflow, scsi_get_resid(scmd));\n\tioc_warn(ioc, \"\\ttag(%d), transfer_count(%d), sc->result(0x%08x)\\n\",\n\t\t le16_to_cpu(mpi_reply->TaskTag),\n\t\t le32_to_cpu(mpi_reply->TransferCount), scmd->result);\n\tioc_warn(ioc, \"\\tscsi_status(%s)(0x%02x), scsi_state(%s)(0x%02x)\\n\",\n\t\t desc_scsi_status, scsi_status, desc_scsi_state, scsi_state);\n\n\tif (scsi_state & MPI2_SCSI_STATE_AUTOSENSE_VALID) {\n\t\tstruct sense_info data;\n\t\t_scsih_normalize_sense(scmd->sense_buffer, &data);\n\t\tioc_warn(ioc, \"\\t[sense_key,asc,ascq]: [0x%02x,0x%02x,0x%02x], count(%d)\\n\",\n\t\t\t data.skey, data.asc, data.ascq,\n\t\t\t le32_to_cpu(mpi_reply->SenseCount));\n\t}\n\tif (scsi_state & MPI2_SCSI_STATE_RESPONSE_INFO_VALID) {\n\t\tresponse_info = le32_to_cpu(mpi_reply->ResponseInfo);\n\t\tresponse_bytes = (u8 *)&response_info;\n\t\t_scsih_response_code(ioc, response_bytes[0]);\n\t}\n}\n\n/**\n * _scsih_turn_on_pfa_led - illuminate PFA LED\n * @ioc: per adapter object\n * @handle: device handle\n * Context: process\n */\nstatic void\n_scsih_turn_on_pfa_led(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tMpi2SepReply_t mpi_reply;\n\tMpi2SepRequest_t mpi_request;\n\tstruct _sas_device *sas_device;\n\n\tsas_device = mpt3sas_get_sdev_by_handle(ioc, handle);\n\tif (!sas_device)\n\t\treturn;\n\n\tmemset(&mpi_request, 0, sizeof(Mpi2SepRequest_t));\n\tmpi_request.Function = MPI2_FUNCTION_SCSI_ENCLOSURE_PROCESSOR;\n\tmpi_request.Action = MPI2_SEP_REQ_ACTION_WRITE_STATUS;\n\tmpi_request.SlotStatus =\n\t    cpu_to_le32(MPI2_SEP_REQ_SLOTSTATUS_PREDICTED_FAULT);\n\tmpi_request.DevHandle = cpu_to_le16(handle);\n\tmpi_request.Flags = MPI2_SEP_REQ_FLAGS_DEVHANDLE_ADDRESS;\n\tif ((mpt3sas_base_scsi_enclosure_processor(ioc, &mpi_reply,\n\t    &mpi_request)) != 0) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tsas_device->pfa_led_on = 1;\n\n\tif (mpi_reply.IOCStatus || mpi_reply.IOCLogInfo) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"enclosure_processor: ioc_status (0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t    le16_to_cpu(mpi_reply.IOCStatus),\n\t\t\t\t    le32_to_cpu(mpi_reply.IOCLogInfo)));\n\t\tgoto out;\n\t}\nout:\n\tsas_device_put(sas_device);\n}\n\n/**\n * _scsih_turn_off_pfa_led - turn off Fault LED\n * @ioc: per adapter object\n * @sas_device: sas device whose PFA LED has to turned off\n * Context: process\n */\nstatic void\n_scsih_turn_off_pfa_led(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_device *sas_device)\n{\n\tMpi2SepReply_t mpi_reply;\n\tMpi2SepRequest_t mpi_request;\n\n\tmemset(&mpi_request, 0, sizeof(Mpi2SepRequest_t));\n\tmpi_request.Function = MPI2_FUNCTION_SCSI_ENCLOSURE_PROCESSOR;\n\tmpi_request.Action = MPI2_SEP_REQ_ACTION_WRITE_STATUS;\n\tmpi_request.SlotStatus = 0;\n\tmpi_request.Slot = cpu_to_le16(sas_device->slot);\n\tmpi_request.DevHandle = 0;\n\tmpi_request.EnclosureHandle = cpu_to_le16(sas_device->enclosure_handle);\n\tmpi_request.Flags = MPI2_SEP_REQ_FLAGS_ENCLOSURE_SLOT_ADDRESS;\n\tif ((mpt3sas_base_scsi_enclosure_processor(ioc, &mpi_reply,\n\t\t&mpi_request)) != 0) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tif (mpi_reply.IOCStatus || mpi_reply.IOCLogInfo) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"enclosure_processor: ioc_status (0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t    le16_to_cpu(mpi_reply.IOCStatus),\n\t\t\t\t    le32_to_cpu(mpi_reply.IOCLogInfo)));\n\t\treturn;\n\t}\n}\n\n/**\n * _scsih_send_event_to_turn_on_pfa_led - fire delayed event\n * @ioc: per adapter object\n * @handle: device handle\n * Context: interrupt.\n */\nstatic void\n_scsih_send_event_to_turn_on_pfa_led(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct fw_event_work *fw_event;\n\n\tfw_event = alloc_fw_event_work(0);\n\tif (!fw_event)\n\t\treturn;\n\tfw_event->event = MPT3SAS_TURN_ON_PFA_LED;\n\tfw_event->device_handle = handle;\n\tfw_event->ioc = ioc;\n\t_scsih_fw_event_add(ioc, fw_event);\n\tfw_event_work_put(fw_event);\n}\n\n/**\n * _scsih_smart_predicted_fault - process smart errors\n * @ioc: per adapter object\n * @handle: device handle\n * Context: interrupt.\n */\nstatic void\n_scsih_smart_predicted_fault(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct scsi_target *starget;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tMpi2EventNotificationReply_t *event_reply;\n\tMpi2EventDataSasDeviceStatusChange_t *event_data;\n\tstruct _sas_device *sas_device;\n\tssize_t sz;\n\tunsigned long flags;\n\n\t/* only handle non-raid devices */\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_handle(ioc, handle);\n\tif (!sas_device)\n\t\tgoto out_unlock;\n\n\tstarget = sas_device->starget;\n\tsas_target_priv_data = starget->hostdata;\n\n\tif ((sas_target_priv_data->flags & MPT_TARGET_FLAGS_RAID_COMPONENT) ||\n\t   ((sas_target_priv_data->flags & MPT_TARGET_FLAGS_VOLUME)))\n\t\tgoto out_unlock;\n\n\t_scsih_display_enclosure_chassis_info(NULL, sas_device, NULL, starget);\n\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\tif (ioc->pdev->subsystem_vendor == PCI_VENDOR_ID_IBM)\n\t\t_scsih_send_event_to_turn_on_pfa_led(ioc, handle);\n\n\t/* insert into event log */\n\tsz = offsetof(Mpi2EventNotificationReply_t, EventData) +\n\t     sizeof(Mpi2EventDataSasDeviceStatusChange_t);\n\tevent_reply = kzalloc(sz, GFP_ATOMIC);\n\tif (!event_reply) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\n\tevent_reply->Function = MPI2_FUNCTION_EVENT_NOTIFICATION;\n\tevent_reply->Event =\n\t    cpu_to_le16(MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE);\n\tevent_reply->MsgLength = sz/4;\n\tevent_reply->EventDataLength =\n\t    cpu_to_le16(sizeof(Mpi2EventDataSasDeviceStatusChange_t)/4);\n\tevent_data = (Mpi2EventDataSasDeviceStatusChange_t *)\n\t    event_reply->EventData;\n\tevent_data->ReasonCode = MPI2_EVENT_SAS_DEV_STAT_RC_SMART_DATA;\n\tevent_data->ASC = 0x5D;\n\tevent_data->DevHandle = cpu_to_le16(handle);\n\tevent_data->SASAddress = cpu_to_le64(sas_target_priv_data->sas_address);\n\tmpt3sas_ctl_add_to_event_log(ioc, event_reply);\n\tkfree(event_reply);\nout:\n\tif (sas_device)\n\t\tsas_device_put(sas_device);\n\treturn;\n\nout_unlock:\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\tgoto out;\n}\n\n/**\n * _scsih_io_done - scsi request callback\n * @ioc: per adapter object\n * @smid: system request message index\n * @msix_index: MSIX table index supplied by the OS\n * @reply: reply message frame(lower 32bit addr)\n *\n * Callback handler when using _scsih_qcmd.\n *\n * Return: 1 meaning mf should be freed from _base_interrupt\n *         0 means the mf is freed from this function.\n */\nstatic u8\n_scsih_io_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)\n{\n\tMpi25SCSIIORequest_t *mpi_request;\n\tMpi2SCSIIOReply_t *mpi_reply;\n\tstruct scsi_cmnd *scmd;\n\tstruct scsiio_tracker *st;\n\tu16 ioc_status;\n\tu32 xfer_cnt;\n\tu8 scsi_state;\n\tu8 scsi_status;\n\tu32 log_info;\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tu32 response_code = 0;\n\n\tmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\n\tscmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);\n\tif (scmd == NULL)\n\t\treturn 1;\n\n\t_scsih_set_satl_pending(scmd, false);\n\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\n\tif (mpi_reply == NULL) {\n\t\tscmd->result = DID_OK << 16;\n\t\tgoto out;\n\t}\n\n\tsas_device_priv_data = scmd->device->hostdata;\n\tif (!sas_device_priv_data || !sas_device_priv_data->sas_target ||\n\t     sas_device_priv_data->sas_target->deleted) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tgoto out;\n\t}\n\tioc_status = le16_to_cpu(mpi_reply->IOCStatus);\n\n\t/*\n\t * WARPDRIVE: If direct_io is set then it is directIO,\n\t * the failed direct I/O should be redirected to volume\n\t */\n\tst = scsi_cmd_priv(scmd);\n\tif (st->direct_io &&\n\t     ((ioc_status & MPI2_IOCSTATUS_MASK)\n\t      != MPI2_IOCSTATUS_SCSI_TASK_TERMINATED)) {\n\t\tst->direct_io = 0;\n\t\tst->scmd = scmd;\n\t\tmemcpy(mpi_request->CDB.CDB32, scmd->cmnd, scmd->cmd_len);\n\t\tmpi_request->DevHandle =\n\t\t    cpu_to_le16(sas_device_priv_data->sas_target->handle);\n\t\tioc->put_smid_scsi_io(ioc, smid,\n\t\t    sas_device_priv_data->sas_target->handle);\n\t\treturn 0;\n\t}\n\t/* turning off TLR */\n\tscsi_state = mpi_reply->SCSIState;\n\tif (scsi_state & MPI2_SCSI_STATE_RESPONSE_INFO_VALID)\n\t\tresponse_code =\n\t\t    le32_to_cpu(mpi_reply->ResponseInfo) & 0xFF;\n\tif (!sas_device_priv_data->tlr_snoop_check) {\n\t\tsas_device_priv_data->tlr_snoop_check++;\n\t\tif ((!ioc->is_warpdrive &&\n\t\t    !scsih_is_raid(&scmd->device->sdev_gendev) &&\n\t\t    !scsih_is_nvme(&scmd->device->sdev_gendev))\n\t\t    && sas_is_tlr_enabled(scmd->device) &&\n\t\t    response_code == MPI2_SCSITASKMGMT_RSP_INVALID_FRAME) {\n\t\t\tsas_disable_tlr(scmd->device);\n\t\t\tsdev_printk(KERN_INFO, scmd->device, \"TLR disabled\\n\");\n\t\t}\n\t}\n\n\txfer_cnt = le32_to_cpu(mpi_reply->TransferCount);\n\tscsi_set_resid(scmd, scsi_bufflen(scmd) - xfer_cnt);\n\tif (ioc_status & MPI2_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE)\n\t\tlog_info =  le32_to_cpu(mpi_reply->IOCLogInfo);\n\telse\n\t\tlog_info = 0;\n\tioc_status &= MPI2_IOCSTATUS_MASK;\n\tscsi_status = mpi_reply->SCSIStatus;\n\n\tif (ioc_status == MPI2_IOCSTATUS_SCSI_DATA_UNDERRUN && xfer_cnt == 0 &&\n\t    (scsi_status == MPI2_SCSI_STATUS_BUSY ||\n\t     scsi_status == MPI2_SCSI_STATUS_RESERVATION_CONFLICT ||\n\t     scsi_status == MPI2_SCSI_STATUS_TASK_SET_FULL)) {\n\t\tioc_status = MPI2_IOCSTATUS_SUCCESS;\n\t}\n\n\tif (scsi_state & MPI2_SCSI_STATE_AUTOSENSE_VALID) {\n\t\tstruct sense_info data;\n\t\tconst void *sense_data = mpt3sas_base_get_sense_buffer(ioc,\n\t\t    smid);\n\t\tu32 sz = min_t(u32, SCSI_SENSE_BUFFERSIZE,\n\t\t    le32_to_cpu(mpi_reply->SenseCount));\n\t\tmemcpy(scmd->sense_buffer, sense_data, sz);\n\t\t_scsih_normalize_sense(scmd->sense_buffer, &data);\n\t\t/* failure prediction threshold exceeded */\n\t\tif (data.asc == 0x5D)\n\t\t\t_scsih_smart_predicted_fault(ioc,\n\t\t\t    le16_to_cpu(mpi_reply->DevHandle));\n\t\tmpt3sas_trigger_scsi(ioc, data.skey, data.asc, data.ascq);\n\n\t\tif ((ioc->logging_level & MPT_DEBUG_REPLY) &&\n\t\t     ((scmd->sense_buffer[2] == UNIT_ATTENTION) ||\n\t\t     (scmd->sense_buffer[2] == MEDIUM_ERROR) ||\n\t\t     (scmd->sense_buffer[2] == HARDWARE_ERROR)))\n\t\t\t_scsih_scsi_ioc_info(ioc, scmd, mpi_reply, smid);\n\t}\n\tswitch (ioc_status) {\n\tcase MPI2_IOCSTATUS_BUSY:\n\tcase MPI2_IOCSTATUS_INSUFFICIENT_RESOURCES:\n\t\tscmd->result = SAM_STAT_BUSY;\n\t\tbreak;\n\n\tcase MPI2_IOCSTATUS_SCSI_DEVICE_NOT_THERE:\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tbreak;\n\n\tcase MPI2_IOCSTATUS_SCSI_IOC_TERMINATED:\n\t\tif (sas_device_priv_data->block) {\n\t\t\tscmd->result = DID_TRANSPORT_DISRUPTED << 16;\n\t\t\tgoto out;\n\t\t}\n\t\tif (log_info == 0x31110630) {\n\t\t\tif (scmd->retries > 2) {\n\t\t\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\t\t\tscsi_device_set_state(scmd->device,\n\t\t\t\t    SDEV_OFFLINE);\n\t\t\t} else {\n\t\t\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\t\t\tscmd->device->expecting_cc_ua = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (log_info == VIRTUAL_IO_FAILED_RETRY) {\n\t\t\tscmd->result = DID_RESET << 16;\n\t\t\tbreak;\n\t\t} else if ((scmd->device->channel == RAID_CHANNEL) &&\n\t\t   (scsi_state == (MPI2_SCSI_STATE_TERMINATED |\n\t\t   MPI2_SCSI_STATE_NO_SCSI_STATUS))) {\n\t\t\tscmd->result = DID_RESET << 16;\n\t\t\tbreak;\n\t\t}\n\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SCSI_TASK_TERMINATED:\n\tcase MPI2_IOCSTATUS_SCSI_EXT_TERMINATED:\n\t\tscmd->result = DID_RESET << 16;\n\t\tbreak;\n\n\tcase MPI2_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:\n\t\tif ((xfer_cnt == 0) || (scmd->underflow > xfer_cnt))\n\t\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\telse\n\t\t\tscmd->result = (DID_OK << 16) | scsi_status;\n\t\tbreak;\n\n\tcase MPI2_IOCSTATUS_SCSI_DATA_UNDERRUN:\n\t\tscmd->result = (DID_OK << 16) | scsi_status;\n\n\t\tif ((scsi_state & MPI2_SCSI_STATE_AUTOSENSE_VALID))\n\t\t\tbreak;\n\n\t\tif (xfer_cnt < scmd->underflow) {\n\t\t\tif (scsi_status == SAM_STAT_BUSY)\n\t\t\t\tscmd->result = SAM_STAT_BUSY;\n\t\t\telse\n\t\t\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\t} else if (scsi_state & (MPI2_SCSI_STATE_AUTOSENSE_FAILED |\n\t\t     MPI2_SCSI_STATE_NO_SCSI_STATUS))\n\t\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\telse if (scsi_state & MPI2_SCSI_STATE_TERMINATED)\n\t\t\tscmd->result = DID_RESET << 16;\n\t\telse if (!xfer_cnt && scmd->cmnd[0] == REPORT_LUNS) {\n\t\t\tmpi_reply->SCSIState = MPI2_SCSI_STATE_AUTOSENSE_VALID;\n\t\t\tmpi_reply->SCSIStatus = SAM_STAT_CHECK_CONDITION;\n\t\t\tscmd->result = (DRIVER_SENSE << 24) |\n\t\t\t    SAM_STAT_CHECK_CONDITION;\n\t\t\tscmd->sense_buffer[0] = 0x70;\n\t\t\tscmd->sense_buffer[2] = ILLEGAL_REQUEST;\n\t\t\tscmd->sense_buffer[12] = 0x20;\n\t\t\tscmd->sense_buffer[13] = 0;\n\t\t}\n\t\tbreak;\n\n\tcase MPI2_IOCSTATUS_SCSI_DATA_OVERRUN:\n\t\tscsi_set_resid(scmd, 0);\n\t\tfallthrough;\n\tcase MPI2_IOCSTATUS_SCSI_RECOVERED_ERROR:\n\tcase MPI2_IOCSTATUS_SUCCESS:\n\t\tscmd->result = (DID_OK << 16) | scsi_status;\n\t\tif (response_code ==\n\t\t    MPI2_SCSITASKMGMT_RSP_INVALID_FRAME ||\n\t\t    (scsi_state & (MPI2_SCSI_STATE_AUTOSENSE_FAILED |\n\t\t     MPI2_SCSI_STATE_NO_SCSI_STATUS)))\n\t\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\telse if (scsi_state & MPI2_SCSI_STATE_TERMINATED)\n\t\t\tscmd->result = DID_RESET << 16;\n\t\tbreak;\n\n\tcase MPI2_IOCSTATUS_EEDP_GUARD_ERROR:\n\tcase MPI2_IOCSTATUS_EEDP_REF_TAG_ERROR:\n\tcase MPI2_IOCSTATUS_EEDP_APP_TAG_ERROR:\n\t\t_scsih_eedp_error_handling(scmd, ioc_status);\n\t\tbreak;\n\n\tcase MPI2_IOCSTATUS_SCSI_PROTOCOL_ERROR:\n\tcase MPI2_IOCSTATUS_INVALID_FUNCTION:\n\tcase MPI2_IOCSTATUS_INVALID_SGL:\n\tcase MPI2_IOCSTATUS_INTERNAL_ERROR:\n\tcase MPI2_IOCSTATUS_INVALID_FIELD:\n\tcase MPI2_IOCSTATUS_INVALID_STATE:\n\tcase MPI2_IOCSTATUS_SCSI_IO_DATA_ERROR:\n\tcase MPI2_IOCSTATUS_SCSI_TASK_MGMT_FAILED:\n\tcase MPI2_IOCSTATUS_INSUFFICIENT_POWER:\n\tdefault:\n\t\tscmd->result = DID_SOFT_ERROR << 16;\n\t\tbreak;\n\n\t}\n\n\tif (scmd->result && (ioc->logging_level & MPT_DEBUG_REPLY))\n\t\t_scsih_scsi_ioc_info(ioc , scmd, mpi_reply, smid);\n\n out:\n\n\tscsi_dma_unmap(scmd);\n\tmpt3sas_base_free_smid(ioc, smid);\n\tscmd->scsi_done(scmd);\n\treturn 0;\n}\n\n/**\n * _scsih_update_vphys_after_reset - update the Port's\n *\t\t\tvphys_list after reset\n * @ioc: per adapter object\n *\n * Returns nothing.\n */\nstatic void\n_scsih_update_vphys_after_reset(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu16 sz, ioc_status;\n\tint i;\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasIOUnitPage0_t *sas_iounit_pg0 = NULL;\n\tu16 attached_handle;\n\tu64 attached_sas_addr;\n\tu8 found = 0, port_id;\n\tMpi2SasPhyPage0_t phy_pg0;\n\tstruct hba_port *port, *port_next, *mport;\n\tstruct virtual_phy *vphy, *vphy_next;\n\tstruct _sas_device *sas_device;\n\n\t/*\n\t * Mark all the vphys objects as dirty.\n\t */\n\tlist_for_each_entry_safe(port, port_next,\n\t    &ioc->port_table_list, list) {\n\t\tif (!port->vphys_mask)\n\t\t\tcontinue;\n\t\tlist_for_each_entry_safe(vphy, vphy_next,\n\t\t    &port->vphys_list, list) {\n\t\t\tvphy->flags |= MPT_VPHY_FLAG_DIRTY_PHY;\n\t\t}\n\t}\n\n\t/*\n\t * Read SASIOUnitPage0 to get each HBA Phy's data.\n\t */\n\tsz = offsetof(Mpi2SasIOUnitPage0_t, PhyData) +\n\t    (ioc->sas_hba.num_phys * sizeof(Mpi2SasIOUnit0PhyData_t));\n\tsas_iounit_pg0 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_iounit_pg0) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\tif ((mpt3sas_config_get_sas_iounit_pg0(ioc, &mpi_reply,\n\t    sas_iounit_pg0, sz)) != 0)\n\t\tgoto out;\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\tgoto out;\n\t/*\n\t * Loop over each HBA Phy.\n\t */\n\tfor (i = 0; i < ioc->sas_hba.num_phys; i++) {\n\t\t/*\n\t\t * Check whether Phy's Negotiation Link Rate is > 1.5G or not.\n\t\t */\n\t\tif ((sas_iounit_pg0->PhyData[i].NegotiatedLinkRate >> 4) <\n\t\t    MPI2_SAS_NEG_LINK_RATE_1_5)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check whether Phy is connected to SEP device or not,\n\t\t * if it is SEP device then read the Phy's SASPHYPage0 data to\n\t\t * determine whether Phy is a virtual Phy or not. if it is\n\t\t * virtual phy then it is conformed that the attached remote\n\t\t * device is a HBA's vSES device.\n\t\t */\n\t\tif (!(le32_to_cpu(\n\t\t    sas_iounit_pg0->PhyData[i].ControllerPhyDeviceInfo) &\n\t\t    MPI2_SAS_DEVICE_INFO_SEP))\n\t\t\tcontinue;\n\n\t\tif ((mpt3sas_config_get_phy_pg0(ioc, &mpi_reply, &phy_pg0,\n\t\t    i))) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(le32_to_cpu(phy_pg0.PhyInfo) &\n\t\t    MPI2_SAS_PHYINFO_VIRTUAL_PHY))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Get the vSES device's SAS Address.\n\t\t */\n\t\tattached_handle = le16_to_cpu(\n\t\t    sas_iounit_pg0->PhyData[i].AttachedDevHandle);\n\t\tif (_scsih_get_sas_address(ioc, attached_handle,\n\t\t    &attached_sas_addr) != 0) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfound = 0;\n\t\tport = port_next = NULL;\n\t\t/*\n\t\t * Loop over each virtual_phy object from\n\t\t * each port's vphys_list.\n\t\t */\n\t\tlist_for_each_entry_safe(port,\n\t\t    port_next, &ioc->port_table_list, list) {\n\t\t\tif (!port->vphys_mask)\n\t\t\t\tcontinue;\n\t\t\tlist_for_each_entry_safe(vphy, vphy_next,\n\t\t\t    &port->vphys_list, list) {\n\t\t\t\t/*\n\t\t\t\t * Continue with next virtual_phy object\n\t\t\t\t * if the object is not marked as dirty.\n\t\t\t\t */\n\t\t\t\tif (!(vphy->flags & MPT_VPHY_FLAG_DIRTY_PHY))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/*\n\t\t\t\t * Continue with next virtual_phy object\n\t\t\t\t * if the object's SAS Address is not equals\n\t\t\t\t * to current Phy's vSES device SAS Address.\n\t\t\t\t */\n\t\t\t\tif (vphy->sas_address != attached_sas_addr)\n\t\t\t\t\tcontinue;\n\t\t\t\t/*\n\t\t\t\t * Enable current Phy number bit in object's\n\t\t\t\t * phy_mask field.\n\t\t\t\t */\n\t\t\t\tif (!(vphy->phy_mask & (1 << i)))\n\t\t\t\t\tvphy->phy_mask = (1 << i);\n\t\t\t\t/*\n\t\t\t\t * Get hba_port object from hba_port table\n\t\t\t\t * corresponding to current phy's Port ID.\n\t\t\t\t * if there is no hba_port object corresponding\n\t\t\t\t * to Phy's Port ID then create a new hba_port\n\t\t\t\t * object & add to hba_port table.\n\t\t\t\t */\n\t\t\t\tport_id = sas_iounit_pg0->PhyData[i].Port;\n\t\t\t\tmport = mpt3sas_get_port_by_id(ioc, port_id, 1);\n\t\t\t\tif (!mport) {\n\t\t\t\t\tmport = kzalloc(\n\t\t\t\t\t    sizeof(struct hba_port), GFP_KERNEL);\n\t\t\t\t\tif (!mport)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tmport->port_id = port_id;\n\t\t\t\t\tioc_info(ioc,\n\t\t\t\t\t    \"%s: hba_port entry: %p, port: %d is added to hba_port list\\n\",\n\t\t\t\t\t    __func__, mport, mport->port_id);\n\t\t\t\t\tlist_add_tail(&mport->list,\n\t\t\t\t\t\t&ioc->port_table_list);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If mport & port pointers are not pointing to\n\t\t\t\t * same hba_port object then it means that vSES\n\t\t\t\t * device's Port ID got changed after reset and\n\t\t\t\t * hence move current virtual_phy object from\n\t\t\t\t * port's vphys_list to mport's vphys_list.\n\t\t\t\t */\n\t\t\t\tif (port != mport) {\n\t\t\t\t\tif (!mport->vphys_mask)\n\t\t\t\t\t\tINIT_LIST_HEAD(\n\t\t\t\t\t\t    &mport->vphys_list);\n\t\t\t\t\tmport->vphys_mask |= (1 << i);\n\t\t\t\t\tport->vphys_mask &= ~(1 << i);\n\t\t\t\t\tlist_move(&vphy->list,\n\t\t\t\t\t    &mport->vphys_list);\n\t\t\t\t\tsas_device = mpt3sas_get_sdev_by_addr(\n\t\t\t\t\t    ioc, attached_sas_addr, port);\n\t\t\t\t\tif (sas_device)\n\t\t\t\t\t\tsas_device->port = mport;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Earlier while updating the hba_port table,\n\t\t\t\t * it is determined that there is no other\n\t\t\t\t * direct attached device with mport's Port ID,\n\t\t\t\t * Hence mport was marked as dirty. Only vSES\n\t\t\t\t * device has this Port ID, so unmark the mport\n\t\t\t\t * as dirt.\n\t\t\t\t */\n\t\t\t\tif (mport->flags & HBA_PORT_FLAG_DIRTY_PORT) {\n\t\t\t\t\tmport->sas_address = 0;\n\t\t\t\t\tmport->phy_mask = 0;\n\t\t\t\t\tmport->flags &=\n\t\t\t\t\t    ~HBA_PORT_FLAG_DIRTY_PORT;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Unmark current virtual_phy object as dirty.\n\t\t\t\t */\n\t\t\t\tvphy->flags &= ~MPT_VPHY_FLAG_DIRTY_PHY;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (found)\n\t\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tkfree(sas_iounit_pg0);\n}\n\n/**\n * _scsih_get_port_table_after_reset - Construct temporary port table\n * @ioc: per adapter object\n * @port_table: address where port table needs to be constructed\n *\n * return number of HBA port entries available after reset.\n */\nstatic int\n_scsih_get_port_table_after_reset(struct MPT3SAS_ADAPTER *ioc,\n\tstruct hba_port *port_table)\n{\n\tu16 sz, ioc_status;\n\tint i, j;\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasIOUnitPage0_t *sas_iounit_pg0 = NULL;\n\tu16 attached_handle;\n\tu64 attached_sas_addr;\n\tu8 found = 0, port_count = 0, port_id;\n\n\tsz = offsetof(Mpi2SasIOUnitPage0_t, PhyData) + (ioc->sas_hba.num_phys\n\t    * sizeof(Mpi2SasIOUnit0PhyData_t));\n\tsas_iounit_pg0 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_iounit_pg0) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\treturn port_count;\n\t}\n\n\tif ((mpt3sas_config_get_sas_iounit_pg0(ioc, &mpi_reply,\n\t    sas_iounit_pg0, sz)) != 0)\n\t\tgoto out;\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\tgoto out;\n\tfor (i = 0; i < ioc->sas_hba.num_phys; i++) {\n\t\tfound = 0;\n\t\tif ((sas_iounit_pg0->PhyData[i].NegotiatedLinkRate >> 4) <\n\t\t    MPI2_SAS_NEG_LINK_RATE_1_5)\n\t\t\tcontinue;\n\t\tattached_handle =\n\t\t    le16_to_cpu(sas_iounit_pg0->PhyData[i].AttachedDevHandle);\n\t\tif (_scsih_get_sas_address(\n\t\t    ioc, attached_handle, &attached_sas_addr) != 0) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t    __FILE__, __LINE__, __func__);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < port_count; j++) {\n\t\t\tport_id = sas_iounit_pg0->PhyData[i].Port;\n\t\t\tif (port_table[j].port_id == port_id &&\n\t\t\t    port_table[j].sas_address == attached_sas_addr) {\n\t\t\t\tport_table[j].phy_mask |= (1 << i);\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found)\n\t\t\tcontinue;\n\n\t\tport_id = sas_iounit_pg0->PhyData[i].Port;\n\t\tport_table[port_count].port_id = port_id;\n\t\tport_table[port_count].phy_mask = (1 << i);\n\t\tport_table[port_count].sas_address = attached_sas_addr;\n\t\tport_count++;\n\t}\nout:\n\tkfree(sas_iounit_pg0);\n\treturn port_count;\n}\n\nenum hba_port_matched_codes {\n\tNOT_MATCHED = 0,\n\tMATCHED_WITH_ADDR_AND_PHYMASK,\n\tMATCHED_WITH_ADDR_SUBPHYMASK_AND_PORT,\n\tMATCHED_WITH_ADDR_AND_SUBPHYMASK,\n\tMATCHED_WITH_ADDR,\n};\n\n/**\n * _scsih_look_and_get_matched_port_entry - Get matched hba port entry\n *\t\t\t\t\tfrom HBA port table\n * @ioc: per adapter object\n * @port_entry - hba port entry from temporary port table which needs to be\n *\t\tsearched for matched entry in the HBA port table\n * @matched_port_entry - save matched hba port entry here\n * @count - count of matched entries\n *\n * return type of matched entry found.\n */\nstatic enum hba_port_matched_codes\n_scsih_look_and_get_matched_port_entry(struct MPT3SAS_ADAPTER *ioc,\n\tstruct hba_port *port_entry,\n\tstruct hba_port **matched_port_entry, int *count)\n{\n\tstruct hba_port *port_table_entry, *matched_port = NULL;\n\tenum hba_port_matched_codes matched_code = NOT_MATCHED;\n\tint lcount = 0;\n\t*matched_port_entry = NULL;\n\n\tlist_for_each_entry(port_table_entry, &ioc->port_table_list, list) {\n\t\tif (!(port_table_entry->flags & HBA_PORT_FLAG_DIRTY_PORT))\n\t\t\tcontinue;\n\n\t\tif ((port_table_entry->sas_address == port_entry->sas_address)\n\t\t    && (port_table_entry->phy_mask == port_entry->phy_mask)) {\n\t\t\tmatched_code = MATCHED_WITH_ADDR_AND_PHYMASK;\n\t\t\tmatched_port = port_table_entry;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((port_table_entry->sas_address == port_entry->sas_address)\n\t\t    && (port_table_entry->phy_mask & port_entry->phy_mask)\n\t\t    && (port_table_entry->port_id == port_entry->port_id)) {\n\t\t\tmatched_code = MATCHED_WITH_ADDR_SUBPHYMASK_AND_PORT;\n\t\t\tmatched_port = port_table_entry;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((port_table_entry->sas_address == port_entry->sas_address)\n\t\t    && (port_table_entry->phy_mask & port_entry->phy_mask)) {\n\t\t\tif (matched_code ==\n\t\t\t    MATCHED_WITH_ADDR_SUBPHYMASK_AND_PORT)\n\t\t\t\tcontinue;\n\t\t\tmatched_code = MATCHED_WITH_ADDR_AND_SUBPHYMASK;\n\t\t\tmatched_port = port_table_entry;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (port_table_entry->sas_address == port_entry->sas_address) {\n\t\t\tif (matched_code ==\n\t\t\t    MATCHED_WITH_ADDR_SUBPHYMASK_AND_PORT)\n\t\t\t\tcontinue;\n\t\t\tif (matched_code == MATCHED_WITH_ADDR_AND_SUBPHYMASK)\n\t\t\t\tcontinue;\n\t\t\tmatched_code = MATCHED_WITH_ADDR;\n\t\t\tmatched_port = port_table_entry;\n\t\t\tlcount++;\n\t\t}\n\t}\n\n\t*matched_port_entry = matched_port;\n\tif (matched_code ==  MATCHED_WITH_ADDR)\n\t\t*count = lcount;\n\treturn matched_code;\n}\n\n/**\n * _scsih_del_phy_part_of_anther_port - remove phy if it\n *\t\t\t\tis a part of anther port\n *@ioc: per adapter object\n *@port_table: port table after reset\n *@index: hba port entry index\n *@port_count: number of ports available after host reset\n *@offset: HBA phy bit offset\n *\n */\nstatic void\n_scsih_del_phy_part_of_anther_port(struct MPT3SAS_ADAPTER *ioc,\n\tstruct hba_port *port_table,\n\tint index, u8 port_count, int offset)\n{\n\tstruct _sas_node *sas_node = &ioc->sas_hba;\n\tu32 i, found = 0;\n\n\tfor (i = 0; i < port_count; i++) {\n\t\tif (i == index)\n\t\t\tcontinue;\n\n\t\tif (port_table[i].phy_mask & (1 << offset)) {\n\t\t\tmpt3sas_transport_del_phy_from_an_existing_port(\n\t\t\t    ioc, sas_node, &sas_node->phy[offset]);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\tport_table[index].phy_mask |= (1 << offset);\n}\n\n/**\n * _scsih_add_or_del_phys_from_existing_port - add/remove phy to/from\n *\t\t\t\t\t\tright port\n *@ioc: per adapter object\n *@hba_port_entry: hba port table entry\n *@port_table: temporary port table\n *@index: hba port entry index\n *@port_count: number of ports available after host reset\n *\n */\nstatic void\n_scsih_add_or_del_phys_from_existing_port(struct MPT3SAS_ADAPTER *ioc,\n\tstruct hba_port *hba_port_entry, struct hba_port *port_table,\n\tint index, int port_count)\n{\n\tu32 phy_mask, offset = 0;\n\tstruct _sas_node *sas_node = &ioc->sas_hba;\n\n\tphy_mask = hba_port_entry->phy_mask ^ port_table[index].phy_mask;\n\n\tfor (offset = 0; offset < ioc->sas_hba.num_phys; offset++) {\n\t\tif (phy_mask & (1 << offset)) {\n\t\t\tif (!(port_table[index].phy_mask & (1 << offset))) {\n\t\t\t\t_scsih_del_phy_part_of_anther_port(\n\t\t\t\t    ioc, port_table, index, port_count,\n\t\t\t\t    offset);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sas_node->phy[offset].phy_belongs_to_port)\n\t\t\t\tmpt3sas_transport_del_phy_from_an_existing_port(\n\t\t\t\t    ioc, sas_node, &sas_node->phy[offset]);\n\t\t\tmpt3sas_transport_add_phy_to_an_existing_port(\n\t\t\t    ioc, sas_node, &sas_node->phy[offset],\n\t\t\t    hba_port_entry->sas_address,\n\t\t\t    hba_port_entry);\n\t\t}\n\t}\n}\n\n/**\n * _scsih_del_dirty_vphy - delete virtual_phy objects marked as dirty.\n * @ioc: per adapter object\n *\n * Returns nothing.\n */\nstatic void\n_scsih_del_dirty_vphy(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct hba_port *port, *port_next;\n\tstruct virtual_phy *vphy, *vphy_next;\n\n\tlist_for_each_entry_safe(port, port_next,\n\t    &ioc->port_table_list, list) {\n\t\tif (!port->vphys_mask)\n\t\t\tcontinue;\n\t\tlist_for_each_entry_safe(vphy, vphy_next,\n\t\t    &port->vphys_list, list) {\n\t\t\tif (vphy->flags & MPT_VPHY_FLAG_DIRTY_PHY) {\n\t\t\t\tdrsprintk(ioc, ioc_info(ioc,\n\t\t\t\t    \"Deleting vphy %p entry from port id: %d\\t, Phy_mask 0x%08x\\n\",\n\t\t\t\t    vphy, port->port_id,\n\t\t\t\t    vphy->phy_mask));\n\t\t\t\tport->vphys_mask &= ~vphy->phy_mask;\n\t\t\t\tlist_del(&vphy->list);\n\t\t\t\tkfree(vphy);\n\t\t\t}\n\t\t}\n\t\tif (!port->vphys_mask && !port->sas_address)\n\t\t\tport->flags |= HBA_PORT_FLAG_DIRTY_PORT;\n\t}\n}\n\n/**\n * _scsih_del_dirty_port_entries - delete dirty port entries from port list\n *\t\t\t\t\tafter host reset\n *@ioc: per adapter object\n *\n */\nstatic void\n_scsih_del_dirty_port_entries(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct hba_port *port, *port_next;\n\n\tlist_for_each_entry_safe(port, port_next,\n\t    &ioc->port_table_list, list) {\n\t\tif (!(port->flags & HBA_PORT_FLAG_DIRTY_PORT) ||\n\t\t    port->flags & HBA_PORT_FLAG_NEW_PORT)\n\t\t\tcontinue;\n\n\t\tdrsprintk(ioc, ioc_info(ioc,\n\t\t    \"Deleting port table entry %p having Port: %d\\t Phy_mask 0x%08x\\n\",\n\t\t    port, port->port_id, port->phy_mask));\n\t\tlist_del(&port->list);\n\t\tkfree(port);\n\t}\n}\n\n/**\n * _scsih_sas_port_refresh - Update HBA port table after host reset\n * @ioc: per adapter object\n */\nstatic void\n_scsih_sas_port_refresh(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu32 port_count = 0;\n\tstruct hba_port *port_table;\n\tstruct hba_port *port_table_entry;\n\tstruct hba_port *port_entry = NULL;\n\tint i, j, count = 0, lcount = 0;\n\tint ret;\n\tu64 sas_addr;\n\n\tdrsprintk(ioc, ioc_info(ioc,\n\t    \"updating ports for sas_host(0x%016llx)\\n\",\n\t    (unsigned long long)ioc->sas_hba.sas_address));\n\n\tport_table = kcalloc(ioc->sas_hba.num_phys,\n\t    sizeof(struct hba_port), GFP_KERNEL);\n\tif (!port_table)\n\t\treturn;\n\n\tport_count = _scsih_get_port_table_after_reset(ioc, port_table);\n\tif (!port_count)\n\t\treturn;\n\n\tdrsprintk(ioc, ioc_info(ioc, \"New Port table\\n\"));\n\tfor (j = 0; j < port_count; j++)\n\t\tdrsprintk(ioc, ioc_info(ioc,\n\t\t    \"Port: %d\\t Phy_mask 0x%08x\\t sas_addr(0x%016llx)\\n\",\n\t\t    port_table[j].port_id,\n\t\t    port_table[j].phy_mask, port_table[j].sas_address));\n\n\tlist_for_each_entry(port_table_entry, &ioc->port_table_list, list)\n\t\tport_table_entry->flags |= HBA_PORT_FLAG_DIRTY_PORT;\n\n\tdrsprintk(ioc, ioc_info(ioc, \"Old Port table\\n\"));\n\tport_table_entry = NULL;\n\tlist_for_each_entry(port_table_entry, &ioc->port_table_list, list) {\n\t\tdrsprintk(ioc, ioc_info(ioc,\n\t\t    \"Port: %d\\t Phy_mask 0x%08x\\t sas_addr(0x%016llx)\\n\",\n\t\t    port_table_entry->port_id,\n\t\t    port_table_entry->phy_mask,\n\t\t    port_table_entry->sas_address));\n\t}\n\n\tfor (j = 0; j < port_count; j++) {\n\t\tret = _scsih_look_and_get_matched_port_entry(ioc,\n\t\t    &port_table[j], &port_entry, &count);\n\t\tif (!port_entry) {\n\t\t\tdrsprintk(ioc, ioc_info(ioc,\n\t\t\t    \"No Matched entry for sas_addr(0x%16llx), Port:%d\\n\",\n\t\t\t    port_table[j].sas_address,\n\t\t\t    port_table[j].port_id));\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase MATCHED_WITH_ADDR_SUBPHYMASK_AND_PORT:\n\t\tcase MATCHED_WITH_ADDR_AND_SUBPHYMASK:\n\t\t\t_scsih_add_or_del_phys_from_existing_port(ioc,\n\t\t\t    port_entry, port_table, j, port_count);\n\t\t\tbreak;\n\t\tcase MATCHED_WITH_ADDR:\n\t\t\tsas_addr = port_table[j].sas_address;\n\t\t\tfor (i = 0; i < port_count; i++) {\n\t\t\t\tif (port_table[i].sas_address == sas_addr)\n\t\t\t\t\tlcount++;\n\t\t\t}\n\n\t\t\tif (count > 1 || lcount > 1)\n\t\t\t\tport_entry = NULL;\n\t\t\telse\n\t\t\t\t_scsih_add_or_del_phys_from_existing_port(ioc,\n\t\t\t\t    port_entry, port_table, j, port_count);\n\t\t}\n\n\t\tif (!port_entry)\n\t\t\tcontinue;\n\n\t\tif (port_entry->port_id != port_table[j].port_id)\n\t\t\tport_entry->port_id = port_table[j].port_id;\n\t\tport_entry->flags &= ~HBA_PORT_FLAG_DIRTY_PORT;\n\t\tport_entry->phy_mask = port_table[j].phy_mask;\n\t}\n\n\tport_table_entry = NULL;\n}\n\n/**\n * _scsih_alloc_vphy - allocate virtual_phy object\n * @ioc: per adapter object\n * @port_id: Port ID number\n * @phy_num: HBA Phy number\n *\n * Returns allocated virtual_phy object.\n */\nstatic struct virtual_phy *\n_scsih_alloc_vphy(struct MPT3SAS_ADAPTER *ioc, u8 port_id, u8 phy_num)\n{\n\tstruct virtual_phy *vphy;\n\tstruct hba_port *port;\n\n\tport = mpt3sas_get_port_by_id(ioc, port_id, 0);\n\tif (!port)\n\t\treturn NULL;\n\n\tvphy = mpt3sas_get_vphy_by_phy(ioc, port, phy_num);\n\tif (!vphy) {\n\t\tvphy = kzalloc(sizeof(struct virtual_phy), GFP_KERNEL);\n\t\tif (!vphy)\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * Enable bit corresponding to HBA phy number on its\n\t\t * parent hba_port object's vphys_mask field.\n\t\t */\n\t\tport->vphys_mask |= (1 << phy_num);\n\t\tvphy->phy_mask |= (1 << phy_num);\n\n\t\tINIT_LIST_HEAD(&port->vphys_list);\n\t\tlist_add_tail(&vphy->list, &port->vphys_list);\n\n\t\tioc_info(ioc,\n\t\t    \"vphy entry: %p, port id: %d, phy:%d is added to port's vphys_list\\n\",\n\t\t    vphy, port->port_id, phy_num);\n\t}\n\treturn vphy;\n}\n\n/**\n * _scsih_sas_host_refresh - refreshing sas host object contents\n * @ioc: per adapter object\n * Context: user\n *\n * During port enable, fw will send topology events for every device. Its\n * possible that the handles may change from the previous setting, so this\n * code keeping handles updating if changed.\n */\nstatic void\n_scsih_sas_host_refresh(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu16 sz;\n\tu16 ioc_status;\n\tint i;\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasIOUnitPage0_t *sas_iounit_pg0 = NULL;\n\tu16 attached_handle;\n\tu8 link_rate, port_id;\n\tstruct hba_port *port;\n\tMpi2SasPhyPage0_t phy_pg0;\n\n\tdtmprintk(ioc,\n\t\t  ioc_info(ioc, \"updating handles for sas_host(0x%016llx)\\n\",\n\t\t\t   (u64)ioc->sas_hba.sas_address));\n\n\tsz = offsetof(Mpi2SasIOUnitPage0_t, PhyData) + (ioc->sas_hba.num_phys\n\t    * sizeof(Mpi2SasIOUnit0PhyData_t));\n\tsas_iounit_pg0 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_iounit_pg0) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tif ((mpt3sas_config_get_sas_iounit_pg0(ioc, &mpi_reply,\n\t    sas_iounit_pg0, sz)) != 0)\n\t\tgoto out;\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\tgoto out;\n\tfor (i = 0; i < ioc->sas_hba.num_phys ; i++) {\n\t\tlink_rate = sas_iounit_pg0->PhyData[i].NegotiatedLinkRate >> 4;\n\t\tif (i == 0)\n\t\t\tioc->sas_hba.handle = le16_to_cpu(\n\t\t\t    sas_iounit_pg0->PhyData[0].ControllerDevHandle);\n\t\tport_id = sas_iounit_pg0->PhyData[i].Port;\n\t\tif (!(mpt3sas_get_port_by_id(ioc, port_id, 0))) {\n\t\t\tport = kzalloc(sizeof(struct hba_port), GFP_KERNEL);\n\t\t\tif (!port)\n\t\t\t\tgoto out;\n\n\t\t\tport->port_id = port_id;\n\t\t\tioc_info(ioc,\n\t\t\t    \"hba_port entry: %p, port: %d is added to hba_port list\\n\",\n\t\t\t    port, port->port_id);\n\t\t\tif (ioc->shost_recovery)\n\t\t\t\tport->flags = HBA_PORT_FLAG_NEW_PORT;\n\t\t\tlist_add_tail(&port->list, &ioc->port_table_list);\n\t\t}\n\t\t/*\n\t\t * Check whether current Phy belongs to HBA vSES device or not.\n\t\t */\n\t\tif (le32_to_cpu(sas_iounit_pg0->PhyData[i].ControllerPhyDeviceInfo) &\n\t\t    MPI2_SAS_DEVICE_INFO_SEP &&\n\t\t    (link_rate >=  MPI2_SAS_NEG_LINK_RATE_1_5)) {\n\t\t\tif ((mpt3sas_config_get_phy_pg0(ioc, &mpi_reply,\n\t\t\t    &phy_pg0, i))) {\n\t\t\t\tioc_err(ioc,\n\t\t\t\t    \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t     __FILE__, __LINE__, __func__);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!(le32_to_cpu(phy_pg0.PhyInfo) &\n\t\t\t    MPI2_SAS_PHYINFO_VIRTUAL_PHY))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Allocate a virtual_phy object for vSES device, if\n\t\t\t * this vSES device is hot added.\n\t\t\t */\n\t\t\tif (!_scsih_alloc_vphy(ioc, port_id, i))\n\t\t\t\tgoto out;\n\t\t\tioc->sas_hba.phy[i].hba_vphy = 1;\n\t\t}\n\n\t\tioc->sas_hba.phy[i].handle = ioc->sas_hba.handle;\n\t\tattached_handle = le16_to_cpu(sas_iounit_pg0->PhyData[i].\n\t\t    AttachedDevHandle);\n\t\tif (attached_handle && link_rate < MPI2_SAS_NEG_LINK_RATE_1_5)\n\t\t\tlink_rate = MPI2_SAS_NEG_LINK_RATE_1_5;\n\t\tioc->sas_hba.phy[i].port =\n\t\t    mpt3sas_get_port_by_id(ioc, port_id, 0);\n\t\tmpt3sas_transport_update_links(ioc, ioc->sas_hba.sas_address,\n\t\t    attached_handle, i, link_rate,\n\t\t    ioc->sas_hba.phy[i].port);\n\t}\n out:\n\tkfree(sas_iounit_pg0);\n}\n\n/**\n * _scsih_sas_host_add - create sas host object\n * @ioc: per adapter object\n *\n * Creating host side data object, stored in ioc->sas_hba\n */\nstatic void\n_scsih_sas_host_add(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint i;\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasIOUnitPage0_t *sas_iounit_pg0 = NULL;\n\tMpi2SasIOUnitPage1_t *sas_iounit_pg1 = NULL;\n\tMpi2SasPhyPage0_t phy_pg0;\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tMpi2SasEnclosurePage0_t enclosure_pg0;\n\tu16 ioc_status;\n\tu16 sz;\n\tu8 device_missing_delay;\n\tu8 num_phys, port_id;\n\tstruct hba_port *port;\n\n\tmpt3sas_config_get_number_hba_phys(ioc, &num_phys);\n\tif (!num_phys) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\tioc->sas_hba.phy = kcalloc(num_phys,\n\t    sizeof(struct _sas_phy), GFP_KERNEL);\n\tif (!ioc->sas_hba.phy) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tioc->sas_hba.num_phys = num_phys;\n\n\t/* sas_iounit page 0 */\n\tsz = offsetof(Mpi2SasIOUnitPage0_t, PhyData) + (ioc->sas_hba.num_phys *\n\t    sizeof(Mpi2SasIOUnit0PhyData_t));\n\tsas_iounit_pg0 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_iounit_pg0) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\tif ((mpt3sas_config_get_sas_iounit_pg0(ioc, &mpi_reply,\n\t    sas_iounit_pg0, sz))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\n\t/* sas_iounit page 1 */\n\tsz = offsetof(Mpi2SasIOUnitPage1_t, PhyData) + (ioc->sas_hba.num_phys *\n\t    sizeof(Mpi2SasIOUnit1PhyData_t));\n\tsas_iounit_pg1 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_iounit_pg1) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tif ((mpt3sas_config_get_sas_iounit_pg1(ioc, &mpi_reply,\n\t    sas_iounit_pg1, sz))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\n\tioc->io_missing_delay =\n\t    sas_iounit_pg1->IODeviceMissingDelay;\n\tdevice_missing_delay =\n\t    sas_iounit_pg1->ReportDeviceMissingDelay;\n\tif (device_missing_delay & MPI2_SASIOUNIT1_REPORT_MISSING_UNIT_16)\n\t\tioc->device_missing_delay = (device_missing_delay &\n\t\t    MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK) * 16;\n\telse\n\t\tioc->device_missing_delay = device_missing_delay &\n\t\t    MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK;\n\n\tioc->sas_hba.parent_dev = &ioc->shost->shost_gendev;\n\tfor (i = 0; i < ioc->sas_hba.num_phys ; i++) {\n\t\tif ((mpt3sas_config_get_phy_pg0(ioc, &mpi_reply, &phy_pg0,\n\t\t    i))) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (i == 0)\n\t\t\tioc->sas_hba.handle = le16_to_cpu(sas_iounit_pg0->\n\t\t\t    PhyData[0].ControllerDevHandle);\n\n\t\tport_id = sas_iounit_pg0->PhyData[i].Port;\n\t\tif (!(mpt3sas_get_port_by_id(ioc, port_id, 0))) {\n\t\t\tport = kzalloc(sizeof(struct hba_port), GFP_KERNEL);\n\t\t\tif (!port)\n\t\t\t\tgoto out;\n\n\t\t\tport->port_id = port_id;\n\t\t\tioc_info(ioc,\n\t\t\t   \"hba_port entry: %p, port: %d is added to hba_port list\\n\",\n\t\t\t   port, port->port_id);\n\t\t\tlist_add_tail(&port->list,\n\t\t\t    &ioc->port_table_list);\n\t\t}\n\n\t\t/*\n\t\t * Check whether current Phy belongs to HBA vSES device or not.\n\t\t */\n\t\tif ((le32_to_cpu(phy_pg0.PhyInfo) &\n\t\t    MPI2_SAS_PHYINFO_VIRTUAL_PHY) &&\n\t\t    (phy_pg0.NegotiatedLinkRate >> 4) >=\n\t\t    MPI2_SAS_NEG_LINK_RATE_1_5) {\n\t\t\t/*\n\t\t\t * Allocate a virtual_phy object for vSES device.\n\t\t\t */\n\t\t\tif (!_scsih_alloc_vphy(ioc, port_id, i))\n\t\t\t\tgoto out;\n\t\t\tioc->sas_hba.phy[i].hba_vphy = 1;\n\t\t}\n\n\t\tioc->sas_hba.phy[i].handle = ioc->sas_hba.handle;\n\t\tioc->sas_hba.phy[i].phy_id = i;\n\t\tioc->sas_hba.phy[i].port =\n\t\t    mpt3sas_get_port_by_id(ioc, port_id, 0);\n\t\tmpt3sas_transport_add_host_phy(ioc, &ioc->sas_hba.phy[i],\n\t\t    phy_pg0, ioc->sas_hba.parent_dev);\n\t}\n\tif ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\n\t    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, ioc->sas_hba.handle))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tioc->sas_hba.enclosure_handle =\n\t    le16_to_cpu(sas_device_pg0.EnclosureHandle);\n\tioc->sas_hba.sas_address = le64_to_cpu(sas_device_pg0.SASAddress);\n\tioc_info(ioc, \"host_add: handle(0x%04x), sas_addr(0x%016llx), phys(%d)\\n\",\n\t\t ioc->sas_hba.handle,\n\t\t (u64)ioc->sas_hba.sas_address,\n\t\t ioc->sas_hba.num_phys);\n\n\tif (ioc->sas_hba.enclosure_handle) {\n\t\tif (!(mpt3sas_config_get_enclosure_pg0(ioc, &mpi_reply,\n\t\t    &enclosure_pg0, MPI2_SAS_ENCLOS_PGAD_FORM_HANDLE,\n\t\t   ioc->sas_hba.enclosure_handle)))\n\t\t\tioc->sas_hba.enclosure_logical_id =\n\t\t\t    le64_to_cpu(enclosure_pg0.EnclosureLogicalID);\n\t}\n\n out:\n\tkfree(sas_iounit_pg1);\n\tkfree(sas_iounit_pg0);\n}\n\n/**\n * _scsih_expander_add -  creating expander object\n * @ioc: per adapter object\n * @handle: expander handle\n *\n * Creating expander object, stored in ioc->sas_expander_list.\n *\n * Return: 0 for success, else error.\n */\nstatic int\n_scsih_expander_add(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _sas_node *sas_expander;\n\tstruct _enclosure_node *enclosure_dev;\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2ExpanderPage0_t expander_pg0;\n\tMpi2ExpanderPage1_t expander_pg1;\n\tu32 ioc_status;\n\tu16 parent_handle;\n\tu64 sas_address, sas_address_parent = 0;\n\tint i;\n\tunsigned long flags;\n\tstruct _sas_port *mpt3sas_port = NULL;\n\tu8 port_id;\n\n\tint rc = 0;\n\n\tif (!handle)\n\t\treturn -1;\n\n\tif (ioc->shost_recovery || ioc->pci_error_recovery)\n\t\treturn -1;\n\n\tif ((mpt3sas_config_get_expander_pg0(ioc, &mpi_reply, &expander_pg0,\n\t    MPI2_SAS_EXPAND_PGAD_FORM_HNDL, handle))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\n\t/* handle out of order topology events */\n\tparent_handle = le16_to_cpu(expander_pg0.ParentDevHandle);\n\tif (_scsih_get_sas_address(ioc, parent_handle, &sas_address_parent)\n\t    != 0) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\n\tport_id = expander_pg0.PhysicalPort;\n\tif (sas_address_parent != ioc->sas_hba.sas_address) {\n\t\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\t\tsas_expander = mpt3sas_scsih_expander_find_by_sas_address(ioc,\n\t\t    sas_address_parent,\n\t\t    mpt3sas_get_port_by_id(ioc, port_id, 0));\n\t\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\t\tif (!sas_expander) {\n\t\t\trc = _scsih_expander_add(ioc, parent_handle);\n\t\t\tif (rc != 0)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tsas_address = le64_to_cpu(expander_pg0.SASAddress);\n\tsas_expander = mpt3sas_scsih_expander_find_by_sas_address(ioc,\n\t    sas_address, mpt3sas_get_port_by_id(ioc, port_id, 0));\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\n\tif (sas_expander)\n\t\treturn 0;\n\n\tsas_expander = kzalloc(sizeof(struct _sas_node),\n\t    GFP_KERNEL);\n\tif (!sas_expander) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\n\tsas_expander->handle = handle;\n\tsas_expander->num_phys = expander_pg0.NumPhys;\n\tsas_expander->sas_address_parent = sas_address_parent;\n\tsas_expander->sas_address = sas_address;\n\tsas_expander->port = mpt3sas_get_port_by_id(ioc, port_id, 0);\n\tif (!sas_expander->port) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\trc = -1;\n\t\tgoto out_fail;\n\t}\n\n\tioc_info(ioc, \"expander_add: handle(0x%04x), parent(0x%04x), sas_addr(0x%016llx), phys(%d)\\n\",\n\t\t handle, parent_handle,\n\t\t (u64)sas_expander->sas_address, sas_expander->num_phys);\n\n\tif (!sas_expander->num_phys)\n\t\tgoto out_fail;\n\tsas_expander->phy = kcalloc(sas_expander->num_phys,\n\t    sizeof(struct _sas_phy), GFP_KERNEL);\n\tif (!sas_expander->phy) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trc = -1;\n\t\tgoto out_fail;\n\t}\n\n\tINIT_LIST_HEAD(&sas_expander->sas_port_list);\n\tmpt3sas_port = mpt3sas_transport_port_add(ioc, handle,\n\t    sas_address_parent, sas_expander->port);\n\tif (!mpt3sas_port) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trc = -1;\n\t\tgoto out_fail;\n\t}\n\tsas_expander->parent_dev = &mpt3sas_port->rphy->dev;\n\tsas_expander->rphy = mpt3sas_port->rphy;\n\n\tfor (i = 0 ; i < sas_expander->num_phys ; i++) {\n\t\tif ((mpt3sas_config_get_expander_pg1(ioc, &mpi_reply,\n\t\t    &expander_pg1, i, handle))) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\trc = -1;\n\t\t\tgoto out_fail;\n\t\t}\n\t\tsas_expander->phy[i].handle = handle;\n\t\tsas_expander->phy[i].phy_id = i;\n\t\tsas_expander->phy[i].port =\n\t\t    mpt3sas_get_port_by_id(ioc, port_id, 0);\n\n\t\tif ((mpt3sas_transport_add_expander_phy(ioc,\n\t\t    &sas_expander->phy[i], expander_pg1,\n\t\t    sas_expander->parent_dev))) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\trc = -1;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tif (sas_expander->enclosure_handle) {\n\t\tenclosure_dev =\n\t\t\tmpt3sas_scsih_enclosure_find_by_handle(ioc,\n\t\t\t\t\t\tsas_expander->enclosure_handle);\n\t\tif (enclosure_dev)\n\t\t\tsas_expander->enclosure_logical_id =\n\t\t\t    le64_to_cpu(enclosure_dev->pg0.EnclosureLogicalID);\n\t}\n\n\t_scsih_expander_node_add(ioc, sas_expander);\n\treturn 0;\n\n out_fail:\n\n\tif (mpt3sas_port)\n\t\tmpt3sas_transport_port_remove(ioc, sas_expander->sas_address,\n\t\t    sas_address_parent, sas_expander->port);\n\tkfree(sas_expander);\n\treturn rc;\n}\n\n/**\n * mpt3sas_expander_remove - removing expander object\n * @ioc: per adapter object\n * @sas_address: expander sas_address\n */\nvoid\nmpt3sas_expander_remove(struct MPT3SAS_ADAPTER *ioc, u64 sas_address,\n\tstruct hba_port *port)\n{\n\tstruct _sas_node *sas_expander;\n\tunsigned long flags;\n\n\tif (ioc->shost_recovery)\n\t\treturn;\n\n\tif (!port)\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tsas_expander = mpt3sas_scsih_expander_find_by_sas_address(ioc,\n\t    sas_address, port);\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\tif (sas_expander)\n\t\t_scsih_expander_node_remove(ioc, sas_expander);\n}\n\n/**\n * _scsih_done -  internal SCSI_IO callback handler.\n * @ioc: per adapter object\n * @smid: system request message index\n * @msix_index: MSIX table index supplied by the OS\n * @reply: reply message frame(lower 32bit addr)\n *\n * Callback handler when sending internal generated SCSI_IO.\n * The callback index passed is `ioc->scsih_cb_idx`\n *\n * Return: 1 meaning mf should be freed from _base_interrupt\n *         0 means the mf is freed from this function.\n */\nstatic u8\n_scsih_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)\n{\n\tMPI2DefaultReply_t *mpi_reply;\n\n\tmpi_reply =  mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\tif (ioc->scsih_cmds.status == MPT3_CMD_NOT_USED)\n\t\treturn 1;\n\tif (ioc->scsih_cmds.smid != smid)\n\t\treturn 1;\n\tioc->scsih_cmds.status |= MPT3_CMD_COMPLETE;\n\tif (mpi_reply) {\n\t\tmemcpy(ioc->scsih_cmds.reply, mpi_reply,\n\t\t    mpi_reply->MsgLength*4);\n\t\tioc->scsih_cmds.status |= MPT3_CMD_REPLY_VALID;\n\t}\n\tioc->scsih_cmds.status &= ~MPT3_CMD_PENDING;\n\tcomplete(&ioc->scsih_cmds.done);\n\treturn 1;\n}\n\n\n\n\n#define MPT3_MAX_LUNS (255)\n\n\n/**\n * _scsih_check_access_status - check access flags\n * @ioc: per adapter object\n * @sas_address: sas address\n * @handle: sas device handle\n * @access_status: errors returned during discovery of the device\n *\n * Return: 0 for success, else failure\n */\nstatic u8\n_scsih_check_access_status(struct MPT3SAS_ADAPTER *ioc, u64 sas_address,\n\tu16 handle, u8 access_status)\n{\n\tu8 rc = 1;\n\tchar *desc = NULL;\n\n\tswitch (access_status) {\n\tcase MPI2_SAS_DEVICE0_ASTATUS_NO_ERRORS:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SATA_NEEDS_INITIALIZATION:\n\t\trc = 0;\n\t\tbreak;\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SATA_CAPABILITY_FAILED:\n\t\tdesc = \"sata capability failed\";\n\t\tbreak;\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SATA_AFFILIATION_CONFLICT:\n\t\tdesc = \"sata affiliation conflict\";\n\t\tbreak;\n\tcase MPI2_SAS_DEVICE0_ASTATUS_ROUTE_NOT_ADDRESSABLE:\n\t\tdesc = \"route not addressable\";\n\t\tbreak;\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SMP_ERROR_NOT_ADDRESSABLE:\n\t\tdesc = \"smp error not addressable\";\n\t\tbreak;\n\tcase MPI2_SAS_DEVICE0_ASTATUS_DEVICE_BLOCKED:\n\t\tdesc = \"device blocked\";\n\t\tbreak;\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SATA_INIT_FAILED:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_UNKNOWN:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_AFFILIATION_CONFLICT:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_DIAG:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_IDENTIFICATION:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_CHECK_POWER:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_PIO_SN:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_MDMA_SN:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_UDMA_SN:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_ZONING_VIOLATION:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_NOT_ADDRESSABLE:\n\tcase MPI2_SAS_DEVICE0_ASTATUS_SIF_MAX:\n\t\tdesc = \"sata initialization failed\";\n\t\tbreak;\n\tdefault:\n\t\tdesc = \"unknown\";\n\t\tbreak;\n\t}\n\n\tif (!rc)\n\t\treturn 0;\n\n\tioc_err(ioc, \"discovery errors(%s): sas_address(0x%016llx), handle(0x%04x)\\n\",\n\t\tdesc, (u64)sas_address, handle);\n\treturn rc;\n}\n\n/**\n * _scsih_check_device - checking device responsiveness\n * @ioc: per adapter object\n * @parent_sas_address: sas address of parent expander or sas host\n * @handle: attached device handle\n * @phy_number: phy number\n * @link_rate: new link rate\n */\nstatic void\n_scsih_check_device(struct MPT3SAS_ADAPTER *ioc,\n\tu64 parent_sas_address, u16 handle, u8 phy_number, u8 link_rate)\n{\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tstruct _sas_device *sas_device = NULL;\n\tstruct _enclosure_node *enclosure_dev = NULL;\n\tu32 ioc_status;\n\tunsigned long flags;\n\tu64 sas_address;\n\tstruct scsi_target *starget;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tu32 device_info;\n\tstruct hba_port *port;\n\n\tif ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\n\t    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle)))\n\t\treturn;\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\treturn;\n\n\t/* wide port handling ~ we need only handle device once for the phy that\n\t * is matched in sas device page zero\n\t */\n\tif (phy_number != sas_device_pg0.PhyNum)\n\t\treturn;\n\n\t/* check if this is end device */\n\tdevice_info = le32_to_cpu(sas_device_pg0.DeviceInfo);\n\tif (!(_scsih_is_end_device(device_info)))\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_address = le64_to_cpu(sas_device_pg0.SASAddress);\n\tport = mpt3sas_get_port_by_id(ioc, sas_device_pg0.PhysicalPort, 0);\n\tif (!port)\n\t\tgoto out_unlock;\n\tsas_device = __mpt3sas_get_sdev_by_addr(ioc,\n\t    sas_address, port);\n\n\tif (!sas_device)\n\t\tgoto out_unlock;\n\n\tif (unlikely(sas_device->handle != handle)) {\n\t\tstarget = sas_device->starget;\n\t\tsas_target_priv_data = starget->hostdata;\n\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\"handle changed from(0x%04x) to (0x%04x)!!!\\n\",\n\t\t\tsas_device->handle, handle);\n\t\tsas_target_priv_data->handle = handle;\n\t\tsas_device->handle = handle;\n\t\tif (le16_to_cpu(sas_device_pg0.Flags) &\n\t\t     MPI2_SAS_DEVICE0_FLAGS_ENCL_LEVEL_VALID) {\n\t\t\tsas_device->enclosure_level =\n\t\t\t\tsas_device_pg0.EnclosureLevel;\n\t\t\tmemcpy(sas_device->connector_name,\n\t\t\t\tsas_device_pg0.ConnectorName, 4);\n\t\t\tsas_device->connector_name[4] = '\\0';\n\t\t} else {\n\t\t\tsas_device->enclosure_level = 0;\n\t\t\tsas_device->connector_name[0] = '\\0';\n\t\t}\n\n\t\tsas_device->enclosure_handle =\n\t\t\t\tle16_to_cpu(sas_device_pg0.EnclosureHandle);\n\t\tsas_device->is_chassis_slot_valid = 0;\n\t\tenclosure_dev = mpt3sas_scsih_enclosure_find_by_handle(ioc,\n\t\t\t\t\t\tsas_device->enclosure_handle);\n\t\tif (enclosure_dev) {\n\t\t\tsas_device->enclosure_logical_id =\n\t\t\t    le64_to_cpu(enclosure_dev->pg0.EnclosureLogicalID);\n\t\t\tif (le16_to_cpu(enclosure_dev->pg0.Flags) &\n\t\t\t    MPI2_SAS_ENCLS0_FLAGS_CHASSIS_SLOT_VALID) {\n\t\t\t\tsas_device->is_chassis_slot_valid = 1;\n\t\t\t\tsas_device->chassis_slot =\n\t\t\t\t\tenclosure_dev->pg0.ChassisSlot;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check if device is present */\n\tif (!(le16_to_cpu(sas_device_pg0.Flags) &\n\t    MPI2_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)) {\n\t\tioc_err(ioc, \"device is not present handle(0x%04x), flags!!!\\n\",\n\t\t\thandle);\n\t\tgoto out_unlock;\n\t}\n\n\t/* check if there were any issues with discovery */\n\tif (_scsih_check_access_status(ioc, sas_address, handle,\n\t    sas_device_pg0.AccessStatus))\n\t\tgoto out_unlock;\n\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\t_scsih_ublock_io_device(ioc, sas_address, port);\n\n\tif (sas_device)\n\t\tsas_device_put(sas_device);\n\treturn;\n\nout_unlock:\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\tif (sas_device)\n\t\tsas_device_put(sas_device);\n}\n\n/**\n * _scsih_add_device -  creating sas device object\n * @ioc: per adapter object\n * @handle: sas device handle\n * @phy_num: phy number end device attached to\n * @is_pd: is this hidden raid component\n *\n * Creating end device object, stored in ioc->sas_device_list.\n *\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_scsih_add_device(struct MPT3SAS_ADAPTER *ioc, u16 handle, u8 phy_num,\n\tu8 is_pd)\n{\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tstruct _sas_device *sas_device;\n\tstruct _enclosure_node *enclosure_dev = NULL;\n\tu32 ioc_status;\n\tu64 sas_address;\n\tu32 device_info;\n\tu8 port_id;\n\n\tif ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\n\t    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -1;\n\t}\n\n\t/* check if this is end device */\n\tdevice_info = le32_to_cpu(sas_device_pg0.DeviceInfo);\n\tif (!(_scsih_is_end_device(device_info)))\n\t\treturn -1;\n\tset_bit(handle, ioc->pend_os_device_add);\n\tsas_address = le64_to_cpu(sas_device_pg0.SASAddress);\n\n\t/* check if device is present */\n\tif (!(le16_to_cpu(sas_device_pg0.Flags) &\n\t    MPI2_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)) {\n\t\tioc_err(ioc, \"device is not present handle(0x04%x)!!!\\n\",\n\t\t\thandle);\n\t\treturn -1;\n\t}\n\n\t/* check if there were any issues with discovery */\n\tif (_scsih_check_access_status(ioc, sas_address, handle,\n\t    sas_device_pg0.AccessStatus))\n\t\treturn -1;\n\n\tport_id = sas_device_pg0.PhysicalPort;\n\tsas_device = mpt3sas_get_sdev_by_addr(ioc,\n\t    sas_address, mpt3sas_get_port_by_id(ioc, port_id, 0));\n\tif (sas_device) {\n\t\tclear_bit(handle, ioc->pend_os_device_add);\n\t\tsas_device_put(sas_device);\n\t\treturn -1;\n\t}\n\n\tif (sas_device_pg0.EnclosureHandle) {\n\t\tenclosure_dev =\n\t\t\tmpt3sas_scsih_enclosure_find_by_handle(ioc,\n\t\t\t    le16_to_cpu(sas_device_pg0.EnclosureHandle));\n\t\tif (enclosure_dev == NULL)\n\t\t\tioc_info(ioc, \"Enclosure handle(0x%04x) doesn't match with enclosure device!\\n\",\n\t\t\t\t sas_device_pg0.EnclosureHandle);\n\t}\n\n\tsas_device = kzalloc(sizeof(struct _sas_device),\n\t    GFP_KERNEL);\n\tif (!sas_device) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn 0;\n\t}\n\n\tkref_init(&sas_device->refcount);\n\tsas_device->handle = handle;\n\tif (_scsih_get_sas_address(ioc,\n\t    le16_to_cpu(sas_device_pg0.ParentDevHandle),\n\t    &sas_device->sas_address_parent) != 0)\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\tsas_device->enclosure_handle =\n\t    le16_to_cpu(sas_device_pg0.EnclosureHandle);\n\tif (sas_device->enclosure_handle != 0)\n\t\tsas_device->slot =\n\t\t    le16_to_cpu(sas_device_pg0.Slot);\n\tsas_device->device_info = device_info;\n\tsas_device->sas_address = sas_address;\n\tsas_device->phy = sas_device_pg0.PhyNum;\n\tsas_device->fast_path = (le16_to_cpu(sas_device_pg0.Flags) &\n\t    MPI25_SAS_DEVICE0_FLAGS_FAST_PATH_CAPABLE) ? 1 : 0;\n\tsas_device->port = mpt3sas_get_port_by_id(ioc, port_id, 0);\n\tif (!sas_device->port) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t    __FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(sas_device_pg0.Flags)\n\t\t& MPI2_SAS_DEVICE0_FLAGS_ENCL_LEVEL_VALID) {\n\t\tsas_device->enclosure_level =\n\t\t\tsas_device_pg0.EnclosureLevel;\n\t\tmemcpy(sas_device->connector_name,\n\t\t\tsas_device_pg0.ConnectorName, 4);\n\t\tsas_device->connector_name[4] = '\\0';\n\t} else {\n\t\tsas_device->enclosure_level = 0;\n\t\tsas_device->connector_name[0] = '\\0';\n\t}\n\t/* get enclosure_logical_id & chassis_slot*/\n\tsas_device->is_chassis_slot_valid = 0;\n\tif (enclosure_dev) {\n\t\tsas_device->enclosure_logical_id =\n\t\t    le64_to_cpu(enclosure_dev->pg0.EnclosureLogicalID);\n\t\tif (le16_to_cpu(enclosure_dev->pg0.Flags) &\n\t\t    MPI2_SAS_ENCLS0_FLAGS_CHASSIS_SLOT_VALID) {\n\t\t\tsas_device->is_chassis_slot_valid = 1;\n\t\t\tsas_device->chassis_slot =\n\t\t\t\t\tenclosure_dev->pg0.ChassisSlot;\n\t\t}\n\t}\n\n\t/* get device name */\n\tsas_device->device_name = le64_to_cpu(sas_device_pg0.DeviceName);\n\n\tif (ioc->wait_for_discovery_to_complete)\n\t\t_scsih_sas_device_init_add(ioc, sas_device);\n\telse\n\t\t_scsih_sas_device_add(ioc, sas_device);\n\nout:\n\tsas_device_put(sas_device);\n\treturn 0;\n}\n\n/**\n * _scsih_remove_device -  removing sas device object\n * @ioc: per adapter object\n * @sas_device: the sas_device object\n */\nstatic void\n_scsih_remove_device(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_device *sas_device)\n{\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\n\tif ((ioc->pdev->subsystem_vendor == PCI_VENDOR_ID_IBM) &&\n\t     (sas_device->pfa_led_on)) {\n\t\t_scsih_turn_off_pfa_led(ioc, sas_device);\n\t\tsas_device->pfa_led_on = 0;\n\t}\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: enter: handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t    __func__,\n\t\t\t    sas_device->handle, (u64)sas_device->sas_address));\n\n\tdewtprintk(ioc, _scsih_display_enclosure_chassis_info(ioc, sas_device,\n\t    NULL, NULL));\n\n\tif (sas_device->starget && sas_device->starget->hostdata) {\n\t\tsas_target_priv_data = sas_device->starget->hostdata;\n\t\tsas_target_priv_data->deleted = 1;\n\t\t_scsih_ublock_io_device(ioc, sas_device->sas_address,\n\t\t    sas_device->port);\n\t\tsas_target_priv_data->handle =\n\t\t     MPT3SAS_INVALID_DEVICE_HANDLE;\n\t}\n\n\tif (!ioc->hide_drives)\n\t\tmpt3sas_transport_port_remove(ioc,\n\t\t    sas_device->sas_address,\n\t\t    sas_device->sas_address_parent,\n\t\t    sas_device->port);\n\n\tioc_info(ioc, \"removing handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t sas_device->handle, (u64)sas_device->sas_address);\n\n\t_scsih_display_enclosure_chassis_info(ioc, sas_device, NULL, NULL);\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: exit: handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t    __func__,\n\t\t\t    sas_device->handle, (u64)sas_device->sas_address));\n\tdewtprintk(ioc, _scsih_display_enclosure_chassis_info(ioc, sas_device,\n\t    NULL, NULL));\n}\n\n/**\n * _scsih_sas_topology_change_event_debug - debug for topology event\n * @ioc: per adapter object\n * @event_data: event data payload\n * Context: user.\n */\nstatic void\n_scsih_sas_topology_change_event_debug(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataSasTopologyChangeList_t *event_data)\n{\n\tint i;\n\tu16 handle;\n\tu16 reason_code;\n\tu8 phy_number;\n\tchar *status_str = NULL;\n\tu8 link_rate, prev_link_rate;\n\n\tswitch (event_data->ExpStatus) {\n\tcase MPI2_EVENT_SAS_TOPO_ES_ADDED:\n\t\tstatus_str = \"add\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_TOPO_ES_NOT_RESPONDING:\n\t\tstatus_str = \"remove\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_TOPO_ES_RESPONDING:\n\tcase 0:\n\t\tstatus_str =  \"responding\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_TOPO_ES_DELAY_NOT_RESPONDING:\n\t\tstatus_str = \"remove delay\";\n\t\tbreak;\n\tdefault:\n\t\tstatus_str = \"unknown status\";\n\t\tbreak;\n\t}\n\tioc_info(ioc, \"sas topology change: (%s)\\n\", status_str);\n\tpr_info(\"\\thandle(0x%04x), enclosure_handle(0x%04x) \" \\\n\t    \"start_phy(%02d), count(%d)\\n\",\n\t    le16_to_cpu(event_data->ExpanderDevHandle),\n\t    le16_to_cpu(event_data->EnclosureHandle),\n\t    event_data->StartPhyNum, event_data->NumEntries);\n\tfor (i = 0; i < event_data->NumEntries; i++) {\n\t\thandle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\tphy_number = event_data->StartPhyNum + i;\n\t\treason_code = event_data->PHY[i].PhyStatus &\n\t\t    MPI2_EVENT_SAS_TOPO_RC_MASK;\n\t\tswitch (reason_code) {\n\t\tcase MPI2_EVENT_SAS_TOPO_RC_TARG_ADDED:\n\t\t\tstatus_str = \"target add\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING:\n\t\t\tstatus_str = \"target remove\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_SAS_TOPO_RC_DELAY_NOT_RESPONDING:\n\t\t\tstatus_str = \"delay target remove\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_SAS_TOPO_RC_PHY_CHANGED:\n\t\t\tstatus_str = \"link rate change\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_SAS_TOPO_RC_NO_CHANGE:\n\t\t\tstatus_str = \"target responding\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus_str = \"unknown\";\n\t\t\tbreak;\n\t\t}\n\t\tlink_rate = event_data->PHY[i].LinkRate >> 4;\n\t\tprev_link_rate = event_data->PHY[i].LinkRate & 0xF;\n\t\tpr_info(\"\\tphy(%02d), attached_handle(0x%04x): %s:\" \\\n\t\t    \" link rate: new(0x%02x), old(0x%02x)\\n\", phy_number,\n\t\t    handle, status_str, link_rate, prev_link_rate);\n\n\t}\n}\n\n/**\n * _scsih_sas_topology_change_event - handle topology changes\n * @ioc: per adapter object\n * @fw_event: The fw_event_work object\n * Context: user.\n *\n */\nstatic int\n_scsih_sas_topology_change_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tint i;\n\tu16 parent_handle, handle;\n\tu16 reason_code;\n\tu8 phy_number, max_phys;\n\tstruct _sas_node *sas_expander;\n\tu64 sas_address;\n\tunsigned long flags;\n\tu8 link_rate, prev_link_rate;\n\tstruct hba_port *port;\n\tMpi2EventDataSasTopologyChangeList_t *event_data =\n\t\t(Mpi2EventDataSasTopologyChangeList_t *)\n\t\tfw_event->event_data;\n\n\tif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)\n\t\t_scsih_sas_topology_change_event_debug(ioc, event_data);\n\n\tif (ioc->shost_recovery || ioc->remove_host || ioc->pci_error_recovery)\n\t\treturn 0;\n\n\tif (!ioc->sas_hba.num_phys)\n\t\t_scsih_sas_host_add(ioc);\n\telse\n\t\t_scsih_sas_host_refresh(ioc);\n\n\tif (fw_event->ignore) {\n\t\tdewtprintk(ioc, ioc_info(ioc, \"ignoring expander event\\n\"));\n\t\treturn 0;\n\t}\n\n\tparent_handle = le16_to_cpu(event_data->ExpanderDevHandle);\n\tport = mpt3sas_get_port_by_id(ioc, event_data->PhysicalPort, 0);\n\n\t/* handle expander add */\n\tif (event_data->ExpStatus == MPI2_EVENT_SAS_TOPO_ES_ADDED)\n\t\tif (_scsih_expander_add(ioc, parent_handle) != 0)\n\t\t\treturn 0;\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tsas_expander = mpt3sas_scsih_expander_find_by_handle(ioc,\n\t    parent_handle);\n\tif (sas_expander) {\n\t\tsas_address = sas_expander->sas_address;\n\t\tmax_phys = sas_expander->num_phys;\n\t\tport = sas_expander->port;\n\t} else if (parent_handle < ioc->sas_hba.num_phys) {\n\t\tsas_address = ioc->sas_hba.sas_address;\n\t\tmax_phys = ioc->sas_hba.num_phys;\n\t} else {\n\t\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\n\t/* handle siblings events */\n\tfor (i = 0; i < event_data->NumEntries; i++) {\n\t\tif (fw_event->ignore) {\n\t\t\tdewtprintk(ioc,\n\t\t\t\t   ioc_info(ioc, \"ignoring expander event\\n\"));\n\t\t\treturn 0;\n\t\t}\n\t\tif (ioc->remove_host || ioc->pci_error_recovery)\n\t\t\treturn 0;\n\t\tphy_number = event_data->StartPhyNum + i;\n\t\tif (phy_number >= max_phys)\n\t\t\tcontinue;\n\t\treason_code = event_data->PHY[i].PhyStatus &\n\t\t    MPI2_EVENT_SAS_TOPO_RC_MASK;\n\t\tif ((event_data->PHY[i].PhyStatus &\n\t\t    MPI2_EVENT_SAS_TOPO_PHYSTATUS_VACANT) && (reason_code !=\n\t\t    MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING))\n\t\t\t\tcontinue;\n\t\thandle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\tlink_rate = event_data->PHY[i].LinkRate >> 4;\n\t\tprev_link_rate = event_data->PHY[i].LinkRate & 0xF;\n\t\tswitch (reason_code) {\n\t\tcase MPI2_EVENT_SAS_TOPO_RC_PHY_CHANGED:\n\n\t\t\tif (ioc->shost_recovery)\n\t\t\t\tbreak;\n\n\t\t\tif (link_rate == prev_link_rate)\n\t\t\t\tbreak;\n\n\t\t\tmpt3sas_transport_update_links(ioc, sas_address,\n\t\t\t    handle, phy_number, link_rate, port);\n\n\t\t\tif (link_rate < MPI2_SAS_NEG_LINK_RATE_1_5)\n\t\t\t\tbreak;\n\n\t\t\t_scsih_check_device(ioc, sas_address, handle,\n\t\t\t    phy_number, link_rate);\n\n\t\t\tif (!test_bit(handle, ioc->pend_os_device_add))\n\t\t\t\tbreak;\n\n\t\t\tfallthrough;\n\n\t\tcase MPI2_EVENT_SAS_TOPO_RC_TARG_ADDED:\n\n\t\t\tif (ioc->shost_recovery)\n\t\t\t\tbreak;\n\n\t\t\tmpt3sas_transport_update_links(ioc, sas_address,\n\t\t\t    handle, phy_number, link_rate, port);\n\n\t\t\t_scsih_add_device(ioc, handle, phy_number, 0);\n\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_SAS_TOPO_RC_TARG_NOT_RESPONDING:\n\n\t\t\t_scsih_device_remove_by_handle(ioc, handle);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* handle expander removal */\n\tif (event_data->ExpStatus == MPI2_EVENT_SAS_TOPO_ES_NOT_RESPONDING &&\n\t    sas_expander)\n\t\tmpt3sas_expander_remove(ioc, sas_address, port);\n\n\treturn 0;\n}\n\n/**\n * _scsih_sas_device_status_change_event_debug - debug for device event\n * @ioc: ?\n * @event_data: event data payload\n * Context: user.\n */\nstatic void\n_scsih_sas_device_status_change_event_debug(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataSasDeviceStatusChange_t *event_data)\n{\n\tchar *reason_str = NULL;\n\n\tswitch (event_data->ReasonCode) {\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_SMART_DATA:\n\t\treason_str = \"smart data\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_UNSUPPORTED:\n\t\treason_str = \"unsupported device discovered\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET:\n\t\treason_str = \"internal device reset\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_TASK_ABORT_INTERNAL:\n\t\treason_str = \"internal task abort\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_ABORT_TASK_SET_INTERNAL:\n\t\treason_str = \"internal task abort set\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_CLEAR_TASK_SET_INTERNAL:\n\t\treason_str = \"internal clear task set\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_QUERY_TASK_INTERNAL:\n\t\treason_str = \"internal query task\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_SATA_INIT_FAILURE:\n\t\treason_str = \"sata init failure\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_CMP_INTERNAL_DEV_RESET:\n\t\treason_str = \"internal device reset complete\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_CMP_TASK_ABORT_INTERNAL:\n\t\treason_str = \"internal task abort complete\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_ASYNC_NOTIFICATION:\n\t\treason_str = \"internal async notification\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_EXPANDER_REDUCED_FUNCTIONALITY:\n\t\treason_str = \"expander reduced functionality\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEV_STAT_RC_CMP_EXPANDER_REDUCED_FUNCTIONALITY:\n\t\treason_str = \"expander reduced functionality complete\";\n\t\tbreak;\n\tdefault:\n\t\treason_str = \"unknown reason\";\n\t\tbreak;\n\t}\n\tioc_info(ioc, \"device status change: (%s)\\thandle(0x%04x), sas address(0x%016llx), tag(%d)\",\n\t\t reason_str, le16_to_cpu(event_data->DevHandle),\n\t\t (u64)le64_to_cpu(event_data->SASAddress),\n\t\t le16_to_cpu(event_data->TaskTag));\n\tif (event_data->ReasonCode == MPI2_EVENT_SAS_DEV_STAT_RC_SMART_DATA)\n\t\tpr_cont(\", ASC(0x%x), ASCQ(0x%x)\\n\",\n\t\t\tevent_data->ASC, event_data->ASCQ);\n\tpr_cont(\"\\n\");\n}\n\n/**\n * _scsih_sas_device_status_change_event - handle device status change\n * @ioc: per adapter object\n * @event_data: The fw event\n * Context: user.\n */\nstatic void\n_scsih_sas_device_status_change_event(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataSasDeviceStatusChange_t *event_data)\n{\n\tstruct MPT3SAS_TARGET *target_priv_data;\n\tstruct _sas_device *sas_device;\n\tu64 sas_address;\n\tunsigned long flags;\n\n\t/* In MPI Revision K (0xC), the internal device reset complete was\n\t * implemented, so avoid setting tm_busy flag for older firmware.\n\t */\n\tif ((ioc->facts.HeaderVersion >> 8) < 0xC)\n\t\treturn;\n\n\tif (event_data->ReasonCode !=\n\t    MPI2_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET &&\n\t   event_data->ReasonCode !=\n\t    MPI2_EVENT_SAS_DEV_STAT_RC_CMP_INTERNAL_DEV_RESET)\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_address = le64_to_cpu(event_data->SASAddress);\n\tsas_device = __mpt3sas_get_sdev_by_addr(ioc,\n\t    sas_address,\n\t    mpt3sas_get_port_by_id(ioc, event_data->PhysicalPort, 0));\n\n\tif (!sas_device || !sas_device->starget)\n\t\tgoto out;\n\n\ttarget_priv_data = sas_device->starget->hostdata;\n\tif (!target_priv_data)\n\t\tgoto out;\n\n\tif (event_data->ReasonCode ==\n\t    MPI2_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET)\n\t\ttarget_priv_data->tm_busy = 1;\n\telse\n\t\ttarget_priv_data->tm_busy = 0;\n\n\tif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)\n\t\tioc_info(ioc,\n\t\t    \"%s tm_busy flag for handle(0x%04x)\\n\",\n\t\t    (target_priv_data->tm_busy == 1) ? \"Enable\" : \"Disable\",\n\t\t    target_priv_data->handle);\n\nout:\n\tif (sas_device)\n\t\tsas_device_put(sas_device);\n\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n}\n\n\n/**\n * _scsih_check_pcie_access_status - check access flags\n * @ioc: per adapter object\n * @wwid: wwid\n * @handle: sas device handle\n * @access_status: errors returned during discovery of the device\n *\n * Return: 0 for success, else failure\n */\nstatic u8\n_scsih_check_pcie_access_status(struct MPT3SAS_ADAPTER *ioc, u64 wwid,\n\tu16 handle, u8 access_status)\n{\n\tu8 rc = 1;\n\tchar *desc = NULL;\n\n\tswitch (access_status) {\n\tcase MPI26_PCIEDEV0_ASTATUS_NO_ERRORS:\n\tcase MPI26_PCIEDEV0_ASTATUS_NEEDS_INITIALIZATION:\n\t\trc = 0;\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_CAPABILITY_FAILED:\n\t\tdesc = \"PCIe device capability failed\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_DEVICE_BLOCKED:\n\t\tdesc = \"PCIe device blocked\";\n\t\tioc_info(ioc,\n\t\t    \"Device with Access Status (%s): wwid(0x%016llx), \"\n\t\t    \"handle(0x%04x)\\n ll only be added to the internal list\",\n\t\t    desc, (u64)wwid, handle);\n\t\trc = 0;\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_MEMORY_SPACE_ACCESS_FAILED:\n\t\tdesc = \"PCIe device mem space access failed\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_UNSUPPORTED_DEVICE:\n\t\tdesc = \"PCIe device unsupported\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_MSIX_REQUIRED:\n\t\tdesc = \"PCIe device MSIx Required\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_INIT_FAIL_MAX:\n\t\tdesc = \"PCIe device init fail max\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_UNKNOWN:\n\t\tdesc = \"PCIe device status unknown\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_READY_TIMEOUT:\n\t\tdesc = \"nvme ready timeout\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_DEVCFG_UNSUPPORTED:\n\t\tdesc = \"nvme device configuration unsupported\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_IDENTIFY_FAILED:\n\t\tdesc = \"nvme identify failed\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_QCONFIG_FAILED:\n\t\tdesc = \"nvme qconfig failed\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_QCREATION_FAILED:\n\t\tdesc = \"nvme qcreation failed\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_EVENTCFG_FAILED:\n\t\tdesc = \"nvme eventcfg failed\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_GET_FEATURE_STAT_FAILED:\n\t\tdesc = \"nvme get feature stat failed\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_IDLE_TIMEOUT:\n\t\tdesc = \"nvme idle timeout\";\n\t\tbreak;\n\tcase MPI26_PCIEDEV0_ASTATUS_NVME_FAILURE_STATUS:\n\t\tdesc = \"nvme failure status\";\n\t\tbreak;\n\tdefault:\n\t\tioc_err(ioc, \"NVMe discovery error(0x%02x): wwid(0x%016llx), handle(0x%04x)\\n\",\n\t\t\taccess_status, (u64)wwid, handle);\n\t\treturn rc;\n\t}\n\n\tif (!rc)\n\t\treturn rc;\n\n\tioc_info(ioc, \"NVMe discovery error(%s): wwid(0x%016llx), handle(0x%04x)\\n\",\n\t\t desc, (u64)wwid, handle);\n\treturn rc;\n}\n\n/**\n * _scsih_pcie_device_remove_from_sml -  removing pcie device\n * from SML and free up associated memory\n * @ioc: per adapter object\n * @pcie_device: the pcie_device object\n */\nstatic void\n_scsih_pcie_device_remove_from_sml(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _pcie_device *pcie_device)\n{\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: enter: handle(0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t    __func__,\n\t\t\t    pcie_device->handle, (u64)pcie_device->wwid));\n\tif (pcie_device->enclosure_handle != 0)\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: enter: enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t    __func__,\n\t\t\t\t    (u64)pcie_device->enclosure_logical_id,\n\t\t\t\t    pcie_device->slot));\n\tif (pcie_device->connector_name[0] != '\\0')\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: enter: enclosure level(0x%04x), connector name(%s)\\n\",\n\t\t\t\t    __func__,\n\t\t\t\t    pcie_device->enclosure_level,\n\t\t\t\t    pcie_device->connector_name));\n\n\tif (pcie_device->starget && pcie_device->starget->hostdata) {\n\t\tsas_target_priv_data = pcie_device->starget->hostdata;\n\t\tsas_target_priv_data->deleted = 1;\n\t\t_scsih_ublock_io_device(ioc, pcie_device->wwid, NULL);\n\t\tsas_target_priv_data->handle = MPT3SAS_INVALID_DEVICE_HANDLE;\n\t}\n\n\tioc_info(ioc, \"removing handle(0x%04x), wwid(0x%016llx)\\n\",\n\t\t pcie_device->handle, (u64)pcie_device->wwid);\n\tif (pcie_device->enclosure_handle != 0)\n\t\tioc_info(ioc, \"removing : enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t (u64)pcie_device->enclosure_logical_id,\n\t\t\t pcie_device->slot);\n\tif (pcie_device->connector_name[0] != '\\0')\n\t\tioc_info(ioc, \"removing: enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t pcie_device->enclosure_level,\n\t\t\t pcie_device->connector_name);\n\n\tif (pcie_device->starget && (pcie_device->access_status !=\n\t\t\t\tMPI26_PCIEDEV0_ASTATUS_DEVICE_BLOCKED))\n\t\tscsi_remove_target(&pcie_device->starget->dev);\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s: exit: handle(0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t    __func__,\n\t\t\t    pcie_device->handle, (u64)pcie_device->wwid));\n\tif (pcie_device->enclosure_handle != 0)\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: exit: enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t    __func__,\n\t\t\t\t    (u64)pcie_device->enclosure_logical_id,\n\t\t\t\t    pcie_device->slot));\n\tif (pcie_device->connector_name[0] != '\\0')\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: exit: enclosure level(0x%04x), connector name( %s)\\n\",\n\t\t\t\t    __func__,\n\t\t\t\t    pcie_device->enclosure_level,\n\t\t\t\t    pcie_device->connector_name));\n\n\tkfree(pcie_device->serial_number);\n}\n\n\n/**\n * _scsih_pcie_check_device - checking device responsiveness\n * @ioc: per adapter object\n * @handle: attached device handle\n */\nstatic void\n_scsih_pcie_check_device(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi26PCIeDevicePage0_t pcie_device_pg0;\n\tu32 ioc_status;\n\tstruct _pcie_device *pcie_device;\n\tu64 wwid;\n\tunsigned long flags;\n\tstruct scsi_target *starget;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tu32 device_info;\n\n\tif ((mpt3sas_config_get_pcie_device_pg0(ioc, &mpi_reply,\n\t\t&pcie_device_pg0, MPI26_PCIE_DEVICE_PGAD_FORM_HANDLE, handle)))\n\t\treturn;\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\treturn;\n\n\t/* check if this is end device */\n\tdevice_info = le32_to_cpu(pcie_device_pg0.DeviceInfo);\n\tif (!(_scsih_is_nvme_pciescsi_device(device_info)))\n\t\treturn;\n\n\twwid = le64_to_cpu(pcie_device_pg0.WWID);\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tpcie_device = __mpt3sas_get_pdev_by_wwid(ioc, wwid);\n\n\tif (!pcie_device) {\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\treturn;\n\t}\n\n\tif (unlikely(pcie_device->handle != handle)) {\n\t\tstarget = pcie_device->starget;\n\t\tsas_target_priv_data = starget->hostdata;\n\t\tpcie_device->access_status = pcie_device_pg0.AccessStatus;\n\t\tstarget_printk(KERN_INFO, starget,\n\t\t    \"handle changed from(0x%04x) to (0x%04x)!!!\\n\",\n\t\t    pcie_device->handle, handle);\n\t\tsas_target_priv_data->handle = handle;\n\t\tpcie_device->handle = handle;\n\n\t\tif (le32_to_cpu(pcie_device_pg0.Flags) &\n\t\t    MPI26_PCIEDEV0_FLAGS_ENCL_LEVEL_VALID) {\n\t\t\tpcie_device->enclosure_level =\n\t\t\t    pcie_device_pg0.EnclosureLevel;\n\t\t\tmemcpy(&pcie_device->connector_name[0],\n\t\t\t    &pcie_device_pg0.ConnectorName[0], 4);\n\t\t} else {\n\t\t\tpcie_device->enclosure_level = 0;\n\t\t\tpcie_device->connector_name[0] = '\\0';\n\t\t}\n\t}\n\n\t/* check if device is present */\n\tif (!(le32_to_cpu(pcie_device_pg0.Flags) &\n\t    MPI26_PCIEDEV0_FLAGS_DEVICE_PRESENT)) {\n\t\tioc_info(ioc, \"device is not present handle(0x%04x), flags!!!\\n\",\n\t\t\t handle);\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\tpcie_device_put(pcie_device);\n\t\treturn;\n\t}\n\n\t/* check if there were any issues with discovery */\n\tif (_scsih_check_pcie_access_status(ioc, wwid, handle,\n\t    pcie_device_pg0.AccessStatus)) {\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\tpcie_device_put(pcie_device);\n\t\treturn;\n\t}\n\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\tpcie_device_put(pcie_device);\n\n\t_scsih_ublock_io_device(ioc, wwid, NULL);\n\n\treturn;\n}\n\n/**\n * _scsih_pcie_add_device -  creating pcie device object\n * @ioc: per adapter object\n * @handle: pcie device handle\n *\n * Creating end device object, stored in ioc->pcie_device_list.\n *\n * Return: 1 means queue the event later, 0 means complete the event\n */\nstatic int\n_scsih_pcie_add_device(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tMpi26PCIeDevicePage0_t pcie_device_pg0;\n\tMpi26PCIeDevicePage2_t pcie_device_pg2;\n\tMpi2ConfigReply_t mpi_reply;\n\tstruct _pcie_device *pcie_device;\n\tstruct _enclosure_node *enclosure_dev;\n\tu32 ioc_status;\n\tu64 wwid;\n\n\tif ((mpt3sas_config_get_pcie_device_pg0(ioc, &mpi_reply,\n\t    &pcie_device_pg0, MPI26_PCIE_DEVICE_PGAD_FORM_HANDLE, handle))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn 0;\n\t}\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn 0;\n\t}\n\n\tset_bit(handle, ioc->pend_os_device_add);\n\twwid = le64_to_cpu(pcie_device_pg0.WWID);\n\n\t/* check if device is present */\n\tif (!(le32_to_cpu(pcie_device_pg0.Flags) &\n\t\tMPI26_PCIEDEV0_FLAGS_DEVICE_PRESENT)) {\n\t\tioc_err(ioc, \"device is not present handle(0x04%x)!!!\\n\",\n\t\t\thandle);\n\t\treturn 0;\n\t}\n\n\t/* check if there were any issues with discovery */\n\tif (_scsih_check_pcie_access_status(ioc, wwid, handle,\n\t    pcie_device_pg0.AccessStatus))\n\t\treturn 0;\n\n\tif (!(_scsih_is_nvme_pciescsi_device(le32_to_cpu\n\t    (pcie_device_pg0.DeviceInfo))))\n\t\treturn 0;\n\n\tpcie_device = mpt3sas_get_pdev_by_wwid(ioc, wwid);\n\tif (pcie_device) {\n\t\tclear_bit(handle, ioc->pend_os_device_add);\n\t\tpcie_device_put(pcie_device);\n\t\treturn 0;\n\t}\n\n\t/* PCIe Device Page 2 contains read-only information about a\n\t * specific NVMe device; therefore, this page is only\n\t * valid for NVMe devices and skip for pcie devices of type scsi.\n\t */\n\tif (!(mpt3sas_scsih_is_pcie_scsi_device(\n\t\tle32_to_cpu(pcie_device_pg0.DeviceInfo)))) {\n\t\tif (mpt3sas_config_get_pcie_device_pg2(ioc, &mpi_reply,\n\t\t    &pcie_device_pg2, MPI2_SAS_DEVICE_PGAD_FORM_HANDLE,\n\t\t    handle)) {\n\t\t\tioc_err(ioc,\n\t\t\t    \"failure at %s:%d/%s()!\\n\", __FILE__,\n\t\t\t    __LINE__, __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t\t\t\tMPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_err(ioc,\n\t\t\t    \"failure at %s:%d/%s()!\\n\", __FILE__,\n\t\t\t    __LINE__, __func__);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpcie_device = kzalloc(sizeof(struct _pcie_device), GFP_KERNEL);\n\tif (!pcie_device) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn 0;\n\t}\n\n\tkref_init(&pcie_device->refcount);\n\tpcie_device->id = ioc->pcie_target_id++;\n\tpcie_device->channel = PCIE_CHANNEL;\n\tpcie_device->handle = handle;\n\tpcie_device->access_status = pcie_device_pg0.AccessStatus;\n\tpcie_device->device_info = le32_to_cpu(pcie_device_pg0.DeviceInfo);\n\tpcie_device->wwid = wwid;\n\tpcie_device->port_num = pcie_device_pg0.PortNum;\n\tpcie_device->fast_path = (le32_to_cpu(pcie_device_pg0.Flags) &\n\t    MPI26_PCIEDEV0_FLAGS_FAST_PATH_CAPABLE) ? 1 : 0;\n\n\tpcie_device->enclosure_handle =\n\t    le16_to_cpu(pcie_device_pg0.EnclosureHandle);\n\tif (pcie_device->enclosure_handle != 0)\n\t\tpcie_device->slot = le16_to_cpu(pcie_device_pg0.Slot);\n\n\tif (le32_to_cpu(pcie_device_pg0.Flags) &\n\t    MPI26_PCIEDEV0_FLAGS_ENCL_LEVEL_VALID) {\n\t\tpcie_device->enclosure_level = pcie_device_pg0.EnclosureLevel;\n\t\tmemcpy(&pcie_device->connector_name[0],\n\t\t    &pcie_device_pg0.ConnectorName[0], 4);\n\t} else {\n\t\tpcie_device->enclosure_level = 0;\n\t\tpcie_device->connector_name[0] = '\\0';\n\t}\n\n\t/* get enclosure_logical_id */\n\tif (pcie_device->enclosure_handle) {\n\t\tenclosure_dev =\n\t\t\tmpt3sas_scsih_enclosure_find_by_handle(ioc,\n\t\t\t\t\t\tpcie_device->enclosure_handle);\n\t\tif (enclosure_dev)\n\t\t\tpcie_device->enclosure_logical_id =\n\t\t\t    le64_to_cpu(enclosure_dev->pg0.EnclosureLogicalID);\n\t}\n\t/* TODO -- Add device name once FW supports it */\n\tif (!(mpt3sas_scsih_is_pcie_scsi_device(\n\t    le32_to_cpu(pcie_device_pg0.DeviceInfo)))) {\n\t\tpcie_device->nvme_mdts =\n\t\t    le32_to_cpu(pcie_device_pg2.MaximumDataTransferSize);\n\t\tpcie_device->shutdown_latency =\n\t\t\tle16_to_cpu(pcie_device_pg2.ShutdownLatency);\n\t\t/*\n\t\t * Set IOC's max_shutdown_latency to drive's RTD3 Entry Latency\n\t\t * if drive's RTD3 Entry Latency is greater then IOC's\n\t\t * max_shutdown_latency.\n\t\t */\n\t\tif (pcie_device->shutdown_latency > ioc->max_shutdown_latency)\n\t\t\tioc->max_shutdown_latency =\n\t\t\t\tpcie_device->shutdown_latency;\n\t\tif (pcie_device_pg2.ControllerResetTO)\n\t\t\tpcie_device->reset_timeout =\n\t\t\t    pcie_device_pg2.ControllerResetTO;\n\t\telse\n\t\t\tpcie_device->reset_timeout = 30;\n\t} else\n\t\tpcie_device->reset_timeout = 30;\n\n\tif (ioc->wait_for_discovery_to_complete)\n\t\t_scsih_pcie_device_init_add(ioc, pcie_device);\n\telse\n\t\t_scsih_pcie_device_add(ioc, pcie_device);\n\n\tpcie_device_put(pcie_device);\n\treturn 0;\n}\n\n/**\n * _scsih_pcie_topology_change_event_debug - debug for topology\n * event\n * @ioc: per adapter object\n * @event_data: event data payload\n * Context: user.\n */\nstatic void\n_scsih_pcie_topology_change_event_debug(struct MPT3SAS_ADAPTER *ioc,\n\tMpi26EventDataPCIeTopologyChangeList_t *event_data)\n{\n\tint i;\n\tu16 handle;\n\tu16 reason_code;\n\tu8 port_number;\n\tchar *status_str = NULL;\n\tu8 link_rate, prev_link_rate;\n\n\tswitch (event_data->SwitchStatus) {\n\tcase MPI26_EVENT_PCIE_TOPO_SS_ADDED:\n\t\tstatus_str = \"add\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIE_TOPO_SS_NOT_RESPONDING:\n\t\tstatus_str = \"remove\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIE_TOPO_SS_RESPONDING:\n\tcase 0:\n\t\tstatus_str =  \"responding\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIE_TOPO_SS_DELAY_NOT_RESPONDING:\n\t\tstatus_str = \"remove delay\";\n\t\tbreak;\n\tdefault:\n\t\tstatus_str = \"unknown status\";\n\t\tbreak;\n\t}\n\tioc_info(ioc, \"pcie topology change: (%s)\\n\", status_str);\n\tpr_info(\"\\tswitch_handle(0x%04x), enclosure_handle(0x%04x)\"\n\t\t\"start_port(%02d), count(%d)\\n\",\n\t\tle16_to_cpu(event_data->SwitchDevHandle),\n\t\tle16_to_cpu(event_data->EnclosureHandle),\n\t\tevent_data->StartPortNum, event_data->NumEntries);\n\tfor (i = 0; i < event_data->NumEntries; i++) {\n\t\thandle =\n\t\t\tle16_to_cpu(event_data->PortEntry[i].AttachedDevHandle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\tport_number = event_data->StartPortNum + i;\n\t\treason_code = event_data->PortEntry[i].PortStatus;\n\t\tswitch (reason_code) {\n\t\tcase MPI26_EVENT_PCIE_TOPO_PS_DEV_ADDED:\n\t\t\tstatus_str = \"target add\";\n\t\t\tbreak;\n\t\tcase MPI26_EVENT_PCIE_TOPO_PS_NOT_RESPONDING:\n\t\t\tstatus_str = \"target remove\";\n\t\t\tbreak;\n\t\tcase MPI26_EVENT_PCIE_TOPO_PS_DELAY_NOT_RESPONDING:\n\t\t\tstatus_str = \"delay target remove\";\n\t\t\tbreak;\n\t\tcase MPI26_EVENT_PCIE_TOPO_PS_PORT_CHANGED:\n\t\t\tstatus_str = \"link rate change\";\n\t\t\tbreak;\n\t\tcase MPI26_EVENT_PCIE_TOPO_PS_NO_CHANGE:\n\t\t\tstatus_str = \"target responding\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus_str = \"unknown\";\n\t\t\tbreak;\n\t\t}\n\t\tlink_rate = event_data->PortEntry[i].CurrentPortInfo &\n\t\t\tMPI26_EVENT_PCIE_TOPO_PI_RATE_MASK;\n\t\tprev_link_rate = event_data->PortEntry[i].PreviousPortInfo &\n\t\t\tMPI26_EVENT_PCIE_TOPO_PI_RATE_MASK;\n\t\tpr_info(\"\\tport(%02d), attached_handle(0x%04x): %s:\"\n\t\t\t\" link rate: new(0x%02x), old(0x%02x)\\n\", port_number,\n\t\t\thandle, status_str, link_rate, prev_link_rate);\n\t}\n}\n\n/**\n * _scsih_pcie_topology_change_event - handle PCIe topology\n *  changes\n * @ioc: per adapter object\n * @fw_event: The fw_event_work object\n * Context: user.\n *\n */\nstatic void\n_scsih_pcie_topology_change_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tint i;\n\tu16 handle;\n\tu16 reason_code;\n\tu8 link_rate, prev_link_rate;\n\tunsigned long flags;\n\tint rc;\n\tMpi26EventDataPCIeTopologyChangeList_t *event_data =\n\t\t(Mpi26EventDataPCIeTopologyChangeList_t *) fw_event->event_data;\n\tstruct _pcie_device *pcie_device;\n\n\tif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)\n\t\t_scsih_pcie_topology_change_event_debug(ioc, event_data);\n\n\tif (ioc->shost_recovery || ioc->remove_host ||\n\t\tioc->pci_error_recovery)\n\t\treturn;\n\n\tif (fw_event->ignore) {\n\t\tdewtprintk(ioc, ioc_info(ioc, \"ignoring switch event\\n\"));\n\t\treturn;\n\t}\n\n\t/* handle siblings events */\n\tfor (i = 0; i < event_data->NumEntries; i++) {\n\t\tif (fw_event->ignore) {\n\t\t\tdewtprintk(ioc,\n\t\t\t\t   ioc_info(ioc, \"ignoring switch event\\n\"));\n\t\t\treturn;\n\t\t}\n\t\tif (ioc->remove_host || ioc->pci_error_recovery)\n\t\t\treturn;\n\t\treason_code = event_data->PortEntry[i].PortStatus;\n\t\thandle =\n\t\t\tle16_to_cpu(event_data->PortEntry[i].AttachedDevHandle);\n\t\tif (!handle)\n\t\t\tcontinue;\n\n\t\tlink_rate = event_data->PortEntry[i].CurrentPortInfo\n\t\t\t& MPI26_EVENT_PCIE_TOPO_PI_RATE_MASK;\n\t\tprev_link_rate = event_data->PortEntry[i].PreviousPortInfo\n\t\t\t& MPI26_EVENT_PCIE_TOPO_PI_RATE_MASK;\n\n\t\tswitch (reason_code) {\n\t\tcase MPI26_EVENT_PCIE_TOPO_PS_PORT_CHANGED:\n\t\t\tif (ioc->shost_recovery)\n\t\t\t\tbreak;\n\t\t\tif (link_rate == prev_link_rate)\n\t\t\t\tbreak;\n\t\t\tif (link_rate < MPI26_EVENT_PCIE_TOPO_PI_RATE_2_5)\n\t\t\t\tbreak;\n\n\t\t\t_scsih_pcie_check_device(ioc, handle);\n\n\t\t\t/* This code after this point handles the test case\n\t\t\t * where a device has been added, however its returning\n\t\t\t * BUSY for sometime.  Then before the Device Missing\n\t\t\t * Delay expires and the device becomes READY, the\n\t\t\t * device is removed and added back.\n\t\t\t */\n\t\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\t\tpcie_device = __mpt3sas_get_pdev_by_handle(ioc, handle);\n\t\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\t\t\tif (pcie_device) {\n\t\t\t\tpcie_device_put(pcie_device);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!test_bit(handle, ioc->pend_os_device_add))\n\t\t\t\tbreak;\n\n\t\t\tdewtprintk(ioc,\n\t\t\t\t   ioc_info(ioc, \"handle(0x%04x) device not found: convert event to a device add\\n\",\n\t\t\t\t\t    handle));\n\t\t\tevent_data->PortEntry[i].PortStatus &= 0xF0;\n\t\t\tevent_data->PortEntry[i].PortStatus |=\n\t\t\t\tMPI26_EVENT_PCIE_TOPO_PS_DEV_ADDED;\n\t\t\tfallthrough;\n\t\tcase MPI26_EVENT_PCIE_TOPO_PS_DEV_ADDED:\n\t\t\tif (ioc->shost_recovery)\n\t\t\t\tbreak;\n\t\t\tif (link_rate < MPI26_EVENT_PCIE_TOPO_PI_RATE_2_5)\n\t\t\t\tbreak;\n\n\t\t\trc = _scsih_pcie_add_device(ioc, handle);\n\t\t\tif (!rc) {\n\t\t\t\t/* mark entry vacant */\n\t\t\t\t/* TODO This needs to be reviewed and fixed,\n\t\t\t\t * we dont have an entry\n\t\t\t\t * to make an event void like vacant\n\t\t\t\t */\n\t\t\t\tevent_data->PortEntry[i].PortStatus |=\n\t\t\t\t\tMPI26_EVENT_PCIE_TOPO_PS_NO_CHANGE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MPI26_EVENT_PCIE_TOPO_PS_NOT_RESPONDING:\n\t\t\t_scsih_pcie_device_remove_by_handle(ioc, handle);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * _scsih_pcie_device_status_change_event_debug - debug for device event\n * @ioc: ?\n * @event_data: event data payload\n * Context: user.\n */\nstatic void\n_scsih_pcie_device_status_change_event_debug(struct MPT3SAS_ADAPTER *ioc,\n\tMpi26EventDataPCIeDeviceStatusChange_t *event_data)\n{\n\tchar *reason_str = NULL;\n\n\tswitch (event_data->ReasonCode) {\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_SMART_DATA:\n\t\treason_str = \"smart data\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_UNSUPPORTED:\n\t\treason_str = \"unsupported device discovered\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_INTERNAL_DEVICE_RESET:\n\t\treason_str = \"internal device reset\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_TASK_ABORT_INTERNAL:\n\t\treason_str = \"internal task abort\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_ABORT_TASK_SET_INTERNAL:\n\t\treason_str = \"internal task abort set\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_CLEAR_TASK_SET_INTERNAL:\n\t\treason_str = \"internal clear task set\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_QUERY_TASK_INTERNAL:\n\t\treason_str = \"internal query task\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_DEV_INIT_FAILURE:\n\t\treason_str = \"device init failure\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_CMP_INTERNAL_DEV_RESET:\n\t\treason_str = \"internal device reset complete\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_CMP_TASK_ABORT_INTERNAL:\n\t\treason_str = \"internal task abort complete\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_ASYNC_NOTIFICATION:\n\t\treason_str = \"internal async notification\";\n\t\tbreak;\n\tcase MPI26_EVENT_PCIDEV_STAT_RC_PCIE_HOT_RESET_FAILED:\n\t\treason_str = \"pcie hot reset failed\";\n\t\tbreak;\n\tdefault:\n\t\treason_str = \"unknown reason\";\n\t\tbreak;\n\t}\n\n\tioc_info(ioc, \"PCIE device status change: (%s)\\n\"\n\t\t \"\\thandle(0x%04x), WWID(0x%016llx), tag(%d)\",\n\t\t reason_str, le16_to_cpu(event_data->DevHandle),\n\t\t (u64)le64_to_cpu(event_data->WWID),\n\t\t le16_to_cpu(event_data->TaskTag));\n\tif (event_data->ReasonCode == MPI26_EVENT_PCIDEV_STAT_RC_SMART_DATA)\n\t\tpr_cont(\", ASC(0x%x), ASCQ(0x%x)\\n\",\n\t\t\tevent_data->ASC, event_data->ASCQ);\n\tpr_cont(\"\\n\");\n}\n\n/**\n * _scsih_pcie_device_status_change_event - handle device status\n * change\n * @ioc: per adapter object\n * @fw_event: The fw_event_work object\n * Context: user.\n */\nstatic void\n_scsih_pcie_device_status_change_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tstruct MPT3SAS_TARGET *target_priv_data;\n\tstruct _pcie_device *pcie_device;\n\tu64 wwid;\n\tunsigned long flags;\n\tMpi26EventDataPCIeDeviceStatusChange_t *event_data =\n\t\t(Mpi26EventDataPCIeDeviceStatusChange_t *)fw_event->event_data;\n\tif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)\n\t\t_scsih_pcie_device_status_change_event_debug(ioc,\n\t\t\tevent_data);\n\n\tif (event_data->ReasonCode !=\n\t\tMPI26_EVENT_PCIDEV_STAT_RC_INTERNAL_DEVICE_RESET &&\n\t\tevent_data->ReasonCode !=\n\t\tMPI26_EVENT_PCIDEV_STAT_RC_CMP_INTERNAL_DEV_RESET)\n\t\treturn;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\twwid = le64_to_cpu(event_data->WWID);\n\tpcie_device = __mpt3sas_get_pdev_by_wwid(ioc, wwid);\n\n\tif (!pcie_device || !pcie_device->starget)\n\t\tgoto out;\n\n\ttarget_priv_data = pcie_device->starget->hostdata;\n\tif (!target_priv_data)\n\t\tgoto out;\n\n\tif (event_data->ReasonCode ==\n\t\tMPI26_EVENT_PCIDEV_STAT_RC_INTERNAL_DEVICE_RESET)\n\t\ttarget_priv_data->tm_busy = 1;\n\telse\n\t\ttarget_priv_data->tm_busy = 0;\nout:\n\tif (pcie_device)\n\t\tpcie_device_put(pcie_device);\n\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n}\n\n/**\n * _scsih_sas_enclosure_dev_status_change_event_debug - debug for enclosure\n * event\n * @ioc: per adapter object\n * @event_data: event data payload\n * Context: user.\n */\nstatic void\n_scsih_sas_enclosure_dev_status_change_event_debug(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataSasEnclDevStatusChange_t *event_data)\n{\n\tchar *reason_str = NULL;\n\n\tswitch (event_data->ReasonCode) {\n\tcase MPI2_EVENT_SAS_ENCL_RC_ADDED:\n\t\treason_str = \"enclosure add\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_ENCL_RC_NOT_RESPONDING:\n\t\treason_str = \"enclosure remove\";\n\t\tbreak;\n\tdefault:\n\t\treason_str = \"unknown reason\";\n\t\tbreak;\n\t}\n\n\tioc_info(ioc, \"enclosure status change: (%s)\\n\"\n\t\t \"\\thandle(0x%04x), enclosure logical id(0x%016llx) number slots(%d)\\n\",\n\t\t reason_str,\n\t\t le16_to_cpu(event_data->EnclosureHandle),\n\t\t (u64)le64_to_cpu(event_data->EnclosureLogicalID),\n\t\t le16_to_cpu(event_data->StartSlot));\n}\n\n/**\n * _scsih_sas_enclosure_dev_status_change_event - handle enclosure events\n * @ioc: per adapter object\n * @fw_event: The fw_event_work object\n * Context: user.\n */\nstatic void\n_scsih_sas_enclosure_dev_status_change_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tMpi2ConfigReply_t mpi_reply;\n\tstruct _enclosure_node *enclosure_dev = NULL;\n\tMpi2EventDataSasEnclDevStatusChange_t *event_data =\n\t\t(Mpi2EventDataSasEnclDevStatusChange_t *)fw_event->event_data;\n\tint rc;\n\tu16 enclosure_handle = le16_to_cpu(event_data->EnclosureHandle);\n\n\tif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)\n\t\t_scsih_sas_enclosure_dev_status_change_event_debug(ioc,\n\t\t     (Mpi2EventDataSasEnclDevStatusChange_t *)\n\t\t     fw_event->event_data);\n\tif (ioc->shost_recovery)\n\t\treturn;\n\n\tif (enclosure_handle)\n\t\tenclosure_dev =\n\t\t\tmpt3sas_scsih_enclosure_find_by_handle(ioc,\n\t\t\t\t\t\tenclosure_handle);\n\tswitch (event_data->ReasonCode) {\n\tcase MPI2_EVENT_SAS_ENCL_RC_ADDED:\n\t\tif (!enclosure_dev) {\n\t\t\tenclosure_dev =\n\t\t\t\tkzalloc(sizeof(struct _enclosure_node),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!enclosure_dev) {\n\t\t\t\tioc_info(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t\t __FILE__, __LINE__, __func__);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trc = mpt3sas_config_get_enclosure_pg0(ioc, &mpi_reply,\n\t\t\t\t&enclosure_dev->pg0,\n\t\t\t\tMPI2_SAS_ENCLOS_PGAD_FORM_HANDLE,\n\t\t\t\tenclosure_handle);\n\n\t\t\tif (rc || (le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t\t\t\t\tMPI2_IOCSTATUS_MASK)) {\n\t\t\t\tkfree(enclosure_dev);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlist_add_tail(&enclosure_dev->list,\n\t\t\t\t\t\t\t&ioc->enclosure_list);\n\t\t}\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_ENCL_RC_NOT_RESPONDING:\n\t\tif (enclosure_dev) {\n\t\t\tlist_del(&enclosure_dev->list);\n\t\t\tkfree(enclosure_dev);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/**\n * _scsih_sas_broadcast_primitive_event - handle broadcast events\n * @ioc: per adapter object\n * @fw_event: The fw_event_work object\n * Context: user.\n */\nstatic void\n_scsih_sas_broadcast_primitive_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tstruct scsi_cmnd *scmd;\n\tstruct scsi_device *sdev;\n\tstruct scsiio_tracker *st;\n\tu16 smid, handle;\n\tu32 lun;\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tu32 termination_count;\n\tu32 query_count;\n\tMpi2SCSITaskManagementReply_t *mpi_reply;\n\tMpi2EventDataSasBroadcastPrimitive_t *event_data =\n\t\t(Mpi2EventDataSasBroadcastPrimitive_t *)\n\t\tfw_event->event_data;\n\tu16 ioc_status;\n\tunsigned long flags;\n\tint r;\n\tu8 max_retries = 0;\n\tu8 task_abort_retries;\n\n\tmutex_lock(&ioc->tm_cmds.mutex);\n\tioc_info(ioc, \"%s: enter: phy number(%d), width(%d)\\n\",\n\t\t __func__, event_data->PhyNum, event_data->PortWidth);\n\n\t_scsih_block_io_all_device(ioc);\n\n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\tmpi_reply = ioc->tm_cmds.reply;\n broadcast_aen_retry:\n\n\t/* sanity checks for retrying this loop */\n\tif (max_retries++ == 5) {\n\t\tdewtprintk(ioc, ioc_info(ioc, \"%s: giving up\\n\", __func__));\n\t\tgoto out;\n\t} else if (max_retries > 1)\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: %d retry\\n\",\n\t\t\t\t    __func__, max_retries - 1));\n\n\ttermination_count = 0;\n\tquery_count = 0;\n\tfor (smid = 1; smid <= ioc->scsiio_depth; smid++) {\n\t\tif (ioc->shost_recovery)\n\t\t\tgoto out;\n\t\tscmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);\n\t\tif (!scmd)\n\t\t\tcontinue;\n\t\tst = scsi_cmd_priv(scmd);\n\t\tsdev = scmd->device;\n\t\tsas_device_priv_data = sdev->hostdata;\n\t\tif (!sas_device_priv_data || !sas_device_priv_data->sas_target)\n\t\t\tcontinue;\n\t\t /* skip hidden raid components */\n\t\tif (sas_device_priv_data->sas_target->flags &\n\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT)\n\t\t\tcontinue;\n\t\t /* skip volumes */\n\t\tif (sas_device_priv_data->sas_target->flags &\n\t\t    MPT_TARGET_FLAGS_VOLUME)\n\t\t\tcontinue;\n\t\t /* skip PCIe devices */\n\t\tif (sas_device_priv_data->sas_target->flags &\n\t\t    MPT_TARGET_FLAGS_PCIE_DEVICE)\n\t\t\tcontinue;\n\n\t\thandle = sas_device_priv_data->sas_target->handle;\n\t\tlun = sas_device_priv_data->lun;\n\t\tquery_count++;\n\n\t\tif (ioc->shost_recovery)\n\t\t\tgoto out;\n\n\t\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\t\tr = mpt3sas_scsih_issue_tm(ioc, handle, 0, 0, lun,\n\t\t\tMPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK, st->smid,\n\t\t\tst->msix_io, 30, 0);\n\t\tif (r == FAILED) {\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t    \"mpt3sas_scsih_issue_tm: FAILED when sending \"\n\t\t\t    \"QUERY_TASK: scmd(%p)\\n\", scmd);\n\t\t\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\t\t\tgoto broadcast_aen_retry;\n\t\t}\n\t\tioc_status = le16_to_cpu(mpi_reply->IOCStatus)\n\t\t    & MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t\"query task: FAILED with IOCSTATUS(0x%04x), scmd(%p)\\n\",\n\t\t\t\tioc_status, scmd);\n\t\t\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\t\t\tgoto broadcast_aen_retry;\n\t\t}\n\n\t\t/* see if IO is still owned by IOC and target */\n\t\tif (mpi_reply->ResponseCode ==\n\t\t     MPI2_SCSITASKMGMT_RSP_TM_SUCCEEDED ||\n\t\t     mpi_reply->ResponseCode ==\n\t\t     MPI2_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC) {\n\t\t\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_abort_retries = 0;\n tm_retry:\n\t\tif (task_abort_retries++ == 60) {\n\t\t\tdewtprintk(ioc,\n\t\t\t\t   ioc_info(ioc, \"%s: ABORT_TASK: giving up\\n\",\n\t\t\t\t\t    __func__));\n\t\t\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\t\t\tgoto broadcast_aen_retry;\n\t\t}\n\n\t\tif (ioc->shost_recovery)\n\t\t\tgoto out_no_lock;\n\n\t\tr = mpt3sas_scsih_issue_tm(ioc, handle, sdev->channel, sdev->id,\n\t\t\tsdev->lun, MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK,\n\t\t\tst->smid, st->msix_io, 30, 0);\n\t\tif (r == FAILED || st->cb_idx != 0xFF) {\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t    \"mpt3sas_scsih_issue_tm: ABORT_TASK: FAILED : \"\n\t\t\t    \"scmd(%p)\\n\", scmd);\n\t\t\tgoto tm_retry;\n\t\t}\n\n\t\tif (task_abort_retries > 1)\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t    \"mpt3sas_scsih_issue_tm: ABORT_TASK: RETRIES (%d):\"\n\t\t\t    \" scmd(%p)\\n\",\n\t\t\t    task_abort_retries - 1, scmd);\n\n\t\ttermination_count += le32_to_cpu(mpi_reply->TerminationCount);\n\t\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\t}\n\n\tif (ioc->broadcast_aen_pending) {\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc,\n\t\t\t\t    \"%s: loop back due to pending AEN\\n\",\n\t\t\t\t    __func__));\n\t\t ioc->broadcast_aen_pending = 0;\n\t\t goto broadcast_aen_retry;\n\t}\n\n out:\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n out_no_lock:\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"%s - exit, query_count = %d termination_count = %d\\n\",\n\t\t\t    __func__, query_count, termination_count));\n\n\tioc->broadcast_aen_busy = 0;\n\tif (!ioc->shost_recovery)\n\t\t_scsih_ublock_io_all_device(ioc);\n\tmutex_unlock(&ioc->tm_cmds.mutex);\n}\n\n/**\n * _scsih_sas_discovery_event - handle discovery events\n * @ioc: per adapter object\n * @fw_event: The fw_event_work object\n * Context: user.\n */\nstatic void\n_scsih_sas_discovery_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tMpi2EventDataSasDiscovery_t *event_data =\n\t\t(Mpi2EventDataSasDiscovery_t *) fw_event->event_data;\n\n\tif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK) {\n\t\tioc_info(ioc, \"discovery event: (%s)\",\n\t\t\t event_data->ReasonCode == MPI2_EVENT_SAS_DISC_RC_STARTED ?\n\t\t\t \"start\" : \"stop\");\n\t\tif (event_data->DiscoveryStatus)\n\t\t\tpr_cont(\"discovery_status(0x%08x)\",\n\t\t\t\tle32_to_cpu(event_data->DiscoveryStatus));\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tif (event_data->ReasonCode == MPI2_EVENT_SAS_DISC_RC_STARTED &&\n\t    !ioc->sas_hba.num_phys) {\n\t\tif (disable_discovery > 0 && ioc->shost_recovery) {\n\t\t\t/* Wait for the reset to complete */\n\t\t\twhile (ioc->shost_recovery)\n\t\t\t\tssleep(1);\n\t\t}\n\t\t_scsih_sas_host_add(ioc);\n\t}\n}\n\n/**\n * _scsih_sas_device_discovery_error_event - display SAS device discovery error\n *\t\t\t\t\t\tevents\n * @ioc: per adapter object\n * @fw_event: The fw_event_work object\n * Context: user.\n */\nstatic void\n_scsih_sas_device_discovery_error_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tMpi25EventDataSasDeviceDiscoveryError_t *event_data =\n\t\t(Mpi25EventDataSasDeviceDiscoveryError_t *)fw_event->event_data;\n\n\tswitch (event_data->ReasonCode) {\n\tcase MPI25_EVENT_SAS_DISC_ERR_SMP_FAILED:\n\t\tioc_warn(ioc, \"SMP command sent to the expander (handle:0x%04x, sas_address:0x%016llx, physical_port:0x%02x) has failed\\n\",\n\t\t\t le16_to_cpu(event_data->DevHandle),\n\t\t\t (u64)le64_to_cpu(event_data->SASAddress),\n\t\t\t event_data->PhysicalPort);\n\t\tbreak;\n\tcase MPI25_EVENT_SAS_DISC_ERR_SMP_TIMEOUT:\n\t\tioc_warn(ioc, \"SMP command sent to the expander (handle:0x%04x, sas_address:0x%016llx, physical_port:0x%02x) has timed out\\n\",\n\t\t\t le16_to_cpu(event_data->DevHandle),\n\t\t\t (u64)le64_to_cpu(event_data->SASAddress),\n\t\t\t event_data->PhysicalPort);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/**\n * _scsih_pcie_enumeration_event - handle enumeration events\n * @ioc: per adapter object\n * @fw_event: The fw_event_work object\n * Context: user.\n */\nstatic void\n_scsih_pcie_enumeration_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tMpi26EventDataPCIeEnumeration_t *event_data =\n\t\t(Mpi26EventDataPCIeEnumeration_t *)fw_event->event_data;\n\n\tif (!(ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK))\n\t\treturn;\n\n\tioc_info(ioc, \"pcie enumeration event: (%s) Flag 0x%02x\",\n\t\t (event_data->ReasonCode == MPI26_EVENT_PCIE_ENUM_RC_STARTED) ?\n\t\t \"started\" : \"completed\",\n\t\t event_data->Flags);\n\tif (event_data->EnumerationStatus)\n\t\tpr_cont(\"enumeration_status(0x%08x)\",\n\t\t\tle32_to_cpu(event_data->EnumerationStatus));\n\tpr_cont(\"\\n\");\n}\n\n/**\n * _scsih_ir_fastpath - turn on fastpath for IR physdisk\n * @ioc: per adapter object\n * @handle: device handle for physical disk\n * @phys_disk_num: physical disk number\n *\n * Return: 0 for success, else failure.\n */\nstatic int\n_scsih_ir_fastpath(struct MPT3SAS_ADAPTER *ioc, u16 handle, u8 phys_disk_num)\n{\n\tMpi2RaidActionRequest_t *mpi_request;\n\tMpi2RaidActionReply_t *mpi_reply;\n\tu16 smid;\n\tu8 issue_reset = 0;\n\tint rc = 0;\n\tu16 ioc_status;\n\tu32 log_info;\n\n\tif (ioc->hba_mpi_version_belonged == MPI2_VERSION)\n\t\treturn rc;\n\n\tmutex_lock(&ioc->scsih_cmds.mutex);\n\n\tif (ioc->scsih_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: scsih_cmd in use\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\tioc->scsih_cmds.status = MPT3_CMD_PENDING;\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->scsih_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->scsih_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi2RaidActionRequest_t));\n\n\tmpi_request->Function = MPI2_FUNCTION_RAID_ACTION;\n\tmpi_request->Action = MPI2_RAID_ACTION_PHYSDISK_HIDDEN;\n\tmpi_request->PhysDiskNum = phys_disk_num;\n\n\tdewtprintk(ioc,\n\t\t   ioc_info(ioc, \"IR RAID_ACTION: turning fast path on for handle(0x%04x), phys_disk_num (0x%02x)\\n\",\n\t\t\t    handle, phys_disk_num));\n\n\tinit_completion(&ioc->scsih_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->scsih_cmds.done, 10*HZ);\n\n\tif (!(ioc->scsih_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tmpt3sas_check_cmd_timeout(ioc,\n\t\t    ioc->scsih_cmds.status, mpi_request,\n\t\t    sizeof(Mpi2RaidActionRequest_t)/4, issue_reset);\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (ioc->scsih_cmds.status & MPT3_CMD_REPLY_VALID) {\n\n\t\tmpi_reply = ioc->scsih_cmds.reply;\n\t\tioc_status = le16_to_cpu(mpi_reply->IOCStatus);\n\t\tif (ioc_status & MPI2_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE)\n\t\t\tlog_info =  le32_to_cpu(mpi_reply->IOCLogInfo);\n\t\telse\n\t\t\tlog_info = 0;\n\t\tioc_status &= MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tdewtprintk(ioc,\n\t\t\t\t   ioc_info(ioc, \"IR RAID_ACTION: failed: ioc_status(0x%04x), loginfo(0x%08x)!!!\\n\",\n\t\t\t\t\t    ioc_status, log_info));\n\t\t\trc = -EFAULT;\n\t\t} else\n\t\t\tdewtprintk(ioc,\n\t\t\t\t   ioc_info(ioc, \"IR RAID_ACTION: completed successfully\\n\"));\n\t}\n\n out:\n\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\n\tmutex_unlock(&ioc->scsih_cmds.mutex);\n\n\tif (issue_reset)\n\t\tmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\treturn rc;\n}\n\n/**\n * _scsih_reprobe_lun - reprobing lun\n * @sdev: scsi device struct\n * @no_uld_attach: sdev->no_uld_attach flag setting\n *\n **/\nstatic void\n_scsih_reprobe_lun(struct scsi_device *sdev, void *no_uld_attach)\n{\n\tsdev->no_uld_attach = no_uld_attach ? 1 : 0;\n\tsdev_printk(KERN_INFO, sdev, \"%s raid component\\n\",\n\t    sdev->no_uld_attach ? \"hiding\" : \"exposing\");\n\tWARN_ON(scsi_device_reprobe(sdev));\n}\n\n/**\n * _scsih_sas_volume_add - add new volume\n * @ioc: per adapter object\n * @element: IR config element data\n * Context: user.\n */\nstatic void\n_scsih_sas_volume_add(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventIrConfigElement_t *element)\n{\n\tstruct _raid_device *raid_device;\n\tunsigned long flags;\n\tu64 wwid;\n\tu16 handle = le16_to_cpu(element->VolDevHandle);\n\tint rc;\n\n\tmpt3sas_config_get_volume_wwid(ioc, handle, &wwid);\n\tif (!wwid) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\traid_device = _scsih_raid_device_find_by_wwid(ioc, wwid);\n\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\n\tif (raid_device)\n\t\treturn;\n\n\traid_device = kzalloc(sizeof(struct _raid_device), GFP_KERNEL);\n\tif (!raid_device) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\traid_device->id = ioc->sas_id++;\n\traid_device->channel = RAID_CHANNEL;\n\traid_device->handle = handle;\n\traid_device->wwid = wwid;\n\t_scsih_raid_device_add(ioc, raid_device);\n\tif (!ioc->wait_for_discovery_to_complete) {\n\t\trc = scsi_add_device(ioc->shost, RAID_CHANNEL,\n\t\t    raid_device->id, 0);\n\t\tif (rc)\n\t\t\t_scsih_raid_device_remove(ioc, raid_device);\n\t} else {\n\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\t_scsih_determine_boot_device(ioc, raid_device, 1);\n\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t}\n}\n\n/**\n * _scsih_sas_volume_delete - delete volume\n * @ioc: per adapter object\n * @handle: volume device handle\n * Context: user.\n */\nstatic void\n_scsih_sas_volume_delete(struct MPT3SAS_ADAPTER *ioc, u16 handle)\n{\n\tstruct _raid_device *raid_device;\n\tunsigned long flags;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct scsi_target *starget = NULL;\n\n\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\traid_device = mpt3sas_raid_device_find_by_handle(ioc, handle);\n\tif (raid_device) {\n\t\tif (raid_device->starget) {\n\t\t\tstarget = raid_device->starget;\n\t\t\tsas_target_priv_data = starget->hostdata;\n\t\t\tsas_target_priv_data->deleted = 1;\n\t\t}\n\t\tioc_info(ioc, \"removing handle(0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t raid_device->handle, (u64)raid_device->wwid);\n\t\tlist_del(&raid_device->list);\n\t\tkfree(raid_device);\n\t}\n\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\tif (starget)\n\t\tscsi_remove_target(&starget->dev);\n}\n\n/**\n * _scsih_sas_pd_expose - expose pd component to /dev/sdX\n * @ioc: per adapter object\n * @element: IR config element data\n * Context: user.\n */\nstatic void\n_scsih_sas_pd_expose(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventIrConfigElement_t *element)\n{\n\tstruct _sas_device *sas_device;\n\tstruct scsi_target *starget = NULL;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tunsigned long flags;\n\tu16 handle = le16_to_cpu(element->PhysDiskDevHandle);\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_handle(ioc, handle);\n\tif (sas_device) {\n\t\tsas_device->volume_handle = 0;\n\t\tsas_device->volume_wwid = 0;\n\t\tclear_bit(handle, ioc->pd_handles);\n\t\tif (sas_device->starget && sas_device->starget->hostdata) {\n\t\t\tstarget = sas_device->starget;\n\t\t\tsas_target_priv_data = starget->hostdata;\n\t\t\tsas_target_priv_data->flags &=\n\t\t\t    ~MPT_TARGET_FLAGS_RAID_COMPONENT;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\tif (!sas_device)\n\t\treturn;\n\n\t/* exposing raid component */\n\tif (starget)\n\t\tstarget_for_each_device(starget, NULL, _scsih_reprobe_lun);\n\n\tsas_device_put(sas_device);\n}\n\n/**\n * _scsih_sas_pd_hide - hide pd component from /dev/sdX\n * @ioc: per adapter object\n * @element: IR config element data\n * Context: user.\n */\nstatic void\n_scsih_sas_pd_hide(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventIrConfigElement_t *element)\n{\n\tstruct _sas_device *sas_device;\n\tstruct scsi_target *starget = NULL;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tunsigned long flags;\n\tu16 handle = le16_to_cpu(element->PhysDiskDevHandle);\n\tu16 volume_handle = 0;\n\tu64 volume_wwid = 0;\n\n\tmpt3sas_config_get_volume_handle(ioc, handle, &volume_handle);\n\tif (volume_handle)\n\t\tmpt3sas_config_get_volume_wwid(ioc, volume_handle,\n\t\t    &volume_wwid);\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tsas_device = __mpt3sas_get_sdev_by_handle(ioc, handle);\n\tif (sas_device) {\n\t\tset_bit(handle, ioc->pd_handles);\n\t\tif (sas_device->starget && sas_device->starget->hostdata) {\n\t\t\tstarget = sas_device->starget;\n\t\t\tsas_target_priv_data = starget->hostdata;\n\t\t\tsas_target_priv_data->flags |=\n\t\t\t    MPT_TARGET_FLAGS_RAID_COMPONENT;\n\t\t\tsas_device->volume_handle = volume_handle;\n\t\t\tsas_device->volume_wwid = volume_wwid;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\tif (!sas_device)\n\t\treturn;\n\n\t/* hiding raid component */\n\t_scsih_ir_fastpath(ioc, handle, element->PhysDiskNum);\n\n\tif (starget)\n\t\tstarget_for_each_device(starget, (void *)1, _scsih_reprobe_lun);\n\n\tsas_device_put(sas_device);\n}\n\n/**\n * _scsih_sas_pd_delete - delete pd component\n * @ioc: per adapter object\n * @element: IR config element data\n * Context: user.\n */\nstatic void\n_scsih_sas_pd_delete(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventIrConfigElement_t *element)\n{\n\tu16 handle = le16_to_cpu(element->PhysDiskDevHandle);\n\n\t_scsih_device_remove_by_handle(ioc, handle);\n}\n\n/**\n * _scsih_sas_pd_add - remove pd component\n * @ioc: per adapter object\n * @element: IR config element data\n * Context: user.\n */\nstatic void\n_scsih_sas_pd_add(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventIrConfigElement_t *element)\n{\n\tstruct _sas_device *sas_device;\n\tu16 handle = le16_to_cpu(element->PhysDiskDevHandle);\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tu32 ioc_status;\n\tu64 sas_address;\n\tu16 parent_handle;\n\n\tset_bit(handle, ioc->pd_handles);\n\n\tsas_device = mpt3sas_get_sdev_by_handle(ioc, handle);\n\tif (sas_device) {\n\t\t_scsih_ir_fastpath(ioc, handle, element->PhysDiskNum);\n\t\tsas_device_put(sas_device);\n\t\treturn;\n\t}\n\n\tif ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\n\t    MPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\n\tparent_handle = le16_to_cpu(sas_device_pg0.ParentDevHandle);\n\tif (!_scsih_get_sas_address(ioc, parent_handle, &sas_address))\n\t\tmpt3sas_transport_update_links(ioc, sas_address, handle,\n\t\t    sas_device_pg0.PhyNum, MPI2_SAS_NEG_LINK_RATE_1_5,\n\t\t    mpt3sas_get_port_by_id(ioc,\n\t\t    sas_device_pg0.PhysicalPort, 0));\n\n\t_scsih_ir_fastpath(ioc, handle, element->PhysDiskNum);\n\t_scsih_add_device(ioc, handle, 0, 1);\n}\n\n/**\n * _scsih_sas_ir_config_change_event_debug - debug for IR Config Change events\n * @ioc: per adapter object\n * @event_data: event data payload\n * Context: user.\n */\nstatic void\n_scsih_sas_ir_config_change_event_debug(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataIrConfigChangeList_t *event_data)\n{\n\tMpi2EventIrConfigElement_t *element;\n\tu8 element_type;\n\tint i;\n\tchar *reason_str = NULL, *element_str = NULL;\n\n\telement = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];\n\n\tioc_info(ioc, \"raid config change: (%s), elements(%d)\\n\",\n\t\t le32_to_cpu(event_data->Flags) & MPI2_EVENT_IR_CHANGE_FLAGS_FOREIGN_CONFIG ?\n\t\t \"foreign\" : \"native\",\n\t\t event_data->NumElements);\n\tfor (i = 0; i < event_data->NumElements; i++, element++) {\n\t\tswitch (element->ReasonCode) {\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_ADDED:\n\t\t\treason_str = \"add\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_REMOVED:\n\t\t\treason_str = \"remove\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_NO_CHANGE:\n\t\t\treason_str = \"no change\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_HIDE:\n\t\t\treason_str = \"hide\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_UNHIDE:\n\t\t\treason_str = \"unhide\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_VOLUME_CREATED:\n\t\t\treason_str = \"volume_created\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED:\n\t\t\treason_str = \"volume_deleted\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_PD_CREATED:\n\t\t\treason_str = \"pd_created\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_PD_DELETED:\n\t\t\treason_str = \"pd_deleted\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treason_str = \"unknown reason\";\n\t\t\tbreak;\n\t\t}\n\t\telement_type = le16_to_cpu(element->ElementFlags) &\n\t\t    MPI2_EVENT_IR_CHANGE_EFLAGS_ELEMENT_TYPE_MASK;\n\t\tswitch (element_type) {\n\t\tcase MPI2_EVENT_IR_CHANGE_EFLAGS_VOLUME_ELEMENT:\n\t\t\telement_str = \"volume\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_EFLAGS_VOLPHYSDISK_ELEMENT:\n\t\t\telement_str = \"phys disk\";\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_EFLAGS_HOTSPARE_ELEMENT:\n\t\t\telement_str = \"hot spare\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telement_str = \"unknown element\";\n\t\t\tbreak;\n\t\t}\n\t\tpr_info(\"\\t(%s:%s), vol handle(0x%04x), \" \\\n\t\t    \"pd handle(0x%04x), pd num(0x%02x)\\n\", element_str,\n\t\t    reason_str, le16_to_cpu(element->VolDevHandle),\n\t\t    le16_to_cpu(element->PhysDiskDevHandle),\n\t\t    element->PhysDiskNum);\n\t}\n}\n\n/**\n * _scsih_sas_ir_config_change_event - handle ir configuration change events\n * @ioc: per adapter object\n * @fw_event: The fw_event_work object\n * Context: user.\n */\nstatic void\n_scsih_sas_ir_config_change_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tMpi2EventIrConfigElement_t *element;\n\tint i;\n\tu8 foreign_config;\n\tMpi2EventDataIrConfigChangeList_t *event_data =\n\t\t(Mpi2EventDataIrConfigChangeList_t *)\n\t\tfw_event->event_data;\n\n\tif ((ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK) &&\n\t     (!ioc->hide_ir_msg))\n\t\t_scsih_sas_ir_config_change_event_debug(ioc, event_data);\n\n\tforeign_config = (le32_to_cpu(event_data->Flags) &\n\t    MPI2_EVENT_IR_CHANGE_FLAGS_FOREIGN_CONFIG) ? 1 : 0;\n\n\telement = (Mpi2EventIrConfigElement_t *)&event_data->ConfigElement[0];\n\tif (ioc->shost_recovery &&\n\t    ioc->hba_mpi_version_belonged != MPI2_VERSION) {\n\t\tfor (i = 0; i < event_data->NumElements; i++, element++) {\n\t\t\tif (element->ReasonCode == MPI2_EVENT_IR_CHANGE_RC_HIDE)\n\t\t\t\t_scsih_ir_fastpath(ioc,\n\t\t\t\t\tle16_to_cpu(element->PhysDiskDevHandle),\n\t\t\t\t\telement->PhysDiskNum);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < event_data->NumElements; i++, element++) {\n\n\t\tswitch (element->ReasonCode) {\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_VOLUME_CREATED:\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_ADDED:\n\t\t\tif (!foreign_config)\n\t\t\t\t_scsih_sas_volume_add(ioc, element);\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED:\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_REMOVED:\n\t\t\tif (!foreign_config)\n\t\t\t\t_scsih_sas_volume_delete(ioc,\n\t\t\t\t    le16_to_cpu(element->VolDevHandle));\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_PD_CREATED:\n\t\t\tif (!ioc->is_warpdrive)\n\t\t\t\t_scsih_sas_pd_hide(ioc, element);\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_PD_DELETED:\n\t\t\tif (!ioc->is_warpdrive)\n\t\t\t\t_scsih_sas_pd_expose(ioc, element);\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_HIDE:\n\t\t\tif (!ioc->is_warpdrive)\n\t\t\t\t_scsih_sas_pd_add(ioc, element);\n\t\t\tbreak;\n\t\tcase MPI2_EVENT_IR_CHANGE_RC_UNHIDE:\n\t\t\tif (!ioc->is_warpdrive)\n\t\t\t\t_scsih_sas_pd_delete(ioc, element);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * _scsih_sas_ir_volume_event - IR volume event\n * @ioc: per adapter object\n * @fw_event: The fw_event_work object\n * Context: user.\n */\nstatic void\n_scsih_sas_ir_volume_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tu64 wwid;\n\tunsigned long flags;\n\tstruct _raid_device *raid_device;\n\tu16 handle;\n\tu32 state;\n\tint rc;\n\tMpi2EventDataIrVolume_t *event_data =\n\t\t(Mpi2EventDataIrVolume_t *) fw_event->event_data;\n\n\tif (ioc->shost_recovery)\n\t\treturn;\n\n\tif (event_data->ReasonCode != MPI2_EVENT_IR_VOLUME_RC_STATE_CHANGED)\n\t\treturn;\n\n\thandle = le16_to_cpu(event_data->VolDevHandle);\n\tstate = le32_to_cpu(event_data->NewValue);\n\tif (!ioc->hide_ir_msg)\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: handle(0x%04x), old(0x%08x), new(0x%08x)\\n\",\n\t\t\t\t    __func__, handle,\n\t\t\t\t    le32_to_cpu(event_data->PreviousValue),\n\t\t\t\t    state));\n\tswitch (state) {\n\tcase MPI2_RAID_VOL_STATE_MISSING:\n\tcase MPI2_RAID_VOL_STATE_FAILED:\n\t\t_scsih_sas_volume_delete(ioc, handle);\n\t\tbreak;\n\n\tcase MPI2_RAID_VOL_STATE_ONLINE:\n\tcase MPI2_RAID_VOL_STATE_DEGRADED:\n\tcase MPI2_RAID_VOL_STATE_OPTIMAL:\n\n\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\traid_device = mpt3sas_raid_device_find_by_handle(ioc, handle);\n\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\n\t\tif (raid_device)\n\t\t\tbreak;\n\n\t\tmpt3sas_config_get_volume_wwid(ioc, handle, &wwid);\n\t\tif (!wwid) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\traid_device = kzalloc(sizeof(struct _raid_device), GFP_KERNEL);\n\t\tif (!raid_device) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\traid_device->id = ioc->sas_id++;\n\t\traid_device->channel = RAID_CHANNEL;\n\t\traid_device->handle = handle;\n\t\traid_device->wwid = wwid;\n\t\t_scsih_raid_device_add(ioc, raid_device);\n\t\trc = scsi_add_device(ioc->shost, RAID_CHANNEL,\n\t\t    raid_device->id, 0);\n\t\tif (rc)\n\t\t\t_scsih_raid_device_remove(ioc, raid_device);\n\t\tbreak;\n\n\tcase MPI2_RAID_VOL_STATE_INITIALIZING:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/**\n * _scsih_sas_ir_physical_disk_event - PD event\n * @ioc: per adapter object\n * @fw_event: The fw_event_work object\n * Context: user.\n */\nstatic void\n_scsih_sas_ir_physical_disk_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tu16 handle, parent_handle;\n\tu32 state;\n\tstruct _sas_device *sas_device;\n\tMpi2ConfigReply_t mpi_reply;\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tu32 ioc_status;\n\tMpi2EventDataIrPhysicalDisk_t *event_data =\n\t\t(Mpi2EventDataIrPhysicalDisk_t *) fw_event->event_data;\n\tu64 sas_address;\n\n\tif (ioc->shost_recovery)\n\t\treturn;\n\n\tif (event_data->ReasonCode != MPI2_EVENT_IR_PHYSDISK_RC_STATE_CHANGED)\n\t\treturn;\n\n\thandle = le16_to_cpu(event_data->PhysDiskDevHandle);\n\tstate = le32_to_cpu(event_data->NewValue);\n\n\tif (!ioc->hide_ir_msg)\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"%s: handle(0x%04x), old(0x%08x), new(0x%08x)\\n\",\n\t\t\t\t    __func__, handle,\n\t\t\t\t    le32_to_cpu(event_data->PreviousValue),\n\t\t\t\t    state));\n\n\tswitch (state) {\n\tcase MPI2_RAID_PD_STATE_ONLINE:\n\tcase MPI2_RAID_PD_STATE_DEGRADED:\n\tcase MPI2_RAID_PD_STATE_REBUILDING:\n\tcase MPI2_RAID_PD_STATE_OPTIMAL:\n\tcase MPI2_RAID_PD_STATE_HOT_SPARE:\n\n\t\tif (!ioc->is_warpdrive)\n\t\t\tset_bit(handle, ioc->pd_handles);\n\n\t\tsas_device = mpt3sas_get_sdev_by_handle(ioc, handle);\n\t\tif (sas_device) {\n\t\t\tsas_device_put(sas_device);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply,\n\t\t    &sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_HANDLE,\n\t\t    handle))) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\treturn;\n\t\t}\n\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\treturn;\n\t\t}\n\n\t\tparent_handle = le16_to_cpu(sas_device_pg0.ParentDevHandle);\n\t\tif (!_scsih_get_sas_address(ioc, parent_handle, &sas_address))\n\t\t\tmpt3sas_transport_update_links(ioc, sas_address, handle,\n\t\t\t    sas_device_pg0.PhyNum, MPI2_SAS_NEG_LINK_RATE_1_5,\n\t\t\t    mpt3sas_get_port_by_id(ioc,\n\t\t\t    sas_device_pg0.PhysicalPort, 0));\n\n\t\t_scsih_add_device(ioc, handle, 0, 1);\n\n\t\tbreak;\n\n\tcase MPI2_RAID_PD_STATE_OFFLINE:\n\tcase MPI2_RAID_PD_STATE_NOT_CONFIGURED:\n\tcase MPI2_RAID_PD_STATE_NOT_COMPATIBLE:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/**\n * _scsih_sas_ir_operation_status_event_debug - debug for IR op event\n * @ioc: per adapter object\n * @event_data: event data payload\n * Context: user.\n */\nstatic void\n_scsih_sas_ir_operation_status_event_debug(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventDataIrOperationStatus_t *event_data)\n{\n\tchar *reason_str = NULL;\n\n\tswitch (event_data->RAIDOperation) {\n\tcase MPI2_EVENT_IR_RAIDOP_RESYNC:\n\t\treason_str = \"resync\";\n\t\tbreak;\n\tcase MPI2_EVENT_IR_RAIDOP_ONLINE_CAP_EXPANSION:\n\t\treason_str = \"online capacity expansion\";\n\t\tbreak;\n\tcase MPI2_EVENT_IR_RAIDOP_CONSISTENCY_CHECK:\n\t\treason_str = \"consistency check\";\n\t\tbreak;\n\tcase MPI2_EVENT_IR_RAIDOP_BACKGROUND_INIT:\n\t\treason_str = \"background init\";\n\t\tbreak;\n\tcase MPI2_EVENT_IR_RAIDOP_MAKE_DATA_CONSISTENT:\n\t\treason_str = \"make data consistent\";\n\t\tbreak;\n\t}\n\n\tif (!reason_str)\n\t\treturn;\n\n\tioc_info(ioc, \"raid operational status: (%s)\\thandle(0x%04x), percent complete(%d)\\n\",\n\t\t reason_str,\n\t\t le16_to_cpu(event_data->VolDevHandle),\n\t\t event_data->PercentComplete);\n}\n\n/**\n * _scsih_sas_ir_operation_status_event - handle RAID operation events\n * @ioc: per adapter object\n * @fw_event: The fw_event_work object\n * Context: user.\n */\nstatic void\n_scsih_sas_ir_operation_status_event(struct MPT3SAS_ADAPTER *ioc,\n\tstruct fw_event_work *fw_event)\n{\n\tMpi2EventDataIrOperationStatus_t *event_data =\n\t\t(Mpi2EventDataIrOperationStatus_t *)\n\t\tfw_event->event_data;\n\tstatic struct _raid_device *raid_device;\n\tunsigned long flags;\n\tu16 handle;\n\n\tif ((ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK) &&\n\t    (!ioc->hide_ir_msg))\n\t\t_scsih_sas_ir_operation_status_event_debug(ioc,\n\t\t     event_data);\n\n\t/* code added for raid transport support */\n\tif (event_data->RAIDOperation == MPI2_EVENT_IR_RAIDOP_RESYNC) {\n\n\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\thandle = le16_to_cpu(event_data->VolDevHandle);\n\t\traid_device = mpt3sas_raid_device_find_by_handle(ioc, handle);\n\t\tif (raid_device)\n\t\t\traid_device->percent_complete =\n\t\t\t    event_data->PercentComplete;\n\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t}\n}\n\n/**\n * _scsih_prep_device_scan - initialize parameters prior to device scan\n * @ioc: per adapter object\n *\n * Set the deleted flag prior to device scan.  If the device is found during\n * the scan, then we clear the deleted flag.\n */\nstatic void\n_scsih_prep_device_scan(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct MPT3SAS_DEVICE *sas_device_priv_data;\n\tstruct scsi_device *sdev;\n\n\tshost_for_each_device(sdev, ioc->shost) {\n\t\tsas_device_priv_data = sdev->hostdata;\n\t\tif (sas_device_priv_data && sas_device_priv_data->sas_target)\n\t\t\tsas_device_priv_data->sas_target->deleted = 1;\n\t}\n}\n\n/**\n * _scsih_mark_responding_sas_device - mark a sas_devices as responding\n * @ioc: per adapter object\n * @sas_device_pg0: SAS Device page 0\n *\n * After host reset, find out whether devices are still responding.\n * Used in _scsih_remove_unresponsive_sas_devices.\n */\nstatic void\n_scsih_mark_responding_sas_device(struct MPT3SAS_ADAPTER *ioc,\nMpi2SasDevicePage0_t *sas_device_pg0)\n{\n\tstruct MPT3SAS_TARGET *sas_target_priv_data = NULL;\n\tstruct scsi_target *starget;\n\tstruct _sas_device *sas_device = NULL;\n\tstruct _enclosure_node *enclosure_dev = NULL;\n\tunsigned long flags;\n\tstruct hba_port *port = mpt3sas_get_port_by_id(\n\t    ioc, sas_device_pg0->PhysicalPort, 0);\n\n\tif (sas_device_pg0->EnclosureHandle) {\n\t\tenclosure_dev =\n\t\t\tmpt3sas_scsih_enclosure_find_by_handle(ioc,\n\t\t\t\tle16_to_cpu(sas_device_pg0->EnclosureHandle));\n\t\tif (enclosure_dev == NULL)\n\t\t\tioc_info(ioc, \"Enclosure handle(0x%04x) doesn't match with enclosure device!\\n\",\n\t\t\t\t sas_device_pg0->EnclosureHandle);\n\t}\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tlist_for_each_entry(sas_device, &ioc->sas_device_list, list) {\n\t\tif (sas_device->sas_address != le64_to_cpu(\n\t\t    sas_device_pg0->SASAddress))\n\t\t\tcontinue;\n\t\tif (sas_device->slot != le16_to_cpu(sas_device_pg0->Slot))\n\t\t\tcontinue;\n\t\tif (sas_device->port != port)\n\t\t\tcontinue;\n\t\tsas_device->responding = 1;\n\t\tstarget = sas_device->starget;\n\t\tif (starget && starget->hostdata) {\n\t\t\tsas_target_priv_data = starget->hostdata;\n\t\t\tsas_target_priv_data->tm_busy = 0;\n\t\t\tsas_target_priv_data->deleted = 0;\n\t\t} else\n\t\t\tsas_target_priv_data = NULL;\n\t\tif (starget) {\n\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t    \"handle(0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t    le16_to_cpu(sas_device_pg0->DevHandle),\n\t\t\t    (unsigned long long)\n\t\t\t    sas_device->sas_address);\n\n\t\t\tif (sas_device->enclosure_handle != 0)\n\t\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\t \"enclosure logical id(0x%016llx), slot(%d)\\n\",\n\t\t\t\t (unsigned long long)\n\t\t\t\t sas_device->enclosure_logical_id,\n\t\t\t\t sas_device->slot);\n\t\t}\n\t\tif (le16_to_cpu(sas_device_pg0->Flags) &\n\t\t      MPI2_SAS_DEVICE0_FLAGS_ENCL_LEVEL_VALID) {\n\t\t\tsas_device->enclosure_level =\n\t\t\t   sas_device_pg0->EnclosureLevel;\n\t\t\tmemcpy(&sas_device->connector_name[0],\n\t\t\t\t&sas_device_pg0->ConnectorName[0], 4);\n\t\t} else {\n\t\t\tsas_device->enclosure_level = 0;\n\t\t\tsas_device->connector_name[0] = '\\0';\n\t\t}\n\n\t\tsas_device->enclosure_handle =\n\t\t\tle16_to_cpu(sas_device_pg0->EnclosureHandle);\n\t\tsas_device->is_chassis_slot_valid = 0;\n\t\tif (enclosure_dev) {\n\t\t\tsas_device->enclosure_logical_id = le64_to_cpu(\n\t\t\t\tenclosure_dev->pg0.EnclosureLogicalID);\n\t\t\tif (le16_to_cpu(enclosure_dev->pg0.Flags) &\n\t\t\t    MPI2_SAS_ENCLS0_FLAGS_CHASSIS_SLOT_VALID) {\n\t\t\t\tsas_device->is_chassis_slot_valid = 1;\n\t\t\t\tsas_device->chassis_slot =\n\t\t\t\t\tenclosure_dev->pg0.ChassisSlot;\n\t\t\t}\n\t\t}\n\n\t\tif (sas_device->handle == le16_to_cpu(\n\t\t    sas_device_pg0->DevHandle))\n\t\t\tgoto out;\n\t\tpr_info(\"\\thandle changed from(0x%04x)!!!\\n\",\n\t\t    sas_device->handle);\n\t\tsas_device->handle = le16_to_cpu(\n\t\t    sas_device_pg0->DevHandle);\n\t\tif (sas_target_priv_data)\n\t\t\tsas_target_priv_data->handle =\n\t\t\t    le16_to_cpu(sas_device_pg0->DevHandle);\n\t\tgoto out;\n\t}\n out:\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n}\n\n/**\n * _scsih_create_enclosure_list_after_reset - Free Existing list,\n *\tAnd create enclosure list by scanning all Enclosure Page(0)s\n * @ioc: per adapter object\n */\nstatic void\n_scsih_create_enclosure_list_after_reset(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _enclosure_node *enclosure_dev;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 enclosure_handle;\n\tint rc;\n\n\t/* Free existing enclosure list */\n\tmpt3sas_free_enclosure_list(ioc);\n\n\t/* Re constructing enclosure list after reset*/\n\tenclosure_handle = 0xFFFF;\n\tdo {\n\t\tenclosure_dev =\n\t\t\tkzalloc(sizeof(struct _enclosure_node), GFP_KERNEL);\n\t\tif (!enclosure_dev) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\treturn;\n\t\t}\n\t\trc = mpt3sas_config_get_enclosure_pg0(ioc, &mpi_reply,\n\t\t\t\t&enclosure_dev->pg0,\n\t\t\t\tMPI2_SAS_ENCLOS_PGAD_FORM_GET_NEXT_HANDLE,\n\t\t\t\tenclosure_handle);\n\n\t\tif (rc || (le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t\t\t\t\tMPI2_IOCSTATUS_MASK)) {\n\t\t\tkfree(enclosure_dev);\n\t\t\treturn;\n\t\t}\n\t\tlist_add_tail(&enclosure_dev->list,\n\t\t\t\t\t\t&ioc->enclosure_list);\n\t\tenclosure_handle =\n\t\t\tle16_to_cpu(enclosure_dev->pg0.EnclosureHandle);\n\t} while (1);\n}\n\n/**\n * _scsih_search_responding_sas_devices -\n * @ioc: per adapter object\n *\n * After host reset, find out whether devices are still responding.\n * If not remove.\n */\nstatic void\n_scsih_search_responding_sas_devices(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 ioc_status;\n\tu16 handle;\n\tu32 device_info;\n\n\tioc_info(ioc, \"search for end-devices: start\\n\");\n\n\tif (list_empty(&ioc->sas_device_list))\n\t\tgoto out;\n\n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply,\n\t    &sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE,\n\t    handle))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\t\tbreak;\n\t\thandle = le16_to_cpu(sas_device_pg0.DevHandle);\n\t\tdevice_info = le32_to_cpu(sas_device_pg0.DeviceInfo);\n\t\tif (!(_scsih_is_end_device(device_info)))\n\t\t\tcontinue;\n\t\t_scsih_mark_responding_sas_device(ioc, &sas_device_pg0);\n\t}\n\n out:\n\tioc_info(ioc, \"search for end-devices: complete\\n\");\n}\n\n/**\n * _scsih_mark_responding_pcie_device - mark a pcie_device as responding\n * @ioc: per adapter object\n * @pcie_device_pg0: PCIe Device page 0\n *\n * After host reset, find out whether devices are still responding.\n * Used in _scsih_remove_unresponding_devices.\n */\nstatic void\n_scsih_mark_responding_pcie_device(struct MPT3SAS_ADAPTER *ioc,\n\tMpi26PCIeDevicePage0_t *pcie_device_pg0)\n{\n\tstruct MPT3SAS_TARGET *sas_target_priv_data = NULL;\n\tstruct scsi_target *starget;\n\tstruct _pcie_device *pcie_device;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tlist_for_each_entry(pcie_device, &ioc->pcie_device_list, list) {\n\t\tif ((pcie_device->wwid == le64_to_cpu(pcie_device_pg0->WWID))\n\t\t    && (pcie_device->slot == le16_to_cpu(\n\t\t    pcie_device_pg0->Slot))) {\n\t\t\tpcie_device->access_status =\n\t\t\t\t\tpcie_device_pg0->AccessStatus;\n\t\t\tpcie_device->responding = 1;\n\t\t\tstarget = pcie_device->starget;\n\t\t\tif (starget && starget->hostdata) {\n\t\t\t\tsas_target_priv_data = starget->hostdata;\n\t\t\t\tsas_target_priv_data->tm_busy = 0;\n\t\t\t\tsas_target_priv_data->deleted = 0;\n\t\t\t} else\n\t\t\t\tsas_target_priv_data = NULL;\n\t\t\tif (starget) {\n\t\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\t    \"handle(0x%04x), wwid(0x%016llx) \",\n\t\t\t\t    pcie_device->handle,\n\t\t\t\t    (unsigned long long)pcie_device->wwid);\n\t\t\t\tif (pcie_device->enclosure_handle != 0)\n\t\t\t\t\tstarget_printk(KERN_INFO, starget,\n\t\t\t\t\t    \"enclosure logical id(0x%016llx), \"\n\t\t\t\t\t    \"slot(%d)\\n\",\n\t\t\t\t\t    (unsigned long long)\n\t\t\t\t\t    pcie_device->enclosure_logical_id,\n\t\t\t\t\t    pcie_device->slot);\n\t\t\t}\n\n\t\t\tif (((le32_to_cpu(pcie_device_pg0->Flags)) &\n\t\t\t    MPI26_PCIEDEV0_FLAGS_ENCL_LEVEL_VALID) &&\n\t\t\t    (ioc->hba_mpi_version_belonged != MPI2_VERSION)) {\n\t\t\t\tpcie_device->enclosure_level =\n\t\t\t\t    pcie_device_pg0->EnclosureLevel;\n\t\t\t\tmemcpy(&pcie_device->connector_name[0],\n\t\t\t\t    &pcie_device_pg0->ConnectorName[0], 4);\n\t\t\t} else {\n\t\t\t\tpcie_device->enclosure_level = 0;\n\t\t\t\tpcie_device->connector_name[0] = '\\0';\n\t\t\t}\n\n\t\t\tif (pcie_device->handle == le16_to_cpu(\n\t\t\t    pcie_device_pg0->DevHandle))\n\t\t\t\tgoto out;\n\t\t\tpr_info(\"\\thandle changed from(0x%04x)!!!\\n\",\n\t\t\t    pcie_device->handle);\n\t\t\tpcie_device->handle = le16_to_cpu(\n\t\t\t    pcie_device_pg0->DevHandle);\n\t\t\tif (sas_target_priv_data)\n\t\t\t\tsas_target_priv_data->handle =\n\t\t\t\t    le16_to_cpu(pcie_device_pg0->DevHandle);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n out:\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n}\n\n/**\n * _scsih_search_responding_pcie_devices -\n * @ioc: per adapter object\n *\n * After host reset, find out whether devices are still responding.\n * If not remove.\n */\nstatic void\n_scsih_search_responding_pcie_devices(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi26PCIeDevicePage0_t pcie_device_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 ioc_status;\n\tu16 handle;\n\tu32 device_info;\n\n\tioc_info(ioc, \"search for end-devices: start\\n\");\n\n\tif (list_empty(&ioc->pcie_device_list))\n\t\tgoto out;\n\n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_pcie_device_pg0(ioc, &mpi_reply,\n\t\t&pcie_device_pg0, MPI26_PCIE_DEVICE_PGAD_FORM_GET_NEXT_HANDLE,\n\t\thandle))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_info(ioc, \"\\tbreak from %s: ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t __func__, ioc_status,\n\t\t\t\t le32_to_cpu(mpi_reply.IOCLogInfo));\n\t\t\tbreak;\n\t\t}\n\t\thandle = le16_to_cpu(pcie_device_pg0.DevHandle);\n\t\tdevice_info = le32_to_cpu(pcie_device_pg0.DeviceInfo);\n\t\tif (!(_scsih_is_nvme_pciescsi_device(device_info)))\n\t\t\tcontinue;\n\t\t_scsih_mark_responding_pcie_device(ioc, &pcie_device_pg0);\n\t}\nout:\n\tioc_info(ioc, \"search for PCIe end-devices: complete\\n\");\n}\n\n/**\n * _scsih_mark_responding_raid_device - mark a raid_device as responding\n * @ioc: per adapter object\n * @wwid: world wide identifier for raid volume\n * @handle: device handle\n *\n * After host reset, find out whether devices are still responding.\n * Used in _scsih_remove_unresponsive_raid_devices.\n */\nstatic void\n_scsih_mark_responding_raid_device(struct MPT3SAS_ADAPTER *ioc, u64 wwid,\n\tu16 handle)\n{\n\tstruct MPT3SAS_TARGET *sas_target_priv_data = NULL;\n\tstruct scsi_target *starget;\n\tstruct _raid_device *raid_device;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\tlist_for_each_entry(raid_device, &ioc->raid_device_list, list) {\n\t\tif (raid_device->wwid == wwid && raid_device->starget) {\n\t\t\tstarget = raid_device->starget;\n\t\t\tif (starget && starget->hostdata) {\n\t\t\t\tsas_target_priv_data = starget->hostdata;\n\t\t\t\tsas_target_priv_data->deleted = 0;\n\t\t\t} else\n\t\t\t\tsas_target_priv_data = NULL;\n\t\t\traid_device->responding = 1;\n\t\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t\t\tstarget_printk(KERN_INFO, raid_device->starget,\n\t\t\t    \"handle(0x%04x), wwid(0x%016llx)\\n\", handle,\n\t\t\t    (unsigned long long)raid_device->wwid);\n\n\t\t\t/*\n\t\t\t * WARPDRIVE: The handles of the PDs might have changed\n\t\t\t * across the host reset so re-initialize the\n\t\t\t * required data for Direct IO\n\t\t\t */\n\t\t\tmpt3sas_init_warpdrive_properties(ioc, raid_device);\n\t\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\t\tif (raid_device->handle == handle) {\n\t\t\t\tspin_unlock_irqrestore(&ioc->raid_device_lock,\n\t\t\t\t    flags);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpr_info(\"\\thandle changed from(0x%04x)!!!\\n\",\n\t\t\t    raid_device->handle);\n\t\t\traid_device->handle = handle;\n\t\t\tif (sas_target_priv_data)\n\t\t\t\tsas_target_priv_data->handle = handle;\n\t\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n}\n\n/**\n * _scsih_search_responding_raid_devices -\n * @ioc: per adapter object\n *\n * After host reset, find out whether devices are still responding.\n * If not remove.\n */\nstatic void\n_scsih_search_responding_raid_devices(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2RaidVolPage1_t volume_pg1;\n\tMpi2RaidVolPage0_t volume_pg0;\n\tMpi2RaidPhysDiskPage0_t pd_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 ioc_status;\n\tu16 handle;\n\tu8 phys_disk_num;\n\n\tif (!ioc->ir_firmware)\n\t\treturn;\n\n\tioc_info(ioc, \"search for raid volumes: start\\n\");\n\n\tif (list_empty(&ioc->raid_device_list))\n\t\tgoto out;\n\n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_raid_volume_pg1(ioc, &mpi_reply,\n\t    &volume_pg1, MPI2_RAID_VOLUME_PGAD_FORM_GET_NEXT_HANDLE, handle))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\t\tbreak;\n\t\thandle = le16_to_cpu(volume_pg1.DevHandle);\n\n\t\tif (mpt3sas_config_get_raid_volume_pg0(ioc, &mpi_reply,\n\t\t    &volume_pg0, MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, handle,\n\t\t     sizeof(Mpi2RaidVolPage0_t)))\n\t\t\tcontinue;\n\n\t\tif (volume_pg0.VolumeState == MPI2_RAID_VOL_STATE_OPTIMAL ||\n\t\t    volume_pg0.VolumeState == MPI2_RAID_VOL_STATE_ONLINE ||\n\t\t    volume_pg0.VolumeState == MPI2_RAID_VOL_STATE_DEGRADED)\n\t\t\t_scsih_mark_responding_raid_device(ioc,\n\t\t\t    le64_to_cpu(volume_pg1.WWID), handle);\n\t}\n\n\t/* refresh the pd_handles */\n\tif (!ioc->is_warpdrive) {\n\t\tphys_disk_num = 0xFF;\n\t\tmemset(ioc->pd_handles, 0, ioc->pd_handles_sz);\n\t\twhile (!(mpt3sas_config_get_phys_disk_pg0(ioc, &mpi_reply,\n\t\t    &pd_pg0, MPI2_PHYSDISK_PGAD_FORM_GET_NEXT_PHYSDISKNUM,\n\t\t    phys_disk_num))) {\n\t\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t\t    MPI2_IOCSTATUS_MASK;\n\t\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\t\t\tbreak;\n\t\t\tphys_disk_num = pd_pg0.PhysDiskNum;\n\t\t\thandle = le16_to_cpu(pd_pg0.DevHandle);\n\t\t\tset_bit(handle, ioc->pd_handles);\n\t\t}\n\t}\n out:\n\tioc_info(ioc, \"search for responding raid volumes: complete\\n\");\n}\n\n/**\n * _scsih_mark_responding_expander - mark a expander as responding\n * @ioc: per adapter object\n * @expander_pg0:SAS Expander Config Page0\n *\n * After host reset, find out whether devices are still responding.\n * Used in _scsih_remove_unresponsive_expanders.\n */\nstatic void\n_scsih_mark_responding_expander(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2ExpanderPage0_t *expander_pg0)\n{\n\tstruct _sas_node *sas_expander = NULL;\n\tunsigned long flags;\n\tint i;\n\tstruct _enclosure_node *enclosure_dev = NULL;\n\tu16 handle = le16_to_cpu(expander_pg0->DevHandle);\n\tu16 enclosure_handle = le16_to_cpu(expander_pg0->EnclosureHandle);\n\tu64 sas_address = le64_to_cpu(expander_pg0->SASAddress);\n\tstruct hba_port *port = mpt3sas_get_port_by_id(\n\t    ioc, expander_pg0->PhysicalPort, 0);\n\n\tif (enclosure_handle)\n\t\tenclosure_dev =\n\t\t\tmpt3sas_scsih_enclosure_find_by_handle(ioc,\n\t\t\t\t\t\t\tenclosure_handle);\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tlist_for_each_entry(sas_expander, &ioc->sas_expander_list, list) {\n\t\tif (sas_expander->sas_address != sas_address)\n\t\t\tcontinue;\n\t\tif (sas_expander->port != port)\n\t\t\tcontinue;\n\t\tsas_expander->responding = 1;\n\n\t\tif (enclosure_dev) {\n\t\t\tsas_expander->enclosure_logical_id =\n\t\t\t    le64_to_cpu(enclosure_dev->pg0.EnclosureLogicalID);\n\t\t\tsas_expander->enclosure_handle =\n\t\t\t    le16_to_cpu(expander_pg0->EnclosureHandle);\n\t\t}\n\n\t\tif (sas_expander->handle == handle)\n\t\t\tgoto out;\n\t\tpr_info(\"\\texpander(0x%016llx): handle changed\" \\\n\t\t    \" from(0x%04x) to (0x%04x)!!!\\n\",\n\t\t    (unsigned long long)sas_expander->sas_address,\n\t\t    sas_expander->handle, handle);\n\t\tsas_expander->handle = handle;\n\t\tfor (i = 0 ; i < sas_expander->num_phys ; i++)\n\t\t\tsas_expander->phy[i].handle = handle;\n\t\tgoto out;\n\t}\n out:\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n}\n\n/**\n * _scsih_search_responding_expanders -\n * @ioc: per adapter object\n *\n * After host reset, find out whether devices are still responding.\n * If not remove.\n */\nstatic void\n_scsih_search_responding_expanders(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2ExpanderPage0_t expander_pg0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 ioc_status;\n\tu64 sas_address;\n\tu16 handle;\n\tu8 port;\n\n\tioc_info(ioc, \"search for expanders: start\\n\");\n\n\tif (list_empty(&ioc->sas_expander_list))\n\t\tgoto out;\n\n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_expander_pg0(ioc, &mpi_reply, &expander_pg0,\n\t    MPI2_SAS_EXPAND_PGAD_FORM_GET_NEXT_HNDL, handle))) {\n\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\t\tbreak;\n\n\t\thandle = le16_to_cpu(expander_pg0.DevHandle);\n\t\tsas_address = le64_to_cpu(expander_pg0.SASAddress);\n\t\tport = expander_pg0.PhysicalPort;\n\t\tpr_info(\n\t\t    \"\\texpander present: handle(0x%04x), sas_addr(0x%016llx), port:%d\\n\",\n\t\t    handle, (unsigned long long)sas_address,\n\t\t    (ioc->multipath_on_hba ?\n\t\t    port : MULTIPATH_DISABLED_PORT_ID));\n\t\t_scsih_mark_responding_expander(ioc, &expander_pg0);\n\t}\n\n out:\n\tioc_info(ioc, \"search for expanders: complete\\n\");\n}\n\n/**\n * _scsih_remove_unresponding_devices - removing unresponding devices\n * @ioc: per adapter object\n */\nstatic void\n_scsih_remove_unresponding_devices(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _sas_device *sas_device, *sas_device_next;\n\tstruct _sas_node *sas_expander, *sas_expander_next;\n\tstruct _raid_device *raid_device, *raid_device_next;\n\tstruct _pcie_device *pcie_device, *pcie_device_next;\n\tstruct list_head tmp_list;\n\tunsigned long flags;\n\tLIST_HEAD(head);\n\n\tioc_info(ioc, \"removing unresponding devices: start\\n\");\n\n\t/* removing unresponding end devices */\n\tioc_info(ioc, \"removing unresponding devices: end-devices\\n\");\n\t/*\n\t * Iterate, pulling off devices marked as non-responding. We become the\n\t * owner for the reference the list had on any object we prune.\n\t */\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tlist_for_each_entry_safe(sas_device, sas_device_next,\n\t    &ioc->sas_device_list, list) {\n\t\tif (!sas_device->responding)\n\t\t\tlist_move_tail(&sas_device->list, &head);\n\t\telse\n\t\t\tsas_device->responding = 0;\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\t/*\n\t * Now, uninitialize and remove the unresponding devices we pruned.\n\t */\n\tlist_for_each_entry_safe(sas_device, sas_device_next, &head, list) {\n\t\t_scsih_remove_device(ioc, sas_device);\n\t\tlist_del_init(&sas_device->list);\n\t\tsas_device_put(sas_device);\n\t}\n\n\tioc_info(ioc, \"Removing unresponding devices: pcie end-devices\\n\");\n\tINIT_LIST_HEAD(&head);\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tlist_for_each_entry_safe(pcie_device, pcie_device_next,\n\t    &ioc->pcie_device_list, list) {\n\t\tif (!pcie_device->responding)\n\t\t\tlist_move_tail(&pcie_device->list, &head);\n\t\telse\n\t\t\tpcie_device->responding = 0;\n\t}\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\tlist_for_each_entry_safe(pcie_device, pcie_device_next, &head, list) {\n\t\t_scsih_pcie_device_remove_from_sml(ioc, pcie_device);\n\t\tlist_del_init(&pcie_device->list);\n\t\tpcie_device_put(pcie_device);\n\t}\n\n\t/* removing unresponding volumes */\n\tif (ioc->ir_firmware) {\n\t\tioc_info(ioc, \"removing unresponding devices: volumes\\n\");\n\t\tlist_for_each_entry_safe(raid_device, raid_device_next,\n\t\t    &ioc->raid_device_list, list) {\n\t\t\tif (!raid_device->responding)\n\t\t\t\t_scsih_sas_volume_delete(ioc,\n\t\t\t\t    raid_device->handle);\n\t\t\telse\n\t\t\t\traid_device->responding = 0;\n\t\t}\n\t}\n\n\t/* removing unresponding expanders */\n\tioc_info(ioc, \"removing unresponding devices: expanders\\n\");\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tINIT_LIST_HEAD(&tmp_list);\n\tlist_for_each_entry_safe(sas_expander, sas_expander_next,\n\t    &ioc->sas_expander_list, list) {\n\t\tif (!sas_expander->responding)\n\t\t\tlist_move_tail(&sas_expander->list, &tmp_list);\n\t\telse\n\t\t\tsas_expander->responding = 0;\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\tlist_for_each_entry_safe(sas_expander, sas_expander_next, &tmp_list,\n\t    list) {\n\t\t_scsih_expander_node_remove(ioc, sas_expander);\n\t}\n\n\tioc_info(ioc, \"removing unresponding devices: complete\\n\");\n\n\t/* unblock devices */\n\t_scsih_ublock_io_all_device(ioc);\n}\n\nstatic void\n_scsih_refresh_expander_links(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_node *sas_expander, u16 handle)\n{\n\tMpi2ExpanderPage1_t expander_pg1;\n\tMpi2ConfigReply_t mpi_reply;\n\tint i;\n\n\tfor (i = 0 ; i < sas_expander->num_phys ; i++) {\n\t\tif ((mpt3sas_config_get_expander_pg1(ioc, &mpi_reply,\n\t\t    &expander_pg1, i, handle))) {\n\t\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t\t__FILE__, __LINE__, __func__);\n\t\t\treturn;\n\t\t}\n\n\t\tmpt3sas_transport_update_links(ioc, sas_expander->sas_address,\n\t\t    le16_to_cpu(expander_pg1.AttachedDevHandle), i,\n\t\t    expander_pg1.NegotiatedLinkRate >> 4,\n\t\t    sas_expander->port);\n\t}\n}\n\n/**\n * _scsih_scan_for_devices_after_reset - scan for devices after host reset\n * @ioc: per adapter object\n */\nstatic void\n_scsih_scan_for_devices_after_reset(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2ExpanderPage0_t expander_pg0;\n\tMpi2SasDevicePage0_t sas_device_pg0;\n\tMpi26PCIeDevicePage0_t pcie_device_pg0;\n\tMpi2RaidVolPage1_t volume_pg1;\n\tMpi2RaidVolPage0_t volume_pg0;\n\tMpi2RaidPhysDiskPage0_t pd_pg0;\n\tMpi2EventIrConfigElement_t element;\n\tMpi2ConfigReply_t mpi_reply;\n\tu8 phys_disk_num, port_id;\n\tu16 ioc_status;\n\tu16 handle, parent_handle;\n\tu64 sas_address;\n\tstruct _sas_device *sas_device;\n\tstruct _pcie_device *pcie_device;\n\tstruct _sas_node *expander_device;\n\tstatic struct _raid_device *raid_device;\n\tu8 retry_count;\n\tunsigned long flags;\n\n\tioc_info(ioc, \"scan devices: start\\n\");\n\n\t_scsih_sas_host_refresh(ioc);\n\n\tioc_info(ioc, \"\\tscan devices: expanders start\\n\");\n\n\t/* expanders */\n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_expander_pg0(ioc, &mpi_reply, &expander_pg0,\n\t    MPI2_SAS_EXPAND_PGAD_FORM_GET_NEXT_HNDL, handle))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_info(ioc, \"\\tbreak from expander scan: ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t ioc_status, le32_to_cpu(mpi_reply.IOCLogInfo));\n\t\t\tbreak;\n\t\t}\n\t\thandle = le16_to_cpu(expander_pg0.DevHandle);\n\t\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\t\tport_id = expander_pg0.PhysicalPort;\n\t\texpander_device = mpt3sas_scsih_expander_find_by_sas_address(\n\t\t    ioc, le64_to_cpu(expander_pg0.SASAddress),\n\t\t    mpt3sas_get_port_by_id(ioc, port_id, 0));\n\t\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\t\tif (expander_device)\n\t\t\t_scsih_refresh_expander_links(ioc, expander_device,\n\t\t\t    handle);\n\t\telse {\n\t\t\tioc_info(ioc, \"\\tBEFORE adding expander: handle (0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t\t handle,\n\t\t\t\t (u64)le64_to_cpu(expander_pg0.SASAddress));\n\t\t\t_scsih_expander_add(ioc, handle);\n\t\t\tioc_info(ioc, \"\\tAFTER adding expander: handle (0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t\t handle,\n\t\t\t\t (u64)le64_to_cpu(expander_pg0.SASAddress));\n\t\t}\n\t}\n\n\tioc_info(ioc, \"\\tscan devices: expanders complete\\n\");\n\n\tif (!ioc->ir_firmware)\n\t\tgoto skip_to_sas;\n\n\tioc_info(ioc, \"\\tscan devices: phys disk start\\n\");\n\n\t/* phys disk */\n\tphys_disk_num = 0xFF;\n\twhile (!(mpt3sas_config_get_phys_disk_pg0(ioc, &mpi_reply,\n\t    &pd_pg0, MPI2_PHYSDISK_PGAD_FORM_GET_NEXT_PHYSDISKNUM,\n\t    phys_disk_num))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_info(ioc, \"\\tbreak from phys disk scan: ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t ioc_status, le32_to_cpu(mpi_reply.IOCLogInfo));\n\t\t\tbreak;\n\t\t}\n\t\tphys_disk_num = pd_pg0.PhysDiskNum;\n\t\thandle = le16_to_cpu(pd_pg0.DevHandle);\n\t\tsas_device = mpt3sas_get_sdev_by_handle(ioc, handle);\n\t\tif (sas_device) {\n\t\t\tsas_device_put(sas_device);\n\t\t\tcontinue;\n\t\t}\n\t\tif (mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply,\n\t\t    &sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_HANDLE,\n\t\t    handle) != 0)\n\t\t\tcontinue;\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_info(ioc, \"\\tbreak from phys disk scan ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t ioc_status, le32_to_cpu(mpi_reply.IOCLogInfo));\n\t\t\tbreak;\n\t\t}\n\t\tparent_handle = le16_to_cpu(sas_device_pg0.ParentDevHandle);\n\t\tif (!_scsih_get_sas_address(ioc, parent_handle,\n\t\t    &sas_address)) {\n\t\t\tioc_info(ioc, \"\\tBEFORE adding phys disk: handle (0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t\t handle,\n\t\t\t\t (u64)le64_to_cpu(sas_device_pg0.SASAddress));\n\t\t\tport_id = sas_device_pg0.PhysicalPort;\n\t\t\tmpt3sas_transport_update_links(ioc, sas_address,\n\t\t\t    handle, sas_device_pg0.PhyNum,\n\t\t\t    MPI2_SAS_NEG_LINK_RATE_1_5,\n\t\t\t    mpt3sas_get_port_by_id(ioc, port_id, 0));\n\t\t\tset_bit(handle, ioc->pd_handles);\n\t\t\tretry_count = 0;\n\t\t\t/* This will retry adding the end device.\n\t\t\t * _scsih_add_device() will decide on retries and\n\t\t\t * return \"1\" when it should be retried\n\t\t\t */\n\t\t\twhile (_scsih_add_device(ioc, handle, retry_count++,\n\t\t\t    1)) {\n\t\t\t\tssleep(1);\n\t\t\t}\n\t\t\tioc_info(ioc, \"\\tAFTER adding phys disk: handle (0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t\t handle,\n\t\t\t\t (u64)le64_to_cpu(sas_device_pg0.SASAddress));\n\t\t}\n\t}\n\n\tioc_info(ioc, \"\\tscan devices: phys disk complete\\n\");\n\n\tioc_info(ioc, \"\\tscan devices: volumes start\\n\");\n\n\t/* volumes */\n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_raid_volume_pg1(ioc, &mpi_reply,\n\t    &volume_pg1, MPI2_RAID_VOLUME_PGAD_FORM_GET_NEXT_HANDLE, handle))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_info(ioc, \"\\tbreak from volume scan: ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t ioc_status, le32_to_cpu(mpi_reply.IOCLogInfo));\n\t\t\tbreak;\n\t\t}\n\t\thandle = le16_to_cpu(volume_pg1.DevHandle);\n\t\tspin_lock_irqsave(&ioc->raid_device_lock, flags);\n\t\traid_device = _scsih_raid_device_find_by_wwid(ioc,\n\t\t    le64_to_cpu(volume_pg1.WWID));\n\t\tspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\n\t\tif (raid_device)\n\t\t\tcontinue;\n\t\tif (mpt3sas_config_get_raid_volume_pg0(ioc, &mpi_reply,\n\t\t    &volume_pg0, MPI2_RAID_VOLUME_PGAD_FORM_HANDLE, handle,\n\t\t     sizeof(Mpi2RaidVolPage0_t)))\n\t\t\tcontinue;\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_info(ioc, \"\\tbreak from volume scan: ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t ioc_status, le32_to_cpu(mpi_reply.IOCLogInfo));\n\t\t\tbreak;\n\t\t}\n\t\tif (volume_pg0.VolumeState == MPI2_RAID_VOL_STATE_OPTIMAL ||\n\t\t    volume_pg0.VolumeState == MPI2_RAID_VOL_STATE_ONLINE ||\n\t\t    volume_pg0.VolumeState == MPI2_RAID_VOL_STATE_DEGRADED) {\n\t\t\tmemset(&element, 0, sizeof(Mpi2EventIrConfigElement_t));\n\t\t\telement.ReasonCode = MPI2_EVENT_IR_CHANGE_RC_ADDED;\n\t\t\telement.VolDevHandle = volume_pg1.DevHandle;\n\t\t\tioc_info(ioc, \"\\tBEFORE adding volume: handle (0x%04x)\\n\",\n\t\t\t\t volume_pg1.DevHandle);\n\t\t\t_scsih_sas_volume_add(ioc, &element);\n\t\t\tioc_info(ioc, \"\\tAFTER adding volume: handle (0x%04x)\\n\",\n\t\t\t\t volume_pg1.DevHandle);\n\t\t}\n\t}\n\n\tioc_info(ioc, \"\\tscan devices: volumes complete\\n\");\n\n skip_to_sas:\n\n\tioc_info(ioc, \"\\tscan devices: end devices start\\n\");\n\n\t/* sas devices */\n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply,\n\t    &sas_device_pg0, MPI2_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE,\n\t    handle))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t    MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_info(ioc, \"\\tbreak from end device scan: ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t ioc_status, le32_to_cpu(mpi_reply.IOCLogInfo));\n\t\t\tbreak;\n\t\t}\n\t\thandle = le16_to_cpu(sas_device_pg0.DevHandle);\n\t\tif (!(_scsih_is_end_device(\n\t\t    le32_to_cpu(sas_device_pg0.DeviceInfo))))\n\t\t\tcontinue;\n\t\tport_id = sas_device_pg0.PhysicalPort;\n\t\tsas_device = mpt3sas_get_sdev_by_addr(ioc,\n\t\t    le64_to_cpu(sas_device_pg0.SASAddress),\n\t\t    mpt3sas_get_port_by_id(ioc, port_id, 0));\n\t\tif (sas_device) {\n\t\t\tsas_device_put(sas_device);\n\t\t\tcontinue;\n\t\t}\n\t\tparent_handle = le16_to_cpu(sas_device_pg0.ParentDevHandle);\n\t\tif (!_scsih_get_sas_address(ioc, parent_handle, &sas_address)) {\n\t\t\tioc_info(ioc, \"\\tBEFORE adding end device: handle (0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t\t handle,\n\t\t\t\t (u64)le64_to_cpu(sas_device_pg0.SASAddress));\n\t\t\tmpt3sas_transport_update_links(ioc, sas_address, handle,\n\t\t\t    sas_device_pg0.PhyNum, MPI2_SAS_NEG_LINK_RATE_1_5,\n\t\t\t    mpt3sas_get_port_by_id(ioc, port_id, 0));\n\t\t\tretry_count = 0;\n\t\t\t/* This will retry adding the end device.\n\t\t\t * _scsih_add_device() will decide on retries and\n\t\t\t * return \"1\" when it should be retried\n\t\t\t */\n\t\t\twhile (_scsih_add_device(ioc, handle, retry_count++,\n\t\t\t    0)) {\n\t\t\t\tssleep(1);\n\t\t\t}\n\t\t\tioc_info(ioc, \"\\tAFTER adding end device: handle (0x%04x), sas_addr(0x%016llx)\\n\",\n\t\t\t\t handle,\n\t\t\t\t (u64)le64_to_cpu(sas_device_pg0.SASAddress));\n\t\t}\n\t}\n\tioc_info(ioc, \"\\tscan devices: end devices complete\\n\");\n\tioc_info(ioc, \"\\tscan devices: pcie end devices start\\n\");\n\n\t/* pcie devices */\n\thandle = 0xFFFF;\n\twhile (!(mpt3sas_config_get_pcie_device_pg0(ioc, &mpi_reply,\n\t\t&pcie_device_pg0, MPI26_PCIE_DEVICE_PGAD_FORM_GET_NEXT_HANDLE,\n\t\thandle))) {\n\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus)\n\t\t\t\t& MPI2_IOCSTATUS_MASK;\n\t\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tioc_info(ioc, \"\\tbreak from pcie end device scan: ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t ioc_status, le32_to_cpu(mpi_reply.IOCLogInfo));\n\t\t\tbreak;\n\t\t}\n\t\thandle = le16_to_cpu(pcie_device_pg0.DevHandle);\n\t\tif (!(_scsih_is_nvme_pciescsi_device(\n\t\t\tle32_to_cpu(pcie_device_pg0.DeviceInfo))))\n\t\t\tcontinue;\n\t\tpcie_device = mpt3sas_get_pdev_by_wwid(ioc,\n\t\t\t\tle64_to_cpu(pcie_device_pg0.WWID));\n\t\tif (pcie_device) {\n\t\t\tpcie_device_put(pcie_device);\n\t\t\tcontinue;\n\t\t}\n\t\tretry_count = 0;\n\t\tparent_handle = le16_to_cpu(pcie_device_pg0.ParentDevHandle);\n\t\t_scsih_pcie_add_device(ioc, handle);\n\n\t\tioc_info(ioc, \"\\tAFTER adding pcie end device: handle (0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t handle, (u64)le64_to_cpu(pcie_device_pg0.WWID));\n\t}\n\tioc_info(ioc, \"\\tpcie devices: pcie end devices complete\\n\");\n\tioc_info(ioc, \"scan devices: complete\\n\");\n}\n\n/**\n * mpt3sas_scsih_reset_handler - reset callback handler (for scsih)\n * @ioc: per adapter object\n *\n * The handler for doing any required cleanup or initialization.\n */\nvoid mpt3sas_scsih_pre_reset_handler(struct MPT3SAS_ADAPTER *ioc)\n{\n\tdtmprintk(ioc, ioc_info(ioc, \"%s: MPT3_IOC_PRE_RESET\\n\", __func__));\n}\n\n/**\n * mpt3sas_scsih_clear_outstanding_scsi_tm_commands - clears outstanding\n *\t\t\t\t\t\t\tscsi & tm cmds.\n * @ioc: per adapter object\n *\n * The handler for doing any required cleanup or initialization.\n */\nvoid\nmpt3sas_scsih_clear_outstanding_scsi_tm_commands(struct MPT3SAS_ADAPTER *ioc)\n{\n\tdtmprintk(ioc,\n\t    ioc_info(ioc, \"%s: clear outstanding scsi & tm cmds\\n\", __func__));\n\tif (ioc->scsih_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc->scsih_cmds.status |= MPT3_CMD_RESET;\n\t\tmpt3sas_base_free_smid(ioc, ioc->scsih_cmds.smid);\n\t\tcomplete(&ioc->scsih_cmds.done);\n\t}\n\tif (ioc->tm_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc->tm_cmds.status |= MPT3_CMD_RESET;\n\t\tmpt3sas_base_free_smid(ioc, ioc->tm_cmds.smid);\n\t\tcomplete(&ioc->tm_cmds.done);\n\t}\n\n\tmemset(ioc->pend_os_device_add, 0, ioc->pend_os_device_add_sz);\n\tmemset(ioc->device_remove_in_progress, 0,\n\t       ioc->device_remove_in_progress_sz);\n\t_scsih_fw_event_cleanup_queue(ioc);\n\t_scsih_flush_running_cmds(ioc);\n}\n\n/**\n * mpt3sas_scsih_reset_handler - reset callback handler (for scsih)\n * @ioc: per adapter object\n *\n * The handler for doing any required cleanup or initialization.\n */\nvoid\nmpt3sas_scsih_reset_done_handler(struct MPT3SAS_ADAPTER *ioc)\n{\n\tdtmprintk(ioc, ioc_info(ioc, \"%s: MPT3_IOC_DONE_RESET\\n\", __func__));\n\tif ((!ioc->is_driver_loading) && !(disable_discovery > 0 &&\n\t\t\t\t\t   !ioc->sas_hba.num_phys)) {\n\t\tif (ioc->multipath_on_hba) {\n\t\t\t_scsih_sas_port_refresh(ioc);\n\t\t\t_scsih_update_vphys_after_reset(ioc);\n\t\t}\n\t\t_scsih_prep_device_scan(ioc);\n\t\t_scsih_create_enclosure_list_after_reset(ioc);\n\t\t_scsih_search_responding_sas_devices(ioc);\n\t\t_scsih_search_responding_pcie_devices(ioc);\n\t\t_scsih_search_responding_raid_devices(ioc);\n\t\t_scsih_search_responding_expanders(ioc);\n\t\t_scsih_error_recovery_delete_devices(ioc);\n\t}\n}\n\n/**\n * _mpt3sas_fw_work - delayed task for processing firmware events\n * @ioc: per adapter object\n * @fw_event: The fw_event_work object\n * Context: user.\n */\nstatic void\n_mpt3sas_fw_work(struct MPT3SAS_ADAPTER *ioc, struct fw_event_work *fw_event)\n{\n\tioc->current_event = fw_event;\n\t_scsih_fw_event_del_from_list(ioc, fw_event);\n\n\t/* the queue is being flushed so ignore this event */\n\tif (ioc->remove_host || ioc->pci_error_recovery) {\n\t\tfw_event_work_put(fw_event);\n\t\tioc->current_event = NULL;\n\t\treturn;\n\t}\n\n\tswitch (fw_event->event) {\n\tcase MPT3SAS_PROCESS_TRIGGER_DIAG:\n\t\tmpt3sas_process_trigger_data(ioc,\n\t\t\t(struct SL_WH_TRIGGERS_EVENT_DATA_T *)\n\t\t\tfw_event->event_data);\n\t\tbreak;\n\tcase MPT3SAS_REMOVE_UNRESPONDING_DEVICES:\n\t\twhile (scsi_host_in_recovery(ioc->shost) ||\n\t\t\t\t\t ioc->shost_recovery) {\n\t\t\t/*\n\t\t\t * If we're unloading or cancelling the work, bail.\n\t\t\t * Otherwise, this can become an infinite loop.\n\t\t\t */\n\t\t\tif (ioc->remove_host || ioc->fw_events_cleanup)\n\t\t\t\tgoto out;\n\t\t\tssleep(1);\n\t\t}\n\t\t_scsih_remove_unresponding_devices(ioc);\n\t\t_scsih_del_dirty_vphy(ioc);\n\t\t_scsih_del_dirty_port_entries(ioc);\n\t\t_scsih_scan_for_devices_after_reset(ioc);\n\t\t_scsih_set_nvme_max_shutdown_latency(ioc);\n\t\tbreak;\n\tcase MPT3SAS_PORT_ENABLE_COMPLETE:\n\t\tioc->start_scan = 0;\n\t\tif (missing_delay[0] != -1 && missing_delay[1] != -1)\n\t\t\tmpt3sas_base_update_missing_delay(ioc, missing_delay[0],\n\t\t\t    missing_delay[1]);\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"port enable: complete from worker thread\\n\"));\n\t\tbreak;\n\tcase MPT3SAS_TURN_ON_PFA_LED:\n\t\t_scsih_turn_on_pfa_led(ioc, fw_event->device_handle);\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST:\n\t\t_scsih_sas_topology_change_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE:\n\t\tif (ioc->logging_level & MPT_DEBUG_EVENT_WORK_TASK)\n\t\t\t_scsih_sas_device_status_change_event_debug(ioc,\n\t\t\t    (Mpi2EventDataSasDeviceStatusChange_t *)\n\t\t\t    fw_event->event_data);\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DISCOVERY:\n\t\t_scsih_sas_discovery_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEVICE_DISCOVERY_ERROR:\n\t\t_scsih_sas_device_discovery_error_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_BROADCAST_PRIMITIVE:\n\t\t_scsih_sas_broadcast_primitive_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE:\n\t\t_scsih_sas_enclosure_dev_status_change_event(ioc,\n\t\t    fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_IR_CONFIGURATION_CHANGE_LIST:\n\t\t_scsih_sas_ir_config_change_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_IR_VOLUME:\n\t\t_scsih_sas_ir_volume_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_IR_PHYSICAL_DISK:\n\t\t_scsih_sas_ir_physical_disk_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_IR_OPERATION_STATUS:\n\t\t_scsih_sas_ir_operation_status_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_PCIE_DEVICE_STATUS_CHANGE:\n\t\t_scsih_pcie_device_status_change_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_PCIE_ENUMERATION:\n\t\t_scsih_pcie_enumeration_event(ioc, fw_event);\n\t\tbreak;\n\tcase MPI2_EVENT_PCIE_TOPOLOGY_CHANGE_LIST:\n\t\t_scsih_pcie_topology_change_event(ioc, fw_event);\n\t\tioc->current_event = NULL;\n\t\t\treturn;\n\tbreak;\n\t}\nout:\n\tfw_event_work_put(fw_event);\n\tioc->current_event = NULL;\n}\n\n/**\n * _firmware_event_work\n * @work: The fw_event_work object\n * Context: user.\n *\n * wrappers for the work thread handling firmware events\n */\n\nstatic void\n_firmware_event_work(struct work_struct *work)\n{\n\tstruct fw_event_work *fw_event = container_of(work,\n\t    struct fw_event_work, work);\n\n\t_mpt3sas_fw_work(fw_event->ioc, fw_event);\n}\n\n/**\n * mpt3sas_scsih_event_callback - firmware event handler (called at ISR time)\n * @ioc: per adapter object\n * @msix_index: MSIX table index supplied by the OS\n * @reply: reply message frame(lower 32bit addr)\n * Context: interrupt.\n *\n * This function merely adds a new work task into ioc->firmware_event_thread.\n * The tasks are worked from _firmware_event_work in user context.\n *\n * Return: 1 meaning mf should be freed from _base_interrupt\n *         0 means the mf is freed from this function.\n */\nu8\nmpt3sas_scsih_event_callback(struct MPT3SAS_ADAPTER *ioc, u8 msix_index,\n\tu32 reply)\n{\n\tstruct fw_event_work *fw_event;\n\tMpi2EventNotificationReply_t *mpi_reply;\n\tu16 event;\n\tu16 sz;\n\tMpi26EventDataActiveCableExcept_t *ActiveCableEventData;\n\n\t/* events turned off due to host reset */\n\tif (ioc->pci_error_recovery)\n\t\treturn 1;\n\n\tmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\n\tif (unlikely(!mpi_reply)) {\n\t\tioc_err(ioc, \"mpi_reply not valid at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn 1;\n\t}\n\n\tevent = le16_to_cpu(mpi_reply->Event);\n\n\tif (event != MPI2_EVENT_LOG_ENTRY_ADDED)\n\t\tmpt3sas_trigger_event(ioc, event, 0);\n\n\tswitch (event) {\n\t/* handle these */\n\tcase MPI2_EVENT_SAS_BROADCAST_PRIMITIVE:\n\t{\n\t\tMpi2EventDataSasBroadcastPrimitive_t *baen_data =\n\t\t    (Mpi2EventDataSasBroadcastPrimitive_t *)\n\t\t    mpi_reply->EventData;\n\n\t\tif (baen_data->Primitive !=\n\t\t    MPI2_EVENT_PRIMITIVE_ASYNCHRONOUS_EVENT)\n\t\t\treturn 1;\n\n\t\tif (ioc->broadcast_aen_busy) {\n\t\t\tioc->broadcast_aen_pending++;\n\t\t\treturn 1;\n\t\t} else\n\t\t\tioc->broadcast_aen_busy = 1;\n\t\tbreak;\n\t}\n\n\tcase MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST:\n\t\t_scsih_check_topo_delete_events(ioc,\n\t\t    (Mpi2EventDataSasTopologyChangeList_t *)\n\t\t    mpi_reply->EventData);\n\t\tbreak;\n\tcase MPI2_EVENT_PCIE_TOPOLOGY_CHANGE_LIST:\n\t_scsih_check_pcie_topo_remove_events(ioc,\n\t\t    (Mpi26EventDataPCIeTopologyChangeList_t *)\n\t\t    mpi_reply->EventData);\n\t\tbreak;\n\tcase MPI2_EVENT_IR_CONFIGURATION_CHANGE_LIST:\n\t\t_scsih_check_ir_config_unhide_events(ioc,\n\t\t    (Mpi2EventDataIrConfigChangeList_t *)\n\t\t    mpi_reply->EventData);\n\t\tbreak;\n\tcase MPI2_EVENT_IR_VOLUME:\n\t\t_scsih_check_volume_delete_events(ioc,\n\t\t    (Mpi2EventDataIrVolume_t *)\n\t\t    mpi_reply->EventData);\n\t\tbreak;\n\tcase MPI2_EVENT_LOG_ENTRY_ADDED:\n\t{\n\t\tMpi2EventDataLogEntryAdded_t *log_entry;\n\t\tu32 *log_code;\n\n\t\tif (!ioc->is_warpdrive)\n\t\t\tbreak;\n\n\t\tlog_entry = (Mpi2EventDataLogEntryAdded_t *)\n\t\t    mpi_reply->EventData;\n\t\tlog_code = (u32 *)log_entry->LogData;\n\n\t\tif (le16_to_cpu(log_entry->LogEntryQualifier)\n\t\t    != MPT2_WARPDRIVE_LOGENTRY)\n\t\t\tbreak;\n\n\t\tswitch (le32_to_cpu(*log_code)) {\n\t\tcase MPT2_WARPDRIVE_LC_SSDT:\n\t\t\tioc_warn(ioc, \"WarpDrive Warning: IO Throttling has occurred in the WarpDrive subsystem. Check WarpDrive documentation for additional details.\\n\");\n\t\t\tbreak;\n\t\tcase MPT2_WARPDRIVE_LC_SSDLW:\n\t\t\tioc_warn(ioc, \"WarpDrive Warning: Program/Erase Cycles for the WarpDrive subsystem in degraded range. Check WarpDrive documentation for additional details.\\n\");\n\t\t\tbreak;\n\t\tcase MPT2_WARPDRIVE_LC_SSDLF:\n\t\t\tioc_err(ioc, \"WarpDrive Fatal Error: There are no Program/Erase Cycles for the WarpDrive subsystem. The storage device will be in read-only mode. Check WarpDrive documentation for additional details.\\n\");\n\t\t\tbreak;\n\t\tcase MPT2_WARPDRIVE_LC_BRMF:\n\t\t\tioc_err(ioc, \"WarpDrive Fatal Error: The Backup Rail Monitor has failed on the WarpDrive subsystem. Check WarpDrive documentation for additional details.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE:\n\t\t_scsih_sas_device_status_change_event(ioc,\n\t\t    (Mpi2EventDataSasDeviceStatusChange_t *)\n\t\t    mpi_reply->EventData);\n\t\tbreak;\n\tcase MPI2_EVENT_IR_OPERATION_STATUS:\n\tcase MPI2_EVENT_SAS_DISCOVERY:\n\tcase MPI2_EVENT_SAS_DEVICE_DISCOVERY_ERROR:\n\tcase MPI2_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE:\n\tcase MPI2_EVENT_IR_PHYSICAL_DISK:\n\tcase MPI2_EVENT_PCIE_ENUMERATION:\n\tcase MPI2_EVENT_PCIE_DEVICE_STATUS_CHANGE:\n\t\tbreak;\n\n\tcase MPI2_EVENT_TEMP_THRESHOLD:\n\t\t_scsih_temp_threshold_events(ioc,\n\t\t\t(Mpi2EventDataTemperature_t *)\n\t\t\tmpi_reply->EventData);\n\t\tbreak;\n\tcase MPI2_EVENT_ACTIVE_CABLE_EXCEPTION:\n\t\tActiveCableEventData =\n\t\t    (Mpi26EventDataActiveCableExcept_t *) mpi_reply->EventData;\n\t\tswitch (ActiveCableEventData->ReasonCode) {\n\t\tcase MPI26_EVENT_ACTIVE_CABLE_INSUFFICIENT_POWER:\n\t\t\tioc_notice(ioc, \"Currently an active cable with ReceptacleID %d\\n\",\n\t\t\t\t   ActiveCableEventData->ReceptacleID);\n\t\t\tpr_notice(\"cannot be powered and devices connected\\n\");\n\t\t\tpr_notice(\"to this active cable will not be seen\\n\");\n\t\t\tpr_notice(\"This active cable requires %d mW of power\\n\",\n\t\t\t     ActiveCableEventData->ActiveCablePowerRequirement);\n\t\t\tbreak;\n\n\t\tcase MPI26_EVENT_ACTIVE_CABLE_DEGRADED:\n\t\t\tioc_notice(ioc, \"Currently a cable with ReceptacleID %d\\n\",\n\t\t\t\t   ActiveCableEventData->ReceptacleID);\n\t\t\tpr_notice(\n\t\t\t    \"is not running at optimal speed(12 Gb/s rate)\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault: /* ignore the rest */\n\t\treturn 1;\n\t}\n\n\tsz = le16_to_cpu(mpi_reply->EventDataLength) * 4;\n\tfw_event = alloc_fw_event_work(sz);\n\tif (!fw_event) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn 1;\n\t}\n\n\tmemcpy(fw_event->event_data, mpi_reply->EventData, sz);\n\tfw_event->ioc = ioc;\n\tfw_event->VF_ID = mpi_reply->VF_ID;\n\tfw_event->VP_ID = mpi_reply->VP_ID;\n\tfw_event->event = event;\n\t_scsih_fw_event_add(ioc, fw_event);\n\tfw_event_work_put(fw_event);\n\treturn 1;\n}\n\n/**\n * _scsih_expander_node_remove - removing expander device from list.\n * @ioc: per adapter object\n * @sas_expander: the sas_device object\n *\n * Removing object and freeing associated memory from the\n * ioc->sas_expander_list.\n */\nstatic void\n_scsih_expander_node_remove(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _sas_node *sas_expander)\n{\n\tstruct _sas_port *mpt3sas_port, *next;\n\tunsigned long flags;\n\n\t/* remove sibling ports attached to this expander */\n\tlist_for_each_entry_safe(mpt3sas_port, next,\n\t   &sas_expander->sas_port_list, port_list) {\n\t\tif (ioc->shost_recovery)\n\t\t\treturn;\n\t\tif (mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_END_DEVICE)\n\t\t\tmpt3sas_device_remove_by_sas_address(ioc,\n\t\t\t    mpt3sas_port->remote_identify.sas_address,\n\t\t\t    mpt3sas_port->hba_port);\n\t\telse if (mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\tmpt3sas_expander_remove(ioc,\n\t\t\t    mpt3sas_port->remote_identify.sas_address,\n\t\t\t    mpt3sas_port->hba_port);\n\t}\n\n\tmpt3sas_transport_port_remove(ioc, sas_expander->sas_address,\n\t    sas_expander->sas_address_parent, sas_expander->port);\n\n\tioc_info(ioc,\n\t    \"expander_remove: handle(0x%04x), sas_addr(0x%016llx), port:%d\\n\",\n\t    sas_expander->handle, (unsigned long long)\n\t    sas_expander->sas_address,\n\t    sas_expander->port->port_id);\n\n\tspin_lock_irqsave(&ioc->sas_node_lock, flags);\n\tlist_del(&sas_expander->list);\n\tspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\n\n\tkfree(sas_expander->phy);\n\tkfree(sas_expander);\n}\n\n/**\n * _scsih_nvme_shutdown - NVMe shutdown notification\n * @ioc: per adapter object\n *\n * Sending IoUnitControl request with shutdown operation code to alert IOC that\n * the host system is shutting down so that IOC can issue NVMe shutdown to\n * NVMe drives attached to it.\n */\nstatic void\n_scsih_nvme_shutdown(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi26IoUnitControlRequest_t *mpi_request;\n\tMpi26IoUnitControlReply_t *mpi_reply;\n\tu16 smid;\n\n\t/* are there any NVMe devices ? */\n\tif (list_empty(&ioc->pcie_device_list))\n\t\treturn;\n\n\tmutex_lock(&ioc->scsih_cmds.mutex);\n\n\tif (ioc->scsih_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: scsih_cmd in use\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tioc->scsih_cmds.status = MPT3_CMD_PENDING;\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->scsih_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc,\n\t\t    \"%s: failed obtaining a smid\\n\", __func__);\n\t\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\n\t\tgoto out;\n\t}\n\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->scsih_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi26IoUnitControlRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_IO_UNIT_CONTROL;\n\tmpi_request->Operation = MPI26_CTRL_OP_SHUTDOWN;\n\n\tinit_completion(&ioc->scsih_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\t/* Wait for max_shutdown_latency seconds */\n\tioc_info(ioc,\n\t\t\"Io Unit Control shutdown (sending), Shutdown latency %d sec\\n\",\n\t\tioc->max_shutdown_latency);\n\twait_for_completion_timeout(&ioc->scsih_cmds.done,\n\t\t\tioc->max_shutdown_latency*HZ);\n\n\tif (!(ioc->scsih_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tioc_err(ioc, \"%s: timeout\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tif (ioc->scsih_cmds.status & MPT3_CMD_REPLY_VALID) {\n\t\tmpi_reply = ioc->scsih_cmds.reply;\n\t\tioc_info(ioc, \"Io Unit Control shutdown (complete):\"\n\t\t\t\"ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\tle16_to_cpu(mpi_reply->IOCStatus),\n\t\t\tle32_to_cpu(mpi_reply->IOCLogInfo));\n\t}\n out:\n\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\n\tmutex_unlock(&ioc->scsih_cmds.mutex);\n}\n\n\n/**\n * _scsih_ir_shutdown - IR shutdown notification\n * @ioc: per adapter object\n *\n * Sending RAID Action to alert the Integrated RAID subsystem of the IOC that\n * the host system is shutting down.\n */\nstatic void\n_scsih_ir_shutdown(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2RaidActionRequest_t *mpi_request;\n\tMpi2RaidActionReply_t *mpi_reply;\n\tu16 smid;\n\n\t/* is IR firmware build loaded ? */\n\tif (!ioc->ir_firmware)\n\t\treturn;\n\n\t/* are there any volumes ? */\n\tif (list_empty(&ioc->raid_device_list))\n\t\treturn;\n\n\tmutex_lock(&ioc->scsih_cmds.mutex);\n\n\tif (ioc->scsih_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: scsih_cmd in use\\n\", __func__);\n\t\tgoto out;\n\t}\n\tioc->scsih_cmds.status = MPT3_CMD_PENDING;\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->scsih_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\n\t\tgoto out;\n\t}\n\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->scsih_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi2RaidActionRequest_t));\n\n\tmpi_request->Function = MPI2_FUNCTION_RAID_ACTION;\n\tmpi_request->Action = MPI2_RAID_ACTION_SYSTEM_SHUTDOWN_INITIATED;\n\n\tif (!ioc->hide_ir_msg)\n\t\tioc_info(ioc, \"IR shutdown (sending)\\n\");\n\tinit_completion(&ioc->scsih_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->scsih_cmds.done, 10*HZ);\n\n\tif (!(ioc->scsih_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tioc_err(ioc, \"%s: timeout\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tif (ioc->scsih_cmds.status & MPT3_CMD_REPLY_VALID) {\n\t\tmpi_reply = ioc->scsih_cmds.reply;\n\t\tif (!ioc->hide_ir_msg)\n\t\t\tioc_info(ioc, \"IR shutdown (complete): ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t\t\t le16_to_cpu(mpi_reply->IOCStatus),\n\t\t\t\t le32_to_cpu(mpi_reply->IOCLogInfo));\n\t}\n\n out:\n\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\n\tmutex_unlock(&ioc->scsih_cmds.mutex);\n}\n\n/**\n * _scsih_get_shost_and_ioc - get shost and ioc\n *\t\t\tand verify whether they are NULL or not\n * @pdev: PCI device struct\n * @shost: address of scsi host pointer\n * @ioc: address of HBA adapter pointer\n *\n * Return zero if *shost and *ioc are not NULL otherwise return error number.\n */\nstatic int\n_scsih_get_shost_and_ioc(struct pci_dev *pdev,\n\tstruct Scsi_Host **shost, struct MPT3SAS_ADAPTER **ioc)\n{\n\t*shost = pci_get_drvdata(pdev);\n\tif (*shost == NULL) {\n\t\tdev_err(&pdev->dev, \"pdev's driver data is null\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t*ioc = shost_priv(*shost);\n\tif (*ioc == NULL) {\n\t\tdev_err(&pdev->dev, \"shost's private data is null\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\n/**\n * scsih_remove - detach and remove add host\n * @pdev: PCI device struct\n *\n * Routine called when unloading the driver.\n */\nstatic void scsih_remove(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tstruct _sas_port *mpt3sas_port, *next_port;\n\tstruct _raid_device *raid_device, *next;\n\tstruct MPT3SAS_TARGET *sas_target_priv_data;\n\tstruct _pcie_device *pcie_device, *pcienext;\n\tstruct workqueue_struct\t*wq;\n\tunsigned long flags;\n\tMpi2ConfigReply_t mpi_reply;\n\tstruct hba_port *port, *port_next;\n\n\tif (_scsih_get_shost_and_ioc(pdev, &shost, &ioc))\n\t\treturn;\n\n\tioc->remove_host = 1;\n\n\tif (!pci_device_is_present(pdev))\n\t\t_scsih_flush_running_cmds(ioc);\n\n\t_scsih_fw_event_cleanup_queue(ioc);\n\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\twq = ioc->firmware_event_thread;\n\tioc->firmware_event_thread = NULL;\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n\tif (wq)\n\t\tdestroy_workqueue(wq);\n\t/*\n\t * Copy back the unmodified ioc page1. so that on next driver load,\n\t * current modified changes on ioc page1 won't take effect.\n\t */\n\tif (ioc->is_aero_ioc)\n\t\tmpt3sas_config_set_ioc_pg1(ioc, &mpi_reply,\n\t\t\t\t&ioc->ioc_pg1_copy);\n\t/* release all the volumes */\n\t_scsih_ir_shutdown(ioc);\n\tmpt3sas_destroy_debugfs(ioc);\n\tsas_remove_host(shost);\n\tlist_for_each_entry_safe(raid_device, next, &ioc->raid_device_list,\n\t    list) {\n\t\tif (raid_device->starget) {\n\t\t\tsas_target_priv_data =\n\t\t\t    raid_device->starget->hostdata;\n\t\t\tsas_target_priv_data->deleted = 1;\n\t\t\tscsi_remove_target(&raid_device->starget->dev);\n\t\t}\n\t\tioc_info(ioc, \"removing handle(0x%04x), wwid(0x%016llx)\\n\",\n\t\t\t raid_device->handle, (u64)raid_device->wwid);\n\t\t_scsih_raid_device_remove(ioc, raid_device);\n\t}\n\tlist_for_each_entry_safe(pcie_device, pcienext, &ioc->pcie_device_list,\n\t\tlist) {\n\t\t_scsih_pcie_device_remove_from_sml(ioc, pcie_device);\n\t\tlist_del_init(&pcie_device->list);\n\t\tpcie_device_put(pcie_device);\n\t}\n\n\t/* free ports attached to the sas_host */\n\tlist_for_each_entry_safe(mpt3sas_port, next_port,\n\t   &ioc->sas_hba.sas_port_list, port_list) {\n\t\tif (mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_END_DEVICE)\n\t\t\tmpt3sas_device_remove_by_sas_address(ioc,\n\t\t\t    mpt3sas_port->remote_identify.sas_address,\n\t\t\t    mpt3sas_port->hba_port);\n\t\telse if (mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    mpt3sas_port->remote_identify.device_type ==\n\t\t    SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\tmpt3sas_expander_remove(ioc,\n\t\t\t    mpt3sas_port->remote_identify.sas_address,\n\t\t\t    mpt3sas_port->hba_port);\n\t}\n\n\tlist_for_each_entry_safe(port, port_next,\n\t    &ioc->port_table_list, list) {\n\t\tlist_del(&port->list);\n\t\tkfree(port);\n\t}\n\n\t/* free phys attached to the sas_host */\n\tif (ioc->sas_hba.num_phys) {\n\t\tkfree(ioc->sas_hba.phy);\n\t\tioc->sas_hba.phy = NULL;\n\t\tioc->sas_hba.num_phys = 0;\n\t}\n\n\tmpt3sas_base_detach(ioc);\n\tspin_lock(&gioc_lock);\n\tlist_del(&ioc->list);\n\tspin_unlock(&gioc_lock);\n\tscsi_host_put(shost);\n}\n\n/**\n * scsih_shutdown - routine call during system shutdown\n * @pdev: PCI device struct\n */\nstatic void\nscsih_shutdown(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tstruct workqueue_struct\t*wq;\n\tunsigned long flags;\n\tMpi2ConfigReply_t mpi_reply;\n\n\tif (_scsih_get_shost_and_ioc(pdev, &shost, &ioc))\n\t\treturn;\n\n\tioc->remove_host = 1;\n\n\tif (!pci_device_is_present(pdev))\n\t\t_scsih_flush_running_cmds(ioc);\n\n\t_scsih_fw_event_cleanup_queue(ioc);\n\n\tspin_lock_irqsave(&ioc->fw_event_lock, flags);\n\twq = ioc->firmware_event_thread;\n\tioc->firmware_event_thread = NULL;\n\tspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\n\tif (wq)\n\t\tdestroy_workqueue(wq);\n\t/*\n\t * Copy back the unmodified ioc page1 so that on next driver load,\n\t * current modified changes on ioc page1 won't take effect.\n\t */\n\tif (ioc->is_aero_ioc)\n\t\tmpt3sas_config_set_ioc_pg1(ioc, &mpi_reply,\n\t\t\t\t&ioc->ioc_pg1_copy);\n\n\t_scsih_ir_shutdown(ioc);\n\t_scsih_nvme_shutdown(ioc);\n\tmpt3sas_base_detach(ioc);\n}\n\n\n/**\n * _scsih_probe_boot_devices - reports 1st device\n * @ioc: per adapter object\n *\n * If specified in bios page 2, this routine reports the 1st\n * device scsi-ml or sas transport for persistent boot device\n * purposes.  Please refer to function _scsih_determine_boot_device()\n */\nstatic void\n_scsih_probe_boot_devices(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu32 channel;\n\tvoid *device;\n\tstruct _sas_device *sas_device;\n\tstruct _raid_device *raid_device;\n\tstruct _pcie_device *pcie_device;\n\tu16 handle;\n\tu64 sas_address_parent;\n\tu64 sas_address;\n\tunsigned long flags;\n\tint rc;\n\tint tid;\n\tstruct hba_port *port;\n\n\t /* no Bios, return immediately */\n\tif (!ioc->bios_pg3.BiosVersion)\n\t\treturn;\n\n\tdevice = NULL;\n\tif (ioc->req_boot_device.device) {\n\t\tdevice =  ioc->req_boot_device.device;\n\t\tchannel = ioc->req_boot_device.channel;\n\t} else if (ioc->req_alt_boot_device.device) {\n\t\tdevice =  ioc->req_alt_boot_device.device;\n\t\tchannel = ioc->req_alt_boot_device.channel;\n\t} else if (ioc->current_boot_device.device) {\n\t\tdevice =  ioc->current_boot_device.device;\n\t\tchannel = ioc->current_boot_device.channel;\n\t}\n\n\tif (!device)\n\t\treturn;\n\n\tif (channel == RAID_CHANNEL) {\n\t\traid_device = device;\n\t\trc = scsi_add_device(ioc->shost, RAID_CHANNEL,\n\t\t    raid_device->id, 0);\n\t\tif (rc)\n\t\t\t_scsih_raid_device_remove(ioc, raid_device);\n\t} else if (channel == PCIE_CHANNEL) {\n\t\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\t\tpcie_device = device;\n\t\ttid = pcie_device->id;\n\t\tlist_move_tail(&pcie_device->list, &ioc->pcie_device_list);\n\t\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\t\trc = scsi_add_device(ioc->shost, PCIE_CHANNEL, tid, 0);\n\t\tif (rc)\n\t\t\t_scsih_pcie_device_remove(ioc, pcie_device);\n\t} else {\n\t\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\t\tsas_device = device;\n\t\thandle = sas_device->handle;\n\t\tsas_address_parent = sas_device->sas_address_parent;\n\t\tsas_address = sas_device->sas_address;\n\t\tport = sas_device->port;\n\t\tlist_move_tail(&sas_device->list, &ioc->sas_device_list);\n\t\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\t\tif (ioc->hide_drives)\n\t\t\treturn;\n\n\t\tif (!port)\n\t\t\treturn;\n\n\t\tif (!mpt3sas_transport_port_add(ioc, handle,\n\t\t    sas_address_parent, port)) {\n\t\t\t_scsih_sas_device_remove(ioc, sas_device);\n\t\t} else if (!sas_device->starget) {\n\t\t\tif (!ioc->is_driver_loading) {\n\t\t\t\tmpt3sas_transport_port_remove(ioc,\n\t\t\t\t    sas_address,\n\t\t\t\t    sas_address_parent, port);\n\t\t\t\t_scsih_sas_device_remove(ioc, sas_device);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * _scsih_probe_raid - reporting raid volumes to scsi-ml\n * @ioc: per adapter object\n *\n * Called during initial loading of the driver.\n */\nstatic void\n_scsih_probe_raid(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _raid_device *raid_device, *raid_next;\n\tint rc;\n\n\tlist_for_each_entry_safe(raid_device, raid_next,\n\t    &ioc->raid_device_list, list) {\n\t\tif (raid_device->starget)\n\t\t\tcontinue;\n\t\trc = scsi_add_device(ioc->shost, RAID_CHANNEL,\n\t\t    raid_device->id, 0);\n\t\tif (rc)\n\t\t\t_scsih_raid_device_remove(ioc, raid_device);\n\t}\n}\n\nstatic struct _sas_device *get_next_sas_device(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _sas_device *sas_device = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\tif (!list_empty(&ioc->sas_device_init_list)) {\n\t\tsas_device = list_first_entry(&ioc->sas_device_init_list,\n\t\t\t\tstruct _sas_device, list);\n\t\tsas_device_get(sas_device);\n\t}\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n\n\treturn sas_device;\n}\n\nstatic void sas_device_make_active(struct MPT3SAS_ADAPTER *ioc,\n\t\tstruct _sas_device *sas_device)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->sas_device_lock, flags);\n\n\t/*\n\t * Since we dropped the lock during the call to port_add(), we need to\n\t * be careful here that somebody else didn't move or delete this item\n\t * while we were busy with other things.\n\t *\n\t * If it was on the list, we need a put() for the reference the list\n\t * had. Either way, we need a get() for the destination list.\n\t */\n\tif (!list_empty(&sas_device->list)) {\n\t\tlist_del_init(&sas_device->list);\n\t\tsas_device_put(sas_device);\n\t}\n\n\tsas_device_get(sas_device);\n\tlist_add_tail(&sas_device->list, &ioc->sas_device_list);\n\n\tspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\n}\n\n/**\n * _scsih_probe_sas - reporting sas devices to sas transport\n * @ioc: per adapter object\n *\n * Called during initial loading of the driver.\n */\nstatic void\n_scsih_probe_sas(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _sas_device *sas_device;\n\n\tif (ioc->hide_drives)\n\t\treturn;\n\n\twhile ((sas_device = get_next_sas_device(ioc))) {\n\t\tif (!mpt3sas_transport_port_add(ioc, sas_device->handle,\n\t\t    sas_device->sas_address_parent, sas_device->port)) {\n\t\t\t_scsih_sas_device_remove(ioc, sas_device);\n\t\t\tsas_device_put(sas_device);\n\t\t\tcontinue;\n\t\t} else if (!sas_device->starget) {\n\t\t\t/*\n\t\t\t * When asyn scanning is enabled, its not possible to\n\t\t\t * remove devices while scanning is turned on due to an\n\t\t\t * oops in scsi_sysfs_add_sdev()->add_device()->\n\t\t\t * sysfs_addrm_start()\n\t\t\t */\n\t\t\tif (!ioc->is_driver_loading) {\n\t\t\t\tmpt3sas_transport_port_remove(ioc,\n\t\t\t\t    sas_device->sas_address,\n\t\t\t\t    sas_device->sas_address_parent,\n\t\t\t\t    sas_device->port);\n\t\t\t\t_scsih_sas_device_remove(ioc, sas_device);\n\t\t\t\tsas_device_put(sas_device);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tsas_device_make_active(ioc, sas_device);\n\t\tsas_device_put(sas_device);\n\t}\n}\n\n/**\n * get_next_pcie_device - Get the next pcie device\n * @ioc: per adapter object\n *\n * Get the next pcie device from pcie_device_init_list list.\n *\n * Return: pcie device structure if pcie_device_init_list list is not empty\n * otherwise returns NULL\n */\nstatic struct _pcie_device *get_next_pcie_device(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _pcie_device *pcie_device = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\tif (!list_empty(&ioc->pcie_device_init_list)) {\n\t\tpcie_device = list_first_entry(&ioc->pcie_device_init_list,\n\t\t\t\tstruct _pcie_device, list);\n\t\tpcie_device_get(pcie_device);\n\t}\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n\n\treturn pcie_device;\n}\n\n/**\n * pcie_device_make_active - Add pcie device to pcie_device_list list\n * @ioc: per adapter object\n * @pcie_device: pcie device object\n *\n * Add the pcie device which has registered with SCSI Transport Later to\n * pcie_device_list list\n */\nstatic void pcie_device_make_active(struct MPT3SAS_ADAPTER *ioc,\n\t\tstruct _pcie_device *pcie_device)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ioc->pcie_device_lock, flags);\n\n\tif (!list_empty(&pcie_device->list)) {\n\t\tlist_del_init(&pcie_device->list);\n\t\tpcie_device_put(pcie_device);\n\t}\n\tpcie_device_get(pcie_device);\n\tlist_add_tail(&pcie_device->list, &ioc->pcie_device_list);\n\n\tspin_unlock_irqrestore(&ioc->pcie_device_lock, flags);\n}\n\n/**\n * _scsih_probe_pcie - reporting PCIe devices to scsi-ml\n * @ioc: per adapter object\n *\n * Called during initial loading of the driver.\n */\nstatic void\n_scsih_probe_pcie(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _pcie_device *pcie_device;\n\tint rc;\n\n\t/* PCIe Device List */\n\twhile ((pcie_device = get_next_pcie_device(ioc))) {\n\t\tif (pcie_device->starget) {\n\t\t\tpcie_device_put(pcie_device);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pcie_device->access_status ==\n\t\t    MPI26_PCIEDEV0_ASTATUS_DEVICE_BLOCKED) {\n\t\t\tpcie_device_make_active(ioc, pcie_device);\n\t\t\tpcie_device_put(pcie_device);\n\t\t\tcontinue;\n\t\t}\n\t\trc = scsi_add_device(ioc->shost, PCIE_CHANNEL,\n\t\t\tpcie_device->id, 0);\n\t\tif (rc) {\n\t\t\t_scsih_pcie_device_remove(ioc, pcie_device);\n\t\t\tpcie_device_put(pcie_device);\n\t\t\tcontinue;\n\t\t} else if (!pcie_device->starget) {\n\t\t\t/*\n\t\t\t * When async scanning is enabled, its not possible to\n\t\t\t * remove devices while scanning is turned on due to an\n\t\t\t * oops in scsi_sysfs_add_sdev()->add_device()->\n\t\t\t * sysfs_addrm_start()\n\t\t\t */\n\t\t\tif (!ioc->is_driver_loading) {\n\t\t\t/* TODO-- Need to find out whether this condition will\n\t\t\t * occur or not\n\t\t\t */\n\t\t\t\t_scsih_pcie_device_remove(ioc, pcie_device);\n\t\t\t\tpcie_device_put(pcie_device);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tpcie_device_make_active(ioc, pcie_device);\n\t\tpcie_device_put(pcie_device);\n\t}\n}\n\n/**\n * _scsih_probe_devices - probing for devices\n * @ioc: per adapter object\n *\n * Called during initial loading of the driver.\n */\nstatic void\n_scsih_probe_devices(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu16 volume_mapping_flags;\n\n\tif (!(ioc->facts.ProtocolFlags & MPI2_IOCFACTS_PROTOCOL_SCSI_INITIATOR))\n\t\treturn;  /* return when IOC doesn't support initiator mode */\n\n\t_scsih_probe_boot_devices(ioc);\n\n\tif (ioc->ir_firmware) {\n\t\tvolume_mapping_flags =\n\t\t    le16_to_cpu(ioc->ioc_pg8.IRVolumeMappingFlags) &\n\t\t    MPI2_IOCPAGE8_IRFLAGS_MASK_VOLUME_MAPPING_MODE;\n\t\tif (volume_mapping_flags ==\n\t\t    MPI2_IOCPAGE8_IRFLAGS_LOW_VOLUME_MAPPING) {\n\t\t\t_scsih_probe_raid(ioc);\n\t\t\t_scsih_probe_sas(ioc);\n\t\t} else {\n\t\t\t_scsih_probe_sas(ioc);\n\t\t\t_scsih_probe_raid(ioc);\n\t\t}\n\t} else {\n\t\t_scsih_probe_sas(ioc);\n\t\t_scsih_probe_pcie(ioc);\n\t}\n}\n\n/**\n * scsih_scan_start - scsi lld callback for .scan_start\n * @shost: SCSI host pointer\n *\n * The shost has the ability to discover targets on its own instead\n * of scanning the entire bus.  In our implemention, we will kick off\n * firmware discovery.\n */\nstatic void\nscsih_scan_start(struct Scsi_Host *shost)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\tint rc;\n\tif (diag_buffer_enable != -1 && diag_buffer_enable != 0)\n\t\tmpt3sas_enable_diag_buffer(ioc, diag_buffer_enable);\n\telse if (ioc->manu_pg11.HostTraceBufferMaxSizeKB != 0)\n\t\tmpt3sas_enable_diag_buffer(ioc, 1);\n\n\tif (disable_discovery > 0)\n\t\treturn;\n\n\tioc->start_scan = 1;\n\trc = mpt3sas_port_enable(ioc);\n\n\tif (rc != 0)\n\t\tioc_info(ioc, \"port enable: FAILED\\n\");\n}\n\n/**\n * scsih_scan_finished - scsi lld callback for .scan_finished\n * @shost: SCSI host pointer\n * @time: elapsed time of the scan in jiffies\n *\n * This function will be called periodicallyn until it returns 1 with the\n * scsi_host and the elapsed time of the scan in jiffies. In our implemention,\n * we wait for firmware discovery to complete, then return 1.\n */\nstatic int\nscsih_scan_finished(struct Scsi_Host *shost, unsigned long time)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\n\n\tif (disable_discovery > 0) {\n\t\tioc->is_driver_loading = 0;\n\t\tioc->wait_for_discovery_to_complete = 0;\n\t\treturn 1;\n\t}\n\n\tif (time >= (300 * HZ)) {\n\t\tioc->port_enable_cmds.status = MPT3_CMD_NOT_USED;\n\t\tioc_info(ioc, \"port enable: FAILED with timeout (timeout=300s)\\n\");\n\t\tioc->is_driver_loading = 0;\n\t\treturn 1;\n\t}\n\n\tif (ioc->start_scan)\n\t\treturn 0;\n\n\tif (ioc->start_scan_failed) {\n\t\tioc_info(ioc, \"port enable: FAILED with (ioc_status=0x%08x)\\n\",\n\t\t\t ioc->start_scan_failed);\n\t\tioc->is_driver_loading = 0;\n\t\tioc->wait_for_discovery_to_complete = 0;\n\t\tioc->remove_host = 1;\n\t\treturn 1;\n\t}\n\n\tioc_info(ioc, \"port enable: SUCCESS\\n\");\n\tioc->port_enable_cmds.status = MPT3_CMD_NOT_USED;\n\n\tif (ioc->wait_for_discovery_to_complete) {\n\t\tioc->wait_for_discovery_to_complete = 0;\n\t\t_scsih_probe_devices(ioc);\n\t}\n\tmpt3sas_base_start_watchdog(ioc);\n\tioc->is_driver_loading = 0;\n\treturn 1;\n}\n\n/* shost template for SAS 2.0 HBA devices */\nstatic struct scsi_host_template mpt2sas_driver_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.name\t\t\t\t= \"Fusion MPT SAS Host\",\n\t.proc_name\t\t\t= MPT2SAS_DRIVER_NAME,\n\t.queuecommand\t\t\t= scsih_qcmd,\n\t.target_alloc\t\t\t= scsih_target_alloc,\n\t.slave_alloc\t\t\t= scsih_slave_alloc,\n\t.slave_configure\t\t= scsih_slave_configure,\n\t.target_destroy\t\t\t= scsih_target_destroy,\n\t.slave_destroy\t\t\t= scsih_slave_destroy,\n\t.scan_finished\t\t\t= scsih_scan_finished,\n\t.scan_start\t\t\t= scsih_scan_start,\n\t.change_queue_depth\t\t= scsih_change_queue_depth,\n\t.eh_abort_handler\t\t= scsih_abort,\n\t.eh_device_reset_handler\t= scsih_dev_reset,\n\t.eh_target_reset_handler\t= scsih_target_reset,\n\t.eh_host_reset_handler\t\t= scsih_host_reset,\n\t.bios_param\t\t\t= scsih_bios_param,\n\t.can_queue\t\t\t= 1,\n\t.this_id\t\t\t= -1,\n\t.sg_tablesize\t\t\t= MPT2SAS_SG_DEPTH,\n\t.max_sectors\t\t\t= 32767,\n\t.cmd_per_lun\t\t\t= 7,\n\t.shost_attrs\t\t\t= mpt3sas_host_attrs,\n\t.sdev_attrs\t\t\t= mpt3sas_dev_attrs,\n\t.track_queue_depth\t\t= 1,\n\t.cmd_size\t\t\t= sizeof(struct scsiio_tracker),\n};\n\n/* raid transport support for SAS 2.0 HBA devices */\nstatic struct raid_function_template mpt2sas_raid_functions = {\n\t.cookie\t\t= &mpt2sas_driver_template,\n\t.is_raid\t= scsih_is_raid,\n\t.get_resync\t= scsih_get_resync,\n\t.get_state\t= scsih_get_state,\n};\n\n/* shost template for SAS 3.0 HBA devices */\nstatic struct scsi_host_template mpt3sas_driver_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.name\t\t\t\t= \"Fusion MPT SAS Host\",\n\t.proc_name\t\t\t= MPT3SAS_DRIVER_NAME,\n\t.queuecommand\t\t\t= scsih_qcmd,\n\t.target_alloc\t\t\t= scsih_target_alloc,\n\t.slave_alloc\t\t\t= scsih_slave_alloc,\n\t.slave_configure\t\t= scsih_slave_configure,\n\t.target_destroy\t\t\t= scsih_target_destroy,\n\t.slave_destroy\t\t\t= scsih_slave_destroy,\n\t.scan_finished\t\t\t= scsih_scan_finished,\n\t.scan_start\t\t\t= scsih_scan_start,\n\t.change_queue_depth\t\t= scsih_change_queue_depth,\n\t.eh_abort_handler\t\t= scsih_abort,\n\t.eh_device_reset_handler\t= scsih_dev_reset,\n\t.eh_target_reset_handler\t= scsih_target_reset,\n\t.eh_host_reset_handler\t\t= scsih_host_reset,\n\t.bios_param\t\t\t= scsih_bios_param,\n\t.can_queue\t\t\t= 1,\n\t.this_id\t\t\t= -1,\n\t.sg_tablesize\t\t\t= MPT3SAS_SG_DEPTH,\n\t.max_sectors\t\t\t= 32767,\n\t.max_segment_size\t\t= 0xffffffff,\n\t.cmd_per_lun\t\t\t= 7,\n\t.shost_attrs\t\t\t= mpt3sas_host_attrs,\n\t.sdev_attrs\t\t\t= mpt3sas_dev_attrs,\n\t.track_queue_depth\t\t= 1,\n\t.cmd_size\t\t\t= sizeof(struct scsiio_tracker),\n};\n\n/* raid transport support for SAS 3.0 HBA devices */\nstatic struct raid_function_template mpt3sas_raid_functions = {\n\t.cookie\t\t= &mpt3sas_driver_template,\n\t.is_raid\t= scsih_is_raid,\n\t.get_resync\t= scsih_get_resync,\n\t.get_state\t= scsih_get_state,\n};\n\n/**\n * _scsih_determine_hba_mpi_version - determine in which MPI version class\n *\t\t\t\t\tthis device belongs to.\n * @pdev: PCI device struct\n *\n * return MPI2_VERSION for SAS 2.0 HBA devices,\n *\tMPI25_VERSION for SAS 3.0 HBA devices, and\n *\tMPI26 VERSION for Cutlass & Invader SAS 3.0 HBA devices\n */\nstatic u16\n_scsih_determine_hba_mpi_version(struct pci_dev *pdev)\n{\n\n\tswitch (pdev->device) {\n\tcase MPI2_MFGPAGE_DEVID_SSS6200:\n\tcase MPI2_MFGPAGE_DEVID_SAS2004:\n\tcase MPI2_MFGPAGE_DEVID_SAS2008:\n\tcase MPI2_MFGPAGE_DEVID_SAS2108_1:\n\tcase MPI2_MFGPAGE_DEVID_SAS2108_2:\n\tcase MPI2_MFGPAGE_DEVID_SAS2108_3:\n\tcase MPI2_MFGPAGE_DEVID_SAS2116_1:\n\tcase MPI2_MFGPAGE_DEVID_SAS2116_2:\n\tcase MPI2_MFGPAGE_DEVID_SAS2208_1:\n\tcase MPI2_MFGPAGE_DEVID_SAS2208_2:\n\tcase MPI2_MFGPAGE_DEVID_SAS2208_3:\n\tcase MPI2_MFGPAGE_DEVID_SAS2208_4:\n\tcase MPI2_MFGPAGE_DEVID_SAS2208_5:\n\tcase MPI2_MFGPAGE_DEVID_SAS2208_6:\n\tcase MPI2_MFGPAGE_DEVID_SAS2308_1:\n\tcase MPI2_MFGPAGE_DEVID_SAS2308_2:\n\tcase MPI2_MFGPAGE_DEVID_SAS2308_3:\n\tcase MPI2_MFGPAGE_DEVID_SWITCH_MPI_EP:\n\tcase MPI2_MFGPAGE_DEVID_SWITCH_MPI_EP_1:\n\t\treturn MPI2_VERSION;\n\tcase MPI25_MFGPAGE_DEVID_SAS3004:\n\tcase MPI25_MFGPAGE_DEVID_SAS3008:\n\tcase MPI25_MFGPAGE_DEVID_SAS3108_1:\n\tcase MPI25_MFGPAGE_DEVID_SAS3108_2:\n\tcase MPI25_MFGPAGE_DEVID_SAS3108_5:\n\tcase MPI25_MFGPAGE_DEVID_SAS3108_6:\n\t\treturn MPI25_VERSION;\n\tcase MPI26_MFGPAGE_DEVID_SAS3216:\n\tcase MPI26_MFGPAGE_DEVID_SAS3224:\n\tcase MPI26_MFGPAGE_DEVID_SAS3316_1:\n\tcase MPI26_MFGPAGE_DEVID_SAS3316_2:\n\tcase MPI26_MFGPAGE_DEVID_SAS3316_3:\n\tcase MPI26_MFGPAGE_DEVID_SAS3316_4:\n\tcase MPI26_MFGPAGE_DEVID_SAS3324_1:\n\tcase MPI26_MFGPAGE_DEVID_SAS3324_2:\n\tcase MPI26_MFGPAGE_DEVID_SAS3324_3:\n\tcase MPI26_MFGPAGE_DEVID_SAS3324_4:\n\tcase MPI26_MFGPAGE_DEVID_SAS3508:\n\tcase MPI26_MFGPAGE_DEVID_SAS3508_1:\n\tcase MPI26_MFGPAGE_DEVID_SAS3408:\n\tcase MPI26_MFGPAGE_DEVID_SAS3516:\n\tcase MPI26_MFGPAGE_DEVID_SAS3516_1:\n\tcase MPI26_MFGPAGE_DEVID_SAS3416:\n\tcase MPI26_MFGPAGE_DEVID_SAS3616:\n\tcase MPI26_ATLAS_PCIe_SWITCH_DEVID:\n\tcase MPI26_MFGPAGE_DEVID_CFG_SEC_3916:\n\tcase MPI26_MFGPAGE_DEVID_HARD_SEC_3916:\n\tcase MPI26_MFGPAGE_DEVID_CFG_SEC_3816:\n\tcase MPI26_MFGPAGE_DEVID_HARD_SEC_3816:\n\tcase MPI26_MFGPAGE_DEVID_INVALID0_3916:\n\tcase MPI26_MFGPAGE_DEVID_INVALID1_3916:\n\tcase MPI26_MFGPAGE_DEVID_INVALID0_3816:\n\tcase MPI26_MFGPAGE_DEVID_INVALID1_3816:\n\t\treturn MPI26_VERSION;\n\t}\n\treturn 0;\n}\n\n/**\n * _scsih_probe - attach and add scsi host\n * @pdev: PCI device struct\n * @id: pci device id\n *\n * Return: 0 success, anything else error.\n */\nstatic int\n_scsih_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tstruct Scsi_Host *shost = NULL;\n\tint rv;\n\tu16 hba_mpi_version;\n\n\t/* Determine in which MPI version class this pci device belongs */\n\thba_mpi_version = _scsih_determine_hba_mpi_version(pdev);\n\tif (hba_mpi_version == 0)\n\t\treturn -ENODEV;\n\n\t/* Enumerate only SAS 2.0 HBA's if hbas_to_enumerate is one,\n\t * for other generation HBA's return with -ENODEV\n\t */\n\tif ((hbas_to_enumerate == 1) && (hba_mpi_version !=  MPI2_VERSION))\n\t\treturn -ENODEV;\n\n\t/* Enumerate only SAS 3.0 HBA's if hbas_to_enumerate is two,\n\t * for other generation HBA's return with -ENODEV\n\t */\n\tif ((hbas_to_enumerate == 2) && (!(hba_mpi_version ==  MPI25_VERSION\n\t\t|| hba_mpi_version ==  MPI26_VERSION)))\n\t\treturn -ENODEV;\n\n\tswitch (hba_mpi_version) {\n\tcase MPI2_VERSION:\n\t\tpci_disable_link_state(pdev, PCIE_LINK_STATE_L0S |\n\t\t\tPCIE_LINK_STATE_L1 | PCIE_LINK_STATE_CLKPM);\n\t\t/* Use mpt2sas driver host template for SAS 2.0 HBA's */\n\t\tshost = scsi_host_alloc(&mpt2sas_driver_template,\n\t\t  sizeof(struct MPT3SAS_ADAPTER));\n\t\tif (!shost)\n\t\t\treturn -ENODEV;\n\t\tioc = shost_priv(shost);\n\t\tmemset(ioc, 0, sizeof(struct MPT3SAS_ADAPTER));\n\t\tioc->hba_mpi_version_belonged = hba_mpi_version;\n\t\tioc->id = mpt2_ids++;\n\t\tsprintf(ioc->driver_name, \"%s\", MPT2SAS_DRIVER_NAME);\n\t\tswitch (pdev->device) {\n\t\tcase MPI2_MFGPAGE_DEVID_SSS6200:\n\t\t\tioc->is_warpdrive = 1;\n\t\t\tioc->hide_ir_msg = 1;\n\t\t\tbreak;\n\t\tcase MPI2_MFGPAGE_DEVID_SWITCH_MPI_EP:\n\t\tcase MPI2_MFGPAGE_DEVID_SWITCH_MPI_EP_1:\n\t\t\tioc->is_mcpu_endpoint = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tioc->mfg_pg10_hide_flag = MFG_PAGE10_EXPOSE_ALL_DISKS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (multipath_on_hba == -1 || multipath_on_hba == 0)\n\t\t\tioc->multipath_on_hba = 0;\n\t\telse\n\t\t\tioc->multipath_on_hba = 1;\n\n\t\tbreak;\n\tcase MPI25_VERSION:\n\tcase MPI26_VERSION:\n\t\t/* Use mpt3sas driver host template for SAS 3.0 HBA's */\n\t\tshost = scsi_host_alloc(&mpt3sas_driver_template,\n\t\t  sizeof(struct MPT3SAS_ADAPTER));\n\t\tif (!shost)\n\t\t\treturn -ENODEV;\n\t\tioc = shost_priv(shost);\n\t\tmemset(ioc, 0, sizeof(struct MPT3SAS_ADAPTER));\n\t\tioc->hba_mpi_version_belonged = hba_mpi_version;\n\t\tioc->id = mpt3_ids++;\n\t\tsprintf(ioc->driver_name, \"%s\", MPT3SAS_DRIVER_NAME);\n\t\tswitch (pdev->device) {\n\t\tcase MPI26_MFGPAGE_DEVID_SAS3508:\n\t\tcase MPI26_MFGPAGE_DEVID_SAS3508_1:\n\t\tcase MPI26_MFGPAGE_DEVID_SAS3408:\n\t\tcase MPI26_MFGPAGE_DEVID_SAS3516:\n\t\tcase MPI26_MFGPAGE_DEVID_SAS3516_1:\n\t\tcase MPI26_MFGPAGE_DEVID_SAS3416:\n\t\tcase MPI26_MFGPAGE_DEVID_SAS3616:\n\t\tcase MPI26_ATLAS_PCIe_SWITCH_DEVID:\n\t\t\tioc->is_gen35_ioc = 1;\n\t\t\tbreak;\n\t\tcase MPI26_MFGPAGE_DEVID_INVALID0_3816:\n\t\tcase MPI26_MFGPAGE_DEVID_INVALID0_3916:\n\t\t\tdev_err(&pdev->dev,\n\t\t\t    \"HBA with DeviceId 0x%04x, sub VendorId 0x%04x, sub DeviceId 0x%04x is Invalid\",\n\t\t\t    pdev->device, pdev->subsystem_vendor,\n\t\t\t    pdev->subsystem_device);\n\t\t\treturn 1;\n\t\tcase MPI26_MFGPAGE_DEVID_INVALID1_3816:\n\t\tcase MPI26_MFGPAGE_DEVID_INVALID1_3916:\n\t\t\tdev_err(&pdev->dev,\n\t\t\t    \"HBA with DeviceId 0x%04x, sub VendorId 0x%04x, sub DeviceId 0x%04x is Tampered\",\n\t\t\t    pdev->device, pdev->subsystem_vendor,\n\t\t\t    pdev->subsystem_device);\n\t\t\treturn 1;\n\t\tcase MPI26_MFGPAGE_DEVID_CFG_SEC_3816:\n\t\tcase MPI26_MFGPAGE_DEVID_CFG_SEC_3916:\n\t\t\tdev_info(&pdev->dev,\n\t\t\t    \"HBA is in Configurable Secure mode\\n\");\n\t\t\tfallthrough;\n\t\tcase MPI26_MFGPAGE_DEVID_HARD_SEC_3816:\n\t\tcase MPI26_MFGPAGE_DEVID_HARD_SEC_3916:\n\t\t\tioc->is_aero_ioc = ioc->is_gen35_ioc = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tioc->is_gen35_ioc = ioc->is_aero_ioc = 0;\n\t\t}\n\t\tif ((ioc->hba_mpi_version_belonged == MPI25_VERSION &&\n\t\t\tpdev->revision >= SAS3_PCI_DEVICE_C0_REVISION) ||\n\t\t\t(ioc->hba_mpi_version_belonged == MPI26_VERSION)) {\n\t\t\tioc->combined_reply_queue = 1;\n\t\t\tif (ioc->is_gen35_ioc)\n\t\t\t\tioc->combined_reply_index_count =\n\t\t\t\t MPT3_SUP_REPLY_POST_HOST_INDEX_REG_COUNT_G35;\n\t\t\telse\n\t\t\t\tioc->combined_reply_index_count =\n\t\t\t\t MPT3_SUP_REPLY_POST_HOST_INDEX_REG_COUNT_G3;\n\t\t}\n\n\t\tswitch (ioc->is_gen35_ioc) {\n\t\tcase 0:\n\t\t\tif (multipath_on_hba == -1 || multipath_on_hba == 0)\n\t\t\t\tioc->multipath_on_hba = 0;\n\t\t\telse\n\t\t\t\tioc->multipath_on_hba = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (multipath_on_hba == -1 || multipath_on_hba > 0)\n\t\t\t\tioc->multipath_on_hba = 1;\n\t\t\telse\n\t\t\t\tioc->multipath_on_hba = 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tINIT_LIST_HEAD(&ioc->list);\n\tspin_lock(&gioc_lock);\n\tlist_add_tail(&ioc->list, &mpt3sas_ioc_list);\n\tspin_unlock(&gioc_lock);\n\tioc->shost = shost;\n\tioc->pdev = pdev;\n\tioc->scsi_io_cb_idx = scsi_io_cb_idx;\n\tioc->tm_cb_idx = tm_cb_idx;\n\tioc->ctl_cb_idx = ctl_cb_idx;\n\tioc->base_cb_idx = base_cb_idx;\n\tioc->port_enable_cb_idx = port_enable_cb_idx;\n\tioc->transport_cb_idx = transport_cb_idx;\n\tioc->scsih_cb_idx = scsih_cb_idx;\n\tioc->config_cb_idx = config_cb_idx;\n\tioc->tm_tr_cb_idx = tm_tr_cb_idx;\n\tioc->tm_tr_volume_cb_idx = tm_tr_volume_cb_idx;\n\tioc->tm_sas_control_cb_idx = tm_sas_control_cb_idx;\n\tioc->logging_level = logging_level;\n\tioc->schedule_dead_ioc_flush_running_cmds = &_scsih_flush_running_cmds;\n\t/* Host waits for minimum of six seconds */\n\tioc->max_shutdown_latency = IO_UNIT_CONTROL_SHUTDOWN_TIMEOUT;\n\t/*\n\t * Enable MEMORY MOVE support flag.\n\t */\n\tioc->drv_support_bitmap |= MPT_DRV_SUPPORT_BITMAP_MEMMOVE;\n\n\tioc->enable_sdev_max_qd = enable_sdev_max_qd;\n\n\t/* misc semaphores and spin locks */\n\tmutex_init(&ioc->reset_in_progress_mutex);\n\t/* initializing pci_access_mutex lock */\n\tmutex_init(&ioc->pci_access_mutex);\n\tspin_lock_init(&ioc->ioc_reset_in_progress_lock);\n\tspin_lock_init(&ioc->scsi_lookup_lock);\n\tspin_lock_init(&ioc->sas_device_lock);\n\tspin_lock_init(&ioc->sas_node_lock);\n\tspin_lock_init(&ioc->fw_event_lock);\n\tspin_lock_init(&ioc->raid_device_lock);\n\tspin_lock_init(&ioc->pcie_device_lock);\n\tspin_lock_init(&ioc->diag_trigger_lock);\n\n\tINIT_LIST_HEAD(&ioc->sas_device_list);\n\tINIT_LIST_HEAD(&ioc->sas_device_init_list);\n\tINIT_LIST_HEAD(&ioc->sas_expander_list);\n\tINIT_LIST_HEAD(&ioc->enclosure_list);\n\tINIT_LIST_HEAD(&ioc->pcie_device_list);\n\tINIT_LIST_HEAD(&ioc->pcie_device_init_list);\n\tINIT_LIST_HEAD(&ioc->fw_event_list);\n\tINIT_LIST_HEAD(&ioc->raid_device_list);\n\tINIT_LIST_HEAD(&ioc->sas_hba.sas_port_list);\n\tINIT_LIST_HEAD(&ioc->delayed_tr_list);\n\tINIT_LIST_HEAD(&ioc->delayed_sc_list);\n\tINIT_LIST_HEAD(&ioc->delayed_event_ack_list);\n\tINIT_LIST_HEAD(&ioc->delayed_tr_volume_list);\n\tINIT_LIST_HEAD(&ioc->reply_queue_list);\n\tINIT_LIST_HEAD(&ioc->port_table_list);\n\n\tsprintf(ioc->name, \"%s_cm%d\", ioc->driver_name, ioc->id);\n\n\t/* init shost parameters */\n\tshost->max_cmd_len = 32;\n\tshost->max_lun = max_lun;\n\tshost->transportt = mpt3sas_transport_template;\n\tshost->unique_id = ioc->id;\n\n\tif (ioc->is_mcpu_endpoint) {\n\t\t/* mCPU MPI support 64K max IO */\n\t\tshost->max_sectors = 128;\n\t\tioc_info(ioc, \"The max_sectors value is set to %d\\n\",\n\t\t\t shost->max_sectors);\n\t} else {\n\t\tif (max_sectors != 0xFFFF) {\n\t\t\tif (max_sectors < 64) {\n\t\t\t\tshost->max_sectors = 64;\n\t\t\t\tioc_warn(ioc, \"Invalid value %d passed for max_sectors, range is 64 to 32767. Assigning value of 64.\\n\",\n\t\t\t\t\t max_sectors);\n\t\t\t} else if (max_sectors > 32767) {\n\t\t\t\tshost->max_sectors = 32767;\n\t\t\t\tioc_warn(ioc, \"Invalid value %d passed for max_sectors, range is 64 to 32767.Assigning default value of 32767.\\n\",\n\t\t\t\t\t max_sectors);\n\t\t\t} else {\n\t\t\t\tshost->max_sectors = max_sectors & 0xFFFE;\n\t\t\t\tioc_info(ioc, \"The max_sectors value is set to %d\\n\",\n\t\t\t\t\t shost->max_sectors);\n\t\t\t}\n\t\t}\n\t}\n\t/* register EEDP capabilities with SCSI layer */\n\tif (prot_mask >= 0)\n\t\tscsi_host_set_prot(shost, (prot_mask & 0x07));\n\telse\n\t\tscsi_host_set_prot(shost, SHOST_DIF_TYPE1_PROTECTION\n\t\t\t\t   | SHOST_DIF_TYPE2_PROTECTION\n\t\t\t\t   | SHOST_DIF_TYPE3_PROTECTION);\n\n\tscsi_host_set_guard(shost, SHOST_DIX_GUARD_CRC);\n\n\t/* event thread */\n\tsnprintf(ioc->firmware_event_name, sizeof(ioc->firmware_event_name),\n\t    \"fw_event_%s%d\", ioc->driver_name, ioc->id);\n\tioc->firmware_event_thread = alloc_ordered_workqueue(\n\t    ioc->firmware_event_name, 0);\n\tif (!ioc->firmware_event_thread) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trv = -ENODEV;\n\t\tgoto out_thread_fail;\n\t}\n\n\tioc->is_driver_loading = 1;\n\tif ((mpt3sas_base_attach(ioc))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\trv = -ENODEV;\n\t\tgoto out_attach_fail;\n\t}\n\n\tif (ioc->is_warpdrive) {\n\t\tif (ioc->mfg_pg10_hide_flag ==  MFG_PAGE10_EXPOSE_ALL_DISKS)\n\t\t\tioc->hide_drives = 0;\n\t\telse if (ioc->mfg_pg10_hide_flag ==  MFG_PAGE10_HIDE_ALL_DISKS)\n\t\t\tioc->hide_drives = 1;\n\t\telse {\n\t\t\tif (mpt3sas_get_num_volumes(ioc))\n\t\t\t\tioc->hide_drives = 1;\n\t\t\telse\n\t\t\t\tioc->hide_drives = 0;\n\t\t}\n\t} else\n\t\tioc->hide_drives = 0;\n\n\trv = scsi_add_host(shost, &pdev->dev);\n\tif (rv) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out_add_shost_fail;\n\t}\n\n\tscsi_scan_host(shost);\n\tmpt3sas_setup_debugfs(ioc);\n\treturn 0;\nout_add_shost_fail:\n\tmpt3sas_base_detach(ioc);\n out_attach_fail:\n\tdestroy_workqueue(ioc->firmware_event_thread);\n out_thread_fail:\n\tspin_lock(&gioc_lock);\n\tlist_del(&ioc->list);\n\tspin_unlock(&gioc_lock);\n\tscsi_host_put(shost);\n\treturn rv;\n}\n\n#ifdef CONFIG_PM\n/**\n * scsih_suspend - power management suspend main entry point\n * @pdev: PCI device struct\n * @state: PM state change to (usually PCI_D3)\n *\n * Return: 0 success, anything else error.\n */\nstatic int\nscsih_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tpci_power_t device_state;\n\tint rc;\n\n\trc = _scsih_get_shost_and_ioc(pdev, &shost, &ioc);\n\tif (rc)\n\t\treturn rc;\n\n\tmpt3sas_base_stop_watchdog(ioc);\n\tflush_scheduled_work();\n\tscsi_block_requests(shost);\n\t_scsih_nvme_shutdown(ioc);\n\tdevice_state = pci_choose_state(pdev, state);\n\tioc_info(ioc, \"pdev=0x%p, slot=%s, entering operating state [D%d]\\n\",\n\t\t pdev, pci_name(pdev), device_state);\n\n\tpci_save_state(pdev);\n\tmpt3sas_base_free_resources(ioc);\n\tpci_set_power_state(pdev, device_state);\n\treturn 0;\n}\n\n/**\n * scsih_resume - power management resume main entry point\n * @pdev: PCI device struct\n *\n * Return: 0 success, anything else error.\n */\nstatic int\nscsih_resume(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tpci_power_t device_state = pdev->current_state;\n\tint r;\n\n\tr = _scsih_get_shost_and_ioc(pdev, &shost, &ioc);\n\tif (r)\n\t\treturn r;\n\n\tioc_info(ioc, \"pdev=0x%p, slot=%s, previous operating state [D%d]\\n\",\n\t\t pdev, pci_name(pdev), device_state);\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_enable_wake(pdev, PCI_D0, 0);\n\tpci_restore_state(pdev);\n\tioc->pdev = pdev;\n\tr = mpt3sas_base_map_resources(ioc);\n\tif (r)\n\t\treturn r;\n\tioc_info(ioc, \"Issuing Hard Reset as part of OS Resume\\n\");\n\tmpt3sas_base_hard_reset_handler(ioc, SOFT_RESET);\n\tscsi_unblock_requests(shost);\n\tmpt3sas_base_start_watchdog(ioc);\n\treturn 0;\n}\n#endif /* CONFIG_PM */\n\n/**\n * scsih_pci_error_detected - Called when a PCI error is detected.\n * @pdev: PCI device struct\n * @state: PCI channel state\n *\n * Description: Called when a PCI error is detected.\n *\n * Return: PCI_ERS_RESULT_NEED_RESET or PCI_ERS_RESULT_DISCONNECT.\n */\nstatic pci_ers_result_t\nscsih_pci_error_detected(struct pci_dev *pdev, pci_channel_state_t state)\n{\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\n\tif (_scsih_get_shost_and_ioc(pdev, &shost, &ioc))\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tioc_info(ioc, \"PCI error: detected callback, state(%d)!!\\n\", state);\n\n\tswitch (state) {\n\tcase pci_channel_io_normal:\n\t\treturn PCI_ERS_RESULT_CAN_RECOVER;\n\tcase pci_channel_io_frozen:\n\t\t/* Fatal error, prepare for slot reset */\n\t\tioc->pci_error_recovery = 1;\n\t\tscsi_block_requests(ioc->shost);\n\t\tmpt3sas_base_stop_watchdog(ioc);\n\t\tmpt3sas_base_free_resources(ioc);\n\t\treturn PCI_ERS_RESULT_NEED_RESET;\n\tcase pci_channel_io_perm_failure:\n\t\t/* Permanent error, prepare for device removal */\n\t\tioc->pci_error_recovery = 1;\n\t\tmpt3sas_base_stop_watchdog(ioc);\n\t\t_scsih_flush_running_cmds(ioc);\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n/**\n * scsih_pci_slot_reset - Called when PCI slot has been reset.\n * @pdev: PCI device struct\n *\n * Description: This routine is called by the pci error recovery\n * code after the PCI slot has been reset, just before we\n * should resume normal operations.\n */\nstatic pci_ers_result_t\nscsih_pci_slot_reset(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\tint rc;\n\n\tif (_scsih_get_shost_and_ioc(pdev, &shost, &ioc))\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tioc_info(ioc, \"PCI error: slot reset callback!!\\n\");\n\n\tioc->pci_error_recovery = 0;\n\tioc->pdev = pdev;\n\tpci_restore_state(pdev);\n\trc = mpt3sas_base_map_resources(ioc);\n\tif (rc)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tioc_info(ioc, \"Issuing Hard Reset as part of PCI Slot Reset\\n\");\n\trc = mpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\n\tioc_warn(ioc, \"hard reset: %s\\n\",\n\t\t (rc == 0) ? \"success\" : \"failed\");\n\n\tif (!rc)\n\t\treturn PCI_ERS_RESULT_RECOVERED;\n\telse\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n}\n\n/**\n * scsih_pci_resume() - resume normal ops after PCI reset\n * @pdev: pointer to PCI device\n *\n * Called when the error recovery driver tells us that its\n * OK to resume normal operation. Use completion to allow\n * halted scsi ops to resume.\n */\nstatic void\nscsih_pci_resume(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\n\tif (_scsih_get_shost_and_ioc(pdev, &shost, &ioc))\n\t\treturn;\n\n\tioc_info(ioc, \"PCI error: resume callback!!\\n\");\n\n\tmpt3sas_base_start_watchdog(ioc);\n\tscsi_unblock_requests(ioc->shost);\n}\n\n/**\n * scsih_pci_mmio_enabled - Enable MMIO and dump debug registers\n * @pdev: pointer to PCI device\n */\nstatic pci_ers_result_t\nscsih_pci_mmio_enabled(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct MPT3SAS_ADAPTER *ioc;\n\n\tif (_scsih_get_shost_and_ioc(pdev, &shost, &ioc))\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tioc_info(ioc, \"PCI error: mmio enabled callback!!\\n\");\n\n\t/* TODO - dump whatever for debugging purposes */\n\n\t/* This called only if scsih_pci_error_detected returns\n\t * PCI_ERS_RESULT_CAN_RECOVER. Read/write to the device still\n\t * works, no need to reset slot.\n\t */\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\n/**\n * scsih__ncq_prio_supp - Check for NCQ command priority support\n * @sdev: scsi device struct\n *\n * This is called when a user indicates they would like to enable\n * ncq command priorities. This works only on SATA devices.\n */\nbool scsih_ncq_prio_supp(struct scsi_device *sdev)\n{\n\tunsigned char *buf;\n\tbool ncq_prio_supp = false;\n\n\tif (!scsi_device_supports_vpd(sdev))\n\t\treturn ncq_prio_supp;\n\n\tbuf = kmalloc(SCSI_VPD_PG_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn ncq_prio_supp;\n\n\tif (!scsi_get_vpd_page(sdev, 0x89, buf, SCSI_VPD_PG_LEN))\n\t\tncq_prio_supp = (buf[213] >> 4) & 1;\n\n\tkfree(buf);\n\treturn ncq_prio_supp;\n}\n/*\n * The pci device ids are defined in mpi/mpi2_cnfg.h.\n */\nstatic const struct pci_device_id mpt3sas_pci_table[] = {\n\t/* Spitfire ~ 2004 */\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2004,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t/* Falcon ~ 2008 */\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2008,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t/* Liberator ~ 2108 */\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2108_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2108_2,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2108_3,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t/* Meteor ~ 2116 */\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2116_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2116_2,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t/* Thunderbolt ~ 2208 */\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_2,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_3,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_4,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_5,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2208_6,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t/* Mustang ~ 2308 */\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2308_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2308_2,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SAS2308_3,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SWITCH_MPI_EP,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SWITCH_MPI_EP_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t/* SSS6200 */\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI2_MFGPAGE_DEVID_SSS6200,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t/* Fury ~ 3004 and 3008 */\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3004,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3008,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t/* Invader ~ 3108 */\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3108_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3108_2,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3108_5,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI25_MFGPAGE_DEVID_SAS3108_6,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t/* Cutlass ~ 3216 and 3224 */\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3216,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3224,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t/* Intruder ~ 3316 and 3324 */\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3316_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3316_2,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3316_3,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3316_4,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3324_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3324_2,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3324_3,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3324_4,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t/* Ventura, Crusader, Harpoon & Tomcat ~ 3516, 3416, 3508 & 3408*/\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3508,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3508_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3408,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3516,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3516_1,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3416,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t/* Mercator ~ 3616*/\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_SAS3616,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\n\t/* Aero SI 0x00E1 Configurable Secure\n\t * 0x00E2 Hard Secure\n\t */\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_CFG_SEC_3916,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_HARD_SEC_3916,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\n\t/*\n\t *  Aero SI \u2013> 0x00E0 Invalid, 0x00E3 Tampered\n\t */\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_INVALID0_3916,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_INVALID1_3916,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\n\t/* Atlas PCIe Switch Management Port */\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_ATLAS_PCIe_SWITCH_DEVID,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\n\t/* Sea SI 0x00E5 Configurable Secure\n\t * 0x00E6 Hard Secure\n\t */\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_CFG_SEC_3816,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_HARD_SEC_3816,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\n\t/*\n\t *  Sea SI \u2013> 0x00E4 Invalid, 0x00E7 Tampered\n\t */\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_INVALID0_3816,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\t{ MPI2_MFGPAGE_VENDORID_LSI, MPI26_MFGPAGE_DEVID_INVALID1_3816,\n\t\tPCI_ANY_ID, PCI_ANY_ID },\n\n\t{0}     /* Terminating entry */\n};\nMODULE_DEVICE_TABLE(pci, mpt3sas_pci_table);\n\nstatic struct pci_error_handlers _mpt3sas_err_handler = {\n\t.error_detected\t= scsih_pci_error_detected,\n\t.mmio_enabled\t= scsih_pci_mmio_enabled,\n\t.slot_reset\t= scsih_pci_slot_reset,\n\t.resume\t\t= scsih_pci_resume,\n};\n\nstatic struct pci_driver mpt3sas_driver = {\n\t.name\t\t= MPT3SAS_DRIVER_NAME,\n\t.id_table\t= mpt3sas_pci_table,\n\t.probe\t\t= _scsih_probe,\n\t.remove\t\t= scsih_remove,\n\t.shutdown\t= scsih_shutdown,\n\t.err_handler\t= &_mpt3sas_err_handler,\n#ifdef CONFIG_PM\n\t.suspend\t= scsih_suspend,\n\t.resume\t\t= scsih_resume,\n#endif\n};\n\n/**\n * scsih_init - main entry point for this driver.\n *\n * Return: 0 success, anything else error.\n */\nstatic int\nscsih_init(void)\n{\n\tmpt2_ids = 0;\n\tmpt3_ids = 0;\n\n\tmpt3sas_base_initialize_callback_handler();\n\n\t /* queuecommand callback hander */\n\tscsi_io_cb_idx = mpt3sas_base_register_callback_handler(_scsih_io_done);\n\n\t/* task management callback handler */\n\ttm_cb_idx = mpt3sas_base_register_callback_handler(_scsih_tm_done);\n\n\t/* base internal commands callback handler */\n\tbase_cb_idx = mpt3sas_base_register_callback_handler(mpt3sas_base_done);\n\tport_enable_cb_idx = mpt3sas_base_register_callback_handler(\n\t    mpt3sas_port_enable_done);\n\n\t/* transport internal commands callback handler */\n\ttransport_cb_idx = mpt3sas_base_register_callback_handler(\n\t    mpt3sas_transport_done);\n\n\t/* scsih internal commands callback handler */\n\tscsih_cb_idx = mpt3sas_base_register_callback_handler(_scsih_done);\n\n\t/* configuration page API internal commands callback handler */\n\tconfig_cb_idx = mpt3sas_base_register_callback_handler(\n\t    mpt3sas_config_done);\n\n\t/* ctl module callback handler */\n\tctl_cb_idx = mpt3sas_base_register_callback_handler(mpt3sas_ctl_done);\n\n\ttm_tr_cb_idx = mpt3sas_base_register_callback_handler(\n\t    _scsih_tm_tr_complete);\n\n\ttm_tr_volume_cb_idx = mpt3sas_base_register_callback_handler(\n\t    _scsih_tm_volume_tr_complete);\n\n\ttm_sas_control_cb_idx = mpt3sas_base_register_callback_handler(\n\t    _scsih_sas_control_complete);\n\n\tmpt3sas_init_debugfs();\n\treturn 0;\n}\n\n/**\n * scsih_exit - exit point for this driver (when it is a module).\n *\n * Return: 0 success, anything else error.\n */\nstatic void\nscsih_exit(void)\n{\n\n\tmpt3sas_base_release_callback_handler(scsi_io_cb_idx);\n\tmpt3sas_base_release_callback_handler(tm_cb_idx);\n\tmpt3sas_base_release_callback_handler(base_cb_idx);\n\tmpt3sas_base_release_callback_handler(port_enable_cb_idx);\n\tmpt3sas_base_release_callback_handler(transport_cb_idx);\n\tmpt3sas_base_release_callback_handler(scsih_cb_idx);\n\tmpt3sas_base_release_callback_handler(config_cb_idx);\n\tmpt3sas_base_release_callback_handler(ctl_cb_idx);\n\n\tmpt3sas_base_release_callback_handler(tm_tr_cb_idx);\n\tmpt3sas_base_release_callback_handler(tm_tr_volume_cb_idx);\n\tmpt3sas_base_release_callback_handler(tm_sas_control_cb_idx);\n\n/* raid transport support */\n\tif (hbas_to_enumerate != 1)\n\t\traid_class_release(mpt3sas_raid_template);\n\tif (hbas_to_enumerate != 2)\n\t\traid_class_release(mpt2sas_raid_template);\n\tsas_release_transport(mpt3sas_transport_template);\n\tmpt3sas_exit_debugfs();\n}\n\n/**\n * _mpt3sas_init - main entry point for this driver.\n *\n * Return: 0 success, anything else error.\n */\nstatic int __init\n_mpt3sas_init(void)\n{\n\tint error;\n\n\tpr_info(\"%s version %s loaded\\n\", MPT3SAS_DRIVER_NAME,\n\t\t\t\t\tMPT3SAS_DRIVER_VERSION);\n\n\tmpt3sas_transport_template =\n\t    sas_attach_transport(&mpt3sas_transport_functions);\n\tif (!mpt3sas_transport_template)\n\t\treturn -ENODEV;\n\n\t/* No need attach mpt3sas raid functions template\n\t * if hbas_to_enumarate value is one.\n\t */\n\tif (hbas_to_enumerate != 1) {\n\t\tmpt3sas_raid_template =\n\t\t\t\traid_class_attach(&mpt3sas_raid_functions);\n\t\tif (!mpt3sas_raid_template) {\n\t\t\tsas_release_transport(mpt3sas_transport_template);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t/* No need to attach mpt2sas raid functions template\n\t * if hbas_to_enumarate value is two\n\t */\n\tif (hbas_to_enumerate != 2) {\n\t\tmpt2sas_raid_template =\n\t\t\t\traid_class_attach(&mpt2sas_raid_functions);\n\t\tif (!mpt2sas_raid_template) {\n\t\t\tsas_release_transport(mpt3sas_transport_template);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\terror = scsih_init();\n\tif (error) {\n\t\tscsih_exit();\n\t\treturn error;\n\t}\n\n\tmpt3sas_ctl_init(hbas_to_enumerate);\n\n\terror = pci_register_driver(&mpt3sas_driver);\n\tif (error)\n\t\tscsih_exit();\n\n\treturn error;\n}\n\n/**\n * _mpt3sas_exit - exit point for this driver (when it is a module).\n *\n */\nstatic void __exit\n_mpt3sas_exit(void)\n{\n\tpr_info(\"mpt3sas version %s unloading\\n\",\n\t\t\t\tMPT3SAS_DRIVER_VERSION);\n\n\tmpt3sas_ctl_exit(hbas_to_enumerate);\n\n\tpci_unregister_driver(&mpt3sas_driver);\n\n\tscsih_exit();\n}\n\nmodule_init(_mpt3sas_init);\nmodule_exit(_mpt3sas_exit);\n"}}, "reports": [{"events": [{"location": {"col": 42, "file": 0, "line": 410}, "message": "ERROR: function mpt3sas_get_port_by_id called on line 7115 inside lock on line 7113 but uses GFP_KERNEL"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/mpt3sas/mpt3sas_scsih.c", "reportHash": "d98d9c566f32d663a5c97a18444c9a1a", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 0, "line": 410}, "message": "ERROR: function mpt3sas_get_port_by_id called on line 6832 inside lock on line 6829 but uses GFP_KERNEL"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/mpt3sas/mpt3sas_scsih.c", "reportHash": "4a01dcaaf78457c1338a78326cb7ea83", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 0, "line": 410}, "message": "ERROR: function mpt3sas_get_port_by_id called on line 6844 inside lock on line 6841 but uses GFP_KERNEL"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/mpt3sas/mpt3sas_scsih.c", "reportHash": "aaa654b0a60693ab0826ecdc835e53e7", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 0, "line": 410}, "message": "ERROR: function mpt3sas_get_port_by_id called on line 7696 inside lock on line 7692 but uses GFP_KERNEL"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/mpt3sas/mpt3sas_scsih.c", "reportHash": "d5ef64067a55e780b6c33f968bb8f0bc", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 0, "line": 410}, "message": "ERROR: function mpt3sas_get_port_by_id called on line 10250 inside lock on line 10246 but uses GFP_KERNEL"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/mpt3sas/mpt3sas_scsih.c", "reportHash": "b995bb30df31507c556f7a32ecfc04ea", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
